# 附录 E. 带特殊含义的退出代码

> 原文：[`tldp.org/LDP/abs/html/exitcodes.html`](https://tldp.org/LDP/abs/html/exitcodes.html)

**表 E-1\. *保留* 退出代码**

| 退出代码编号 | 含义 | 示例 | 备注 |
| --- | --- | --- | --- |
| `1` | 通用错误的通配符 | let "var1 = 1/0" | 各种错误，如 "除以零" 和其他不允许的操作 |
| `2` | 对 shell 内置命令的误用（根据 Bash 文档） | empty_function() {} | 缺少关键字 或命令，或权限问题（以及 *diff* 在失败的二进制文件比较中的返回代码）。 |
| `126` | 调用的命令无法执行 | /dev/null | 权限问题或命令不是可执行文件 |
| `127` | "命令未找到" | illegal_command | 可能是 `$PATH` 问题或拼写错误 |
| `128` | 向 exit 传递无效参数 | exit 3.14159 | **exit** 只接受 0 - 255 范围内的整数参数（见第一脚注） |
| `128+n` | 致命错误信号 "n" | *kill -9* `$PPID` of script | `**$?**` 返回 137 (128 + 9) |
| `130` | 脚本被 Control-C 终止 | *Ctl-C* | Control-C 是致命错误信号 2，(130 = 128 + 2，见上文) |
| `255*` | 退出状态超出范围 | exit -1 | **exit** 只接受 0 - 255 范围内的整数参数 |

根据上述表格，退出代码 1 - 2、126 - 165 和 255 [[1]](#FTN.AEN23629) 具有特殊含义，因此应避免用于用户指定的退出参数。以 *exit 127* 结束脚本在故障排除时可能会造成混淆（错误代码是 "命令未找到" 还是用户定义的？）。然而，许多脚本使用 *exit 1* 作为一般错误退出。由于退出代码 1 表示许多可能的错误，它对调试并不特别有用。

已尝试系统化退出状态编号（见 `/usr/include/sysexits.h`），但这主要是针对 C 和 C++ 程序员的。可能需要一个适用于脚本的类似标准。本文档的作者建议将用户定义的退出代码限制在 64 - 113 范围内（除了 0，表示成功），以符合 C/C++ 标准。这将分配 50 个有效代码，并使脚本的故障排除更加直接。[[2]](#FTN.AEN23647) 本文档附带的所有示例中的用户定义退出代码都符合此标准，除非存在特殊情况，如 示例 9-2。 

| ![注意](img/068cd6dc5ba56f1437f9ae6e0cb52ede.png) | 在 shell 脚本退出后从命令行发出 $? 只在 Bash 或 *sh* 提示符下给出与上表一致的结果。运行 *C-shell* 或 *tcsh* 在某些情况下可能会给出不同的值。 |
| --- | --- |

### 备注

| [[1]](exitcodes.html#AEN23629) | 超出范围的退出值可能导致意外的退出代码。大于 255 的退出值返回一个 模 256 的退出代码。例如，*exit 3809* 将给出一个退出代码 225（3809 % 256 = 225）。 |
| --- | --- |
| [[2]](exitcodes.html#AEN23647) | `/usr/include/sysexits.h` 的更新分配了之前未使用的退出代码 64 - 78。预计未来未分配的退出代码范围将进一步受限。本文件的作者将 *不会* 对脚本示例进行修复以符合不断变化的标准。这不应该引起任何问题，因为编译后的 C/C++ 二进制文件和 shell 脚本在退出代码的使用上没有重叠或冲突。 |
