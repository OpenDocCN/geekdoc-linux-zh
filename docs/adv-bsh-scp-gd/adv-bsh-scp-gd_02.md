# 第一章：Shell 编程！

> 原文：[`tldp.org/LDP/abs/html/why-shell.html`](https://tldp.org/LDP/abs/html/why-shell.html)

|  **没有一种编程语言是完美的。甚至没有一种最佳语言；只有适合或可能不适合特定目的的语言。**

*--Herbert Mayer**  |

掌握 shell 脚本是希望成为系统管理员的人必备的技能，即使他们不打算实际编写脚本。考虑一下，当 Linux 机器启动时，它会执行`/etc/rc.d`中的 shell 脚本以恢复系统配置并设置服务。对这些启动脚本有详细的理解对于分析系统的行为以及可能对其进行修改非常重要。

脚本制作工艺不难掌握，因为脚本可以分块构建，而且只需要学习一小套 shell 特定的操作符和选项 [[1]](#FTN.AEN62)。语法简单——甚至简朴——类似于在命令行中调用和链接实用程序，而且只有少数“规则”规范了它们的使用。大多数简短脚本第一次就能正常工作，即使是较长的脚本调试也很直接。

> 在个人计算机的早期阶段，BASIC 语言使
> 
> 任何具备一定计算机技能的人都能编写程序。
> 
> 微型计算机的生成。几十年后，Bash 脚本
> 
> 语言使任何具备基本 Linux 知识的人都能编写程序。
> 
> UNIX 在现代机器上做同样的事情。
> 
> 我们现在有了微型单板计算机，这些设备令人惊叹。
> 
> 功能，例如[树莓派](http://www.raspberrypi.org/)。
> 
> Bash 脚本提供了一种探索这些功能的方法。
> 
> 令人着迷的设备。

Shell 脚本是一种快速且粗糙的复杂应用程序原型设计方法。在脚本中实现功能的一个有限子集通常是项目开发的有用第一阶段。通过这种方式，可以测试和调整应用程序的结构，并在最终用*C*、*C++*、*Java*、Perl 或*Python*进行编码之前发现主要陷阱。

Shell 脚本回溯到经典的 UNIX 哲学，即将复杂项目分解成更简单的子任务，将组件和实用程序链接在一起。许多人认为，这种方法比使用新一代全能型高能语言（如*Perl*）解决问题更好，或者至少更令人愉悦，全能型语言试图满足所有人的需求，但代价是迫使你改变思维方式以适应工具。

根据 Herbert Mayer 的说法，“一个有用的语言需要数组、指针以及构建数据结构的通用机制。”根据这些标准，shell 脚本在“有用”方面略有不足。或者，也许不是……

|

不应使用 shell 脚本的情况

+   资源密集型任务，尤其是速度是关键因素时（排序、散列、递归 [[2]](#FTN.AEN87) ...）

+   涉及大量数学运算的过程，尤其是浮点运算、任意精度计算或复数运算（建议使用 *C++* 或 *FORTRAN*）

+   需要跨平台可移植性（建议使用 *C* 或 *Java*）

+   复杂的应用程序，其中结构化编程是必需的（变量类型检查、函数原型等）

+   对于公司未来至关重要的任务

+   在 *安全* 至关重要的情况下，需要保证系统的完整性并防止入侵、破解和破坏

+   项目由相互依赖的子组件组成

+   需要大量文件操作（*Bash* 仅限于串行文件访问，而且方式特别笨拙且效率低下。）

+   需要原生支持多维数组

+   需要数据结构，例如链表或树

+   需要生成或操作图形或 GUI

+   需要直接访问系统硬件或外部外围设备

+   需要端口或 套接字 I/O

+   需要使用库或与旧代码接口

+   专有、闭源应用程序（Shell 脚本将源代码公之于众，供全世界查看。）

如果上述任何一点适用，考虑使用更强大的脚本语言——可能是 *Perl*、*Tcl*、*Python*、*Ruby*——或者可能是编译语言，如 *C*、*C++* 或 *Java*。即便如此，将应用程序作为 shell 脚本进行原型设计可能仍然是一个有用的开发步骤。

|

我们将使用 Bash，这是“Bourne-Again shell”的缩写 [[3]](#FTN.AEN139)，也是对斯蒂芬·鲍恩的经典 *Bourne* shell 的双关语。Bash 已成为大多数 UNIX 版本上 shell 脚本编写的 *de facto* 标准。本书涵盖的大部分原则同样适用于使用其他 shell 脚本，例如 Bash 的来源之一 *Korn Shell*，以及 *C Shell* 和其变体。（请注意，由于某些固有的问题，*C Shell* 编程不建议使用，正如汤姆·克里斯蒂安森在 1993 年 10 月的一篇 [Usenet 帖子](http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/) 中所指出的。）

下文是一个关于 shell 脚本编写的教程。它大量依赖于示例来展示 shell 的各种功能。示例脚本是可以工作的——它们尽可能进行了测试——其中一些在实际生活中甚至很有用。读者可以在源存档中实际操作示例的代码（`scriptname.sh` 或 `scriptname.bash`），[[5]](#FTN.AEN157) 给它们执行权限（`**chmod u+rx scriptname**`），然后运行它们看看会发生什么。如果 [源存档](http://bash.deta.in/abs-guide-latest.tar.bz2) 不可用，则从 [HTML](http://www.tldp.org/LDP/abs/abs-guide.html.tar.gz) 或 [pdf](http://bash.deta.in/abs-guide.pdf) 渲染版本中剪切粘贴。请注意，这里展示的一些脚本在解释之前就引入了功能，这可能要求读者暂时跳读以获得启示。|

除非另有说明，本书的 作者 编写了以下示例脚本。

|   |  **他的面容大胆而坚定。**

*--埃德蒙·斯宾塞**  |

### **注意**

| [[1]](why-shell.html#AEN62) | 这些被称为 内置命令，是 shell 内部的功能。 |
| --- | --- |
| [[2]](why-shell.html#AEN87) | 虽然在 shell 脚本中 递归是可能的，但它通常运行缓慢，其实现通常是 丑陋的修补。 |
| [[3]](why-shell.html#AEN139) | 一个 *首字母缩略词* 是通过将单词的首字母粘贴在一起形成一个令人舌头打结的短语而形成的 *替代词*。这种道德败坏且有害的做法应受到适当的严厉惩罚。公开鞭打似乎是一个合适的选择。 |
| [[4]](why-shell.html#AEN147) | 许多 *ksh88* 的功能，甚至一些来自更新版的 *ksh93* 的功能，已经被合并到 Bash 中。 |
| [[5]](why-shell.html#AEN157) | 按照惯例，符合 Bourne shell 的用户编写的 shell 脚本通常以 `.sh` 扩展名命名。例如 `/etc/rc.d` 中的系统脚本不一定遵循这种命名法。 |
