# 第二十六章\. 列表构造

> 原文：[`tldp.org/LDP/abs/html/list-cons.html`](https://tldp.org/LDP/abs/html/list-cons.html)

*和列表* 和 *或列表* 构造提供了一种连续处理多个命令的方法。这些可以有效地替换复杂的嵌套 if/then 或甚至 case 语句。

**链式命令**

和列表

```sh
command-1 && command-2 && command-3 && ... command-n
```

在前一个命令返回值为 `*true*`（零）的情况下，每个命令依次执行。在第一次返回 `*false*`（非零）时，命令链终止（返回 `*false*` 的第一个命令是最后执行的）。

一个有趣的用法是来自 YongYe 的 [Tetris 游戏脚本](http://bash.deta.in/Tetris_Game.sh) 早期版本的二条件 *和列表*：

```sh
equation()

{  # core algorithm used for doubling and halving the coordinates
   [[ ${cdx} ]] && ((y=cy+(ccy-cdy)${2}2))
   eval ${1}+=\"${x} ${y} \"
}
```

**示例 26-1\. 使用 *和列表* 测试命令行参数**

```sh
#!/bin/bash
# and list

if [ ! -z "$1" ] && echo "Argument #1 = $1" && [ ! -z "$2" ] && \
#                ^^                         ^^               ^^
echo "Argument #2 = $2"
then
  echo "At least 2 arguments passed to script."
  # All the chained commands return true.
else
  echo "Fewer than 2 arguments passed to script."
  # At least one of the chained commands returns false.
fi  
# Note that "if [ ! -z $1 ]" works, but its alleged equivalent,
#   "if [ -n $1 ]" does not.
#     However, quoting fixes this.
#  if "[ -n "$1" ]" works.
#           ^  ^    Careful!
# It is always best to QUOTE the variables being tested.

# This accomplishes the same thing, using "pure" if/then statements.
if [ ! -z "$1" ]
then
  echo "Argument #1 = $1"
fi
if [ ! -z "$2" ]
then
  echo "Argument #2 = $2"
  echo "At least 2 arguments passed to script."
else
  echo "Fewer than 2 arguments passed to script."
fi
# It's longer and more ponderous than using an "and list".

exit $?
```

**示例 26-2\. 使用 *和列表* 进行另一个命令行参数测试**

```sh
#!/bin/bash

ARGS=1        # Number of arguments expected.
E_BADARGS=85  # Exit value if incorrect number of args passed.

test $# -ne $ARGS && \
#    ^^^^^^^^^^^^ condition #1
echo "Usage: `basename $0` $ARGS argument(s)" && exit $E_BADARGS
#                                             ^^
#  If condition #1 tests true (wrong number of args passed to script),
#+ then the rest of the line executes, and script terminates.

# Line below executes only if the above test fails.
echo "Correct number of arguments passed to this script."

exit 0

# To check exit value, do a "echo $?" after script termination.
```

当然，*和列表* 也可以 *设置* 变量的默认值。

```sh
arg1=$@ && [ -z "$arg1" ] && arg1=DEFAULT

              # Set $arg1 to command-line arguments, if any.
              # But . . . set to DEFAULT if not specified on command-line.
```

或列表

```sh
command-1 &#124;&#124; command-2 &#124;&#124; command-3 &#124;&#124; ... command-n
```

在前一个命令返回 false 的情况下，每个命令依次执行。在第一次返回 true 时，命令链终止（返回 true 的第一个命令是最后执行的）。这显然是 "和列表" 的逆。

**示例 26-3\. 使用 *或列表* 与 *和列表* 结合**

```sh
#!/bin/bash

#  delete.sh, a not-so-cunning file deletion utility.
#  Usage: delete filename

E_BADARGS=85

if [ -z "$1" ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS  # No arg? Bail out.
else  
  file=$1          # Set filename.
fi  

[ ! -f "$file" ] && echo "File \"$file\" not found. \
Cowardly refusing to delete a nonexistent file."
# AND LIST, to give error message if file not present.
# Note echo message continuing on to a second line after an escape.

[ ! -f "$file" ] &#124;&#124; (rm -f $file; echo "File \"$file\" deleted.")
# OR LIST, to delete file if present.

# Note logic inversion above.
# AND LIST executes on true, OR LIST on false.

exit $?
```
| ![注意](img/05aa79b283e0d53b5a94a522ee0b6cfe.png) | 如果 *或列表* 中的第一个命令返回 true，它 `*将*` 执行。 |
```sh
# ==> The following snippets from the /etc/rc.d/init.d/single
#+==> script by Miquel van Smoorenburg
#+==> illustrate use of "and" and "or" lists.
# ==> "Arrowed" comments added by document author.

[ -x /usr/bin/clear ] && /usr/bin/clear
  # ==> If /usr/bin/clear exists, then invoke it.
  # ==> Checking for the existence of a command before calling it
  #+==> avoids error messages and other awkward consequences.

  # ==> . . .

# If they want to run something in single user mode, might as well run it...
for i in /etc/rc1.d/S[0-9][0-9]* ; do
        # Check if the script is there.
        [ -x "$i" ] &#124;&#124; continue
  # ==> If corresponding file in $PWD *not* found,
  #+==> then "continue" by jumping to the top of the loop.

        # Reject backup files and files generated by rpm.
        case "$1" in
                *.rpmsave&#124;*.rpmorig&#124;*.rpmnew&#124;*~&#124;*.orig)
                        continue;;
        esac
        [ "$i" = "/etc/rc1.d/S00single" ] && continue
  # ==> Set script name, but don't execute it yet.
        $i start
done

  # ==> . . .
```  |
| ![重要](img/d8e2c61a4ebc25a8846b6825b6029167.png) | `**和列表**` 或 `**或列表**` 的退出状态是最后执行的命令的退出状态。 |

可能的组合 *和* 和 *或* 列表是可能的，但逻辑可能很容易变得复杂，需要密切注意运算符优先级规则，并且可能需要进行大量的调试。

```sh
false && true &#124;&#124; echo false         # false

# Same result as
( false && true ) &#124;&#124; echo false     # false
# But NOT
false && ( true &#124;&#124; echo false )     # (nothing echoed)

#  Note left-to-right grouping and evaluation of statements.

#  It's usually best to avoid such complexities.

#  Thanks, S.C.
```

请参阅 示例 A-7 和 示例 7-4 以了解使用 `**和/或列表**` 构造测试变量的示例。
