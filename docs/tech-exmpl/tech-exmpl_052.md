# 数据库中的强一致性意味着什么

> 原文：[`techbyexample.com/strong-consistency-databases/`](https://techbyexample.com/strong-consistency-databases/)

目录

+   概述

+   强一致性的公式

    +   节点或副本的数量

    +   写法定人数

    +   读取法定人数

+   节点数量为 1

+   节点数量为 2

    +   写法定人数为 2，读法定人数为 1

    +   写法定人数为 1，读法定人数为 2

    +   写法定人数为 2，读法定人数为 2

    +   写法定人数为 1，读法定人数为 1

+   节点数量为 3

    +   写法定人数为 2，读法定人数为 2

    +   写法定人数为 2，读法定人数为 1

    +   写法定人数为 1，读法定人数为 2

+   强一致性的缺点

    +   一致性是如何实现的

    +   可用性是如何实现的

+   何时需要强一致性？

## **概述**

简单来说，如果一个系统在读取时总是获取最新的写入数据，那么它就是强一致的。它永远不会返回过时或陈旧的值。根据维基百科，强一致性的定义是：

**如果协议支持强一致性，则意味着：所有访问都按相同顺序（顺序）由所有并行进程（或节点、处理器等）看到。因此，只有一个一致的状态可以被观察到，而与弱一致性不同，弱一致性下不同的并行进程（或节点等）可能会在不同的状态下感知变量。**

## **强一致性的公式**

要理解数据库中的强一致性，我们首先需要理解三个术语：

+   节点或副本的数量

+   写法定人数

+   阅读法定人数

### **节点或副本的数量**

这是你系统中存在的节点数量。当我们说节点时，实际上是指具有相同数据的副本数量

### **写法定人数**

它是发生写入并被视为成功返回的最小节点数。

### **读取法定值**

它是发生读取并被视为成功返回的最小节点数。如果这些最小节点返回的值不同，则该读取将被拒绝

从数学上讲，如果**写入法定值**和**读取法定值**的和大于读取节点的数量，那么系统被认为是强一致的。

也就是说，如果写入法定值为 W，读取法定值为 R，节点数量为 N，则

+   如果 W+R > N，则系统是强一致的

+   如果 W+R<=N，则系统不能保证强一致性

换句话说，如果写入法定值节点和读取法定值节点之间有一个公共节点，那么系统将是强一致的。这个公共节点将拒绝过时的读取。每当 W+R > N 时，写入法定值和读取法定值之间总会有一个公共节点。要理解这一点在数学上并不困难。

让我们通过一些示例来看一下这个公式是如何成立的。我们将看到以下几种情况。

+   节点数量为 1

+   节点数量为 2

+   节点数量为 3

## **节点数量为 1**

在这种情况下，唯一可能的写入和读取法定值组合是 1 和 1。写入法定值和读取法定值的和大于读取节点的数量。由于只有一个实例，因此读取总是最新的，因为读取和写入发生在同一个实例上

## **节点数量为 2**

在此，还有四种情况。

+   写入法定值为 2，读取法定值为 1 – **强一致**

+   写入法定值为 1，读取法定值为 2 – **强一致**

+   写入法定值为 2，读取法定值为 2 – **强一致**

+   写入法定值为 1，读取法定值为 1 – **非强一致**

### **写入法定值为 2，读取法定值为 1**

在这种情况下，写入法定值和读取法定值的和为 3，大于节点的数量，因此系统应当是强一致的。在这种情况下，由于写入发生在两个节点上，因此从任意一个节点读取都会返回相同的数据，系统整体上将是强一致的

### **写入法定值为 1，读取法定值为 2**

再次，在这种情况下，写入仲裁数和读取仲裁数的总和为 3，超过了节点数量，因此系统应保持强一致性。在这种情况下，写入仅发生在一个实例上。但读取发生在两个节点上。假设有一个名为 A 的数据，其初始值为 1。两个节点的 A 值都是 1。现在在第一个节点上进行了写入，A 的值被更改为 2。由于写入仲裁数为 1，写入将在第一个节点上进行并成功返回。假设在节点 2 与节点 1 的最新数据同步之前，发生了读取操作。由于读取仲裁数为 2，它将从两个节点读取。第一个节点将返回 A 的值为 2，而第二个节点将返回 A 的值为 1。由于两个节点返回的值不同，系统将拒绝该读取操作以保持强一致性。

### **写入仲裁数为 2，读取仲裁数为 2**

再次，在这种情况下，写入仲裁数和读取仲裁数的总和为 4，超过了节点数量，因此系统应保持强一致性。在这种情况下，由于写入发生在两个节点上且读取也来自两个节点，因此每次读取将是最新的。

### **写入仲裁数为 1，读取仲裁数为 1**

再次，在这种情况下，写入仲裁数和读取仲裁数的总和为 2，等于节点数量，因此系统不是强一致的。写入发生在节点 1 上，在数据同步到节点 2 之前，节点 2 上发生了读取操作。这是过时的数据。

## **节点数量为 3**

在这种情况下，可以有多种情况，但我们只讨论其中几种。

+   写入仲裁数为 2，读取仲裁数为 2 – **强一致性**

+   写入仲裁数为 2，读取仲裁数为 1 – **非强一致性**

+   写入仲裁数为 1，读取仲裁数为 2 – **非强一致性**

### **写入仲裁数为 2，读取仲裁数为 2**

在这种情况下，写入仲裁数和读取仲裁数的总和为 4，超过了节点数量，因此系统应保持强一致性。假设有三个节点：**节点 1**、**节点 2** 和 **节点 3**。

再假设一个情况，其中名为 A 的数据的初始值为 1。对节点 1 和节点 2 进行了写入操作，A 的值增加至 2。在数据同步到节点 3 之前，发生了读取操作。对于读取，可能会有三种情况。

+   读取来自节点 1 和节点 2

+   读取来自节点 1 和节点 3

+   读取来自节点 2 和节点 3

**a. 读取来自节点 1 和节点 2**

在这种情况下，没有问题，A 的值将在两个节点中均返回为 2，系统将保持强一致性。

**b. 读取来自节点 1 和节点 3**

在这种情况下，节点 1 将返回值 2，而节点 3 将返回值 A 为 1。由于这两个值不同，读取将被拒绝，系统将保持强一致性。

**c. 读取来自节点 2 和节点 3**

在这种情况下，节点 2 将返回值为 2，而节点 3 将返回值为 1。由于这两个值不同，读取将被拒绝，系统将保持强一致性。

### **写入仲裁数为 2，读取仲裁数为 1**

在这种情况下，写入仲裁数和读取仲裁数的总和为 3，而该总和不大于系统中的节点数，因此系统不应该保持强一致性。

写入发生在节点 1 和节点 2，A 的值更新为 2。读取发生在节点 3，返回的值为 1，使得系统既不保持强一致性也不保持弱一致性。

### **写入仲裁数为 1，读取仲裁数为 2**

写入发生在节点 1，A 的值更新为 2。读取发生在节点 2 和节点 3，两个节点都返回 A 的值为 1。由于返回值相同，读取没有被拒绝，系统不保持强一致性。

## **强一致性的缺点**

只有在网络分区的情况下，才能以牺牲可用性为代价实现强一致性。这也是 CAP 定理的内容。CAP 定理指出，在分布式系统中，你只能实现以下三种属性中的两种：

+   一致性

+   可用性

+   分区容错

实际上，很难实现分区容错，因为网络注定会失败，节点之间的通信注定会中断。这也是为什么在一个不具备分区容错的分布式系统中，只能实现一致性或可用性中的一种。

让我们举个例子来理解为什么必须牺牲其中之一。假设系统中有两个节点，它们相互连接，并且都处于同步状态。

现在假设两个节点之间发生了网络分区。

### **如何实现一致性**

这里节点数为 2。因此，为了实现强一致性，我们有三种选择。

+   写入仲裁数为 2，读取仲裁数为 1。

+   写入仲裁数为 1，读取仲裁数为 2。

+   写入仲裁数为 2，读取仲裁数为 2。

在第一种情况下，由于写入仲裁数是 2，因此必须同时写入两个节点。但由于第二个节点不可用，因此它将拒绝写入操作。因此，系统无法进行写入。

在第二种情况下，由于读取仲裁数是 2，因此必须从两个节点读取。但由于第二个节点不可用，因此它将拒绝读取操作。因此，系统无法进行读取。

在第三种情况下，由于写入仲裁数是 2，因此必须同时写入两个节点，而由于读取仲裁数是 2，因此必须同时从两个节点读取。但由于第二个节点不可用，因此它将拒绝读写请求。因此，系统无法进行读写操作。

从这三个案例中，你可以推断出，在网络分区的情况下，我们以牺牲可用性为代价来实现强一致性，而网络分区是不可避免的。

### **如何实现可用性**

为了实现可用性，我们必须放弃一致性。这里节点数为 2。因此，有一个选项使得系统不会强一致。

+   写入法定人数是 1，读取法定人数是 1

在第一个例子中，由于写入法定人数（Write Quorum）为 1，因此它可以写入节点 1。并且读取法定人数（Read Quorum）也是 1，因此它可以从节点 1 读取。因此，系统是可用的。写入法定人数和读取法定人数之和为 2，这等于节点数。根据公式，当写入法定人数和读取法定人数之和小于或等于节点数时，系统就不是强一致的。因此，在这种情况下，我们有可用性，但系统不一致。

## **何时强一致性是可取的？**

有一些使用场景需要强一致性。例如，在银行交易的情况下，每次读取时都希望得到最新的值。

这就是关于**数据库中的强一致性**。希望你喜欢这篇文章。

**注意：** 另外，查看我们的系统设计教程系列 – [系统设计教程系列](https://techbyexample.com/system-design-questions/)
