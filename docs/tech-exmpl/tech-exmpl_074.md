# 理解 Base64 编码/解码

> 原文：[`techbyexample.com/understanding-base64-encoding-decoding/`](https://techbyexample.com/understanding-base64-encoding-decoding/)

# **概述**

Base64 也称为 Base64 内容传输编码。Base64 是将二进制数据编码为 ASCII 文本。但是它只使用 64 个字符和一个填充字符，这些字符在大多数字符集中都有。因此，它是一种仅使用可打印字符表示二进制数据的方式。这些可打印字符包括：

+   小写字母 **a-z**

+   大写字母 **A-Z**

+   数字 **0-9**

+   字符 **+** 和 **/**

+   **=** 被用作填充字符

Base64 编码用于通过不正确处理二进制数据的媒介传输数据。因此，进行 Base64 编码是为了确保数据在通过这种媒介传输时保持完整，不被修改。Base64 编码后的数据如下所示：

```go
OWRjNGJjMDY5MzVmNGViMGExZTdkMzNjOGMwZTI3ZWI==
```

# **为什么需要 Base64 编码**

让我们谈谈历史，了解为什么需要 Base64。最初，当邮件系统开始时，只有文本可以通过电子邮件传输。后来，电子邮件开始支持附件，包括视频和音频。视频和音频是二进制数据，当二进制数据通过互联网传输时，很有可能发生损坏。那么问题是，为什么会这样？一些媒介如电子邮件只支持文本数据，它们仅用于流式传输文本，因此这些协议可能会将你的二进制数据解释为控制字符，或者某些特殊字符在二进制数据中可能会被不同地解释。二进制数据的问题在于，二进制数据中的某些字符在某些媒介中可能具有特殊含义。换句话说，这些媒介不是 8 位干净的，只能处理文本数据。

所以，Base64 是为不支持二进制数据并且仅处理文本字符的媒介设计的。因为可以保证数据不会被损坏，所以它主要用于仅支持 ASCII 数据的遗留系统。

但为什么是 64 个字符，而不是更多呢？这 64 个字符在大多数字符集中都有，因此你可以合理地相信，数据在传输到另一端时不会被损坏。

请注意，这是编码而不是加密。编码和加密有什么区别？

**编码**

编码意味着将数据转换为另一种格式，以便系统能够正确地处理这种转换后的格式。编码只是一个公开的算法，没有涉及密钥，并且是可逆的。因此，任何知道该算法的人都可以简单地反转并获取原始数据。现在的问题是，为什么需要它？某些传输媒介只理解文本数据或某些字符数量。你的二进制数据无法通过这种媒介传输，因为有数据损坏的风险。

编码不提供任何安全性，而仅仅是为了在理解不同格式的不同介质之间的兼容性

**加密**

加密是为了保密。它总是通过密钥保护，只有知道密钥的人才能解密。因此，在加密的情况下，数据只能由持有密钥的人逆向解码。

例如，通过网络发送密码。在这种情况下，我们加密密码，以便任何未授权的人无法读取它。例如 HTTPS

所以从本质上讲，编码是为了兼容性，而不是为了加密。

# **Base64 编码/解码的工作原理**

Base64 编码在 [`tools.ietf.org/html/rfc4648`](https://tools.ietf.org/html/rfc4648) 中有描述

Base64 编码将把每 3 个字节的数据转换成 4 个编码字符。它将从左到右开始扫描，然后选择前 3 个字节的数据，表示 3 个字符。这 3 个字节将是 24 位。现在它将把这 24 位分成 4 部分，每部分 6 位。然后，每个 6 位组将在下面的表格中索引，以获取映射的字符。

```go
 Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (pad) =
        15 P            32 g            49 x
        16 Q            33 h            50 y
```

让我们通过一个例子来理解。假设我们有以下字符串

```go
ab@
```

上述字符串的位表示为

```go
 a          b        @
01100001  01100010  01000000
```

这 24 个位将被分成 4 组，每组 6 位

```go
011000 010110 001001 000000
```

上述位的数字表示为

```go
 24    22     9      0
011000 010110 001001 000000
```

使用上述数字索引到 base64 表格。以下是映射结果

| 24 | Y |
| --- | --- |
| 22 | W |
| 9 | J |
| 0 | A |

所以 base64 编码后的字符串将是

```go
YWJA
```

如果输入字符串不是 3 的倍数怎么办？在这种情况下，填充字符 **=** 将会出现

假设输入字符串有 4 个字符

```go
ab@c
```

上述字符串的位表示为

```go
 a          b        @        c
01100001  01100010  01000000 01100011
```

前三个字节将被组合在一起。最后的字节将用 4 个额外的零进行填充，以使得整体的位数能被 6 整除。

```go
011000 010110 001001 000000 011000 110000
  24     22     9      0      24     48
```

使用上述数字索引到上面的表格。以下是映射结果

| 24 | Y |
| --- | --- |
| 22 | W |
| 9 | J |
| 0 | A |
| 24 | Y |
| 48 | w |

这将变为

```go
YWJAYw==
```

每两个额外的零由 = 字符表示。由于我们添加了 4 个额外的零，因此末尾有两个 =。

现在让我们看看另一个例子，其中输入字符串有 5 个字符

```go
ab@cd
```

上述字符串的位表示为

```go
 a          b        @        c       d
01100001  01100010  01000000 01100011 01100100
```

前三个字节将被组合在一起。最后两个字节将组合在一起，并用 2 个额外的零进行填充，以使得整体的位数能被 6 整除。

```go
011000 010110 001001 000000 011000 110110 010000
  24     22     9      0      24     54     16
```

使用上述数字索引到上面的表格。以下是映射结果

| 24 | Y |
| --- | --- |
| 22 | W |
| 9 | J |
| 0 | A |
| 24 | Y |
| 54 | 2 |
| 16 | Q |

这将变为

```go
YWJAY2Q=
```

每两个额外的零由 = 字符表示。由于我们添加了 2 个额外的零，因此末尾有一个 =。另外，请注意，每个带有填充的 base64 编码字符串长度是四的倍数

| **实际字符串** | **Base64** **编码** **字符串** | **长度** |
| --- | --- | --- |
| ab@ | YWJA | 4 |
| ab@c | YWJAYw== | 8 |
| ab@cd | YWJAY2Q= | 8 |

对于编码，我们只有我们上面讨论的三种情况

+   输入字符串的位数能被 6 整除。无需添加填充。例如 ab@

+   输入字符串的位数不能被 6 整除，余数为 4\. 将添加两个 == 填充。例如 ab@c

+   输入的位数不能被 6 整除，余数为 2\. 将添加一个 = 填充。例如 ab@cd

现在浮现的问题是，填充是否必要？答案是，这取决于情况。我们将在查看了解码过程后讨论这一点。

# **Base64 解码**

现在让我们将 base64 编码的字符串解码回原始字符串。解码是编码的反向过程。我们以这个例子为例

```go
YWJAY2Q=
```

将其分成多个 4 字符一组。

```go
YWJA 
```

和

```go
Y2Q=
```

现在从每组中去掉结尾的 = 字符。对于剩余的字符串，将其转换为上述表格中对应的位表示。

```go
 Y      W       J      A     
011000 010110 001001 000000
```

和

```go
 Y      2      Q
011000 110110 010000
```

现在将其分成 8 位一组。保留结尾的零。这是为了处理添加的结尾 =。结尾的零将是 00 或 0000。

```go
01100001  01100010  01000000 
```

和

```go
01100011 01100100
```

现在对每个字节，按照 ASCII 表分配相应的字符

```go
 01100001  01100010  01000000
   a          b        @ 
```

和

```go
01100011 01100100
  c       d
```

因此，最终的字符串将是

```go
ab@cd
```

为什么我们要将 Base64 编码的字符串分成 4 个字符一组进行解码？原因是填充，下一节会解释清楚。

# **填充是否必要**

你可能会好奇，base64 编码是否必须使用 = 填充，因为我们在解码时直接丢弃了填充。答案是，这取决于情况

+   发送单一字符串时，填充并不必要。

+   当你拼接多个字符串的 base64 编码时，填充非常重要。如果拼接的是没有填充的字符串，那么原始字符串就无法恢复，因为有关添加字节的信息会丢失。举个例子，见下文

| **实际字符串** | **带填充的 Base64 编码** | **不带填充的 Base64 编码** |
| --- | --- | --- |
| a | YQ== | YQ |
| bc | YmM= | YmM |
| def | ZGVm | ZGVm |

现在让我们考虑这两种情况。

**当拼接不带填充的数据发送时**

在这种情况下，拼接后的 Base64 字符串将是

```go
YQYmMZGVm
```

尝试解码它，你会得到如下的最终字符串，但它是错误的

```go
a&1
```

**当拼接带有填充的数据发送时**

在这种情况下，拼接后的 Base64 字符串将是

```go
YQ==YmM=ZGVm
```

尝试按 4 个字符一组进行解码，你会得到如下正确的最终字符串

```go
abcdef
```

现在，脑海中再次浮现的问题是，为什么需要拼接多个 base64 编码的字符串？答案是在处理流式数据时，如果你希望在数据到达时直接发送 base64 编码数据，拼接是非常有用的。例如，视频缓冲。

所以这就是为什么填充是被鼓励的，尽管在所有情况下并不是绝对必要的。

# **大小**

由于 Base64 本质上将 3 个字节编码为 4 个 ASCII 字符（如果有填充）。这四个 ASCII 字符会以每个 1 字节的形式通过网络发送。因此，结果的大小将始终比原始大小多出 33.33%。所以，如果原始字符串的大小是 n 字节，那么 Base64 编码后的大小将是：

```go
n*4/3
```

# **Base64 替代方案**

还有许多其他的编码选项，但其中一些非常复杂，而另一些则占用太多空间。例如，Base80 占用更少的空间，但却显著更难使用，因为二的幂是二进制的自然基数。另外，还有十六进制编码。它简单但占用更多空间。

+   十六进制 – 它的字符集由 16 个字符组成。

+   Base36 – 大小写不敏感的编码。

+   Base80

+   Base58

+   …

还有其他替代方案。

# **Base64 其他实现**

还有两种其他的 base64 实现。

+   用于 URL 的 Base64。在这种情况下，**‘+’** 和 **‘\’** 被替换为**‘+’** 和 **‘-‘**。这是因为 **‘+’** 和 **‘\’** 会进一步通过 URL 编码转化为十六进制序列，从而进一步增加 URL 的长度。例如，**‘+’** 会被转换为‘%2B’，**‘\’** 会被编码为‘%2F’。

+   用于文件名的 Base64。在这种情况下，**‘\’** 被替换为**‘-‘**。这是因为 **‘\’** 在 Unix 和 Windows 的文件路径中都被使用。

# **Base64 应用**

+   在电子邮件中传输二进制数据，例如将视频和音频作为电子邮件附件发送。

+   基本认证在 HTTP 协议中是作为 Base64 编码发送的。

还有其他 Base64 的应用。

# **结论**

这就是关于 Base64 编码的所有内容。希望你喜欢这篇文章。请在评论中分享你的反馈。
