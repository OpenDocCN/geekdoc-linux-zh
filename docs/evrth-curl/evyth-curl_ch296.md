# 超时

所有内部操作都需要以非阻塞方式编写，不能只是挂起并等待事件发生。同时，多接口允许用户在几乎任何时间调用 libcurl，即使没有发生任何操作或超时触发。

## 仅向应用暴露单个超时

在外部 API 中，libcurl 每次只提供一个超时，无论有多少并发传输以及设置了哪些选项。应用程序可以通过`curl_multi_timeout()`或`CURLMOPT_TIMERFUNCTION`回调函数来获取超时值，具体取决于它想使用哪个 API。

在内部，操作如下：

+   每个简单句柄都保留一个超时数组，按顺序排列。时间最接近（下次超时）的位于列表之首。

+   所有简单句柄都被放入一个*伸展树*中，这是一个二叉自平衡搜索树，使得根据超时插入和删除节点变得快速。

+   一旦任何句柄的下次超时时间发生变化，伸展树就会重新平衡。

提取带有过期超时的简单句柄是一个快速操作。

## 设置超时

用于*设置*超时的内部函数称为`Curl_expire()`。它要求 libcurl 在未来的一定毫秒数后再次调用此句柄。通过特定的 ID 设置超时，以确保它覆盖了之前为同一超时设置的值等。现有的超时 ID 是有限的，并且是硬编码的。

可以使用`Curl_expire_clear()`再次移除超时，这将从给定简单句柄的超时列表中移除该超时。

## 过期的超时

超时到期意味着应用程序知道它需要再次调用 libcurl。当使用*socket_action* API 时，它甚至知道需要再次为超时到期的特定简单句柄调用 libcurl。

当超时到期时，除了调用 perform 函数外，没有其他特殊动作或活动发生。每个状态或内部函数都需要知道要检查哪些时间或状态，并在被调用时（再次）相应地执行。
