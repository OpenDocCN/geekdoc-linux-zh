# 性能

本节收集了关于作为应用程序作者你可以做什么以从 libcurl 中获得最大性能的一般建议。

libcurl 默认设计为尽可能快地运行。你期望在不做任何额外操作的情况下就能获得最佳性能。然而，有一些常见的事情需要注意或者可能需要避免的错误。

## 重复使用句柄

这是在讨论 libcurl 时的一个通用箴言。如果你使用简单接口，那么提高性能的*主要*关键是后续传输时重用句柄。这允许 libcurl 重用连接、重用 TLS 会话、尽可能多地使用其 DNS 缓存等等。

## 缓冲区大小

如果你下载数据，将`CURLOPT_BUFFERSIZE`设置为合适的大小。它从开始就相对较小，尤其是在高速传输中，你可能通过增加其大小从 libcurl 中获得更多。我们鼓励你在基准测试中尝试几个大小以适应你的用例。

同样，如果你上传数据，你可能需要出于相同的原因调整`CURLOPT_UPLOAD_BUFFERSIZE`。

## 池大小

你通过`CURLOPT_MAXCONNECTS`设置的连接池中保持的活动连接数可能值得调整。当然，这取决于你的应用程序如何使用连接，但如果它例如在短时间内迭代 N 个域名，确保 libcurl 可以保持所有这些连接活跃可能是有意义的。

## 尽可能使回调尽可能快

在高速数据下载中，写入回调会被多次调用。如果这个函数没有以尽可能快的方式编写，那么这个函数本身可能会使*所有*传输比它们本应慢。

当然，对于上传的读取回调也是如此。

避免在 libcurl 回调中执行复杂的逻辑或使用锁/互斥锁。

## 共享数据

如果你使用多个简单句柄，你仍然可以在它们之间共享数据和缓存以提高性能。更详细地了解共享 API。

## 线程

如果你的传输线程最终消耗了 100%的 CPU，那么你可能从将负载分配到多个线程以增加带宽中受益。

通常情况下，你希望每个线程尽可能独立地进行传输，以避免它们相互干扰性能或因共享句柄而出现线程安全的问题。尽量让相同的域名在同一个线程上传输，以便可以优化连接重用。

## `curl_multi_socket_action`

如果你的应用程序执行许多并行传输，比如超过一百个并发传输，那么你*必须*考虑切换到`curl_multi_socket_action()`和基于事件的 API，而不是“常规”的多线程 API。这允许并鼓励你使用基于事件的策略，让你的应用程序避免使用`poll()`和`select()`，这对于高性能和高并发度至关重要。
