# 内存调试

文件 `lib/memdebug.c` 包含了一些函数的调试版本。例如 `malloc()`、`free()`、`fopen()`、`fclose()` 等等，这些函数以某种方式处理可能会给我们带来问题的资源。memdebug 系统中的函数不做任何花哨的事情，它们执行正常功能，然后记录它们刚刚做了什么的信息。这些记录的数据可以在完整会话后进行分析，

`memanalyze.pl` 是位于 `tests/` 中的 perl 脚本，它分析由内存跟踪系统生成的日志文件。它检测资源是否已分配但从未释放，以及其他与资源管理相关的错误。

在内部，预处理器符号 `DEBUGBUILD` 的定义限制了仅针对调试启用构建编译的代码。符号 `CURLDEBUG` 用于区分仅用于内存跟踪/调试的代码。

在编译时使用 `-DCURLDEBUG` 以启用内存调试，这也可以通过运行配置脚本并使用 `--enable-curldebug` 来启用。在编译时使用 `-DDEBUGBUILD` 以启用调试构建，或者运行配置脚本并使用 `--enable-debug`。

`curl --version` 列出了调试启用构建的 `Debug` 功能，以及 curl 调试内存跟踪功能 `TrackMemory`。这些功能是独立的，可以在运行配置脚本时进行控制。当提供 `--enable-debug` 时，这两个功能都会被启用，除非某些限制阻止了内存跟踪的使用。

## 跟踪内存泄漏

…使用内存调试系统。一般来说，我们建议首先使用 valgrind。 

### 单线程

请注意，此内存泄漏系统尚未调整以在多个线程中工作。如果您想在多线程应用程序中使用它，请相应地进行调整。

### 构建

使用 `-DCURLDEBUG` 重新构建 libcurl（通常，重新运行配置脚本并使用 `--enable-debug` 可以解决这个问题）。首先执行 `make clean`，然后执行 `make` 以确保所有文件都正确地重新构建。此外，使用带有调试选项（通常是编译器的 `-g`）构建 libcurl 也是有意义的，这样如果实际上在库中找到泄漏，调试会更加容易。

这构建了一个启用了内存调试的库。

### 修改您的应用程序

在您的应用程序代码中添加一行：

```sh
curl_dbg_memdebug("dump");
```

这使得 malloc 调试系统输出所有资源使用函数到指定的文件名。确保您重新构建程序，并且与上述描述中为该目的构建的相同 libcurl 链接。

### 运行您的应用程序

按照常规运行您的程序。观察指定的内存跟踪文件增长。

让您的程序退出并使用适当的 libcurl 清理函数等，以确保所有非泄漏都返回/释放正确。

### 分析流程

使用 `tests/memanalyze.pl` perl 脚本分析转储文件：

```sh
$ tests/memanalyze.pl dump
```

现在会输出关于已分配但从未释放的资源等的报告。这个报告适合发布到列表中。

如果没有产生任何输出，libcurl 中未检测到泄漏。那么泄漏很可能是出现在您的代码中。
