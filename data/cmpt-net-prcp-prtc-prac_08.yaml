- en: Internet protocols#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html](https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html](https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html)'
- en: The main objective of the network layer is to allow hosts, connected to different
    networks, to exchange information through intermediate systems called [router](../glossary.html#term-router).
    The unit of information in the network layer is called a [packet](../glossary.html#term-packet).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层的主要目标是允许连接到不同网络的主机通过称为[路由器](../glossary.html#term-router)的中间系统交换信息。网络层的信息单元称为[数据包](../glossary.html#term-packet)。
- en: '![Figure made with TikZ](../Images/666a41088f52b54a3b4670a0295154bb.png)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Figure made with TikZ](../Images/666a41088f52b54a3b4670a0295154bb.png)'
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 106 The network layer in the reference model
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 106 参考模型中的网络层
- en: Before explaining the network layer in detail, it is useful to begin by analyzing
    the service provided by the datalink layer. There are many variants of the datalink
    layer. Some provide a connection-oriented service while others provide a connectionless
    service. In this section, we focus on connectionless datalink layer services as
    they are the most widely used. Using a connection-oriented datalink layer causes
    some problems that are beyond the scope of this chapter. See [**RFC 3819**](https://datatracker.ietf.org/doc/html/rfc3819.html)
    for a discussion on this topic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细解释网络层之前，先分析数据链路层提供的服务是有用的。数据链路层有许多变体。有些提供面向连接的服务，而有些提供无连接的服务。在本节中，我们专注于无连接的数据链路层服务，因为它们是最广泛使用的。使用面向连接的数据链路层会导致一些超出本章范围的问题。有关此主题的讨论，请参阅[**RFC
    3819**](https://datatracker.ietf.org/doc/html/rfc3819.html)。
- en: '![Figure made with TikZ](../Images/e94f023d5f58d59588d996bb0d388d15.png)'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Figure made with TikZ](../Images/e94f023d5f58d59588d996bb0d388d15.png)'
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 107 The point-to-point datalink layer
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 107 点对点数据链路层
- en: There are three main types of datalink layers. The simplest datalink layer is
    when there are only two communicating systems that are directly connected through
    the physical layer. Such a datalink layer is used when there is a point-to-point
    link between the two communicating systems. The two systems can be hosts or routers.
    PPP, defined in [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html),
    is an example of such a point-to-point datalink layer. Datalink layers exchange
    frames and a datalink [frame](../glossary.html#term-frame) sent by a datalink
    layer entity on the left is transmitted through the physical layer, so that it
    can reach the datalink layer entity on the right. Point-to-point datalink layers
    can either provide an unreliable service (frames can be corrupted or lost) or
    a reliable service (in this case, the datalink layer includes retransmission mechanisms
    similar to the ones used in the transport layer). The unreliable service is frequently
    used above physical layers (e.g. optical fiber, twisted pairs) having a low bit
    error ratio while reliability mechanisms are often used in wireless networks to
    recover locally from transmission errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层主要有三种类型。最简单的数据链路层是只有两个通信系统通过物理层直接连接的情况。这种数据链路层用于两个通信系统之间存在点对点连接时。这两个系统可以是主机或路由器。PPP，定义在[**RFC
    1661**](https://datatracker.ietf.org/doc/html/rfc1661.html)，是这种点对点数据链路层的例子。数据链路层交换帧，一个数据链路层实体发送的数据链路[帧](../glossary.html#term-frame)通过物理层传输，以便它能够到达右侧的数据链路层实体。点对点数据链路层可以提供不可靠的服务（帧可能被损坏或丢失）或可靠的服务（在这种情况下，数据链路层包括与传输层使用的类似的重传机制）。不可靠的服务通常用于物理层（例如光纤、双绞线）具有低比特错误比率的物理层之上，而可靠性机制通常用于无线网络以从传输错误中本地恢复。
- en: The second type of datalink layer is the one used in Local Area Networks (LAN).
    Conceptually, a LAN is a set of communicating devices such that any two devices
    can directly exchange frames through the datalink layer. Both hosts and routers
    can be connected to a LAN. Some LANs only connect a few devices, but there are
    LANs that can connect hundreds or even thousands of devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的数据链路层是在局域网（LAN）中使用的。从概念上讲，一个LAN是一组通信设备，其中任何两个设备都可以通过数据链路层直接交换帧。主机和路由器都可以连接到LAN。有些LAN只连接几个设备，但也有一些LAN可以连接数百甚至数千个设备。
- en: '[![../_images/simple-lan.png](../Images/a7152d7ccb5142638996cde819a282cb.png)](../_images/simple-lan.png)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/simple-lan.png](../Images/a7152d7ccb5142638996cde819a282cb.png)](../_images/simple-lan.png)'
- en: Fig. 108 A local area network[#](#id30 "Link to this image")
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图. 108 局域网[#](#id30 "链接到此图像")
- en: In the second part, we describe the organization and the operation of Local
    Area Networks. An important difference between the point-to-point datalink layers
    and the datalink layers used in LANs is that in a LAN, each communicating device
    is identified by a unique datalink layer address. This address is usually embedded
    in the hardware of the device and different types of LANs use different types
    of datalink layer addresses. Most LANs use 48-bits long addresses that are usually
    called MAC addresses. A communicating device attached to a LAN can send a datalink
    frame to any other communicating device that is attached to the same LAN. Most
    LANs also support special broadcast and multicast datalink layer addresses. A
    frame sent to the broadcast address of the LAN is delivered to all communicating
    devices that are attached to the LAN. The multicast addresses are used to identify
    groups of communicating devices. When a frame is sent towards a multicast datalink
    layer address, it is delivered by the LAN to all communicating devices that belong
    to the corresponding group.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们描述了局域网的组织和操作。点对点数据链路层和局域网中使用的数据链路层之间的重要区别在于，在局域网中，每个通信设备都由一个独特的数据链路层地址标识。这个地址通常嵌入在设备的硬件中，不同类型的局域网使用不同类型的数据链路层地址。大多数局域网使用48位长的地址，通常称为MAC地址。连接到局域网的通信设备可以向连接到同一局域网的任何其他通信设备发送数据链路帧。大多数局域网还支持特殊的广播和多播数据链路层地址。发送到局域网广播地址的帧将被发送到连接到局域网的全部通信设备。多播地址用于标识通信设备组。当一个帧发送到多播数据链路层地址时，局域网会将它发送给属于相应组的所有通信设备。
- en: The third type of datalink layers are used in Non-Broadcast Multi-Access (NBMA)
    networks. These networks are used to interconnect devices like a LAN. All devices
    attached to an NBMA network are identified by a unique datalink layer address.
    However, and this is the main difference between an NBMA network and a traditional
    LAN, the NBMA service only supports unicast. The datalink layer service provided
    by an NBMA network supports neither broadcast nor multicast.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型的数据链路层用于非广播多路访问（NBMA）网络。这些网络用于连接类似局域网的设备。连接到NBMA网络的所有设备都由一个独特的数据链路层地址标识。然而，这是NBMA网络与传统局域网之间的主要区别，NBMA服务只支持单播。NBMA网络提供的数据链路层服务既不支持广播也不支持多播。
- en: Unfortunately no datalink layer is able to send frames of unlimited size. Each
    datalink layer is characterized by a maximum frame size. There are more than a
    dozen different datalink layers and unfortunately most of them use a different
    maximum frame size. The network layer must cope with the heterogeneity of the
    datalink layer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有数据链路层能够发送无限大小的帧。每个数据链路层都有一个最大帧大小。有十几种不同的数据链路层，不幸的是，它们大多数使用不同的最大帧大小。网络层必须处理数据链路层的异构性。
- en: 'Two different network layer protocols coexist on the Internet: IP version 4
    and IP version 6\. As explained earlier, these two protocols allow a host to send
    packets to any other host. Both protocols support variable-length packets. The
    most important difference between IPv4 and IPv6 is the size of the IP addresses.
    IPv4 uses addresses that are encoded as a 32 bits long (4 bytes) bit string. IPv6
    addresses are much longer. An IPv6 address is encoded as a 128 bits long (16 bytes)
    bit string.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上共存着两种不同的网络层协议：IP版本4和IP版本6。正如之前所解释的，这两个协议允许一个主机向任何其他主机发送数据包。这两个协议都支持可变长度的数据包。IPv4和IPv6之间最重要的区别是IP地址的大小。IPv4使用32位长（4字节）的编码地址。IPv6地址要长得多。一个IPv6地址被编码为128位长（16字节）的位字符串。
- en: In this section, we describe how hosts use these two protocols to send and receive
    packets. We do not discuss how IP addresses are allocated and how IP packets can
    be efficiently forwarded through the Internet. These parts of IPv4 and IPv6 are
    discussed in the second part of the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了主机如何使用这两个协议发送和接收数据包。我们不讨论IP地址的分配以及如何高效地将IP数据包通过互联网转发。IPv4和IPv6的这些部分将在本书的第二部分讨论。
- en: IP version 4[#](#ip-version-4 "Link to this heading")
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP版本4[#](#ip-version-4 "链接到本标题")
- en: 'IP version 4 is the data plane protocol of the network layer in the TCP/IP
    protocol suite. The design of IP version 4 was based on the following assumptions
    :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IP版本4是TCP/IP协议套件中网络层数据平面协议。IP版本4的设计基于以下假设：
- en: IP should provide an unreliable connectionless service (TCP provides reliability
    when required by the application)
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 应该提供不可靠的无连接服务（当应用程序需要时，TCP 提供可靠性）
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP operates with the datagram transmission mode
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 以数据报传输模式运行
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP addresses have a fixed size of 32 bits
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 地址具有固定的 32 位大小
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP must be usable above different types of datalink layers
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 必须能在不同类型的链路层上使用
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP hosts exchange variable length packets
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 主机交换可变长度的数据包
- en: IPv4 addresses are encoded as a 32 bits field. IPv4 addresses are often represented
    in dotted-decimal format as a sequence of four integers separated by a dot. The
    first integer is the decimal representation of the most significant byte of the
    32 bits IPv4 address, … For example,
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址编码为 32 位字段。IPv4 地址通常以点分十进制格式表示，为四个整数序列，由点分隔。第一个整数是 32 位 IPv4 地址最高有效字节的十进制表示，……例如，
- en: 1.2.3.4 corresponds to 00000001000000100000001100000100
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.2.3.4 对应于 00000001000000100000001100000100
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 127.0.0.1 corresponds to 01111111000000000000000000000001
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.1 对应于 01111111000000000000000000000001
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 255.255.255.255 corresponds to 11111111111111111111111111111111
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 255.255.255.255 对应于 11111111111111111111111111111111
- en: An IPv4 address is used to identify an interface on a router or a host. A router
    has thus as many IPv4 addresses as the number of interfaces that it has in the
    datalink layer. Most hosts have a single datalink layer interface and thus have
    a single IPv4 address. However, with the growth of wireless, more and more hosts
    have several datalink layer interfaces (e.g. an Ethernet interface and a WiFi
    interface). These hosts are said to be multihomed. A multihomed host with two
    interfaces has thus two IPv4 addresses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址用于标识路由器或主机上的接口。因此，路由器拥有的 IPv4 地址数量与它在链路层上的接口数量相同。大多数主机只有一个链路层接口，因此只有一个
    IPv4 地址。然而，随着无线技术的发展，越来越多的主机拥有多个链路层接口（例如，一个以太网接口和一个 WiFi 接口）。这些主机被称为多宿主。具有两个接口的多宿主主机因此有两个
    IPv4 地址。
- en: Many Internet hosts are attached to [Local Area Networks](../glossary.html#term-Local-Area-Networks)
    (LANs) such as Wi-Fi or Ethernet networks. We will describe the operation of these
    networks in more details in the second part of the book, but at this stage, the
    important point to know about these LANs is that they provide a connectionless
    datalink layer service. On a LAN, each device is identified by a unique 48 bits
    long address that is called a [MAC address](../glossary.html#term-MAC-address)
    (MAC stands for [Medium Access Control](../glossary.html#term-Medium-Access-Control)
    that will be explained in details in the second part). To ensure the unicity of
    the MAC addresses, these addresses are usually hardwired directly on the network
    interface cards. Each vendor of network cards ensures that all the interfaces
    that it sells have a unique MAC address. The devices attached a LAN can exchanged
    frames easily. A [frame](../glossary.html#term-frame) is a sequence of bytes that
    starts with a fixed-length header followed by a payload and for some types of
    LANs a trailer. The frame header contains the MAC address of the source of the
    frame and the MAC address of the destination of the frame. The frame payload carries
    the information exchanged and the trailer can contain a CRC to detect transmission
    errors or other types of control information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网主机连接到 [局域网](../glossary.html#term-Local-Area-Networks)（LANs），如 Wi-Fi 或以太网网络。我们将在本书的第二部分更详细地描述这些网络的操作，但在此阶段，关于这些
    LANs 的重要一点是它们提供无连接的链路层服务。在 LAN 上，每个设备都由一个唯一的 48 位长地址标识，称为 [MAC 地址](../glossary.html#term-MAC-address)（MAC
    代表 [介质访问控制](../glossary.html#term-Medium-Access-Control)，将在第二部分中详细解释）。为了确保 MAC
    地址的唯一性，这些地址通常直接硬编码在网络接口卡上。每个网络卡供应商都确保它销售的每个接口都有一个唯一的 MAC 地址。连接到 LAN 的设备可以轻松交换帧。一个
    [帧](../glossary.html#term-frame) 是一个以固定长度头部开始，后面跟有效载荷，对于某些类型的 LAN，还有尾部。帧头部包含帧的源
    MAC 地址和目标 MAC 地址。帧有效载荷携带交换的信息，尾部可以包含 CRC 以检测传输错误或其他类型的控制信息。
- en: '![../_images/frame-ip.svg](../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/frame-ip.svg](../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png)'
- en: Fig. 109 A datalink layer frame containing an IPv4 packet[#](#id31 "Link to
    this image")
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 109 包含 IPv4 数据包的链路层帧[#](#id31 "链接到此图像")
- en: When several hosts are attached to the same LAN, they can quickly exchange IP
    packets by placing these packets inside datalink layer frames. If host A knows
    the MAC address of host B, it can send an IP packet as the payload of a frame
    whose source MAC address is its own MAC address and destination MAC address is
    B’s MAC address. We will detail later how a host can automatically learn the MAC
    address of another host.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个主机连接到同一局域网时，它们可以通过将这些数据包放入数据链路层帧中来快速交换 IP 数据包。如果主机 A 知道主机 B 的 MAC 地址，它可以发送一个
    IP 数据包作为帧的有效负载，其源 MAC 地址是它自己的 MAC 地址，目标 MAC 地址是 B 的 MAC 地址。我们将在后面详细说明主机如何自动学习另一个主机的
    MAC 地址。
- en: When a host is attached to a LAN, it can directly send packets to the other
    hosts attached to the same LAN. To reach remote hosts, it must first send its
    packets to a router, also attached to the LAN. The router will be able to forward
    the packet to other routers such that it reaches its final destination.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机连接到局域网（LAN）时，它可以直接向同一局域网中连接的其他主机发送数据包。要到达远程主机，它必须首先将其数据包发送到也连接到局域网的路由器。路由器将能够将数据包转发到其他路由器，以便到达其最终目的地。
- en: When a host attached to a LAN sends an IP packet, it needs to know whether the
    destination is attached to the same LAN or not. If the destination is attached
    to the same LAN, the host can simply place the packet inside a frame and us the
    datalink layer to deliver it directly to its final destination. Otherwise, the
    host must the datalink layer to send the packet inside a frame to the LAN router
    that will take care of the packet. IPv4 and IPv6 solve this problem by grouping
    IP addresses in subnets. An [IP subnet](../glossary.html#term-IP-subnet) is the
    set of all IP addresses that have the same prefix. It is represented as an IP
    address followed by n, the number of bits in the common prefix.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到局域网的主机发送 IP 数据包时，它需要知道目的地是否连接到同一局域网。如果目的地连接到同一局域网，主机只需将数据包放入帧中，并使用数据链路层将其直接发送到最终目的地。否则，主机必须使用数据链路层将数据包放入帧中，发送到负责该数据包的局域网路由器。IPv4
    和 IPv6 通过将 IP 地址分组到子网中解决了这个问题。一个 [IP 子网](../glossary.html#term-IP-subnet) 是具有相同前缀的所有
    IP 地址的集合。它表示为一个 IP 地址后跟 n，表示公共前缀中的位数。
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high order bits of the
    address and the host identifier is encoded in the low order bits of the address.
    This is illustrated below with a 22 bits subnetwork identifier shown in blue and
    a 12 bits host identifier in red.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址由两部分组成：子网标识符和主机标识符。子网标识符由地址的高位比特组成，而主机标识符编码在地址的低位比特中。以下图示中，蓝色显示了 22 位子网标识符，红色显示了
    12 位主机标识符。
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
- en: Fig. 110 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 110 IPv4 地址内的子网络（蓝色）和主机标识符（红色）
- en: A subnet identifier or IPv4 prefix is usually [[1]](#fnetmask) represented as
    A.B.C.D/p where A.B.C.D is the network address obtained by concatenating the subnet
    identifier with a host identifier containing only 0 and p is the length of the
    subnet identifier in bits. The table below provides examples of IP subnets.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 子网标识符或 IPv4 前缀通常 [[1]](#fnetmask) 表示为 A.B.C.D/p，其中 A.B.C.D 是通过将子网标识符与仅包含 0 的主机标识符连接而获得的网络地址，p
    是子网标识符的位数。下表提供了 IP 子网的示例。
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 子网 | 地址数量 | 最小地址 | 最大地址 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Class A, B, or C addresses
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: A 类、B 类或 C 类地址
- en: 'Today’s IPv4 implementations use variable-length subnets defined in [**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html). With variable-length
    subnets, the subnet identifier can be any size, from 1 to 31 bits. Variable-length
    subnets allow the network operators to use a subnet that better matches the number
    of hosts that are placed inside the subnet. Before the publication of [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html),
    IPv4 address blocks were divided in classes of addresses. [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)
    defined three classes of IPv4 addresses depending on their high order bits:'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 今天的IPv4实现使用在[**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)中定义的可变长度子网。使用可变长度子网，子网标识符可以是1到31位中的任何大小。可变长度子网允许网络运营商使用更适合子网内放置的主机数量的子网。在[**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)发布之前，IPv4地址块是根据地址类别进行划分的。[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)根据其最高位定义了三种IPv4地址类别：
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Class A addresses are the addresses whose high order bit is set to zero. The
    high order byte of this address was the network identifier and the 24 low order
    bits the host identifier. They correspond to today’s `\8` subnets.
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A类地址是指最高位被设置为0的地址。这个地址的最高字节是网络标识符，而24个低字节是主机标识符。它们对应于今天的 `\8` 子网。
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class B addresses are the addresses whose two high order bits are set to one
    followed by zero. The next fourteen bits are the network identifier and the low
    order sixteen bits the host identifier. They correspond to today’s `/16` subnets.
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B类地址是指那些两个最高位被设置为1，然后是0的地址。接下来的十四位是网络标识符，而最低的十六位是主机标识符。它们对应于今天的 `/16` 子网。
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class C addresses are the addresses whose three high order bits are set to one
    followed by one and then zero. The next fourteen bits are the network identifier
    and the low order twenty four bits the host identifier. They correspond to today’s
    `/24` subnets.
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: C类地址是指那些三个最高位被设置为1，然后是1，接着是0的地址。接下来的十四位是网络标识符，而最低的二十四位是主机标识符。它们对应于今天的 `/24`
    子网。
- en: Initially, address blocks were allocated based on the address class required.
    Large companies, network providers and some universities asked for a Class A addresses
    and obtained it. Many universities requested a Class B address. However, this
    allocation was inefficient as Class A address blocks are much larger than the
    needs of most enterprises while Class C are too small. [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)
    suppressed this inefficient allocation. Nowadays, the IPv4 addressing space is
    almost fully utilized, except some reserved blocks. The [IPv4 Address Report](https://ipv4.potaroo.net/)
    provides a detailed report on the evolution of the allocated IPv4 addressing space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，地址块是根据所需的地址类别分配的。大型公司、网络提供商和一些大学请求C类地址并获得了它。许多大学请求B类地址。然而，这种分配效率低下，因为A类地址块比大多数企业的需求大得多，而C类地址块又太小。[**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)抑制了这种低效的分配。如今，IPv4地址空间几乎被完全利用，除了一些保留块。[IPv4地址报告](https://ipv4.potaroo.net/)提供了关于分配的IPv4地址空间演变的详细报告。
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Special IPv4 addresses
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊IPv4地址
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in [**RFC 5735**](https://datatracker.ietf.org/doc/html/rfc5735.html).
    These include :'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数单播IPv4地址都可以出现在全球互联网上的数据包的源地址和目的地址中。然而，值得注意的是，一些IPv4地址块有特殊用途，如[**RFC 5735**](https://datatracker.ietf.org/doc/html/rfc5735.html)中所述。这些包括：
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0.0.0/8`，这个地址块被保留用于自识别。这个块中的一个常见地址是 `0.0.0.0`，有时在主机启动且尚未知道其IPv4地址时使用。'
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.0/8`，这个地址块被保留用于环回地址。每个实现IPv4的主机都必须有一个环回接口（即未连接到数据链路层）。按照惯例，IPv4地址
    `127.0.0.1` 被分配给这个接口。这允许主机上运行的过程使用TCP/IP来联系同一主机上运行的其他过程。这对于测试目的非常有用。'
- en: 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0/8, 172.16.0.0/12 和 192.168.0.0/16 被保留用于不直接连接到互联网的私有网络。这些地址通常被称为私有地址或[**RFC
    1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)地址。
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 169.254.0.0/16 用于链路本地地址[**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。一些主机在连接到未按预期分配地址的网络时，会使用此块中的地址。
- en: IPv4 packets[#](#ipv4-packets "Link to this heading")
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4数据包[#](#ipv4-packets "链接到这个标题")
- en: The IPv4 packet format was defined in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    It is shown in [Fig. 111](#fig-ipv4-header-detail). Apart from a few clarifications
    and some backward compatible changes, the IPv4 packet format did not change significantly
    since the publication of [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    All IPv4 packets use the 20 bytes header shown in figure [Fig. 111](#fig-ipv4-header-detail).
    Some IPv4 packets contain an optional header extension that is described later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包格式在[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)中定义。它在[图111](#fig-ipv4-header-detail)中显示。除了少数澄清和一些向后兼容的更改外，自[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)发布以来，IPv4数据包格式没有发生重大变化。所有IPv4数据包都使用图[图111](#fig-ipv4-header-detail)中显示的20字节头部。一些IPv4数据包包含一个可选的头部扩展，将在后面描述。
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)'
- en: Fig. 111 The IP version 4 header[#](#id33 "Link to this image")
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图111 IP版本4头部[#](#id33 "链接到这张图片")
- en: 'The main fields of the IPv4 header are :'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部的主要字段包括：
- en: a 4 bits version that indicates the version of IP used to build the header.
    Using a version field in the header allows the network layer protocol to evolve.
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4位的版本号，指示构建头部所使用的IP版本。在头部中使用版本字段允许网络层协议进行演变。
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 4 bits IP Header Length (IHL) that indicates the length of the IP header in
    32 bits words. This field allows IPv4 to use options if required, but as it is
    encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4位的IP头部长度（IHL），指示IP头部以32位字为单位的长度。此字段允许IPv4在需要时使用选项，但由于它编码为4位字段，IPv4头部不能超过64字节。
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits DS field that is used for Quality of Service and whose usage is described
    later.
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个8位的DS字段，用于服务质量，其用法将在后面描述。
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits Protocol field that indicates the transport layer protocol that must
    process the packet’s payload at the destination. Common values for this field
    [[2]](#fprotocolnumber) are 6 for TCP and 17 for UDP
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个8位的协议字段，指示必须在目的地处理数据包有效载荷的传输层协议。此字段的常见值[2](#fprotocolnumber)为TCP的6和UDP的17。
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits length field that indicates the total length of the entire IPv4 packet
    (header and payload) in bytes. This implies that an IPv4 packet cannot be longer
    than 65535 bytes.
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的长度字段，表示整个IPv4数据包（头部和有效载荷）的总长度，以字节为单位。这意味着IPv4数据包的长度不能超过65535字节。
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits source address field that contains the IPv4 address of the source
    host
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位源地址字段，包含源主机的IPv4地址
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits destination address field that contains the IPv4 address of the destination
    host
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位的目的地址字段，包含目标主机的IPv4地址
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits checksum that protects only the IPv4 header against transmission errors
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的校验和，仅保护IPv4头部免受传输错误的影响。
- en: The other fields of the IPv4 header are used for specific purposes. The first
    is the 8 bits Time To Live (TTL) field. This field is used by IPv4 to avoid the
    risk of having an IPv4 packet caught in an infinite loop due to a transient or
    permanent error in routing tables [[3]](#fttl). We will discuss in part two why
    such problems can happen. The TTL field of the IPv4 header ensures that even if
    there are forwarding loops in the network, packets will not loop forever. Hosts
    send their IPv4 packets with a positive TTL (usually 64 or more [[4]](#finitialttl)).
    When a router receives an IPv4 packet, it first decrements the TTL by one. If
    the TTL becomes 0, the packet is discarded and a message is sent back to the packet’s
    source (see section [ICMP](#icmp)). Otherwise, the router performs a lookup in
    its forwarding table to forward the packet.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 头部的其他字段用于特定目的。第一个是 8 位生存时间 (TTL) 字段。该字段由 IPv4 用于避免由于路由表中的暂时性或永久性错误而导致 IPv4
    数据包陷入无限循环的风险 [[3]](#fttl)。我们将在第二部分讨论为什么会出现这样的问题。IPv4 头部的 TTL 字段确保即使网络中存在转发循环，数据包也不会无限循环。主机以正的
    TTL（通常是 64 或更多 [[4]](#finitialttl)）发送其 IPv4 数据包。当路由器收到一个 IPv4 数据包时，它首先将 TTL 减少一个。如果
    TTL 变为 0，则丢弃数据包并向数据包的源发送消息（见 [ICMP](#icmp) 部分）。否则，路由器在其转发表中查找以转发数据包。
- en: A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is
    used above many very different datalink layers. Each datalink layer has its own
    characteristics and as indicated earlier, each datalink layer is characterized
    by a maximum frame size. From IP’s point of view, a datalink layer interface is
    characterized by its Maximum Transmission Unit (MTU). The MTU of an interface
    is the largest IPv4 packet (including header) that it can send. The table below
    provides some common MTU sizes [[5]](#f6lowpan).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 的第二个问题是数据链路层的异构性。IPv4 在许多非常不同的数据链路层之上使用。每个数据链路层都有其自身的特性，如前所述，每个数据链路层的特点是最大帧大小。从
    IP 的角度来看，数据链路层接口的特点是其最大传输单元 (MTU)。接口的 MTU 是它能够发送的最大 IPv4 数据包（包括头部）。下表提供了一些常见的
    MTU 大小 [[5]](#f6lowpan)。
- en: '| Datalink layer | MTU |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | MTU |'
- en: '| Ethernet | 1500 bytes |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 以太网 | 1500 字节 |'
- en: '| WiFi | 2272 bytes |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 2272 字节 |'
- en: '| ATM (AAL5) | 9180 bytes |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| ATM (AAL5) | 9180 字节 |'
- en: '| 802.15.4 | 102 or 81 bytes |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 802.15.4 | 102 或 81 字节 |'
- en: '| Token Ring | 4464 bytes |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 令牌环 | 4464 字节 |'
- en: '| FDDI | 4352 bytes |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| FDDI | 4352 字节 |'
- en: Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink
    layer technologies that are used today are able to send a 64 KBytes IPv4 packet
    inside a frame. Consider a client attached to a Token Ring network that wishes
    to send packets to a server connected to an Ethernet network. The client could
    send a 4 KBytes packet that would need to be fragmented inside the network to
    reach the server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲，IPv4 主机可以发送长达 64 KBytes 的数据包，但今天使用的少数数据链路层技术能够在一个帧内发送 64 KBytes 的 IPv4
    数据包。考虑一个连接到 Token Ring 网络的客户机，它希望向连接到以太网网络的服务器发送数据包。客户机可以发送一个 4 KBytes 的数据包，该数据包需要在网络内部进行分片才能到达服务器。
- en: To solve these problems, IPv4 includes a packet fragmentation and reassembly
    mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if
    the packet is too long to be sent via the datalink layer. In IPv4, fragmentation
    is completely performed in the IP layer and a large IPv4 is fragmented into two
    or more IPv4 packets (called fragments). The IPv4 fragments of a large packet
    are normal IPv4 packets that are forwarded towards the destination of the large
    packet by intermediate routers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，IPv4 包含了数据包分片和重组机制。如果数据包太长而无法通过数据链路层发送，主机和中间路由器都可以分片 IPv4 数据包。在 IPv4
    中，分片完全在 IP 层完成，一个大的 IPv4 数据包被分成两个或更多个 IPv4 数据包（称为分片）。大包的 IPv4 分片是正常的 IPv4 数据包，由中间路由器转发到大数据包的目的地。
- en: 'The IPv4 fragmentation mechanism relies on four fields of the IPv4 header :
    Length, Identification, the flags and the Fragment Offset. The IPv4 header contains
    two flags : More fragments and Don’t Fragment (DF). When the DF flag is set, this
    indicates that the packet cannot be fragmented.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 分片机制依赖于 IPv4 头部的四个字段：长度、标识、标志和分片偏移。IPv4 头部包含两个标志：更多分片和不要分片 (DF)。当 DF 标志被设置时，这表示数据包不能被分片。
- en: The basic operation of the IPv4 fragmentation is as follows. A large packet
    is fragmented into two or more fragments. The size of all fragments, except the
    last one, is equal to the Maximum Transmission Unit of the link used to forward
    the packet. Each IPv4 packet contains a 16 bits Identification field. When a packet
    is fragmented, the Identification of the large packet is copied in all fragments
    to allow the destination to reassemble the received fragments together. In each
    fragment, the Fragment Offset indicates, in units of 8 bytes, the position of
    the payload of the fragment in the payload of the original packet. The Length
    field in each fragment indicates the length of the payload of the fragment as
    in a normal IPv4 packet. Finally, the More fragments flag is set only in the last
    fragment of a large packet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4分段的基本操作如下。一个大的数据包被分成两个或更多个分段。除了最后一个分段外，所有分段的尺寸等于用于转发数据包的链路的最大传输单元。每个IPv4数据包包含一个16位的标识字段。当一个数据包被分段时，大包的标识被复制到所有分段中，以便目的地可以将接收到的分段重新组装在一起。在每个分段中，片段偏移以8字节为单位指示分段有效载荷在原始数据包有效载荷中的位置。每个分段中的长度字段指示分段有效载荷的长度，就像正常IPv4数据包一样。最后，更多片段标志仅在大型数据包的最后一个分段中设置。
- en: The following pseudo-code details the IPv4 fragmentation algorithm, assuming
    that the packet does not contain IP options.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码详细说明了IPv4分段算法，假设数据包不包含IP选项。
- en: '[PRE0]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The fragments of an IPv4 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包的分段可以以任何顺序到达目的地，因为每个分段在网络中独立转发，可能遵循不同的路径。此外，一些分段可能丢失，永远不会到达目的地。
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv4 packet is a fragment
    or not by checking the value of the More fragments flag and the Fragment Offset.
    If the Fragment Offset is set to 0 and the More fragments flag is reset, the received
    packet has not been fragmented. Otherwise, the packet has been fragmented and
    must be reassembled. The reassembly algorithm relies on the Identification field
    of the received fragments to associate a fragment with the corresponding packet
    being reassembled. Furthermore, the Fragment Offset field indicates the position
    of the fragment payload in the original non fragmented packet. Finally, the packet
    with the More fragments flag reset allows the destination to determine the total
    length of the original no fragmented packet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目的主机使用的重组算法大致如下。首先，目的地可以通过检查更多片段标志和片段偏移的值来验证接收到的IPv4数据包是否为分段。如果片段偏移设置为0且更多片段标志被重置，则接收到的数据包没有被分段。否则，数据包已经被分段，必须进行重组。重组算法依赖于接收到的分段的标识字段来关联一个分段与正在重组的相应数据包。此外，片段偏移字段指示分段有效载荷在原始未分段数据包中的位置。最后，当更多片段标志被重置时，目的地可以确定原始未分段数据包的总长度。
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bound the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重组算法必须处理IP网络的不可靠性。这意味着一个分段可能被重复，或者一个分段可能永远无法到达目的地。目的地可以通过片段偏移轻松检测到分段重复。为了处理分段丢失，重组算法必须在数据包正在重组期间将其缓冲区中存储的分段的时间限制在合理范围内。这可以通过在接收到数据包的第一个分段时启动计时器来实现。如果在计时器到期之前数据包没有被重组，则丢弃所有分段，并认为数据包已丢失。
- en: The original IP specification, in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html),
    defined several types of options that can be added to the IP header. Each option
    is encoded using a type length value format. They are not widely used today. Additional
    details may be found in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 原始IP规范，在[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)中，定义了可以添加到IP头部的一些选项类型。每个选项都使用类型长度值格式进行编码。它们今天并不广泛使用。更多详细信息可以在[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)中找到。
- en: '## ICMP version 4[#](#icmp-version-4 "Link to this heading")'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '## ICMP版本4[#](#icmp-version-4 "链接到这个标题")'
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMP is defined in [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html).
    ICMP messages are carried as the payload of IP packets (the protocol value reserved
    for ICMP is 1). [Fig. 112](#fig-icmpv4-header) illustrates the IPv4 header. An
    ICMP message is composed of an 8 byte header and a variable length payload that
    usually contains the first bytes of the packet that triggered the transmission
    of the ICMP message.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，中间路由器或目标主机需要通知数据包的发送者处理数据包时发生的问题。在TCP/IP协议套件中，这种报告是通过互联网控制消息协议（ICMP）完成的。ICMP在[**RFC
    792**](https://datatracker.ietf.org/doc/html/rfc792.html)中定义。ICMP消息作为IP数据包的有效负载（为ICMP保留的协议值为1）传输。[图.
    112](#fig-icmpv4-header)说明了IPv4头部。一个ICMP消息由一个8字节头部和一个可变长度的有效负载组成，通常包含触发ICMP消息传输的数据包的前几个字节。
- en: '[![../_images/icmpv4.png](../Images/c6f49e0d69bec409a194b8b0090a586c.png)](../_images/icmpv4.png)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/icmpv4.png](../Images/c6f49e0d69bec409a194b8b0090a586c.png)'
- en: Fig. 112 ICMP version 4 [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html)[#](#id34
    "Link to this image")
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图. 112 ICMP版本4 [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html)[#](#id34
    "链接到此图像")
- en: In the ICMP header, the Type and Code fields indicate the type of problem that
    was detected by the sender of the ICMP message. The Checksum protects the entire
    ICMP message against transmission errors and the Data field contains additional
    information for some ICMP messages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在ICMP头部中，类型和代码字段指示了发送ICMP消息的发送者检测到的问题类型。校验和保护整个ICMP消息免受传输错误的影响，而数据字段包含一些ICMP消息的附加信息。
- en: 'The main types of ICMP messages are :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP消息的主要类型包括：
- en: 'Destination unreachable : a Destination unreachable ICMP message is sent when
    a packet cannot be delivered to its destination due to routing problems. Different
    types of non reachability are distinguished :'
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标不可达：当数据包由于路由问题无法送达其目标地址时，会发送一个目标不可达的ICMP消息。不同类型的不可达性被区分出来：
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Network unreachable : this ICMP message is sent by a router that does not have
    a route for the subnet containing the destination address of the packet'
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络不可达：当路由器没有包含数据包目标地址子网的路径时，会发送此ICMP消息
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Host unreachable : this ICMP message is sent by a router that is attached to
    the subnet that contains the destination address of the packet, but this destination
    address cannot be reached at this time'
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机不可达：当路由器连接到包含数据包目标地址的子网，但此时无法到达该目标地址时，会发送此ICMP消息
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Protocol unreachable : this ICMP message is sent by a destination host that
    has received a packet, but does not support the transport protocol indicated in
    the packet’s Protocol field'
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议不可达：当目标主机收到一个数据包，但不支持数据包协议字段中指示的传输协议时，会发送此ICMP消息
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Port unreachable : this ICMP message is sent by a destination host that has
    received a packet destined to a port number, but no server process is bound to
    this port'
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口不可达：当目标主机收到一个目标端口号的数据包，但没有服务器进程绑定到该端口时，会发送此ICMP消息
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fragmentation needed : this ICMP message is sent by a router that receives
    a packet with the Don’t Fragment flag set that is larger than the MTU of the outgoing
    interface'
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要分片：当路由器收到一个设置了不分片标志且大于出接口MTU的数据包时，会发送此ICMP消息
- en: '*ping(8)* is often used by network operators to verify that a given IP address
    is reachable. Each host is supposed [[6]](#fpingproblems) to reply with an ICMP
    Echo reply message when its receives an ICMP Echo request message. A sample usage
    of *ping(8)* is shown below.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*ping(8)*常被网络操作员用来验证给定的IP地址是否可达。每个主机都应该[[6]](#fpingproblems)在收到ICMP Echo请求消息时回复一个ICMP
    Echo回复消息。以下是一个*ping(8)*的示例用法。'
- en: '[PRE1]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another very useful debugging tool is *traceroute(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the TTL exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose TTL is set to 1 it decrements the TTL and
    is forced to return to the sending host a TTL exceeded ICMP message containing
    the header and the first bytes of the discarded IP packet. To discover all routers
    on a network path, a simple solution is to first send a packet whose TTL is set
    to 1, then a packet whose TTL is set to 2, etc. A sample traceroute output is
    shown below.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试工具是 *traceroute(8)*。traceroute 的 man 页面将此工具描述为“打印数据包到达网络主机的路由”。traceroute
    使用 TTL 超过 ICMP 消息来发现通往目的地的路径上的中间路由器。traceroute 的原理非常简单。当一个路由器收到一个 TTL 设置为 1 的
    IP 数据包时，它会递减 TTL 并被迫向发送主机返回一个包含头部和丢弃的 IP 数据包前几个字节的 TTL 超过 ICMP 消息。为了发现网络路径上的所有路由器，一个简单的解决方案是首先发送一个
    TTL 设置为 1 的数据包，然后发送一个 TTL 设置为 2 的数据包，依此类推。下面是一个示例 traceroute 输出。
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above *traceroute(8)* output shows a 17 hops path between a host at UCLouvain
    and one of the main IETF servers. For each hop, traceroute provides the IPv4 address
    of the router that sent the ICMP message and the measured round-trip-time between
    the source and this router. traceroute sends three probes with each TTL value.
    In some cases, such as at the tenth hop above, the ICMP messages may be received
    from different addresses. This is usually because different packets from the same
    source have followed different paths [[7]](#ftraceroutemore) in the network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 *traceroute(8)* 输出显示了从 UCLouvain 的一个主机到主要 IETF 服务器之一的 17 个跳数路径。对于每个跳数，traceroute
    会提供发送 ICMP 消息的路由器的 IPv4 地址以及源地址和该路由器之间的往返时间。traceroute 为每个 TTL 值发送三个探测。在某些情况下，例如上面的第十个跳数，可能会从不同的地址接收到
    ICMP 消息。这通常是因为来自同一源的不同数据包在网络中遵循了不同的路径 [[7]](#ftraceroutemore)。
- en: Another important utilization of ICMP messages is to discover the maximum MTU
    that can be used to reach a destination without fragmentation. As explained earlier,
    when an IPv4 router receives a packet that is larger than the MTU of the outgoing
    link, it must fragment the packet. Unfortunately, fragmentation is a complex operation
    and routers cannot perform it at line rate [[KM1995]](../bibliography.html#km1995).
    Furthermore, when a TCP segment is transported in an IP packet that is fragmented
    in the network, the loss of a single fragment forces TCP to retransmit the entire
    segment (and thus all the fragments). If TCP was able to send only packets that
    do not require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 消息的另一个重要用途是发现可以用来到达目的地而不需要分片的最大 MTU。如前所述，当一个 IPv4 路由器收到一个大于出链路 MTU 的数据包时，它必须对该数据包进行分片。不幸的是，分片是一个复杂的操作，路由器无法以线路速率执行
    [[KM1995]](../bibliography.html#km1995)。此外，当 TCP 段在网络中通过分片的数据包传输时，单个分片的丢失会迫使 TCP
    重新传输整个段（以及所有分片）。如果 TCP 能够发送不需要在网络中分片的数据包，它就只能重新传输在网络中丢失的信息。此外，如 [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html)
    中讨论的那样，IP 重组在高速情况下会带来几个挑战。使用 IP 分片来允许 UDP 应用程序交换大型消息会引发几个安全问题 [[KPS2003]](../bibliography.html#kps2003)。
- en: ICMP, combined with the Don’t fragment (DF) IPv4 flag, is used by TCP implementations
    to discover the largest MTU size that is allowed to reach a destination host without
    causing network fragmentation. This is the Path MTU discovery mechanism defined
    in [**RFC 1191**](https://datatracker.ietf.org/doc/html/rfc1191.html). A TCP implementation
    that includes Path MTU discovery (most do) requests the IPv4 layer to send all
    segments inside IPv4 packets having the DF flag set. This prohibits intermediate
    routers from fragmenting these packets. If a router needs to forward a packet
    which cannot be fragmented over a link with a smaller MTU, it returns a Fragmentation
    needed ICMP message to the source, indicating the MTU of its outgoing link. This
    ICMP message contains in the MTU of the router’s outgoing link in its Data field.
    Upon reception of this ICMP message, the source TCP implementation adjusts its
    Maximum Segment Size (MSS) so that the packets containing the segments that it
    sends can be forwarded by this router without requiring fragmentation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: TCP实现使用ICMP以及不分段（DF）IPv4标志来发现允许到达目标主机而不引起网络分段的最大的MTU大小。这是在[**RFC 1191**](https://datatracker.ietf.org/doc/html/rfc1191.html)中定义的路径MTU发现机制。包含路径MTU发现（大多数都包含）的TCP实现请求IPv4层发送所有包含DF标志的IPv4数据包中的所有段。这禁止了中间路由器对这些数据包进行分段。如果路由器需要转发一个无法在较小MTU的链路上分段的包，它将返回一个需要分段的ICMP消息给源地址，指示其出链路的MTU。此ICMP消息在其数据字段中包含路由器出链路的MTU。在接收到此ICMP消息后，源TCP实现调整其最大分段大小（MSS），以便发送的包含这些段的包可以由该路由器转发，而无需分段。
- en: Operation of IPv4 hosts[#](#operation-of-ipv4-hosts "Link to this heading")
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4主机的操作[#](#operation-of-ipv4-hosts "链接到本标题")
- en: At this point of the description of IPv4, it is useful to have a detailed look
    at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest
    case is when a host needs to send a segment in an IPv4 packet. The host performs
    two operations. First, it must decide on which interface the packet will be sent.
    Second it must create the corresponding IP packet(s).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述IPv4的这一点上，详细查看IPv4实现如何发送、接收和转发IPv4数据包是有用的。最简单的情况是，当主机需要在一个IPv4数据包中发送一个段时。主机执行两个操作。首先，它必须决定数据包将通过哪个接口发送。其次，它必须创建相应的IP数据包（s）。
- en: To simplify the discussion in this section, we ignore the utilization of IPv4
    options. This is not a severe limitation as today IPv4 packets rarely contain
    options. Details about the processing of the IPv4 options may be found in the
    relevant RFCs, such as [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本节中的讨论，我们忽略了IPv4选项的利用。这并不是一个严重的限制，因为如今IPv4数据包很少包含选项。有关IPv4选项处理详情，可在相关RFC中找到，例如[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)。
- en: 'An IPv4 host having \(n\) datalink layer interfaces manages \(n+1\) IPv4 addresses
    :'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有\(n\)个数据链路层接口的IPv4主机管理\(n+1\)个IPv4地址：
- en: the 127.0.0.1/32 IPv4 address assigned by convention to its loopback address
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照**惯例**分配给回环地址的127.0.0.1/32 IPv4地址
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: one A.B.C.D/p IPv4 address assigned to each of its \(n\) datalink layer interfaces
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将A.B.C.D/p IPv4地址分配给其\(n\)个数据链路层接口中的每一个
- en: 'Such a host maintains a routing table containing one entry for its loopback
    address and one entry for each subnet identifier assigned to its interfaces. Furthermore,
    the host usually uses one of its interfaces as the default interface when sending
    packets that are not addressed to a directly connected destination. This is represented
    by the default route : 0.0.0.0/0 that is associated to one interface.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的主机维护一个路由表，包含一个条目用于其回环地址，以及一个条目用于分配给其接口的每个子网标识符。此外，主机通常在发送未直接连接到目标的数据包时使用其接口之一作为默认接口。这由关联到一个接口的默认路由：0.0.0.0/0表示。
- en: When a transport protocol running on the host requests the transmission of a
    segment, it usually provides the IPv4 destination address to the IPv4 layer in
    addition to the segment [[12]](#fiddf). The IPv4 implementation first performs
    a longest prefix match with the destination address in its routing table. The
    lookup returns the identification of the interface that must be used to send the
    packet. The host can then create the IPv4 packet containing the segment. The source
    IPv4 address of the packet is the IPv4 address of the host on the interface returned
    by the longest prefix match. The Protocol field of the packet is set to the identification
    of the local transport protocol which created the segment. The TTL field of the
    packet is set to the default TTL used by the host. The host must now choose the
    packet’s Identification. This Identification is important if the packet becomes
    fragmented in the network, as it ensures that the destination is able to reassemble
    the received fragments. Ideally, a sending host should never send a packet twice
    with the same Identification to the same destination host, in order to ensure
    that all fragments are correctly reassembled by the destination. Unfortunately,
    with a 16 bits Identification field and an expected MSL of 2 minutes, this implies
    that the maximum bandwidth to a given destination is limited to roughly 286 Mbps.
    With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps [**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) if fragmentation must
    be possible [[12]](#fiddf). This is very low and is another reason why hosts are
    highly encouraged to avoid fragmentation. If; despite all of this, the MTU of
    the outgoing interface is smaller than the packet’s length, the packet is fragmented.
    Finally, the packet’s checksum is computed before transmission.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当在主机上运行的传输协议请求传输一个段时，它通常除了向IPv4层提供段之外，还会提供IPv4目标地址 [[12](#fiddf)]。IPv4实现首先在其路由表中与目标地址执行最长前缀匹配。查找返回必须用于发送数据包的接口标识。然后，主机可以创建包含段的IPv4数据包。数据包的源IPv4地址是返回最长前缀匹配的主机接口的IPv4地址。数据包的协议字段设置为创建段的本地传输协议的标识。数据包的TTL字段设置为主机使用的默认TTL。现在，主机必须选择数据包的标识。如果数据包在网络中分片，这个标识很重要，因为它确保目标能够重新组装接收到的片段。理想情况下，发送主机应该永远不要向同一目标主机发送具有相同标识的数据包两次，以确保所有片段都能被目标正确重新组装。不幸的是，由于16位标识字段和预期的MSL为2分钟，这意味着到给定目标的最大带宽限制在大约286
    Mbps。如果需要分片，并且MTU为1500字节，那么带宽会降低到6.4 Mbps [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html)
    [[12](#fiddf)]。这非常低，这也是为什么强烈建议主机避免分片的原因之一。如果，尽管如此，出接口的MTU小于数据包的长度，数据包将被分片。最后，在传输之前计算数据包的校验和。
- en: When a host receives an IPv4 packet destined to itself, there are several operations
    that it must perform. First, it must check the packet’s checksum. If the checksum
    is incorrect, the packet is discarded. Then, it must check whether the packet
    has been fragmented. If yes, the packet is passed to the reassembly algorithm
    described earlier. Otherwise, the packet must be passed to the upper layer. This
    is done by looking at the Protocol field (6 for TCP, 17 for UDP). If the host
    does not implement the transport layer protocol corresponding to the received
    Protocol field, it sends a Protocol unreachable ICMP message to the sending host.
    If the received packet contains an ICMP message (Protocol field set to 1), the
    processing is more complex. An Echo-request ICMP message triggers the transmission
    of an ICMP Echo-reply message. The other types of ICMP messages indicate an error
    that was caused by a previously transmitted packet. These ICMP messages are usually
    forwarded to the transport protocol that sent the erroneous packet. This can be
    done by inspecting the contents of the ICMP message that includes the header and
    the first 64 bits of the erroneous packet. If the IP packet did not contain options,
    which is the case for most IPv4 packets, the transport protocol can find in the
    first 32 bits of the transport header the source and destination ports to determine
    the affected transport flow. This is important for Path MTU discovery for example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机接收到一个目的地为主机的IPv4数据包时，它必须执行几个操作。首先，它必须检查数据包的校验和。如果校验和不正确，则丢弃该数据包。然后，它必须检查数据包是否已分片。如果是，则将数据包传递给前面描述的重组算法。否则，必须将数据包传递给上层。这是通过查看协议字段（TCP为6，UDP为17）来完成的。如果主机没有实现与接收到的协议字段相对应的传输层协议，它将向发送主机发送一个协议不可达的ICMP消息。如果接收到的数据包包含一个ICMP消息（协议字段设置为1），则处理更为复杂。Echo-request
    ICMP消息触发ICMP Echo-reply消息的传输。其他类型的ICMP消息表明由先前传输的数据包引起的错误。这些ICMP消息通常被转发到发送错误数据包的传输协议。这可以通过检查包含头部和错误数据包前64位的内容的ICMP消息来完成。如果IP数据包没有包含选项，这是大多数IPv4数据包的情况，传输协议可以在传输头部的第一个32位中找到源端口和目的端口，以确定受影响的传输流。这对于路径MTU发现等来说很重要。
- en: IP version 6[#](#ip-version-6 "Link to this heading")
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP版本6[#](#ip-version-6 "链接到本标题")
- en: In the late 1980s and early 1990s the growth of the Internet was causing several
    operational problems on routers. Many of these routers had a single CPU and up
    to 1 MByte of RAM to store their operating system, packet buffers and routing
    tables. Given the rate of allocation of IPv4 prefixes to companies and universities
    willing to join the Internet, the routing tables where growing very quickly and
    some feared that all IPv4 prefixes would quickly be allocated. In 1987, a study
    cited in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html), estimated
    that there would be 100,000 networks in the near future. In August 1990, estimates
    indicated that the class B space would be exhausted by March 1994.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代末和90年代初，互联网的增长在路由器上引发了几个操作问题。许多这些路由器只有一个CPU和高达1兆字节的RAM来存储它们的操作系统、数据包缓冲区和路由表。鉴于IPv4前缀分配给愿意加入互联网的公司和大学的速度，路由表增长非常快，有些人担心所有IPv4前缀很快就会被分配完毕。1987年，[**RFC
    1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)中引用的一项研究估计，在不久的将来将有10万个网络。1990年8月，估计表明B类地址空间将在1994年3月耗尽。
- en: Two types of solution were developed to solve this problem. The first short
    term solution was the introduction of Classless Inter Domain Routing ([CIDR](../glossary.html#term-CIDR)).
    A second short term solution was the Network Address Translation ([NAT](../glossary.html#term-NAT))
    mechanism, defined in [**RFC 1631**](https://datatracker.ietf.org/doc/html/rfc1631.html).
    NAT allowed multiple hosts to share a single public IPv4 address.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开发了两种类型的解决方案来解决这个问题。第一个短期解决方案是引入无类别域间路由([CIDR](../glossary.html#term-CIDR))。第二个短期解决方案是网络地址转换([NAT](../glossary.html#term-NAT))机制，由[**RFC
    1631**](https://datatracker.ietf.org/doc/html/rfc1631.html)定义。NAT允许多个主机共享一个公共IPv4地址。
- en: 'However, in parallel with these short-term solutions, which have allowed the
    IPv4 Internet to continue to be usable until now, the Internet Engineering Task
    Force started working on developing a replacement for IPv4\. This work started
    with an open call for proposals, outlined in [**RFC 1550**](https://datatracker.ietf.org/doc/html/rfc1550.html).
    Several groups responded to this call with proposals for a next generation Internet
    Protocol (IPng) :'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与这些短期解决方案并行，这些解决方案使得IPv4互联网能够继续使用至今，互联网工程任务组开始着手开发IPv4的替代品。这项工作始于一个公开的提案征集，概述在[**RFC
    1550**](https://datatracker.ietf.org/doc/html/rfc1550.html)中。几个小组对此征集做出了回应，提出了下一代互联网协议（IPng）的提案：
- en: TUBA proposed in [**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html)
    and [**RFC 1561**](https://datatracker.ietf.org/doc/html/rfc1561.html)
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: TUBA在[**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html)和[**RFC
    1561**](https://datatracker.ietf.org/doc/html/rfc1561.html)中提出
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PIP proposed in [**RFC 1621**](https://datatracker.ietf.org/doc/html/rfc1621.html)
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIP在[**RFC 1621**](https://datatracker.ietf.org/doc/html/rfc1621.html)中提出
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SIPP proposed in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIPP在[**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)中提出
- en: 'The IETF decided to pursue the development of IPng based on the SIPP proposal.
    As IP version 5 was already used by the experimental ST-2 protocol defined in
    [**RFC 1819**](https://datatracker.ietf.org/doc/html/rfc1819.html), the successor
    of IP version 4 is IP version 6\. The initial IP version 6 defined in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)
    was designed based on the following assumptions :'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: IETF决定根据SIPP提案推进IPng的发展。由于IP版本5已经被定义在[**RFC 1819**](https://datatracker.ietf.org/doc/html/rfc1819.html)中的实验性ST-2协议所使用，因此IP版本4的继任者是IP版本6。最初在[**RFC
    1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)中定义的IP版本6是基于以下假设设计的：
- en: IPv6 addresses are encoded as a 128 bits field
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6地址编码为128位字段
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The IPv6 header has a simple format that can easily be parsed by hardware devices
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6头部具有简单的格式，可以很容易地被硬件设备解析
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A host should be able to configure its IPv6 address automatically
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机应该能够自动配置其IPv6地址
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Security must be part of IPv6
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性必须是IPv6的一部分
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The IPng address size
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: IPng地址大小
- en: When the work on IPng started, it was clear that 32 bits was too small to encode
    an IPng address and all proposals used longer addresses. However, there were many
    discussions about the most suitable address length. A first approach, proposed
    by SIPP in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html),
    was to use 64 bit addresses. A 64 bits address space was 4 billion times larger
    than the IPv4 address space and, furthermore, from an implementation perspective,
    64 bit CPUs were being considered and 64 bit addresses would naturally fit inside
    their registers. Another approach was to use an existing address format. This
    was the TUBA proposal ([**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html))
    that reuses the ISO CLNP 20 bytes addresses. The 20 bytes addresses provided room
    for growth, but using ISO CLNP was not favored by the IETF partially due to political
    reasons, despite the fact that mature CLNP implementations were already available.
    128 bits appeared to be a reasonable compromise at that time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当IPng的工作开始时，很明显32位对于编码IPng地址来说太小了，所有提案都使用了更长的地址。然而，关于最合适的地址长度有许多讨论。一种最初的方法，由SIPP在[**RFC
    1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)中提出，是使用64位地址。64位地址空间比IPv4地址空间大40亿倍，而且从实现的角度来看，正在考虑64位CPU，64位地址自然适合它们的寄存器。另一种方法是使用现有的地址格式。这是TUBA提案([**RFC
    1347**](https://datatracker.ietf.org/doc/html/rfc1347.html))，它重用了ISO CLNP 20字节地址。20字节地址提供了增长空间，但使用ISO
    CLNP并不受IETF青睐，部分原因是政治原因，尽管成熟的CLNP实现已经可用。当时128位似乎是一个合理的折衷方案。
- en: IPv6 addressing architecture[#](#ipv6-addressing-architecture "Link to this
    heading")
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6地址架构[#](#ipv6-addressing-architecture "链接到本标题")
- en: The experience of IPv4 revealed that the scalability of a network layer protocol
    heavily depends on its addressing architecture. The designers of IPv6 spent a
    lot of effort defining its addressing architecture [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html).
    All IPv6 addresses are 128 bits wide. This implies that there are \(340,282,366,920,938,463,463,374,607,431,768,211,456
    (3.4 \times 10^{38})\) different IPv6 addresses. As the surface of the Earth is
    about 510,072,000 \(km^2\), this implies that there are about \(6.67 \times 10^{23}\)
    IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only
    8 addresses per square kilometer, this is a significant improvement on paper.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 的经验表明，网络层协议的可扩展性在很大程度上取决于其寻址架构。IPv6 的设计者投入了大量精力来定义其寻址架构 [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html)。所有
    IPv6 地址都是 128 位宽。这意味着有 \(340,282,366,920,938,463,463,374,607,431,768,211,456 (3.4
    \times 10^{38})\) 个不同的 IPv6 地址。由于地球的表面积约为 510,072,000 \(km^2\)，这意味着地球上每平方米大约有
    \(6.67 \times 10^{23}\) 个 IPv6 地址。与仅提供每平方公里 8 个地址的 IPv4 相比，这在纸上是一个显著的改进。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Textual representation of IPv6 addresses
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址的文本表示
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时有必要以文本格式编写 IPv6 地址，例如在手动配置地址或用于文档目的时。编写 IPv6 地址的首选格式是 `x:x:x:x:x:x:x:x`，其中
    `x` 是表示地址八个 16 位部分的十六进制数字。以下是一些 IPv6 地址的示例：
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`'
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0:0:0:219:e3ff:fed7:1204`'
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16 bits blocks containing only bits set to 0. For example,'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'IPv6 地址通常包含一个长的位序列，这些位被设置为 `0`。在这种情况下，已经定义了一种紧凑的表示法。使用这种表示法，:: 用于表示一个或多个只包含位设置为
    `0` 的 16 位块组。例如，'
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  id: totrans-205
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a` 表示为 `2001:db8::8:800:200c:417a`'
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff01:0:0:0:0:0:0:101` 表示为 `ff01::101`'
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` 表示为 `::1`'
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` 表示为 `::`'
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 前缀可以表示为地址/长度，其中长度是前缀的位数。例如，以下三种表示法对应于相同的 IPv6 前缀：
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8::cd30:0:0:0:0` / `60`'
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0:cd30::` / `60`'
- en: IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address
    is used to identify one datalink-layer interface on a host. If a host has several
    datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then
    it needs several IPv6 addresses. In general, an IPv6 unicast address is structured
    as shown in [Fig. 113](#fig-ipv6-addr-structure).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 支持单播、多播和任播地址。IPv6 单播地址用于标识主机上的一个数据链路层接口。如果一个主机有多个数据链路层接口（例如，一个以太网接口和一个
    Wi-Fi 接口），那么它需要多个 IPv6 地址。通常，IPv6 单播地址的结构如图 [图 113](#fig-ipv6-addr-structure)
    所示。
- en: '![Figure made with TikZ](../Images/334d256816526fa56f8d5037c79a8b94.png)'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/334d256816526fa56f8d5037c79a8b94.png)'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 113 Structure of IPv6 unicast addresses
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 113 IPv6 单播地址结构
- en: 'The IETF has reserved some IPv6 addresses for a special usage. The two most
    important ones are :'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: IETF 为特殊用途预留了一些 IPv6 地址。其中两个最重要的地址是：
- en: '`0:0:0:0:0:0:0:1` (`::1` in compact form) is the IPv6 loopback address. This
    is the address of a logical interface that is always up and running on IPv6 enabled
    hosts.'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` （紧凑形式中的 `::1`）是 IPv6 环回地址。这是在启用 IPv6 的主机上始终处于开启状态的逻辑接口的地址。'
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` (`::` in compact form) is the unspecified IPv6 address. This
    is the IPv6 address that a host can use as source address when trying to acquire
    an official address.'
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` （紧凑形式中的 `::`）是未指定 IPv6 地址。这是主机在尝试获取官方地址时可以用作源地址的 IPv6 地址。'
- en: The last type of unicast IPv6 addresses are the Link Local Unicast addresses
    shown in [Fig. 114](#fig-ipv6-link-local). These addresses are part of the fe80::/10
    address block and are defined in [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html).
    Each host can compute its own link local address by concatenating the fe80::/64
    prefix with the 64 bits identifier of its interface. Link local addresses can
    be used when hosts that are attached to the same link (or local area network)
    need to exchange packets. They are used notably for address discovery and auto-configuration
    purposes. Their usage is restricted to each link and a router cannot forward a
    packet whose source or destination address is a link local address. Link local
    addresses have also been defined for IPv4 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    However, the IPv4 link local addresses are only used when a host cannot obtain
    a regular IPv4 address, e.g. on an isolated LAN.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种单播IPv6地址是图[图. 114](#fig-ipv6-link-local)中所示的链路本地单播地址。这些地址是fe80::/10地址块的一部分，并在[**RFC
    4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)中定义。每个主机可以通过将fe80::/64前缀与其接口的64位标识符连接起来来计算自己的链路本地地址。链路本地地址可以在连接到同一链路（或局域网）的主机需要交换数据包时使用。它们特别用于地址发现和自动配置目的。它们的用途仅限于每个链路，并且路由器不能转发源地址或目的地址为链路本地地址的数据包。链路本地地址也已在IPv4中定义[**RFC
    3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。然而，IPv4链路本地地址仅在主机无法获得常规IPv4地址时使用，例如在孤立的局域网中。
- en: '![Figure made with TikZ](../Images/85809a63cecf02a8a699a08cbd775118.png)'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/85809a63cecf02a8a699a08cbd775118.png)'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 114 IPv6 link local address structure
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图. 114 IPv6链路本地地址结构
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All IPv6 hosts have several addresses
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所有IPv6主机都有多个地址
- en: An important consequence of the IPv6 unicast addressing architecture and the
    utilization of link-local addresses is that each IPv6 host has several IPv6 addresses.
    This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6单播寻址架构和链路本地地址的使用的一个重要后果是，每个IPv6主机都有多个IPv6地址。这意味着所有IPv6堆栈都必须能够处理多个IPv6地址。
- en: The addresses described above are unicast addresses. These addresses are used
    to identify (interfaces on) hosts and routers. They can appear as source and destination
    addresses in the IPv6 packets. When a host sends a packet towards a unicast address,
    this packet is delivered by the network to its final destination. There are situations,
    such as when delivering video or television signal to a large number of receivers,
    where it is useful to have a network that can efficiently deliver the same packet
    to a large number of receivers. This is the multicast service. A multicast service
    can be provided in a LAN. In this case, a multicast address identifies a set of
    receivers and each frame sent towards this address is delivered to all receivers
    in the group. Multicast can also be used in a network containing routers and hosts.
    In this case, a multicast address identifies also a group of receivers and the
    network delivers efficiently each multicast packet to all members of the group.
    Consider for example the network shown in [Fig. 115](#fig-ipv6-simple-network).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的地址是单播地址。这些地址用于标识（主机和路由器的）接口。它们可以出现在IPv6数据包的源地址和目的地址中。当主机向单播地址发送数据包时，该数据包通过网络被交付到其最终目的地。在某些情况下，例如向大量接收器发送视频或电视信号时，拥有一个能够高效地将相同数据包发送给大量接收器的网络是有用的。这就是组播服务。组播服务可以在局域网中提供。在这种情况下，组播地址标识一组接收器，并且每个发送到该地址的帧都将被发送到组中的所有接收器。组播也可以用于包含路由器和主机的网络中。在这种情况下，组播地址也标识一组接收器，并且网络将高效地将每个组播数据包交付给组中的所有成员。例如，考虑图[图.
    115](#fig-ipv6-simple-network)所示的网络。
- en: '![Figure made with TikZ](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 115 A simple network with hosts and routers
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图. 115 带有主机和路由器的简单网络
- en: Assume that `B` and `D` are part of a multicast group. If `A` sends a multicast
    packet towards this group, then `R1` will replicate the packet to forward it to
    `R2` and `R3`. `R2` would forward the packet towards `B`. `R3` would forward the
    packet towards `R4` that would deliver it to `D`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`B`和`D`是组播组的一部分。如果`A`向该组发送一个组播数据包，那么`R1`将复制该数据包以转发给`R2`和`R3`。`R2`将数据包转发给`B`。`R3`将数据包转发给`R4`，`R4`将数据包交付给`D`。
- en: Finally, [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)
    defines the structure of the IPv6 multicast addresses [[8]](#fmultiiana). This
    structure is depicted in [Fig. 116](#fig-ipv6-multicast-addr).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)定义了IPv6多播地址的结构[[8]](#fmultiiana)。这种结构在[图.
    116](#fig-ipv6-multicast-addr)中展示。
- en: '![Figure made with TikZ](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 116 IPv6 multicast address structure
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图. 116 IPv6多播地址结构
- en: The low order 112 bits of an IPv6 multicast address are the group’s identifier.
    The high order bits are used as a marker to distinguish multicast addresses from
    unicast addresses. Notably, the 4-bit Flags field indicates whether the address
    is temporary or permanent. Finally, the Scope field indicates the boundaries of
    the forwarding of packets destined to a particular address. A link-local scope
    indicates that a router should not forward a packet destined to such a multicast
    address. An organization local-scope indicates that a packet sent to such a multicast
    destination address should not leave the organization. Finally the global scope
    is intended for multicast groups spanning the global Internet.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6多播地址的低112位是组的标识符。高位用作标记，以区分多播地址和单播地址。值得注意的是，4位的标志字段指示地址是临时的还是永久的。最后，作用域字段指示特定地址的数据包转发的边界。链路本地作用域表示路由器不应转发目的地为这种多播地址的数据包。组织本地作用域表示发送到这种多播目的地地址的数据包不应离开组织。最后，全局作用域旨在用于跨越全球互联网的多播组。
- en: Among these addresses, some are well known. For example, all hosts automatically
    belong to the `ff02::1` multicast group while all routers automatically belong
    to the `ff02::2` multicast group. A detailed discussion of IPv6 multicast is outside
    the scope of this chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些地址中，一些是众所周知的。例如，所有主机自动属于`ff02::1`多播组，而所有路由器自动属于`ff02::2`多播组。IPv6多播的详细讨论超出了本章的范围。
- en: '### IPv6 packet[#](#ipv6-packet "Link to this heading")'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '### IPv6数据包[#](#ipv6-packet "链接到此标题")'
- en: The IPv6 packet format was heavily inspired by the packet format proposed for
    the SIPP protocol in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html).
    The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 117](#fig-ipv6-header-detail).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包格式在很大程度上受到了为SIPP协议提出的[**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)数据包格式的启发。在[**RFC
    2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)中定义的标准IPv6头部占用40字节，包含8个不同的字段，如图[图.
    117](#fig-ipv6-header-detail)所示。
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)'
- en: Fig. 117 The IP version 6 header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "Link to this image")
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图. 117 IP版本6头部 ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "链接到此图像")
- en: 'Apart from the source and destination addresses, the IPv6 header contains the
    following fields :'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源地址和目的地址之外，IPv6头部还包含以下字段：
- en: 'Version : a 4 bits field set to 6 and intended to allow IP to evolve in the
    future if needed'
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本：一个4位字段设置为6，目的是在需要时允许IP进化。
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Traffic class : this 8 bits field indicates the type of service expected by
    this packet and contains the `CE` and `ECT` flags that are used by Explicit Congestion
    Notification'
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量类别：这个8位字段表示此数据包期望的服务类型，并包含显式拥塞通知使用的`CE`和`ECT`标志。
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flow Label : this field was initially intended to be used to tag packets belonging
    to the same flow. A recent document, [**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)
    describes some possible usages of this field, but it is too early to tell whether
    it will be really used.'
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流标签：这个字段最初打算用来标记属于同一流的数据包。最近的一份文件，[**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)描述了该字段的一些可能的用途，但还太早判断它是否真的会被使用。
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Payload Length : this is the size of the packet payload in bytes. As the length
    is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of
    payload.'
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效载荷长度：这是数据包有效载荷的大小（以字节为单位）。由于长度被编码为16位字段，IPv6数据包可以包含最多65535字节的有效载荷。
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next Header : this 8-bit field indicates the type [[9]](#fianaprotocol) of
    header that follows the IPv6 header. It can be a transport layer header (e.g.
    6 for TCP or 17 for UDP) or an IPv6 option.'
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个头部：这个8位字段指示IPv6头部后面的头部类型[[9]](#fianaprotocol)。它可以是传输层头部（例如，6表示TCP或17表示UDP）或IPv6选项。
- en: ''
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hop Limit : this 8-bit field indicates the number of routers that can forward
    the packet. It is decremented by one by each router and prevents packets from
    looping forever inside the network.'
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳数限制：这个8位字段指示可以转发数据包的路由器数量。每个路由器将其减一，以防止数据包在网络内部无限循环。
- en: It is interesting to note that there is no checksum inside the IPv6 header.
    This is mainly because all datalink layers and transport protocols include a checksum
    or a CRC to protect their frames/segments against transmission errors. Adding
    a checksum in the IPv6 header would have forced each router to recompute the checksum
    of all packets, with limited benefit in detecting errors. In practice, an IP checksum
    allows for catching errors that occur inside routers (e.g. due to memory corruption)
    before the packet reaches its destination. However, this benefit was found to
    be too small given the reliability of current memories and the cost of computing
    the checksum on each router [[10]](#fipv4checksum).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，IPv6头中没有校验和。这主要是因为所有数据链路层和传输协议都包含校验和或CRC来保护它们的帧/段免受传输错误的影响。在IPv6头中添加校验和将迫使每个路由器重新计算所有数据包的校验和，这在检测错误方面的好处有限。实际上，IP校验和允许在数据包到达目的地之前捕获在路由器内部发生的错误（例如，由于内存损坏）。然而，鉴于当前内存的可靠性和在每个路由器上计算校验和的成本，这种好处被认为太小
    [[10]](#fipv4checksum)。
- en: 'When a host receives an IPv6 packet, it needs to determine which transport
    protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is
    the first role of the Next header field. The [IANA](https://www.iana.org) which
    manages the allocation of Internet resources and protocol parameters, maintains
    an official list of transport protocols [[9]](#fianaprotocol). The following protocol
    numbers are reserved :'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机接收到一个IPv6数据包时，它需要确定哪个传输协议（UDP、TCP、SCTP等）需要处理数据包的有效负载。这是下一个头部字段的第一种作用。管理互联网资源分配和协议参数分配的[IANA](https://www.iana.org)维护一个官方的传输协议列表
    [[9]](#fianaprotocol)。以下协议号已被保留：
- en: '`TCP` uses Next Header number `6`'
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCP`使用下一个头部编号`6`'
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UDP` uses Next Header number `17`'
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UDP`使用下一个头部编号`17`'
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SCTP` uses Next Header number `132`'
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCTP`使用下一个头部编号`132`'
- en: For example, an IPv6 packet that contains an TCP segment would appear as shown
    in [Fig. 118](#fig-ipv6-tcp).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，包含TCP段的IPv6数据包将如图118所示[图118](#fig-ipv6-tcp)。
- en: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)'
- en: Fig. 118 An IPv6 packet containing an TCP segment[#](#id40 "Link to this image")
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图118 包含TCP段的IPv6数据包[#](#id40 "链接到此图像")
- en: However, the Next header has broader usages than simply indicating the transport
    protocol which is responsible for the packet payload. An IPv6 packet can contain
    a chain of headers and the last one indicates the transport protocol that is responsible
    for the packet payload. Supporting a chain of headers is a clever design from
    an extensibility viewpoint. As we will see, this chain of headers has several
    usages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一个头部有比仅仅指示负责数据包有效负载的传输协议更广泛的使用。IPv6数据包可以包含一系列头部，最后一个头部指示负责数据包有效负载的传输协议。从可扩展性的角度来看，支持一系列头部是一个巧妙的设计。正如我们将看到的，这个头部链有几个用途。
- en: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) defines
    several types of IPv6 extension headers that could be added to an IPv6 packet
    :'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)定义了可以添加到IPv6数据包的几种类型的IPv6扩展头部：'
- en: Hop-by-Hop Options header. This option is processed by routers and hosts.
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳到跳选项头。此选项由路由器和主机处理。
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Destination Options header. This option is processed only by hosts.
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标选项头。此选项仅由主机处理。
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Routing header. This option is processed by some nodes.
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由头。此选项由某些节点处理。
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragment header. This option is processed only by hosts.
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片头。此选项仅由主机处理。
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Authentication header. This option is processed only by hosts.
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证头。此选项仅由主机处理。
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulating Security Payload. This option is processed only by hosts.
  id: totrans-300
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装安全负载。此选项仅由主机处理。
- en: The last two headers are used to add security above IPv6 and implement IPSec.
    They are described in [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    and [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) and are
    outside the scope of this document.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个头部用于在IPv6之上添加安全性和实现IPSec。它们在[**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)和[**RFC
    2406**](https://datatracker.ietf.org/doc/html/rfc2406.html)中描述，并且超出了本文档的范围。
- en: The Hop-by-Hop Options header was designed to make IPv6 easily extensible. In
    theory, this option could be used to define new fields that were not foreseen
    when IPv6 was designed. It is intended to be processed by both routers and hosts.
    Deploying an extension to a network protocol can be difficult in practice since
    some nodes already support the extensions while others still use the old version
    and do not understand the extension. To deal with this issue, the IPv6 designers
    opted for a Type-Length-Value encoding of these IPv6 options. The Hop-by-Hop Options
    header is encoded as show in [Fig. 119](#fig-ipv6-hbhoption).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到跳选项头部被设计成使 IPv6 容易扩展。理论上，这个选项可以用来定义在设计 IPv6 时未预见的新字段。它旨在由路由器和主机处理。在实践中，将扩展部署到网络协议可能很困难，因为一些节点已经支持扩展，而其他节点仍在使用旧版本且不理解扩展。为了处理这个问题，IPv6
    设计者选择了这些 IPv6 选项的类型-长度-值编码。跳到跳选项头部编码方式如图 119 所示。
- en: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
- en: Fig. 119 The IPv6 Hop-by-Hop Options header[#](#id41 "Link to this image")
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 119 IPv6 跳到跳选项头部[#](#id41 "链接到这个图像")
- en: 'In this optional header, the Next Header field is used to support the chain
    of headers. It indicates the type of the next header in the chain. IPv6 headers
    have different lengths. The Hdr Ext Len field indicates the total length of the
    option header in bytes. The Opt. Type field indicates the type of option. These
    types are encoded such that their high order bits specify how the header needs
    to be handled by nodes that do not recognize it. The following values are defined
    for the two high order bits :'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可选头部中，下一个头部字段用于支持头部的链。它指示链中下一个头部的类型。IPv6 头部有不同的长度。Hdr Ext Len 字段指示选项头部的总长度（以字节为单位）。Opt.
    Type 字段指示选项的类型。这些类型被编码，使得它们的高位位指定了节点在不识别它时如何处理头部。以下为两个高位位定义的值：
- en: '`00` : if a node does not recognize this header, it can be safely skipped and
    the processing continues with the subsequent header'
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`：如果一个节点不识别这个头部，它可以安全地跳过，并继续处理随后的头部'
- en: ''
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`01` : if a node does not recognize this header, the packet must be discarded'
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01`：如果一个节点不识别这个头部，则必须丢弃该数据包'
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`10` (resp. `11`) : if a node does not recognize this header, it must return
    a control packet (ICMP, see later) back to the source (resp. except if the destination
    was a multicast address)'
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`（或`11`）：如果一个节点不识别这个头部，它必须将控制包（ICMP，见后文）返回到源（除非目的地是一个多播地址）'
- en: This encoding allows the designers of protocol extensions to specify whether
    the option must be supported by all nodes on a path or not. Still, deploying such
    an extension can be difficult in practice.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码允许协议扩展的设计者指定选项是否必须由路径上的所有节点支持。然而，在实践中部署此类扩展可能很困难。
- en: Two hop-by-hop options have been defined. [**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    specifies the jumbogram that enables IPv6 to support packets containing a payload
    larger than 65535 bytes. These jumbo packets have their payload length set to
    0 and the jumbogram option contains the packet length as a 32 bits field. Such
    packets can only be sent from a source to a destination if all the routers on
    the path support this option. However, as of this writing it does not seem that
    the jumbogram option has been implemented. The router alert option defined in
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) is the second
    example of a hop-by-hop option. The packets that contain this option should be
    processed in a special way by intermediate routers. This option is used for IP
    packets that carry Resource Reservation Protocol (RSVP) messages, but this is
    outside the scope of this book.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了两种跳到跳的选项。[**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    规定了大封包，它使得 IPv6 能够支持包含大于 65535 字节数据包的负载。这些大封包将它们的负载长度设置为 0，而大封包选项包含一个 32 位的字段来表示数据包长度。只有当路径上的所有路由器都支持此选项时，这些数据包才能从源发送到目的地。然而，截至本文撰写时，似乎大封包选项尚未得到实现。在
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) 中定义的路由器警报选项是跳到跳选项的第二个例子。包含此选项的数据包应该由中间路由器以特殊方式处理。此选项用于携带资源预留协议
    (RSVP) 消息的 IP 数据包，但这超出了本书的范围。
- en: The Destinations Option header uses the same format as the Hop-by-Hop Options
    header. It has some usages, e.g. to support mobile nodes [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html),
    but these are outside the scope of this document.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地选项头使用与跳到跳选项头相同的格式。它有一些用途，例如支持移动节点 [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html)，但这些超出了本文档的范围。
- en: The Fragment Options header is more important. An important problem in the network
    layer is the ability to handle heterogeneous datalink layers. Most datalink layer
    technologies can only transmit and receive frames that are shorter than a given
    maximum frame size. Unfortunately, all datalink layer technologies use different
    maximum frames sizes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 分片选项头更为重要。网络层中的一个重要问题是处理异构数据链路层的能力。大多数数据链路层技术只能传输和接收小于给定最大帧大小的帧。不幸的是，所有数据链路层技术使用不同的最大帧大小。
- en: Each datalink layer has its own characteristics and as indicated earlier, each
    datalink layer is characterized by a maximum frame size. From IP’s point of view,
    a datalink layer interface is characterized by its Maximum Transmission Unit (MTU).
    The MTU of an interface is the largest packet (including header) that it can send.
    The table below provides some common MTU sizes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据链路层都有其自身的特性，如前所述，每个数据链路层以其最大帧大小为特征。从 IP 的角度来看，数据链路层接口以其最大传输单元 (MTU) 为特征。接口的
    MTU 是它可以发送的最大数据包（包括头部）。下表提供了一些常见的 MTU 大小。
- en: '| Datalink layer | MTU |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | 最大传输单元 (MTU) |'
- en: '| Ethernet | 1500 bytes |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 以太网 | 1500 字节 |'
- en: '| WiFi | 2272 bytes |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 2272 字节 |'
- en: '| ATM (AAL5) | 9180 bytes |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| ATM (AAL5) | 9180 字节 |'
- en: '| 802.15.4 | 102 or 81 bytes |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 802.15.4 | 102 或 81 字节 |'
- en: '| Token Ring | 4464 bytes |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 令牌环 | 4464 字节 |'
- en: '| FDDI | 4352 bytes |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| FDDI | 4352 字节 |'
- en: Although IPv6 can send 64 KBytes long packets, few datalink layer technologies
    that are used today are able to send a 64 KBytes packet inside a frame. Furthermore,
    as illustrated in [Fig. 120](#fig-ipv6-need-fragmentation), another problem is
    that a host may send a packet that would be too large for one of the datalink
    layers used by the intermediate routers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IPv6可以发送64 KBytes长的数据包，但今天使用的少数数据链路层技术能够在一个帧内发送64 KBytes的数据包。此外，如图 120 所示，另一个问题是主机可能发送一个对于中间路由器使用的数据链路层来说太大的数据包。
- en: '![Figure made with TikZ](../Images/1baf064048236d27ceffa188e5e44d59.png)'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/1baf064048236d27ceffa188e5e44d59.png)'
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 120 The need for fragmentation and reassembly
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 120 分片和重组的需求
- en: To solve these problems, IPv6 includes a packet fragmentation and reassembly
    mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate
    routers. However, experience with IPv4 has shown that fragmenting packets in routers
    was costly [[KM1995]](../bibliography.html#km1995). For this reason, the developers
    of IPv6 have decided that routers would not fragment packets anymore. In IPv6,
    fragmentation is only performed by the source host. If a source has to send a
    packet which is larger than the MTU of the outgoing interface, the packet needs
    to be fragmented before being transmitted. In IPv6, each packet fragment is an
    IPv6 packet that includes the Fragmentation header shown in [Fig. 121](#fig-ipv6-fragment-header).
    This header is included by the source in each packet fragment. The receiver uses
    them to reassemble the received fragments.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，IPv6 包含了数据包分片和重组机制。在 IPv4 中，分片由主机和中间路由器共同执行。然而，IPv4 的经验表明，在路由器中分片数据包是昂贵的
    [[KM1995]](../bibliography.html#km1995)。因此，IPv6 的开发者决定路由器将不再分片数据包。在 IPv6 中，分片仅由源主机执行。如果一个源必须发送一个大于出接口
    MTU 的数据包，那么在传输之前需要分片该数据包。在 IPv6 中，每个数据包分片都是一个包含如图 121 所示的分片头的 IPv6 数据包。该头由源包含在每个数据包分片中。接收者使用它们来重组接收到的分片。
- en: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
- en: Fig. 121 IPv6 fragmentation header[#](#id43 "Link to this image")
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 121 IPv6 分片头[#](#id43 "链接到此图像")
- en: If a router receives a packet that is too long to be forwarded, the packet is
    dropped and the router returns an ICMPv6 message to inform the sender of the problem.
    The sender can then either fragment the packet or perform Path MTU discovery.
    In IPv6, packet fragmentation is performed only by the source by using IPv6 options.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个路由器收到一个太长无法转发的数据包，该数据包将被丢弃，路由器将返回一个ICMPv6消息来通知发送者问题。发送者可以随后对数据包进行碎片化或执行路径MTU发现。在IPv6中，数据包碎片化仅由源主机通过使用IPv6选项执行。
- en: 'In IPv6, fragmentation is performed exclusively by the source host and relies
    on the fragmentation header. This 64 bits header is composed of six fields :'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，碎片化仅由源主机执行，并依赖于碎片化头部。这个64位头部由六个字段组成：
- en: a Next Header field that indicates the type of the header that follows the fragmentation
    header
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示跟随碎片化头部之后头部类型的Next Header字段
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: two Reserved fields set to 0.
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个保留字段设置为0。
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Fragment Offset is a 13-bit unsigned integer that contains the offset, in
    8 bytes units, of the data following this header, relative to the start of the
    original packet.
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fragment Offset是一个13位的无符号整数，包含相对于原始数据包起始位置的偏移量，以8字节为单位。
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the More flag, which is set to 0 in the last fragment of a packet and to 1 in
    all other fragments.
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: More标志，在数据包的最后一个片段中设置为0，在其他所有片段中设置为1。
- en: ''
  id: totrans-344
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the 32-bit Identification field indicates to which original packet a fragment
    belongs. When a host sends fragmented packets, it should ensure that it does not
    reuse the same identification field for packets sent to the same destination during
    a period of MSL seconds. This is easier with the 32 bits identification used in
    the IPv6 fragmentation header, than with the 16 bits identification field of the
    IPv4 header.
  id: totrans-346
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位的Identification字段指示一个片段属于哪个原始数据包。当主机发送碎片化数据包时，它应确保在MSL秒内不会为发送到同一目的地的数据包重复使用相同的标识字段。与IPv4头部中的16位标识字段相比，IPv6碎片化头部中使用的32位标识字段更容易做到这一点。
- en: Some IPv6 implementations send the fragments of a packet in increasing fragment
    offset order, starting from the first fragment. Others send the fragments in reverse
    order, starting from the last fragment. The latter solution can be advantageous
    for the host that needs to reassemble the fragments, as it can easily allocate
    the buffer required to reassemble all fragments of the packet upon reception of
    the last fragment. When a host receives the first fragment of an IPv6 packet,
    it cannot know a priori the length of the entire IPv6 packet.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IPv6实现以递增的碎片偏移量顺序发送数据包的片段，从第一个片段开始。其他实现则以相反的顺序发送片段，从最后一个片段开始。后者对于需要重新组装片段的主机可能更有利，因为它可以在接收到最后一个片段后轻松分配所需的缓冲区来重新组装数据包的所有片段。当主机接收到IPv6数据包的第一个片段时，它无法事先知道整个IPv6数据包的长度。
- en: '[Fig. 122](#fig-ipv6-fragmentation-example) provides an example of a fragmented
    IPv6 packet containing a UDP segment. The Next Header type reserved for the IPv6
    fragmentation option is 44.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[图122](#fig-ipv6-fragmentation-example)提供了一个包含UDP段的碎片化IPv6数据包的示例。为IPv6碎片化选项保留的Next
    Header类型是44。'
- en: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
- en: Fig. 122 IPv6 fragmentation example[#](#id44 "Link to this image")
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图122 IPv6碎片化示例[#](#id44 "链接到这个图像")
- en: The following pseudo-code details the IPv6 fragmentation, assuming that the
    packet does not contain options.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的伪代码详细说明了IPv6的碎片化，假设数据包不包含选项。
- en: '[PRE3]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the above pseudocode, we maintain a single 32 bits counter that is incremented
    for each packet that needs to be fragmented. Other implementations to compute
    the packet identification are possible. [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    only requires that two fragmented packets that are sent within the MSL between
    the same pair of hosts have different identifications.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述伪代码中，我们维护一个32位计数器，每次需要碎片化的数据包都会增加。其他计算数据包标识的实现也是可能的。[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)仅要求在同一对主机之间发送的、在MSL时间内发送的两个碎片化数据包具有不同的标识。
- en: The fragments of an IPv6 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包的片段可以以任何顺序到达目的地，因为每个片段在网络中独立转发，可能遵循不同的路径。此外，一些片段可能会丢失，永远无法到达目的地。
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv6 packet is a fragment
    or not by checking whether it contains a fragment header. If so, all fragments
    with the some identification must be reassembled together. The reassembly algorithm
    relies on the Identification field of the received fragments to associate a fragment
    with the corresponding packet being reassembled. Furthermore, the Fragment Offset
    field indicates the position of the fragment payload in the original non-fragmented
    packet. Finally, the packet with the M flag reset allows the destination to determine
    the total length of the original non-fragmented packet.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 目的主机使用的重组算法大致如下。首先，目的地可以通过检查是否包含分片头来验证接收到的IPv6数据包是否为分片。如果是，则必须将具有相同标识符的所有分片一起重组。重组算法依赖于接收到的分片的标识符字段，以将分片与正在重组的相应数据包关联起来。此外，分片偏移量字段指示分片有效载荷在原始非分片数据包中的位置。最后，M标志被重置的包允许目的地确定原始非分片数据包的总长度。
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bind the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重组算法必须处理IP网络的不可靠性。这意味着一个分片可能会被重复，或者一个分片可能永远无法到达目的地。由于分片偏移量，目的地可以轻松地检测到分片重复。为了处理分片丢失，重组算法必须在重组过程中将分片存储在缓冲区的时间绑定起来。这可以通过在接收到分片的第一部分时启动计时器来实现。如果在计时器到期之前没有重组数据包，则丢弃所有分片，并认为数据包已丢失。
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Header compression on low bandwidth links
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 低带宽链路上的头部压缩
- en: Given the size of the IPv6 header, it can cause huge overhead on low bandwidth
    links, especially when small packets are exchanged such as for Voice over IP applications.
    In such environments, several techniques can be used to reduce the overhead. A
    first solution is to use data compression in the datalink layer to compress all
    the information exchanged [[Thomborson1992]](../bibliography.html#thomborson1992).
    These techniques are similar to the data compression algorithms used in tools
    such as *compress(1)* or *gzip(1)* [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html).
    They compress streams of bits without taking advantage of the fact that these
    streams contain IP packets with a known structure. A second solution is to compress
    the IP and TCP header. These header compression techniques, such as the one defined
    in [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html) take advantage
    of the redundancy found in successive packets from the same flow to significantly
    reduce the size of the protocol headers. Another solution is to define a compressed
    encoding of the IPv6 header that matches the capabilities of the underlying datalink
    layer [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到IPv6头部长度，它可能会在低带宽链路上造成巨大的开销，尤其是在交换小数据包的情况下，例如VoIP应用。在这样的环境中，可以使用几种技术来减少开销。第一个解决方案是在数据链路层使用数据压缩来压缩交换的所有信息
    [[Thomborson1992]](../bibliography.html#thomborson1992)。这些技术与在*compress(1)*或*gzip(1)*等工具中使用的数据压缩算法类似
    [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html)。它们压缩位流，而不利用这些流包含具有已知结构的IP数据包的事实。第二个解决方案是压缩IP和TCP头。这些头压缩技术，如[**RFC
    5795**](https://datatracker.ietf.org/doc/html/rfc5795.html)中定义的，利用了来自同一流的连续数据包中的冗余，从而显著减小了协议头的大小。另一个解决方案是定义一个与底层数据链路层能力相匹配的IPv6头压缩编码
    [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html)。
- en: The last type of IPv6 header extension is the Routing header. The `type 0` routing
    header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    is an example of an IPv6 option that must be processed by some routers. This option
    is encoded as shown in [Fig. 123](#fig-ipv6-rh0).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6头部扩展的最后一种类型是路由头。在[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)中定义的`类型0`路由头是一个必须由某些路由器处理的IPv6选项的例子。此选项的编码方式如图[图123](#fig-ipv6-rh0)所示。
- en: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)(../_images/ipv6-routing-0.svg)'
- en: Fig. 123 The Type 0 routing header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "Link to this image")
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 123 类型 0 路由头部 ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "链接到此图像")
- en: 'The type 0 routing option was intended to allow a host to indicate a loose
    source route that should be followed by a packet by specifying the addresses of
    some of the routers that must forward this packet. Unfortunately, further work
    with this routing header, including an entertaining demonstration with [scapy](https://www.secdev.org/projects/scapy/)
    [[BE2007]](../bibliography.html#be2007) , revealed severe security problems with
    this routing header. For this reason, loose source routing with the type 0 routing
    header has been removed from the IPv6 specification [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html).  ###
    ICMP version 6[#](#icmp-version-6 "Link to this heading")'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 0 路由选项旨在允许主机通过指定必须转发此数据包的一些路由器的地址来指示一个松散源路由，该路由应由数据包遵循。不幸的是，进一步对该路由头部的工作，包括使用
    [scapy](https://www.secdev.org/projects/scapy/) 的娱乐性演示 [[BE2007]](../bibliography.html#be2007)，揭示了该路由头部存在严重的安全问题。因此，使用类型
    0 路由头部的松散源路由已被从 IPv6 规范中删除 [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html)。###
    ICMP 版本 6[#](#icmp-version-6 "链接到本标题")
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMPv6 is defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html).
    It is used both to report problems that occurred while processing an IPv6 packet,
    but also to distribute addresses.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，中间路由器或目的主机需要通知数据包的发送者处理数据包时发生的问题。在 TCP/IP 协议套件中，这种报告是通过互联网控制消息协议 (ICMP) 来完成的。ICMPv6
    定义在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)。它既用于报告处理
    IPv6 数据包时发生的问题，也用于分配地址。
- en: ICMPv6 messages are carried inside IPv6 packets (the Next Header field for ICMPv6
    is `58`). Each ICMP message contains a 32 bits header with an 8 bits type field,
    a code field and a 16 bits checksum computed over the entire ICMPv6 message. The
    message body contains a copy of the IPv6 packet in error. The ICMPv6 header is
    shown in [Fig. 124](#fig-icmpv6-header).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 消息承载在 IPv6 数据包内部（ICMPv6 的下一个头部字段为 `58`）。每个 ICMP 消息包含一个 32 位的头部，其中包含一个
    8 位的类型字段、一个代码字段和一个覆盖整个 ICMPv6 消息的 16 位校验和。消息体包含错误 IPv6 数据包的副本。ICMPv6 头部如图 [图 124](#fig-icmpv6-header)
    所示。
- en: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)'
- en: Fig. 124 ICMP version 6 packet format[#](#id46 "Link to this image")
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图 124 ICMP 版本 6 数据包格式[#](#id46 "链接到此图像")
- en: 'ICMPv6 specifies two classes of messages : error messages that indicate a problem
    in handling a packet and informational messages. Four types of error messages
    are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    :'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 定义了两种消息类型：指示处理数据包时出现问题的错误消息和信息性消息。在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    中定义了四种类型的错误消息：
- en: '`1`Destination Unreachable. Such an ICMPv6 message is sent when the destination
    address of a packet is unreachable. The code field of the ICMP header contains
    additional information about the type of unreachability. The following codes are
    specified in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)'
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：目的地不可达。当数据包的目的地址不可达时，会发送此类 ICMPv6 消息。ICMP 头部的代码字段包含有关不可达类型的附加信息。以下代码在 [**RFC
    4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中指定。'
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` : No route to destination. This indicates that the router that sent the
    ICMPv6 message did not have a route towards the packet’s destination'
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：无到目的地的路由。这表示发送 ICMPv6 消息的路由器没有到数据包目的地的路由。'
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` : Communication with destination administratively prohibited. This indicates
    that a firewall has refused to forward the packet towards its final destination.'
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：与目的地的通信被行政禁止。这表明防火墙已拒绝转发数据包到其最终目的地。'
- en: ''
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Beyond scope of source address. This message can be sent if the source
    is using link-local addresses to reach a global unicast address outside its subnet.'
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：源地址范围之外。如果源地址使用链路本地地址来访问其子网之外的全球单播地址，则可以发送此消息。'
- en: ''
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Address unreachable. This message indicates that the packet reached the
    subnet of the destination, but the host that owns this destination address cannot
    be reached.'
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：地址不可达。此消息表示数据包已到达目的地的子网，但拥有此目的地址的主机无法到达。'
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Port unreachable. This message indicates that the IPv6 packet was received
    by the destination, but there was no application listening to the specified port.'
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：端口不可达。此消息表示IPv6数据包已由目的地接收，但没有应用程序监听指定的端口。'
- en: ''
  id: totrans-388
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Packet Too Big. The router that was to send the ICMPv6 message received
    an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message
    contains the MTU of this link in bytes. This allows the sending host to implement
    Path MTU discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)'
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：数据包过大。原本要发送ICMPv6消息的路由器收到了一个大于出链路MTU的IPv6数据包。ICMPv6消息包含此链路的MTU（以字节为单位）。这允许发送主机实现路径MTU发现[**RFC
    1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)。'
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-396
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Time Exceeded. This error message can be sent either by a router or by
    a host. A router would set code to 0 to report the reception of a packet whose
    Hop Limit reached 0. A host would set code to 1 to report that it was unable to
    reassemble received IPv6 fragments.'
  id: totrans-397
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：超时。此错误消息可以由路由器或主机发送。路由器会将代码设置为0来报告接收到的数据包的跳数限制达到0。主机会将代码设置为1来报告它无法重新组装接收到的IPv6分片。'
- en: ''
  id: totrans-398
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Parameter Problem. This ICMPv6 message is used to report either the reception
    of an IPv6 packet with an erroneous header field (code 0) or an unknown Next Header
    or IP option (codes 1 and 2). In this case, the message body contains the erroneous
    IPv6 packet and the first 32 bits of the message body contain a pointer to the
    error.'
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：参数问题。此ICMPv6消息用于报告接收到的IPv6数据包带有错误的首部字段（代码0）或未知下一个头部或IP选项（代码1和2）。在这种情况下，消息体包含错误的IPv6数据包，消息体的前32位包含一个指向错误的指针。'
- en: The Destination Unreachable ICMP error message is returned when a packet cannot
    be forwarded to its final destination. The first four ICMPv6 error messages (type
    `1`, codes `0-3`) are generated by routers while hosts may return code `4` when
    there is no application bound to the corresponding port number.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据包无法转发到其最终目的地时，会返回目标不可达ICMP错误消息。前四个ICMPv6错误消息（类型`1`，代码`0-3`）由路由器生成，而主机在没有应用程序绑定到相应端口号时可能会返回代码`4`。
- en: The Packet Too Big ICMP messages enable the source host to discover the MTU
    size that it can safely use to reach a given destination. To understand its operation,
    consider the (academic) scenario shown in [Fig. 125](#fig-ipv6-mtu-discovery).
    In this figure, the labels on each link represent the maximum packet size supported
    by this link.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包过大ICMP消息使源主机能够发现它可以安全使用的MTU大小，以到达给定的目的地。为了理解其操作，请考虑[图125](#fig-ipv6-mtu-discovery)中所示的（学术）场景。在此图中，每个链路上的标签表示此链路支持的最大的数据包大小。
- en: '![Figure made with TikZ](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 125 Example for IPv6 MTU discovery
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图125 IPv6 MTU发现示例
- en: If `A` sends a 1500 bytes packet, `R1` will return an ICMPv6 error message indicating
    a maximum packet length of 1400 bytes. `A` would then fragment the packet before
    retransmitting it. The small fragment would go through, but the large fragment
    will be refused by `R2` that would return an ICMPv6 error message. `A` can fragment
    again the packet and send it to the final destination as two fragments.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`A`发送一个1500字节的数据包，`R1`将返回一个指示最大数据包长度为1400字节的ICMPv6错误消息。然后`A`会在重新传输之前将数据包分片。小分片会通过，但大分片将被`R2`拒绝，`R2`将返回一个ICMPv6错误消息。`A`可以再次分片数据包，并将其作为两个分片发送到最终目的地。
- en: In practice, an IPv6 implementation does not store the transmitted packets to
    be able to retransmit them if needed. However, since TCP (and SCTP) buffer the
    segments that they transmit, a similar approach can be used in transport protocols
    to detect the largest MTU on a path towards a given destination. This technique
    is called PathMTU Discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，IPv6实现不会存储要传输的数据包以便在需要时重新传输。然而，由于TCP（和SCTP）缓存它们传输的段，可以在传输协议中使用类似的方法来检测指向给定目的地的路径上的最大MTU。这种技术称为路径MTU发现[**RFC
    1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)。
- en: When a TCP segment is transported in an IP packet that is fragmented in the
    network, the loss of a single fragment forces TCP to retransmit the entire segment
    (and thus all the fragments). If TCP was able to send only packets that do not
    require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 TCP 段在网络中通过一个分片的数据包传输时，单个分片丢失会迫使 TCP 重新传输整个段（以及所有分片）。如果 TCP 能够发送不需要在网络中分片的数据包，它只需重新传输在网络中丢失的信息。此外，如
    [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) 中讨论的那样，IP 重组在高速情况下会带来几个挑战。使用
    IP 分片允许 UDP 应用程序交换大型消息，这会引发几个安全问题 [[KPS2003]](../bibliography.html#kps2003)。
- en: ICMPv6 is used by TCP implementations to discover the largest MTU size that
    is allowed to reach a destination host without causing network fragmentation.
    A TCP implementation parses the Packets Too Big ICMP messages that it receives.
    These ICMP messages contain the MTU of the router’s outgoing link in their Data
    field. Upon reception of such an ICMP message, the source TCP implementation adjusts
    its Maximum Segment Size (MSS) so that the packets containing the segments that
    it sends can be forwarded by this router without requiring fragmentation.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 被 TCP 实现用来发现允许到达目的主机而不引起网络分片的最大 MTU 大小。TCP 实现解析它接收到的 Packets Too Big
    ICMP 消息。这些 ICMP 消息在其数据字段中包含路由器出链路的 MTU。在接收到此类 ICMP 消息后，源 TCP 实现调整其最大分段大小（MSS），以便包含它发送的段的数据包可以由该路由器转发，而无需分片。
- en: 'Two types of informational ICMPv6 messages are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    : echo request and echo reply, which are used to test the reachability of a destination
    by using *ping6(8)*. Each host is supposed to reply with an ICMP Echo reply message
    when it receives an ICMP Echo request message. A sample usage of *ping6(8)* is
    shown below.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中定义了两种类型的信息性
    ICMPv6 消息：回显请求和回显回复，它们用于通过 *ping6(8)* 测试目的地的可达性。当主机接收到 ICMP Echo 请求消息时，它应该回复一个
    ICMP Echo 回复消息。以下是一个 *ping6(8)* 的示例用法。
- en: '[PRE4]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another very useful debugging tool is *traceroute6(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the Time exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose Hop Limit is set to `1` it is forced to return
    to the sending host a Time exceeded ICMP message containing the header and the
    first bytes of the discarded packet. To discover all routers on a network path,
    a simple solution is to first send a packet whose Hop Limit is set to 1, then
    a packet whose Hop Limit is set to 2, etc. A sample traceroute6 output is shown
    below.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试工具是 *traceroute6(8)*。traceroute 手册页将此工具描述为“打印数据包到达网络主机的路由”。traceroute
    使用 Time exceeded ICMP 消息来发现通往目的地的路径上的中间路由器。traceroute 的原理非常简单。当一个路由器收到一个 Hop Limit
    设置为 `1` 的 IP 数据包时，它被迫向发送主机返回一个包含头部和丢弃数据包的前几个字节的 Time exceeded ICMP 消息。为了发现网络路径上的所有路由器，一个简单的解决方案是首先发送一个
    Hop Limit 设置为 1 的数据包，然后发送一个 Hop Limit 设置为 2 的数据包，依此类推。以下是一个 traceroute6 输出的示例。
- en: '[PRE5]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rate limitation of ICMP messages
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 消息速率限制
- en: High-end hardware based routers use special purpose chips on their interfaces
    to forward IPv6 packets at line rate. These chips are optimized to process correct
    IP packets. They are not able to create ICMP messages at line rate. When such
    a chip receives an IP packet that triggers an ICMP message, it interrupts the
    main CPU of the router and the software running on this CPU processes the packet.
    This CPU is much slower than the hardware acceleration found on the interfaces
    [[Gill2004]](../bibliography.html#gill2004). It would be overloaded if it had
    to process IP packets at line rate and generate one ICMP message for each received
    packet. To protect this CPU, high-end routers limit the rate at which the hardware
    can interrupt the main CPU and thus the rate at which ICMP messages can be generated.
    This implies that not all erroneous IP packets cause the transmission of an ICMP
    message. The risk of overloading the main CPU of the router is also the reason
    why using hop-by-hop IPv6 options, including the router alert option is discouraged
    [[#falert]_](#id49).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 高端硬件路由器在其接口上使用专用芯片以线路速率转发 IPv6 数据包。这些芯片针对处理正确的 IP 数据包进行了优化。它们无法以线路速率创建 ICMP
    消息。当这样的芯片收到触发 ICMP 消息的 IP 数据包时，它会中断路由器的主 CPU，并且在此 CPU 上运行的软件处理该数据包。这个 CPU 比接口上发现的硬件加速要慢得多
    [[Gill2004]](../bibliography.html#gill2004)。如果它必须以线路速率处理 IP 数据包并为每个接收到的数据包生成一个
    ICMP 消息，它将会过载。为了保护这个 CPU，高端路由器限制了硬件中断主 CPU 的速率，从而限制了 ICMP 消息的生成速率。这意味着并非所有错误的
    IP 数据包都会导致 ICMP 消息的传输。路由器主 CPU 过载的风险也是不建议使用跳到跳 IPv6 选项（包括路由器警报选项）的原因 [[#falert]_](#id49)。
- en: Footnotes
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: IP version 4[#](#ip-version-4 "Link to this heading")
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP 版本 4[#](#ip-version-4 "链接到这个标题")
- en: 'IP version 4 is the data plane protocol of the network layer in the TCP/IP
    protocol suite. The design of IP version 4 was based on the following assumptions
    :'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: IP 版本 4 是 TCP/IP 协议套件中网络层数据平面协议。IP 版本 4 的设计基于以下假设：
- en: IP should provide an unreliable connectionless service (TCP provides reliability
    when required by the application)
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 应该提供不可靠的无连接服务（当应用程序需要时，TCP 提供可靠性）
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP operates with the datagram transmission mode
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 使用数据报传输模式
- en: ''
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP addresses have a fixed size of 32 bits
  id: totrans-426
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 地址具有固定的 32 位大小
- en: ''
  id: totrans-427
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-428
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP must be usable above different types of datalink layers
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 必须能在不同类型的链路层上使用
- en: ''
  id: totrans-430
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-431
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP hosts exchange variable length packets
  id: totrans-432
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 主机交换可变长度的数据包
- en: IPv4 addresses are encoded as a 32 bits field. IPv4 addresses are often represented
    in dotted-decimal format as a sequence of four integers separated by a dot. The
    first integer is the decimal representation of the most significant byte of the
    32 bits IPv4 address, … For example,
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址编码为 32 位字段。IPv4 地址通常以点分十进制格式表示，为四个整数序列，由点分隔。第一个整数是 32 位 IPv4 地址最高有效字节的十进制表示，…
    例如，
- en: 1.2.3.4 corresponds to 00000001000000100000001100000100
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.2.3.4 对应于 00000001000000100000001100000100
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 127.0.0.1 corresponds to 01111111000000000000000000000001
  id: totrans-437
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.1 对应于 01111111000000000000000000000001
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 255.255.255.255 corresponds to 11111111111111111111111111111111
  id: totrans-440
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 255.255.255.255 对应于 11111111111111111111111111111111
- en: An IPv4 address is used to identify an interface on a router or a host. A router
    has thus as many IPv4 addresses as the number of interfaces that it has in the
    datalink layer. Most hosts have a single datalink layer interface and thus have
    a single IPv4 address. However, with the growth of wireless, more and more hosts
    have several datalink layer interfaces (e.g. an Ethernet interface and a WiFi
    interface). These hosts are said to be multihomed. A multihomed host with two
    interfaces has thus two IPv4 addresses.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv4 地址用于标识路由器或主机上的接口。因此，路由器具有与它在链路层上具有的接口数量一样多的 IPv4 地址。大多数主机只有一个链路层接口，因此只有一个
    IPv4 地址。然而，随着无线技术的发展，越来越多的主机有多个链路层接口（例如，一个以太网接口和一个 WiFi 接口）。这些主机被称为多宿主。具有两个接口的多宿主主机因此有两个
    IPv4 地址。
- en: Many Internet hosts are attached to [Local Area Networks](../glossary.html#term-Local-Area-Networks)
    (LANs) such as Wi-Fi or Ethernet networks. We will describe the operation of these
    networks in more details in the second part of the book, but at this stage, the
    important point to know about these LANs is that they provide a connectionless
    datalink layer service. On a LAN, each device is identified by a unique 48 bits
    long address that is called a [MAC address](../glossary.html#term-MAC-address)
    (MAC stands for [Medium Access Control](../glossary.html#term-Medium-Access-Control)
    that will be explained in details in the second part). To ensure the unicity of
    the MAC addresses, these addresses are usually hardwired directly on the network
    interface cards. Each vendor of network cards ensures that all the interfaces
    that it sells have a unique MAC address. The devices attached a LAN can exchanged
    frames easily. A [frame](../glossary.html#term-frame) is a sequence of bytes that
    starts with a fixed-length header followed by a payload and for some types of
    LANs a trailer. The frame header contains the MAC address of the source of the
    frame and the MAC address of the destination of the frame. The frame payload carries
    the information exchanged and the trailer can contain a CRC to detect transmission
    errors or other types of control information.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网主机连接到[局域网](../glossary.html#term-Local-Area-Networks)（LANs），例如Wi-Fi或以太网网络。我们将在本书的第二部分更详细地描述这些网络的运行情况，但在此阶段，关于这些LANs的重要一点是它们提供无连接的数据链路层服务。在LAN中，每个设备都由一个唯一的48位长地址标识，这个地址被称为[MAC地址](../glossary.html#term-MAC-address)（MAC代表[介质访问控制](../glossary.html#term-Medium-Access-Control)，将在第二部分中详细解释）。为了确保MAC地址的唯一性，这些地址通常直接硬编码在网络接口卡上。每个网络卡供应商都确保它销售的每个接口都有一个唯一的MAC地址。连接到LAN的设备可以轻松交换帧。一个[帧](../glossary.html#term-frame)是一系列字节，以固定长度的头部开始，后面是有效载荷，对于某些类型的LAN，还有尾部。帧头部包含帧的源MAC地址和目标MAC地址。帧有效载荷携带交换的信息，尾部可以包含CRC以检测传输错误或其他类型的控制信息。
- en: '![../_images/frame-ip.svg](../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/frame-ip.svg](../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png)'
- en: Fig. 109 A datalink layer frame containing an IPv4 packet[#](#id31 "Link to
    this image")
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图109 包含IPv4数据包的数据链路层帧[#](#id31 "链接到这张图片")
- en: When several hosts are attached to the same LAN, they can quickly exchange IP
    packets by placing these packets inside datalink layer frames. If host A knows
    the MAC address of host B, it can send an IP packet as the payload of a frame
    whose source MAC address is its own MAC address and destination MAC address is
    B’s MAC address. We will detail later how a host can automatically learn the MAC
    address of another host.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个主机连接到同一LAN时，它们可以通过将这些数据包放入数据链路层帧中来快速交换IP数据包。如果主机A知道主机B的MAC地址，它可以发送一个IP数据包作为帧的有效载荷，其源MAC地址是它自己的MAC地址，目标MAC地址是B的MAC地址。我们将在后面详细说明主机如何自动学习另一个主机的MAC地址。
- en: When a host is attached to a LAN, it can directly send packets to the other
    hosts attached to the same LAN. To reach remote hosts, it must first send its
    packets to a router, also attached to the LAN. The router will be able to forward
    the packet to other routers such that it reaches its final destination.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机连接到LAN时，它可以直接向同一LAN上连接的其他主机发送数据包。要到达远程主机，它必须首先将其数据包发送到也连接到LAN的网关。网关将能够将数据包转发到其他网关，以便到达其最终目的地。
- en: When a host attached to a LAN sends an IP packet, it needs to know whether the
    destination is attached to the same LAN or not. If the destination is attached
    to the same LAN, the host can simply place the packet inside a frame and us the
    datalink layer to deliver it directly to its final destination. Otherwise, the
    host must the datalink layer to send the packet inside a frame to the LAN router
    that will take care of the packet. IPv4 and IPv6 solve this problem by grouping
    IP addresses in subnets. An [IP subnet](../glossary.html#term-IP-subnet) is the
    set of all IP addresses that have the same prefix. It is represented as an IP
    address followed by n, the number of bits in the common prefix.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到LAN的主机发送IP数据包时，它需要知道目标是否连接到同一LAN。如果目标连接到同一LAN，主机只需将数据包放入帧中，并使用数据链路层直接将其发送到最终目的地。否则，主机必须使用数据链路层将数据包放入帧中发送到LAN网关，由网关负责处理数据包。IPv4和IPv6通过将IP地址分组到子网中解决了这个问题。一个[IP子网](../glossary.html#term-IP-subnet)是具有相同前缀的所有IP地址的集合。它表示为一个IP地址后跟n，表示公共前缀中的位数。
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high order bits of the
    address and the host identifier is encoded in the low order bits of the address.
    This is illustrated below with a 22 bits subnetwork identifier shown in blue and
    a 12 bits host identifier in red.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IPv4地址由两部分组成：子网标识符和主机标识符。子网标识符由地址的高阶位组成，而主机标识符编码在地址的低阶位中。下面用22位子网标识符（蓝色）和12位主机标识符（红色）说明了这一点。
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
- en: Fig. 110 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图110 IPv4地址内的子网（蓝色）和主机标识符（红色）
- en: A subnet identifier or IPv4 prefix is usually [[1]](#fnetmask) represented as
    A.B.C.D/p where A.B.C.D is the network address obtained by concatenating the subnet
    identifier with a host identifier containing only 0 and p is the length of the
    subnet identifier in bits. The table below provides examples of IP subnets.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 子网标识符或IPv4前缀通常表示为A.B.C.D/p，其中A.B.C.D是通过将子网标识符与只包含0的主机标识符连接起来得到的网络地址，p是子网标识符的位数长度。下表提供了IP子网的示例。
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 子网 | 地址数量 | 最小地址 | 最大地址 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
- en: Note
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Class A, B, or C addresses
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: A类、B类或C类地址
- en: 'Today’s IPv4 implementations use variable-length subnets defined in [**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html). With variable-length
    subnets, the subnet identifier can be any size, from 1 to 31 bits. Variable-length
    subnets allow the network operators to use a subnet that better matches the number
    of hosts that are placed inside the subnet. Before the publication of [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html),
    IPv4 address blocks were divided in classes of addresses. [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)
    defined three classes of IPv4 addresses depending on their high order bits:'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 今天IPv4的实现使用的是在[**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)中定义的可变长度子网。可变长度子网允许子网标识符的大小从1位到31位不等。可变长度子网使得网络操作员能够使用更符合子网内主机数量的子网。在[**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)发布之前，IPv4地址块是根据地址类别划分的。[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)根据高阶位定义了三种IPv4地址类别：
- en: ''
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Class A addresses are the addresses whose high order bit is set to zero. The
    high order byte of this address was the network identifier and the 24 low order
    bits the host identifier. They correspond to today’s `\8` subnets.
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A类地址是那些高阶位设置为0的地址。这个地址的高阶字节是网络标识符，24个低阶位是主机标识符。它们对应于今天的`\8`子网。
- en: ''
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class B addresses are the addresses whose two high order bits are set to one
    followed by zero. The next fourteen bits are the network identifier and the low
    order sixteen bits the host identifier. They correspond to today’s `/16` subnets.
  id: totrans-467
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B类地址是那些高阶两位设置为1后跟0的地址。接下来的十四位是网络标识符，低阶十六位是主机标识符。它们对应于今天的`/16`子网。
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class C addresses are the addresses whose three high order bits are set to one
    followed by one and then zero. The next fourteen bits are the network identifier
    and the low order twenty four bits the host identifier. They correspond to today’s
    `/24` subnets.
  id: totrans-470
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: C类地址是那些高阶三位设置为1后跟1再跟0的地址。接下来的十四位是网络标识符，低阶二十四位是主机标识符。它们对应于今天的`/24`子网。
- en: Initially, address blocks were allocated based on the address class required.
    Large companies, network providers and some universities asked for a Class A addresses
    and obtained it. Many universities requested a Class B address. However, this
    allocation was inefficient as Class A address blocks are much larger than the
    needs of most enterprises while Class C are too small. [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)
    suppressed this inefficient allocation. Nowadays, the IPv4 addressing space is
    almost fully utilized, except some reserved blocks. The [IPv4 Address Report](https://ipv4.potaroo.net/)
    provides a detailed report on the evolution of the allocated IPv4 addressing space.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，地址块是根据所需的地址类别分配的。大型公司、网络提供商和一些大学请求A类地址并获得了它。许多大学请求B类地址。然而，这种分配效率低下，因为A类地址块比大多数企业的需求大得多，而C类地址又太小。[**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)抑制了这种低效的分配。如今，IPv4地址空间几乎被完全利用，除了一些保留块。[IPv4地址报告](https://ipv4.potaroo.net/)提供了关于分配的IPv4地址空间演变的详细报告。
- en: Note
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Special IPv4 addresses
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊IPv4地址
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in [**RFC 5735**](https://datatracker.ietf.org/doc/html/rfc5735.html).
    These include :'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数单播IPv4地址可以出现在全球互联网上的数据包的源地址和目的地址中。然而，值得注意的是，一些IPv4地址块有特殊用途，如[**RFC 5735**](https://datatracker.ietf.org/doc/html/rfc5735.html)中所述。这些包括：
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.0.0.0/8，保留用于自识别。此块中的一个常见地址是0.0.0.0，有时在主机启动且尚未知道其IPv4地址时使用。
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.0/8，保留用于环回地址。每个实现IPv4的主机都必须有一个环回接口（即未连接到数据链路层）。按照惯例，IPv4地址127.0.0.1分配给此接口。这允许主机上运行的过程使用TCP/IP来联系同一主机上运行的其他过程。这对于测试目的非常有用。
- en: 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0/8、172.16.0.0/12和192.168.0.0/16保留用于不直接连接到互联网的私有网络。这些地址通常被称为私有地址或[**RFC
    1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)地址。
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 169.254.0.0/16用于链路本地地址[**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。一些主机在连接到未按预期分配地址的网络时使用此块中的地址。
- en: IPv4 packets[#](#ipv4-packets "Link to this heading")
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4数据包[#](#ipv4-packets "链接到此标题")
- en: The IPv4 packet format was defined in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    It is shown in [Fig. 111](#fig-ipv4-header-detail). Apart from a few clarifications
    and some backward compatible changes, the IPv4 packet format did not change significantly
    since the publication of [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    All IPv4 packets use the 20 bytes header shown in figure [Fig. 111](#fig-ipv4-header-detail).
    Some IPv4 packets contain an optional header extension that is described later.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包格式在[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)中定义。它在[图111](#fig-ipv4-header-detail)中显示。除了少数澄清和一些向后兼容的更改外，自[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)发布以来，IPv4数据包格式没有发生重大变化。所有IPv4数据包都使用图[图111](#fig-ipv4-header-detail)中所示的20字节头部。一些IPv4数据包包含一个可选的头部扩展，将在后面描述。
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
- en: Fig. 111 The IP version 4 header[#](#id33 "Link to this image")
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图111 IP版本4头部[#](#id33 "链接到此图像")
- en: 'The main fields of the IPv4 header are :'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部的主要字段包括：
- en: a 4 bits version that indicates the version of IP used to build the header.
    Using a version field in the header allows the network layer protocol to evolve.
  id: totrans-484
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4位的版本号，指示构建头部所使用的IP版本。在头部中使用版本字段允许网络层协议进行演变。
- en: ''
  id: totrans-485
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-486
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 4 bits IP Header Length (IHL) that indicates the length of the IP header in
    32 bits words. This field allows IPv4 to use options if required, but as it is
    encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.
  id: totrans-487
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4位的IP头部长度（IHL）字段，指示IP头部在32位字中的长度。该字段允许IPv4在需要时使用选项，但由于它编码为4位字段，IPv4头部不能超过64字节。
- en: ''
  id: totrans-488
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-489
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits DS field that is used for Quality of Service and whose usage is described
    later.
  id: totrans-490
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个8位的DS字段，用于服务质量，其用法将在后面描述。
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits Protocol field that indicates the transport layer protocol that must
    process the packet’s payload at the destination. Common values for this field
    [[2]](#fprotocolnumber) are 6 for TCP and 17 for UDP
  id: totrans-493
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个8位的协议字段，指示必须在目的地处理数据包有效载荷的传输层协议。该字段的常见值 [[2]](#fprotocolnumber) 为TCP的6和UDP的17
- en: ''
  id: totrans-494
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-495
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits length field that indicates the total length of the entire IPv4 packet
    (header and payload) in bytes. This implies that an IPv4 packet cannot be longer
    than 65535 bytes.
  id: totrans-496
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的长度字段，指示整个IPv4数据包（头部和有效载荷）的总长度，以字节为单位。这意味着IPv4数据包不能超过65535字节。
- en: ''
  id: totrans-497
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-498
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits source address field that contains the IPv4 address of the source
    host
  id: totrans-499
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位的源地址字段，包含源主机的IPv4地址
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits destination address field that contains the IPv4 address of the destination
    host
  id: totrans-502
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位的目的地址字段，包含目的主机的IPv4地址
- en: ''
  id: totrans-503
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-504
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits checksum that protects only the IPv4 header against transmission errors
  id: totrans-505
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的校验和，仅用于保护IPv4头部免受传输错误的影响
- en: The other fields of the IPv4 header are used for specific purposes. The first
    is the 8 bits Time To Live (TTL) field. This field is used by IPv4 to avoid the
    risk of having an IPv4 packet caught in an infinite loop due to a transient or
    permanent error in routing tables [[3]](#fttl). We will discuss in part two why
    such problems can happen. The TTL field of the IPv4 header ensures that even if
    there are forwarding loops in the network, packets will not loop forever. Hosts
    send their IPv4 packets with a positive TTL (usually 64 or more [[4]](#finitialttl)).
    When a router receives an IPv4 packet, it first decrements the TTL by one. If
    the TTL becomes 0, the packet is discarded and a message is sent back to the packet’s
    source (see section [ICMP](#icmp)). Otherwise, the router performs a lookup in
    its forwarding table to forward the packet.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部的其他字段用于特定目的。第一个是8位的生存时间（TTL）字段。该字段由IPv4用于避免因路由表中的暂时性或永久性错误而导致IPv4数据包陷入无限循环的风险
    [[3]](#fttl)。我们将在第二部分讨论为什么会出现这样的问题。IPv4头部的TTL字段确保即使网络中存在转发循环，数据包也不会无限循环。主机发送其IPv4数据包时，会带上一个正的TTL（通常是64或更多
    [[4]](#finitialttl)）。当一个路由器接收到一个IPv4数据包时，它首先将TTL减一。如果TTL变为0，则丢弃该数据包，并向数据包的源发送一条消息（见[ICMP](#icmp)部分）。否则，路由器在其转发表中查找以转发数据包。
- en: A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is
    used above many very different datalink layers. Each datalink layer has its own
    characteristics and as indicated earlier, each datalink layer is characterized
    by a maximum frame size. From IP’s point of view, a datalink layer interface is
    characterized by its Maximum Transmission Unit (MTU). The MTU of an interface
    is the largest IPv4 packet (including header) that it can send. The table below
    provides some common MTU sizes [[5]](#f6lowpan).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的第二个问题是数据链路层的异构性。IPv4被用于许多非常不同的数据链路层之上。每个数据链路层都有其自身的特性，如前所述，每个数据链路层以其最大帧大小为特征。从IP的角度来看，数据链路层接口以其最大传输单元（MTU）为特征。接口的MTU是它可以发送的最大IPv4数据包（包括头部）。下表提供了一些常见的MTU大小
    [[5]](#f6lowpan)。
- en: '| Datalink layer | MTU |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | MTU |'
- en: '| Ethernet | 1500 bytes |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 以太网 | 1500 字节 |'
- en: '| WiFi | 2272 bytes |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 2272 字节 |'
- en: '| ATM (AAL5) | 9180 bytes |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| ATM (AAL5) | 9180 字节 |'
- en: '| 802.15.4 | 102 or 81 bytes |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 802.15.4 | 102 或 81 字节 |'
- en: '| Token Ring | 4464 bytes |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 令牌环 | 4464 字节 |'
- en: '| FDDI | 4352 bytes |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| FDDI | 4352 字节 |'
- en: Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink
    layer technologies that are used today are able to send a 64 KBytes IPv4 packet
    inside a frame. Consider a client attached to a Token Ring network that wishes
    to send packets to a server connected to an Ethernet network. The client could
    send a 4 KBytes packet that would need to be fragmented inside the network to
    reach the server.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上IPv4主机可以发送长达64 KBytes的数据包，但今天使用的少数数据链路层技术能够在一个帧内发送64 KBytes的IPv4数据包。考虑一个连接到令牌环网络的客户端，它希望向连接到以太网网络的服务器发送数据包。客户端可以发送一个4
    KBytes的数据包，该数据包需要在网络内部分片才能到达服务器。
- en: To solve these problems, IPv4 includes a packet fragmentation and reassembly
    mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if
    the packet is too long to be sent via the datalink layer. In IPv4, fragmentation
    is completely performed in the IP layer and a large IPv4 is fragmented into two
    or more IPv4 packets (called fragments). The IPv4 fragments of a large packet
    are normal IPv4 packets that are forwarded towards the destination of the large
    packet by intermediate routers.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，IPv4包括一个数据包分片和重组机制。如果数据包太长而无法通过数据链路层发送，主机和中间路由器都可能分片IPv4数据包。在IPv4中，分片完全在IP层完成，一个大IPv4数据包被分成两个或更多个IPv4数据包（称为片段）。大包的IPv4片段是正常的IPv4数据包，由中间路由器转发到大数据包的目标。
- en: 'The IPv4 fragmentation mechanism relies on four fields of the IPv4 header :
    Length, Identification, the flags and the Fragment Offset. The IPv4 header contains
    two flags : More fragments and Don’t Fragment (DF). When the DF flag is set, this
    indicates that the packet cannot be fragmented.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4分片机制依赖于IPv4头部中的四个字段：长度、标识、标志和分片偏移。IPv4头部包含两个标志：更多片段和不要分片（DF）。当DF标志被设置时，这表示数据包不能被分片。
- en: The basic operation of the IPv4 fragmentation is as follows. A large packet
    is fragmented into two or more fragments. The size of all fragments, except the
    last one, is equal to the Maximum Transmission Unit of the link used to forward
    the packet. Each IPv4 packet contains a 16 bits Identification field. When a packet
    is fragmented, the Identification of the large packet is copied in all fragments
    to allow the destination to reassemble the received fragments together. In each
    fragment, the Fragment Offset indicates, in units of 8 bytes, the position of
    the payload of the fragment in the payload of the original packet. The Length
    field in each fragment indicates the length of the payload of the fragment as
    in a normal IPv4 packet. Finally, the More fragments flag is set only in the last
    fragment of a large packet.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4分片的基本操作如下。一个大的数据包被分成两个或更多个片段。除了最后一个片段外，所有片段的大小等于用于转发数据包的链路的最大传输单元。每个IPv4数据包包含一个16位的标识字段。当一个数据包被分片时，大包的标识被复制到所有片段中，以便目标能够将接收到的片段重新组装。在每个片段中，分片偏移指示，以8字节为单位，片段有效载荷在原始数据包有效载荷中的位置。每个片段中的长度字段指示片段有效载荷的长度，就像一个正常的IPv4数据包一样。最后，只有在大数据包的最后一个片段中设置更多片段标志。
- en: The following pseudo-code details the IPv4 fragmentation algorithm, assuming
    that the packet does not contain IP options.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码详细说明了IPv4分片算法，假设数据包不包含IP选项。
- en: '[PRE6]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The fragments of an IPv4 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包的片段可能以任何顺序到达目的地，因为每个片段在网络中独立转发，可能遵循不同的路径。此外，一些片段可能会丢失，永远不会到达目的地。
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv4 packet is a fragment
    or not by checking the value of the More fragments flag and the Fragment Offset.
    If the Fragment Offset is set to 0 and the More fragments flag is reset, the received
    packet has not been fragmented. Otherwise, the packet has been fragmented and
    must be reassembled. The reassembly algorithm relies on the Identification field
    of the received fragments to associate a fragment with the corresponding packet
    being reassembled. Furthermore, the Fragment Offset field indicates the position
    of the fragment payload in the original non fragmented packet. Finally, the packet
    with the More fragments flag reset allows the destination to determine the total
    length of the original no fragmented packet.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 目的主机使用的重组算法大致如下。首先，目的地可以通过检查更多分片标志和分片偏移量的值来验证接收到的IPv4数据包是否为分片。如果分片偏移量设置为0且更多分片标志被重置，则接收到的数据包没有被分片。否则，数据包已被分片，必须进行重组。重组算法依赖于接收到的分片中的标识字段，以将分片与正在重组的相应数据包关联起来。此外，分片偏移量字段指示分片有效载荷在原始未分片数据包中的位置。最后，更多分片标志被重置的数据包允许目的地确定原始未分片数据包的总长度。
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bound the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重组算法必须处理IP网络的不可靠性。这意味着一个分片可能会被重复，或者一个分片可能永远无法到达目的地。由于分片偏移量，目的地可以轻松检测到分片重复。为了处理分片丢失，重组算法必须在数据包被重组期间限制其缓冲区中存储分片的时间。这可以通过在接收到数据包的第一个分片时启动计时器来实现。如果在计时器到期之前数据包没有被重组，则丢弃所有分片，并认为数据包已丢失。
- en: The original IP specification, in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html),
    defined several types of options that can be added to the IP header. Each option
    is encoded using a type length value format. They are not widely used today. Additional
    details may be found in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 原始IP规范，在[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)中，定义了可以添加到IP头部的一些选项类型。每个选项都使用类型长度值格式进行编码。它们今天并不广泛使用。更多详细信息可以在[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)中找到。
- en: IPv4 packets[#](#ipv4-packets "Link to this heading")
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4数据包[#](#ipv4-packets "链接到此标题")
- en: The IPv4 packet format was defined in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    It is shown in [Fig. 111](#fig-ipv4-header-detail). Apart from a few clarifications
    and some backward compatible changes, the IPv4 packet format did not change significantly
    since the publication of [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    All IPv4 packets use the 20 bytes header shown in figure [Fig. 111](#fig-ipv4-header-detail).
    Some IPv4 packets contain an optional header extension that is described later.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包格式在[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)中定义。它在[图.
    111](#fig-ipv4-header-detail)中显示。除了少数澄清和一些向后兼容的更改外，自[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)发布以来，IPv4数据包格式没有发生重大变化。所有IPv4数据包都使用图[图.
    111](#fig-ipv4-header-detail)中显示的20字节头部。一些IPv4数据包包含一个可选的头部扩展，将在后面进行描述。
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
- en: Fig. 111 The IP version 4 header[#](#id33 "Link to this image")
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 图. 111 IP版本4头部[#](#id33 "链接到此图像")
- en: 'The main fields of the IPv4 header are :'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部的主要字段包括：
- en: a 4 bits version that indicates the version of IP used to build the header.
    Using a version field in the header allows the network layer protocol to evolve.
  id: totrans-530
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: a 4位版本号，表示构建头部所使用的IP版本。在头部中使用版本字段允许网络层协议进行演变。
- en: ''
  id: totrans-531
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-532
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 4 bits IP Header Length (IHL) that indicates the length of the IP header in
    32 bits words. This field allows IPv4 to use options if required, but as it is
    encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.
  id: totrans-533
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4位IP头部长度（IHL）字段，表示IP头部以32位字为单位的长度。该字段允许IPv4在需要时使用选项，但由于它编码为一个4位字段，IPv4头部不能超过64字节。
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits DS field that is used for Quality of Service and whose usage is described
    later.
  id: totrans-536
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个8位的DS字段，用于服务质量，其用法将在后面描述。
- en: ''
  id: totrans-537
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-538
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits Protocol field that indicates the transport layer protocol that must
    process the packet’s payload at the destination. Common values for this field
    [[2]](#fprotocolnumber) are 6 for TCP and 17 for UDP
  id: totrans-539
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个8位的协议字段，表示必须在目的地处理分组有效载荷的传输层协议。此字段的常见值[[2]](#fprotocolnumber)为6（TCP）和17（UDP）。
- en: ''
  id: totrans-540
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits length field that indicates the total length of the entire IPv4 packet
    (header and payload) in bytes. This implies that an IPv4 packet cannot be longer
    than 65535 bytes.
  id: totrans-542
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位长度字段，表示整个IPv4分组（头部和有效载荷）的总长度（以字节为单位）。这意味着IPv4分组的长度不能超过65535字节。
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-544
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits source address field that contains the IPv4 address of the source
    host
  id: totrans-545
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位源地址字段，包含源主机的IPv4地址。
- en: ''
  id: totrans-546
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits destination address field that contains the IPv4 address of the destination
    host
  id: totrans-548
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位目的地址字段，包含目的主机的IPv4地址。
- en: ''
  id: totrans-549
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits checksum that protects only the IPv4 header against transmission errors
  id: totrans-551
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的校验和字段，仅用于保护IPv4头部免受传输错误的影响
- en: The other fields of the IPv4 header are used for specific purposes. The first
    is the 8 bits Time To Live (TTL) field. This field is used by IPv4 to avoid the
    risk of having an IPv4 packet caught in an infinite loop due to a transient or
    permanent error in routing tables [[3]](#fttl). We will discuss in part two why
    such problems can happen. The TTL field of the IPv4 header ensures that even if
    there are forwarding loops in the network, packets will not loop forever. Hosts
    send their IPv4 packets with a positive TTL (usually 64 or more [[4]](#finitialttl)).
    When a router receives an IPv4 packet, it first decrements the TTL by one. If
    the TTL becomes 0, the packet is discarded and a message is sent back to the packet’s
    source (see section [ICMP](#icmp)). Otherwise, the router performs a lookup in
    its forwarding table to forward the packet.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部的其他字段用于特定目的。第一个是8位生存时间（TTL）字段。该字段由IPv4用于避免由于路由表中的暂时性或永久性错误而导致IPv4分组陷入无限循环的风险[[3]](#fttl)。我们将在第二部分讨论为什么会出现这样的问题。IPv4头部的TTL字段确保即使网络中存在转发循环，分组也不会无限循环。主机以正的TTL（通常是64或更多[[4]](#finitialttl)）发送它们的IPv4分组。当路由器接收到一个IPv4分组时，它首先将TTL减一。如果TTL变为0，则丢弃该分组，并向分组源发送一条消息（见[ICMP](#icmp)部分）。否则，路由器在其转发表中查找以转发分组。
- en: A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is
    used above many very different datalink layers. Each datalink layer has its own
    characteristics and as indicated earlier, each datalink layer is characterized
    by a maximum frame size. From IP’s point of view, a datalink layer interface is
    characterized by its Maximum Transmission Unit (MTU). The MTU of an interface
    is the largest IPv4 packet (including header) that it can send. The table below
    provides some common MTU sizes [[5]](#f6lowpan).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的第二个问题是数据链路层的异构性。IPv4在许多非常不同的数据链路层之上使用。每个数据链路层都有自己的特性，如前所述，每个数据链路层由最大帧大小来表征。从IP的角度来看，数据链路层接口由其最大传输单元（MTU）来表征。接口的MTU是它可以发送的最大IPv4分组（包括头部）。下表提供了一些常见的MTU大小[[5]](#f6lowpan)。
- en: '| Datalink layer | MTU |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | MTU |'
- en: '| Ethernet | 1500 bytes |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 以太网 | 1500字节 |'
- en: '| WiFi | 2272 bytes |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 2272字节 |'
- en: '| ATM (AAL5) | 9180 bytes |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| ATM (AAL5) | 9180字节 |'
- en: '| 802.15.4 | 102 or 81 bytes |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 802.15.4 | 102或81字节 |'
- en: '| Token Ring | 4464 bytes |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 令牌环 | 4464字节 |'
- en: '| FDDI | 4352 bytes |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| FDDI | 4352字节 |'
- en: Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink
    layer technologies that are used today are able to send a 64 KBytes IPv4 packet
    inside a frame. Consider a client attached to a Token Ring network that wishes
    to send packets to a server connected to an Ethernet network. The client could
    send a 4 KBytes packet that would need to be fragmented inside the network to
    reach the server.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从理论上讲，IPv4主机可以发送长达64 KBytes的分组，但今天使用的少数数据链路层技术能够在一个帧内发送64 KBytes的IPv4分组。考虑一个连接到令牌环网络的客户端，它希望向连接到以太网网络的服务器发送分组。客户端可以发送一个4
    KBytes的分组，该分组需要在网络内部进行分片才能到达服务器。
- en: To solve these problems, IPv4 includes a packet fragmentation and reassembly
    mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if
    the packet is too long to be sent via the datalink layer. In IPv4, fragmentation
    is completely performed in the IP layer and a large IPv4 is fragmented into two
    or more IPv4 packets (called fragments). The IPv4 fragments of a large packet
    are normal IPv4 packets that are forwarded towards the destination of the large
    packet by intermediate routers.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，IPv4包括一个数据包分片和重组机制。如果数据包太长而无法通过数据链路层发送，主机和中间路由器都可能对IPv4数据包进行分片。在IPv4中，分片完全在IP层完成，一个大的IPv4数据包被分成两个或更多IPv4数据包（称为分片）。大包的分片是正常的IPv4数据包，由中间路由器转发到大数据包的目的地。
- en: 'The IPv4 fragmentation mechanism relies on four fields of the IPv4 header :
    Length, Identification, the flags and the Fragment Offset. The IPv4 header contains
    two flags : More fragments and Don’t Fragment (DF). When the DF flag is set, this
    indicates that the packet cannot be fragmented.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4分片机制依赖于IPv4头部中的四个字段：长度、标识、标志和分片偏移。IPv4头部包含两个标志：更多分片和不要分片（DF）。当DF标志被设置时，这表示数据包不能被分片。
- en: The basic operation of the IPv4 fragmentation is as follows. A large packet
    is fragmented into two or more fragments. The size of all fragments, except the
    last one, is equal to the Maximum Transmission Unit of the link used to forward
    the packet. Each IPv4 packet contains a 16 bits Identification field. When a packet
    is fragmented, the Identification of the large packet is copied in all fragments
    to allow the destination to reassemble the received fragments together. In each
    fragment, the Fragment Offset indicates, in units of 8 bytes, the position of
    the payload of the fragment in the payload of the original packet. The Length
    field in each fragment indicates the length of the payload of the fragment as
    in a normal IPv4 packet. Finally, the More fragments flag is set only in the last
    fragment of a large packet.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4分片的基本操作如下。一个大数据包被分成两个或更多分片。除了最后一个分片外，所有分片的大小都等于用于转发数据包的链路的最大传输单元（MTU）。每个IPv4数据包包含一个16位的标识字段。当一个数据包被分片时，大数据包的标识被复制到所有分片中，以便目的地可以将接收到的分片重新组装在一起。在每个分片中，分片偏移以8字节为单位指示分片有效载荷在原始数据包有效载荷中的位置。每个分片中的长度字段指示分片有效载荷的长度，就像一个正常的IPv4数据包一样。最后，更多分片标志仅在大型数据包的最后一个分片中设置。
- en: The following pseudo-code details the IPv4 fragmentation algorithm, assuming
    that the packet does not contain IP options.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码详细说明了IPv4分片算法，假设数据包不包含IP选项。
- en: '[PRE7]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fragments of an IPv4 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据包的分片可能以任何顺序到达目的地，因为每个分片在网络中独立转发，可能遵循不同的路径。此外，一些分片可能丢失，永远不会到达目的地。
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv4 packet is a fragment
    or not by checking the value of the More fragments flag and the Fragment Offset.
    If the Fragment Offset is set to 0 and the More fragments flag is reset, the received
    packet has not been fragmented. Otherwise, the packet has been fragmented and
    must be reassembled. The reassembly algorithm relies on the Identification field
    of the received fragments to associate a fragment with the corresponding packet
    being reassembled. Furthermore, the Fragment Offset field indicates the position
    of the fragment payload in the original non fragmented packet. Finally, the packet
    with the More fragments flag reset allows the destination to determine the total
    length of the original no fragmented packet.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 目的主机使用的重组算法大致如下。首先，目的地可以通过检查更多分片标志和分片偏移的值来验证接收到的IPv4数据包是否为分片。如果分片偏移设置为0且更多分片标志被重置，则接收到的数据包没有被分片。否则，数据包已经被分片，必须进行重组。重组算法依赖于接收到的分片的标识字段来关联一个分片与正在重组的相应数据包。此外，分片偏移字段指示分片有效载荷在原始未分片数据包中的位置。最后，更多分片标志被重置的数据包允许目的地确定原始未分片数据包的总长度。
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bound the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重组算法必须处理IP网络的不可靠性。这意味着一个分片可能会被重复，或者一个分片可能永远无法到达目的地。由于分片偏移量，目的地可以轻松检测到分片重复。为了处理分片丢失，重组算法必须在数据包正在重组期间限制其缓冲区中存储分片的时间。这可以通过在接收到数据包的第一个分片时启动计时器来实现。如果在计时器到期之前数据包没有被重组，则所有分片都将被丢弃，并且数据包被视为丢失。
- en: The original IP specification, in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html),
    defined several types of options that can be added to the IP header. Each option
    is encoded using a type length value format. They are not widely used today. Additional
    details may be found in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 原始IP规范，在[**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)中，定义了可以添加到IP头部的一些选项类型。每个选项都使用类型长度值格式进行编码。它们今天并不广泛使用。更多详细信息可以在[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)中找到。
- en: '## ICMP version 4[#](#icmp-version-4 "Link to this heading")'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '## ICMP版本 4[#](#icmp-version-4 "链接到此标题")'
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMP is defined in [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html).
    ICMP messages are carried as the payload of IP packets (the protocol value reserved
    for ICMP is 1). [Fig. 112](#fig-icmpv4-header) illustrates the IPv4 header. An
    ICMP message is composed of an 8 byte header and a variable length payload that
    usually contains the first bytes of the packet that triggered the transmission
    of the ICMP message.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，中间路由器或目的地主机需要通知数据包的发送者处理数据包时发生的问题。在TCP/IP协议套件中，这种报告是通过互联网控制消息协议（ICMP）完成的。ICMP在[**RFC
    792**](https://datatracker.ietf.org/doc/html/rfc792.html)中定义。ICMP消息作为IP数据包的有效负载（为ICMP保留的协议值为1）传输。[图
    112](#fig-icmpv4-header)说明了IPv4头部。一个ICMP消息由一个8字节头部和一个可变长度的有效负载组成，通常包含触发ICMP消息传输的数据包的前几个字节。
- en: '[![../_images/icmpv4.png](../Images/c6f49e0d69bec409a194b8b0090a586c.png)](../_images/icmpv4.png)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/icmpv4.png](../Images/c6f49e0d69bec409a194b8b0090a586c.png)](../_images/icmpv4.png)'
- en: Fig. 112 ICMP version 4 [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html)[#](#id34
    "Link to this image")
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图 112 ICMP版本 4 [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html)[#](#id34
    "链接到此图像")
- en: In the ICMP header, the Type and Code fields indicate the type of problem that
    was detected by the sender of the ICMP message. The Checksum protects the entire
    ICMP message against transmission errors and the Data field contains additional
    information for some ICMP messages.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在ICMP头部，类型和代码字段指示发送ICMP消息的发送者检测到的问题类型。校验和保护整个ICMP消息免受传输错误的影响，而数据字段包含一些ICMP消息的附加信息。
- en: 'The main types of ICMP messages are :'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP消息的主要类型包括：
- en: 'Destination unreachable : a Destination unreachable ICMP message is sent when
    a packet cannot be delivered to its destination due to routing problems. Different
    types of non reachability are distinguished :'
  id: totrans-577
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地不可达：当数据包由于路由问题无法送达其目的地时，会发送一个目的地不可达的ICMP消息。区分不同类型的不可达性：
- en: ''
  id: totrans-578
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Network unreachable : this ICMP message is sent by a router that does not have
    a route for the subnet containing the destination address of the packet'
  id: totrans-580
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络不可达：此ICMP消息由没有为包含数据包目的地地址的子网提供路由的路由器发送
- en: ''
  id: totrans-581
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-582
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Host unreachable : this ICMP message is sent by a router that is attached to
    the subnet that contains the destination address of the packet, but this destination
    address cannot be reached at this time'
  id: totrans-583
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机不可达：此ICMP消息由连接到包含数据包目的地地址的子网的路由器发送，但此时无法到达该目的地地址
- en: ''
  id: totrans-584
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-585
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Protocol unreachable : this ICMP message is sent by a destination host that
    has received a packet, but does not support the transport protocol indicated in
    the packet’s Protocol field'
  id: totrans-586
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议不可达：此 ICMP 消息由接收了数据包但未支持数据包协议字段中指示的传输协议的目标主机发送。
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-588
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Port unreachable : this ICMP message is sent by a destination host that has
    received a packet destined to a port number, but no server process is bound to
    this port'
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口不可达：此 ICMP 消息由接收了发送到端口号的数据包但没有任何服务器进程绑定到该端口的目标主机发送。
- en: ''
  id: totrans-590
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-591
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fragmentation needed : this ICMP message is sent by a router that receives
    a packet with the Don’t Fragment flag set that is larger than the MTU of the outgoing
    interface'
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要分片：此 ICMP 消息由接收了设置了“不要分片”标志但大于出接口 MTU 的数据包的路由器发送。
- en: '*ping(8)* is often used by network operators to verify that a given IP address
    is reachable. Each host is supposed [[6]](#fpingproblems) to reply with an ICMP
    Echo reply message when its receives an ICMP Echo request message. A sample usage
    of *ping(8)* is shown below.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '*ping(8)* 通常被网络操作员用来验证给定的 IP 地址是否可达。每个主机都应该 [[6]](#fpingproblems) 在收到 ICMP
    Echo 请求消息时回复一个 ICMP Echo 回显消息。下面是 *ping(8)* 的一个示例用法。'
- en: '[PRE8]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another very useful debugging tool is *traceroute(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the TTL exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose TTL is set to 1 it decrements the TTL and
    is forced to return to the sending host a TTL exceeded ICMP message containing
    the header and the first bytes of the discarded IP packet. To discover all routers
    on a network path, a simple solution is to first send a packet whose TTL is set
    to 1, then a packet whose TTL is set to 2, etc. A sample traceroute output is
    shown below.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试工具是 *traceroute(8)*。traceroute 的 man 页面将此工具描述为“打印数据包到达网络主机的路由”。traceroute
    使用 TTL 超过 ICMP 消息来发现通往目标的路由器。traceroute 的原理非常简单。当一个路由器收到一个 TTL 设置为 1 的 IP 数据包时，它会递减
    TTL 并被迫向发送主机返回一个包含头部和丢弃的 IP 数据包前几个字节的 TTL 超过 ICMP 消息。为了发现网络路径上的所有路由器，一个简单的解决方案是首先发送一个
    TTL 设置为 1 的数据包，然后发送一个 TTL 设置为 2 的数据包，依此类推。下面是一个 traceroute 输出的示例。
- en: '[PRE9]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The above *traceroute(8)* output shows a 17 hops path between a host at UCLouvain
    and one of the main IETF servers. For each hop, traceroute provides the IPv4 address
    of the router that sent the ICMP message and the measured round-trip-time between
    the source and this router. traceroute sends three probes with each TTL value.
    In some cases, such as at the tenth hop above, the ICMP messages may be received
    from different addresses. This is usually because different packets from the same
    source have followed different paths [[7]](#ftraceroutemore) in the network.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 *traceroute(8)* 输出显示了 UCLouvain 的一个主机与 IETF 的一些主要服务器之间的 17 个跳数路径。对于每个跳数，traceroute
    提供了发送 ICMP 消息的路由器的 IPv4 地址以及源路由器与该路由器之间的往返时间。traceroute 使用每个 TTL 值发送三个探测。在某些情况下，例如上面的第十个跳数，可能会从不同的地址接收到
    ICMP 消息。这通常是因为来自同一源的不同数据包在网络中遵循了不同的路径 [[7]](#ftraceroutemore)。
- en: Another important utilization of ICMP messages is to discover the maximum MTU
    that can be used to reach a destination without fragmentation. As explained earlier,
    when an IPv4 router receives a packet that is larger than the MTU of the outgoing
    link, it must fragment the packet. Unfortunately, fragmentation is a complex operation
    and routers cannot perform it at line rate [[KM1995]](../bibliography.html#km1995).
    Furthermore, when a TCP segment is transported in an IP packet that is fragmented
    in the network, the loss of a single fragment forces TCP to retransmit the entire
    segment (and thus all the fragments). If TCP was able to send only packets that
    do not require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP消息的另一个重要用途是发现不产生分片的情况下可以到达目的地的最大MTU。如前所述，当IPv4路由器收到一个大于出链路MTU的数据包时，它必须对该数据包进行分片。不幸的是，分片是一个复杂的操作，路由器无法以线路速率执行它
    [[KM1995]](../bibliography.html#km1995)。此外，当TCP段在网络中通过分片的数据包传输时，单个分片的丢失会迫使TCP重新传输整个段（以及所有分片）。如果TCP能够发送不需要在网络中分片的数据包，它只需重新传输在网络中丢失的信息。此外，如[**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html)中讨论的那样，在高速情况下，IP重组引起了一些挑战。使用IP分片允许UDP应用程序交换大消息，这引发了一些安全问题
    [[KPS2003]](../bibliography.html#kps2003)。
- en: ICMP, combined with the Don’t fragment (DF) IPv4 flag, is used by TCP implementations
    to discover the largest MTU size that is allowed to reach a destination host without
    causing network fragmentation. This is the Path MTU discovery mechanism defined
    in [**RFC 1191**](https://datatracker.ietf.org/doc/html/rfc1191.html). A TCP implementation
    that includes Path MTU discovery (most do) requests the IPv4 layer to send all
    segments inside IPv4 packets having the DF flag set. This prohibits intermediate
    routers from fragmenting these packets. If a router needs to forward a packet
    which cannot be fragmented over a link with a smaller MTU, it returns a Fragmentation
    needed ICMP message to the source, indicating the MTU of its outgoing link. This
    ICMP message contains in the MTU of the router’s outgoing link in its Data field.
    Upon reception of this ICMP message, the source TCP implementation adjusts its
    Maximum Segment Size (MSS) so that the packets containing the segments that it
    sends can be forwarded by this router without requiring fragmentation.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP结合使用“不分片”（DF）IPv4标志，由TCP实现用来发现允许到达目的主机而不引起网络分片的最大MTU大小。这是在[**RFC 1191**](https://datatracker.ietf.org/doc/html/rfc1191.html)中定义的路径MTU发现机制。包含路径MTU发现（大多数都包含）的TCP实现请求IPv4层发送所有包含DF标志的IPv4数据包内的所有段。这禁止中间路由器对这些数据包进行分片。如果一个路由器需要转发一个无法在具有较小MTU的链路上分片的数据包，它将返回一个“需要分片”的ICMP消息给源地址，指示其出链路的MTU。此ICMP消息在其数据字段中包含路由器出链路的MTU。在接收到此ICMP消息后，源TCP实现调整其最大段大小（MSS），以便它发送的包含段的包可以由该路由器转发，而无需分片。
- en: Operation of IPv4 hosts[#](#operation-of-ipv4-hosts "Link to this heading")
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4主机的操作[#](#operation-of-ipv4-hosts "链接到本标题")
- en: At this point of the description of IPv4, it is useful to have a detailed look
    at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest
    case is when a host needs to send a segment in an IPv4 packet. The host performs
    two operations. First, it must decide on which interface the packet will be sent.
    Second it must create the corresponding IP packet(s).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述IPv4的这一阶段，详细了解一下IPv4实现如何发送、接收和转发IPv4数据包是有用的。最简单的情况是，当主机需要在一个IPv4数据包中发送一个段时。主机执行两个操作。首先，它必须决定数据包将通过哪个接口发送。其次，它必须创建相应的IP数据包（或数据包）。
- en: To simplify the discussion in this section, we ignore the utilization of IPv4
    options. This is not a severe limitation as today IPv4 packets rarely contain
    options. Details about the processing of the IPv4 options may be found in the
    relevant RFCs, such as [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本节中的讨论，我们忽略了IPv4选项的利用。这并不是一个严重的限制，因为如今IPv4数据包很少包含选项。有关IPv4选项处理详情，可在相关RFC中找到，例如[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html)。
- en: 'An IPv4 host having \(n\) datalink layer interfaces manages \(n+1\) IPv4 addresses
    :'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有\(n\)个数据链路层接口的IPv4主机管理\(n+1\)个IPv4地址：
- en: the 127.0.0.1/32 IPv4 address assigned by convention to its loopback address
  id: totrans-604
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例分配给其回环地址的 127.0.0.1/32 IPv4 地址
- en: ''
  id: totrans-605
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-606
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: one A.B.C.D/p IPv4 address assigned to each of its \(n\) datalink layer interfaces
  id: totrans-607
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给其 \(n\) 个数据链路层接口之一的 A.B.C.D/p IPv4 地址
- en: 'Such a host maintains a routing table containing one entry for its loopback
    address and one entry for each subnet identifier assigned to its interfaces. Furthermore,
    the host usually uses one of its interfaces as the default interface when sending
    packets that are not addressed to a directly connected destination. This is represented
    by the default route : 0.0.0.0/0 that is associated to one interface.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的主机维护一个路由表，包含一个条目用于其回环地址，以及一个条目用于分配给其接口的每个子网标识符。此外，当发送未指向直接连接目的地的数据包时，主机通常使用其接口之一作为默认接口。这由关联到一个接口的默认路由
    0.0.0.0/0 表示。
- en: When a transport protocol running on the host requests the transmission of a
    segment, it usually provides the IPv4 destination address to the IPv4 layer in
    addition to the segment [[12]](#fiddf). The IPv4 implementation first performs
    a longest prefix match with the destination address in its routing table. The
    lookup returns the identification of the interface that must be used to send the
    packet. The host can then create the IPv4 packet containing the segment. The source
    IPv4 address of the packet is the IPv4 address of the host on the interface returned
    by the longest prefix match. The Protocol field of the packet is set to the identification
    of the local transport protocol which created the segment. The TTL field of the
    packet is set to the default TTL used by the host. The host must now choose the
    packet’s Identification. This Identification is important if the packet becomes
    fragmented in the network, as it ensures that the destination is able to reassemble
    the received fragments. Ideally, a sending host should never send a packet twice
    with the same Identification to the same destination host, in order to ensure
    that all fragments are correctly reassembled by the destination. Unfortunately,
    with a 16 bits Identification field and an expected MSL of 2 minutes, this implies
    that the maximum bandwidth to a given destination is limited to roughly 286 Mbps.
    With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps [**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) if fragmentation must
    be possible [[12]](#fiddf). This is very low and is another reason why hosts are
    highly encouraged to avoid fragmentation. If; despite all of this, the MTU of
    the outgoing interface is smaller than the packet’s length, the packet is fragmented.
    Finally, the packet’s checksum is computed before transmission.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 当在主机上运行的数据传输协议请求传输一个段时，它通常除了向 IPv4 层提供段 [[12]](#fiddf) 的 IPv4 目的地址外，还提供段。IPv4
    实现首先在其路由表中与目的地址执行最长前缀匹配。查找返回必须用于发送数据包的接口标识。然后，主机可以创建包含段的 IPv4 数据包。数据包的源 IPv4 地址是返回的最长前缀匹配接口上的主机的
    IPv4 地址。数据包的协议字段设置为创建段的本地传输协议的标识。数据包的 TTL 字段设置为主机使用的默认 TTL。现在，主机必须选择数据包的标识。如果数据包在网络中分片，这个标识很重要，因为它确保目的地能够重新组装接收到的片段。理想情况下，发送主机应该永远不要向同一目的地主机发送具有相同标识的数据包两次，以确保所有片段都能被目的地正确重新组装。不幸的是，由于
    16 位的标识字段和预期的 MSL 为 2 分钟，这意味着到给定目的地的最大带宽限制在大约 286 Mbps。如果必须可能分片，那么在更现实的 1500 字节
    MTU 下，该带宽降低到 6.4 Mbps [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html)
    [[12]](#fiddf)。这非常低，这也是为什么强烈鼓励主机避免分片的原因之一。尽管如此，如果输出接口的 MTU 小于数据包的长度，数据包将被分片。最后，在传输之前计算数据包的校验和。
- en: When a host receives an IPv4 packet destined to itself, there are several operations
    that it must perform. First, it must check the packet’s checksum. If the checksum
    is incorrect, the packet is discarded. Then, it must check whether the packet
    has been fragmented. If yes, the packet is passed to the reassembly algorithm
    described earlier. Otherwise, the packet must be passed to the upper layer. This
    is done by looking at the Protocol field (6 for TCP, 17 for UDP). If the host
    does not implement the transport layer protocol corresponding to the received
    Protocol field, it sends a Protocol unreachable ICMP message to the sending host.
    If the received packet contains an ICMP message (Protocol field set to 1), the
    processing is more complex. An Echo-request ICMP message triggers the transmission
    of an ICMP Echo-reply message. The other types of ICMP messages indicate an error
    that was caused by a previously transmitted packet. These ICMP messages are usually
    forwarded to the transport protocol that sent the erroneous packet. This can be
    done by inspecting the contents of the ICMP message that includes the header and
    the first 64 bits of the erroneous packet. If the IP packet did not contain options,
    which is the case for most IPv4 packets, the transport protocol can find in the
    first 32 bits of the transport header the source and destination ports to determine
    the affected transport flow. This is important for Path MTU discovery for example.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机收到一个目的地为自身的 IPv4 数据包时，它必须执行几个操作。首先，它必须检查数据包的校验和。如果校验和不正确，则丢弃数据包。然后，它必须检查数据包是否已分片。如果是，则将数据包传递给前面描述的重组算法。否则，数据包必须传递给上层。这是通过查看协议字段（TCP
    为 6，UDP 为 17）来完成的。如果主机不实现与接收到的协议字段对应的传输层协议，它将向发送主机发送一个协议不可达的 ICMP 消息。如果接收到的数据包包含一个
    ICMP 消息（协议字段设置为 1），则处理更为复杂。Echo-request ICMP 消息触发 ICMP Echo-reply 消息的传输。其他类型的
    ICMP 消息表明由先前传输的数据包引起的错误。这些 ICMP 消息通常转发给发送错误数据包的传输协议。这可以通过检查包含头部和错误数据包前 64 位的内容的
    ICMP 消息来完成。如果 IP 数据包没有包含选项，这是大多数 IPv4 数据包的情况，传输协议可以在传输头部的第一个 32 位中找到源端口和目的端口，以确定受影响的传输流。这对于路径
    MTU 发现等来说很重要。
- en: Operation of IPv4 hosts[#](#operation-of-ipv4-hosts "Link to this heading")
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4 主机的操作[#](#operation-of-ipv4-hosts "链接到本标题")
- en: At this point of the description of IPv4, it is useful to have a detailed look
    at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest
    case is when a host needs to send a segment in an IPv4 packet. The host performs
    two operations. First, it must decide on which interface the packet will be sent.
    Second it must create the corresponding IP packet(s).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述 IPv4 的这个阶段，详细了解一下 IPv4 实现如何发送、接收和转发 IPv4 数据包是有用的。最简单的情况是当主机需要在一个 IPv4 数据包中发送一个段。主机执行两个操作。首先，它必须决定数据包将通过哪个接口发送。其次，它必须创建相应的
    IP 数据包（s）。
- en: To simplify the discussion in this section, we ignore the utilization of IPv4
    options. This is not a severe limitation as today IPv4 packets rarely contain
    options. Details about the processing of the IPv4 options may be found in the
    relevant RFCs, such as [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本节中的讨论，我们忽略 IPv4 选项的使用。这并不是一个严重的限制，因为今天 IPv4 数据包很少包含选项。有关 IPv4 选项处理的详细信息，可以在相关的
    RFC 中找到，例如 [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)。
- en: 'An IPv4 host having \(n\) datalink layer interfaces manages \(n+1\) IPv4 addresses
    :'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 \(n\) 个数据链路层接口的 IPv4 主机管理 \(n+1\) 个 IPv4 地址：
- en: the 127.0.0.1/32 IPv4 address assigned by convention to its loopback address
  id: totrans-615
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例分配给其回环地址的 127.0.0.1/32 IPv4 地址
- en: ''
  id: totrans-616
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-617
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: one A.B.C.D/p IPv4 address assigned to each of its \(n\) datalink layer interfaces
  id: totrans-618
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给其 \(n\) 个数据链路层接口的每个接口的 A.B.C.D/p IPv4 地址
- en: 'Such a host maintains a routing table containing one entry for its loopback
    address and one entry for each subnet identifier assigned to its interfaces. Furthermore,
    the host usually uses one of its interfaces as the default interface when sending
    packets that are not addressed to a directly connected destination. This is represented
    by the default route : 0.0.0.0/0 that is associated to one interface.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的主机维护一个路由表，其中包含一个条目用于其回环地址，以及一个条目用于分配给其接口的每个子网标识符。此外，当发送未直接连接到目的地的数据包时，主机通常使用其接口之一作为默认接口。这通过关联到一个接口的默认路由：0.0.0.0/0
    来表示。
- en: When a transport protocol running on the host requests the transmission of a
    segment, it usually provides the IPv4 destination address to the IPv4 layer in
    addition to the segment [[12]](#fiddf). The IPv4 implementation first performs
    a longest prefix match with the destination address in its routing table. The
    lookup returns the identification of the interface that must be used to send the
    packet. The host can then create the IPv4 packet containing the segment. The source
    IPv4 address of the packet is the IPv4 address of the host on the interface returned
    by the longest prefix match. The Protocol field of the packet is set to the identification
    of the local transport protocol which created the segment. The TTL field of the
    packet is set to the default TTL used by the host. The host must now choose the
    packet’s Identification. This Identification is important if the packet becomes
    fragmented in the network, as it ensures that the destination is able to reassemble
    the received fragments. Ideally, a sending host should never send a packet twice
    with the same Identification to the same destination host, in order to ensure
    that all fragments are correctly reassembled by the destination. Unfortunately,
    with a 16 bits Identification field and an expected MSL of 2 minutes, this implies
    that the maximum bandwidth to a given destination is limited to roughly 286 Mbps.
    With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps [**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) if fragmentation must
    be possible [[12]](#fiddf). This is very low and is another reason why hosts are
    highly encouraged to avoid fragmentation. If; despite all of this, the MTU of
    the outgoing interface is smaller than the packet’s length, the packet is fragmented.
    Finally, the packet’s checksum is computed before transmission.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当在主机上运行的传输协议请求传输一个段时，它通常除了向IPv4层提供段之外，还会提供IPv4目标地址 [[12](#fiddf)]。IPv4实现首先在其路由表中与目标地址执行最长前缀匹配。查找返回必须用于发送数据包的接口标识。然后，主机可以创建包含段的IPv4数据包。数据包的源IPv4地址是返回最长前缀匹配的主机接口的IPv4地址。数据包的协议字段设置为创建段的本地传输协议的标识。数据包的TTL字段设置为主机使用的默认TTL。现在，主机必须选择数据包的标识。如果数据包在网络中分片，这个标识很重要，因为它确保目标能够重新组装接收到的片段。理想情况下，发送主机应该永远不要向同一目标主机发送具有相同标识的数据包两次，以确保所有片段都能被目标正确重新组装。不幸的是，由于16位标识字段和预期的MSL为2分钟，这意味着到给定目标的最大带宽限制在大约286
    Mbps。如果需要分片，并且MTU为1500字节，那么带宽会降低到6.4 Mbps [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html)
    [[12](#fiddf)]。这非常低，这也是为什么强烈建议主机避免分片的原因之一。如果，尽管如此，出接口的MTU小于数据包的长度，数据包将被分片。最后，在传输之前计算数据包的校验和。
- en: When a host receives an IPv4 packet destined to itself, there are several operations
    that it must perform. First, it must check the packet’s checksum. If the checksum
    is incorrect, the packet is discarded. Then, it must check whether the packet
    has been fragmented. If yes, the packet is passed to the reassembly algorithm
    described earlier. Otherwise, the packet must be passed to the upper layer. This
    is done by looking at the Protocol field (6 for TCP, 17 for UDP). If the host
    does not implement the transport layer protocol corresponding to the received
    Protocol field, it sends a Protocol unreachable ICMP message to the sending host.
    If the received packet contains an ICMP message (Protocol field set to 1), the
    processing is more complex. An Echo-request ICMP message triggers the transmission
    of an ICMP Echo-reply message. The other types of ICMP messages indicate an error
    that was caused by a previously transmitted packet. These ICMP messages are usually
    forwarded to the transport protocol that sent the erroneous packet. This can be
    done by inspecting the contents of the ICMP message that includes the header and
    the first 64 bits of the erroneous packet. If the IP packet did not contain options,
    which is the case for most IPv4 packets, the transport protocol can find in the
    first 32 bits of the transport header the source and destination ports to determine
    the affected transport flow. This is important for Path MTU discovery for example.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机接收到一个目的地为自身的 IPv4 数据包时，它必须执行几个操作。首先，它必须检查数据包的校验和。如果校验和不正确，数据包将被丢弃。然后，它必须检查数据包是否已分片。如果是，数据包将被传递给前面描述的重组算法。否则，数据包必须传递到上层。这是通过查看协议字段（TCP
    为 6，UDP 为 17）来完成的。如果主机没有实现对应于接收到的协议字段的传输层协议，它将向发送主机发送一个协议不可达的 ICMP 消息。如果接收到的数据包包含一个
    ICMP 消息（协议字段设置为 1），处理将更加复杂。一个 Echo-request ICMP 消息将触发发送 ICMP Echo-reply 消息。其他类型的
    ICMP 消息表明由先前传输的数据包引起的错误。这些 ICMP 消息通常被转发到发送错误数据包的传输协议。这可以通过检查包含头部和错误数据包前 64 位的内容的
    ICMP 消息来完成。如果 IP 数据包没有包含选项，这是大多数 IPv4 数据包的情况，传输协议可以在传输头部的第一个 32 位中找到源端口和目的端口，以确定受影响的传输流。这对于路径
    MTU 发现等来说很重要。
- en: IP version 6[#](#ip-version-6 "Link to this heading")
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP 版本 6[#](#ip-version-6 "链接到这个标题")
- en: In the late 1980s and early 1990s the growth of the Internet was causing several
    operational problems on routers. Many of these routers had a single CPU and up
    to 1 MByte of RAM to store their operating system, packet buffers and routing
    tables. Given the rate of allocation of IPv4 prefixes to companies and universities
    willing to join the Internet, the routing tables where growing very quickly and
    some feared that all IPv4 prefixes would quickly be allocated. In 1987, a study
    cited in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html), estimated
    that there would be 100,000 networks in the near future. In August 1990, estimates
    indicated that the class B space would be exhausted by March 1994.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1980 年代后期和 1990 年代初期，互联网的增长在路由器上引起了几个操作问题。许多这些路由器只有一个 CPU 和高达 1 兆字节的 RAM 来存储它们的操作系统、数据包缓冲区和路由表。考虑到愿意加入互联网的公司和大学的
    IPv4 前缀分配率，路由表增长非常快，有些人担心所有 IPv4 前缀很快就会被分配。1987 年，[**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)
    中引用的一项研究估计，在不久的将来将有 100,000 个网络。1990 年 8 月，估计表明 B 类地址空间将在 1994 年 3 月耗尽。
- en: Two types of solution were developed to solve this problem. The first short
    term solution was the introduction of Classless Inter Domain Routing ([CIDR](../glossary.html#term-CIDR)).
    A second short term solution was the Network Address Translation ([NAT](../glossary.html#term-NAT))
    mechanism, defined in [**RFC 1631**](https://datatracker.ietf.org/doc/html/rfc1631.html).
    NAT allowed multiple hosts to share a single public IPv4 address.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发了两种类型的解决方案。第一种短期解决方案是引入无类别域间路由（[CIDR](../glossary.html#term-CIDR)）。第二种短期解决方案是网络地址转换（[NAT](../glossary.html#term-NAT)）机制，由
    [**RFC 1631**](https://datatracker.ietf.org/doc/html/rfc1631.html) 定义。NAT 允许多个主机共享一个单一的公共
    IPv4 地址。
- en: 'However, in parallel with these short-term solutions, which have allowed the
    IPv4 Internet to continue to be usable until now, the Internet Engineering Task
    Force started working on developing a replacement for IPv4\. This work started
    with an open call for proposals, outlined in [**RFC 1550**](https://datatracker.ietf.org/doc/html/rfc1550.html).
    Several groups responded to this call with proposals for a next generation Internet
    Protocol (IPng) :'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与这些短期解决方案并行，这些解决方案使得IPv4互联网能够继续使用至今，互联网工程任务组开始着手开发IPv4的替代方案。这项工作始于一个公开的提案征集，具体内容在[**RFC
    1550**](https://datatracker.ietf.org/doc/html/rfc1550.html)中概述。几个小组对此征集做出了回应，提出了下一代互联网协议（IPng）的提案：
- en: TUBA proposed in [**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html)
    and [**RFC 1561**](https://datatracker.ietf.org/doc/html/rfc1561.html)
  id: totrans-626
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html)和[**RFC 1561**](https://datatracker.ietf.org/doc/html/rfc1561.html)中提出的TUBA
- en: ''
  id: totrans-627
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-628
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PIP proposed in [**RFC 1621**](https://datatracker.ietf.org/doc/html/rfc1621.html)
  id: totrans-629
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[**RFC 1621**](https://datatracker.ietf.org/doc/html/rfc1621.html)中提出的PIP
- en: ''
  id: totrans-630
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-631
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SIPP proposed in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)
  id: totrans-632
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)中提出的SIPP
- en: 'The IETF decided to pursue the development of IPng based on the SIPP proposal.
    As IP version 5 was already used by the experimental ST-2 protocol defined in
    [**RFC 1819**](https://datatracker.ietf.org/doc/html/rfc1819.html), the successor
    of IP version 4 is IP version 6\. The initial IP version 6 defined in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)
    was designed based on the following assumptions :'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: IETF决定基于SIPP提案开发IPng。由于IP版本5已经被[**RFC 1819**](https://datatracker.ietf.org/doc/html/rfc1819.html)中定义的实验性ST-2协议所使用，因此IPv4的继任者是IPv6。在[**RFC
    1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)中定义的初始IPv6是基于以下假设设计的：
- en: IPv6 addresses are encoded as a 128 bits field
  id: totrans-634
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6地址编码为128位字段
- en: ''
  id: totrans-635
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-636
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The IPv6 header has a simple format that can easily be parsed by hardware devices
  id: totrans-637
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6头部具有简单的格式，可以很容易地被硬件设备解析
- en: ''
  id: totrans-638
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-639
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A host should be able to configure its IPv6 address automatically
  id: totrans-640
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机应该能够自动配置其IPv6地址
- en: ''
  id: totrans-641
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Security must be part of IPv6
  id: totrans-643
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性必须是IPv6的一部分
- en: Note
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The IPng address size
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: IPng地址大小
- en: When the work on IPng started, it was clear that 32 bits was too small to encode
    an IPng address and all proposals used longer addresses. However, there were many
    discussions about the most suitable address length. A first approach, proposed
    by SIPP in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html),
    was to use 64 bit addresses. A 64 bits address space was 4 billion times larger
    than the IPv4 address space and, furthermore, from an implementation perspective,
    64 bit CPUs were being considered and 64 bit addresses would naturally fit inside
    their registers. Another approach was to use an existing address format. This
    was the TUBA proposal ([**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html))
    that reuses the ISO CLNP 20 bytes addresses. The 20 bytes addresses provided room
    for growth, but using ISO CLNP was not favored by the IETF partially due to political
    reasons, despite the fact that mature CLNP implementations were already available.
    128 bits appeared to be a reasonable compromise at that time.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 当IPng的工作开始时，很明显32位对于编码IPng地址来说太小了，所有提案都使用了更长的地址。然而，关于最合适的地址长度有许多讨论。SIPP在[**RFC
    1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)中提出的一个初步方法是使用64位地址。64位地址空间比IPv4地址空间大40亿倍，而且从实现的角度来看，正在考虑64位CPU，64位地址自然适合它们的寄存器。另一种方法是使用现有的地址格式。这是TUBA提案([**RFC
    1347**](https://datatracker.ietf.org/doc/html/rfc1347.html))，它重用了ISO CLNP 20字节地址。20字节地址提供了增长空间，但使用ISO
    CLNP并不受IETF青睐，部分原因是政治原因，尽管成熟的CLNP实现已经可用。当时128位似乎是一个合理的折衷方案。
- en: IPv6 addressing architecture[#](#ipv6-addressing-architecture "Link to this
    heading")
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6寻址架构[#](#ipv6-addressing-architecture "链接到这个标题")
- en: The experience of IPv4 revealed that the scalability of a network layer protocol
    heavily depends on its addressing architecture. The designers of IPv6 spent a
    lot of effort defining its addressing architecture [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html).
    All IPv6 addresses are 128 bits wide. This implies that there are \(340,282,366,920,938,463,463,374,607,431,768,211,456
    (3.4 \times 10^{38})\) different IPv6 addresses. As the surface of the Earth is
    about 510,072,000 \(km^2\), this implies that there are about \(6.67 \times 10^{23}\)
    IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only
    8 addresses per square kilometer, this is a significant improvement on paper.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 的经验表明，网络层协议的可扩展性在很大程度上取决于其寻址架构。IPv6 的设计者花费了大量精力来定义其寻址架构 [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html)。所有
    IPv6 地址都是 128 位宽。这意味着有 \(340,282,366,920,938,463,463,374,607,431,768,211,456 (3.4
    \times 10^{38})\) 个不同的 IPv6 地址。由于地球表面积约为 510,072,000 \(km^2\)，这意味着地球上每平方米大约有 \(6.67
    \times 10^{23}\) 个 IPv6 地址。与仅提供每平方公里 8 个地址的 IPv4 相比，这在纸上是一个显著的改进。
- en: Note
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Textual representation of IPv6 addresses
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址的文本表示
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时需要以文本格式编写 IPv6 地址，例如在手动配置地址或用于文档目的时。编写 IPv6 地址的首选格式是 `x:x:x:x:x:x:x:x`，其中
    `x` 是表示地址八个 16 位部分的十六进制数字。以下是一些 IPv6 地址的示例：
- en: ''
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  id: totrans-653
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
- en: ''
  id: totrans-654
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-655
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  id: totrans-656
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`'
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-658
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  id: totrans-659
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0:0:0:219:e3ff:fed7:1204`'
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16 bits blocks containing only bits set to 0. For example,'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 'IPv6 地址通常包含一串设置为 `0` 的位。在这种情况下，已定义了一种紧凑表示法。使用这种表示法，:: 用于表示一个或多个只包含设置为 `0` 的位的
    16 位块组。例如，'
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  id: totrans-661
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a` 表示为 `2001:db8::8:800:200c:417a`'
- en: ''
  id: totrans-662
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-663
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  id: totrans-664
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff01:0:0:0:0:0:0:101` 表示为 `ff01::101`'
- en: ''
  id: totrans-665
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-666
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  id: totrans-667
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` 表示为 `::1`'
- en: ''
  id: totrans-668
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-669
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  id: totrans-670
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` 表示为 `::`'
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 前缀可以表示为地址/长度，其中长度是前缀的位数。例如，以下三种表示法对应于相同的 IPv6 前缀：
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  id: totrans-672
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
- en: ''
  id: totrans-673
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-674
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  id: totrans-675
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8::cd30:0:0:0:0` / `60`'
- en: ''
  id: totrans-676
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-677
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  id: totrans-678
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0:cd30::` / `60`'
- en: IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address
    is used to identify one datalink-layer interface on a host. If a host has several
    datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then
    it needs several IPv6 addresses. In general, an IPv6 unicast address is structured
    as shown in [Fig. 113](#fig-ipv6-addr-structure).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 支持单播、多播和任播地址。IPv6 单播地址用于标识主机上的一个数据链路层接口。如果一个主机有多个数据链路层接口（例如，一个以太网接口和一个
    Wi-Fi 接口），那么它需要多个 IPv6 地址。通常，IPv6 单播地址的结构如图 [图 113](#fig-ipv6-addr-structure)
    所示。
- en: '![Figure made with TikZ](../Images/334d256816526fa56f8d5037c79a8b94.png)'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/334d256816526fa56f8d5037c79a8b94.png)'
- en: ''
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 113 Structure of IPv6 unicast addresses
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 113 IPv6 单播地址结构
- en: 'The IETF has reserved some IPv6 addresses for a special usage. The two most
    important ones are :'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网工程任务组（IETF）为特殊用途预留了一些 IPv6 地址。其中最重要的两个是：
- en: '`0:0:0:0:0:0:0:1` (`::1` in compact form) is the IPv6 loopback address. This
    is the address of a logical interface that is always up and running on IPv6 enabled
    hosts.'
  id: totrans-684
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` （紧凑形式为 `::1`）是 IPv6 环回地址。这是在启用 IPv6 的主机上始终处于开启状态和运行状态的逻辑接口的地址。'
- en: ''
  id: totrans-685
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-686
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` (`::` in compact form) is the unspecified IPv6 address. This
    is the IPv6 address that a host can use as source address when trying to acquire
    an official address.'
  id: totrans-687
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` （紧凑形式为 `::`）是未指定 IPv6 地址。这是主机在尝试获取官方地址时可以用作源地址的 IPv6 地址。'
- en: The last type of unicast IPv6 addresses are the Link Local Unicast addresses
    shown in [Fig. 114](#fig-ipv6-link-local). These addresses are part of the fe80::/10
    address block and are defined in [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html).
    Each host can compute its own link local address by concatenating the fe80::/64
    prefix with the 64 bits identifier of its interface. Link local addresses can
    be used when hosts that are attached to the same link (or local area network)
    need to exchange packets. They are used notably for address discovery and auto-configuration
    purposes. Their usage is restricted to each link and a router cannot forward a
    packet whose source or destination address is a link local address. Link local
    addresses have also been defined for IPv4 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    However, the IPv4 link local addresses are only used when a host cannot obtain
    a regular IPv4 address, e.g. on an isolated LAN.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种单播 IPv6 地址是 [图 114](#fig-ipv6-link-local) 中所示的链路本地单播地址。这些地址是 fe80::/10 地址块的一部分，并在
    [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html) 中定义。每个主机都可以通过将
    fe80::/64 前缀与其接口的 64 位标识符连接起来来计算自己的链路本地地址。链路本地地址可以在连接到同一链路（或局域网）的主机需要交换数据包时使用。它们特别用于地址发现和自动配置目的。它们的用途仅限于每个链路，并且路由器不能转发源地址或目的地址为链路本地地址的数据包。IPv4
    也已为链路本地地址定义了 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。然而，IPv4
    链路本地地址仅在主机无法获取常规 IPv4 地址时使用，例如在孤立的局域网中。
- en: '![Figure made with TikZ](../Images/85809a63cecf02a8a699a08cbd775118.png)'
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/85809a63cecf02a8a699a08cbd775118.png)'
- en: ''
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 114 IPv6 link local address structure
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 114 IPv6 链路本地地址结构
- en: Note
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All IPv6 hosts have several addresses
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 IPv6 主机都有多个地址
- en: An important consequence of the IPv6 unicast addressing architecture and the
    utilization of link-local addresses is that each IPv6 host has several IPv6 addresses.
    This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 单播寻址架构和链路本地地址的利用的一个重要后果是，每个 IPv6 主机都有多个 IPv6 地址。这意味着所有 IPv6 堆栈都必须能够处理多个
    IPv6 地址。
- en: The addresses described above are unicast addresses. These addresses are used
    to identify (interfaces on) hosts and routers. They can appear as source and destination
    addresses in the IPv6 packets. When a host sends a packet towards a unicast address,
    this packet is delivered by the network to its final destination. There are situations,
    such as when delivering video or television signal to a large number of receivers,
    where it is useful to have a network that can efficiently deliver the same packet
    to a large number of receivers. This is the multicast service. A multicast service
    can be provided in a LAN. In this case, a multicast address identifies a set of
    receivers and each frame sent towards this address is delivered to all receivers
    in the group. Multicast can also be used in a network containing routers and hosts.
    In this case, a multicast address identifies also a group of receivers and the
    network delivers efficiently each multicast packet to all members of the group.
    Consider for example the network shown in [Fig. 115](#fig-ipv6-simple-network).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的地址是单播地址。这些地址用于标识（主机和路由器上的）主机。它们可以出现在 IPv6 数据包的源地址和目的地址中。当主机向单播地址发送数据包时，该数据包将通过网络交付到其最终目的地。在某些情况下，例如向大量接收器发送视频或电视信号时，拥有一个能够高效地将相同数据包发送到大量接收器的网络是有用的。这就是多播服务。多播服务可以在局域网中提供。在这种情况下，一个多播地址标识一组接收器，并且每个发送到该地址的帧都将交付给该组中的所有接收器。多播也可以在包含路由器和主机的网络中使用。在这种情况下，多播地址也标识一组接收器，并且网络将高效地将每个多播数据包交付给该组的所有成员。例如，考虑
    [图 115](#fig-ipv6-simple-network) 中所示的网络。
- en: '![Figure made with TikZ](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
- en: ''
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 115 A simple network with hosts and routers
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 115 一个包含主机和路由器的简单网络
- en: Assume that `B` and `D` are part of a multicast group. If `A` sends a multicast
    packet towards this group, then `R1` will replicate the packet to forward it to
    `R2` and `R3`. `R2` would forward the packet towards `B`. `R3` would forward the
    packet towards `R4` that would deliver it to `D`.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `B` 和 `D` 是一个多播组的成员。如果 `A` 向该组发送一个多播数据包，那么 `R1` 将复制数据包以将其转发到 `R2` 和 `R3`。`R2`
    将将数据包转发到 `B`。`R3` 将将数据包转发到 `R4`，`R4` 将将其交付给 `D`。
- en: Finally, [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)
    defines the structure of the IPv6 multicast addresses [[8]](#fmultiiana). This
    structure is depicted in [Fig. 116](#fig-ipv6-multicast-addr).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)定义了IPv6多播地址的结构[[8]](#fmultiiana)。这个结构在图116中展示。
- en: '![Figure made with TikZ](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
- en: ''
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 116 IPv6 multicast address structure
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图116 IPv6多播地址结构
- en: The low order 112 bits of an IPv6 multicast address are the group’s identifier.
    The high order bits are used as a marker to distinguish multicast addresses from
    unicast addresses. Notably, the 4-bit Flags field indicates whether the address
    is temporary or permanent. Finally, the Scope field indicates the boundaries of
    the forwarding of packets destined to a particular address. A link-local scope
    indicates that a router should not forward a packet destined to such a multicast
    address. An organization local-scope indicates that a packet sent to such a multicast
    destination address should not leave the organization. Finally the global scope
    is intended for multicast groups spanning the global Internet.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6多播地址的低112位是组的标识符。高位用作标记，以区分多播地址和单播地址。值得注意的是，4位标志字段指示地址是临时的还是永久的。最后，范围字段指示特定地址的包转发的边界。链路本地范围表示路由器不应转发目的地为这种多播地址的包。组织本地范围表示发送到这种多播目的地址的包不应离开组织。最后，全局范围旨在用于跨越全球互联网的多播组。
- en: Among these addresses, some are well known. For example, all hosts automatically
    belong to the `ff02::1` multicast group while all routers automatically belong
    to the `ff02::2` multicast group. A detailed discussion of IPv6 multicast is outside
    the scope of this chapter.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些地址中，有些是众所周知的。例如，所有主机自动属于`ff02::1`多播组，而所有路由器自动属于`ff02::2`多播组。IPv6多播的详细讨论超出了本章的范围。
- en: '### IPv6 packet[#](#ipv6-packet "Link to this heading")'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '### IPv6数据包[#](#ipv6-packet "链接到此标题")'
- en: The IPv6 packet format was heavily inspired by the packet format proposed for
    the SIPP protocol in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html).
    The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 117](#fig-ipv6-header-detail).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包格式深受[**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)中为SIPP协议提出的包格式的启发。在[**RFC
    2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)中定义的标准IPv6头部占用40字节，包含8个不同的字段，如图117所示。
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
- en: Fig. 117 The IP version 6 header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "Link to this image")
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 图117 IP版本6头部([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "链接到此图像")
- en: 'Apart from the source and destination addresses, the IPv6 header contains the
    following fields :'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源地址和目的地址之外，IPv6头部还包含以下字段：
- en: 'Version : a 4 bits field set to 6 and intended to allow IP to evolve in the
    future if needed'
  id: totrans-711
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本：一个设置为6的4位字段，旨在允许IP在需要时在未来进行演变。
- en: ''
  id: totrans-712
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Traffic class : this 8 bits field indicates the type of service expected by
    this packet and contains the `CE` and `ECT` flags that are used by Explicit Congestion
    Notification'
  id: totrans-714
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量类别：这个8位字段表示此数据包期望的服务类型，并包含显式拥塞通知使用的`CE`和`ECT`标志。
- en: ''
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-716
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flow Label : this field was initially intended to be used to tag packets belonging
    to the same flow. A recent document, [**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)
    describes some possible usages of this field, but it is too early to tell whether
    it will be really used.'
  id: totrans-717
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流标签：这个字段最初打算用来标记属于同一流的包。最近的一份文件，[**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)描述了该字段的一些可能用途，但还太早判断它是否真的会被使用。
- en: ''
  id: totrans-718
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-719
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Payload Length : this is the size of the packet payload in bytes. As the length
    is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of
    payload.'
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效载荷长度：这是数据包有效载荷的大小（以字节为单位）。由于长度被编码为16位字段，IPv6数据包可以包含多达65535字节的有效载荷。
- en: ''
  id: totrans-721
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-722
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next Header : this 8-bit field indicates the type [[9]](#fianaprotocol) of
    header that follows the IPv6 header. It can be a transport layer header (e.g.
    6 for TCP or 17 for UDP) or an IPv6 option.'
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个头部：这个8位字段指示IPv6头部之后跟随的头部类型。它可以是传输层头部（例如，6表示TCP或17表示UDP）或IPv6选项。
- en: ''
  id: totrans-724
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-725
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hop Limit : this 8-bit field indicates the number of routers that can forward
    the packet. It is decremented by one by each router and prevents packets from
    looping forever inside the network.'
  id: totrans-726
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳数限制：这个 8 位字段指示可以转发数据包的路由器数量。每个路由器将其减一，以防止数据包在网络内部无限循环。
- en: It is interesting to note that there is no checksum inside the IPv6 header.
    This is mainly because all datalink layers and transport protocols include a checksum
    or a CRC to protect their frames/segments against transmission errors. Adding
    a checksum in the IPv6 header would have forced each router to recompute the checksum
    of all packets, with limited benefit in detecting errors. In practice, an IP checksum
    allows for catching errors that occur inside routers (e.g. due to memory corruption)
    before the packet reaches its destination. However, this benefit was found to
    be too small given the reliability of current memories and the cost of computing
    the checksum on each router [[10]](#fipv4checksum).
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，IPv6 头部中没有校验和。这主要是因为所有数据链路层和传输协议都包含校验和或 CRC，以保护它们的帧/段免受传输错误的影响。在 IPv6 头部中添加校验和将迫使每个路由器重新计算所有数据包的校验和，这在检测错误方面的好处有限。在实践中，IP
    校验和允许在数据包到达目的地之前捕获在路由器内部发生的错误（例如，由于内存损坏）。然而，鉴于当前内存的可靠性和在每个路由器上计算校验和的成本，这种好处被认为太小
    [[10]](#fipv4checksum)。
- en: 'When a host receives an IPv6 packet, it needs to determine which transport
    protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is
    the first role of the Next header field. The [IANA](https://www.iana.org) which
    manages the allocation of Internet resources and protocol parameters, maintains
    an official list of transport protocols [[9]](#fianaprotocol). The following protocol
    numbers are reserved :'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机接收到 IPv6 数据包时，它需要确定需要处理数据包有效负载的哪个传输协议（UDP、TCP、SCTP 等）。这是下一个头部字段的第一种作用。负责互联网资源分配和协议参数分配的
    [IANA](https://www.iana.org) 维护了一个官方的传输协议列表 [[9]](#fianaprotocol)。以下协议号已被保留：
- en: '`TCP` uses Next Header number `6`'
  id: totrans-729
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCP` 使用下一个头部编号 `6`'
- en: ''
  id: totrans-730
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-731
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UDP` uses Next Header number `17`'
  id: totrans-732
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UDP` 使用下一个头部编号 `17`'
- en: ''
  id: totrans-733
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-734
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SCTP` uses Next Header number `132`'
  id: totrans-735
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCTP` 使用下一个头部编号 `132`'
- en: For example, an IPv6 packet that contains an TCP segment would appear as shown
    in [Fig. 118](#fig-ipv6-tcp).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，包含 TCP 数据段的 IPv6 数据包将显示如图 118 所示：
- en: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
- en: Fig. 118 An IPv6 packet containing an TCP segment[#](#id40 "Link to this image")
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 图 118 包含 TCP 数据段的 IPv6 数据包[#](#id40 "链接到此图像")
- en: However, the Next header has broader usages than simply indicating the transport
    protocol which is responsible for the packet payload. An IPv6 packet can contain
    a chain of headers and the last one indicates the transport protocol that is responsible
    for the packet payload. Supporting a chain of headers is a clever design from
    an extensibility viewpoint. As we will see, this chain of headers has several
    usages.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一个头部具有比仅仅指示负责数据包有效负载的传输协议更广泛的使用。IPv6 数据包可以包含一系列头部，最后一个头部指示负责数据包有效负载的传输协议。从可扩展性的角度来看，支持一系列头部是一个巧妙的设计。正如我们将看到的，这一系列头部有几个用途。
- en: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) defines
    several types of IPv6 extension headers that could be added to an IPv6 packet
    :'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) 定义了可以添加到
    IPv6 数据包中的几种 IPv6 扩展头部类型：'
- en: Hop-by-Hop Options header. This option is processed by routers and hosts.
  id: totrans-741
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳到跳选项头部。此选项由路由器和主机处理。
- en: ''
  id: totrans-742
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-743
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Destination Options header. This option is processed only by hosts.
  id: totrans-744
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的选项头部。此选项仅由主机处理。
- en: ''
  id: totrans-745
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-746
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Routing header. This option is processed by some nodes.
  id: totrans-747
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由头部。此选项由某些节点处理。
- en: ''
  id: totrans-748
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-749
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragment header. This option is processed only by hosts.
  id: totrans-750
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段头部。此选项仅由主机处理。
- en: ''
  id: totrans-751
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-752
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Authentication header. This option is processed only by hosts.
  id: totrans-753
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证头部。此选项仅由主机处理。
- en: ''
  id: totrans-754
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-755
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulating Security Payload. This option is processed only by hosts.
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装安全载荷。此选项仅由主机处理。
- en: The last two headers are used to add security above IPv6 and implement IPSec.
    They are described in [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    and [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) and are
    outside the scope of this document.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个头部用于在 IPv6 上添加安全性和实现 IPSec。它们在 [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    和 [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) 中描述，并且超出了本文档的范围。
- en: The Hop-by-Hop Options header was designed to make IPv6 easily extensible. In
    theory, this option could be used to define new fields that were not foreseen
    when IPv6 was designed. It is intended to be processed by both routers and hosts.
    Deploying an extension to a network protocol can be difficult in practice since
    some nodes already support the extensions while others still use the old version
    and do not understand the extension. To deal with this issue, the IPv6 designers
    opted for a Type-Length-Value encoding of these IPv6 options. The Hop-by-Hop Options
    header is encoded as show in [Fig. 119](#fig-ipv6-hbhoption).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到跳选项头部被设计成使IPv6易于扩展。理论上，此选项可以用来定义在IPv6设计时未预见的新字段。它旨在由路由器和主机处理。在实践中，将扩展部署到网络协议可能很困难，因为一些节点已经支持扩展，而其他节点仍在使用旧版本且不理解扩展。为了处理这个问题，IPv6设计者选择了这些IPv6选项的类型-长度-值编码。跳到跳选项头部编码方式如图119所示[图.
    119](#fig-ipv6-hbhoption)。
- en: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
- en: Fig. 119 The IPv6 Hop-by-Hop Options header[#](#id41 "Link to this image")
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 图119 IPv6跳到跳选项头部[#](#id41 "链接到此图像")
- en: 'In this optional header, the Next Header field is used to support the chain
    of headers. It indicates the type of the next header in the chain. IPv6 headers
    have different lengths. The Hdr Ext Len field indicates the total length of the
    option header in bytes. The Opt. Type field indicates the type of option. These
    types are encoded such that their high order bits specify how the header needs
    to be handled by nodes that do not recognize it. The following values are defined
    for the two high order bits :'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可选头部中，Next Header字段用于支持头部的链。它指示链中下一个头部的类型。IPv6头部有不同的长度。Hdr Ext Len字段指示可选头部的总长度（以字节为单位）。Opt.
    Type字段指示选项的类型。这些类型被编码，使得它们的高位比特指定了节点在不识别它时如何处理头部。以下为两个高位比特定义的值：
- en: '`00` : if a node does not recognize this header, it can be safely skipped and
    the processing continues with the subsequent header'
  id: totrans-762
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00` : 如果一个节点不识别这个头部，它可以安全地跳过，并继续处理后续的头部'
- en: ''
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-764
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`01` : if a node does not recognize this header, the packet must be discarded'
  id: totrans-765
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01` : 如果一个节点不识别这个头部，则必须丢弃该数据包'
- en: ''
  id: totrans-766
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-767
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`10` (resp. `11`) : if a node does not recognize this header, it must return
    a control packet (ICMP, see later) back to the source (resp. except if the destination
    was a multicast address)'
  id: totrans-768
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`（或`11`）: 如果一个节点不识别这个头部，它必须返回一个控制包（ICMP，见后）回源（除非目的地址是组播地址）'
- en: This encoding allows the designers of protocol extensions to specify whether
    the option must be supported by all nodes on a path or not. Still, deploying such
    an extension can be difficult in practice.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码允许协议扩展的设计者指定选项是否必须由路径上的所有节点支持。然而，在实践中部署此类扩展可能很困难。
- en: Two hop-by-hop options have been defined. [**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    specifies the jumbogram that enables IPv6 to support packets containing a payload
    larger than 65535 bytes. These jumbo packets have their payload length set to
    0 and the jumbogram option contains the packet length as a 32 bits field. Such
    packets can only be sent from a source to a destination if all the routers on
    the path support this option. However, as of this writing it does not seem that
    the jumbogram option has been implemented. The router alert option defined in
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) is the second
    example of a hop-by-hop option. The packets that contain this option should be
    processed in a special way by intermediate routers. This option is used for IP
    packets that carry Resource Reservation Protocol (RSVP) messages, but this is
    outside the scope of this book.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两种跳到跳的选项。[**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    规定了使IPv6能够支持包含大于65535字节有效载荷的数据包的巨帧。这些巨帧将有效载荷长度设置为0，巨帧选项包含一个32位字段表示数据包长度。只有当路径上的所有路由器都支持此选项时，才能从源发送到目的地的数据包。然而，截至本文撰写时，似乎巨帧选项尚未实现。在[**RFC
    2711**](https://datatracker.ietf.org/doc/html/rfc2711.html)中定义的router alert选项是跳到跳选项的第二个例子。包含此选项的数据包应由中间路由器以特殊方式处理。此选项用于携带资源预留协议（RSVP）消息的IP数据包，但这超出了本书的范围。
- en: The Destinations Option header uses the same format as the Hop-by-Hop Options
    header. It has some usages, e.g. to support mobile nodes [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html),
    but these are outside the scope of this document.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地选项头部使用与跳到跳选项头部相同的格式。它有一些用途，例如支持移动节点[**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html)，但这些超出了本文档的范围。
- en: The Fragment Options header is more important. An important problem in the network
    layer is the ability to handle heterogeneous datalink layers. Most datalink layer
    technologies can only transmit and receive frames that are shorter than a given
    maximum frame size. Unfortunately, all datalink layer technologies use different
    maximum frames sizes.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 分片选项头部更为重要。网络层中的一个重要问题是处理异构数据链路层的能力。大多数数据链路层技术只能传输和接收小于给定最大帧大小的帧。不幸的是，所有数据链路层技术使用不同的最大帧大小。
- en: Each datalink layer has its own characteristics and as indicated earlier, each
    datalink layer is characterized by a maximum frame size. From IP’s point of view,
    a datalink layer interface is characterized by its Maximum Transmission Unit (MTU).
    The MTU of an interface is the largest packet (including header) that it can send.
    The table below provides some common MTU sizes.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据链路层都有其自身的特性，如前所述，每个数据链路层以其最大帧大小为特征。从IP的角度来看，数据链路层接口以其最大传输单元（MTU）为特征。接口的MTU是它可以发送的最大数据包（包括头部）。下表提供了一些常见的MTU大小。
- en: '| Datalink layer | MTU |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | MTU |'
- en: '| Ethernet | 1500 bytes |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '| 以太网 | 1500 字节 |'
- en: '| WiFi | 2272 bytes |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 2272 字节 |'
- en: '| ATM (AAL5) | 9180 bytes |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| ATM (AAL5) | 9180 字节 |'
- en: '| 802.15.4 | 102 or 81 bytes |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| 802.15.4 | 102 或 81 字节 |'
- en: '| Token Ring | 4464 bytes |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| 令牌环 | 4464 字节 |'
- en: '| FDDI | 4352 bytes |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| FDDI | 4352 字节 |'
- en: Although IPv6 can send 64 KBytes long packets, few datalink layer technologies
    that are used today are able to send a 64 KBytes packet inside a frame. Furthermore,
    as illustrated in [Fig. 120](#fig-ipv6-need-fragmentation), another problem is
    that a host may send a packet that would be too large for one of the datalink
    layers used by the intermediate routers.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IPv6可以发送长达64 KBytes的数据包，但今天使用的少数数据链路层技术能够在一个帧内发送64 KBytes的数据包。此外，如图 120 所示，另一个问题是主机可能发送一个对于中间路由器使用的数据链路层来说太大的数据包。
- en: '![Figure made with TikZ](../Images/1baf064048236d27ceffa188e5e44d59.png)'
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/1baf064048236d27ceffa188e5e44d59.png)'
- en: ''
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 120 The need for fragmentation and reassembly
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 120 分片和重组的需求
- en: To solve these problems, IPv6 includes a packet fragmentation and reassembly
    mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate
    routers. However, experience with IPv4 has shown that fragmenting packets in routers
    was costly [[KM1995]](../bibliography.html#km1995). For this reason, the developers
    of IPv6 have decided that routers would not fragment packets anymore. In IPv6,
    fragmentation is only performed by the source host. If a source has to send a
    packet which is larger than the MTU of the outgoing interface, the packet needs
    to be fragmented before being transmitted. In IPv6, each packet fragment is an
    IPv6 packet that includes the Fragmentation header shown in [Fig. 121](#fig-ipv6-fragment-header).
    This header is included by the source in each packet fragment. The receiver uses
    them to reassemble the received fragments.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，IPv6 包含了数据包分片和重组机制。在IPv4中，分片是由主机和中间路由器共同执行的。然而，IPv4的经验表明，在路由器中分片数据包是昂贵的[[KM1995]](../bibliography.html#km1995)。因此，IPv6的开发者决定路由器将不再分片数据包。在IPv6中，分片仅由源主机执行。如果一个源必须发送一个大于出接口MTU的数据包，那么在传输之前需要分片该数据包。在IPv6中，每个数据包分片都是一个包含如图
    121 所示的分片头部（Fragmentation header）的IPv6数据包。该头部由源包含在每个数据包分片中。接收器使用它们来重组接收到的分片。
- en: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)'
- en: Fig. 121 IPv6 fragmentation header[#](#id43 "Link to this image")
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 图 121 IPv6 分片头部[#](#id43 "链接到这张图片")
- en: If a router receives a packet that is too long to be forwarded, the packet is
    dropped and the router returns an ICMPv6 message to inform the sender of the problem.
    The sender can then either fragment the packet or perform Path MTU discovery.
    In IPv6, packet fragmentation is performed only by the source by using IPv6 options.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个路由器收到一个太长而无法转发的数据包，该数据包将被丢弃，路由器将返回一个 ICMPv6 消息来通知发送者问题。发送者可以随后分片数据包或执行路径
    MTU 发现。在 IPv6 中，数据包分片仅由源宿主通过使用 IPv6 选项来执行。
- en: 'In IPv6, fragmentation is performed exclusively by the source host and relies
    on the fragmentation header. This 64 bits header is composed of six fields :'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPv6 中，分片由源宿主独家执行，并依赖于分片头部。这个 64 位的头部由六个字段组成：
- en: a Next Header field that indicates the type of the header that follows the fragmentation
    header
  id: totrans-790
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示随后的分片头部类型的一个 Next Header 字段
- en: ''
  id: totrans-791
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-792
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: two Reserved fields set to 0.
  id: totrans-793
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个保留字段设置为 0。
- en: ''
  id: totrans-794
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Fragment Offset is a 13-bit unsigned integer that contains the offset, in
    8 bytes units, of the data following this header, relative to the start of the
    original packet.
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片偏移是一个 13 位的无符号整数，包含从该头部开始的数据偏移量，以 8 字节为单位，相对于原始数据包的开始。
- en: ''
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-798
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the More flag, which is set to 0 in the last fragment of a packet and to 1 in
    all other fragments.
  id: totrans-799
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多标志，在数据包的最后一个分片中设置为 0，在其他所有分片中设置为 1。
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-801
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the 32-bit Identification field indicates to which original packet a fragment
    belongs. When a host sends fragmented packets, it should ensure that it does not
    reuse the same identification field for packets sent to the same destination during
    a period of MSL seconds. This is easier with the 32 bits identification used in
    the IPv6 fragmentation header, than with the 16 bits identification field of the
    IPv4 header.
  id: totrans-802
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32 位的标识字段指示分片属于哪个原始数据包。当宿主发送分片数据包时，它应确保在 MSL 秒内不会为发送到同一目的地的数据包重复使用相同的标识字段。与
    IPv4 头部中的 16 位标识字段相比，使用 IPv6 分片头部中的 32 位标识更容易做到这一点。
- en: Some IPv6 implementations send the fragments of a packet in increasing fragment
    offset order, starting from the first fragment. Others send the fragments in reverse
    order, starting from the last fragment. The latter solution can be advantageous
    for the host that needs to reassemble the fragments, as it can easily allocate
    the buffer required to reassemble all fragments of the packet upon reception of
    the last fragment. When a host receives the first fragment of an IPv6 packet,
    it cannot know a priori the length of the entire IPv6 packet.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 IPv6 实现按照递增的分片偏移顺序发送数据包的分片，从第一个分片开始。其他实现则按照相反的顺序发送分片，从最后一个分片开始。对于需要重新组装分片的宿主来说，后者解决方案可能更有优势，因为它可以在接收到最后一个分片后轻松地分配所需的缓冲区来重新组装数据包的所有分片。当一个宿主接收到一个
    IPv6 数据包的第一个分片时，它无法事先知道整个 IPv6 数据包的长度。
- en: '[Fig. 122](#fig-ipv6-fragmentation-example) provides an example of a fragmented
    IPv6 packet containing a UDP segment. The Next Header type reserved for the IPv6
    fragmentation option is 44.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 122](#fig-ipv6-fragmentation-example) 展示了一个包含 UDP 段的已分片 IPv6 数据包的示例。为 IPv6
    分片选项保留的 Next Header 类型是 44。'
- en: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
- en: Fig. 122 IPv6 fragmentation example[#](#id44 "Link to this image")
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 图 122 IPv6 分片示例[#](#id44 "链接到这张图片")
- en: The following pseudo-code details the IPv6 fragmentation, assuming that the
    packet does not contain options.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码详细说明了 IPv6 分片，假设数据包不包含选项。
- en: '[PRE10]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the above pseudocode, we maintain a single 32 bits counter that is incremented
    for each packet that needs to be fragmented. Other implementations to compute
    the packet identification are possible. [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    only requires that two fragmented packets that are sent within the MSL between
    the same pair of hosts have different identifications.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述伪代码中，我们维护一个 32 位的计数器，每次需要分片的数据包都会增加计数。其他计算数据包标识的实现也是可能的。[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    只要求在同一对主机之间发送的、在 MSL 时间内分片的数据包具有不同的标识。
- en: The fragments of an IPv6 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 数据包的分片可以以任何顺序到达目的地，因为每个分片在网络中独立转发，可能遵循不同的路径。此外，一些分片可能会丢失，永远不会到达目的地。
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv6 packet is a fragment
    or not by checking whether it contains a fragment header. If so, all fragments
    with the some identification must be reassembled together. The reassembly algorithm
    relies on the Identification field of the received fragments to associate a fragment
    with the corresponding packet being reassembled. Furthermore, the Fragment Offset
    field indicates the position of the fragment payload in the original non-fragmented
    packet. Finally, the packet with the M flag reset allows the destination to determine
    the total length of the original non-fragmented packet.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 目的主机使用的重组算法大致如下。首先，目的地可以通过检查它是否包含分片头部来验证接收到的IPv6数据包是否为分片。如果是，则必须将具有相同标识符的所有分片一起重组。重组算法依赖于接收到的分片的标识符字段，以将分片与正在重组的相应数据包关联起来。此外，分片偏移字段指示分片有效载荷在原始非分片数据包中的位置。最后，M标志被重置的包允许目的地确定原始非分片数据包的总长度。
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bind the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重组算法必须处理IP网络的不可靠性。这意味着一个分片可能会被重复，或者一个分片可能永远无法到达目的地。由于分片偏移量，目的地可以轻松地检测到分片重复。为了处理分片丢失，重组算法必须在重组过程中将分片存储在缓冲区的时间绑定起来。这可以通过在接收到分片的第一部分时启动计时器来实现。如果在计时器到期之前没有重组数据包，则丢弃所有分片，并认为数据包已丢失。
- en: Note
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Header compression on low bandwidth links
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在低带宽链路上的头部压缩
- en: Given the size of the IPv6 header, it can cause huge overhead on low bandwidth
    links, especially when small packets are exchanged such as for Voice over IP applications.
    In such environments, several techniques can be used to reduce the overhead. A
    first solution is to use data compression in the datalink layer to compress all
    the information exchanged [[Thomborson1992]](../bibliography.html#thomborson1992).
    These techniques are similar to the data compression algorithms used in tools
    such as *compress(1)* or *gzip(1)* [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html).
    They compress streams of bits without taking advantage of the fact that these
    streams contain IP packets with a known structure. A second solution is to compress
    the IP and TCP header. These header compression techniques, such as the one defined
    in [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html) take advantage
    of the redundancy found in successive packets from the same flow to significantly
    reduce the size of the protocol headers. Another solution is to define a compressed
    encoding of the IPv6 header that matches the capabilities of the underlying datalink
    layer [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html).
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到IPv6头部的尺寸，它可能会在低带宽链路上造成巨大的开销，尤其是在交换小数据包时，例如VoIP应用。在这样的环境中，可以使用几种技术来减少开销。第一个解决方案是在数据链路层使用数据压缩来压缩交换的所有信息[[Thomborson1992]](../bibliography.html#thomborson1992)。这些技术与在*compress(1)*或*gzip(1)*等工具中使用的数据压缩算法类似。它们压缩位流，而不利用这些流包含具有已知结构的IP数据包的事实。第二个解决方案是压缩IP和TCP头部。这些头部压缩技术，如[**RFC
    5795**](https://datatracker.ietf.org/doc/html/rfc5795.html)中定义的，利用了来自同一流的连续数据包中的冗余，从而显著减小了协议头部的尺寸。另一个解决方案是定义一个与底层数据链路层能力相匹配的IPv6头部压缩编码[**RFC
    4944**](https://datatracker.ietf.org/doc/html/rfc4944.html)。
- en: The last type of IPv6 header extension is the Routing header. The `type 0` routing
    header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    is an example of an IPv6 option that must be processed by some routers. This option
    is encoded as shown in [Fig. 123](#fig-ipv6-rh0).
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6头部扩展的最后一类是路由头部。在[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)中定义的`type
    0`路由头部是一个IPv6选项的例子，该选项必须由某些路由器处理。此选项的编码方式如图[图. 123](#fig-ipv6-rh0)所示。
- en: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)'
- en: Fig. 123 The Type 0 routing header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "Link to this image")
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 图 123 类型 0 路由头 ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "链接到此图像")
- en: 'The type 0 routing option was intended to allow a host to indicate a loose
    source route that should be followed by a packet by specifying the addresses of
    some of the routers that must forward this packet. Unfortunately, further work
    with this routing header, including an entertaining demonstration with [scapy](https://www.secdev.org/projects/scapy/)
    [[BE2007]](../bibliography.html#be2007) , revealed severe security problems with
    this routing header. For this reason, loose source routing with the type 0 routing
    header has been removed from the IPv6 specification [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html).  ###
    ICMP version 6[#](#icmp-version-6 "Link to this heading")'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '类型 0 路由选项旨在允许主机通过指定必须转发此数据包的一些路由器的地址来指示应遵循的松散源路由。不幸的是，包括使用 [scapy](https://www.secdev.org/projects/scapy/)
    的有趣演示在内的进一步工作，揭示了此路由头存在严重的安全问题。因此，使用类型 0 路由头的松散源路由已被从 IPv6 规范中删除 [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html)。  ###
    ICMP 版本 6[#](#icmp-version-6 "链接到此标题")'
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMPv6 is defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html).
    It is used both to report problems that occurred while processing an IPv6 packet,
    but also to distribute addresses.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，中间路由器或目标主机需要通知数据包的发送者处理数据包时发生的问题。在 TCP/IP 协议套件中，这种报告是通过互联网控制消息协议 (ICMP) 完成的。ICMPv6
    定义在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中。它既用于报告处理
    IPv6 数据包时出现的问题，也用于分配地址。
- en: ICMPv6 messages are carried inside IPv6 packets (the Next Header field for ICMPv6
    is `58`). Each ICMP message contains a 32 bits header with an 8 bits type field,
    a code field and a 16 bits checksum computed over the entire ICMPv6 message. The
    message body contains a copy of the IPv6 packet in error. The ICMPv6 header is
    shown in [Fig. 124](#fig-icmpv6-header).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 消息包含在 IPv6 数据包中（ICMPv6 的下一个头部字段为 `58`）。每个 ICMP 消息包含一个 32 位头部，其中包含一个 8
    位类型字段、一个代码字段和一个覆盖整个 ICMPv6 消息的 16 位校验和。消息体包含错误 IPv6 数据包的副本。ICMPv6 头部在 [图 124](#fig-icmpv6-header)
    中显示。
- en: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)'
- en: Fig. 124 ICMP version 6 packet format[#](#id46 "Link to this image")
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 图 124 ICMP 版本 6 数据包格式[#](#id46 "链接到此图像")
- en: 'ICMPv6 specifies two classes of messages : error messages that indicate a problem
    in handling a packet and informational messages. Four types of error messages
    are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    :'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 定义了两种消息类型：指示处理数据包时出现问题的错误消息和信息消息。在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    中定义了四种错误消息类型：
- en: '`1`Destination Unreachable. Such an ICMPv6 message is sent when the destination
    address of a packet is unreachable. The code field of the ICMP header contains
    additional information about the type of unreachability. The following codes are
    specified in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)'
  id: totrans-825
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：目标不可达。当数据包的目标地址不可达时，会发送此类 ICMPv6 消息。ICMP 头部的代码字段包含有关不可达类型的其他信息。以下代码在 [**RFC
    4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中指定'
- en: ''
  id: totrans-826
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-827
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-828
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-829
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-830
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` : No route to destination. This indicates that the router that sent the
    ICMPv6 message did not have a route towards the packet’s destination'
  id: totrans-831
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：无到目标的路由。这表示发送 ICMPv6 消息的路由器没有通往数据包目标的路由'
- en: ''
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` : Communication with destination administratively prohibited. This indicates
    that a firewall has refused to forward the packet towards its final destination.'
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：与目标通信被管理员禁止。这表示防火墙拒绝转发数据包到其最终目的地。'
- en: ''
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Beyond scope of source address. This message can be sent if the source
    is using link-local addresses to reach a global unicast address outside its subnet.'
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：源地址超出范围。如果源地址使用链路本地地址来访问其子网外的全局单播地址，则可以发送此消息。'
- en: ''
  id: totrans-838
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-839
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Address unreachable. This message indicates that the packet reached the
    subnet of the destination, but the host that owns this destination address cannot
    be reached.'
  id: totrans-840
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：地址不可达。此消息表示数据包已到达目的地的子网，但拥有此目的地址的主机无法到达。'
- en: ''
  id: totrans-841
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-842
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Port unreachable. This message indicates that the IPv6 packet was received
    by the destination, but there was no application listening to the specified port.'
  id: totrans-843
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：端口不可达。此消息表示 IPv6 数据包已到达目的地，但没有应用程序监听指定的端口。'
- en: ''
  id: totrans-844
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-848
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-849
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Packet Too Big. The router that was to send the ICMPv6 message received
    an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message
    contains the MTU of this link in bytes. This allows the sending host to implement
    Path MTU discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)'
  id: totrans-850
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：数据包太大。原本要发送 ICMPv6 消息的路由器接收到了一个比出站链路 MTU 大的 IPv6 数据包。ICMPv6 消息包含此链路的 MTU
    大小（以字节为单位）。这允许发送主机实现路径 MTU 发现 [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)。'
- en: ''
  id: totrans-851
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-852
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Time Exceeded. This error message can be sent either by a router or by
    a host. A router would set code to 0 to report the reception of a packet whose
    Hop Limit reached 0. A host would set code to 1 to report that it was unable to
    reassemble received IPv6 fragments.'
  id: totrans-853
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：时间超出。此错误消息可以由路由器或主机发送。路由器会将代码设置为 0 来报告接收到的数据包的跳数限制达到 0。主机会将代码设置为 1 来报告它无法重新组装接收到的
    IPv6 片段。'
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-855
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Parameter Problem. This ICMPv6 message is used to report either the reception
    of an IPv6 packet with an erroneous header field (code 0) or an unknown Next Header
    or IP option (codes 1 and 2). In this case, the message body contains the erroneous
    IPv6 packet and the first 32 bits of the message body contain a pointer to the
    error.'
  id: totrans-856
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：参数问题。此 ICMPv6 消息用于报告接收到的 IPv6 数据包带有错误的首部字段（代码 0）或未知下一个头部或 IP 选项（代码 1 和
    2）。在这种情况下，消息体包含错误的 IPv6 数据包，消息体的前 32 位包含一个指向错误的指针。'
- en: The Destination Unreachable ICMP error message is returned when a packet cannot
    be forwarded to its final destination. The first four ICMPv6 error messages (type
    `1`, codes `0-3`) are generated by routers while hosts may return code `4` when
    there is no application bound to the corresponding port number.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包无法转发到其最终目的地时，会返回目标不可达 ICMP 错误消息。前四个 ICMPv6 错误消息（类型 `1`，代码 `0-3`）由路由器生成，而主机在没有任何应用程序绑定到相应的端口号时可能会返回代码
    `4`。
- en: The Packet Too Big ICMP messages enable the source host to discover the MTU
    size that it can safely use to reach a given destination. To understand its operation,
    consider the (academic) scenario shown in [Fig. 125](#fig-ipv6-mtu-discovery).
    In this figure, the labels on each link represent the maximum packet size supported
    by this link.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包太大 ICMP 消息使源主机能够发现它可以安全使用的 MTU 大小，以便到达给定的目的地。为了理解其操作，请考虑图 125 中所示的（学术）场景。[图
    125](#fig-ipv6-mtu-discovery)。在此图中，每个链路上的标签表示该链路支持的最大的数据包大小。
- en: '![Figure made with TikZ](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 125 Example for IPv6 MTU discovery
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 125 IPv6 MTU 发现示例
- en: If `A` sends a 1500 bytes packet, `R1` will return an ICMPv6 error message indicating
    a maximum packet length of 1400 bytes. `A` would then fragment the packet before
    retransmitting it. The small fragment would go through, but the large fragment
    will be refused by `R2` that would return an ICMPv6 error message. `A` can fragment
    again the packet and send it to the final destination as two fragments.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `A` 发送一个 1500 字节的数据包，`R1` 将返回一个指示最大数据包长度为 1400 字节的 ICMPv6 错误消息。然后 `A` 将在重新传输之前将数据包分段。小片段将能够通过，但大片段将被
    `R2` 拒绝，`R2` 将返回一个 ICMPv6 错误消息。`A` 可以再次将数据包分段并发送到最后目的地作为两个片段。
- en: In practice, an IPv6 implementation does not store the transmitted packets to
    be able to retransmit them if needed. However, since TCP (and SCTP) buffer the
    segments that they transmit, a similar approach can be used in transport protocols
    to detect the largest MTU on a path towards a given destination. This technique
    is called PathMTU Discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，IPv6 实现不会存储要传输的数据包以便在需要时重新传输。然而，由于 TCP（和 SCTP）会缓存它们传输的段，因此在传输协议中可以使用类似的方法来检测通往给定目的地的路径上的最大
    MTU。这种技术称为路径 MTU 发现 [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)。
- en: When a TCP segment is transported in an IP packet that is fragmented in the
    network, the loss of a single fragment forces TCP to retransmit the entire segment
    (and thus all the fragments). If TCP was able to send only packets that do not
    require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 TCP 段在网络中的 IP 数据包中传输并且被分片时，单个分片的丢失会迫使 TCP 重新传输整个段（以及所有分片）。如果 TCP 能够发送不需要在网络中分片的数据包，它就只能重新传输在网络中丢失的信息。此外，如
    [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) 中讨论的那样，IP 重组在高速情况下会带来几个挑战。使用
    IP 分片来允许 UDP 应用程序交换大消息会引发几个安全问题 [[KPS2003]](../bibliography.html#kps2003)。
- en: ICMPv6 is used by TCP implementations to discover the largest MTU size that
    is allowed to reach a destination host without causing network fragmentation.
    A TCP implementation parses the Packets Too Big ICMP messages that it receives.
    These ICMP messages contain the MTU of the router’s outgoing link in their Data
    field. Upon reception of such an ICMP message, the source TCP implementation adjusts
    its Maximum Segment Size (MSS) so that the packets containing the segments that
    it sends can be forwarded by this router without requiring fragmentation.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 被 TCP 实现用来发现允许到达目的主机而不引起网络分片的最大 MTU 大小。TCP 实现解析它接收到的 Packets Too Big
    ICMP 消息。这些 ICMP 消息在其数据字段中包含路由器出链路的 MTU。在接收到此类 ICMP 消息后，源 TCP 实现调整其最大段大小（MSS），以便包含它发送的段的包可以由该路由器转发，而无需分片。
- en: 'Two types of informational ICMPv6 messages are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    : echo request and echo reply, which are used to test the reachability of a destination
    by using *ping6(8)*. Each host is supposed to reply with an ICMP Echo reply message
    when it receives an ICMP Echo request message. A sample usage of *ping6(8)* is
    shown below.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中定义了两种类型的信息性
    ICMPv6 消息：echo 请求和 echo 响应，它们用于通过 *ping6(8)* 测试目的地的可达性。当每个主机接收到一个 ICMP Echo 请求消息时，它都应该回复一个
    ICMP Echo 响应消息。以下是一个 *ping6(8)* 的示例用法。
- en: '[PRE11]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another very useful debugging tool is *traceroute6(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the Time exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose Hop Limit is set to `1` it is forced to return
    to the sending host a Time exceeded ICMP message containing the header and the
    first bytes of the discarded packet. To discover all routers on a network path,
    a simple solution is to first send a packet whose Hop Limit is set to 1, then
    a packet whose Hop Limit is set to 2, etc. A sample traceroute6 output is shown
    below.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试工具是 *traceroute6(8)*。traceroute 手册页将此工具描述为“打印数据包到达网络主机的路由”。traceroute
    使用 Time exceeded ICMP 消息来发现通往目的地的路径上的中间路由器。traceroute 的原理非常简单。当一个路由器收到一个 Hop Limit
    设置为 `1` 的 IP 数据包时，它被迫向发送主机返回一个包含头部和丢弃数据包的前几个字节的 Time exceeded ICMP 消息。为了发现网络路径上的所有路由器，一个简单的解决方案是首先发送一个
    Hop Limit 设置为 1 的数据包，然后发送一个 Hop Limit 设置为 2 的数据包，依此类推。以下是一个 traceroute6 输出的示例。
- en: '[PRE12]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rate limitation of ICMP messages
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 消息速率限制
- en: High-end hardware based routers use special purpose chips on their interfaces
    to forward IPv6 packets at line rate. These chips are optimized to process correct
    IP packets. They are not able to create ICMP messages at line rate. When such
    a chip receives an IP packet that triggers an ICMP message, it interrupts the
    main CPU of the router and the software running on this CPU processes the packet.
    This CPU is much slower than the hardware acceleration found on the interfaces
    [[Gill2004]](../bibliography.html#gill2004). It would be overloaded if it had
    to process IP packets at line rate and generate one ICMP message for each received
    packet. To protect this CPU, high-end routers limit the rate at which the hardware
    can interrupt the main CPU and thus the rate at which ICMP messages can be generated.
    This implies that not all erroneous IP packets cause the transmission of an ICMP
    message. The risk of overloading the main CPU of the router is also the reason
    why using hop-by-hop IPv6 options, including the router alert option is discouraged
    [[#falert]_](#id49).
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 基于高端硬件的路由器在其接口上使用专用芯片以线路速率转发IPv6数据包。这些芯片针对处理正确的IP数据包进行了优化。它们无法以线路速率创建ICMP消息。当这样的芯片接收到触发ICMP消息的IP数据包时，它会中断路由器的主CPU，并且在此CPU上运行的软件处理该数据包。这个CPU比接口上发现的硬件加速要慢得多
    [[Gill2004]](../bibliography.html#gill2004)。如果它必须以线路速率处理IP数据包并为每个接收到的数据包生成一个ICMP消息，它将会过载。为了保护这个CPU，高端路由器限制了硬件中断主CPU的速率，从而限制了ICMP消息的生成速率。这意味着并非所有错误的IP数据包都会导致ICMP消息的传输。路由器主CPU过载的风险也是不建议使用跳到跳IPv6选项，包括路由器警报选项的原因
    [[#falert]_](#id49)。
- en: Footnotes
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: IPv6 addressing architecture[#](#ipv6-addressing-architecture "Link to this
    heading")
  id: totrans-874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6寻址架构[#](#ipv6-addressing-architecture "链接到本标题")
- en: The experience of IPv4 revealed that the scalability of a network layer protocol
    heavily depends on its addressing architecture. The designers of IPv6 spent a
    lot of effort defining its addressing architecture [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html).
    All IPv6 addresses are 128 bits wide. This implies that there are \(340,282,366,920,938,463,463,374,607,431,768,211,456
    (3.4 \times 10^{38})\) different IPv6 addresses. As the surface of the Earth is
    about 510,072,000 \(km^2\), this implies that there are about \(6.67 \times 10^{23}\)
    IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only
    8 addresses per square kilometer, this is a significant improvement on paper.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的经验表明，网络层协议的可扩展性在很大程度上取决于其寻址架构。IPv6的设计者花费了大量精力来定义其寻址架构 [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html)。所有IPv6地址都是128位宽。这意味着有
    \(340,282,366,920,938,463,463,374,607,431,768,211,456 (3.4 \times 10^{38})\) 个不同的IPv6地址。由于地球的表面积约为510,072,000
    \(km^2\)，这意味着地球上每平方米大约有 \(6.67 \times 10^{23}\) 个IPv6地址。与仅提供每平方公里8个地址的IPv4相比，这在纸上是一个显著的改进。
- en: Note
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Textual representation of IPv6 addresses
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址的文本表示
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  id: totrans-878
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时有必要以文本格式编写IPv6地址，例如在手动配置地址或用于文档目的时。编写IPv6地址的首选格式是 `x:x:x:x:x:x:x:x`，其中 `x`
    是表示地址八个16位部分的十六进制数字。以下是一些IPv6地址的示例：
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  id: totrans-880
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
- en: ''
  id: totrans-881
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-882
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  id: totrans-883
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`'
- en: ''
  id: totrans-884
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0:0:0:219:e3ff:fed7:1204`'
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16 bits blocks containing only bits set to 0. For example,'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 'IPv6地址通常包含一个长的位序列，这些位被设置为 `0`。在这种情况下，已经定义了一种紧凑的表示法。使用这种表示法，:: 用于表示一个或多个只包含位设置为
    `0` 的16位块组。例如，'
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  id: totrans-888
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a` 表示为 `2001:db8::8:800:200c:417a`'
- en: ''
  id: totrans-889
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-890
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  id: totrans-891
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff01:0:0:0:0:0:0:101` 表示为 `ff01::101`'
- en: ''
  id: totrans-892
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-893
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  id: totrans-894
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` 表示为 `::1`'
- en: ''
  id: totrans-895
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-896
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  id: totrans-897
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` 表示为 `::`'
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 前缀可以表示为地址/长度，其中长度是前缀的位数长度。例如，以下三种表示法对应于相同的 IPv6 前缀：
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  id: totrans-899
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
- en: ''
  id: totrans-900
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-901
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  id: totrans-902
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8::cd30:0:0:0:0` / `60`'
- en: ''
  id: totrans-903
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  id: totrans-905
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0:cd30::` / `60`'
- en: IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address
    is used to identify one datalink-layer interface on a host. If a host has several
    datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then
    it needs several IPv6 addresses. In general, an IPv6 unicast address is structured
    as shown in [Fig. 113](#fig-ipv6-addr-structure).
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 支持单播、多播和任播地址。IPv6 单播地址用于标识主机上的一个数据链路层接口。如果一个主机有多个数据链路层接口（例如，一个以太网接口和一个
    Wi-Fi 接口），那么它需要多个 IPv6 地址。通常，IPv6 单播地址的结构如图 113 [所示](#fig-ipv6-addr-structure)。
- en: '![Figure made with TikZ](../Images/334d256816526fa56f8d5037c79a8b94.png)'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/334d256816526fa56f8d5037c79a8b94.png)'
- en: ''
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 113 Structure of IPv6 unicast addresses
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 113 IPv6 单播地址结构
- en: 'The IETF has reserved some IPv6 addresses for a special usage. The two most
    important ones are :'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: IETF 已经为一些 IPv6 地址保留了特殊用途。其中最重要的两个是：
- en: '`0:0:0:0:0:0:0:1` (`::1` in compact form) is the IPv6 loopback address. This
    is the address of a logical interface that is always up and running on IPv6 enabled
    hosts.'
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` （紧凑形式为 `::1`）是 IPv6 环回地址。这是在启用 IPv6 的主机上始终处于开启状态和运行状态的逻辑接口的地址。'
- en: ''
  id: totrans-912
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` (`::` in compact form) is the unspecified IPv6 address. This
    is the IPv6 address that a host can use as source address when trying to acquire
    an official address.'
  id: totrans-914
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` （紧凑形式为 `::`）是未指定 IPv6 地址。这是主机在尝试获取官方地址时可以用作源地址的 IPv6 地址。'
- en: The last type of unicast IPv6 addresses are the Link Local Unicast addresses
    shown in [Fig. 114](#fig-ipv6-link-local). These addresses are part of the fe80::/10
    address block and are defined in [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html).
    Each host can compute its own link local address by concatenating the fe80::/64
    prefix with the 64 bits identifier of its interface. Link local addresses can
    be used when hosts that are attached to the same link (or local area network)
    need to exchange packets. They are used notably for address discovery and auto-configuration
    purposes. Their usage is restricted to each link and a router cannot forward a
    packet whose source or destination address is a link local address. Link local
    addresses have also been defined for IPv4 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    However, the IPv4 link local addresses are only used when a host cannot obtain
    a regular IPv4 address, e.g. on an isolated LAN.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种单播 IPv6 地址是图 114 [所示](#fig-ipv6-link-local) 的链路本地单播地址。这些地址是 fe80::/10 地址块的一部分，并在
    [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html) 中定义。每个主机可以通过将其接口的
    64 位标识符与 fe80::/64 前缀连接起来来计算自己的链路本地地址。链路本地地址可以在连接到同一链路（或局域网）的主机需要交换数据包时使用。它们特别用于地址发现和自动配置目的。它们的用途仅限于每个链路，并且路由器不能转发源或目的地址为链路本地地址的数据包。IPv4
    也已为链路本地地址定义了 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。然而，IPv4
    链路本地地址仅在主机无法获取常规 IPv4 地址时使用，例如在孤立的局域网中。
- en: '![Figure made with TikZ](../Images/85809a63cecf02a8a699a08cbd775118.png)'
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/85809a63cecf02a8a699a08cbd775118.png)'
- en: ''
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 114 IPv6 link local address structure
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 114 IPv6 链路本地地址结构
- en: Note
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: All IPv6 hosts have several addresses
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 IPv6 主机都有多个地址
- en: An important consequence of the IPv6 unicast addressing architecture and the
    utilization of link-local addresses is that each IPv6 host has several IPv6 addresses.
    This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 单播寻址架构和链路本地地址的利用的重要后果是，每个 IPv6 主机都有多个 IPv6 地址。这意味着所有 IPv6 堆栈都必须能够处理多个 IPv6
    地址。
- en: The addresses described above are unicast addresses. These addresses are used
    to identify (interfaces on) hosts and routers. They can appear as source and destination
    addresses in the IPv6 packets. When a host sends a packet towards a unicast address,
    this packet is delivered by the network to its final destination. There are situations,
    such as when delivering video or television signal to a large number of receivers,
    where it is useful to have a network that can efficiently deliver the same packet
    to a large number of receivers. This is the multicast service. A multicast service
    can be provided in a LAN. In this case, a multicast address identifies a set of
    receivers and each frame sent towards this address is delivered to all receivers
    in the group. Multicast can also be used in a network containing routers and hosts.
    In this case, a multicast address identifies also a group of receivers and the
    network delivers efficiently each multicast packet to all members of the group.
    Consider for example the network shown in [Fig. 115](#fig-ipv6-simple-network).
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的地址是单播地址。这些地址用于标识（主机和路由器上的）主机和路由器。它们可以出现在 IPv6 包的源地址和目的地址中。当主机向单播地址发送包时，该包通过网络被交付到其最终目的地。在某些情况下，例如向大量接收器发送视频或电视信号时，拥有一个能够高效地将相同包发送到大量接收器的网络是有用的。这就是组播服务。组播服务可以在局域网中提供。在这种情况下，组播地址标识一组接收器，并且每个发送到该地址的帧都发送到组中的所有接收器。组播也可以用于包含路由器和主机的网络。在这种情况下，组播地址也标识一组接收器，并且网络高效地将每个组播包发送到组的所有成员。例如，考虑
    [图115](#fig-ipv6-simple-network) 中显示的网络。
- en: '![Figure made with TikZ](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
- en: ''
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 115 A simple network with hosts and routers
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图115 带有主机和路由器的简单网络
- en: Assume that `B` and `D` are part of a multicast group. If `A` sends a multicast
    packet towards this group, then `R1` will replicate the packet to forward it to
    `R2` and `R3`. `R2` would forward the packet towards `B`. `R3` would forward the
    packet towards `R4` that would deliver it to `D`.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `B` 和 `D` 是组播组的一部分。如果 `A` 向该组发送组播包，则 `R1` 将复制该包以将其转发到 `R2` 和 `R3`。`R2` 将将包转发到
    `B`。`R3` 将将包转发到 `R4`，它将将其交付给 `D`。
- en: Finally, [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)
    defines the structure of the IPv6 multicast addresses [[8]](#fmultiiana). This
    structure is depicted in [Fig. 116](#fig-ipv6-multicast-addr).
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html) 定义了 IPv6
    组播地址的结构 [[8]](#fmultiiana)。该结构在 [图116](#fig-ipv6-multicast-addr) 中表示。
- en: '![Figure made with TikZ](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 116 IPv6 multicast address structure
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图116 IPv6 组播地址结构
- en: The low order 112 bits of an IPv6 multicast address are the group’s identifier.
    The high order bits are used as a marker to distinguish multicast addresses from
    unicast addresses. Notably, the 4-bit Flags field indicates whether the address
    is temporary or permanent. Finally, the Scope field indicates the boundaries of
    the forwarding of packets destined to a particular address. A link-local scope
    indicates that a router should not forward a packet destined to such a multicast
    address. An organization local-scope indicates that a packet sent to such a multicast
    destination address should not leave the organization. Finally the global scope
    is intended for multicast groups spanning the global Internet.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6组播地址的低序112位是组的标识符。高序位用作标记，以区分组播地址和单播地址。值得注意的是，4位的标志字段表示地址是临时还是永久。最后，范围字段表示特定地址的包转发的边界。链路本地范围表示路由器不应转发目的地为这种组播地址的包。组织本地范围表示发送到这种组播目的地地址的包不应离开组织。最后，全局范围旨在用于跨越全球互联网的组播组。
- en: Among these addresses, some are well known. For example, all hosts automatically
    belong to the `ff02::1` multicast group while all routers automatically belong
    to the `ff02::2` multicast group. A detailed discussion of IPv6 multicast is outside
    the scope of this chapter.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些地址中，有些是众所周知的。例如，所有主机自动属于 `ff02::1` 组播组，而所有路由器自动属于 `ff02::2` 组播组。IPv6 组播的详细讨论超出了本章的范围。
- en: '### IPv6 packet[#](#ipv6-packet "Link to this heading")'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '### IPv6 包[#](#ipv6-packet "链接到这个标题")'
- en: The IPv6 packet format was heavily inspired by the packet format proposed for
    the SIPP protocol in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html).
    The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 117](#fig-ipv6-header-detail).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包格式在很大程度上受到了为SIPP协议提出的[**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)数据包格式的启发。在[**RFC
    2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)中定义的标准IPv6头部占用40字节，包含8个不同的字段，如图[图117](#fig-ipv6-header-detail)所示。
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)(../_images/ipv6.svg)'
- en: Fig. 117 The IP version 6 header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "Link to this image")
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 图117 IP版本6头部 ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "链接到此图像")
- en: 'Apart from the source and destination addresses, the IPv6 header contains the
    following fields :'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源地址和目的地址之外，IPv6头部还包含以下字段：
- en: 'Version : a 4 bits field set to 6 and intended to allow IP to evolve in the
    future if needed'
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本：一个4位字段，设置为6，旨在允许IP在需要时进行演变。
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Traffic class : this 8 bits field indicates the type of service expected by
    this packet and contains the `CE` and `ECT` flags that are used by Explicit Congestion
    Notification'
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流类别：这个8位字段指示此数据包期望的服务类型，并包含用于显式拥塞通知的`CE`和`ECT`标志。
- en: ''
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-943
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flow Label : this field was initially intended to be used to tag packets belonging
    to the same flow. A recent document, [**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)
    describes some possible usages of this field, but it is too early to tell whether
    it will be really used.'
  id: totrans-944
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流标签：该字段最初旨在用于标记属于同一流的数据包。一份最近的文件，[**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)描述了该字段的一些可能的用途，但还太早判断它是否真的会被使用。
- en: ''
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Payload Length : this is the size of the packet payload in bytes. As the length
    is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of
    payload.'
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效载荷长度：这是数据包有效载荷的大小（以字节为单位）。由于长度被编码为16位字段，IPv6数据包可以包含多达65535字节的负载。
- en: ''
  id: totrans-948
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-949
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next Header : this 8-bit field indicates the type [[9]](#fianaprotocol) of
    header that follows the IPv6 header. It can be a transport layer header (e.g.
    6 for TCP or 17 for UDP) or an IPv6 option.'
  id: totrans-950
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个头部：这个8位字段指示随后的IPv6头部类型 [[9]](#fianaprotocol)。它可以是传输层头部（例如，6表示TCP或17表示UDP）或IPv6选项。
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-952
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hop Limit : this 8-bit field indicates the number of routers that can forward
    the packet. It is decremented by one by each router and prevents packets from
    looping forever inside the network.'
  id: totrans-953
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳数限制：这个8位字段指示可以转发数据包的路由器数量。每个路由器将其减一，以防止数据包在网络内部无限循环。
- en: It is interesting to note that there is no checksum inside the IPv6 header.
    This is mainly because all datalink layers and transport protocols include a checksum
    or a CRC to protect their frames/segments against transmission errors. Adding
    a checksum in the IPv6 header would have forced each router to recompute the checksum
    of all packets, with limited benefit in detecting errors. In practice, an IP checksum
    allows for catching errors that occur inside routers (e.g. due to memory corruption)
    before the packet reaches its destination. However, this benefit was found to
    be too small given the reliability of current memories and the cost of computing
    the checksum on each router [[10]](#fipv4checksum).
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，IPv6头部中没有校验和。这主要是因为所有数据链路层和传输协议都包含校验和或CRC，以保护它们的帧/段免受传输错误的影响。在IPv6头部中添加校验和将迫使每个路由器重新计算所有数据包的校验和，这在检测错误方面的好处有限。实际上，IP校验和允许在数据包到达目的地之前捕获在路由器内部发生的错误（例如，由于内存损坏）。然而，鉴于当前内存的可靠性和在每个路由器上计算校验和的成本，这种好处被认为太小
    [[10]](#fipv4checksum)。
- en: 'When a host receives an IPv6 packet, it needs to determine which transport
    protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is
    the first role of the Next header field. The [IANA](https://www.iana.org) which
    manages the allocation of Internet resources and protocol parameters, maintains
    an official list of transport protocols [[9]](#fianaprotocol). The following protocol
    numbers are reserved :'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机接收到一个IPv6数据包时，它需要确定需要处理数据包负载的传输协议（UDP、TCP、SCTP等）。这是下一个头部字段的第一种作用。负责管理互联网资源分配和协议参数的[IANA](https://www.iana.org)，维护了一个官方的传输协议列表
    [[9]](#fianaprotocol)。以下协议号已被保留：
- en: '`TCP` uses Next Header number `6`'
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCP`使用下一个头部编号`6`'
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UDP` uses Next Header number `17`'
  id: totrans-959
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UDP` 使用下一个头部编号 `17`'
- en: ''
  id: totrans-960
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SCTP` uses Next Header number `132`'
  id: totrans-962
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCTP` 使用下一个头部编号 `132`'
- en: For example, an IPv6 packet that contains an TCP segment would appear as shown
    in [Fig. 118](#fig-ipv6-tcp).
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，包含 TCP 片段的 IPv6 数据包将如图 118 所示。
- en: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)'
- en: Fig. 118 An IPv6 packet containing an TCP segment[#](#id40 "Link to this image")
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 图 118 包含 TCP 片段的 IPv6 数据包[#](#id40 "链接到此图像")
- en: However, the Next header has broader usages than simply indicating the transport
    protocol which is responsible for the packet payload. An IPv6 packet can contain
    a chain of headers and the last one indicates the transport protocol that is responsible
    for the packet payload. Supporting a chain of headers is a clever design from
    an extensibility viewpoint. As we will see, this chain of headers has several
    usages.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一个头部除了简单地指示负责数据包有效载荷的传输协议之外，还有更广泛的使用。IPv6 数据包可以包含一系列头部，最后一个头部指示负责数据包有效载荷的传输协议。从可扩展性的角度来看，支持一系列头部是一个巧妙的设计。正如我们将看到的，这个头部链有几种用途。
- en: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) defines
    several types of IPv6 extension headers that could be added to an IPv6 packet
    :'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) 定义了可以添加到
    IPv6 数据包的几种类型的 IPv6 扩展头部：'
- en: Hop-by-Hop Options header. This option is processed by routers and hosts.
  id: totrans-968
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳-跳选项头部。此选项由路由器和主机处理。
- en: ''
  id: totrans-969
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-970
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Destination Options header. This option is processed only by hosts.
  id: totrans-971
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的地选项头部。此选项仅由主机处理。
- en: ''
  id: totrans-972
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-973
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Routing header. This option is processed by some nodes.
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由头部。此选项由某些节点处理。
- en: ''
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragment header. This option is processed only by hosts.
  id: totrans-977
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段标题。此选项仅由主机处理。
- en: ''
  id: totrans-978
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-979
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Authentication header. This option is processed only by hosts.
  id: totrans-980
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证头部。此选项仅由主机处理。
- en: ''
  id: totrans-981
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulating Security Payload. This option is processed only by hosts.
  id: totrans-983
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装安全载荷。此选项仅由主机处理。
- en: The last two headers are used to add security above IPv6 and implement IPSec.
    They are described in [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    and [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) and are
    outside the scope of this document.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个头部用于在 IPv6 上增加安全性并实现 IPSec。它们在 [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    和 [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) 中描述，并且超出了本文档的范围。
- en: The Hop-by-Hop Options header was designed to make IPv6 easily extensible. In
    theory, this option could be used to define new fields that were not foreseen
    when IPv6 was designed. It is intended to be processed by both routers and hosts.
    Deploying an extension to a network protocol can be difficult in practice since
    some nodes already support the extensions while others still use the old version
    and do not understand the extension. To deal with this issue, the IPv6 designers
    opted for a Type-Length-Value encoding of these IPv6 options. The Hop-by-Hop Options
    header is encoded as show in [Fig. 119](#fig-ipv6-hbhoption).
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 跳-跳选项头部是为了使 IPv6 更容易扩展而设计的。理论上，此选项可以用来定义在设计 IPv6 时未预见的新字段。它旨在由路由器和主机共同处理。在实际部署网络协议的扩展时可能会很困难，因为一些节点已经支持扩展，而其他节点仍在使用旧版本且不理解扩展。为了处理这个问题，IPv6
    设计者选择了这些 IPv6 选项的 Type-Length-Value 编码。跳-跳选项头部编码如图 119 所示。
- en: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)'
- en: Fig. 119 The IPv6 Hop-by-Hop Options header[#](#id41 "Link to this image")
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 图 119 IPv6 跳-跳选项头部[#](#id41 "链接到此图像")
- en: 'In this optional header, the Next Header field is used to support the chain
    of headers. It indicates the type of the next header in the chain. IPv6 headers
    have different lengths. The Hdr Ext Len field indicates the total length of the
    option header in bytes. The Opt. Type field indicates the type of option. These
    types are encoded such that their high order bits specify how the header needs
    to be handled by nodes that do not recognize it. The following values are defined
    for the two high order bits :'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在此可选头部中，下一个头部字段用于支持头部链。它指示链中下一个头部的类型。IPv6 头部有不同的长度。Hdr Ext Len 字段指示选项头部的总长度（以字节为单位）。Opt.
    Type 字段指示选项的类型。这些类型被编码，以便其高阶位指定节点在不识别它时如何处理头部。以下为两个高阶位定义的值：
- en: '`00` : if a node does not recognize this header, it can be safely skipped and
    the processing continues with the subsequent header'
  id: totrans-989
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00`：如果一个节点不识别这个头部，它可以安全地跳过，并继续处理随后的头部'
- en: ''
  id: totrans-990
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-991
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`01` : if a node does not recognize this header, the packet must be discarded'
  id: totrans-992
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01`：如果一个节点不识别这个头部，则必须丢弃该数据包'
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-994
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`10` (resp. `11`) : if a node does not recognize this header, it must return
    a control packet (ICMP, see later) back to the source (resp. except if the destination
    was a multicast address)'
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`（或`11`）：如果一个节点不识别这个头部，它必须返回一个控制包（ICMP，见后）回源地址（除非目的地址是组播地址）'
- en: This encoding allows the designers of protocol extensions to specify whether
    the option must be supported by all nodes on a path or not. Still, deploying such
    an extension can be difficult in practice.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码允许协议扩展的设计者指定选项是否必须由路径上的所有节点支持。尽管如此，在实践中部署此类扩展可能很困难。
- en: Two hop-by-hop options have been defined. [**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    specifies the jumbogram that enables IPv6 to support packets containing a payload
    larger than 65535 bytes. These jumbo packets have their payload length set to
    0 and the jumbogram option contains the packet length as a 32 bits field. Such
    packets can only be sent from a source to a destination if all the routers on
    the path support this option. However, as of this writing it does not seem that
    the jumbogram option has been implemented. The router alert option defined in
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) is the second
    example of a hop-by-hop option. The packets that contain this option should be
    processed in a special way by intermediate routers. This option is used for IP
    packets that carry Resource Reservation Protocol (RSVP) messages, but this is
    outside the scope of this book.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了两种跳到跳的选项。[**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    规定了大封包，使得IPv6能够支持包含大于65535字节有效载荷的数据包。这些大封包将有效载荷长度设置为0，而大封包选项包含一个32位的字段表示数据包长度。只有当路径上的所有路由器都支持此选项时，才能从源发送到目的地的数据包。然而，截至本文撰写时，似乎大封包选项尚未实现。在[**RFC
    2711**](https://datatracker.ietf.org/doc/html/rfc2711.html)中定义的“路由器警报”选项是跳到跳选项的第二个例子。包含此选项的数据包应由中间路由器以特殊方式处理。此选项用于携带资源预留协议（RSVP）消息的IP数据包，但这超出了本书的范围。
- en: The Destinations Option header uses the same format as the Hop-by-Hop Options
    header. It has some usages, e.g. to support mobile nodes [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html),
    but these are outside the scope of this document.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地选项头部使用与跳到跳选项头部相同的格式。它有一些用途，例如支持移动节点[**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html)，但这些超出了本文档的范围。
- en: The Fragment Options header is more important. An important problem in the network
    layer is the ability to handle heterogeneous datalink layers. Most datalink layer
    technologies can only transmit and receive frames that are shorter than a given
    maximum frame size. Unfortunately, all datalink layer technologies use different
    maximum frames sizes.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 分片选项头部更为重要。网络层的一个重要问题是处理异构数据链路层的能力。大多数数据链路层技术只能传输和接收小于给定最大帧大小的帧。不幸的是，所有数据链路层技术使用不同的最大帧大小。
- en: Each datalink layer has its own characteristics and as indicated earlier, each
    datalink layer is characterized by a maximum frame size. From IP’s point of view,
    a datalink layer interface is characterized by its Maximum Transmission Unit (MTU).
    The MTU of an interface is the largest packet (including header) that it can send.
    The table below provides some common MTU sizes.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据链路层都有其自身的特性，如前所述，每个数据链路层的特性是由其最大帧大小决定的。从IP的角度来看，数据链路层接口的特性是由其最大传输单元（MTU）决定的。接口的MTU是指它可以发送的最大数据包（包括头部）。下表提供了一些常见的MTU大小。
- en: '| Datalink layer | MTU |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | MTU |'
- en: '| Ethernet | 1500 bytes |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '| 以太网 | 1500 字节 |'
- en: '| WiFi | 2272 bytes |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 2272 字节 |'
- en: '| ATM (AAL5) | 9180 bytes |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
  zh: '| ATM (AAL5) | 9180 字节 |'
- en: '| 802.15.4 | 102 or 81 bytes |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
  zh: '| 802.15.4 | 102 或 81 字节 |'
- en: '| Token Ring | 4464 bytes |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '| 令牌环 | 4464 字节 |'
- en: '| FDDI | 4352 bytes |'
  id: totrans-1007
  prefs: []
  type: TYPE_TB
  zh: '| FDDI | 4352 字节 |'
- en: Although IPv6 can send 64 KBytes long packets, few datalink layer technologies
    that are used today are able to send a 64 KBytes packet inside a frame. Furthermore,
    as illustrated in [Fig. 120](#fig-ipv6-need-fragmentation), another problem is
    that a host may send a packet that would be too large for one of the datalink
    layers used by the intermediate routers.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IPv6可以发送64 KBytes长的数据包，但今天使用的少数数据链路层技术能够在一个帧内发送64 KBytes的数据包。此外，如图120所示，另一个问题是主机可能发送一个对于中间路由器使用的数据链路层来说太大的数据包。
- en: '![Figure made with TikZ](../Images/1baf064048236d27ceffa188e5e44d59.png)'
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/1baf064048236d27ceffa188e5e44d59.png)'
- en: ''
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 120 The need for fragmentation and reassembly
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图120 分片和重组的需求
- en: To solve these problems, IPv6 includes a packet fragmentation and reassembly
    mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate
    routers. However, experience with IPv4 has shown that fragmenting packets in routers
    was costly [[KM1995]](../bibliography.html#km1995). For this reason, the developers
    of IPv6 have decided that routers would not fragment packets anymore. In IPv6,
    fragmentation is only performed by the source host. If a source has to send a
    packet which is larger than the MTU of the outgoing interface, the packet needs
    to be fragmented before being transmitted. In IPv6, each packet fragment is an
    IPv6 packet that includes the Fragmentation header shown in [Fig. 121](#fig-ipv6-fragment-header).
    This header is included by the source in each packet fragment. The receiver uses
    them to reassemble the received fragments.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，IPv6包括数据包分片和重组机制。在IPv4中，分片由主机和中间路由器共同执行。然而，IPv4的经验表明，在路由器中分片数据包是昂贵的[[KM1995]](../bibliography.html#km1995)。因此，IPv6的开发者决定路由器将不再分片数据包。在IPv6中，分片仅由源主机执行。如果一个源必须发送一个大于出接口MTU的数据包，该数据包在传输之前需要被分片。在IPv6中，每个数据包分片都是一个包含[图121](#fig-ipv6-fragment-header)中显示的分片头部的IPv6数据包。该头部由源包含在每个数据包分片中。接收者使用它们来重组接收到的分片。
- en: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)'
- en: Fig. 121 IPv6 fragmentation header[#](#id43 "Link to this image")
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 图121 IPv6分片头部[#](#id43 "链接到这张图片")
- en: If a router receives a packet that is too long to be forwarded, the packet is
    dropped and the router returns an ICMPv6 message to inform the sender of the problem.
    The sender can then either fragment the packet or perform Path MTU discovery.
    In IPv6, packet fragmentation is performed only by the source by using IPv6 options.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个路由器收到一个太长而无法转发的数据包，该数据包将被丢弃，并且路由器将返回一个ICMPv6消息来通知发送者问题。发送者随后可以选择分片数据包或执行路径MTU发现。在IPv6中，数据包分片仅由源端通过使用IPv6选项来执行。
- en: 'In IPv6, fragmentation is performed exclusively by the source host and relies
    on the fragmentation header. This 64 bits header is composed of six fields :'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，分片仅由源主机执行，并依赖于分片头部。这个64位头部由六个字段组成：
- en: a Next Header field that indicates the type of the header that follows the fragmentation
    header
  id: totrans-1017
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示跟随分片头部之后头部长度的下一个头部字段
- en: ''
  id: totrans-1018
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1019
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: two Reserved fields set to 0.
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个保留字段设置为0。
- en: ''
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Fragment Offset is a 13-bit unsigned integer that contains the offset, in
    8 bytes units, of the data following this header, relative to the start of the
    original packet.
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片偏移是一个13位的无符号整数，包含相对于原始数据包起始点的偏移量，以8字节为单位。
- en: ''
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the More flag, which is set to 0 in the last fragment of a packet and to 1 in
    all other fragments.
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的标志，在数据包的最后一个分片中设置为0，在其他所有分片中设置为1。
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the 32-bit Identification field indicates to which original packet a fragment
    belongs. When a host sends fragmented packets, it should ensure that it does not
    reuse the same identification field for packets sent to the same destination during
    a period of MSL seconds. This is easier with the 32 bits identification used in
    the IPv6 fragmentation header, than with the 16 bits identification field of the
    IPv4 header.
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位标识字段指示一个分片属于哪个原始数据包。当一个主机发送分片数据包时，它应确保在MSL秒内不会为发送到同一目的地的数据包重复使用相同的标识字段。与IPv4头部中的16位标识字段相比，IPv6分片头部使用的32位标识字段更容易实现这一点。
- en: Some IPv6 implementations send the fragments of a packet in increasing fragment
    offset order, starting from the first fragment. Others send the fragments in reverse
    order, starting from the last fragment. The latter solution can be advantageous
    for the host that needs to reassemble the fragments, as it can easily allocate
    the buffer required to reassemble all fragments of the packet upon reception of
    the last fragment. When a host receives the first fragment of an IPv6 packet,
    it cannot know a priori the length of the entire IPv6 packet.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IPv6实现按照递增的片段偏移顺序发送数据包的片段，从第一个片段开始。其他实现则按照相反的顺序发送片段，从最后一个片段开始。对于需要重新组装片段的主机来说，后者解决方案可能更有优势，因为它可以在接收到最后一个片段后轻松地分配所需的缓冲区来重新组装所有片段。当一个主机接收到IPv6数据包的第一个片段时，它无法事先知道整个IPv6数据包的长度。
- en: '[Fig. 122](#fig-ipv6-fragmentation-example) provides an example of a fragmented
    IPv6 packet containing a UDP segment. The Next Header type reserved for the IPv6
    fragmentation option is 44.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '[图122](#fig-ipv6-fragmentation-example)展示了包含UDP段的分片IPv6数据包的示例。为IPv6分片选项保留的下一个头部类型是44。'
- en: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)(../_images/ipv6-frag-example.png)'
- en: Fig. 122 IPv6 fragmentation example[#](#id44 "Link to this image")
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 图122 IPv6分片示例[#](#id44 "链接到这张图片")
- en: The following pseudo-code details the IPv6 fragmentation, assuming that the
    packet does not contain options.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码详细说明了IPv6分片，假设数据包不包含选项。
- en: '[PRE13]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the above pseudocode, we maintain a single 32 bits counter that is incremented
    for each packet that needs to be fragmented. Other implementations to compute
    the packet identification are possible. [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    only requires that two fragmented packets that are sent within the MSL between
    the same pair of hosts have different identifications.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述伪代码中，我们维护一个32位的计数器，每次需要分片的数据包都会增加。其他实现计算数据包标识的方法是可能的。[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)仅要求在同一对主机之间发送的、在MSL时间内分片的两个数据包具有不同的标识符。
- en: The fragments of an IPv6 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包的片段可以以任何顺序到达目的地，因为每个片段在网络中独立转发，可能遵循不同的路径。此外，一些片段可能会丢失，永远不会到达目的地。
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv6 packet is a fragment
    or not by checking whether it contains a fragment header. If so, all fragments
    with the some identification must be reassembled together. The reassembly algorithm
    relies on the Identification field of the received fragments to associate a fragment
    with the corresponding packet being reassembled. Furthermore, the Fragment Offset
    field indicates the position of the fragment payload in the original non-fragmented
    packet. Finally, the packet with the M flag reset allows the destination to determine
    the total length of the original non-fragmented packet.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 目的主机使用的重新组装算法大致如下。首先，目的地可以通过检查是否包含片段头部来验证接收到的IPv6数据包是否为片段。如果是，则必须将具有相同标识符的所有片段一起重新组装。重新组装算法依赖于接收到的片段的标识符字段来关联一个片段与正在重新组装的相应数据包。此外，片段偏移字段指示片段有效载荷在原始非分片数据包中的位置。最后，M标志被重置的包允许目的地确定原始非分片数据包的总长度。
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bind the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重组算法必须处理 IP 网络的不可靠性。这意味着一个片段可能会被重复，或者一个片段可能永远无法到达目的地。目的地可以通过片段偏移量轻松检测到片段重复。为了处理片段丢失，重组算法必须在重组数据包期间将数据包的片段存储在其缓冲区中的时间绑定。这可以通过在接收到数据包的第一个片段时启动计时器来实现。如果在计时器到期之前数据包没有被重组，则丢弃所有片段，并认为数据包已丢失。
- en: Note
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Header compression on low bandwidth links
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 低带宽链路上的头部压缩
- en: Given the size of the IPv6 header, it can cause huge overhead on low bandwidth
    links, especially when small packets are exchanged such as for Voice over IP applications.
    In such environments, several techniques can be used to reduce the overhead. A
    first solution is to use data compression in the datalink layer to compress all
    the information exchanged [[Thomborson1992]](../bibliography.html#thomborson1992).
    These techniques are similar to the data compression algorithms used in tools
    such as *compress(1)* or *gzip(1)* [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html).
    They compress streams of bits without taking advantage of the fact that these
    streams contain IP packets with a known structure. A second solution is to compress
    the IP and TCP header. These header compression techniques, such as the one defined
    in [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html) take advantage
    of the redundancy found in successive packets from the same flow to significantly
    reduce the size of the protocol headers. Another solution is to define a compressed
    encoding of the IPv6 header that matches the capabilities of the underlying datalink
    layer [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html).
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 IPv6 头部的大小，它可能会在低带宽链路上造成巨大的开销，尤其是在交换小数据包的情况下，例如用于 VoIP 应用。在这样的环境中，可以使用几种技术来减少开销。第一个解决方案是在数据链路层使用数据压缩来压缩交换的所有信息
    [[Thomborson1992]](../bibliography.html#thomborson1992)。这些技术与在 *compress(1)* 或
    *gzip(1)* 等工具中使用的数据压缩算法类似 [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html)。它们压缩位流，而没有利用这些流包含具有已知结构的
    IP 数据包的事实。第二个解决方案是压缩 IP 和 TCP 头部。这些头部压缩技术，例如在 [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html)
    中定义的技术，利用了来自同一流的连续数据包中的冗余，从而显著减小了协议头部的大小。另一个解决方案是定义一个与底层数据链路层能力相匹配的 IPv6 头部压缩编码
    [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html)。
- en: The last type of IPv6 header extension is the Routing header. The `type 0` routing
    header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    is an example of an IPv6 option that must be processed by some routers. This option
    is encoded as shown in [Fig. 123](#fig-ipv6-rh0).
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 头部扩展的最后一类是路由头。在 [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    中定义的 `type 0` 路由头是一个必须由某些路由器处理的 IPv6 选项的例子。此选项的编码方式如图 123 所示。
- en: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
- en: Fig. 123 The Type 0 routing header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "Link to this image")
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 图 123 类型 0 路由头 ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "链接到此图像")
- en: The type 0 routing option was intended to allow a host to indicate a loose source
    route that should be followed by a packet by specifying the addresses of some
    of the routers that must forward this packet. Unfortunately, further work with
    this routing header, including an entertaining demonstration with [scapy](https://www.secdev.org/projects/scapy/)
    [[BE2007]](../bibliography.html#be2007) , revealed severe security problems with
    this routing header. For this reason, loose source routing with the type 0 routing
    header has been removed from the IPv6 specification [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html).
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 0 路由选项旨在允许主机通过指定必须转发此数据包的一些路由器的地址来指示应遵循的松散源路由。不幸的是，进一步使用此路由头的工作，包括使用 [scapy](https://www.secdev.org/projects/scapy/)
    的娱乐性演示 [[BE2007]](../bibliography.html#be2007)，揭示了此路由头存在严重的安全问题。因此，使用类型 0 路由头进行的松散源路由已被从
    IPv6 规范中删除 [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html)。
- en: '### ICMP version 6[#](#icmp-version-6 "Link to this heading")'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '### ICMP 版本 6[#](#icmp-version-6 "链接到此标题")'
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMPv6 is defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html).
    It is used both to report problems that occurred while processing an IPv6 packet,
    but also to distribute addresses.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据包时，有时中间路由器或目的主机需要通知数据包发送者出现的问题。在 TCP/IP 协议套件中，这种报告是通过互联网控制消息协议 (ICMP) 来完成的。ICMPv6
    定义在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中。它既用于报告处理
    IPv6 数据包时出现的问题，也用于分配地址。
- en: ICMPv6 messages are carried inside IPv6 packets (the Next Header field for ICMPv6
    is `58`). Each ICMP message contains a 32 bits header with an 8 bits type field,
    a code field and a 16 bits checksum computed over the entire ICMPv6 message. The
    message body contains a copy of the IPv6 packet in error. The ICMPv6 header is
    shown in [Fig. 124](#fig-icmpv6-header).
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 消息承载在 IPv6 数据包中（ICMPv6 的下一个头部字段为 `58`）。每个 ICMP 消息包含一个 32 位头部，其中包含一个 8
    位类型字段、一个代码字段和一个覆盖整个 ICMPv6 消息的 16 位校验和。消息体包含错误 IPv6 数据包的副本。ICMPv6 头部在 [图 124](#fig-icmpv6-header)
    中显示。
- en: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
- en: Fig. 124 ICMP version 6 packet format[#](#id46 "Link to this image")
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 图 124 ICMP 版本 6 数据包格式[#](#id46 "链接到此图像")
- en: 'ICMPv6 specifies two classes of messages : error messages that indicate a problem
    in handling a packet and informational messages. Four types of error messages
    are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    :'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 指定了两类消息：指示处理数据包问题时的问题消息和信息性消息。在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    中定义了四种类型的错误消息：
- en: '`1`Destination Unreachable. Such an ICMPv6 message is sent when the destination
    address of a packet is unreachable. The code field of the ICMP header contains
    additional information about the type of unreachability. The following codes are
    specified in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)'
  id: totrans-1053
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 目的地不可达。当数据包的目的地址不可达时，会发送此类 ICMPv6 消息。ICMP 头部的代码字段包含有关不可达类型的其他信息。以下代码在 [**RFC
    4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中指定'
- en: ''
  id: totrans-1054
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1057
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1058
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` : No route to destination. This indicates that the router that sent the
    ICMPv6 message did not have a route towards the packet’s destination'
  id: totrans-1059
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` : 无路由到达目的地。这表示发送 ICMPv6 消息的路由器没有通往数据包目的地的路由'
- en: ''
  id: totrans-1060
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1061
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` : Communication with destination administratively prohibited. This indicates
    that a firewall has refused to forward the packet towards its final destination.'
  id: totrans-1062
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` : 管理上禁止与目的地通信。这表示防火墙拒绝转发数据包到其最终目的地。'
- en: ''
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1064
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Beyond scope of source address. This message can be sent if the source
    is using link-local addresses to reach a global unicast address outside its subnet.'
  id: totrans-1065
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` : 源地址范围外。如果源使用链路本地地址来访问其子网之外的全球单播地址，则可以发送此消息。'
- en: ''
  id: totrans-1066
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Address unreachable. This message indicates that the packet reached the
    subnet of the destination, but the host that owns this destination address cannot
    be reached.'
  id: totrans-1068
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` : 地址不可达。此消息表示数据包已到达目的地的子网，但无法到达拥有此目的地址的主机。'
- en: ''
  id: totrans-1069
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1070
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Port unreachable. This message indicates that the IPv6 packet was received
    by the destination, but there was no application listening to the specified port.'
  id: totrans-1071
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4` : 端口不可达。此消息表示IPv6数据包已由目的地接收，但没有应用程序监听指定的端口。'
- en: ''
  id: totrans-1072
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1073
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1074
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1075
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1077
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Packet Too Big. The router that was to send the ICMPv6 message received
    an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message
    contains the MTU of this link in bytes. This allows the sending host to implement
    Path MTU discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)'
  id: totrans-1078
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` : 数据包太大。原本要发送ICMPv6消息的路由器接收到了一个大于出链路MTU的IPv6数据包。ICMPv6消息包含此链路的MTU（以字节为单位）。这允许发送主机实现路径MTU发现[**RFC
    1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)。'
- en: ''
  id: totrans-1079
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1080
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Time Exceeded. This error message can be sent either by a router or by
    a host. A router would set code to 0 to report the reception of a packet whose
    Hop Limit reached 0. A host would set code to 1 to report that it was unable to
    reassemble received IPv6 fragments.'
  id: totrans-1081
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` : 时间超限。此错误消息可以由路由器或主机发送。路由器会将代码设置为0以报告接收到的数据包的跳数限制达到0。主机会将代码设置为1以报告它无法重新组装接收到的IPv6分片。'
- en: ''
  id: totrans-1082
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1083
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Parameter Problem. This ICMPv6 message is used to report either the reception
    of an IPv6 packet with an erroneous header field (code 0) or an unknown Next Header
    or IP option (codes 1 and 2). In this case, the message body contains the erroneous
    IPv6 packet and the first 32 bits of the message body contain a pointer to the
    error.'
  id: totrans-1084
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4` : 参数问题。此ICMPv6消息用于报告接收到的IPv6数据包带有错误的首部字段（代码0）或未知下一个头部或IP选项（代码1和2）。在这种情况下，消息体包含错误的数据包和消息体前32位包含一个指向错误的指针。'
- en: The Destination Unreachable ICMP error message is returned when a packet cannot
    be forwarded to its final destination. The first four ICMPv6 error messages (type
    `1`, codes `0-3`) are generated by routers while hosts may return code `4` when
    there is no application bound to the corresponding port number.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包无法转发到其最终目的地时，会返回目标不可达ICMP错误消息。前四个ICMPv6错误消息（类型`1`，代码`0-3`）由路由器生成，而主机在没有任何应用程序绑定到相应的端口号时可能会返回代码`4`。
- en: The Packet Too Big ICMP messages enable the source host to discover the MTU
    size that it can safely use to reach a given destination. To understand its operation,
    consider the (academic) scenario shown in [Fig. 125](#fig-ipv6-mtu-discovery).
    In this figure, the labels on each link represent the maximum packet size supported
    by this link.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包太大ICMP消息使源主机能够发现它可以安全使用的MTU大小以到达给定目的地。为了理解其操作，考虑[图125](#fig-ipv6-mtu-discovery)中所示的（学术）场景。在此图中，每个链路上的标签代表该链路支持的最大的数据包大小。
- en: '![Figure made with TikZ](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 125 Example for IPv6 MTU discovery
  id: totrans-1089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图125：IPv6 MTU发现的示例
- en: If `A` sends a 1500 bytes packet, `R1` will return an ICMPv6 error message indicating
    a maximum packet length of 1400 bytes. `A` would then fragment the packet before
    retransmitting it. The small fragment would go through, but the large fragment
    will be refused by `R2` that would return an ICMPv6 error message. `A` can fragment
    again the packet and send it to the final destination as two fragments.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`A`发送一个1500字节的数据包，`R1`将返回一个指示最大数据包长度为1400字节的ICMPv6错误消息。然后`A`将分片数据包并在重新传输之前发送。小分片将能够通过，但大分片将被`R2`拒绝，并返回一个ICMPv6错误消息。`A`可以再次分片数据包并将其作为两个分片发送到最终目的地。
- en: In practice, an IPv6 implementation does not store the transmitted packets to
    be able to retransmit them if needed. However, since TCP (and SCTP) buffer the
    segments that they transmit, a similar approach can be used in transport protocols
    to detect the largest MTU on a path towards a given destination. This technique
    is called PathMTU Discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html).
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，IPv6实现不会存储要传输的数据包以便在需要时重新传输。然而，由于TCP（和SCTP）缓存它们传输的段，可以在传输协议中使用类似的方法来检测通向给定目的地的路径上的最大MTU。这种技术称为路径MTU发现[**RFC
    1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)。
- en: When a TCP segment is transported in an IP packet that is fragmented in the
    network, the loss of a single fragment forces TCP to retransmit the entire segment
    (and thus all the fragments). If TCP was able to send only packets that do not
    require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 当TCP段在网络中通过分片的数据包传输时，单个分片丢失会迫使TCP重新传输整个段（以及所有分片）。如果TCP能够发送不需要在网络中分片的数据包，它只需重新传输在网络中丢失的信息。此外，如[**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html)中讨论的那样，IP重组在高速情况下引起了一些挑战。使用IP分片允许UDP应用程序交换大型消息，这引发了一些安全问题
    [[KPS2003]](../bibliography.html#kps2003)。
- en: ICMPv6 is used by TCP implementations to discover the largest MTU size that
    is allowed to reach a destination host without causing network fragmentation.
    A TCP implementation parses the Packets Too Big ICMP messages that it receives.
    These ICMP messages contain the MTU of the router’s outgoing link in their Data
    field. Upon reception of such an ICMP message, the source TCP implementation adjusts
    its Maximum Segment Size (MSS) so that the packets containing the segments that
    it sends can be forwarded by this router without requiring fragmentation.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 被TCP实现用于发现允许到达目标主机而不引起网络分片的最大MTU大小。TCP实现解析它接收到的“数据包太大”ICMP消息。这些ICMP消息在其数据字段中包含路由器出链路的MTU。在接收到这样的ICMP消息后，源TCP实现调整其最大分段大小（MSS），以便包含它发送的段的数据包可以由该路由器转发，而无需分片。
- en: 'Two types of informational ICMPv6 messages are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    : echo request and echo reply, which are used to test the reachability of a destination
    by using *ping6(8)*. Each host is supposed to reply with an ICMP Echo reply message
    when it receives an ICMP Echo request message. A sample usage of *ping6(8)* is
    shown below.'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html) 中定义了两种类型的信息ICMPv6消息：回显请求和回显回复，它们用于通过
    *ping6(8)* 测试目标的可达性。每个主机在接收到ICMP回显请求消息时都应该回复一个ICMP回显回复消息。以下是一个 *ping6(8)* 的示例用法。
- en: '[PRE14]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another very useful debugging tool is *traceroute6(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the Time exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose Hop Limit is set to `1` it is forced to return
    to the sending host a Time exceeded ICMP message containing the header and the
    first bytes of the discarded packet. To discover all routers on a network path,
    a simple solution is to first send a packet whose Hop Limit is set to 1, then
    a packet whose Hop Limit is set to 2, etc. A sample traceroute6 output is shown
    below.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的调试工具是 *traceroute6(8)*。traceroute手册页将此工具描述为“打印数据包到达网络主机的路由”。traceroute使用超时ICMP消息来发现通往目标的路由器。traceroute背后的原理非常简单。当一个路由器收到一个跳数限制设置为`1`的IP数据包时，它被迫向发送主机返回一个包含头部和丢弃数据包的前几个字节的超时ICMP消息。为了发现网络路径上的所有路由器，一个简单的解决方案是首先发送一个跳数限制设置为1的数据包，然后发送一个跳数限制设置为2的数据包，依此类推。以下是一个traceroute6输出的示例。
- en: '[PRE15]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Rate limitation of ICMP messages
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP消息的速率限制
- en: High-end hardware based routers use special purpose chips on their interfaces
    to forward IPv6 packets at line rate. These chips are optimized to process correct
    IP packets. They are not able to create ICMP messages at line rate. When such
    a chip receives an IP packet that triggers an ICMP message, it interrupts the
    main CPU of the router and the software running on this CPU processes the packet.
    This CPU is much slower than the hardware acceleration found on the interfaces
    [[Gill2004]](../bibliography.html#gill2004). It would be overloaded if it had
    to process IP packets at line rate and generate one ICMP message for each received
    packet. To protect this CPU, high-end routers limit the rate at which the hardware
    can interrupt the main CPU and thus the rate at which ICMP messages can be generated.
    This implies that not all erroneous IP packets cause the transmission of an ICMP
    message. The risk of overloading the main CPU of the router is also the reason
    why using hop-by-hop IPv6 options, including the router alert option is discouraged
    [[#falert]_](#id49).
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于高端硬件的路由器在其接口上使用专用芯片以线路速率转发IPv6数据包。这些芯片经过优化以处理正确的IP数据包。它们无法以线路速率创建ICMP消息。当这样的芯片接收到触发ICMP消息的IP数据包时，它会中断路由器的主CPU，并且在此CPU上运行的软件处理该数据包。这个CPU比接口上发现的硬件加速要慢得多
    [[Gill2004]](../bibliography.html#gill2004)。如果它必须以线路速率处理IP数据包并为每个接收到的数据包生成一个ICMP消息，它将会过载。为了保护这个CPU，高端路由器限制了硬件中断主CPU的速率，从而限制了ICMP消息的生成速率。这意味着并非所有错误的IP数据包都会导致ICMP消息的传输。路由器主CPU过载的风险也是不建议使用跳到跳IPv6选项，包括路由器警报选项的原因
    [[#falert]_](#id49)。
- en: Footnotes
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
