- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2025-12-20 20:16:26'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2025-12-20 20:16:26
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: The little book about OS development
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于操作系统开发的简明指南
- en: 来源：[http://littleosbook.github.io/](http://littleosbook.github.io/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[http://littleosbook.github.io/](http://littleosbook.github.io/)
- en: Contents
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: '[1 Introduction](#introduction)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1 简介](#introduction)'
- en: '[1.1 About the Book](#about-the-book)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.1 关于本书](#about-the-book)'
- en: '[1.2 The Reader](#the-reader)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.2 读者](#the-reader)'
- en: '[1.3 Credits, Thanks and Acknowledgements](#credits-thanks-and-acknowledgements)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.3 信用、感谢和致谢](#credits-thanks-and-acknowledgements)'
- en: '[1.4 Contributors](#contributors)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.4 贡献者](#contributors)'
- en: '[1.5 Changes and Corrections](#changes-and-corrections)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.5 变更和更正](#changes-and-corrections)'
- en: '[1.6 Issues and where to get help](#issues-and-where-to-get-help)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.6 问题及获取帮助的地方](#issues-and-where-to-get-help)'
- en: '[1.7 License](#license)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1.7 许可证](#license)'
- en: '[2 First Steps](#first-steps)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2 第一步](#first-steps)'
- en: '[2.1 Tools](#tools)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1 工具](#tools)'
- en: '[2.1.1 Quick Setup](#quick-setup)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1.1 快速设置](#quick-setup)'
- en: '[2.1.2 Programming Languages](#programming-languages)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1.2 编程语言](#programming-languages)'
- en: '[2.1.3 Host Operating System](#host-operating-system)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1.3 主操作系统](#host-operating-system)'
- en: '[2.1.4 Build System](#build-system)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1.4 构建系统](#build-system)'
- en: '[2.1.5 Virtual Machine](#virtual-machine)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.1.5 虚拟机](#virtual-machine)'
- en: '[2.2 Booting](#booting)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2 引导](#booting)'
- en: '[2.2.1 BIOS](#bios)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2.1 BIOS](#bios)'
- en: '[2.2.2 The Bootloader](#the-bootloader)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2.2 引导加载程序](#the-bootloader)'
- en: '[2.2.3 The Operating System](#the-operating-system)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.2.3 操作系统](#the-operating-system)'
- en: '[2.3 Hello Cafebabe](#hello-cafebabe)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3 欢迎来到 Cafebabe](#hello-cafebabe)'
- en: '[2.3.1 Compiling the Operating System](#compiling-the-operating-system)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3.1 编译操作系统](#compiling-the-operating-system)'
- en: '[2.3.2 Linking the Kernel](#linking-the-kernel)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3.2 链接内核](#linking-the-kernel)'
- en: '[2.3.3 Obtaining GRUB](#obtaining-grub)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3.3 获取 GRUB](#obtaining-grub)'
- en: '[2.3.4 Building an ISO Image](#building-an-iso-image)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3.4 构建 ISO 镜像](#building-an-iso-image)'
- en: '[2.3.5 Running Bochs](#running-bochs)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.3.5 运行 Bochs](#running-bochs)'
- en: '[2.4 Further Reading](#further-reading)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2.4 进一步阅读](#further-reading)'
- en: '[3 Getting to C](#getting-to-c)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3 进入 C](#getting-to-c)'
- en: '[3.1 Setting Up a Stack](#setting-up-a-stack)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.1 设置堆栈](#setting-up-a-stack)'
- en: '[3.2 Calling C Code From Assembly](#calling-c-code-from-assembly)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.2 从汇编调用 C 代码](#calling-c-code-from-assembly)'
- en: '[3.2.1 Packing Structs](#packing-structs)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.2.1 结构体打包](#packing-structs)'
- en: '[3.3 Compiling C Code](#compiling-c-code)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.3 编译 C 代码](#compiling-c-code)'
- en: '[3.4 Build Tools](#build-tools)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.4 构建工具](#build-tools)'
- en: '[3.5 Further Reading](#further-reading-1)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3.5 进一步阅读](#further-reading-1)'
- en: '[4 Output](#output)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4 输出](#output)'
- en: '[4.1 Interacting with the Hardware](#interacting-with-the-hardware)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.1 与硬件交互](#interacting-with-the-hardware)'
- en: '[4.2 The Framebuffer](#the-framebuffer)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2 帧缓冲区](#the-framebuffer)'
- en: '[4.2.1 Writing Text](#writing-text)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2.1 写入文本](#writing-text)'
- en: '[4.2.2 Moving the Cursor](#moving-the-cursor)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2.2 移动光标](#moving-the-cursor)'
- en: '[4.2.3 The Driver](#the-driver)'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.2.3 驱动程序](#the-driver)'
- en: '[4.3 The Serial Ports](#the-serial-ports)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3 串行端口](#the-serial-ports)'
- en: '[4.3.1 Configuring the Serial Port](#configuring-the-serial-port)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.1 配置串行端口](#configuring-the-serial-port)'
- en: '[4.3.2 Configuring the Line](#configuring-the-line)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.2 配置线路](#configuring-the-line)'
- en: '[4.3.3 Configuring the Buffers](#configuring-the-buffers)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.3 配置缓冲区](#configuring-the-buffers)'
- en: '[4.3.4 Configuring the Modem](#configuring-the-modem)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.4 配置调制解调器](#configuring-the-modem)'
- en: '[4.3.5 Writing Data to the Serial Port](#writing-data-to-the-serial-port)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.5 向串行端口写入数据](#writing-data-to-the-serial-port)'
- en: '[4.3.6 Configuring Bochs](#configuring-bochs)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.6 配置 Bochs](#configuring-bochs)'
- en: '[4.3.7 The Driver](#the-driver-1)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.3.7 驱动程序](#the-driver-1)'
- en: '[4.4 Further Reading](#further-reading-2)'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4.4 进一步阅读](#further-reading-2)'
- en: '[5 Segmentation](#segmentation)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5 分段](#segmentation)'
- en: '[5.1 Accessing Memory](#accessing-memory)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.1 访问内存](#accessing-memory)'
- en: '[5.2 The Global Descriptor Table (GDT)](#the-global-descriptor-table-gdt)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.2 全局描述符表 (GDT)](#the-global-descriptor-table-gdt)'
- en: '[5.3 Loading the GDT](#loading-the-gdt)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.3 加载 GDT](#loading-the-gdt)'
- en: '[5.4 Further Reading](#further-reading-3)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5.4 进一步阅读](#further-reading-3)'
- en: '[6 Interrupts and Input](#interrupts-and-input)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6 中断和输入](#interrupts-and-input)'
- en: '[6.1 Interrupts Handlers](#interrupts-handlers)'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.1 中断处理程序](#interrupts-handlers)'
- en: '[6.2 Creating an Entry in the IDT](#creating-an-entry-in-the-idt)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.2 在 IDT 中创建条目](#creating-an-entry-in-the-idt)'
- en: '[6.3 Handling an Interrupt](#handling-an-interrupt)'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.3 处理中断](#handling-an-interrupt)'
- en: '[6.4 Creating a Generic Interrupt Handler](#creating-a-generic-interrupt-handler)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.4 创建通用中断处理程序](#creating-a-generic-interrupt-handler)'
- en: '[6.5 Loading the IDT](#loading-the-idt)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.5 加载 IDT](#loading-the-idt)'
- en: '[6.6 Programmable Interrupt Controller (PIC)](#programmable-interrupt-controller-pic)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.6 可编程中断控制器 (PIC)](#programmable-interrupt-controller-pic)'
- en: '[6.7 Reading Input from the Keyboard](#reading-input-from-the-keyboard)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.7 从键盘读取输入](#reading-input-from-the-keyboard)'
- en: '[6.8 Further Reading](#further-reading-4)'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6.8 进一步阅读](#further-reading-4)'
- en: '[7 The Road to User Mode](#the-road-to-user-mode)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7 用户模式之路](#the-road-to-user-mode)'
- en: '[7.1 Loading an External Program](#loading-an-external-program)'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.1 加载外部程序](#loading-an-external-program)'
- en: '[7.1.1 GRUB Modules](#grub-modules)'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.1.1 GRUB模块](#grub-modules)'
- en: '[7.2 Executing a Program](#executing-a-program)'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2 执行程序](#executing-a-program)'
- en: '[7.2.1 A Very Simple Program](#a-very-simple-program)'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2.1 一个非常简单的程序](#a-very-simple-program)'
- en: '[7.2.2 Compiling](#compiling)'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2.2 编译](#compiling)'
- en: '[7.2.3 Finding the Program in Memory](#finding-the-program-in-memory)'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2.3 在内存中查找程序](#finding-the-program-in-memory)'
- en: '[7.2.4 Jumping to the Code](#jumping-to-the-code)'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.2.4 跳转到代码](#jumping-to-the-code)'
- en: '[7.3 The Beginning of User Mode](#the-beginning-of-user-mode)'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7.3 用户模式开始](#the-beginning-of-user-mode)'
- en: '[8 A Short Introduction to Virtual Memory](#a-short-introduction-to-virtual-memory)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8 虚拟内存简介](#a-short-introduction-to-virtual-memory)'
- en: '[8.1 Virtual Memory Through Segmentation?](#virtual-memory-through-segmentation)'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.1 通过分段实现虚拟内存？](#virtual-memory-through-segmentation)'
- en: '[8.2 Further Reading](#further-reading-5)'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8.2 进一步阅读](#further-reading-5)'
- en: '[9 Paging](#paging)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9 分页](#paging)'
- en: '[9.1 Why Paging?](#why-paging)'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.1 为什么需要分页？](#why-paging)'
- en: '[9.2 Paging in x86](#paging-in-x86)'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.2 x86中的分页](#paging-in-x86)'
- en: '[9.2.1 Identity Paging](#identity-paging)'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.2.1 身份分页](#identity-paging)'
- en: '[9.2.2 Enabling Paging](#enabling-paging)'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.2.2 启用分页](#enabling-paging)'
- en: '[9.2.3 A Few Details](#a-few-details)'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.2.3 一些细节](#a-few-details)'
- en: '[9.3 Paging and the Kernel](#paging-and-the-kernel)'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3 分页与内核](#paging-and-the-kernel)'
- en: '[9.3.1 Reasons to Not Identity Map the Kernel](#reasons-to-not-identity-map-the-kernel)'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3.1 不将内核映射为身份映射的原因](#reasons-to-not-identity-map-the-kernel)'
- en: '[9.3.2 The Virtual Address for the Kernel](#the-virtual-address-for-the-kernel)'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3.2 内核的虚拟地址](#the-virtual-address-for-the-kernel)'
- en: '[9.3.3 Placing the Kernel at `0xC0000000`](#placing-the-kernel-at-0xc0000000)'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3.3 将内核放置在`0xC0000000`](#placing-the-kernel-at-0xc0000000)'
- en: '[9.3.4 Higher-half Linker Script](#higher-half-linker-script)'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3.4 高端链接脚本](#higher-half-linker-script)'
- en: '[9.3.5 Entering the Higher Half](#entering-the-higher-half)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3.5 进入高端内存区域](#entering-the-higher-half)'
- en: '[9.3.6 Running in the Higher Half](#running-in-the-higher-half)'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.3.6 在高端内存区域运行](#running-in-the-higher-half)'
- en: '[9.4 Virtual Memory Through Paging](#virtual-memory-through-paging)'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.4 通过分页实现虚拟内存](#virtual-memory-through-paging)'
- en: '[9.5 Further Reading](#further-reading-6)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9.5 进一步阅读](#further-reading-6)'
- en: '[10 Page Frame Allocation](#page-frame-allocation)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10 页面帧分配](#page-frame-allocation)'
- en: '[10.1 Managing Available Memory](#managing-available-memory)'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.1 管理可用内存](#managing-available-memory)'
- en: '[10.1.1 How Much Memory is There?](#how-much-memory-is-there)'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.1.1 有多少内存？](#how-much-memory-is-there)'
- en: '[10.1.2 Managing Available Memory](#managing-available-memory-1)'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.1.2 管理可用内存](#managing-available-memory-1)'
- en: '[10.2 How Can We Access a Page Frame?](#how-can-we-access-a-page-frame)'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.2 如何访问页面帧？](#how-can-we-access-a-page-frame)'
- en: '[10.3 A Kernel Heap](#a-kernel-heap)'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.3 内核堆](#a-kernel-heap)'
- en: '[10.4 Further reading](#further-reading-7)'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10.4 进一步阅读](#further-reading-7)'
- en: '[11 User Mode](#user-mode)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11 用户模式](#user-mode)'
- en: '[11.1 Segments for User Mode](#segments-for-user-mode)'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.1 用户模式分段](#segments-for-user-mode)'
- en: '[11.2 Setting Up For User Mode](#setting-up-for-user-mode)'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.2 为用户模式设置环境](#setting-up-for-user-mode)'
- en: '[11.3 Entering User Mode](#entering-user-mode)'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.3 进入用户模式](#entering-user-mode)'
- en: '[11.4 Using C for User Mode Programs](#using-c-for-user-mode-programs)'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.4 为用户模式程序使用C](#using-c-for-user-mode-programs)'
- en: '[11.4.1 A C Library](#a-c-library)'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.4.1 一个C库](#a-c-library)'
- en: '[11.5 Further Reading](#further-reading-8)'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11.5 进一步阅读](#further-reading-8)'
- en: '[12 File Systems](#file-systems)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12 文件系统](#file-systems)'
- en: '[12.1 Why a File System?](#why-a-file-system)'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.1 为什么需要文件系统？](#why-a-file-system)'
- en: '[12.2 A Simple Read-Only File System](#a-simple-read-only-file-system)'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.2 一个简单的只读文件系统](#a-simple-read-only-file-system)'
- en: '[12.3 Inodes and Writable File Systems](#inodes-and-writable-file-systems)'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.3 索引节点和可写文件系统](#inodes-and-writable-file-systems)'
- en: '[12.4 A Virtual File System](#a-virtual-file-system)'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.4 虚拟文件系统](#a-virtual-file-system)'
- en: '[12.5 Further Reading](#further-reading-9)'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12.5 进一步阅读](#further-reading-9)'
- en: '[13 System Calls](#system-calls)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13 系统调用](#system-calls)'
- en: '[13.1 Designing System Calls](#designing-system-calls)'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.1 设计系统调用](#designing-system-calls)'
- en: '[13.2 Implementing System Calls](#implementing-system-calls)'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.2 实现系统调用](#implementing-system-calls)'
- en: '[13.3 Further Reading](#further-reading-10)'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13.3 进一步阅读](#further-reading-10)'
- en: '[14 Multitasking](#multitasking)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14 多任务处理](#multitasking)'
- en: '[14.1 Creating New Processes](#creating-new-processes)'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.1 创建新进程](#creating-new-processes)'
- en: '[14.2 Cooperative Scheduling with Yielding](#cooperative-scheduling-with-yielding)'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.2 带有让步的协作调度](#cooperative-scheduling-with-yielding)'
- en: '[14.3 Preemptive Scheduling with Interrupts](#preemptive-scheduling-with-interrupts)'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.3 带中断的抢占式调度](#preemptive-scheduling-with-interrupts)'
- en: '[14.3.1 Programmable Interval Timer](#programmable-interval-timer)'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.3.1 可编程间隔定时器](#programmable-interval-timer)'
- en: '[14.3.2 Separate Kernel Stacks for Processes](#separate-kernel-stacks-for-processes)'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.3.2 为进程设置独立的内核堆栈](#separate-kernel-stacks-for-processes)'
- en: '[14.3.3 Difficulties with Preemptive Scheduling](#difficulties-with-preemptive-scheduling)'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.3.3 抢占式调度的困难](#difficulties-with-preemptive-scheduling)'
- en: '[14.4 Further Reading](#further-reading-11)'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14.4 进一步阅读](#further-reading-11)'
- en: 1 Introduction
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 简介
- en: This text is a practical guide to writing your own x86 operating system. It
    is designed to give enough help with the technical details while at the same time
    not reveal too much with samples and code excerpts. We’ve tried to collect parts
    of the vast (and often excellent) expanse of material and tutorials available,
    on the web and otherwise, and add our own insights into the problems we encountered
    and struggled with.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是编写您自己的x86操作系统的实用指南。它旨在在提供足够的技术细节的同时，不通过示例和代码摘录透露过多。我们试图收集网络上和其他地方大量（且通常很优秀）的材料和教程的部分，并加入我们对遇到和挣扎的问题的见解。
- en: This book is not about the theory behind operating systems, or how any specific
    operating system (OS) works. For OS theory we recommend the book *Modern Operating
    Systems* by Andrew Tanenbaum [1]. Lists and details on current operating systems
    are available on the Internet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不是关于操作系统背后的理论，也不是关于任何特定操作系统（OS）如何工作的。对于操作系统理论，我们推荐安德鲁·坦南鲍姆（Andrew Tanenbaum）的《现代操作系统》（Modern
    Operating Systems）[1]。有关当前操作系统的列表和详细信息可在互联网上找到。
- en: The starting chapters are quite detailed and explicit, to quickly get you into
    coding. Later chapters give more of an outline of what is needed, as more and
    more of the implementation and design becomes up to the reader, who should now
    be more familiar with the world of kernel development. At the end of some chapters
    there are links for further reading, which might be interesting and give a deeper
    understanding of the topics covered.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 开头章节相当详细且明确，以便快速进入编码。后面的章节更多地概述了所需内容，因为越来越多的实现和设计取决于读者，此时读者应该对内核开发的世界更加熟悉。在某些章节的末尾，有一些进一步阅读的链接，这些链接可能很有趣，并能对所涵盖的主题有更深入的理解。
- en: In [chapter 2](#first-steps) and [3](#getting-to-c) we set up our development
    environment and boot up our OS kernel in a virtual machine, eventually starting
    to write code in C. We continue in [chapter 4](#output) with writing to the screen
    and the serial port, and then we dive into segmentation in [chapter 5](#segmentation)
    and interrupts and input in [chapter 6](#interrupts-and-input).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](#first-steps)和[第3章](#getting-to-c)中，我们设置了我们的开发环境，并在虚拟机中启动了我们的操作系统内核，最终开始用C语言编写代码。我们在[第4章](#output)中继续编写屏幕和串行端口，然后在[第5章](#segmentation)中深入研究分段，在[第6章](#interrupts-and-input)中探讨中断和输入。
- en: After this we have a quite functional but bare-bones OS kernel. In [chapter
    7](#the-road-to-user-mode) we start the road to user mode applications, with virtual
    memory through paging ([chapter 8](#a-short-introduction-to-virtual-memory) and
    [9](#paging)), memory allocation ([chapter 10](#page-frame-allocation)), and finally
    running a user application in [chapter 11](#user-mode).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们有一个相当功能但基础薄弱的操作系统内核。在[第7章](#the-road-to-user-mode)中，我们开始通往用户模式应用程序的道路，通过分页（[第8章](#a-short-introduction-to-virtual-memory)和[第9章](#paging)）实现虚拟内存，内存分配（[第10章](#page-frame-allocation)），最后在[第11章](#user-mode)中运行用户应用程序。
- en: In the last three chapters we discuss the more advanced topics of file systems
    ([chapter 12](#file-systems)), system calls ([chapter 13](#system-calls)), and
    multitasking ([chapter 14](#multitasking)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后三章中，我们讨论了更高级的主题，包括文件系统（[第12章](#file-systems)）、系统调用（[第13章](#system-calls)）和多任务处理（[第14章](#multitasking)）。
- en: 1.1 About the Book
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 关于本书
- en: The OS kernel and this book were produced as part of an advanced individual
    course at the Royal Institute of Technology [2], Stockholm. The authors had previously
    taken courses in OS theory, but had only minor practical experience with OS kernel
    development. In order to get more insight and a deeper understanding of how the
    theory from the previous OS courses works out in practice, the authors decided
    to create a new course, which focused on the development of a small OS. Another
    goal of the course was writing a thorough tutorial on how to develop a small OS
    basically from scratch, and this short book is the result.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统内核和本书是作为瑞典皇家理工学院 [2] 的高级个人课程的一部分产生的。作者之前曾学习过操作系统理论课程，但在操作系统内核开发方面只有很少的实践经验。为了获得更多见解和更深入地理解之前操作系统课程中的理论如何在实践中发挥作用，作者决定创建一门新课程，该课程专注于小型操作系统的开发。该课程的另一个目标是编写一份详尽的教程，介绍如何从头开始基本开发小型操作系统，而这本简短的书就是结果。
- en: The x86 architecture is, and has been for a long time, one of the most common
    hardware architectures. It was not a difficult choice to use the x86 architecture
    as the target of the OS, with its large community, extensive reference material
    and mature emulators. The documentation and information surrounding the details
    of the hardware we had to work with was not always easy to find or understand,
    despite (or perhaps due to) the age of the architecture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: x86 架构长期以来一直是最常见的硬件架构之一。选择使用 x86 架构作为操作系统的目标并不困难，因为它拥有庞大的社区、广泛的参考资料和成熟的模拟器。尽管（或许正因为）架构的年龄，我们不得不与之合作的硬件细节的文档和信息并不总是容易找到或理解。
- en: The OS was developed in about six weeks of full-time work. The implementation
    was done in many small steps, and after each step the OS was tested manually.
    By developing in this incremental and iterative way, it was often easier to find
    any bugs that were introduced, since only a small part of the code had changed
    since the last known good state of the code. We encourage the reader to work in
    a similar way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统是在大约六周的全职工作中开发的。实现是通过许多小步骤完成的，并且每完成一步后，操作系统都会手动进行测试。通过这种增量迭代的方式开发，通常更容易找到引入的任何错误，因为自上次已知良好的代码状态以来，只有一小部分代码发生了变化。我们鼓励读者以类似的方式工作。
- en: During the six weeks of development, almost every single line of code was written
    by the authors together (this way of working is also called *pair-programming*).
    It is our belief that we managed to avoid a lot of bugs due to this style of development,
    but this is hard to prove scientifically.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在六周的开发期间，几乎每一行代码都是由作者共同编写的（这种工作方式也称为 *结对编程*）。我们相信，由于这种开发方式，我们成功地避免了大量错误，但这很难从科学上证明。
- en: 1.2 The Reader
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 读者
- en: The reader of this book should be comfortable with UNIX/Linux, systems programming,
    the C language and computer systems in general (such as hexadecimal notation [3]).
    This book could be a way to get started learning those things, but it will be
    more difficult, and developing an operating system is already challenging on its
    own. Search engines and other tutorials are often helpful if you get stuck.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本书读者应熟悉 UNIX/Linux、系统编程、C 语言以及计算机系统（例如十六进制表示法 [3]）。这本书可以是开始学习这些内容的一种方式，但会更具挑战性，而开发操作系统本身就是一个挑战。如果你遇到困难，搜索引擎和其他教程通常很有帮助。
- en: 1.3 Credits, Thanks and Acknowledgements
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 学分、感谢和致谢
- en: We’d like to thank the OSDev community [4] for their great wiki and helpful
    members, and James Malloy for his eminent kernel development tutorial [5]. We’d
    also like to thank our supervisor Torbjörn Granlund for his insightful questions
    and interesting discussions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想感谢 OSDev 社区 [4] 他们的优秀维基和有帮助的成员，以及 James Malloy 的杰出内核开发教程 [5]。我们还想感谢我们的导师
    Torbjörn Granlund，他的洞察力问题和有趣的讨论。
- en: Most of the CSS formatting of the book is based on the work by Scott Chacon
    for the book Pro Git, [http://progit.org/](http://progit.org/).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分 CSS 格式化基于 Scott Chacon 为《Pro Git》一书所做的贡献，[http://progit.org/](http://progit.org/)。
- en: 1.4 Contributors
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 贡献者
- en: 'We are very grateful for the patches that people send us. The following users
    have all contributed to this book:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常感谢人们发送给我们的补丁。以下用户都为本书做出了贡献：
- en: '[alexschneider](https://github.com/alexschneider)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[alexschneider](https://github.com/alexschneider)'
- en: '[Avidanborisov](https://github.com/Avidanborisov)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Avidanborisov](https://github.com/Avidanborisov)'
- en: '[nirs](https://github.com/nirs)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[nirs](https://github.com/nirs)'
- en: '[kedarmhaswade](https://github.com/kedarmhaswade)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[kedarmhaswade](https://github.com/kedarmhaswade)'
- en: '[vamanea](https://github.com/vamanea)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[vamanea](https://github.com/vamanea)'
- en: '[ansjob](https://github.com/ansjob)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ansjob](https://github.com/ansjob)'
- en: 1.5 Changes and Corrections
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 变更和修正
- en: This book is hosted on Github - if you have any suggestions, comments or corrections,
    just fork the book, write your changes, and send us a pull request. We’ll happily
    incorporate anything that makes this book better.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本书托管在 Github 上 - 如果您有任何建议、评论或修正，只需将本书 fork，编写您的更改，并向我们发送 pull request。我们将愉快地吸收任何使本书更好的内容。
- en: 1.6 Issues and where to get help
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 问题及获取帮助的地方
- en: 'If you run into problems while reading the book, please check the issues on
    Github for help: [https://github.com/littleosbook/littleosbook/issues](https://github.com/littleosbook/littleosbook/issues).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在阅读本书时遇到问题，请检查 Github 上的问题以获取帮助：[https://github.com/littleosbook/littleosbook/issues](https://github.com/littleosbook/littleosbook/issues)。
- en: 1.7 License
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 许可证
- en: All content is under the Creative Commons Attribution Non Commercial Share Alike
    3.0 license, [http://creativecommons.org/licenses/by-nc-sa/3.0/us/](http://creativecommons.org/licenses/by-nc-sa/3.0/us/).
    The code samples are in the public domain - use them however you want. References
    to this book are always received with warmth.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内容均受 Creative Commons Attribution Non Commercial Share Alike 3.0 许可协议保护，[http://creativecommons.org/licenses/by-nc-sa/3.0/us/](http://creativecommons.org/licenses/by-nc-sa/3.0/us/)。代码示例属于公有领域
    - 您可以随意使用。对本书的引用总是受到热情的欢迎。
- en: 2 First Steps
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 第一步
- en: Developing an operating system (OS) is no easy task, and the question “How do
    I even begin to solve this problem?” is likely to come up several times during
    the course of the project for different problems. This chapter will help you set
    up your development environment and booting a very small (and primitive) operating
    system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 开发操作系统（OS）绝非易事，在项目过程中，针对不同问题，“我该如何开始解决这个问题？”这个问题可能会多次出现。本章将帮助您设置开发环境并引导一个非常小（且原始）的操作系统。
- en: 2.1 Tools
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 工具
- en: 2.1.1 Quick Setup
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 快速设置
- en: We (the authors) have used Ubuntu [6] as the operating system for doing OS development,
    running it both physically and virtually (using the virtual machine VirtualBox
    [7]). A quick way to get everything up and running is to use the same setup as
    we did, since we know that these tools work with the samples provided in this
    book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们（作者）已将 Ubuntu [6] 作为操作系统开发的环境，物理和虚拟（使用虚拟机 VirtualBox [7]）运行。快速启动和运行所有内容的方法是使用我们使用的相同设置，因为我们知道这些工具与本书中提供的示例兼容。
- en: 'Once Ubuntu is installed, either physical or virtual, the following packages
    should be installed using `apt-get`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Ubuntu 后，无论是物理安装还是虚拟安装，都应该使用 `apt-get` 安装以下软件包：
- en: '[PRE0]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 2.1.2 Programming Languages
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 编程语言
- en: The operating system will be developed using the C programming language [8][9],
    using GCC [10]. We use C because developing an OS requires a very precise control
    of the generated code and direct access to memory. Other languages that provide
    the same features can also be used, but this book will only cover C.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统将使用 C 编程语言 [8][9] 开发，使用 GCC [10]。我们使用 C 是因为开发操作系统需要对生成的代码有非常精确的控制和直接访问内存。也可以使用提供相同功能的其他语言，但本书将仅涵盖
    C。
- en: 'The code will make use of one type attribute that is specific for GCC:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将使用 GCC 特定的一种类型属性：
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This attribute allows us to ensure that the compiler uses a memory layout for
    a `struct` exactly as we define it in the code. This is explained in more detail
    in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性允许我们确保编译器使用与我们在代码中定义的 `struct` 完全相同的内存布局。这将在下一章中详细解释。
- en: Due to this attribute, the example code might be hard to compile using a C compiler
    other than GCC.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此属性，示例代码可能难以使用除 GCC 之外的 C 编译器编译。
- en: For writing assembly code, we have chosen NASM [11] as the assembler, since
    we prefer NASM’s syntax over GNU Assembler.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编写汇编代码，我们选择了 NASM [11] 作为汇编器，因为我们更喜欢 NASM 的语法而不是 GNU 汇编器。
- en: Bash [12] will be used as the scripting language throughout the book.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 Bash [12] 作为脚本语言。
- en: 2.1.3 Host Operating System
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 主操作系统
- en: All the code examples assumes that the code is being compiled on a UNIX like
    operating system. All code examples have been successfully compiled using Ubuntu
    [6] versions 11.04 and 11.10.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例都假设代码是在类 UNIX 操作系统上编译的。所有代码示例都已成功使用 Ubuntu [6] 版本 11.04 和 11.10 编译。
- en: 2.1.4 Build System
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 构建系统
- en: Make [13] has been used when constructing the Makefile examples.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Make [13] 已经被用于构建 Makefile 示例。
- en: 2.1.5 Virtual Machine
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 虚拟机
- en: When developing an OS it is very convenient to be able to run your code in a
    *virtual machine* instead of on a physical computer, since starting your OS in
    a virtual machine is much faster than getting your OS onto a physical medium and
    then running it on a physical machine. Bochs [14] is an emulator for the x86 (IA-32)
    platform which is well suited for OS development due to its debugging features.
    Other popular choices are QEMU [15] and VirtualBox [7]. This book uses Bochs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发操作系统时，能够在虚拟机上运行代码而不是在物理计算机上运行，这非常方便，因为将操作系统启动在虚拟机上比将操作系统安装到物理介质上并在物理机器上运行要快得多。Bochs
    [14] 是一个适用于 x86 (IA-32) 平台的模拟器，由于其调试功能，非常适合操作系统开发。其他流行的选择包括 QEMU [15] 和 VirtualBox
    [7]。本书使用 Bochs。
- en: By using a virtual machine we cannot ensure that our OS works on real, physical
    hardware. The environment simulated by the virtual machine is designed to be very
    similar to their physical counterparts, and the OS can be tested on one by just
    copying the executable to a CD and finding a suitable machine.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用虚拟机，我们无法确保我们的操作系统能在真实的物理硬件上运行。虚拟机模拟的环境被设计得与它们的物理对应物非常相似，只需将可执行文件复制到光盘并找到合适的机器，就可以在虚拟机上测试操作系统。
- en: 2.2 Booting
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 启动
- en: 'Booting an operating system consists of transferring control along a chain
    of small programs, each one more “powerful” than the previous one, where the operating
    system is the last “program”. See the following figure for an example of the boot
    process:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 启动操作系统包括沿着一系列小程序链传递控制权，每个程序都比前一个程序“更强大”，其中操作系统是最后一个“程序”。请参见以下图例，了解启动过程：
- en: '![An example of the boot process. Each box is a program.](img/061abc1092e86c93567ab242232a9f74.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![启动过程的示例。每个方框都是一个程序。](img/061abc1092e86c93567ab242232a9f74.png)'
- en: An example of the boot process. Each box is a program.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程的示例。每个方框都是一个程序。
- en: 2.2.1 BIOS
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 BIOS
- en: When the PC is turned on, the computer will start a small program that adheres
    to the *Basic Input Output System* (BIOS) [16] standard. This program is usually
    stored on a read only memory chip on the motherboard of the PC. The original role
    of the BIOS program was to export some library functions for printing to the screen,
    reading keyboard input etc. Modern operating systems do not use the BIOS’ functions,
    they use drivers that interact directly with the hardware, bypassing the BIOS.
    Today, BIOS mainly runs some early diagnostics (power-on-self-test) and then transfers
    control to the bootloader.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PC 开机时，计算机将启动一个小程序，该程序遵循 *基本输入输出系统* (BIOS) [16] 标准。这个程序通常存储在 PC 主板上的只读存储芯片中。BIOS
    程序的原始作用是为打印到屏幕、读取键盘输入等导出一些库函数。现代操作系统不使用 BIOS 的功能，它们使用直接与硬件交互的驱动程序，绕过 BIOS。今天，BIOS
    主要运行一些早期诊断（加电自检）然后将控制权传递给引导加载程序。
- en: 2.2.2 The Bootloader
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 引导加载程序
- en: 'The BIOS program will transfer control of the PC to a program called a *bootloader*.
    The bootloader’s task is to transfer control to us, the operating system developers,
    and our code. However, due to some restrictions[¹](#fn1) of the hardware and because
    of backward compatibility, the bootloader is often split into two parts: the first
    part of the bootloader will transfer control to the second part, which finally
    gives control of the PC to the operating system.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 程序将控制权传递给一个名为 *引导加载程序* 的程序。引导加载程序的任务是将控制权传递给我们，操作系统开发者，以及我们的代码。然而，由于硬件的一些限制[¹](#fn1)
    和向后兼容性的原因，引导加载程序通常分为两部分：引导加载程序的第一部分将控制权传递给第二部分，最终将 PC 的控制权交给操作系统。
- en: 'Writing a bootloader involves writing a lot of low-level code that interacts
    with the BIOS. Therefore, an existing bootloader will be used: the GNU GRand Unified
    Bootloader (GRUB) [17].'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编写引导加载程序涉及编写大量与 BIOS 交互的低级代码。因此，将使用现有的引导加载程序：GNU GRand Unified Bootloader (GRUB)
    [17]。
- en: Using GRUB, the operating system can be built as an ordinary ELF [18] executable,
    which will be loaded by GRUB into the correct memory location. The compilation
    of the kernel requires that the code is laid out in memory in a specific way (how
    to compile the kernel will be discussed later in this chapter).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GRUB，操作系统可以被构建为一个普通的 ELF [18] 可执行文件，该文件将由 GRUB 加载到正确的内存位置。内核的编译要求代码在内存中以特定的方式布局（如何编译内核将在本章后面讨论）。
- en: 2.2.3 The Operating System
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 操作系统
- en: GRUB will transfer control to the operating system by jumping to a position
    in memory. Before the jump, GRUB will look for a magic number to ensure that it
    is actually jumping to an OS and not some random code. This magic number is part
    of the *multiboot specification* [19] which GRUB adheres to. Once GRUB has made
    the jump, the OS has full control of the computer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB将通过跳转到内存中的某个位置来将控制权传递给操作系统。在跳转之前，GRUB将寻找一个魔法数字以确保它实际上是在跳转到操作系统而不是一些随机代码。这个魔法数字是
    *multiboot规范* [19] 的一部分，GRUB遵循这个规范。一旦GRUB完成跳转，操作系统将完全控制计算机。
- en: 2.3 Hello Cafebabe
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 欢迎来到Cafebabe
- en: This section will describe how to implement of the smallest possible OS that
    can be used together with GRUB. The only thing the OS will do is write `0xCAFEBABE`
    to the `eax` register (most people would probably not even call this an OS).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述如何实现可以与GRUB一起使用的最小可能的操作系统。操作系统唯一要做的就是将 `0xCAFEBABE` 写入 `eax` 寄存器（大多数人甚至可能不会称这为操作系统）。
- en: 2.3.1 Compiling the Operating System
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 编译操作系统
- en: 'This part of the OS has to be written in assembly code, since C requires a
    stack, which isn’t available (the chapter [“Getting to C”](#getting-to-c) describes
    how to set one up). Save the following code in a file called `loader.s`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C语言需要栈，而栈不可用（第[“如何进入C”](#getting-to-c)章描述了如何设置栈），这部分操作系统必须用汇编代码编写。将以下代码保存到名为
    `loader.s` 的文件中：
- en: '[PRE2]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only thing this OS will do is write the very specific number `0xCAFEBABE`
    to the `eax` register. It is *very* unlikely that the number `0xCAFEBABE` would
    be in the `eax` register if the OS did *not* put it there.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作系统唯一要做的就是将特定的数字 `0xCAFEBABE` 写入 `eax` 寄存器。如果操作系统没有将这个数字放入 `eax` 寄存器，那么 `0xCAFEBABE`
    出现在 `eax` 寄存器中是非常不可能的。
- en: 'The file `loader.s` can be compiled into a 32 bits ELF [18] object file with
    the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令将文件 `loader.s` 编译成32位ELF [18] 对象文件：
- en: '[PRE3]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 2.3.2 Linking the Kernel
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 链接内核
- en: 'The code must now be linked to produce an executable file, which requires some
    extra thought compared to when linking most programs. We want GRUB to load the
    kernel at a memory address larger than or equal to `0x00100000` (1 megabyte (MB)),
    because addresses lower than 1 MB are used by GRUB itself, BIOS and memory-mapped
    I/O. Therefore, the following linker script is needed (written for GNU LD [20]):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必须将代码链接以生成可执行文件，与链接大多数程序相比，这需要更多的思考。我们希望GRUB在大于或等于 `0x00100000`（1兆字节（MB））的内存地址处加载内核，因为低于1
    MB的地址被GRUB本身、BIOS和内存映射I/O使用。因此，需要以下链接脚本（为GNU LD [20] 编写）：
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save the linker script into a file called `link.ld`. The executable can now
    be linked with the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将链接脚本保存到名为 `link.ld` 的文件中。现在可以使用以下命令将可执行文件链接：
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The final executable will be called `kernel.elf`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的可执行文件将被称为 `kernel.elf`。
- en: 2.3.3 Obtaining GRUB
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 获取GRUB
- en: The GRUB version we will use is GRUB Legacy, since the OS ISO image can then
    be generated on systems using both GRUB Legacy and GRUB 2\. More specifically,
    the GRUB Legacy `stage2_eltorito` bootloader will be used. This file can be built
    from GRUB 0.97 by downloading the source from [ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz](ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz).
    However, the `configure` script doesn’t work well with Ubuntu [21], so the binary
    file can be downloaded from [http://littleosbook.github.com/files/stage2_eltorito](http://littleosbook.github.com/files/stage2_eltorito).
    Copy the file `stage2_eltorito` to the folder that already contains `loader.s`
    and `link.ld`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GRUB Legacy版本，因为这样可以在同时使用GRUB Legacy和GRUB 2的系统上生成OS ISO镜像。更具体地说，将使用GRUB
    Legacy的 `stage2_eltorito` 引导加载程序。此文件可以从GRUB 0.97的源代码中构建，通过从[ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz](ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz)下载源代码。然而，`configure`
    脚本在Ubuntu [21] 上运行不佳，因此可以从[http://littleosbook.github.com/files/stage2_eltorito](http://littleosbook.github.com/files/stage2_eltorito)下载二进制文件。将文件
    `stage2_eltorito` 复制到已包含 `loader.s` 和 `link.ld` 的文件夹中。
- en: 2.3.4 Building an ISO Image
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 构建ISO镜像
- en: The executable must be placed on a media that can be loaded by a virtual or
    physical machine. In this book we will use ISO [22] image files as the media,
    but one can also use floppy images, depending on what the virtual or physical
    machine supports.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件必须放置在可以被虚拟机或物理机加载的媒体上。在这本书中，我们将使用ISO [22] 镜像文件作为媒体，但也可以根据虚拟机或物理机支持的情况使用软盘镜像。
- en: 'We will create the kernel ISO image with the program `genisoimage`. A folder
    must first be created that contains the files that will be on the ISO image. The
    following commands create the folder and copy the files to their correct places:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `genisoimage` 程序创建内核 ISO 图像。首先必须创建一个包含 ISO 图像上文件的文件夹。以下命令创建了文件夹并将文件复制到正确的位置：
- en: '[PRE6]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A configuration file `menu.lst` for GRUB must be created. This file tells GRUB
    where the kernel is located and configures some options:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 必须创建一个用于 GRUB 的配置文件 `menu.lst`。此文件告诉 GRUB 内核的位置并配置一些选项：
- en: '[PRE7]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Place the file `menu.lst` in the folder `iso/boot/grub/`. The contents of the
    `iso` folder should now look like the following figure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件 `menu.lst` 放入文件夹 `iso/boot/grub/` 中。现在 `iso` 文件夹的内容应该如下所示：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The ISO image can then be generated with the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用以下命令生成 ISO 图像：
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information about the flags used in the command, see the manual for
    `genisoimage`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有关命令中使用的标志的更多信息，请参阅 `genisoimage` 的手册。
- en: The ISO image `os.iso` now contains the kernel executable, the GRUB bootloader
    and the configuration file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 图像 `os.iso` 现在包含内核可执行文件、GRUB 引导加载程序和配置文件。
- en: 2.3.5 Running Bochs
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 运行 Bochs
- en: 'Now we can run the OS in the Bochs emulator using the `os.iso` ISO image. Bochs
    needs a configuration file to start and an example of a simple configuration file
    is given below:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `os.iso` ISO 图像在 Bochs 模拟器中运行操作系统。Bochs 需要一个配置文件才能启动，下面提供了一个简单配置文件的示例：
- en: '[PRE10]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You might need to change the path to `romimage` and `vgaromimage` depending
    on how you installed Bochs. More information about the Bochs config file can be
    found at Boch’s website [23].
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要根据您安装 Bochs 的方式更改 `romimage` 和 `vgaromimage` 的路径。有关 Bochs 配置文件的更多信息，可以在
    Boch 的网站上找到 [23]。
- en: 'If you saved the configuration in a file named `bochsrc.txt` then you can run
    Bochs with the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将配置保存到名为 `bochsrc.txt` 的文件中，则可以使用以下命令运行 Bochs：
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The flag `-f` tells Bochs to use the given configuration file and the flag `-q`
    tells Bochs to skip the interactive start menu. You should now see Bochs starting
    and displaying a console with some information from GRUB on it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 标志 `-f` 告诉 Bochs 使用给定的配置文件，而标志 `-q` 告诉 Bochs 跳过交互式启动菜单。现在您应该看到 Bochs 正在启动并显示一个带有
    GRUB 信息的控制台。
- en: 'After quitting Bochs, display the log produced by Boch:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 退出 Bochs 后，显示 Boch 生成的日志：
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should now see the contents of the registers of the CPU simulated by Bochs
    somewhere in the output. If you find `RAX=00000000CAFEBABE` or `EAX=CAFEBABE`
    (depending on if you are running Bochs with or without 64 bit support) in the
    output then your OS has successfully booted!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在输出中看到由 Bochs 模拟的 CPU 寄存器的内容。如果您在输出中找到 `RAX=00000000CAFEBABE` 或 `EAX=CAFEBABE`（取决于您是否以
    64 位支持运行 Bochs），那么您的操作系统已成功引导！
- en: 2.4 Further Reading
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 进一步阅读
- en: Gustavo Duertes has written an in-depth article about what actually happens
    when a x86 computer boots up, [http://duartes.org/gustavo/blog/post/how-computers-boot-up](http://duartes.org/gustavo/blog/post/how-computers-boot-up)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gustavo Duertes 撰写了一篇深入的文章，关于 x86 计算机启动时实际发生的事情，[http://duartes.org/gustavo/blog/post/how-computers-boot-up](http://duartes.org/gustavo/blog/post/how-computers-boot-up)
- en: Gustavo continues to describe what the kernel does in the very early stages
    at [http://duartes.org/gustavo/blog/post/kernel-boot-process](http://duartes.org/gustavo/blog/post/kernel-boot-process)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gustavo 继续描述内核在[http://duartes.org/gustavo/blog/post/kernel-boot-process](http://duartes.org/gustavo/blog/post/kernel-boot-process)的非常早期的阶段所做的工作
- en: 'The OSDev wiki also contains a nice article about booting an x86 computer:
    [http://wiki.osdev.org/Boot_Sequence](http://wiki.osdev.org/Boot_Sequence)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSDev 维基还包含了一篇关于如何引导 x86 计算机的优秀文章：[http://wiki.osdev.org/Boot_Sequence](http://wiki.osdev.org/Boot_Sequence)
- en: 3 Getting to C
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 进入 C 语言
- en: This chapter will show you how to use C instead of assembly code as the programming
    language for the OS. Assembly is very good for interacting with the CPU and enables
    maximum control over every aspect of the code. However, at least for the authors,
    C is a much more convenient language to use. Therefore, we would like to use C
    as much as possible and use assembly code only where it make sense.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何使用 C 语言而不是汇编代码作为操作系统的编程语言。汇编语言非常适合与 CPU 交互，并允许对代码的各个方面进行最大程度的控制。然而，至少对于作者来说，C
    语言是一个更方便使用的语言。因此，我们希望尽可能多地使用 C 语言，并且只在有意义的场合使用汇编代码。
- en: 3.1 Setting Up a Stack
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 设置堆栈
- en: One prerequisite for using C is a stack, since all non-trivial C programs use
    a stack. Setting up a stack is not harder than to make the `esp` register point
    to the end of an area of free memory (remember that the stack grows towards lower
    addresses on the x86) that is correctly aligned (alignment on 4 bytes is recommended
    from a performance perspective).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C的一个先决条件是有一个栈，因为所有非平凡的C程序都使用栈。设置栈并不比将`esp`寄存器指向一块正确对齐的空闲内存区域的末尾更难（记住，在x86上栈是向低地址增长的）。从性能角度考虑，建议对齐在4字节上。
- en: We could point `esp` to a random area in memory since, so far, the only thing
    in the memory is GRUB, BIOS, the OS kernel and some memory-mapped I/O. This is
    not a good idea - we don’t know how much memory is available or if the area `esp`
    would point to is used by something else. A better idea is to reserve a piece
    of uninitialized memory in the `bss` section in the ELF file of the kernel. It
    is better to use the `bss` section instead of the `data` section to reduce the
    size of the OS executable. Since GRUB understands ELF, GRUB will allocate any
    memory reserved in the `bss` section when loading the OS.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`esp`指向内存中的任意区域，因为到目前为止，内存中只有GRUB、BIOS、操作系统内核和一些内存映射I/O。这不是一个好主意——我们不知道有多少内存可用，或者`esp`指向的区域是否被其他东西使用。更好的办法是在内核的ELF文件中的`.bss`部分预留一块未初始化的内存。使用`.bss`部分而不是`.data`部分来减少操作系统可执行文件的大小更好。因为GRUB理解ELF，所以GRUB在加载操作系统时将分配在`.bss`部分预留的任何内存。
- en: 'The NASM pseudo-instruction `resb` [24] can be used to declare uninitialized
    data:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: NASM伪指令`resb`[24]可以用来声明未初始化的数据：
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is no need to worry about the use of uninitialized memory for the stack,
    since it is not possible to read a stack location that has not been written (without
    manual pointer fiddling). A (correct) program can not pop an element from the
    stack without having pushed an element onto the stack first. Therefore, the memory
    locations of the stack will always be written to before they are being read.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于栈的使用，无需担心未初始化内存，因为不可能读取尚未写入的栈位置（除非手动操作指针）。一个（正确）的程序不能在没有先向栈中推入元素的情况下从栈中弹出元素。因此，栈的内存位置在读取之前总是会被写入。
- en: 'The stack pointer is then set up by pointing `esp` to the end of the `kernel_stack`
    memory:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将栈指针设置为将`esp`指向`kernel_stack`内存的末尾：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 3.2 Calling C Code From Assembly
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 从汇编语言调用C代码
- en: 'The next step is to call a C function from assembly code. There are many different
    conventions for how to call C code from assembly code [25]. This book uses the
    *cdecl* calling convention, since that is the one used by GCC. The cdecl calling
    convention states that arguments to a function should be passed via the stack
    (on x86). The arguments of the function should be pushed on the stack in a right-to-left
    order, that is, you push the rightmost argument first. The return value of the
    function is placed in the `eax` register. The following code shows an example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从汇编代码中调用C函数。关于如何从汇编代码中调用C代码有许多不同的约定[25]。本书使用*cdecl*调用约定，因为这是GCC使用的约定。cdecl调用约定指出，函数的参数应通过栈（在x86上）传递。函数的参数应按从右到左的顺序推入栈中，即首先推入最右边的参数。函数的返回值放在`eax`寄存器中。以下代码展示了示例：
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 3.2.1 Packing Structs
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 打包结构体
- en: 'In the rest of this book, you will often come across “configuration bytes”
    that are a collection of bits in a very specific order. Below follows an example
    with 32 bits:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，你经常会遇到“配置字节”，它们是一系列按特定顺序排列的位。以下是一个32位的示例：
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instead of using an unsigned integer, `unsigned int`, for handling such configurations,
    it is much more convenient to use “packed structures”:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用无符号整数`unsigned int`来处理此类配置，使用“打包结构”会更方便：
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When using the `struct` in the previous example there is no guarantee that
    the size of the `struct` will be exactly 32 bits - the compiler can add some padding
    between elements for various reasons, for example to speed up element access or
    due to requirements set by the hardware and/or compiler. When using a `struct`
    to represent configuration bytes, it is very important that the compiler does
    *not* add any padding, because the `struct` will eventually be treated as a 32
    bit unsigned integer by the hardware. The attribute `packed` can be used to force
    GCC to *not* add any padding:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当在前面示例中使用 `struct` 时，无法保证 `struct` 的大小正好是 32 位 - 编译器可能会出于各种原因在元素之间添加一些填充，例如为了加快元素访问速度或由于硬件和/或编译器的要求。当使用
    `struct` 来表示配置字节时，非常重要的一点是编译器**不**添加任何填充，因为硬件最终会将 `struct` 作为 32 位无符号整数处理。可以使用
    `packed` 属性来强制 GCC **不**添加任何填充：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `__attribute__((packed))` is not part of the C standard - it might
    not work with all C compilers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__attribute__((packed))` 不是 C 标准的一部分 - 它可能不适用于所有 C 编译器。
- en: 3.3 Compiling C Code
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 编译 C 代码
- en: When compiling the C code for the OS, a lot of flags to GCC need to be used.
    This is because the C code should *not* assume the presence of a standard library,
    since there is no standard library available for our OS. For more information
    about the flags, see the GCC manual.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译操作系统的 C 代码时，需要使用很多 GCC 标志。这是因为 C 代码**不应**假设标准库的存在，因为我们的操作系统没有可用的标准库。有关标志的更多信息，请参阅
    GCC 手册。
- en: 'The flags used for compiling the C code are:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 C 代码时使用的标志是：
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As always when writing C programs we recommend turning on all warnings and
    treat warnings as errors:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如编写 C 程序时始终推荐的那样，我们建议打开所有警告并将警告视为错误：
- en: '[PRE21]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can now create a function `kmain` in a file called `kmain.c` that you call
    from `loader.s`. At this point, `kmain` probably won’t need any arguments (but
    in later chapters it will).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在名为 `kmain.c` 的文件中创建一个名为 `kmain` 的函数，然后从 `loader.s` 中调用它。在这个阶段，`kmain`
    可能不需要任何参数（但在后面的章节中将会需要）。
- en: 3.4 Build Tools
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 构建工具
- en: 'Now is also probably a good time to set up some build tools to make it easier
    to compile and test-run the OS. We recommend using `make` [13], but there are
    plenty of other build systems available. A simple Makefile for the OS could look
    like the following example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能也是设置一些构建工具的好时机，以便更容易编译和测试运行操作系统。我们建议使用 `make` [13]，但还有许多其他构建系统可供选择。操作系统的一个简单
    Makefile 示例可能如下所示：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The contents of your working directory should now look like the following figure:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作目录内容现在应该看起来像以下图示：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should now be able to start the OS with the simple command `make run`, which
    will compile the kernel and boot it up in Bochs (as defined in the Makefile above).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用简单的命令 `make run` 启动操作系统，该命令将编译内核并在 Bochs 中启动它（如上方的 Makefile 中定义）。
- en: 3.5 Further Reading
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 进一步阅读
- en: Kernigan & Richie’s book, *The C Programming Language, Second Edition*, [8]
    is great for learning about all the aspects of C.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kernighan 和 Ritchie 的书，*《C 程序设计语言（第二版）》，[8]*，非常适合学习 C 的各个方面。
- en: 4 Output
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 输出
- en: This chapter will present how to display text on the console as well as writing
    data to the serial port. Furthermore, we will create our first *driver*, that
    is, code that acts as a layer between the kernel and the hardware, providing a
    higher abstraction than communicating directly with the hardware. The first part
    of this chapter is about creating a driver for the *framebuffer* [26] to be able
    to display text on the console. The second part shows how to create a driver for
    the serial port. Bochs can store output from the serial port in a file, effectively
    creating a logging mechanism for the operating system.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何在控制台上显示文本以及将数据写入串行端口。此外，我们还将创建我们的第一个 *驱动程序*，即作为内核和硬件之间层的代码，提供比直接与硬件通信更高的抽象。本章的第一部分是关于创建一个用于
    *framebuffer* [26] 的驱动程序，以便能够在控制台上显示文本。第二部分展示了如何创建串行端口的驱动程序。Bochs 可以将串行端口的输出存储在文件中，从而为操作系统创建一个日志机制。
- en: 4.1 Interacting with the Hardware
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 与硬件交互
- en: There are usually two different ways to interact with the hardware, *memory-mapped
    I/O* and *I/O ports*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬件交互通常有两种不同的方式，*内存映射 I/O* 和 *I/O 端口*。
- en: If the hardware uses memory-mapped I/O then you can write to a specific memory
    address and the hardware will be updated with the new data. One example of this
    is the framebuffer, which will be discussed in more detail later. For example,
    if you write the value `0x410F` to address `0x000B8000`, you will see the letter
    A in white color on a black background (see the section on [the framebuffer](#the-framebuffer)
    for more details).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果硬件使用内存映射I/O，则可以写入特定的内存地址，硬件将使用新数据更新。一个例子是帧缓冲区，稍后将更详细地讨论。例如，如果将值`0x410F`写入地址`0x000B8000`，你将看到白色背景上的字母A（有关更多详细信息，请参阅[帧缓冲区](#the-framebuffer)部分）。
- en: 'If the hardware uses I/O ports then the assembly code instructions `out` and
    `in` must be used to communicate with the hardware. The instruction `out` takes
    two parameters: the address of the I/O port and the data to send. The instruction
    `in` takes a single parameter, the address of the I/O port, and returns data from
    the hardware. One can think of I/O ports as communicating with hardware the same
    way as you communicate with a server using sockets. The cursor (the blinking rectangle)
    of the framebuffer is one example of hardware controlled via I/O ports on a PC.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果硬件使用I/O端口，则必须使用汇编代码指令`out`和`in`与硬件通信。指令`out`有两个参数：I/O端口的地址和要发送的数据。指令`in`有一个参数，即I/O端口的地址，并从硬件返回数据。可以将I/O端口视为与硬件通信的方式，就像使用套接字与服务器通信一样。帧缓冲区（闪烁的矩形）的光标是PC上通过I/O端口控制的硬件的一个例子。
- en: 4.2 The Framebuffer
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 帧缓冲区
- en: The framebuffer is a hardware device that is capable of displaying a buffer
    of memory on the screen [26]. The framebuffer has 80 columns and 25 rows, and
    the row and column indices start at 0 (so rows are labelled 0 - 24).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区是一个能够将内存缓冲区显示在屏幕上的硬件设备 [26]。帧缓冲区有80列和25行，行和列的索引从0开始（因此行被标记为0 - 24）。
- en: 4.2.1 Writing Text
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 写入文本
- en: 'Writing text to the console via the framebuffer is done with memory-mapped
    I/O. The starting address of the memory-mapped I/O for the framebuffer is `0x000B8000`
    [27]. The memory is divided into 16 bit cells, where the 16 bits determine both
    the character, the foreground color and the background color. The highest eight
    bits is the ASCII [28] value of the character, bit 7 - 4 the background and bit
    3 - 0 the foreground, as can be seen in the following figure:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过帧缓冲区将文本写入控制台是通过内存映射I/O完成的。帧缓冲区内存映射I/O的起始地址是`0x000B8000` [27]。内存被划分为16位单元，其中16位决定了字符、前景色和背景色。最高的8位是字符的ASCII
    [28]值，位7 - 4是背景色，位3 - 0是前景色，如下面的图所示：
- en: '[PRE24]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The available colors are shown in the following table:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的颜色显示在下表中：
- en: '| Color | Value | Color | Value | Color | Value | Color | Value |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 颜色 | 值 | 颜色 | 值 | 颜色 | 值 | 颜色 | 值 |'
- en: '| --: | :-- | --: | :-- | --: | :-- | --: | :-- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --: | :-- | --: | :-- | --: | :-- | --: | :-- |'
- en: '| Black | 0 | Red | 4 | Dark grey | 8 | Light red | 12 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 黑色 | 0 | 红色 | 4 | 暗灰色 | 8 | 淡红色 | 12 |'
- en: '| Blue | 1 | Magenta | 5 | Light blue | 9 | Light magenta | 13 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 蓝色 | 1 | 品红色 | 5 | 淡蓝色 | 9 | 淡品红色 | 13 |'
- en: '| Green | 2 | Brown | 6 | Light green | 10 | Light brown | 14 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 绿色 | 2 | 棕色 | 6 | 淡绿色 | 10 | 淡棕色 | 14 |'
- en: '| Cyan | 3 | Light grey | 7 | Light cyan | 11 | White | 15 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 青色 | 3 | 淡灰色 | 7 | 淡青色 | 11 | 白色 | 15 |'
- en: 'The first cell corresponds to row zero, column zero on the console. Using an
    ASCII table, one can see that A corresponds to 65 or `0x41`. Therefore, to write
    the character A with a green foreground (2) and dark grey background (8) at place
    (0,0), the following assembly code instruction is used:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元对应于控制台上的第0行，第0列。使用ASCII表，可以看到A对应于65或`0x41`。因此，要在位置（0,0）使用绿色前景色（2）和深灰色背景色（8）写入字符A，可以使用以下汇编代码指令：
- en: '[PRE25]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second cell then corresponds to row zero, column one and its address is
    therefore:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个单元对应于第0行，第1列，因此其地址是：
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Writing to the framebuffer can also be done in C by treating the address `0x000B8000`
    as a char pointer, `char *fb = (char *) 0x000B8000`. Then, writing A at place
    (0,0) with green foreground and dark grey background becomes:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将地址`0x000B8000`视为字符指针，`char *fb = (char *) 0x000B8000`，也可以在C语言中写入帧缓冲区。然后，使用绿色前景色（2）和深灰色背景色（8）在位置（0,0）写入字符A，如下所示：
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code shows how this can be wrapped into a function:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何将其封装成函数：
- en: '[PRE28]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The function can then be used as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用该函数如下：
- en: '[PRE29]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 4.2.2 Moving the Cursor
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 移动光标
- en: 'Moving the cursor of the framebuffer is done via two different I/O ports. The
    cursor’s position is determined with a 16 bits integer: 0 means row zero, column
    zero; 1 means row zero, column one; 80 means row one, column zero and so on. Since
    the position is 16 bits large, and the `out` assembly code instruction argument
    is 8 bits, the position must be sent in two turns, first 8 bits then the next
    8 bits. The framebuffer has two I/O ports, one for accepting the data, and one
    for describing the data being received. Port `0x3D4` [29] is the port that describes
    the data and port `0x3D5` [29] is for the data itself.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个不同的I/O端口移动帧缓冲区的光标。光标的位置由一个16位整数确定：0表示第一行，第一列；1表示第一行，第二列；80表示第二行，第一列，依此类推。由于位置是16位大小，而`out`汇编代码指令的参数是8位，因此位置必须分两次发送，首先发送8位，然后发送下一个8位。帧缓冲区有两个I/O端口，一个用于接收数据，一个用于描述接收到的数据。端口`0x3D4`[29]是描述数据的端口，端口`0x3D5`[29]是用于数据本身的端口。
- en: 'To set the cursor at row one, column zero (position `80 = 0x0050`), one would
    use the following assembly code instructions:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要将光标设置在第一行，第一列（位置`80 = 0x0050`），可以使用以下汇编代码指令：
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `out` assembly code instruction can’t be executed directly in C. Therefore
    it is a good idea to wrap `out` in a function in assembly code which can be accessed
    from C via the cdecl calling standard [25]:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`汇编代码指令不能直接在C语言中执行。因此，将`out`封装在汇编代码中的函数是一个好主意，该函数可以通过cdecl调用约定从C语言访问[25]：'
- en: '[PRE31]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By storing this function in a file called `io.s` and also creating a header
    `io.h`, the `out` assembly code instruction can be conveniently accessed from
    C:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此函数存储在名为`io.s`的文件中，并创建一个头文件`io.h`，可以方便地从C语言中访问`out`汇编代码指令：
- en: '[PRE32]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Moving the cursor can now be wrapped in a C function:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将移动光标的功能封装在一个C函数中：
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 4.2.3 The Driver
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 驱动程序
- en: 'The driver should provide an interface that the rest of the code in the OS
    will use for interacting with the framebuffer. There is no right or wrong in what
    functionality the interface should provide, but a suggestion is to have a `write`
    function with the following declaration:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序应提供一个接口，供操作系统中的其余代码用于与帧缓冲区交互。接口应提供什么功能没有对错之分，但建议有一个具有以下声明的`write`函数：
- en: '[PRE34]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `write` function writes the contents of the buffer `buf` of length `len`
    to the screen. The `write` function should automatically advance the cursor after
    a character has been written and scroll the screen if necessary.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`函数将长度为`len`的缓冲区`buf`的内容写入屏幕。`write`函数应在写入字符后自动移动光标，并在必要时滚动屏幕。'
- en: 4.3 The Serial Ports
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 串行端口
- en: The serial port [30] is an interface for communicating between hardware devices
    and although it is available on almost all motherboards, it is seldom exposed
    to the user in the form of a DE-9 connector nowadays. The serial port is easy
    to use, and, more importantly, it can be used as a logging utility in Bochs. If
    a computer has support for a serial port, then it usually has support for multiple
    serial ports, but we will only make use of one of the ports. This is because we
    will only use the serial ports for logging. Furthermore, we will only use the
    serial ports for output, not input. The serial ports are completely controlled
    via I/O ports.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 串行端口[30]是硬件设备之间通信的接口，尽管它几乎存在于所有主板上，但现在很少以DE-9连接器的形式向用户暴露。串行端口易于使用，更重要的是，它可以用作Bochs中的日志工具。如果计算机支持串行端口，那么它通常也支持多个串行端口，但我们将只使用一个端口。这是因为我们只将串行端口用于日志记录。此外，我们只将串行端口用于输出，而不是输入。串行端口完全通过I/O端口进行控制。
- en: 4.3.1 Configuring the Serial Port
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 配置串行端口
- en: 'The first data that need to be sent to the serial port is configuration data.
    In order for two hardware devices to be able to talk to each other they must agree
    upon a couple of things. These things include:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 需要发送到串行端口的第一份数据是配置数据。为了使两个硬件设备能够相互通信，它们必须就一些事项达成一致。这些事项包括：
- en: The speed used for sending data (bit or baud rate)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据时使用的速度（位或波特率）
- en: If any error checking should be used for the data (parity bit, stop bits)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应对数据进行错误检查（奇偶校验位，停止位）
- en: The number of bits that represent a unit of data (data bits)
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示数据单元的位数（数据位）
- en: 4.3.2 Configuring the Line
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 配置线路
- en: Configuring the line means to configure how data is being sent over the line.
    The serial port has an I/O port, the *line command port*, that is used for configuration.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 配置线路意味着配置数据通过线路发送的方式。串行端口有一个I/O端口，即*线路命令端口*，用于配置。
- en: First the speed for sending data will be set. The serial port has an internal
    clock that runs at 115200 Hz. Setting the speed means sending a divisor to the
    serial port, for example sending 2 results in a speed of `115200 / 2 = 57600`
    Hz.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将设置发送数据的速度。串行端口有一个内部时钟，以115200 Hz的速度运行。设置速度意味着向串行端口发送一个除数，例如发送2的结果是速度为 `115200
    / 2 = 57600` Hz。
- en: 'The divisor is a 16 bit number but we can only send 8 bits at a time. We must
    therefore send an instruction telling the serial port to first expect the highest
    8 bits, then the lowest 8 bits. This is done by sending `0x80` to the line command
    port. An example is shown below:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 除数是一个16位数字，但我们一次只能发送8位。因此，我们必须发送一个指令告诉串行端口首先期望最高8位，然后是最低8位。这是通过向线路命令端口发送 `0x80`
    来完成的。以下是一个示例：
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The way that data should be sent must be configured. This is also done via
    the line command port by sending a byte. The layout of the 8 bits looks like the
    following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 数据应如何发送必须进行配置。这也是通过发送一个字节到线路命令端口来完成的。8位的布局如下所示：
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A description for each name can be found in the table below (and in [31]):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称的描述可以在下表找到（并在[31]中）：
- en: '| Name | Description |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --: | :-- |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| --: | :-- |'
- en: '| d | Enables (`d = 1`) or disables (`d = 0`) DLAB |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| d | 启用（d = 1）或禁用（d = 0）DLAB |'
- en: '| b | If break control is enabled (`b = 1`) or disabled (`b = 0`) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| b | 如果启用断开控制（b = 1）或禁用（b = 0） |'
- en: '| prty | The number of parity bits to use |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| prty | 要使用的奇偶校验位数 |'
- en: '| s | The number of stop bits to use (`s = 0` equals 1, `s = 1` equals 1.5
    or 2) |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| s | 要使用的停止位数（s = 0 等于 1，s = 1 等于 1.5 或 2） |'
- en: '| dl | Describes the length of the data |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| dl | 描述数据长度 |'
- en: 'We will use the mostly standard value `0x03` [31], meaning a length of 8 bits,
    no parity bit, one stop bit and break control disabled. This is sent to the line
    command port, as seen in the following example:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用大多数标准的值 `0x03` [31]，这意味着8位长度，无奇偶校验位，一个停止位，禁用断开控制。这被发送到线路命令端口，如下面的示例所示：
- en: '[PRE37]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The article on OSDev [31] has a more in-depth explanation of the values.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: OSDev [31] 上的文章对值有更深入的说明。
- en: 4.3.3 Configuring the Buffers
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 配置缓冲区
- en: 'When data is transmitted via the serial port it is placed in buffers, both
    when receiving and sending data. This way, if you send data to the serial port
    faster than it can send it over the wire, it will be buffered. However, if you
    send too much data too fast the buffer will be full and data will be lost. In
    other words, the buffers are FIFO queues. The FIFO queue configuration byte looks
    like the following figure:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过串行端口传输数据时，它会被放置在缓冲区中，无论是接收还是发送数据。这样，如果您以比串行端口通过电线发送数据更快的速度发送数据，它将被缓冲。然而，如果您发送太多数据，并且发送得太快，缓冲区将满，数据将丢失。换句话说，缓冲区是FIFO队列。FIFO队列配置字节看起来如下所示：
- en: '[PRE38]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A description for each name can be found in the table below:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称的描述可以在下表找到：
- en: '| Name | Description |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --: | :-- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --: | :-- |'
- en: '| lvl | How many bytes should be stored in the FIFO buffers |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| lvl | 应存储在FIFO缓冲区中的字节数 |'
- en: '| bs | If the buffers should be 16 or 64 bytes large |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| bs | 如果缓冲区应为16或64字节大小 |'
- en: '| r | Reserved for future use |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| r | 保留供将来使用 |'
- en: '| dma | How the serial port data should be accessed |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| dma | 串行端口数据应如何访问 |'
- en: '| clt | Clear the transmission FIFO buffer |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| clt | 清除传输FIFO缓冲区 |'
- en: '| clr | Clear the receiver FIFO buffer |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| clr | 清除接收器FIFO缓冲区 |'
- en: '| e | If the FIFO buffer should be enabled or not |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| e | 如果FIFO缓冲区应启用或禁用 |'
- en: 'We use the value `0xC7 = 11000111` that:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用值 `0xC7 = 11000111`，该值：
- en: Enables FIFO
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用FIFO
- en: Clear both receiver and transmission FIFO queues
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除接收器和传输FIFO队列
- en: Use 14 bytes as size of queue
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用14字节作为队列大小
- en: The WikiBook on serial programming [32] explains the values in more depth.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: WikiBook上的串行编程[32]对值有更深入的说明。
- en: 4.3.4 Configuring the Modem
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 配置调制解调器
- en: The modem control register is used for very simple hardware flow control via
    the Ready To Transmit (RTS) and Data Terminal Ready (DTR) pins. When configuring
    the serial port we want RTS and DTR to be 1, which means that we are ready to
    send data.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 调制解调器控制寄存器用于通过就绪发送（RTS）和数据终端就绪（DTR）引脚进行非常简单的硬件流控制。当配置串行端口时，我们希望RTS和DTR为1，这意味着我们已准备好发送数据。
- en: 'The modem configuration byte is shown in the following figure:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 调制解调器配置字节如下所示：
- en: '[PRE39]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A description for each name can be found in the table below:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称的描述可以在下表找到：
- en: '| Name | Description |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --: | :-- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --: | :-- |'
- en: '| r | Reserved |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| r | 保留 |'
- en: '| af | Autoflow control enabled |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| af | 启用自动流控制 |'
- en: '| lb | Loopback mode (used for debugging serial ports) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| lb | 环回模式（用于调试串行端口） |'
- en: '| ao2 | Auxiliary output 2, used for receiving interrupts |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| ao2 | 辅助输出2，用于接收中断 |'
- en: '| ao1 | Auxiliary output 1 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| ao1 | 辅助输出1 |'
- en: '| rts | Ready To Transmit |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| rts | 准备传输 |'
- en: '| dtr | Data Terminal Ready |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| dtr | 数据终端就绪 |'
- en: We don’t need to enable interrupts, because we won’t handle any received data.
    Therefore we use the configuration value `0x03 = 00000011` (RTS = 1 and DTS =
    1).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要启用中断，因为我们不会处理任何接收到的数据。因此，我们使用配置值`0x03 = 00000011`（RTS = 1和DTS = 1）。
- en: 4.3.5 Writing Data to the Serial Port
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 向串行端口写入数据
- en: Writing data to the serial port is done via the data I/O port. However, before
    writing, the transmit FIFO queue has to be empty (all previous writes must have
    finished). The transmit FIFO queue is empty if bit 5 of the line status I/O port
    is equal to one.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 向串行端口写入数据是通过数据I/O端口完成的。然而，在写入之前，必须确保发送FIFO队列为空（所有之前的写入都必须完成）。如果线路状态I/O端口的第5位等于1，则发送FIFO队列为空。
- en: 'Reading the contents of an I/O port is done via the `in` assembly code instruction.
    There is no way to use the `in` assembly code instruction from C, therefore it
    has to be wrapped (the same way as the `out` assembly code instruction):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`in`汇编代码指令读取I/O端口的 内容。无法从C中使用`in`汇编代码指令，因此必须将其包装（与`out`汇编代码指令相同的方式）：
- en: '[PRE40]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Checking if the transmit FIFO is empty can then be done from C:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从C中检查发送FIFO是否为空：
- en: '[PRE42]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Writing to a serial port means spinning as long as the transmit FIFO queue isn’t
    empty, and then writing the data to the data I/O port.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 向串行端口写入意味着只要发送FIFO队列不为空，就需要持续旋转，然后将数据写入数据I/O端口。
- en: 4.3.6 Configuring Bochs
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6 配置Bochs
- en: 'To save the output from the first serial serial port the Bochs configuration
    file `bochsrc.txt` must be updated. The `com1` configuration instructs Bochs how
    to handle first serial port:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存第一个串行端口的输出，必须更新Bochs配置文件`bochsrc.txt`。`com1`配置指示Bochs如何处理第一个串行端口：
- en: '[PRE43]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output from serial port one will now be stored in the file `com1.out`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在串行端口一的输出将存储在文件`com1.out`中。
- en: 4.3.7 The Driver
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.7 驱动程序
- en: We recommend that you implement a `write` function for the serial port similar
    to the `write` function in the driver for the framebuffer. To avoid name clashes
    with the `write` function for the framebuffer it is a good idea to name the functions
    `fb_write` and `serial_write` to distinguish them.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您为串行端口实现一个类似于驱动程序中`write`函数的`write`函数。为了避免与帧缓冲区的`write`函数名称冲突，将函数命名为`fb_write`和`serial_write`是一个好主意，以区分它们。
- en: We further recommend that you try to write a `printf`-like function, see section
    7.3 in [8]. The `printf` function could take an additional argument to decide
    to which device to write the output (framebuffer or serial).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议您尝试编写一个类似于`printf`的函数，参见[8]中的第7.3节。`printf`函数可以接受一个额外的参数来决定输出到哪个设备（帧缓冲区或串行）。
- en: A final recommendation is that you create some way of distinguishing the severeness
    of the log messages, for example by prepending the messages with `DEBUG`, `INFO`
    or `ERROR`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的建议是，您创建一种方法来区分日志消息的严重性，例如通过在消息前添加`DEBUG`、`INFO`或`ERROR`。
- en: 4.4 Further Reading
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 进一步阅读
- en: The book “Serial programming” (available on WikiBooks) has a great section on
    programming the serial port, [http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers](http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers)
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍《串行编程》（可在WikiBooks上找到）有一个关于串行端口编程的精彩部分，[http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers](http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers)
- en: The OSDev wiki has a page with a lot of information about the serial ports,
    [http://wiki.osdev.org/Serial_ports](http://wiki.osdev.org/Serial_ports)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSDev wiki有一个包含大量关于串行端口信息的页面，[http://wiki.osdev.org/Serial_ports](http://wiki.osdev.org/Serial_ports)
- en: 5 Segmentation
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 分段
- en: '*Segmentation* in x86 means accessing the memory through segments. Segments
    are portions of the address space, possibly overlapping, specified by a base address
    and a limit. To address a byte in segmented memory you use a 48-bit *logical address*:
    16 bits that specifies the segment and 32-bits that specifies what offset within
    that segment you want. The offset is added to the base address of the segment,
    and the resulting linear address is checked against the segment’s limit - see
    the figure below. If everything works out fine (including access-rights checks
    ignored for now) the result is a *linear address*. When paging is disabled, then
    the linear address space is mapped 1:1 onto the *physical address* space, and
    the physical memory can be accessed. (See the chapter [“Paging”](#paging) for
    how to enable paging.)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86中，**分段**意味着通过段来访问内存。段是地址空间的一部分，可能是重叠的，由一个基址和一个限制来指定。要定位分段内存中的一个字节，你使用一个48位的**逻辑地址**：16位指定段，32位指定你想要在该段内的偏移量。这个偏移量加到段的基址上，得到的结果线性地址与段的限制进行比较
    - 见下面的图。如果一切正常（包括现在忽略的访问权限检查）的结果是一个**线性地址**。当禁用分页时，线性地址空间1:1映射到**物理地址**空间，可以访问物理内存。（参见[“分页”](#paging)章节了解如何启用分页。）
- en: '![Translation of logical addresses to linear addresses.](img/316873ad8130260306c4e96481a1c497.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑地址到线性地址的转换。](img/316873ad8130260306c4e96481a1c497.png)'
- en: Translation of logical addresses to linear addresses.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑地址到线性地址的转换。
- en: 'To enable segmentation you need to set up a table that describes each segment
    - a *segment descriptor table*. In x86, there are two types of descriptor tables:
    the *Global Descriptor Table* (GDT) and *Local Descriptor Tables* (LDT). An LDT
    is set up and managed by user-space processes, and all processes have their own
    LDT. LDTs can be used if a more complex segmentation model is desired - we won’t
    use it. The GDT is shared by everyone - it’s global.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用分段，你需要设置一个描述每个段的表 - 一个**段描述符表**。在x86架构中，有两种类型的描述符表：**全局描述符表**（GDT）和**局部描述符表**（LDT）。LDT由用户空间进程设置和管理，每个进程都有自己的LDT。如果需要更复杂的分段模型，可以使用LDT
    - 我们不会使用它。GDT是大家共用的 - 它是全局的。
- en: As we discuss in the sections on virtual memory and paging, segmentation is
    rarely used more than in a minimal setup, similar to what we do below.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在虚拟内存和分页章节中讨论的那样，分段在大多数情况下很少被使用，类似于我们下面所做的那样。
- en: 5.1 Accessing Memory
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 访问内存
- en: 'Most of the time when accessing memory there is no need to explicitly specify
    the segment to use. The processor has six 16-bit segment registers: `cs`, `ss`,
    `ds`, `es`, `gs` and `fs`. The register `cs` is the code segment register and
    specifies the segment to use when fetching instructions. The register `ss` is
    used whenever accessing the stack (through the stack pointer `esp`), and `ds`
    is used for other data accesses. The OS is free to use the registers `es`, `gs`
    and `fs` however it want.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问内存的大多数时候，没有必要显式指定要使用的段。处理器有六个16位的段寄存器：`cs`、`ss`、`ds`、`es`、`gs`和`fs`。寄存器`cs`是代码段寄存器，用于获取指令时指定要使用的段。寄存器`ss`在访问堆栈（通过堆栈指针`esp`）时使用，而`ds`用于其他数据访问。操作系统可以自由地使用寄存器`es`、`gs`和`fs`。
- en: 'Below is an example showing implicit use of the segment registers:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示隐式使用段寄存器的示例：
- en: '[PRE44]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The above example can be compared with the following one that makes explicit
    use of the segment registers:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可以与以下一个显式使用段寄存器的示例进行比较：
- en: '[PRE45]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You don’t need to use `ss` for storing the stack segment selector, or `ds` for
    the data segment selector. You could store the stack segment selector in `ds`
    and vice versa. However, in order to use the implicit style shown above, you must
    store the segment selectors in their indented registers.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要使用`ss`来存储堆栈段选择符，或`ds`来存储数据段选择符。你可以将堆栈段选择符存储在`ds`中，反之亦然。然而，为了使用上面显示的隐式样式，你必须将段选择符存储在其缩进的寄存器中。
- en: Segment descriptors and their fields are described in figure 3-8 in the Intel
    manual [33].
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 段描述符及其字段在英特尔手册[33]的第3-8图中有描述。
- en: 5.2 The Global Descriptor Table (GDT)
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 全局描述符表（GDT）
- en: A GDT/LDT is an array of 8-byte segment descriptors. The first descriptor in
    the GDT is always a null descriptor and can never be used to access memory. At
    least two segment descriptors (plus the null descriptor) are needed for the GDT,
    because the descriptor contains more information than just the base and limit
    fields. The two most relevant fields for us are the *Type* field and the *Descriptor
    Privilege Level* (DPL) field.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: GDT/LDT是一个8字节段描述符的数组。GDT中的第一个描述符始终是空描述符，并且永远不能用于访问内存。GDT至少需要两个段描述符（加上空描述符），因为描述符包含的信息不仅仅是基址和界限字段。对我们来说，最相关的两个字段是*类型*字段和*描述符特权级*（DPL）字段。
- en: 'Table 3-1 in chapter 3 of the Intel manual [33] specifies the values for the
    Type field. The table shows that the Type field can’t be both writable *and* executable
    at the same time. Therefore, two segments are needed: one segment for executing
    code to put in `cs` (Type is Execute-only or Execute-Read) and one segment for
    reading and writing data (Type is Read/Write) to put in the other segment registers.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Intel手册[33]第3章的表3-1指定了类型字段的值。该表显示类型字段不能同时是可写和可执行的。因此，需要两个段：一个用于执行代码并将其放入`cs`（类型为仅执行或执行-读取）的段，另一个用于读取和写入数据（类型为读/写）并将其放入其他段寄存器。
- en: The DPL specifies the *privilege levels* required to use the segment. x86 allows
    for four privilege levels (PL), 0 to 3, where PL0 is the most privileged. In most
    operating systems (eg. Linux and Windows), only PL0 and PL3 are used. However,
    some operating system, such as MINIX, make use of all levels. The kernel should
    be able to do anything, therefore it uses segments with DPL set to 0 (also called
    kernel mode). The current privilege level (CPL) is determined by the segment selector
    in `cs`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: DPL指定使用该段所需的*特权级*。x86允许四个特权级（PL），0到3，其中PL0是最特权的。在大多数操作系统（例如Linux和Windows）中，仅使用PL0和PL3。然而，一些操作系统（如MINIX）使用所有级别。内核应该能够做任何事情，因此它使用DPL设置为0的段（也称为内核模式）。当前特权级（CPL）由`cs`中的段选择符确定。
- en: The segments needed are described in the table below.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下表中描述了所需的段。
- en: The segment descriptors needed.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的段描述符。
- en: '| Index | Offset | Name | Address range | Type | DPL |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 偏移量 | 名称 | 地址范围 | 类型 | DPL |'
- en: '| --: | --: | :-- | :-- | :-- | :-- |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| --: | --: | :-- | :-- | :-- | :-- |'
- en: '| 0 | `0x00` | null descriptor |  |  |  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `0x00` | 空描述符 |  |  |  |'
- en: '| 1 | `0x08` | kernel code segment | `0x00000000 - 0xFFFFFFFF` | RX | PL0 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `0x08` | 内核代码段 | `0x00000000 - 0xFFFFFFFF` | RX | PL0 |'
- en: '| 2 | `0x10` | kernel data segment | `0x00000000 - 0xFFFFFFFF` | RW | PL0 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `0x10` | 内核数据段 | `0x00000000 - 0xFFFFFFFF` | RW | PL0 |'
- en: Note that the segments overlap - they both encompass the entire linear address
    space. In our minimal setup we’ll only use segmentation to get privilege levels.
    See the Intel manual [33], chapter 3, for details on the other descriptor fields.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，段重叠 - 它们都包含整个线性地址空间。在我们的最小设置中，我们只会使用分段来获取特权级。有关其他描述符字段的详细信息，请参阅Intel手册[33]第3章。
- en: 5.3 Loading the GDT
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 加载GDT
- en: 'Loading the GDT into the processor is done with the `lgdt` assembly code instruction,
    which takes the address of a struct that specifies the start and size of the GDT.
    It is easiest to encode this information using a [“packed struct”](#packing-structs)
    as shown in the following example:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lgdt`汇编代码指令将GDT加载到处理器中，该指令接受一个结构体的地址，该结构体指定GDT的起始地址和大小。最简单的方法是使用以下示例中的“打包结构”来编码此信息：
- en: '[PRE46]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the content of the `eax` register is the address to such a struct, then
    the GDT can be loaded with the assembly code shown below:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`eax`寄存器的内容是此类结构的地址，则可以使用以下汇编代码将GDT加载：
- en: '[PRE47]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It might be easier if you make this instruction available from C, the same way
    as was done with the assembly code instructions `in` and `out`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能从C中提供此指令，就像对汇编代码指令`in`和`out`所做的那样，可能会更容易。
- en: 'After the GDT has been loaded the segment registers needs to be loaded with
    their corresponding segment selectors. The content of a segment selector is described
    in the figure and table below:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 加载GDT后，需要将段寄存器加载为其对应的段选择符。段选择符的内容在下图和下表中描述：
- en: '[PRE48]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The layout of segment selectors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 段选择符的布局。
- en: '| Name | Description |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| :-- | :-- |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| :-- | :-- |'
- en: '| rpl | Requested Privilege Level - we want to execute in PL0 for now. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| rpl | 请求的特权级 - 目前我们希望在PL0级别执行。 |'
- en: '| ti | Table Indicator. 0 means that this specifies a GDT segment, 1 means
    an LDT Segment. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| ti | 表指示符。0表示指定GDT段，1表示LDT段。 |'
- en: '| offset (index) | Offset within descriptor table. |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 偏移（索引） | 描述符表内的偏移量。 |'
- en: 'The offset of the segment selector is added to the start of the GDT to get
    the address of the segment descriptor: `0x08` for the first descriptor and `0x10`
    for the second, since each descriptor is 8 bytes. The Requested Privilege Level
    (RPL) should be `0` since the kernel of the OS should execute in privilege level
    0.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 段选择符的偏移量加到GDT的起始位置，以获得段描述符的地址：第一个描述符为 `0x08`，第二个为 `0x10`，因为每个描述符是8字节。请求的特权级（RPL）应该是
    `0`，因为操作系统的内核应该在特权级0上执行。
- en: 'Loading the segment selector registers is easy for the data registers - just
    copy the correct offsets to the registers:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 加载段选择符寄存器对于数据寄存器来说很容易——只需将正确的偏移量复制到寄存器中：
- en: '[PRE49]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To load `cs` we have to do a “far jump”:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载 `cs`，我们必须执行一个“远跳”：
- en: '[PRE50]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A far jump is a jump where we explicitly specify the full 48-bit logical address:
    the segment selector to use and the absolute address to jump to. It will first
    set `cs` to `0x08` and then jump to `flush_cs` using its absolute address.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 远跳是一种显式指定完整48位逻辑地址的跳转：要使用的段选择符和要跳转到的绝对地址。它首先将 `cs` 设置为 `0x08`，然后使用其绝对地址跳转到 `flush_cs`。
- en: 5.4 Further Reading
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 进一步阅读
- en: Chapter 3 of the Intel manual [33] is filled with low-level and technical details
    about segmentation.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔手册[33]的第3章充满了关于分段的低级和技术细节。
- en: 'The OSDev wiki has a page about segmentation: [http://wiki.osdev.org/Segmentation](http://wiki.osdev.org/Segmentation)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSDev wiki有一个关于分段的页面：[http://wiki.osdev.org/Segmentation](http://wiki.osdev.org/Segmentation)
- en: 'The Wikipedia page on x86 segmentation might be worth looking into: [http://en.wikipedia.org/wiki/X86_memory_segmentation](http://en.wikipedia.org/wiki/X86_memory_segmentation)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上关于x86分段的页面可能值得一看：[http://en.wikipedia.org/wiki/X86_memory_segmentation](http://en.wikipedia.org/wiki/X86_memory_segmentation)
- en: 6 Interrupts and Input
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 中断和输入
- en: Now that the OS can produce *output* it would be nice if it also could get some
    *input*. (The operating system must be able to handle *interrupts* in order to
    read information from the keyboard). An interrupt occurs when a hardware device,
    such as the keyboard, the serial port or the timer, signals the CPU that the state
    of the device has changed. The CPU itself can also send interrupts due to program
    errors, for example when a program references memory it doesn’t have access to,
    or when a program divides a number by zero. Finally, there are also *software
    intterupts*, which are interrupts that are caused by the `int` assembly code instruction,
    and they are often used for system calls.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在操作系统可以产生 *输出*，如果它也能接收一些 *输入* 会更好。（操作系统必须能够处理 *中断* 以从键盘读取信息）。当硬件设备，如键盘、串行端口或定时器，向CPU发出信号，表明设备状态已改变时，就会发生中断。CPU本身也可以由于程序错误而发送中断，例如当程序引用它没有访问权限的内存时，或者当程序将一个数除以零时。最后，还有
    *软件中断*，它们是由 `int` 汇编指令引起的，通常用于系统调用。
- en: 6.1 Interrupts Handlers
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 中断处理程序
- en: 'Interrupts are handled via the *Interrupt Descriptor Table* (IDT). The IDT
    describes a handler for each interrupt. The interrupts are numbered (0 - 255)
    and the handler for interrupt *i* is defined at the *ith* position in the table.
    There are three different kinds of handlers for interrupts:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 中断通过 *中断描述符表* (IDT) 处理。IDT描述了每个中断的处理程序。中断被编号（0 - 255），中断 *i* 的处理程序定义在表的 *i*
    位置。对于中断有三种不同类型的处理程序：
- en: Task handler
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务处理程序
- en: Interrupt handler
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断处理程序
- en: Trap handler
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陷阱处理程序
- en: The task handlers use functionality specific to the Intel version of x86, so
    they won’t be covered here (see the Intel manual [33], chapter 6, for more info).
    The only difference between an interrupt handler and a trap handler is that the
    interrupt handler disables interrupts, which means you cannot get an interrupt
    while at the same time handling an interrupt. In this book, we will use trap handlers
    and disable interrupts manually when we need to.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 任务处理程序使用特定于英特尔版本的x86的功能，因此这里不会涉及（有关更多信息，请参阅英特尔手册[33]，第6章）。中断处理程序和陷阱处理程序之间的唯一区别是，中断处理程序会禁用中断，这意味着在处理中断的同时无法获得中断。在这本书中，当我们需要时，我们将使用陷阱处理程序并手动禁用中断。
- en: 6.2 Creating an Entry in the IDT
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 在IDT中创建条目
- en: 'An entry in the IDT for an interrupt handler consists of 64 bits. The highest
    32 bits are shown in the figure below:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序在IDT中的条目由64位组成。最高32位如图所示：
- en: '[PRE51]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The lowest 32 bits are presented in the following figure:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 最低32位如图所示：
- en: '[PRE52]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A description for each name can be found in the table below:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称的描述可以在下面的表中找到：
- en: '| Name | Description |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --: | :-- |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| --: | :-- |'
- en: '| offset high | The 16 highest bits of the 32 bit address in the segment. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量高 | 段中32位地址的16位最高位。 |'
- en: '| offset low | The 16 lowest bits of the 32 bits address in the segment. |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 偏移量低 | 段中32位地址的16位最低位。 |'
- en: '| p | If the handler is present in memory or not (1 = present, 0 = not present).
    |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| p | 如果处理程序存在于内存中或不存在（1 = 存在，0 = 不存在）。 |'
- en: '| DPL | Descriptor Privilige Level, the privilege level the handler can be
    called from (0, 1, 2, 3). |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| DPL | 描述符特权级，处理程序可以被调用的特权级（0、1、2、3）。 |'
- en: '| D | Size of gate, (1 = 32 bits, 0 = 16 bits). |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| D | 门的尺寸，(1 = 32位，0 = 16位)。 |'
- en: '| segment selector | The offset in the GDT. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 段选择符 | GDT中的偏移量。 |'
- en: '| r | Reserved. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| r | 保留。 |'
- en: 'The offset is a pointer to code (preferably an assembly code label). For example,
    to create an entry for a handler whose code starts at `0xDEADBEEF` and that runs
    in privilege level 0 (therefore using the same code segment selector as the kernel)
    the following two bytes would be used:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量是指向代码的指针（最好是汇编代码标签）。例如，为了创建一个从`0xDEADBEEF`开始且在特权级0（因此使用与内核相同的代码段选择符）运行的处理器条目，将使用以下两个字节：
- en: '[PRE53]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the IDT is represented as an `unsigned integer idt[512]` then to register
    the above example as an handler for interrupt 0 (divide-by-zero), the following
    code would be used:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IDT表示为`unsigned integer idt[512]`，那么要将上述示例注册为中断0（除以零）的处理程序，将使用以下代码：
- en: '[PRE54]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As written in the chapter [“Getting to C”](#getting-to-c), we recommend that
    you instead of using bytes (or unsigned integers) use packed structures to make
    the code more readable.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如第[“进入C”](#getting-to-c)章所述，我们建议您使用打包结构（而不是字节或无符号整数）来使代码更易于阅读。
- en: 6.3 Handling an Interrupt
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 处理中断
- en: 'When an interrupt occurs the CPU will push some information about the interrupt
    onto the stack, then look up the appropriate interrupt hander in the IDT and jump
    to it. The stack at the time of the interrupt will look like the following:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生中断时，CPU会将有关中断的一些信息推入堆栈，然后在IDT中查找适当的中断处理程序并跳转到它。中断发生时的堆栈将如下所示：
- en: '[PRE55]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The reason for the question mark behind error code is that not all interrupts
    create an *error code*. The specific CPU interrupts that put an error code on
    the stack are 8, 10, 11, 12, 13, 14 and 17\. The error code can be used by the
    interrupt handler to get more information on what has happened. Also, note that
    the interrupt *number* is *not* pushed onto the stack. We can only determine what
    interrupt has occurred by knowing what code is executing - if the handler registered
    for interrupt 17 is executing, then interrupt 17 has occurred.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码后面的问号的原因是并非所有中断都会创建一个*错误代码*。将错误代码推入堆栈的特定CPU中断是8、10、11、12、13、14和17。错误代码可以被中断处理程序用来获取更多关于发生了什么的信息。此外，请注意，中断*编号*并没有推入堆栈。我们只能通过知道正在执行什么代码来确定发生了什么中断——如果注册了中断17的处理程序正在执行，那么就发生了中断17。
- en: Once the interrupt handler is done, it uses the `iret` instruction to return.
    The instruction `iret` expects the stack to be the same as at the time of the
    interrupt (see the figure above). Therefore, any values pushed onto the stack
    by the interrupt handler must be popped. Before returning, `iret` restores `eflags`
    by popping the value from the stack and then finally jumps to `cs:eip` as specified
    by the values on the stack.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦中断处理程序完成，它将使用`iret`指令返回。指令`iret`期望堆栈与中断发生时相同（参见上图）。因此，任何由中断处理程序推入堆栈的值都必须弹出。在返回之前，`iret`通过从堆栈中弹出值来恢复`eflags`，然后最终跳转到堆栈上指定的`cs:eip`。
- en: The interrupt handler has to be written in assembly code, since all registers
    that the interrupt handlers use must be preserved by pushing them onto the stack.
    This is because the code that was interrupted doesn’t know about the interrupt
    and will therefore expect that its registers stay the same. Writing all the logic
    of the interrupt handler in assembly code will be tiresome. Creating a handler
    in assembly code that saves the registers, calls a C function, restores the registers
    and finally executes `iret` is a good idea!
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序必须用汇编代码编写，因为中断处理程序使用的所有寄存器都必须通过将它们推入堆栈来保存。这是因为被中断的代码不知道中断，因此会期望其寄存器保持不变。将中断处理程序的逻辑全部用汇编代码编写将会很繁琐。在汇编代码中创建一个保存寄存器、调用C函数、恢复寄存器并最终执行`iret`的处理器是一个好主意！
- en: 'The C handler should get the state of the registers, the state of the stack
    and the number of the interrupt as arguments. The following definitions can for
    example be used:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: C处理程序应该获取寄存器的状态、堆栈的状态和中断号作为参数。以下定义可以例如使用：
- en: '[PRE56]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 6.4 Creating a Generic Interrupt Handler
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 创建一个通用中断处理程序
- en: 'Since the CPU does not push the interrupt number on the stack it is a little
    tricky to write a generic interrupt handler. This section will use macros to show
    how it can be done. Writing one version for each interrupt is tedious - it is
    better to use the macro functionality of NASM [34]. And since not all interrupts
    produce an error code the value 0 will be added as the “error code” for interrupts
    without an error code. The following code shows an example of how this can be
    done:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CPU不会将中断号压入堆栈，因此编写一个通用的中断处理程序有点棘手。本节将使用宏来展示如何实现。为每个中断编写一个版本是繁琐的——最好使用NASM
    [34]的宏功能。由于并非所有中断都产生错误代码，因此对于没有错误代码的中断，将添加值0作为“错误代码”。以下代码展示了如何实现：
- en: '[PRE57]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `common_interrupt_handler` does the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`common_interrupt_handler`执行以下操作：'
- en: Push the registers on the stack.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将寄存器推入堆栈。
- en: Call the C function `interrupt_handler`.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用C函数`interrupt_handler`。
- en: Pop the registers from the stack.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从堆栈中弹出寄存器。
- en: Add 8 to `esp` (because of the error code and the interrupt number pushed earlier).
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将8加到`esp`（因为之前推入的错误代码和中断号）。
- en: Execute `iret` to return to the interrupted code.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`iret`以返回到被中断的代码。
- en: Since the macros declare global labels the addresses of the interrupt handlers
    can be accessed from C or assembly code when creating the IDT.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏声明了全局标签，因此当创建IDT时，可以从C或汇编代码中访问中断处理程序的地址。
- en: 6.5 Loading the IDT
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 加载中断描述符表（IDT）
- en: 'The IDT is loaded with the `lidt` assembly code instruction which takes the
    address of the first element in the table. It is easiest to wrap this instruction
    and use it from C:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: IDT通过`lidt`汇编代码指令加载，该指令取表中的第一个元素的地址。最简单的方法是将此指令包装起来并从C中使用它：
- en: '[PRE58]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 6.6 Programmable Interrupt Controller (PIC)
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 可编程中断控制器（PIC）
- en: 'To start using hardware interrupts you must first configure the Programmable
    Interrupt Controller (PIC). The PIC makes it possible to map signals from the
    hardware to interrupts. The reasons for configuring the PIC are:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用硬件中断，您必须首先配置可编程中断控制器（PIC）。PIC使得将硬件信号映射到中断成为可能。配置PIC的原因是：
- en: Remap the interrupts. The PIC uses interrupts 0 - 15 for hardware interrupts
    by default, which conflicts with the CPU interrupts. Therefore the PIC interrupts
    must be remapped to another interval.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新映射中断。PIC默认使用中断0-15进行硬件中断，这与CPU中断冲突。因此，PIC中断必须重新映射到另一个区间。
- en: Select which interrupts to receive. You probably don’t want to receive interrupts
    from all devices since you don’t have code that handles these interrupts anyway.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要接收哪些中断。你可能不希望从所有设备接收中断，因为你无论如何都没有处理这些中断的代码。
- en: Set up the correct mode for the PIC.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置PIC的正确模式。
- en: In the beginning there was only one PIC (PIC 1) and eight interrupts. As more
    hardware were added, 8 interrupts were too few. The solution chosen was to chain
    on another PIC (PIC 2) on the first PIC (see interrupt 2 on PIC 1).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，只有一个PIC（PIC 1）和八个中断。随着更多硬件的添加，八个中断就不够了。选择的解决方案是在第一个PIC（PIC 1）上链式连接另一个PIC（PIC
    2）（参见PIC 1上的中断2）。
- en: 'The hardware interrupts are shown in the table below:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了硬件中断：
- en: '| PIC 1 | Hardware | PIC 2 | Hardware |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| PIC 1 | 硬件 | PIC 2 | 硬件 |'
- en: '| --: | :-- | --: | :-- |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| --: | :-- | --: | :-- |'
- en: '| 0 | Timer | 8 | Real Time Clock |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 定时器 | 8 | 实时时钟 |'
- en: '| 1 | Keyboard | 9 | General I/O |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 键盘 | 9 | 通用I/O |'
- en: '| 2 | PIC 2 | 10 | General I/O |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 2 | PIC 2 | 10 | 通用I/O |'
- en: '| 3 | COM 2 | 11 | General I/O |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 3 | COM 2 | 11 | 通用I/O |'
- en: '| 4 | COM 1 | 12 | General I/O |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| 4 | COM 1 | 12 | 通用I/O |'
- en: '| 5 | LPT 2 | 13 | Coprocessor |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| 5 | LPT 2 | 13 | 协处理器 |'
- en: '| 6 | Floppy disk | 14 | IDE Bus |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 软盘 | 14 | IDE总线 |'
- en: '| 7 | LPT 1 | 15 | IDE Bus |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 7 | LPT 1 | 15 | IDE总线 |'
- en: A great tutorial for configuring the PIC can be found at the SigOPS website
    [35]. We won’t repeat that information here.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在SigOPS网站上可以找到一个关于配置PIC的优秀教程[35]。我们不会在这里重复这些信息。
- en: Every interrupt from the PIC has to be acknowledged - that is, sending a message
    to the PIC confirming that the interrupt has been handled. If this isn’t done
    the PIC won’t generate any more interrupts.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 每个来自PIC的中断都必须被确认——也就是说，向PIC发送消息以确认已处理中断。如果不这样做，PIC将不会生成任何更多中断。
- en: 'Acknowledging a PIC interrupt is done by sending the byte `0x20` to the PIC
    that raised the interrupt. Implementing a `pic_acknowledge` function can thus
    be done as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向引发中断的 PIC 发送字节 `0x20` 来确认 PIC 中断。因此，实现 `pic_acknowledge` 函数可以如下进行：
- en: '[PRE59]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 6.7 Reading Input from the Keyboard
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 从键盘读取输入
- en: 'The keyboard does not generate ASCII characters, it generates scan codes. A
    scan code represents a button - both presses and releases. The scan code representing
    the just pressed button can be read from the keyboard’s data I/O port which has
    address `0x60`. How this can be done is shown in the following example:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘不生成 ASCII 字符，它生成扫描码。扫描码代表一个按钮 - 无论是按下还是释放。代表刚刚按下的按钮的扫描码可以从地址为 `0x60` 的键盘数据
    I/O 端口读取。以下示例展示了如何做到这一点：
- en: '[PRE60]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The next step is to write a function that translates a scan code to the corresponding
    ASCII character. If you want to map the scan codes to ASCII characters as is done
    on an American keyboard then Andries Brouwer has a great tutorial [36].
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写一个将扫描码转换为相应 ASCII 字符的函数。如果你想要像在美国键盘上那样将扫描码映射到 ASCII 字符，Andries Brouwer
    有一个很好的教程 [36]。
- en: Remember, since the keyboard interrupt is raised by the PIC, you must call `pic_acknowledge`
    at the end of the keyboard interrupt handler. Also, the keyboard will not send
    you any more interrupts until you read the scan code from the keyboard.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于键盘中断是由 PIC 引起的，你必须在键盘中断处理程序的末尾调用 `pic_acknowledge`。此外，键盘在你不读取扫描码之前不会发送任何更多中断。
- en: 6.8 Further Reading
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 进一步阅读
- en: The OSDev wiki has a great page on interrupts, [http://wiki.osdev.org/Interrupts](http://wiki.osdev.org/Interrupts)
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSDev 维基有一个关于中断的优秀页面，[http://wiki.osdev.org/Interrupts](http://wiki.osdev.org/Interrupts)
- en: Chapter 6 of Intel Manual 3a [33] describes everything there is to know about
    interrupts.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intel 手册 3a 的第 6 章节描述了关于中断的所有知识。
- en: 7 The Road to User Mode
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 用户模式之路
- en: Now that the kernel boots, prints to screen and reads from keyboard - what do
    we do? Usually, a kernel is not supposed to do the application logic itself, but
    leave that for applications. The kernel creates the proper abstractions (for memory,
    files, devices) to make application development easier, performs tasks on behalf
    of applications (system calls) and [schedules processes](#scheduling).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内核已经启动，打印到屏幕并从键盘读取 - 我们接下来做什么？通常，内核不应该自己执行应用程序逻辑，而是留给应用程序。内核创建适当的抽象（对于内存、文件、设备），使应用程序开发更容易，代表应用程序执行任务（系统调用），并
    [调度进程](#scheduling)。
- en: User mode, in contrast with kernel mode, is the environment in which the user’s
    programs execute. This environment is less privileged than the kernel, and will
    prevent (badly written) user programs from messing with other programs or the
    kernel. Badly written kernels are free to mess up what they want.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核模式相比，用户模式是用户程序执行的环境。这个环境比内核权限低，将防止（编写不良的）用户程序干扰其他程序或内核。编写不良的内核可以随意破坏它们想要的。
- en: There’s quite a way to go until the OS created in this book can execute programs
    in user mode, but this chapter will show how to easily execute a small program
    in kernel mode.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 直到本书中创建的操作系统可以以用户模式执行程序，还有很长的路要走，但本章将展示如何轻松地在内核模式下执行一个小程序。
- en: 7.1 Loading an External Program
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 加载外部程序
- en: Where do we get the external program from? Somehow we need to load the code
    we want to execute into memory. More feature-complete operating systems usually
    have drivers and file systems that enable them to load the software from a CD-ROM
    drive, a hard disk or other persistent media.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从哪里获取外部程序？我们 somehow 需要将我们想要执行的代码加载到内存中。功能更完整的操作系统通常有驱动程序和文件系统，使它们能够从 CD-ROM
    驱动器、硬盘或其他持久介质中加载软件。
- en: Instead of creating all these drivers and file systems we will use a feature
    in GRUB called modules to load the program.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会创建所有这些驱动程序和文件系统，我们将使用 GRUB 中的一个功能，称为模块来加载程序。
- en: 7.1.1 GRUB Modules
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 GRUB 模块
- en: 'GRUB can load arbitrary files into memory from the ISO image, and these files
    are usually referred to as *modules*. To make GRUB load a module, edit the file
    `iso/boot/grub/menu.lst` and add the following line at the end of the file:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB 可以从 ISO 映像中加载任意文件到内存中，这些文件通常被称为 *模块*。要使 GRUB 加载一个模块，编辑文件 `iso/boot/grub/menu.lst`
    并在文件末尾添加以下行：
- en: '[PRE61]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now create the folder `iso/modules`:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建文件夹 `iso/modules`：
- en: '[PRE62]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The application `program` will be created later in this chapter.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序 `program` 将在本章后面创建。
- en: The code that calls `kmain` must be updated to pass information to `kmain` about
    where it can find the modules. We also want to tell GRUB that it should align
    all the modules on page boundaries when loading them (see the chapter [“Paging”](#paging)
    for details about page alignment).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`kmain`的代码必须更新，以便将有关模块位置的信息传递给`kmain`。我们还希望告诉GRUB在加载模块时应将所有模块对齐到页面边界（有关页面对齐的详细信息，请参阅[“分页”](#paging)章节）。
- en: 'To instruct GRUB how to load our modules, the “multiboot header” - the first
    bytes of the kernel - must be updated as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 要指导GRUB如何加载我们的模块，内核的“多引导头” - 内核的第一字节 - 必须按以下方式更新：
- en: '[PRE63]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: GRUB will also store a pointer to a `struct` in the register `ebx` that, among
    other things, describes at which addresses the modules are loaded. Therefore,
    you probably want to push `ebx` on the stack before calling `kmain` to make it
    an argument for `kmain`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB还会在寄存器`ebx`中存储一个指向`struct`的指针，该指针描述了模块加载的地址。因此，在调用`kmain`之前，你可能想要将`ebx`压入堆栈，使其成为`kmain`的参数。
- en: 7.2 Executing a Program
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 执行程序
- en: 7.2.1 A Very Simple Program
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 一个非常简单的程序
- en: 'A program written at this stage can only perform a few actions. Therefore,
    a very short program that writes a value to a register suffices as a test program.
    Halting Bochs after a while and then check that register contains the correct
    number by looking in the Bochs log will verify that the program has run. This
    is an example of such a short program:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段编写的程序只能执行少数几个操作。因此，一个将值写入寄存器的非常短的程序就足以作为测试程序。在一段时间后停止Bochs，然后通过查看Bochs日志来检查该寄存器是否包含正确的数字，以验证程序已运行。这是一个这样的短程序示例：
- en: '[PRE64]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 7.2.2 Compiling
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 编译
- en: 'Since our kernel cannot parse advanced executable formats we need to compile
    the code into a flat binary. NASM can do this with the flag `-f`:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的内核无法解析高级可执行格式，我们需要将代码编译成一个平坦的二进制文件。NASM可以使用`-f`标志来完成此操作：
- en: '[PRE65]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is all we need. You must now move the file `program` to the folder `iso/modules`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的全部。现在你必须将文件`program`移动到文件夹`iso/modules`中。
- en: 7.2.3 Finding the Program in Memory
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 在内存中查找程序
- en: Before jumping to the program we must find where it resides in memory. Assuming
    that the contents of `ebx` is passed as an argument to `kmain`, we can do this
    entirely from C.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到程序之前，我们必须找到它在内存中的位置。假设`ebx`的内容作为参数传递给`kmain`，我们可以完全从C中完成这个操作。
- en: The pointer in `ebx` points to a *multiboot* structure [19]. Download the `multiboot.h`
    file from [http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html](http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html),
    which describes the structure.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`ebx`中的指针指向一个*多引导*结构[19]。从[http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html](http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html)下载`multiboot.h`文件，该文件描述了结构。'
- en: 'The pointer passed to `kmain` in the `ebx` register can be cast to a `multiboot_info_t`
    pointer. The address of the first module is in the field `mods_addr`. The following
    code shows an example:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`kmain`的`ebx`寄存器中的指针可以转换为`multiboot_info_t`指针。第一个模块的地址在`mods_addr`字段中。以下代码显示了一个示例：
- en: '[PRE66]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: However, before just blindly following the pointer, you should check that the
    module got loaded correctly by GRUB. This can be done by checking the `flags`
    field of the `multiboot_info_t` structure. You should also check the field `mods_count`
    to make sure it is exactly 1\. For more details about the multiboot structure,
    see the multiboot documentation [19].
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在盲目跟随指针之前，你应该检查模块是否被GRUB正确加载。这可以通过检查`multiboot_info_t`结构的`flags`字段来完成。你还应该检查`mods_count`字段，以确保它正好为1。有关多引导结构的更多详细信息，请参阅多引导文档[19]。
- en: 7.2.4 Jumping to the Code
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 跳转到代码
- en: 'The only thing left to do is to jump to the code loaded by GRUB. Since it is
    easier to parse the multiboot structure in C than assembly code, calling the code
    from C is more convenient (it can of course be done with `jmp` or `call` in assembly
    code as well). The C code could look like this:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是跳转到GRUB加载的代码。由于在C中解析多引导结构比汇编代码更容易，所以从C调用代码更方便（当然，也可以用汇编代码中的`jmp`或`call`来完成）。C代码可能看起来像这样：
- en: '[PRE67]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we start the kernel, wait until it has run and entered the infinite loop
    in the program, and then halt Bochs, we should see `0xDEADBEEF` in the register
    `eax` via the Bochs log. We have successfully started a program in our OS!
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动内核，等待它运行并进入程序中的无限循环，然后停止Bochs，我们应该通过Bochs日志看到寄存器`eax`中的`0xDEADBEEF`。我们在我们的操作系统中成功启动了一个程序！
- en: 7.3 The Beginning of User Mode
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 用户模式的开始
- en: The program we’ve written now runs at the same privilege level as the kernel
    - we’ve just entered it in a somewhat peculiar way. To enable applications to
    execute at a different privilege level we’ll need to, beside [*segmentation*](#segmentation),
    do [*paging*](#paging) and [*page frame allocation*](#page-frame-allocation).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在编写的程序与内核运行在相同的权限级别上 - 我们只是以某种奇特的方式进入了它。为了使应用程序能够在不同的权限级别上执行，我们除了[*分段*](#segmentation)之外，还需要做[*分页*](#paging)和[*页面帧分配*](#page-frame-allocation)。
- en: It’s quite a lot of work and technical details to go through, but in a few chapters
    you’ll have working user mode programs.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理的工作和详细的技术细节相当多，但在几章之内，你将拥有运行的用户模式程序。
- en: 8 A Short Introduction to Virtual Memory
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 虚拟内存简述
- en: '*Virtual memory* is an abstraction of physical memory. The purpose of virtual
    memory is generally to simplify application development and to let processes address
    more memory than what is actually physically present in the machine. We also don’t
    want applications messing with the kernel or other applications’ memory due to
    security.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟内存*是物理内存的一种抽象。虚拟内存的目的是通常是为了简化应用程序的开发，并让进程能够访问比机器实际物理存在的内存更多的内存。我们也不希望应用程序因为安全原因而干扰内核或其他应用程序的内存。'
- en: 'In the x86 architecture, virtual memory can be accomplished in two ways: *segmentation*
    and *paging*. Paging is by far the most common and versatile technique, and we’ll
    implement it the next chapter. Some use of segmentation is still necessary to
    allow for code to execute under different privilege levels.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86架构中，虚拟内存可以通过两种方式实现：*分段*和*分页*。分页是最常见和最通用的技术，我们将在下一章实现它。尽管如此，分段的一些使用仍然是必要的，以便允许代码在不同的权限级别下执行。
- en: Managing memory is a big part of what an operating system does. [Paging](#paging)
    and [page frame allocation](#page-frame-allocation) deals with that.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 管理内存是操作系统所做的大事之一。[分页](#paging)和[页面帧分配](#page-frame-allocation)处理这个问题。
- en: Segmentation and paging is described in the [33], chapter 3 and 4.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 分段和分页在[33]的第3章和第4章中描述。
- en: 8.1 Virtual Memory Through Segmentation?
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 通过分段实现虚拟内存？
- en: You could skip paging entirely and just use segmentation for virtual memory.
    Each user mode process would get its own segment, with base address and limit
    properly set up. This way no process can see the memory of another process. A
    problem with this is that the physical memory for a process needs to be contiguous
    (or at least it is very convenient if it is). Either we need to know in advance
    how much memory the program will require (unlikely), or we can move the memory
    segments to places where they can grow when the limit is reached (expensive, causes
    fragmentation - can result in “out of memory” even though enough memory is available).
    Paging solves both these problems.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完全跳过分页，只使用分段来实现虚拟内存。每个用户模式进程都会得到自己的分段，其基址和限制被正确设置。这样，没有进程可以看到另一个进程的内存。这个问题是，进程的物理内存需要是连续的（或者至少如果它是的话，会非常方便）。我们可能需要事先知道程序将需要多少内存（不太可能），或者我们可以将内存段移动到当限制达到时可以扩展的地方（昂贵，导致碎片化
    - 即使有足够的内存也可能导致“内存不足”）。分页解决了这两个问题。
- en: It is interesting to note that in x86_64 (the 64-bit version of the x86 architecture),
    segmentation is almost completely removed.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在x86_64（x86架构的64位版本）中，分段几乎被完全移除。
- en: 8.2 Further Reading
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 进一步阅读
- en: 'LWN.net has an article on virtual memory: [http://lwn.net/Articles/253361/](http://lwn.net/Articles/253361/)'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LWN.net有一篇关于虚拟内存的文章：[http://lwn.net/Articles/253361/](http://lwn.net/Articles/253361/)
- en: 'Gustavo Duarte has also written an article about virtual memory: [http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation](http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation)'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gustavo Duarte也写了一篇关于虚拟内存的文章：[http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation](http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation)
- en: 9 Paging
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 分页
- en: Segmentation translates a logical address into a linear address. *Paging* translates
    these linear addresses onto the physical address space, and determines access
    rights and how the memory should be cached.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 分段将逻辑地址转换为线性地址。*分页*将这些线性地址转换到物理地址空间，并确定访问权限以及内存应该如何缓存。
- en: 9.1 Why Paging?
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 为什么需要分页？
- en: Paging is the most common technique used in x86 to enable virtual memory. Virtual
    memory through paging means that each process will get the impression that the
    available memory range is `0x00000000` - `0xFFFFFFFF` even though the actual size
    of the memory might be much less. It also means that when a process addresses
    a byte of memory it will use a virtual (linear) address instead of physical one.
    The code in the user process won’t notice any difference (except for execution
    delays). The linear address gets translated to a physical address by the MMU and
    the page table. If the virtual address isn’t mapped to a physical address, the
    CPU will raise a page fault interrupt.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是x86中最常用的技术，用于启用虚拟内存。通过分页实现的虚拟内存意味着每个进程都会有一种印象，即可用的内存范围是`0x00000000` - `0xFFFFFFFF`，尽管实际的内存大小可能要小得多。这也意味着当进程访问内存的一个字节时，它将使用虚拟（线性）地址而不是物理地址。用户进程中的代码不会注意到任何差异（除了执行延迟）。线性地址通过MMU和页表转换为物理地址。如果虚拟地址没有映射到物理地址，CPU将引发页面错误中断。
- en: Paging is optional, and some operating systems do not make use of it. But if
    we want to mark certain areas of memory accessible only to code running at a certain
    privilege level (to be able to have processes running at different privilege levels),
    paging is the neatest way to do it.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是可选的，某些操作系统并不使用它。但如果我们想标记内存的某些区域，只允许在特定权限级别运行的代码访问（以便能够有不同权限级别运行的过程），分页是做这件事最整洁的方式。
- en: 9.2 Paging in x86
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 x86中的分页
- en: Paging in x86 (chapter 4 in the Intel manual [33]) consists of a *page directory*
    (PDT) that can contain references to 1024 *page tables* (PT), each of which can
    point to 1024 sections of physical memory called *page frames* (PF). Each page
    frame is 4096 byte large. In a virtual (linear) address, the highest 10 bits specifies
    the offset of a page directory entry (PDE) in the current PDT, the next 10 bits
    the offset of a page table entry (PTE) within the page table pointed to by that
    PDE. The lowest 12 bits in the address is the offset within the page frame to
    be addressed.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: x86中的分页（英特尔手册[33]中的第4章）包括一个*页目录*（PDT），它可以包含对1024个*页表*（PT）的引用，每个页表可以指向1024个物理内存的部分，称为*页帧*（PF）。每个页帧大小为4096字节。在虚拟（线性）地址中，最高的10位指定了当前PDT中页目录条目（PDE）的偏移量，接下来的10位指定了由该PDE指向的页表中的页表条目（PTE）的偏移量。地址中的最低12位是页帧内要访问的偏移量。
- en: All page directories, page tables and page frames need to be aligned on 4096
    byte addresses. This makes it possible to address a PDT, PT or PF with just the
    highest 20 bits of a 32 bit address, since the lowest 12 need to be zero.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的页目录、页表和页帧都需要对齐到4096字节地址。这使得仅使用32位地址的最高20位就可以访问PDT、PT或PF，因为最低的12位需要为零。
- en: 'The PDE and PTE structure is very similar to each other: 32 bits (4 bytes),
    where the highest 20 bits points to a PTE or PF, and the lowest 12 bits control
    access rights and other configurations. 4 bytes times 1024 equals 4096 bytes,
    so a page directory and page table both fit in a page frame themselves.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: PDE和PTE结构彼此非常相似：32位（4字节），其中最高的20位指向PTE或PF，最低的12位控制访问权限和其他配置。4字节乘以1024等于4096字节，因此页目录和页表本身都可以放入页帧中。
- en: The translation of linear addresses to physical addresses is described in the
    figure below.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 线性地址到物理地址的转换在下面的图中描述。
- en: While pages are normally 4096 bytes, it is also possible to use 4 MB pages.
    A PDE then points directly to a 4 MB page frame, which needs to be aligned on
    a 4 MB address boundary. The address translation is almost the same as in the
    figure, with just the page table step removed. It is possible to mix 4 MB and
    4 KB pages.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然页通常是4096字节，但也可能使用4MB页。在这种情况下，PDE直接指向一个4MB的页帧，该页帧需要对齐到4MB地址边界。地址转换几乎与图中的相同，只是去掉了页表步骤。可以混合使用4MB和4KB页。
- en: '![Translating virtual addresses (linear addresses) to physical addresses.](img/8a5c324efa415f1a6e2fa86960549158.png)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![将虚拟地址（线性地址）转换为物理地址。](img/8a5c324efa415f1a6e2fa86960549158.png)'
- en: Translating virtual addresses (linear addresses) to physical addresses.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟地址（线性地址）转换为物理地址。
- en: The 20 bits pointing to the current PDT is stored in the register `cr3`. The
    lower 12 bits of `cr3` are used for configuration.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 指向当前PDT的20位存储在寄存器`cr3`中。`cr3`的较低12位用于配置。
- en: For more details on the paging structures, see chapter 4 in the Intel manual
    [33]. The most interesting bits are *U/S*, which determine what privilege levels
    can access this page (PL0 or PL3), and *R/W*, which makes the memory in the page
    read-write or read-only.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分页结构的更多详细信息，请参阅英特尔手册第4章[33]。最有趣的位是*U/S*，它决定了哪些特权级别可以访问此页面（PL0或PL3），以及*R/W*，它使页面中的内存为读写或只读。
- en: 9.2.1 Identity Paging
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 身份分页
- en: The simplest kind of paging is when we map each virtual address onto the same
    physical address, called *identity paging*. This can be done at compile time by
    creating a page directory where each entry points to its corresponding 4 MB frame.
    In NASM this can be done with macros and commands (`%rep`, `times` and `dd`).
    It can of course also be done at run-time by using ordinary assembly code instructions.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的分页类型是将每个虚拟地址映射到相同的物理地址，称为*身份分页*。这可以在编译时通过创建一个页面目录来实现，其中每个条目都指向其对应的4 MB帧。在NASM中，可以使用宏和命令（`%rep`、`times`和`dd`）来实现。当然，也可以通过使用普通的汇编代码指令在运行时实现。
- en: 9.2.2 Enabling Paging
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 启用分页
- en: 'Paging is enabled by first writing the address of a page directory to `cr3`
    and then setting bit 31 (the PG “paging-enable” bit) of `cr0` to `1`. To use 4
    MB pages, set the PSE bit (Page Size Extensions, bit 4) of `cr4`. The following
    assembly code shows an example:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先将页面目录的地址写入`cr3`，然后设置`cr0`的31位（PG“分页启用”位）为`1`来启用分页。要使用4 MB页面，设置`cr4`的PSE位（页面大小扩展，位4）。下面的汇编代码显示了示例：
- en: '[PRE68]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 9.2.3 A Few Details
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 一些细节
- en: It is important to note that all addresses within the page directory, page tables
    and in `cr3` need to be physical addresses to the structures, never virtual. This
    will be more relevant in later sections where we dynamically update the paging
    structures (see the chapter [“User Mode”](#user-mode)).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，页面目录、页面表和`cr3`中的所有地址都需要是结构体的物理地址，而不是虚拟地址。这在后面的章节中会更为相关，其中我们将动态更新分页结构（参见章节[“用户模式”](#user-mode)）。
- en: An instruction that is useful when an updating a PDT or PT is `invlpg`. It invalidates
    the *Translation Lookaside Buffer* (TLB) entry for a virtual address. The TLB
    is a cache for translated addresses, mapping physical addresses corresponding
    to virtual addresses. This is only required when changing a PDE or PTE that was
    previously mapped to something else. If the PDE or PTE had previously been marked
    as not present (bit 0 was set to 0), executing `invlpg` is unnecessary. Changing
    the value of `cr3` will cause all entries in the TLB to be invalidated.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新PDT或PT时，一个有用的指令是`invlpg`。它使虚拟地址的*转换后备缓冲区*（TLB）条目无效。TLB是翻译地址的缓存，映射与虚拟地址对应的物理地址。这仅在更改之前映射到其他内容的PDE或PTE时才需要。如果PDE或PTE之前已被标记为不存在（位0设置为0），则执行`invlpg`是不必要的。更改`cr3`的值将使TLB中的所有条目无效。
- en: 'An example of invalidating a TLB entry is shown below:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个无效化TLB条目的示例：
- en: '[PRE69]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 9.3 Paging and the Kernel
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 分页与内核
- en: This section will describe how paging affects the OS kernel. We encourage you
    to run your OS using identity paging before trying to implement a more advanced
    paging setup, since it can be hard to debug a malfunctioning page table that is
    set up via assembly code.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述分页如何影响操作系统内核。我们鼓励你在尝试实现更高级的分页设置之前，先使用身份分页运行你的操作系统，因为通过汇编代码设置的分页表故障调试可能很困难。
- en: 9.3.1 Reasons to Not Identity Map the Kernel
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 不将内核映射为身份映射的原因
- en: If the kernel is placed at the beginning of the virtual address space - that
    is, the virtual address space (`0x00000000`, `"size of kernel"`) maps to the location
    of the kernel in memory - there will be issues when linking the user mode process
    code. Normally, during linking, the linker assumes that the code will be loaded
    into the memory position `0x00000000`. Therefore, when resolving absolute references,
    `0x00000000` will be the base address for calculating the exact position. But
    if the kernel is mapped onto the virtual address space (`0x00000000`, `"size of
    kernel"`), the user mode process cannot be loaded at virtual address `0x00000000`
    - it must be placed somewhere else. Therefore, the assumption from the linker
    that the user mode process is loaded into memory at position `0x00000000` is wrong.
    This can be corrected by using a linker script which tells the linker to assume
    a different starting address, but that is a very cumbersome solution for the users
    of the operating system.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核被放置在虚拟地址空间的开始处——也就是说，虚拟地址空间（`0x00000000`，"内核大小"）映射到内存中内核的位置——在链接用户模式进程代码时将会有问题。通常，在链接过程中，链接器假设代码将被加载到内存位置`0x00000000`。因此，在解析绝对引用时，`0x00000000`将是计算确切位置的基址。但是，如果内核被映射到虚拟地址空间（`0x00000000`，"内核大小"），用户模式进程就不能加载到虚拟地址`0x00000000`——它必须放置在其他位置。因此，链接器关于用户模式进程在内存位置`0x00000000`加载的假设是错误的。这可以通过使用链接脚本来纠正，该脚本告诉链接器假设不同的起始地址，但这对于操作系统的用户来说是一个非常繁琐的解决方案。
- en: This also assumes that we want the kernel to be part of the user mode process’
    address space. As we will see later, this is a nice feature, since during system
    calls we don’t have to change any paging structures to get access to the kernel’s
    code and data. The kernel pages will of course require privilege level 0 for access,
    to prevent a user process from reading or writing kernel memory.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这也假设我们希望内核成为用户模式进程地址空间的一部分。正如我们稍后将会看到的，这是一个很好的特性，因为在系统调用期间，我们不需要更改任何分页结构就可以访问内核的代码和数据。内核页面当然需要特权级别0才能访问，以防止用户进程读取或写入内核内存。
- en: 9.3.2 The Virtual Address for the Kernel
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 内核的虚拟地址
- en: Preferably, the kernel should be placed at a very high virtual memory address,
    for example `0xC0000000` (3 GB). The user mode process is not likely to be 3 GB
    large, which is now the only way that it can conflict with the kernel. When the
    kernel uses virtual addresses at 3 GB and above it is called a *higher-half kernel*.
    `0xC0000000` is just an example, the kernel can be placed at any address higher
    than 0 to get the same benefits. Choosing the correct address depends on how much
    virtual memory should be available for the kernel (it is easiest if all memory
    above the kernel virtual address should belong to the kernel) and how much virtual
    memory should be available for the process.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将内核放置在一个非常高的虚拟内存地址，例如`0xC0000000`（3 GB）。用户模式进程不太可能达到3 GB的大小，这是现在唯一可能与其冲突的方式。当内核使用3
    GB以上的虚拟地址时，它被称为*上半部分内核*。`0xC0000000`只是一个例子，内核可以放置在任何高于0的地址以获得相同的好处。选择正确的地址取决于应该为内核提供多少虚拟内存（如果所有高于内核虚拟地址的内存都属于内核，那就最容易了）以及应该为进程提供多少虚拟内存。
- en: If the user mode process is larger than 3 GB, some pages will need to be swapped
    out by the kernel. Swapping pages is not part of this book.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户模式进程大于3 GB，内核将需要交换出一些页面。交换页面不是本书的内容。
- en: 9.3.3 Placing the Kernel at `0xC0000000`
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 将内核放置在`0xC0000000`
- en: To start with, it is better to place the kernel at `0xC0100000` than `0xC0000000`,
    since this makes it possible to map (`0x00000000`, `0x00100000`) to (`0xC0000000`,
    `0xC0100000`). This way, the entire range (`0x00000000`, `"size of kernel"`) of
    memory is mapped to the range (`0xC0000000`, `0xC0000000 + "size of kernel"`).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将内核放置在`0xC0100000`而不是`0xC0000000`会更好，因为这样可以使得`0x00000000`到`0x00100000`映射到`0xC0000000`到`0xC0100000`。这样，整个内存范围（`0x00000000`，"内核大小"）就被映射到了`0xC0000000`到`0xC0000000
    + "内核大小"`的范围。
- en: Placing the kernel at `0xC0100000` isn’t hard, but it does require some thought.
    This is once again a linking problem. When the linker resolves all absolute references
    in the kernel, it will assume that our kernel is loaded at physical memory location
    `0x00100000`, not `0x00000000`, since relocation is used in the linker script
    (see the section [“Linking the kernel”](#linking-the-kernel)). However, we want
    the jumps to be resolved using `0xC0100000` as base address, since otherwise a
    kernel jump will jump straight into the user mode process code (remember that
    the user mode process is loaded at virtual memory `0x00000000`).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 将内核放置在`0xC0100000`并不困难，但这确实需要一些思考。这又是一个链接问题。当链接器解析内核中的所有绝对引用时，它将假设我们的内核加载在物理内存位置`0x00100000`，而不是`0x00000000`，因为链接脚本中使用了重定位（参见[“链接内核”](#linking-the-kernel)部分）。然而，我们希望使用`0xC0100000`作为基址来解析跳转，因为否则内核跳转将直接跳入用户模式进程代码（记住用户模式进程是加载在虚拟内存`0x00000000`的）。
- en: However, we can’t simply tell the linker to assume that the kernel starts (is
    loaded) at `0xC01000000`, since we want it to be loaded at the physical address
    `0x00100000`. The reason for having the kernel loaded at 1 MB is because it can’t
    be loaded at `0x00000000`, since there is BIOS and GRUB code loaded below 1 MB.
    Furthermore, we cannot assume that we can load the kernel at `0xC0100000`, since
    the machine might not have 3 GB of physical memory.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能简单地告诉链接器假设内核从`0xC01000000`开始（加载），因为我们希望它在物理地址`0x00100000`加载。内核加载到1 MB的原因是因为它不能加载到`0x00000000`，因为BIOS和GRUB代码已经加载在1
    MB以下。此外，我们不能假设可以在`0xC0100000`加载内核，因为机器可能没有3 GB的物理内存。
- en: This can be solved by using both relocation (`.=0xC0100000`) and the `AT` instruction
    in the linker script. Relocation specifies that non-relative memory-references
    should should use the relocation address as base in address calculations. `AT`
    specifies where the kernel should be loaded into memory. Relocation is done at
    link time by GNU ld [37], the load address specified by `AT` is handled by GRUB
    when loading the kernel, and is part of the ELF format [18].
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在链接脚本中使用重定位(`.=0xC0100000`)和`AT`指令来解决。重定位指定非相对内存引用应使用重定位地址作为地址计算的基础。`AT`指定内核应加载到内存中的位置。重定位在链接时间由GNU
    ld [37]完成，由`AT`指定的加载地址由GRUB在加载内核时处理，并且是ELF格式 [18]的一部分。
- en: 9.3.4 Higher-half Linker Script
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4 高半部分链接脚本
- en: 'We can modify the [first linker script](#linking-the-kernel) to implement this:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改[第一个链接脚本](#linking-the-kernel)来实现这一点：
- en: '[PRE70]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 9.3.5 Entering the Higher Half
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5 进入高半部分
- en: When GRUB jumps to the kernel code, there is no paging table. Therefore, all
    references to `0xC0100000 + X` won’t be mapped to the correct physical address,
    and will therefore cause a general protection exception (GPE) at the very best,
    otherwise (if the computer has more than 3 GB of memory) the computer will just
    crash.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当GRUB跳转到内核代码时，没有页表。因此，所有对`0xC0100000 + X`的引用都不会映射到正确的物理地址，因此在最坏的情况下将导致一般保护异常（GPE），否则（如果计算机有超过3
    GB的内存），计算机将直接崩溃。
- en: 'Therefore, assembly code that doesn’t use relative jumps or relative memory
    addressing must be used to do the following:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，必须使用不使用相对跳转或相对内存寻址的汇编代码来完成以下操作：
- en: Set up a page table.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个页表。
- en: Add identity mapping for the first 4 MB of the virtual address space.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为虚拟地址空间的前4 MB添加标识映射。
- en: Add an entry for `0xC0100000` that maps to `0x0010000`
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`0xC0100000`添加一个映射到`0x0010000`的条目
- en: 'If we skip the identity mapping for the first 4 MB, the CPU would generate
    a page fault immediately after paging was enabled when trying to fetch the next
    instruction from memory. After the table has been created, an jump can be done
    to a label to make `eip` point to a virtual address in the higher half:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跳过前4 MB的标识映射，当启用分页并尝试从内存中获取下一条指令时，CPU会立即产生页面错误。在创建表之后，可以通过标签跳转到使`eip`指向高半部分虚拟地址的标签：
- en: '[PRE71]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The register `eip` will now point to a memory location somewhere right after
    `0xC0100000` - all the code can now execute as if it were located at `0xC0100000`,
    the higher-half. The entry mapping of the first 4 MB of virtual memory to the
    first 4 MB of physical memory can now be removed from the page table and its corresponding
    entry in the TLB invalidated with `invlpg [0]`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器`eip`现在将指向`0xC0100000`之后的某个内存位置 - 所有代码现在都可以像它位于`0xC0100000`一样执行，即高半部分。现在可以从页表中删除虚拟内存的前4
    MB到物理内存的前4 MB的映射条目，并使用`invlpg [0]`使TLB中相应的条目无效。
- en: 9.3.6 Running in the Higher Half
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.6 在高半部分运行
- en: There are a few more details we must deal with when using a higher-half kernel.
    We must be careful when using memory-mapped I/O that uses specific memory locations.
    For example, the frame buffer is located at `0x000B8000`, but since there is no
    entry in the page table for the address `0x000B8000` any longer, the address `0xC00B8000`
    must be used, since the virtual address `0xC0000000` maps to the physical address
    `0x00000000`.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用高端内核时，我们还需要处理一些细节。在使用特定内存位置的内存映射I/O时，我们必须小心。例如，帧缓冲区位于`0x000B8000`，但由于页表中不再有`0x000B8000`地址的条目，因此必须使用地址`0xC00B8000`，因为虚拟地址`0xC0000000`映射到物理地址`0x00000000`。
- en: Any explicit references to addresses within the multiboot structure needs to
    be changed to reflect the new virtual addresses as well.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在多引导结构中对地址的任何明确引用都需要更改以反映新的虚拟地址。
- en: Mapping 4 MB pages for the kernel is simple, but wastes memory (unless you have
    a really big kernel). Creating a higher-half kernel mapped in as 4 KB pages saves
    memory but is harder to set up. Memory for the page directory and one page table
    can be reserved in the `.data` section, but one needs to configure the mappings
    from virtual to physical addresses at run-time. The size of the kernel can be
    determined by exporting labels from the linker script [37], which we’ll need to
    do later anyway when writing the page frame allocator (see the chapter [“Page
    Frame Allocation](#page-frame-allocation)).
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 为内核映射4 MB页面很简单，但会浪费内存（除非你的内核真的很大）。将高端内核映射为4 KB页面可以节省内存，但设置起来更困难。可以在`.data`部分预留页面目录和一张页面表的空间，但需要在运行时配置从虚拟地址到物理地址的映射。内核的大小可以通过从链接器脚本中导出标签来确定[37]，我们稍后编写页面帧分配器时也需要这样做（参见章节[“页面帧分配](#page-frame-allocation)”）。
- en: 9.4 Virtual Memory Through Paging
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 通过分页实现虚拟内存
- en: Paging enables two things that are good for virtual memory. First, it allows
    for fine-grained access control to memory. You can mark pages as read-only, read-write,
    only for PL0 etc. Second, it creates the illusion of contiguous memory. User mode
    processes, and the kernel, can access memory as if it were contiguous, and the
    contiguous memory can be extended without the need to move data around in memory.
    We can also allow the user mode programs access to all memory below 3 GB, but
    unless they actually use it, we don’t have to assign page frames to the pages.
    This allows processes to have code located near `0x00000000` and the stack at
    just below `0xC0000000`, and still not require more than two actual pages.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 分页使得虚拟内存具有两个优点。首先，它允许对内存进行细粒度的访问控制。您可以标记页面为只读、读写、仅对PL0等。其次，它创造了连续内存的错觉。用户模式进程和内核可以像访问连续内存一样访问内存，并且连续内存可以扩展，而无需在内存中移动数据。我们还可以允许用户模式程序访问低于3
    GB的所有内存，但除非它们实际使用它，否则我们不需要为页面分配页面帧。这使得进程可以在`0x00000000`附近定位代码，并将堆栈放置在`0xC0000000`稍下方，而无需超过两个实际页面。
- en: 9.5 Further Reading
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 进一步阅读
- en: Chapter 4 (and to some extent chapter 3) of the Intel manual [33] are your definitive
    sources for the details about paging.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔手册的第4章（以及在一定程度上第3章）是关于分页详细信息的权威来源[33]。
- en: 'Wikipedia has an article on paging: [http://en.wikipedia.org/wiki/Paging](http://en.wikipedia.org/wiki/Paging)'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上有一篇关于分页的文章：[http://en.wikipedia.org/wiki/Paging](http://en.wikipedia.org/wiki/Paging)
- en: 'The OSDev wiki has a page on paging: [http://wiki.osdev.org/Paging](http://wiki.osdev.org/Paging)
    and a tutorial for making a higher-half kernel: [http://wiki.osdev.org/Higher_Half_bare_bones](http://wiki.osdev.org/Higher_Half_bare_bones)'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSDev wiki有一个关于分页的页面：[http://wiki.osdev.org/Paging](http://wiki.osdev.org/Paging)以及制作高端内核的教程：[http://wiki.osdev.org/Higher_Half_bare_bones](http://wiki.osdev.org/Higher_Half_bare_bones)
- en: 'Gustavo Duarte’s article on how a kernel manages memory is well worth a read:
    [http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory](http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory)'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gustavo Duarte关于内核如何管理内存的文章值得一读：[http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory](http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory)
- en: Details on the linker command language can be found at Steve Chamberlain’s website
    [37].
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于链接器命令语言的详细信息可以在Steve Chamberlain的网站上找到[37]。
- en: 'More details on the ELF format can be found in this presentation: [http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf](http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf)'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于ELF格式的详细信息可以在这次演示中找到：[http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf](http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf)
- en: 10 Page Frame Allocation
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 页面帧分配
- en: When using virtual memory, how does the OS know which parts of memory are free
    to use? That is the role of the page frame allocator.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用虚拟内存时，操作系统如何知道哪些内存部分是可用的？这就是页面帧分配器的角色。
- en: 10.1 Managing Available Memory
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 管理可用内存
- en: 10.1.1 How Much Memory is There?
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 有多少内存可用？
- en: 'First we need to know how much memory is available on the computer the OS is
    running on. The easiest way to do this is to read it from the multiboot structure
    [19] passed to us by GRUB. GRUB collects the information we need about the memory
    - what is reserved, I/O mapped, read-only etc. We must also make sure that we
    don’t mark the part of memory used by the kernel as free (since GRUB doesn’t mark
    this memory as reserved). One way to know how much memory the kernel uses is to
    export labels at the beginning and the end of the kernel binary from the linker
    script:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道操作系统运行的计算机上有多少可用内存。最简单的方法是从GRUB传递给我们的多引导结构[19]中读取它。GRUB收集我们需要的关于内存的信息——哪些被保留，哪些是I/O映射的，哪些是只读的等。我们还必须确保我们不标记内核使用的内存部分为空闲（因为GRUB没有将这部分内存标记为保留）。了解内核使用多少内存的一种方法是在链接脚本中从内核二进制文件的开始和结束处导出标签：
- en: '[PRE72]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'These labels can directly be read from assembly code and pushed on the stack
    to make them available to C code:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签可以直接从汇编代码中读取并推送到堆栈上，以便C代码可以使用：
- en: '[PRE73]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This way we get the labels as arguments to `kmain`. If you want to use C instead
    of assembly code, one way to do it is to declare the labels as functions and take
    the addresses of these functions:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以将标签作为`kmain`的参数。如果你想用C而不是汇编代码，一种方法是将标签声明为函数并获取这些函数的地址：
- en: '[PRE74]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you use GRUB modules you need to make sure the memory they use is marked
    as reserved as well.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用GRUB模块，你需要确保它们使用的内存也被标记为保留。
- en: Note that the available memory does not need to be contiguous. In the first
    1 MB there are several I/O-mapped memory sections, as well as memory used by GRUB
    and the BIOS. Other parts of the memory might be similarly unavailable.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可用的内存不需要是连续的。在最初的1 MB中，有几个I/O映射内存部分，以及GRUB和BIOS使用的内存。内存的其他部分可能同样不可用。
- en: It’s convenient to divide the memory sections into complete page frames, as
    we can’t map part of pages into memory.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存部分划分为完整的页面帧很方便，因为我们不能将页面的一部分映射到内存中。
- en: 10.1.2 Managing Available Memory
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 管理可用内存
- en: 'How do we know which page frames are in use? The page frame allocator needs
    to keep track of which are free and which aren’t. There are several ways to do
    this: bitmaps, linked lists, trees, the Buddy System (used by Linux) etc. For
    more information about the different algorithms see the article on OSDev [38].'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道哪些页面帧正在使用中？页面帧分配器需要跟踪哪些是空闲的，哪些不是。有几种方法可以做到这一点：位图、链表、树、伙伴系统（Linux使用）等。有关不同算法的更多信息，请参阅OSDev[38]上的文章。
- en: Bitmaps are quite easy to implement. One bit is used for each page frame and
    one (or more) page frames are dedicated to store the bitmap. (Note that this is
    just one way to do it, other designs might be better and/or more fun to implement.)
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 位图实现起来相当简单。每个页面帧使用一个位，一个（或多个）页面帧被专门用来存储位图。（注意，这只是其中一种方法，其他设计可能更好，或者更有趣来实现。）
- en: 10.2 How Can We Access a Page Frame?
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 我们如何访问页面帧？
- en: The page frame allocator returns the physical start address of the page frame.
    This page frame is not mapped in - no page table points to this page frame. How
    can we read and write data to the frame?
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 页面帧分配器返回页面帧的物理起始地址。这个页面帧没有被映射——没有页面表指向这个页面帧。我们如何读取和写入帧中的数据？
- en: We need to map the page frame into virtual memory, by updating the PDT and/or
    PT used by the kernel. What if all available page tables are full? Then we can’t
    map the page frame into memory, because we’d need a new page table - which takes
    up an entire page frame - and to write to this page frame we’d need to map its
    page frame… Somehow this circular dependency must be broken.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过更新内核使用的PDT和/或PT，将页面帧映射到虚拟内存中。如果所有可用的页面表都满了怎么办？那么我们就无法将页面帧映射到内存中，因为我们需要一个新页面表——它占用了整个页面帧——并且要写入这个页面帧，我们需要映射它的页面帧……这种循环依赖关系必须被打破。
- en: 'One solution is to reserve a part of the first page table used by the kernel
    (or some other higher-half page table) for temporarily mapping page frames to
    make them accessible. If the kernel is mapped at `0xC0000000` (page directory
    entry with index 768), and 4 KB page frames are used, then the kernel has at least
    one page table. If we assume - or limit us to - a kernel of size at most 4 MB
    minus 4 KB we can dedicate the last entry (entry 1023) of this page table for
    temporary mappings. The virtual address of pages mapped in using the last entry
    of the kernel’s PT will be:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是为内核（或某些其他上半部分页面表）使用的第一个页面表的一部分预留空间，以便临时映射页面帧使其可访问。如果内核映射在 `0xC0000000`（索引为768的页面目录条目），并且使用4
    KB页面帧，那么内核至少有一个页面表。如果我们假设（或限制为）内核大小最多为4 MB减去4 KB，我们可以将这个页面表的最后一个条目（条目1023）用于临时映射。使用内核PT的最后一个条目映射的页面虚拟地址将是：
- en: '[PRE75]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: After we’ve temporarily mapped the page frame we want to use as a page table,
    and set it up to map in our first page frame, we can add it to the paging directory,
    and remove the temporary mapping.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们临时映射我们想要用作页面表的页面帧，并将其设置为映射我们的第一个页面帧之后，我们可以将其添加到分页目录中，并移除临时映射。
- en: 10.3 A Kernel Heap
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 内核堆
- en: So far we’ve only been able to work with fixed-size data, or directly with raw
    memory. Now that we have a page frame allocator we can implement `malloc` and
    `free` to use in the kernel.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只能处理固定大小的数据，或者直接与原始内存打交道。现在我们有了页面帧分配器，我们可以实现 `malloc` 和 `free` 以在内核中使用。
- en: Kernighan and Ritchie [8] have an example implementation in their book [8] that
    we can draw inspiration from. The only modification we need to do is to replace
    calls to `sbrk`/`brk` with calls to the page frame allocator when more memory
    is needed. We must also make sure to map the page frames returned by the page
    frame allocator to virtual addresses. A correct implementation should also return
    page frames to the page frame allocator on call to `free`, whenever sufficiently
    large blocks of memory are freed.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: Kernighan和Ritchie [8] 在他们的书中 [8] 有一个示例实现，我们可以从中获得灵感。我们唯一需要做的修改是将对 `sbrk`/`brk`
    的调用替换为对页面帧分配器的调用，当需要更多内存时。我们还必须确保将页面帧分配器返回的页面帧映射到虚拟地址。正确的实现还应该在调用 `free` 时，每当释放足够大的内存块时，将页面帧返回给页面帧分配器。
- en: 10.4 Further reading
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 进一步阅读
- en: 'The OSDev wiki page on page frame allocation: [http://wiki.osdev.org/Page_Frame_Allocation](http://wiki.osdev.org/Page_Frame_Allocation)'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统开发wiki页面关于页面帧分配的页面：[http://wiki.osdev.org/Page_Frame_Allocation](http://wiki.osdev.org/Page_Frame_Allocation)
- en: 11 User Mode
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 用户模式
- en: User mode is now almost within our reach, there are just a few more steps required
    to get there. Although these steps might seem easy they way they are presented
    in this chapter, they can be tricky to implement, since there are a lot of places
    where small errors will cause bugs that are hard to find.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式现在几乎在我们触手可及，只需再走几步就可以到达那里。尽管这些步骤在本书的呈现方式下可能看起来很简单，但它们的实现可能会很棘手，因为有很多地方小错误会导致难以发现的bug。
- en: 11.1 Segments for User Mode
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 用户模式段
- en: 'To enable user mode we need to add two more segments to the GDT. They are very
    similar to the kernel segments we added when we [set up the GDT](#the-global-descriptor-table-gdt)
    in the [chapter about segmentation](#segmentation):'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用用户模式，我们需要向GDT中添加两个额外的段。它们与我们[在关于分段的章节中设置GDT](#the-global-descriptor-table-gdt)
    时添加的内核段非常相似：
- en: The segment descriptors needed for user mode.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式所需的段描述符。
- en: '| Index | Offset | Name | Address range | Type | DPL |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 偏移量 | 名称 | 地址范围 | 类型 | DPL |'
- en: '| --: | --: | :-- | :-- | :-- | :-- |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| --: | --: | :-- | :-- | :-- | :-- |'
- en: '| 3 | `0x18` | user code segment | `0x00000000 - 0xFFFFFFFF` | RX | PL3 |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `0x18` | 用户代码段 | `0x00000000 - 0xFFFFFFFF` | RX | PL3 |'
- en: '| 4 | `0x20` | user data segment | `0x00000000 - 0xFFFFFFFF` | RW | PL3 |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `0x20` | 用户数据段 | `0x00000000 - 0xFFFFFFFF` | RW | PL3 |'
- en: The difference is the DPL, which now allows code to execute in PL3\. The segments
    can still be used to address the entire address space, just using these segments
    for user mode code will not protect the kernel. For that we need paging.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于DPL，现在允许代码在PL3中执行。这些段仍然可以用来访问整个地址空间，只是使用这些段来执行用户模式代码不会保护内核。为此我们需要分页。
- en: 11.2 Setting Up For User Mode
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 为用户模式设置
- en: 'There are a few things every user mode process needs:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户模式进程都需要一些东西：
- en: Page frames for code, data and stack. At the moment it suffices to allocate
    one page frame for the stack and enough page frames to fit the program’s code.
    Don’t worry about setting up a stack that can be grow and shrink at this point
    in time, focus on getting a basic implementation work first.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码、数据和堆栈的页面帧。目前，只需为堆栈分配一个页面帧以及足够容纳程序代码的页面帧即可。在此阶段，不必担心设置可以增长和缩小的堆栈，首先关注实现基本功能。
- en: The binary from the GRUB module has to be copied to the page frames used for
    the programs code.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要将GRUB模块的二进制文件复制到用于程序代码的页面帧中。
- en: A page directory and page tables are needed to map the page frames described
    above into memory. At least two page tables are needed, because the code and data
    should be mapped in at `0x00000000` and increasing, and the stack should start
    just below the kernel, at `0xBFFFFFFB`, growing towards lower addresses. The U/S
    flag has to be set to allow PL3 access.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个页面目录和页面表来将上面描述的页面帧映射到内存中。至少需要两个页面表，因为代码和数据应该映射到`0x00000000`及以上的地址，而堆栈应该从内核下方开始，位于`0xBFFFFFFB`，向更低地址增长。必须设置U/S标志以允许PL3访问。
- en: It might be convenient to store this information in a `struct` representing
    a process. This process `struct` can be dynamically allocated with the kernel’s
    `malloc` function.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 将此信息存储在表示进程的`struct`中可能很方便。可以使用内核的`malloc`函数动态分配此进程`struct`。
- en: 11.3 Entering User Mode
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 进入用户模式
- en: The only way to execute code with a lower privilege level than the current privilege
    level (CPL) is to execute an `iret` or `lret` instruction - interrupt return or
    long return, respectively.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行低于当前特权级（CPL）的代码，唯一的方法是执行`iret`或`lret`指令——分别是中断返回或长返回。
- en: 'To enter user mode we set up the stack as if the processor had raised an inter-privilege
    level interrupt. The stack should look like the following:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入用户模式，我们需要设置堆栈，就像处理器已经引发了一个特权级中断一样。堆栈应该看起来像以下这样：
- en: '[PRE76]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: See the Intel manual [33], section 6.2.1, figure 6-4 for more information.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅英特尔手册[33]，第6.2.1节，图6-4。
- en: The instruction `iret` will then read these values from the stack and fill in
    the corresponding registers. Before we execute `iret` we need to change to the
    page directory we setup for the user mode process. It is important to remember
    that to continue executing kernel code after we’ve switched PDT, the kernel needs
    to be mapped in. One way to accomplish this is to have a separate PDT for the
    kernel, which maps all data at `0xC0000000` and above, and merge it with the user
    PDT (which only maps below `0xC0000000`) when performing the switch. Remember
    that physical address of the PDT has to be used when setting the register `cr3`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`iret`将随后从堆栈中读取这些值并填充相应的寄存器。在我们执行`iret`之前，我们需要切换到为用户模式进程设置的页面目录。重要的是要记住，在切换PDT之后继续执行内核代码，内核需要被映射。实现这一目标的一种方法是为内核设置一个单独的PDT，它将所有数据映射到`0xC0000000`及以上，并在切换时将其与用户PDT（仅映射到`0xC0000000`以下）合并。记住，设置寄存器`cr3`时必须使用PDT的物理地址。
- en: The register `eflags` contains a set of different flags, specified in section
    2.3 of the Intel manual [33]. Most important for us is the interrupt enable (IF)
    flag. The assembly code instruction `sti` can’t be used in privilege level 3 for
    enabling interrupts. If interrupts are disabled when entering user mode, then
    interrupts can’t enabled once user mode is entered. Setting the IF flag in the
    `eflags` entry on the stack will enable interrupts in user mode, since the assembly
    code instruction `iret` will set the register `eflags` to the corresponding value
    on the stack.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器`eflags`包含一组不同的标志，这些标志在英特尔手册的第2.3节中指定[33]。对我们来说最重要的是中断使能（IF）标志。在特权级3中不能使用汇编代码指令`sti`来启用中断。如果进入用户模式时中断被禁用，那么一旦进入用户模式，就无法启用中断。在堆栈上的`eflags`条目中设置IF标志将在用户模式下启用中断，因为汇编代码指令`iret`将寄存器`eflags`设置为堆栈上的相应值。
- en: For now, we should have interrupts disabled, as it requires a little more work
    to get inter-privilege level interrupts to work properly (see the section [“System
    calls”](#system-calls)).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应该禁用中断，因为要正确地使特权级中断工作需要做更多的工作（参见[“系统调用”](#system-calls)部分）。
- en: The value `eip` on the stack should point to the entry point for the user code
    - `0x00000000` in our case. The value `esp` on the stack should be where the stack
    starts - `0xBFFFFFFB` (`0xC0000000 - 4`).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈上的`eip`值应指向用户代码的入口点——在我们的例子中是`0x00000000`。堆栈上的`esp`值应该是堆栈的起始位置——`0xBFFFFFFB`（`0xC0000000
    - 4`）。
- en: 'The values `cs` and `ss` on the stack should be the segment selectors for the
    user code and user data segments, respectively. As we saw in the [segmentation
    chapter](#creating-and-loading-the-gdt), the lowest two bits of a segment selector
    is the RPL - the Requested Privilege Level. When using `iret` to enter PL3, the
    RPL of `cs` and `ss` should be `0x3`. The following code shows an example:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上的 `cs` 和 `ss` 的值应该是用户代码段和数据段的段选择符。正如我们在 [分段章节](#creating-and-loading-the-gdt)
    中看到的，段选择器的最低两位是 RPL - 请求的权限级别。当使用 `iret` 进入 PL3 时，`cs` 和 `ss` 的 RPL 应该是 `0x3`。以下代码展示了示例：
- en: '[PRE77]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The register `ds`, and the other data segment registers, should be set to the
    same segment selector as `ss`. They can be set the ordinary way, with the `mov`
    assembly code instruction.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 `ds` 以及其他数据段寄存器应该设置为与 `ss` 相同的段选择符。它们可以通过普通的 `mov` 汇编指令来设置。
- en: We are now ready to execute `iret`. If everything has been set up right, we
    should now have a kernel that can enter user mode.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备执行 `iret`。如果一切设置正确，我们现在应该有一个可以进入用户模式的内核。
- en: 11.4 Using C for User Mode Programs
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用 C 语言为用户模式程序
- en: When C is used as the programming language for user mode programs, it is important
    to think about the structure of the file that will be the result of the compilation.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 C 语言作为用户模式程序的编程语言时，考虑编译结果文件的结构是很重要的。
- en: The reason we can use ELF [18] as the file format for for the kernel executable
    is because GRUB knows how to parse and interpret the ELF file format. If we implemented
    an ELF parser, we could compile the user mode programs into ELF binaries as well.
    We leave this as an exercise for the reader.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 ELF [18] 作为内核可执行文件的文件格式的原因是 GRUB 知道如何解析和解释 ELF 文件格式。如果我们实现了 ELF 解析器，我们也可以将用户模式程序编译成
    ELF 可执行文件。我们将这个作为读者的练习。
- en: 'One thing we can do to make it easier to develop user mode programs is to allow
    the programs to be written in C, but compile them to flat binaries instead of
    ELF binaries. In C the layout of the generated code is more unpredictable and
    the entry point, `main`, might not be at offset 0 in the binary. One common way
    to work around this is to add a few assembly code lines placed at offset 0 which
    calls `main`:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些事情来简化用户模式程序的开发，那就是允许程序用 C 语言编写，但将它们编译成平面二进制文件而不是 ELF 二进制文件。在 C 语言中，生成的代码布局更不可预测，入口点
    `main` 可能不在二进制的偏移量为 0 的位置。一种常见的方法是在偏移量为 0 的位置添加几行汇编代码，调用 `main`：
- en: '[PRE78]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If this code is saved in a file called `start.s`, then the following code show
    an example of a linker script that places these instructions first in executable
    (remember that `start.s` gets compiled to `start.o`):'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码保存在名为 `start.s` 的文件中，那么下面的代码展示了链接脚本的一个示例，它将这些指令首先放置在可执行文件中（记住 `start.s`
    被编译成 `start.o`）：
- en: '[PRE79]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '*Note*: `*(.text)` will not include the `.text` section of `start.o` again.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意*：`*(.text)` 不会再次包含 `start.o` 的 `.text` 部分。'
- en: With this script we can write programs in C or assembler (or any other language
    that compiles to object files linkable with `ld`), and it is easy to load and
    map for the kernel (`.rodata` will be mapped in as writeable, though).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个脚本，我们可以用 C 或汇编（或任何编译成与 `ld` 链接的对象文件的任何其他语言）编写程序，并且对于内核来说，加载和映射都很简单（`.rodata`
    将被映射为可写）。
- en: 'When we compile user programs we want the following GCC flags:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译用户程序时，我们希望使用以下 GCC 标志：
- en: '[PRE80]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For linking, the followings flags should be used:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链接，应使用以下标志：
- en: '[PRE81]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The option `-T` instructs the linker to use the linker script `link.ld`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `-T` 指示链接器使用链接脚本 `link.ld`。
- en: 11.4.1 A C Library
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 C 语言库
- en: It might now be interesting to start thinking about writing a small “standard
    library” for your programs. Some of the functionality requires [system calls](#system-calls)
    to work, but some, such as the functions in `string.h`, does not.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能开始考虑为你的程序编写一个小型的“标准库”了。其中一些功能需要 [系统调用](#system-calls) 来工作，但一些，例如 `string.h`
    中的函数，则不需要。
- en: 11.5 Further Reading
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 进一步阅读
- en: 'Gustavo Duarte has an article on privilege levels: [http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection](http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection)'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gustavo Duarte 撰写了一篇关于权限级别的文章：[http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection](http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection)
- en: 12 File Systems
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 文件系统
- en: We are not required to have file systems in our operating system, but it is
    a very usable abstraction, and it often plays a central part of many operating
    systems, especially UNIX-like operating systems. Before we start the process of
    supporting multiple processes and system calls we might want to consider implementing
    a simple file system.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在我们的操作系统中拥有文件系统，但它是一个非常实用的抽象，它通常在许多操作系统中扮演着核心角色，尤其是在类UNIX操作系统中。在我们开始支持多个进程和系统调用的过程之前，我们可能想要考虑实现一个简单的文件系统。
- en: 12.1 Why a File System?
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 为什么需要文件系统？
- en: How do we specify what programs to run in our OS? Which is the first program
    to run? How do programs output data or read input?
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何指定在操作系统中运行哪些程序？哪个是第一个运行的程序？程序如何输出数据或读取输入？
- en: In UNIX-like systems, with their almost-everything-is-a-file convention, these
    problems are solved by the file system. (It might also be interesting to read
    a bit about the Plan 9 project, which takes this idea one step further.)
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在类UNIX系统中，由于几乎一切皆文件的传统，这些问题都由文件系统来解决。（也许阅读一些关于Plan 9项目的资料也会很有趣，该项目将这一想法推进了一步。）
- en: 12.2 A Simple Read-Only File System
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 一个简单的只读文件系统
- en: The simplest file system might be what we already have - one file, existing
    only in RAM, loaded by GRUB before the kernel starts. When the kernel and operating
    system grows this is probably too limiting.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的文件系统可能是我们已有的——一个仅存在于RAM中的文件，由GRUB在内核启动前加载。当内核和操作系统增长时，这可能过于限制。
- en: A file system that is slightly more advanced than just the bits of one file
    is a file with metadata. The metadata can describe the type of the file, the size
    of the file and so on. A utility program can be created that runs at build time,
    adding this metadata to a file. This way, a “file system in a file” can be constructed
    by concatenating several files with metadata into one large file. The result of
    this technique is a read-only file system that resides in memory (once GRUB has
    loaded the file).
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 比仅一个文件的位更高级的文件系统是具有元数据的文件。元数据可以描述文件的类型、文件大小等。可以创建一个实用程序，在构建时运行，将此元数据添加到文件中。这样，可以通过将具有元数据的几个文件连接成一个大型文件来构建“文件系统在文件中”。这种技术的结果是一个只读文件系统，它位于内存中（一旦GRUB加载了文件）。
- en: The program constructing the file system can traverse a directory on the host
    system and add all subdirectories and files as part of the target file system.
    Each object in the file system (directory or file) can consist of a header and
    a body, where the body of a file is the actual file and the body of a directory
    is a list of entries - names and “addresses” of other files and directories.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件系统的程序可以遍历宿主系统上的目录，并将所有子目录和文件作为目标文件系统的一部分添加。文件系统中的每个对象（目录或文件）可以由一个头和一个主体组成，其中文件的主体是实际的文件，目录的主体是条目列表——其他文件和目录的名称和“地址”。
- en: Each object in this file system will become contiguous, so they will be easy
    to read from memory for the kernel. All objects will also have a fixed size (except
    for the last one, which can grow), therefore it is difficult to add new files
    or modify existing ones.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件系统中的每个对象都将连续，因此对于内核来说，它们将很容易从内存中读取。所有对象都将具有固定的大小（除了最后一个，它可以增长），因此很难添加新文件或修改现有文件。
- en: 12.3 Inodes and Writable File Systems
  id: totrans-715
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 索引节点和可写文件系统
- en: When the need for a writable file system arises, then it is a good idea to look
    into the concept of an *inode*. See the section [“Further Reading”](#further-reading-6)
    for recommended reading.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要可写文件系统时，研究inode的概念是一个好主意。参见[“进一步阅读”](#further-reading-6)部分以获取推荐阅读材料。
- en: 12.4 A Virtual File System
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 虚拟文件系统
- en: What abstraction should be used for reading and writing to devices such as the
    screen and the keyboard?
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用什么抽象来读取和写入如屏幕和键盘这样的设备？
- en: A virtual file system (VFS) creates an abstraction on top of the concrete file
    systems. A VFS mainly supplies the path system and file hierarchy, it delegates
    operations on files to the underlying file systems. The original paper on VFS
    is succinct and well worth a read. See the section [“Further Reading”](#further-reading-6)
    for a reference.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟文件系统（VFS）在具体文件系统之上创建了一个抽象。VFS主要提供路径系统和文件层次结构，它将文件操作委托给底层文件系统。关于VFS的原始论文简明扼要，值得一读。参见[“进一步阅读”](#further-reading-6)部分以获取参考。
- en: With a VFS we could mount a special file system on the path `/dev`. This file
    system would handle all devices such as keyboards and the console. However, one
    could also take the traditional UNIX approach, with major/minor device numbers
    and `mknod` to create special files for devices. Which approach you think is the
    most appropriate is up to you, there is no right or wrong when building abstraction
    layers (although some abstractions turn out way more useful than others).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VFS，我们可以在路径`/dev`上挂载一个特殊文件系统。这个文件系统将处理所有设备，如键盘和控制台。然而，也可以采用传统的UNIX方法，使用主/次设备号和`mknod`来为设备创建特殊文件。你认为哪种方法最合适，这取决于你，在构建抽象层时没有对错之分（尽管有些抽象最终证明比其他的有用得多）。
- en: 12.5 Further Reading
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 进一步阅读
- en: 'The ideas behind the Plan 9 operating systems is worth taking a look at: [http://plan9.bell-labs.com/plan9/index.html](http://plan9.bell-labs.com/plan9/index.html)'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得一看的是Plan 9操作系统的理念：[http://plan9.bell-labs.com/plan9/index.html](http://plan9.bell-labs.com/plan9/index.html)
- en: 'Wikipedia’s page on inodes: [http://en.wikipedia.org/wiki/Inode](http://en.wikipedia.org/wiki/Inode)
    and the inode pointer structure: [http://en.wikipedia.org/wiki/Inode_pointer_structure](http://en.wikipedia.org/wiki/Inode_pointer_structure).'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia关于inode的页面：[http://en.wikipedia.org/wiki/Inode](http://en.wikipedia.org/wiki/Inode)
    以及inode指针结构：[http://en.wikipedia.org/wiki/Inode_pointer_structure](http://en.wikipedia.org/wiki/Inode_pointer_structure).
- en: 'The original paper on the concept of vnodes and a virtual file system is quite
    interesting: [http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf](http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf)'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于vnodes和虚拟文件系统概念的原始论文非常有趣：[http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf](http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf)
- en: Poul-Henning Kamp discusses the idea of a special file system for `/dev` in
    [http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html](http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html)
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Poul-Henning Kamp在[http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html](http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html)讨论了为`/dev`创建特殊文件系统的想法。
- en: 13 System Calls
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 系统调用
- en: '*System calls* is the way user-mode applications interact with the kernel -
    to ask for resources, request operations to be performed, etc. The system call
    API is the part of the kernel that is most exposed to the users, therefore its
    design requires some thought.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统调用*是用户模式应用程序与内核交互的方式——请求资源、请求执行操作等。系统调用API是内核中最面向用户的部分，因此其设计需要一些思考。'
- en: 13.1 Designing System Calls
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 设计系统调用
- en: It is up to us, the kernel developers, to design the system calls that application
    developers can use. We can draw inspiration from the POSIX standards or, if they
    seem like too much work, just look at the ones for Linux, and pick and choose.
    See the section [“Further Reading”](#further-reading-7) at the end of the chapter
    for references.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序开发者可以使用的系统调用是我们内核开发者的事情。我们可以从POSIX标准中汲取灵感，或者如果觉得工作量太大，也可以看看Linux的，然后挑选合适的。请参阅章节末尾的[“进一步阅读”](#further-reading-7)部分以获取参考资料。
- en: 13.2 Implementing System Calls
  id: totrans-730
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 实现系统调用
- en: System calls are traditionally invoked with software interrupts. The user applications
    put the appropriate values in registers or on the stack and then initiates a pre-defined
    interrupt which transfers execution to the kernel. The interrupt number used is
    dependent on the kernel, Linux uses the number `0x80` to identify that an interrupt
    is intended as a system call.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用传统上是通过软件中断来调用的。用户应用程序将适当的值放入寄存器或堆栈中，然后启动一个预定义的中断，将执行权转移到内核。所使用的中断号取决于内核，Linux使用数字`0x80`来标识中断是作为系统调用意图的。
- en: When system calls are executed, the current privilege level is typically changed
    from PL3 to PL0 (if the application is running in user mode). To allow this, the
    DPL of the entry in the IDT for the system call interrupt needs to allow PL3 access.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统调用执行时，当前权限级别通常从PL3变为PL0（如果应用程序在用户模式下运行）。为了允许这样做，系统调用中断在IDT中的条目的DPL需要允许PL3访问。
- en: Whenever inter-privilege level interrupts occur, the processor pushes a few
    important registers onto the stack - the same ones we used to enter user mode
    [before](#user-mode), see figure 6-4, section 6.12.1, in the Intel manual [33].
    What stack is used? The same section in [33] specifies that if an interrupt leads
    to code executing at a numerically lower privilege level, a stack switch occurs.
    The new values for the registers `ss` and `esp` is loaded from the current Task
    State Segment (TSS). The TSS structure is specified in figure 7-2, section 7.2.1
    of the Intel manual [33].
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生跨权限级别的中断时，处理器会将一些重要的寄存器推入堆栈 - 与我们之前进入用户模式时使用的相同的寄存器 [之前](#user-mode)，参见 Intel
    手册第 6-4 图，第 6.12.1 节 [33]。使用哪个堆栈？[33] 中的相同部分指定，如果中断导致以数值较低的权限级别执行代码，则发生堆栈切换。寄存器
    `ss` 和 `esp` 的新值从当前的任务状态段 (TSS) 加载。TSS 结构在 Intel 手册 [33] 的第 7-2 图，第 7.2.1 节中指定。
- en: To enable system calls we need to setup a TSS before entering user mode. Setting
    it up can be done in C by setting the `ss0` and `esp0` fields of a “packed struct”
    that represents a TSS. Before loading the “packed struct” into the processor,
    a TSS descriptor has to be added to the GDT. The structure of the TSS descriptor
    is described in section 7.2.2 in [33].
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用系统调用，我们需要在进入用户模式之前设置一个 TSS。可以通过在表示 TSS 的“打包结构”中设置 `ss0` 和 `esp0` 字段来完成设置。在将“打包结构”加载到处理器之前，必须将
    TSS 描述符添加到 GDT 中。TSS 描述符的结构在 [33] 的第 7.2.2 节中描述。
- en: You specify the current TSS segment selector by loading it into the `tr` register
    with the `ltr` assembly code instruction. If the TSS segment descriptor has index
    5, and thus offset `5 * 8 = 40 = 0x28`, this is the value that should be loaded
    into the register `tr`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过使用 `ltr` 汇编指令将当前 TSS 段选择器加载到 `tr` 寄存器中来指定当前的 TSS 段选择器。如果 TSS 段描述符的索引为 5，因此偏移量为
    `5 * 8 = 40 = 0x28`，则这是应该加载到寄存器 `tr` 中的值。
- en: When we entered user mode before in the chapter [“Entering User Mode”](#entering-user-mode)
    we disabled interrupts when executing in PL3\. Since system calls are implemented
    using interrupts, interrupts must be enabled in user mode. Setting the IF flag
    bit in the `eflags` value on the stack will make `iret` enable interrupts (since
    the `eflags` value on the stack will be loaded into the `eflags` register by the
    assembly code instruction `iret`).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章 [“进入用户模式”](#entering-user-mode) 中之前进入用户模式时，我们禁用了在 PL3 执行时的中断。由于系统调用是通过中断实现的，因此在用户模式中必须启用中断。通过在堆栈上的
    `eflags` 值中设置 IF 标志位，可以使 `iret` 启用中断（因为 `iret` 汇编指令会将堆栈上的 `eflags` 值加载到 `eflags`
    寄存器中）。
- en: 13.3 Further Reading
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 进一步阅读
- en: 'The Wikipedia page on POSIX, with links to the specifications: [http://en.wikipedia.org/wiki/POSIX](http://en.wikipedia.org/wiki/POSIX)'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 POSIX 的维基百科页面，包含对规范的链接：[http://en.wikipedia.org/wiki/POSIX](http://en.wikipedia.org/wiki/POSIX)
- en: 'A list of system calls used in Linux: [http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html](http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html)'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 中使用的系统调用列表：[http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html](http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html)
- en: 'The Wikipedia page on system calls: [http://en.wikipedia.org/wiki/System_call](http://en.wikipedia.org/wiki/System_call)'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于系统调用的维基百科页面：[http://en.wikipedia.org/wiki/System_call](http://en.wikipedia.org/wiki/System_call)
- en: The Intel manual [33] sections on interrupts (chapter 6) and TSS (chapter 7)
    are where you get all the details you need.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intel 手册 [33] 中关于中断（第 6 章）和 TSS（第 7 章）的部分是您获取所需所有细节的地方。
- en: 14 Multitasking
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 多任务处理
- en: 'How do you make multiple processes appear to run at the same time? Today, this
    question has two answers:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使多个进程看起来像是在同一时间运行？今天，这个问题有两个答案：
- en: With the availability of multi-core processors, or on system with multiple processors,
    two processes can actually run at the same time by running two processes on different
    cores or processors.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着多核处理器的可用性或系统中有多个处理器的情况下，两个进程实际上可以通过在不同的核心或处理器上运行两个进程来同时运行。
- en: Fake it. That is, switch rapidly (faster than a human can notice) between the
    processes. At any given moment there is only one process executing, but the rapid
    switching gives the impression that they are running “at the same time”.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欺骗它。也就是说，快速切换（比人类能察觉的更快）到不同的进程。在任何给定时刻只有一个进程正在执行，但快速的切换给人一种它们“同时”运行的印象。
- en: Since the operating system created in this book does not support multi-core
    processors or multiple processors the only option is to fake it. The part of the
    operating system responsible for rapidly switching between the processes is called
    the *scheduling algorithm*.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中创建的操作系统不支持多核处理器或多处理器，唯一的选择是模拟。负责在进程之间快速切换的操作系统部分被称为*调度算法*。
- en: 14.1 Creating New Processes
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 创建新进程
- en: 'Creating new processes is usually done with two different system calls: `fork`
    and `exec`. `fork` creates an exact copy of the currently running process, while
    `exec` replaces the current process with one that is specified by a path to the
    location of a program in the file system. Of these two we recommend that you start
    implementing `exec`, since this system call will do almost exactly the same steps
    as described in the section [“Setting up for user mode”](#setting-up-for-user-mode)
    in the chapter [“User Mode”](#user-mode).'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新进程通常使用两个不同的系统调用：`fork`和`exec`。`fork`创建当前运行进程的精确副本，而`exec`则用文件系统中程序位置的路径指定的进程替换当前进程。在这两个中，我们建议您首先实现`exec`，因为这个系统调用将几乎与第“用户模式”章中[“为用户模式设置”](#setting-up-for-user-mode)部分所描述的步骤完全相同。
- en: 14.2 Cooperative Scheduling with Yielding
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 带有yield的协作式调度
- en: The easiest way to achieve rapid switching between processes is if the processes
    themselves are responsible for the switching. The processes run for a while and
    then tell the OS (via a system call) that it can now switch to another process.
    Giving up the control of CPU to another process is called *yielding* and when
    the processes themselves are responsible for the scheduling it’s called *cooperative
    scheduling*, since all the processes must cooperate with each other.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 实现进程之间快速切换的最简单方法是让进程本身负责切换。进程运行一段时间后，通过系统调用通知操作系统（OS）现在可以切换到另一个进程。将CPU控制权交给另一个进程称为*yielding*，当进程本身负责调度时，称为*协作式调度*，因为所有进程必须相互协作。
- en: When a process yields the process’ entire state must be saved (all the registers),
    preferably on the kernel heap in a structure that represents a process. When changing
    to a new process all the registers must be restored from the saved values.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程yield时，必须保存进程的整个状态（所有寄存器），最好是在内核堆中，在一个表示进程的结构中。当切换到新进程时，必须从保存的值中恢复所有寄存器。
- en: Scheduling can be implemented by keeping a list of which processes are running.
    The system call `yield` should then run the next process in the list and put the
    current one last (other schemes are possible, but this is a simple one).
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 调度可以通过维护一个正在运行的进程列表来实现。然后，系统调用`yield`应该运行列表中的下一个进程，并将当前进程放在最后（其他方案也是可能的，但这是一个简单的方案）。
- en: The transfer of control to the new process is done via the `iret` assembly code
    instruction in exactly the same way as explained in the section [“Entering user
    mode”](#entering-user-mode) in the chapter [“User Mode”](#user-mode).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 控制权转移到新进程是通过`iret`汇编代码指令完成的，这与在第“用户模式”章中[“进入用户模式”](#entering-user-mode)部分所解释的完全相同。
- en: We **strongly** recommend that you start to implement support for multiple processes
    by implementing cooperative scheduling. We further recommend that you have a working
    solution for both `exec`, `fork` and `yield` before implementing preemptive scheduling.
    Since cooperative scheduling is deterministic, it is much easier to debug than
    preemptive scheduling.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**强烈**建议您通过实现协作式调度来开始实现多进程的支持。我们进一步建议在实现抢占式调度之前，您应该有一个针对`exec`、`fork`和`yield`的工作解决方案。由于协作式调度是确定性的，因此它比抢占式调度更容易调试。
- en: 14.3 Preemptive Scheduling with Interrupts
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 带中断的抢占式调度
- en: Instead of letting the processes themselves manage when to change to another
    process the OS can switch processes automatically after a short period of time.
    The OS can set up the *programmable interval timer* (PIT) to raise an interrupt
    after a short period of time, for example 20 ms. In the interrupt handler for
    the PIT interrupt the OS will change the running process to a new one. This way
    the processes themselves don’t need to worry about scheduling. This kind of scheduling
    is called *preemptive scheduling*.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让进程本身管理何时切换到另一个进程，操作系统可以在短时间内自动切换进程。操作系统可以设置*可编程间隔定时器*（PIT）在短时间内引发中断，例如20毫秒。在PIT中断的处理程序中，操作系统将切换运行进程到一个新的进程。这样，进程本身就不必担心调度。这种调度称为*抢占式调度*。
- en: 14.3.1 Programmable Interval Timer
  id: totrans-757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 可编程间隔定时器
- en: To be able to do preemptive scheduling the PIT must first be configured to raise
    interrupts every *x* milliseconds, where *x* should be configurable.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够进行抢占式调度，PIT 必须首先配置为每 *x* 毫秒引发中断，其中 *x* 应该是可配置的。
- en: 'The configuration of the PIT is very similar to the configuration of other
    hardware devices: a byte is sent to an I/O port. The command port of the PIT is
    `0x43`. To read about all the configuration options, see the article about the
    PIT on OSDev [39]. We use the following options:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: PIT 的配置与其他硬件设备的配置非常相似：向一个 I/O 端口发送一个字节。PIT 的命令端口是 `0x43`。要了解所有配置选项，请参阅 OSDev
    [39] 上的关于 PIT 的文章。我们使用以下选项：
- en: Raise interrupts (use channel 0)
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发中断（使用通道 0）
- en: Send the divider as low byte then high byte (see next section for an explanation)
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将除数作为低字节然后是高字节发送（下一节将进行解释）
- en: Use a square wave
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方波
- en: Use binary mode
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二进制模式
- en: This results in the configuration byte `00110110`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致配置字节 `00110110`。
- en: Setting the interval for how often interrupts are to be raised is done via a
    *divider*, the same way as for the serial port. Instead of sending the PIT a value
    (e.g. in milliseconds) that says how often an interrupt should be raised you send
    the divider. The PIT operates at 1193182 Hz as default. Sending the divider 10
    results in the PIT running at `1193182 / 10 = 119318` Hz. The divider can only
    be 16 bits, so it is only possible to configure the timer’s frequency between
    1193182 Hz and `1193182 / 65535 = 18.2` Hz. We recommend that you create a function
    that takes an interval in milliseconds and converts it to the correct divider.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 设置中断引发的频率间隔是通过 *除数* 来完成的，这与串行端口相同。你发送给 PIT 的不是表示中断应引发频率的值（例如，以毫秒为单位），而是发送除数。PIT
    默认以 1193182 Hz 运行。发送除数 10 使得 PIT 以 `1193182 / 10 = 119318` Hz 运行。除数只能是 16 位，因此只能配置定时器的频率在
    1193182 Hz 和 `1193182 / 65535 = 18.2` Hz 之间。我们建议你创建一个函数，该函数接受一个以毫秒为单位的间隔并将其转换为正确的除数。
- en: The divider is sent to the channel 0 data I/O port of the PIT, but since only
    one byte can be sent at at a time, the lowest 8 bits of the divider has to sent
    first, then the highest 8 bits of the divider can be sent. The channel 0 data
    I/O port is located at `0x40`. Again, see the article on OSDev [39] for more details.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 除数发送到 PIT 的通道 0 数据 I/O 端口，但由于一次只能发送一个字节，因此必须首先发送除数的最低 8 位，然后才能发送除数的高 8 位。通道
    0 数据 I/O 端口位于 `0x40`。同样，请参阅 OSDev [39] 上的文章以获取更多详细信息。
- en: 14.3.2 Separate Kernel Stacks for Processes
  id: totrans-767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 为进程使用单独的内核堆栈
- en: If all processes uses the same kernel stack (the stack exposed by the TSS) there
    will be trouble if a process is interrupted while still in kernel mode. The process
    that is being switched to will now use the same kernel stack and will overwrite
    what the previous process have written on the stack (remember that TSS data structure
    points to the *beginning* of the stack).
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有进程都使用相同的内核堆栈（TSS 暴露的堆栈），那么当进程在内核模式中断时将会有问题。现在被切换的进程将使用相同的内核堆栈，并将覆盖之前进程在堆栈上写入的内容（记住
    TSS 数据结构指向堆栈的 *开始*）。
- en: To solve this problem every process should have it’s own kernel stack, the same
    way that each process have their own user mode stack. When switching process the
    TSS must be updated to point to the new process’ kernel stack.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，每个进程都应该有自己的内核堆栈，就像每个进程都有自己的用户模式堆栈一样。在切换进程时，TSS 必须更新以指向新进程的内核堆栈。
- en: 14.3.3 Difficulties with Preemptive Scheduling
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 抢占式调度中的困难
- en: When using preemptive scheduling one problem arises that doesn’t exist with
    cooperative scheduling. With cooperative scheduling every time a process yields,
    it must be in user mode (privilege level 3), since yield is a system call. With
    preemptive scheduling, the processes can be interrupted in either user mode or
    kernel mode (privilege level 0), since the process itself does not control when
    it gets interrupted.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用抢占式调度时，会出现一个在协作式调度中不存在的难题。在协作式调度中，每次进程让出控制权时，它必须在用户模式（特权级别 3），因为让出是系统调用。在抢占式调度中，进程可以在用户模式或内核模式（特权级别
    0）中被中断，因为进程本身不控制何时被中断。
- en: Interrupting a process in kernel mode is a little bit different than interrupting
    a process in user mode, due to the way the CPU sets up the stack at interrupts.
    If a privilege level change occurred (the process was interrupted in user mode)
    the CPU will push the value of the process `ss` and `esp` register on the stack.
    If *no* privilege level change occurs (the process was interrupted in kernel mode)
    the CPU won’t push the `esp` register on the stack. Furthermore, if there was
    no privilege level change, the CPU won’t change stack to the one defined it the
    TSS.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核模式下中断一个进程与在用户模式下中断一个进程略有不同，这是因为CPU在中断时设置堆栈的方式。如果发生了特权级别变化（进程在用户模式下被中断），CPU会将进程的`ss`和`esp`寄存器的值推入堆栈。如果没有发生特权级别变化（进程在内核模式下被中断），CPU不会将`esp`寄存器的值推入堆栈。此外，如果没有特权级别变化，CPU不会将堆栈切换到TSS中定义的堆栈。
- en: This problem is solved by calculating what the value of `esp` was *before* the
    interrupt. Since you know that the CPU pushes 3 things on the stack when no privilege
    change happens and you know how much you have pushed on the stack, you can calculate
    what the value of `esp` was at the time of the interrupt. This is possible since
    the CPU won’t change stacks if there is no privilege level change, so the content
    of `esp` will be the same as at the time of the interrupt.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算中断前`esp`的值来解决这个问题。由于你知道在没有特权变化发生时CPU会在堆栈上推入3个东西，你也知道你在堆栈上推入了多少，你可以计算出中断时`esp`的值。这是可能的，因为如果没有特权级别变化，CPU不会更改堆栈，所以`esp`的内容将与中断时相同。
- en: To further complicate things, one must think of how to handle case when switching
    to a new process that should be running in kernel mode. Since `iret` is being
    used without a privilege level change the CPU won’t update the value of `esp`
    with the one placed on the stack - you must update `esp` yourself.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加复杂，必须考虑如何处理切换到应在内核模式下运行的新进程的情况。由于`iret`在没有特权级别变化的情况下使用，CPU不会更新堆栈上放置的`esp`值
    - 你必须自己更新`esp`。
- en: 14.4 Further Reading
  id: totrans-775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 进一步阅读
- en: For more information about different scheduling algorithms, see [http://wiki.osdev.org/Scheduling_Algorithms](http://wiki.osdev.org/Scheduling_Algorithms)
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于不同的调度算法的更多信息，请参阅[http://wiki.osdev.org/Scheduling_Algorithms](http://wiki.osdev.org/Scheduling_Algorithms)
- en: 14.4 References
  id: totrans-777
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.4 参考文献
- en: '[1] Andrew Tanenbaum, 2007\. *Modern operating systems, 3rd edition*. Prentice
    Hall, Inc.,'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] Andrew Tanenbaum，2007年。*现代操作系统，第3版*。Prentice Hall, Inc.，'
- en: '[2] *The royal institute of technology*, [http://www.kth.se](http://www.kth.se),'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] *皇家理工学院*，[http://www.kth.se](http://www.kth.se),'
- en: '[3] Wikipedia, *Hexadecimal*, [http://en.wikipedia.org/wiki/Hexadecimal](http://en.wikipedia.org/wiki/Hexadecimal),'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 维基百科，*十六进制*，[http://en.wikipedia.org/wiki/Hexadecimal](http://en.wikipedia.org/wiki/Hexadecimal),'
- en: '[4] OSDev, *OSDev*, [http://wiki.osdev.org/Main_Page](http://wiki.osdev.org/Main_Page),'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] OSDev，*OSDev*，[http://wiki.osdev.org/Main_Page](http://wiki.osdev.org/Main_Page),'
- en: '[5] James Molloy, *James m’s kernel development tutorial*, [http://www.jamesmolloy.co.uk/tutorial_html/](http://www.jamesmolloy.co.uk/tutorial_html/),'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] James Molloy，*James m的内核开发教程*，[http://www.jamesmolloy.co.uk/tutorial_html/](http://www.jamesmolloy.co.uk/tutorial_html/),'
- en: '[6] Canonical Ltd, *Ubuntu*, [http://www.ubuntu.com/](http://www.ubuntu.com/),'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] Canonical Ltd，*Ubuntu*，[http://www.ubuntu.com/](http://www.ubuntu.com/),'
- en: '[7] Oracle, *Oracle vM virtualBox*, [http://www.virtualbox.org/](http://www.virtualbox.org/),'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] Oracle，*Oracle vM virtualBox*，[http://www.virtualbox.org/](http://www.virtualbox.org/),'
- en: '[8] Dennis M. Ritchie Brian W. Kernighan, 1988\. *The c programming language,
    second edition*. Prentice Hall, Inc.,'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] Dennis M. Ritchie 和 Brian W. Kernighan，1988年。*C程序设计语言，第二版*。Prentice Hall,
    Inc.，'
- en: '[9] Wikipedia, *C (programming language)*, [http://en.wikipedia.org/wiki/C_(programming_language)](http://en.wikipedia.org/wiki/C_(programming_language)),'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] 维基百科，*C（编程语言）*，[http://en.wikipedia.org/wiki/C_(programming_language)](http://en.wikipedia.org/wiki/C_(programming_language)),'
- en: '[10] Free Software Foundation, *GCC, the gNU compiler collection*, [http://gcc.gnu.org/](http://gcc.gnu.org/),'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '[10] 自由软件基金会，*GCC，GNU编译器集合*，[http://gcc.gnu.org/](http://gcc.gnu.org/),'
- en: '[11] NASM, *NASM: The netwide assembler*, [http://www.nasm.us/](http://www.nasm.us/),'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '[11] NASM，*NASM：网络汇编器*，[http://www.nasm.us/](http://www.nasm.us/),'
- en: '[12] Wikipedia, *Bash*, [http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29](http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29),'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '[12] 维基百科，*Bash（Unix shell）*，[http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29](http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29),'
- en: '[13] Free Software Foundation, *GNU make*, [http://www.gnu.org/software/make/](http://www.gnu.org/software/make/),'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '[13] 自由软件基金会，*GNU make*，[http://www.gnu.org/software/make/](http://www.gnu.org/software/make/),'
- en: '[14] Volker Ruppert, *bochs: The open souce iA-32 emulation project*, [http://bochs.sourceforge.net/](http://bochs.sourceforge.net/),'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '[14] Volker Ruppert，*bochs：开源iA-32仿真项目*，[http://bochs.sourceforge.net/](http://bochs.sourceforge.net/),'
- en: '[15] QEMU, *QEMU*, [http://wiki.qemu.org/Main_Page](http://wiki.qemu.org/Main_Page),'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '[15] QEMU，*QEMU*，[http://wiki.qemu.org/Main_Page](http://wiki.qemu.org/Main_Page),'
- en: '[16] Wikipedia, *BIOS*, [https://en.wikipedia.org/wiki/BIOS](https://en.wikipedia.org/wiki/BIOS),'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '[16] 维基百科，*BIOS*，[https://en.wikipedia.org/wiki/BIOS](https://en.wikipedia.org/wiki/BIOS),'
- en: '[17] Free Software Foundation, *GNU gRUB*, [http://www.gnu.org/software/grub/](http://www.gnu.org/software/grub/),'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '[17] 自由软件基金会，*GNU gRUB*，[http://www.gnu.org/software/grub/](http://www.gnu.org/software/grub/),'
- en: '[18] Wikipedia, *Executable and linkable format*, [http://en.wikipedia.org/wiki/Executable_and_Linkable_Format](http://en.wikipedia.org/wiki/Executable_and_Linkable_Format),'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '[18] 维基百科，*可执行和链接格式*，[http://en.wikipedia.org/wiki/Executable_and_Linkable_Format](http://en.wikipedia.org/wiki/Executable_and_Linkable_Format),'
- en: '[19] Free Software Foundation, *Multiboot specification version 0.6.96*, [http://www.gnu.org/software/
    grub/manual/multiboot/multiboot.html](http://www.gnu.org/software/'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '[19] 自由软件基金会，*多引导规范版本 0.6.96*，[http://www.gnu.org/software/ grub/manual/multiboot/multiboot.html](http://www.gnu.org/software/'
- en: grub/manual/multiboot/multiboot.html),
  id: totrans-797
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: grub/manual/multiboot/multiboot.html),
- en: '[20] GNU, *GNU binutils*, [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/),'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '[20] GNU，*GNU binutils*，[http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/),'
- en: '[21] Lars Nodeen, *Bug #426419: configure: error: GRUB requires a working absolute
    objcopy*, [https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419](https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419),'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[21] Lars Nodeen，*错误编号#426419：configure：错误：GRUB需要一个工作的绝对objcopy*，[https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419](https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419),'
- en: '[22] Wikipedia, *ISO image*, [http://en.wikipedia.org/wiki/ISO_image](http://en.wikipedia.org/wiki/ISO_image),'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '[22] 维基百科，*ISO镜像*，[http://en.wikipedia.org/wiki/ISO_image](http://en.wikipedia.org/wiki/ISO_image),'
- en: '[23] Bochs, *bochsrc*, [http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html](http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html),'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '[23] Bochs，*bochsrc*，[http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html](http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html),'
- en: '[24] NASM, *RESB and friends: Declaring uninitialized data*, [http://www.nasm.us/doc/nasmdoc3.htm](http://www.nasm.us/doc/nasmdoc3.htm),'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '[24] NASM，*RESB及其相关：声明未初始化数据*，[http://www.nasm.us/doc/nasmdoc3.htm](http://www.nasm.us/doc/nasmdoc3.htm),'
- en: '[25] Wikipedia, *x86 calling conventions*, [http://en.wikipedia.org/wiki/X86_calling_conventions](http://en.wikipedia.org/wiki/X86_calling_conventions),'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '[25] 维基百科，*x86调用约定*，[http://en.wikipedia.org/wiki/X86_calling_conventions](http://en.wikipedia.org/wiki/X86_calling_conventions),'
- en: '[26] Wikipedia, *Framebuffer*, [http://en.wikipedia.org/wiki/Framebuffer](http://en.wikipedia.org/wiki/Framebuffer),'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '[26] 维基百科，*帧缓冲区*，[http://en.wikipedia.org/wiki/Framebuffer](http://en.wikipedia.org/wiki/Framebuffer),'
- en: '[27] Wikipedia, *VGA-compatible text mode*, [http://en.wikipedia.org/wiki/VGA-compatible_text_mode](http://en.wikipedia.org/wiki/VGA-compatible_text_mode),'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[27] 维基百科，*VGA兼容文本模式*，[http://en.wikipedia.org/wiki/VGA-compatible_text_mode](http://en.wikipedia.org/wiki/VGA-compatible_text_mode),'
- en: '[28] Wikipedia, *ASCII*, [https://en.wikipedia.org/wiki/Ascii](https://en.wikipedia.org/wiki/Ascii),'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '[28] 维基百科，*ASCII*，[https://en.wikipedia.org/wiki/Ascii](https://en.wikipedia.org/wiki/Ascii),'
- en: '[29] OSDev, *VGA hardware*, [http://wiki.osdev.org/VGA_Hardware](http://wiki.osdev.org/VGA_Hardware),'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '[29] OSDev，*VGA硬件*，[http://wiki.osdev.org/VGA_Hardware](http://wiki.osdev.org/VGA_Hardware),'
- en: '[30] Wikipedia, *Serial port*, [http://en.wikipedia.org/wiki/Serial_port](http://en.wikipedia.org/wiki/Serial_port),'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '[30] 维基百科，*串行端口*，[http://en.wikipedia.org/wiki/Serial_port](http://en.wikipedia.org/wiki/Serial_port),'
- en: '[31] OSDev, *Serial ports*, [http://wiki.osdev.org/Serial_ports](http://wiki.osdev.org/Serial_ports),'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '[31] OSDev，*串行端口*，[http://wiki.osdev.org/Serial_ports](http://wiki.osdev.org/Serial_ports),'
- en: '[32] WikiBooks, *Serial programming/8250 uART programming*, [http://en.wikibooks.org/wiki/Serial_Programming/
    8250_UART_Programming](http://en.wikibooks.org/wiki/Serial_Programming/'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '[32] WikiBooks，*串行编程/8250 uART编程*，[http://en.wikibooks.org/wiki/Serial_Programming/
    8250_UART_Programming](http://en.wikibooks.org/wiki/Serial_Programming/'
- en: 8250_UART_Programming),
  id: totrans-811
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8250_UART_Programming),
- en: '[33] Intel, *Intel 64 and iA-32 architectures software developer’s manual vol.
    3A*, [http://www.intel.com/content/ www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/](http://www.intel.com/content/'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '[33] 英特尔，*Intel 64和iA-32架构软件开发商手册第3A卷*，[http://www.intel.com/content/ www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/](http://www.intel.com/content/'
- en: www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/),
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html/),
- en: '[34] NASM, *Multi-line macros*, [http://www.nasm.us/doc/nasmdoc4.html#section-4.3](http://www.nasm.us/doc/nasmdoc4.html#section-4.3),'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '[34] NASM, *多行宏*, [http://www.nasm.us/doc/nasmdoc4.html#section-4.3](http://www.nasm.us/doc/nasmdoc4.html#section-4.3),'
- en: '[35] SIGOPS, *i386 interrupt handling*, [http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html](http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html),'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '[35] SIGOPS, *i386中断处理*, [http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html](http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html),'
- en: '[36] Andries Brouwer, *Keyboard scancodes*, [http://www.win.tue.nl/](http://www.win.tue.nl/),'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '[36] Andries Brouwer, *键盘扫描码*, [http://www.win.tue.nl/](http://www.win.tue.nl/),'
- en: '[37] Steve Chamberlain, *Using ld, the gNU linker*, [http://www.math.utah.edu/docs/info/ld_toc.html](http://www.math.utah.edu/docs/info/ld_toc.html),'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '[37] Steve Chamberlain, *使用ld，gNU链接器*, [http://www.math.utah.edu/docs/info/ld_toc.html](http://www.math.utah.edu/docs/info/ld_toc.html),'
- en: '[38] OSDev, *Page frame allocation*, [http://wiki.osdev.org/Page_Frame_Allocation](http://wiki.osdev.org/Page_Frame_Allocation),'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '[38] OSDev, *页面帧分配*, [http://wiki.osdev.org/Page_Frame_Allocation](http://wiki.osdev.org/Page_Frame_Allocation),'
- en: '[39] OSDev, *Programmable interval timer*, [http://wiki.osdev.org/Programmable_Interval_Timer](http://wiki.osdev.org/Programmable_Interval_Timer),'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '[39] OSDev, *可编程间隔定时器*, [http://wiki.osdev.org/Programmable_Interval_Timer](http://wiki.osdev.org/Programmable_Interval_Timer),'
- en: '* * *'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The bootloader must fit into the *master boot record* (MBR) boot sector of a
    hard drive, which is only 512 bytes large.[↩](#fnref1)
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导加载程序必须适应硬盘的 *主引导记录* (MBR) 启动扇区，该扇区大小仅为 512 字节。[↩](#fnref1)
