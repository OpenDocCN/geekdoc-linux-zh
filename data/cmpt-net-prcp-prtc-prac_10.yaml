- en: Routing in IP networks#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP网络中的路由#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/networks/routing.html](https://4ed.computer-networking.info/syllabus/default/networks/routing.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://4ed.computer-networking.info/syllabus/default/networks/routing.html](https://4ed.computer-networking.info/syllabus/default/networks/routing.html)
- en: In a large IP network such as the global Internet, routers need to exchange
    routing information. The Internet is an interconnection of networks, often called
    domains, that are under different responsibilities. As of 2025, the Internet is
    composed on more than 100,000 different domains and this number is still growing
    [[1]](#fas). A domain can be a small enterprise that manages a few routers in
    a single building, a larger enterprise with a hundred routers at multiple locations,
    or a large Internet Service Provider managing thousands of routers. Two classes
    of routing protocols are used to allow these domains to efficiently exchange routing
    information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在像全球互联网这样的大型IP网络中，路由器需要交换路由信息。互联网是由不同责任下的网络互联而成的，通常称为域。截至2025年，互联网由超过10万个不同的域组成，并且这个数字仍在增长[[1]](#fas)。一个域可以是一个管理单个建筑中几个路由器的小型企业，一个拥有多个地点的百台路由器的大型企业，或者管理数千台路由器的大型互联网服务提供商。使用两类路由协议来允许这些域有效地交换路由信息。
- en: '[![../_images/small-internet.png](../Images/1bcab7d617ca420273763701fade6b20.png)](../_images/small-internet.png)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/small-internet.png](../Images/1bcab7d617ca420273763701fade6b20.png)(../_images/small-internet.png)'
- en: Fig. 145 Organization of a small Internet[#](#id16 "Link to this image")
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图145 小型互联网的组织结构[#](#id16 "链接到这张图片")
- en: The first class of routing protocols are the intradomain routing protocols (sometimes
    also called the interior gateway protocols or [IGP](../glossary.html#term-IGP)).
    An intradomain routing protocol is used by all routers inside a domain to exchange
    routing information about the destinations that are reachable inside the domain.
    There are several intradomain routing protocols. Some domains use [RIP](../glossary.html#term-RIP),
    which is a distance vector protocol. Other domains use link-state routing protocols
    such as [OSPF](../glossary.html#term-OSPF) or [IS-IS](../glossary.html#term-IS-IS).
    Finally, some domains use static routing or proprietary protocols such as [IGRP](../glossary.html#term-IGRP)
    or [EIGRP](../glossary.html#term-EIGRP).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议的第一类是域内路由协议（有时也称为内部网关协议或[IGP](../glossary.html#term-IGP)）。域内路由协议被域内所有路由器用来交换关于域内可达目的地的路由信息。存在几种域内路由协议。一些域使用[RIP](../glossary.html#term-RIP)，这是一个距离矢量协议。其他域使用链路状态路由协议，如[OSPF](../glossary.html#term-OSPF)或[IS-IS](../glossary.html#term-IS-IS)。最后，一些域使用静态路由或专有协议，如[IGRP](../glossary.html#term-IGRP)或[EIGRP](../glossary.html#term-EIGRP)。
- en: These intradomain routing protocols usually have two objectives. First, they
    distribute routing information that corresponds to the shortest path between two
    routers in the domain. Second, they should allow the routers to quickly recover
    from link and router failures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些域内路由协议通常有两个目标。首先，它们分发与域内两个路由器之间最短路径相对应的路由信息。其次，它们应该允许路由器快速从链路和路由器故障中恢复。
- en: The second class of routing protocols are the interdomain routing protocols
    (sometimes also called the exterior gateway protocols or [EGP](../glossary.html#term-EGP)).
    The objective of an interdomain routing protocol is to distribute routing information
    between domains. For scalability reasons, an interdomain routing protocol must
    distribute aggregated routing information and considers each domain as a black
    box.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议的第二类是域间路由协议（有时也称为外部网关协议或[EGP](../glossary.html#term-EGP)）。域间路由协议的目标是在域之间分发路由信息。出于可扩展性的原因，域间路由协议必须分发聚合的路由信息，并将每个域视为一个黑盒。
- en: A very important difference between intradomain and interdomain routing are
    the routing policies that are used by each domain. Inside a single domain, all
    routers are considered equal, and when several routes are available to reach a
    given destination prefix, the best route is selected based on technical criteria
    such as the route with the shortest delay, the route with the minimum number of
    hops or the route with the highest bandwidth.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 域内路由和域间路由之间一个非常重要的区别是每个域使用的路由策略。在单个域内，所有路由器都被视为平等，当有多个路由可供到达给定的目标前缀时，最佳路由是根据技术标准选择的，例如具有最短延迟的路由、具有最少跳数的路由或具有最高带宽的路由。
- en: 'When we consider the interconnection of domains that are managed by different
    organizations, this is no longer true. Each domain implements its own routing
    policy. A routing policy is composed of three elements : an import filter that
    specifies which routes can be accepted by a domain, an export filter that specifies
    which routes can be advertised by a domain and a ranking algorithm that selects
    the best route when a domain knows several routes towards the same destination
    prefix. As we will see later, another important difference is that the objective
    of the interdomain routing protocol is to find the cheapest route towards each
    destination. There is only one interdomain routing protocol : [BGP](../glossary.html#term-BGP).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑由不同组织管理的域之间的互联时，这一点就不再成立。每个域都实施自己的路由策略。路由策略由三个元素组成：一个导入过滤器，指定哪些路由可以被域接受；一个导出过滤器，指定哪些路由可以被域通告；以及一个选择算法，当域知道通往同一目标前缀的多个路由时，选择最佳路由。正如我们稍后将会看到的，另一个重要的区别是，域间路由协议的目标是找到通往每个目标的最便宜路由。只有一个域间路由协议：[BGP](../glossary.html#term-BGP)。
- en: Intradomain routing[#](#intradomain-routing "Link to this heading")
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域内路由[#](#intradomain-routing "链接到本标题")
- en: 'In this section, we briefly describe the key features of the two main intradomain
    unicast routing protocols : RIP and OSPF. The basic principles of distance vector
    and link-state routing have been presented earlier.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要描述了两个主要域内单播路由协议（RIP和OSPF）的关键特性。距离矢量路由和链路状态路由的基本原理已在前面介绍。
- en: '### RIP[#](#rip "Link to this heading")'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '### RIP[#](#rip "链接到本标题")'
- en: The Routing Information Protocol (RIP) is the simplest routing protocol that
    was standardized for the TCP/IP protocol suite. RIP is defined in [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html).
    Additional information about RIP may be found in [[Malkin1999]](../bibliography.html#malkin1999).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 路由信息协议（RIP）是为TCP/IP协议族标准化的最简单的路由协议。RIP在[**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)中定义。有关RIP的更多信息，可以在[[Malkin1999]](../bibliography.html#malkin1999)中找到。
- en: RIP routers periodically exchange RIP messages. The format of these messages
    is shown below. A RIP message is sent inside a UDP segment whose destination port
    is set to 521. A RIP message contains several fields. The command field indicates
    whether the RIP message is a request or a response. When a router boots, its routing
    table is empty and it cannot forward any packet. To speedup the discovery of the
    network, it can send a request message to the RIP IPv6 multicast address, `FF02::9`.
    All RIP routers listen to this multicast address and any router attached to the
    subnet will reply by sending its own routing table as a sequence of RIP messages.
    In steady state, routers multicast one of more RIP response messages every 30
    seconds. These messages contain the distance vectors that summarize the router’s
    routing table. The current version of RIP is version 2 defined in [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)
    for IPv4 and [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    for IPv6.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RIP路由器定期交换RIP消息。以下显示了这些消息的格式。RIP消息被发送在UDP段中，其目标端口设置为521。RIP消息包含几个字段。命令字段指示RIP消息是请求还是响应。当路由器启动时，其路由表为空，无法转发任何数据包。为了加快网络发现的进程，它可以向RIP
    IPv6多播地址`FF02::9`发送请求消息。所有RIP路由器都会监听这个多播地址，任何连接到子网的路由器都会通过发送自己的路由表作为一系列RIP消息来回复。在稳定状态下，路由器每30秒多播一个或多个RIP响应消息。这些消息包含总结路由器路由表的距离矢量。RIP的当前版本是版本2，定义在[**RFC
    2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)中，用于IPv4，以及[**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)中，用于IPv6。
- en: '[![../_images/ripng.svg](../Images/6db6a4a10d1008fa61d614059970a21a.png)](../_images/ripng.svg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ripng.svg](../Images/6db6a4a10d1008fa61d614059970a21a.png)'
- en: Fig. 146 The RIP message format[#](#id17 "Link to this image")
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图. 146 RIP消息格式[#](#id17 "链接到本图像")
- en: Each RIP message contains a set of route entries. Each route entry is encoded
    as a 20 bytes field whose format is shown below. RIP was initially designed to
    be suitable for different network layer protocols. Some implementations of RIP
    were used in XNS or IPX networks [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html).
    The format of the route entries used by [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    is shown below. Prefix length is the length of the subnet identifier in bits and
    the metric is encoded as one byte. The maximum metric supported by RIP is 15.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个RIP消息包含一组路由条目。每个路由条目编码为一个20字节的字段，其格式如下所示。RIP最初被设计为适用于不同的网络层协议。一些RIP的实现被用于XNS或IPX网络[**RFC
    2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)。[**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)所使用的路由条目格式如下所示。前缀长度是子网标识符的位数，度量值编码为一个字节。RIP支持的最大度量值为15。
- en: '[![../_images/rip-route-entry-v6.svg](../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png)](../_images/rip-route-entry-v6.svg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/rip-route-entry-v6.svg](../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png)](../_images/rip-route-entry-v6.svg)'
- en: Fig. 147 Format of the RIP IPv6 route entries[#](#id18 "Link to this image")
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图147 RIP IPv6路由条目格式[#](#id18 "链接到这个图像")
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: A note on timers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计时器的一个备注
- en: 'The first RIP implementations sent their distance vector exactly every 30 seconds.
    This worked well in most networks, but some researchers noticed that routers were
    sometimes overloaded because they were processing too many distance vectors at
    the same time [[FJ1994]](../bibliography.html#fj1994). They collected packet traces
    in these networks and found that after some time the routers’ timers became synchronized,
    i.e. almost all routers were sending their distance vectors at almost the same
    time. This synchronization of the transmission times of the distance vectors caused
    an overload on the routers’ CPU but also increased the convergence time of the
    protocol in some cases. This was mainly due to the fact that all routers set their
    timers to the same expiration time after having processed the received distance
    vectors. [Sally Floyd](https://www.icir.org/floyd/) and [Van Jacobson](https://en.wikipedia.org/wiki/Van_Jacobson)
    proposed in [[FJ1994]](../bibliography.html#fj1994) a simple solution to solve
    this synchronization problem. Instead of advertising their distance vector exactly
    after 30 seconds, a router should send its next distance vector after a delay
    chosen randomly in the [15,45] interval [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html).
    This randomization of the delays prevents the synchronization that occurs with
    a fixed delay and is now a recommended practice for protocol designers.  ### OSPF[#](#ospf
    "Link to this heading")'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的RIP实现每30秒发送一次它们的距离向量。这在大多数网络中都工作得很好，但一些研究人员注意到，由于同时处理过多的距离向量，路由器有时会过载[[FJ1994]](../bibliography.html#fj1994)。他们在这些网络中收集了数据包跟踪，并发现经过一段时间后，路由器的计时器变得同步，即几乎所有路由器都在几乎相同的时间发送它们的距离向量。这种距离向量传输时间的同步导致路由器CPU过载，在某些情况下也增加了协议的收敛时间。这主要是因为所有路由器在处理接收到的距离向量后都将它们的计时器设置为相同的过期时间。[Sally
    Floyd](https://www.icir.org/floyd/)和[Van Jacobson](https://en.wikipedia.org/wiki/Van_Jacobson)在[[FJ1994]](../bibliography.html#fj1994)中提出了一种简单的解决方案来解决这个同步问题。路由器不应该在30秒后精确地广告它们的距离向量，而应该在[15,45]区间内随机选择延迟后发送下一个距离向量[**RFC
    2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)。这种延迟的随机化防止了与固定延迟发生的同步，并且现在已成为协议设计者的推荐做法。###
    OSPF[#](#ospf "链接到这个标题")
- en: Link-state routing protocols are used in IP networks. Open Shortest Path First
    (OSPF), defined in [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html),
    is the link state routing protocol that has been standardized by the IETF. The
    last version of OSPF, which supports IPv6, is defined in [**RFC 5340**](https://datatracker.ietf.org/doc/html/rfc5340.html).
    OSPF is frequently used in enterprise networks and in some ISP networks. However,
    ISP networks often use the IS-IS link-state routing protocol [[ISO10589]](../bibliography.html#iso10589)
    , which was developed for the ISO CLNP protocol but was adapted to be used in
    IP [**RFC 1195**](https://datatracker.ietf.org/doc/html/rfc1195.html) networks
    before the finalization of the standardization of OSPF. A detailed analysis of
    ISIS and OSPF may be found in [[BMO2006]](../bibliography.html#bmo2006) and [[Perlman2000]](../bibliography.html#perlman2000).
    Additional information about OSPF may be found in [[Moy1998]](../bibliography.html#moy1998).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态路由协议用于IP网络。定义在[**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)中的开放最短路径优先（OSPF）是IETF标准化的链路状态路由协议。支持IPv6的OSPF的最新版本定义在[**RFC
    5340**](https://datatracker.ietf.org/doc/html/rfc5340.html)中。OSPF常用于企业网络和一些ISP网络。然而，ISP网络通常使用IS-IS链路状态路由协议
    [[ISO10589]](../bibliography.html#iso10589)，该协议是为ISO CLNP协议开发的，但在OSPF标准化最终确定之前，已被修改以用于IP
    [**RFC 1195**](https://datatracker.ietf.org/doc/html/rfc1195.html) 网络。ISIS和OSPF的详细分析可以在[[BMO2006]](../bibliography.html#bmo2006)和[[Perlman2000]](../bibliography.html#perlman2000)中找到。有关OSPF的更多信息，可以在[[Moy1998]](../bibliography.html#moy1998)中找到。
- en: Compared to the basics of link-state routing protocols that we discussed in
    section [Link state routing](network.html#linkstate), there are some particularities
    of OSPF that are worth discussing. First, in a large network, flooding the information
    about all routers and links to thousands of routers or more may be costly as each
    router needs to store all the information about the entire network. A better approach
    would be to introduce hierarchical routing. Hierarchical routing divides the network
    into regions. All the routers inside a region have detailed information about
    the topology of the region but only learn aggregated information about the topology
    of the other regions and their interconnections. OSPF supports a restricted variant
    of hierarchical routing. In OSPF’s terminology, a region is called an area.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[链路状态路由](network.html#linkstate)部分讨论的链路状态路由协议的基本原理相比，OSPF有一些值得讨论的特殊性。首先，在一个大型网络中，将所有路由器和链路的信息洪泛到数千个或更多的路由器可能会很昂贵，因为每个路由器都需要存储整个网络的所有信息。一个更好的方法是将网络划分为区域进行分层路由。分层路由将网络划分为区域。一个区域内的所有路由器都了解该区域的拓扑结构，但只学习其他区域拓扑结构和它们之间互连的汇总信息。OSPF支持分层路由的受限变体。在OSPF术语中，一个区域被称为区域。
- en: 'OSPF imposes restrictions on how a network can be divided into areas. An area
    is a set of routers and links that are grouped together. Usually, the topology
    of an area is chosen so that a packet sent by one router inside the area can reach
    any other router in the area without leaving the area [[2]](#fvirtual) . An OSPF
    area contains two types of routers [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF对网络如何划分为区域施加了限制。一个区域是一组被分组在一起的路由器和链路。通常，一个区域的拓扑结构被选择，以便区域内一个路由器发送的数据包可以在不离开区域的情况下到达该区域内的任何其他路由器
    [[2]](#fvirtual) 。OSPF区域包含两种类型的路由器 [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)：
- en: 'Internal router : A router whose directly connected networks belong to the
    area'
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部路由器：其直接连接的网络属于该区域的路由器。
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Area border routers : A router that is attached to several areas.'
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域边界路由器：连接到多个区域的路由器。
- en: 'For example, the network shown in figure [Fig. 148](#fig-ospf-areas) has been
    divided into three areas : area 0, containing routers RA, RB, RC and RD, area
    1, containing routers R1, R3, R4, R5 and RA, and area 2 containing R7, R8, R9,
    R10, RB and RC. OSPF areas are identified by a 32 bit integer, which is sometimes
    represented as an IP address. Among the OSPF areas, area 0, also called the backbone
    area, has a special role. The backbone area groups all the area border routers
    (routers RA, RB and RC in the figure below) and the routers that are directly
    connected to the backbone routers but do not belong to another area (router RD
    in the figure below). An important restriction imposed by OSPF is that the path
    between two routers that belong to two different areas (e.g. R1 and R8 in the
    figure below) must pass through the backbone area.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图 [图 148](#fig-ospf-areas) 中所示的网络已被划分为三个区域：区域 0，包含路由器 RA、RB、RC 和 RD；区域 1，包含路由器
    R1、R3、R4、R5 和 RA；以及区域 2，包含 R7、R8、R9、R10、RB 和 RC。OSPF 区域通过一个 32 位整数来识别，有时也用 IP
    地址来表示。在 OSPF 区域中，区域 0，也称为骨干区域，具有特殊的作用。骨干区域将所有区域边界路由器（如图下所示的 RA、RB 和 RC 路由器）以及直接连接到骨干路由器但不属于另一个区域的路由器（如图下所示的
    RD 路由器）组合在一起。OSPF 施加的一个重要限制是，属于两个不同区域的两台路由器之间的路径（例如图下所示的 R1 和 R8）必须通过骨干区域。
- en: '[![../_images/ospf-areas.png](../Images/ecfc93d799f6e5b0786b740a7776fc54.png)](../_images/ospf-areas.png)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ospf-areas.png](../Images/ecfc93d799f6e5b0786b740a7776fc54.png)(../_images/ospf-areas.png)'
- en: Fig. 148 OSPF areas[#](#id19 "Link to this image")
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 148 OSPF 区域[#](#id19 "链接到这张图片")
- en: Inside each non-backbone area, routers distribute the topology of the area by
    exchanging link state packets with the other routers in the area. The internal
    routers do not know the topology of other areas, but each router knows how to
    reach the backbone area. Inside an area, the routers only exchange link-state
    packets for all destinations that are reachable inside the area. In OSPF, the
    inter-area routing is done by exchanging distance vectors. This is illustrated
    by the network topology shown in figure [Fig. 149](#fig-net-ospf-areas).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个非骨干区域内部，路由器通过与其他区域内的路由器交换链路状态包来分发该区域的拓扑结构。内部路由器不知道其他区域的拓扑结构，但每个路由器都知道如何到达骨干区域。在一个区域内部，路由器只交换链路状态包，以到达该区域内所有可达的目的地。在
    OSPF 中，通过交换距离向量来实现跨区域路由。这由图 [图 149](#fig-net-ospf-areas) 所示的网络拓扑结构进行了说明。
- en: '[![../_images/ospf-area.png](../Images/e2e208cffe57552ed18b52f85b1655ab.png)](../_images/ospf-area.png)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ospf-area.png](../Images/e2e208cffe57552ed18b52f85b1655ab.png)(../_images/ospf-area.png)'
- en: Fig. 149 Hierarchical routing with OSPF[#](#id20 "Link to this image")
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 149 OSPF 的分层路由[#](#id20 "链接到这张图片")
- en: 'Let us first consider OSPF routing inside area 2. All routers in the area learn
    a route towards 2001:db8:1234::/48 and 2001:db8:5678::/48. The two area border
    routers, RB and RC, create network summary advertisements. Assuming that all links
    have a unit link metric, these would be:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑区域 2 内部的 OSPF 路由。该区域内的所有路由器都学习到通往 2001:db8:1234::/48 和 2001:db8:5678::/48
    的路由。两个区域边界路由器 RB 和 RC 创建网络汇总广告。假设所有链路都具有单位链路度量，这些汇总广告将是：
- en: RB advertises 2001:db8:1234::/48 at a distance of 2 and 2001:db8:5678::/48 at
    a distance of 3
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 发布 2001:db8:1234::/48 的距离为 2，2001:db8:5678::/48 的距离为 3
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RC advertises 2001:db8:5678::/48 at a distance of 2 and 2001:db8:1234::/48 at
    a distance of 3
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC 发布 2001:db8:5678::/48 的距离为 2，2001:db8:1234::/48 的距离为 3
- en: These summary advertisements are flooded through the backbone area attached
    to routers RB and RC. In its routing table, router RA selects the summary advertised
    by RB to reach 2001:db8:1234::/48 and the summary advertised by RC to reach 2001:db8:5678::/48.
    Inside area 1, router RA advertises a summary indicating that 2001:db8:1234::/48
    and 2001:db8:5678::/48 are both at a distance of 3 from itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些汇总广告通过连接到 RB 和 RC 路由器的骨干区域进行洪泛。在 RA 路由器的路由表中，RA 选择 RB 发布的汇总信息以到达 2001:db8:1234::/48，以及
    RC 发布的汇总信息以到达 2001:db8:5678::/48。在区域 1 内部，RA 发布一个汇总信息，表明 2001:db8:1234::/48 和
    2001:db8:5678::/48 都距离自身 3 距离。
- en: 'On the other hand, consider the prefixes 2001:db8:aaaa:0000::/64 and 2001:db8:aaaa:0001::/64
    that are inside area 1. Router RA is the only area border router that is attached
    to this area. This router can create two different network summary advertisements
    :'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，考虑位于区域 1 内部的前缀 2001:db8:aaaa:0000::/64 和 2001:db8:aaaa:0001::/64。RA 是唯一连接到该区域的区域边界路由器。该路由器可以创建两个不同的网络汇总广告：
- en: 2001:db8:aaaa:0001::/64 at a distance of 1 and 2001:db8:aaaa:0000::/64 at a
    distance of 2 from RA
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001:db8:aaaa:0001::/64 距离 RA 为 1，2001:db8:aaaa:0000::/64 距离 RA 为 2
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 2001:db8:aaaa:0000::/63 at a distance of 2 from RA
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001:db8:aaaa:0000::/63 在距离 RA 2 的位置
- en: The first summary advertisement provides precise information about the distance
    used to reach each prefix. However, all routers in the network have to maintain
    a route towards 2001:db8:aaaa:0000::/64 and a route towards 2001:db8:aaaa:0001::/64
    that are both via router RA. The second advertisement would improve the scalability
    of OSPF by reducing the number of routes that are advertised across area boundaries.
    However, in practice this requires manual configuration on the border routers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个摘要通告提供了关于到达每个前缀所使用的距离的精确信息。然而，网络中的所有路由器都必须维护一个指向 2001:db8:aaaa:0000::/64
    和一个指向 2001:db8:aaaa:0001::/64 的路由，这两个路由都通过路由器 RA。第二个通告将通过减少跨越区域边界的通告路由数量来提高 OSPF
    的可扩展性。然而，在实践中这需要在边界路由器上进行手动配置。
- en: The second OSPF particularity that is worth discussing is the support of Local
    Area Networks (LAN). As shown in figure [Fig. 150](#fig-ospf-lan), several routers
    may be attached to the same LAN.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得讨论的第二个 OSPF 特殊性是支持本地局域网 (LAN)。如图 [图 150](#fig-ospf-lan) 所示，多个路由器可能连接到同一个局域网。
- en: '![Figure made with TikZ](../Images/b61c40a915c22075c5f71b026344c0d8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/b61c40a915c22075c5f71b026344c0d8.png)'
- en: Fig. 150 A LAN with routers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 150 带有路由器的局域网
- en: 'A first solution to support such a LAN with a link-state routing protocol would
    be to consider that a LAN is equivalent to a full-mesh of point-to-point links
    as if each router can directly reach any other router on the LAN. However, this
    approach has two important drawbacks :'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此类局域网并使用链路状态路由协议的第一个解决方案是考虑局域网等同于一个全连接的点对点链路网，就像每个路由器可以直接到达局域网上的任何其他路由器一样。然而，这种方法有两个重要的缺点：
- en: Each router must exchange HELLOs and link state packets with all the other routers
    on the LAN. This increases the number of OSPF packets that are sent and processed
    by each router.
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个路由器必须与局域网上的所有其他路由器交换 HELLO 和链路状态数据包。这增加了每个路由器发送和处理的 OSPF 数据包数量。
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Remote routers, when looking at the topology distributed by OSPF, consider that
    there is a full-mesh of links between all the LAN routers. Such a full-mesh implies
    a lot of redundancy in case of failure, while in practice the entire LAN may completely
    fail. In case of a failure of the entire LAN, all routers need to detect the failures
    and flood link state packets before the LAN is completely removed from the OSPF
    topology by remote routers.
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程路由器在查看 OSPF 分发的拓扑时，认为所有局域网路由器之间存在全连接的链路。这种全连接意味着在故障情况下存在大量的冗余，而在实际中整个局域网可能会完全失效。在局域网完全从远程路由器的
    OSPF 拓扑中移除之前，所有路由器都需要检测故障并向其他路由器洪泛链路状态数据包。
- en: To better represent LANs and reduce the number of OSPF packets that are exchanged,
    OSPF handles LAN differently. When OSPF routers boot on a LAN, they elect [[3]](#felection)
    one of them as the Designated Router (DR) [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html).
    The DR router represents the local area network, and advertises the LAN’s subnet.
    Furthermore, LAN routers only exchange HELLO packets with the DR. Thanks to the
    utilization of a DR, the topology of the LAN appears as a set of point-to-point
    links connected to the DR router.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地表示局域网并减少交换的 OSPF 数据包数量，OSPF 对局域网的处理方式不同。当 OSPF 路由器在局域网启动时，它们会选举 [[3]](#felection)
    其中一个作为指定路由器 (DR) [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)。DR
    路由器代表本地局域网，并通告局域网的子网。此外，局域网路由器只与 DR 交换 HELLO 数据包。得益于 DR 的使用，局域网的拓扑结构看起来像是一组连接到
    DR 路由器的点对点链路。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: How to quickly detect a link failure ?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如何快速检测链路故障？
- en: 'Network operators expect an OSPF network to be able to quickly recover from
    link or router failures [[VPD2004]](../bibliography.html#vpd2004). In an OSPF
    network, the recovery after a failure is performed in three steps [[FFEB2005]](../bibliography.html#ffeb2005)
    :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 网络运营商期望 OSPF 网络能够快速从链路或路由器故障中恢复 [[VPD2004]](../bibliography.html#vpd2004)。在
    OSPF 网络中，故障后的恢复分为三个步骤 [[FFEB2005]](../bibliography.html#ffeb2005)：
- en: the routers that are adjacent to the failure detect it quickly. The default
    solution is to rely on the regular exchange of HELLO packets. However, the interval
    between successive HELLOs is often set to 10 seconds… Setting the HELLO timer
    down to a few milliseconds is difficult as HELLO packets are created and processed
    by the main CPU of the routers and these routers cannot easily generate and process
    a HELLO packet every millisecond on each of their interfaces. A better solution
    is to use a dedicated failure detection protocol such as the Bidirectional Forwarding
    Detection (BFD) protocol defined in [[KW2009]](../bibliography.html#kw2009) that
    can be implemented directly on the router interfaces. Another solution to be able
    to detect the failure is to instrument the physical and the datalink layer so
    that they can interrupt the router when a link fails. Unfortunately, such a solution
    cannot be used on all types of physical and datalink layers.
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻近故障的路由器可以快速检测到它。默认的解决方案是依赖于常规的HELLO数据包交换。然而，连续HELLO之间的间隔通常设置为10秒……将HELLO计时器降低到几毫秒是困难的，因为HELLO数据包是由路由器的主CPU创建和处理的，这些路由器无法轻易地在每个接口上每毫秒生成和处理一个HELLO数据包。一个更好的解决方案是使用专门的故障检测协议，例如在[[KW2009]](../bibliography.html#kw2009)中定义的双向转发检测（BFD）协议，该协议可以直接在路由器接口上实现。另一种能够检测故障的解决方案是对物理层和数据链路层进行仪器化，以便在链路失败时中断路由器。不幸的是，这种解决方案不能用于所有类型的物理层和数据链路层。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the routers that have detected the failure flood their updated link state packets
    in the network
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测到故障的路由器会在网络中洪泛它们的更新链路状态数据包
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all routers update their routing table
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有路由器更新它们的路由表
- en: A last, but operationally important, point needs to be discussed about intradomain
    routing protocols such as OSPF and IS-IS. Intradomain routing protocols always
    select the shortest path for each destination. In practice, there are often several
    equal paths towards the same destination. When a router computes several equal
    cost paths towards one destination, it can use these paths in different ways.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但也是操作上重要的一点，需要讨论关于OSPF和IS-IS等域内路由协议。域内路由协议总是为每个目的地选择最短路径。在实践中，往往有几种通往同一目的地的等价路径。当一个路由器计算通往一个目的地的几个等价成本路径时，它可以以不同的方式使用这些路径。
- en: A first approach is to select one of the equal cost paths (e.g. the first or
    the last path found by the SPF computation) and install it in the forwarding table.
    In this case, only one path is used to reach each destination.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是选择一条等价成本路径之一（例如，SPF计算找到的第一条或最后一条路径）并将其安装到转发表中。在这种情况下，每个目的地只使用一条路径。
- en: A second approach is to install all equal cost paths [[4]](#fmaxpaths) in the
    forwarding table and load-balance the packets on the different paths. Consider
    the case where a router has N different outgoing interfaces to reach destination
    d. A first possibility to load-balance the traffic among these interfaces is to
    use round-robin. Round-robin allows equally balancing the packets among the N
    outgoing interfaces. This equal load-balancing is important in practice because
    it allows better spreading the load throughout the network. However, few networks
    use this round-robin strategy to load-balance traffic on routers. The main drawback
    of round-robin is that packets that belong to the same flow (e.g. TCP connection)
    may be forwarded over different paths. If packets belonging to the same TCP connection
    are sent over different paths, they will probably experience different delays
    and arrive out-of-sequence at their destination. When a TCP receiver detects out-of-order
    segments, it sends duplicate acknowledgments that may cause the sender to initiate
    a fast retransmission and enter congestion avoidance. Thus, out-of-order segments
    may lead to lower TCP performance. This is annoying for a load-balancing technique
    whose objective is to improve the network performance by spreading the load.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在转发表中安装所有等价成本路径 [[4]](#fmaxpaths) 并在各个路径上负载均衡数据包。考虑一个路由器有 N 个不同的出接口来达到目的地
    d 的情况。在这些接口之间负载均衡流量的第一种可能性是使用轮询。轮询允许在 N 个出接口之间平均分配数据包。这种平均负载均衡在实践中非常重要，因为它允许更好地在整个网络中分散负载。然而，很少有网络使用这种轮询策略在路由器上负载均衡流量。轮询的主要缺点是，属于同一流（例如
    TCP 连接）的数据包可能会被转发到不同的路径。如果属于同一 TCP 连接的数据包被发送到不同的路径，它们可能会经历不同的延迟，并在目的地以乱序到达。当 TCP
    接收器检测到乱序段时，它会发送重复的确认，这可能导致发送方启动快速重传并进入拥塞避免。因此，乱序段可能会导致 TCP 性能降低。这对于旨在通过分散负载来提高网络性能的负载均衡技术来说是个麻烦。
- en: To efficiently spread the load over different paths, routers need to implement
    per-flow load-balancing. This implies that they must forward all the packets that
    belong to the same flow on the same path. Since a TCP connection is always identified
    by the four-tuple (source and destination addresses, source and destination ports),
    one possibility would be to select an outgoing interface upon arrival of the first
    packet of the flow and store this decision in the router’s memory. Unfortunately,
    such a solution does not scale since the required memory grows with the number
    of TCP connections that pass through the router.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地在不同路径上分散负载，路由器需要实现每流负载均衡。这意味着它们必须在同一路径上转发属于同一流的全部数据包。由于 TCP 连接始终由四元组（源和目的地址、源和目的端口）标识，一个可能的选择是在流的第一数据包到达时选择一个出接口，并将此决策存储在路由器的内存中。不幸的是，这种解决方案无法扩展，因为所需的内存会随着通过路由器的
    TCP 连接数量增长。
- en: 'Fortunately, it is possible to perform per-flow load balancing without maintaining
    any state on the router. Most routers today use hash functions for this purpose
    [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html). When a packet
    arrives, the router extracts the Next Header information and the four-tuple from
    the packet and computes :'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以在不维护任何路由器状态的情况下执行每流负载均衡。今天的大多数路由器都使用哈希函数来完成这项任务 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html)。当一个数据包到达时，路由器会从数据包中提取下一个头部信息以及四元组，并计算：
- en: \(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)
- en: In this formula, N is the number of outgoing interfaces on the equal cost paths
    towards the packet’s destination. Various hash functions are possible, including
    CRC, checksum or MD5 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html).
    Since the hash function is computed over the four-tuple, the same hash value will
    be computed for all packets belonging to the same flow. This prevents reordering
    due to load balancing inside the network. Most routers support this kind of load-balancing
    today [[ACO+2006]](../bibliography.html#aco-2006).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，N 是指向数据包目的地的等价成本路径上的出接口数量。可能的哈希函数包括 CRC、校验和或 MD5 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html)。由于哈希函数是在四元组上计算的，因此属于同一流的所有的数据包都会计算出相同的哈希值。这防止了由于网络内部的负载均衡而导致的重新排序。今天的大多数路由器都支持这种类型的负载均衡
    [[ACO+2006]](../bibliography.html#aco-2006)。
- en: Footnotes
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: Intradomain routing[#](#intradomain-routing "Link to this heading")
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域内路由[#](#intradomain-routing "链接到本标题")
- en: 'In this section, we briefly describe the key features of the two main intradomain
    unicast routing protocols : RIP and OSPF. The basic principles of distance vector
    and link-state routing have been presented earlier.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要描述了两种主要域内单播路由协议（RIP和OSPF）的关键特性。距离矢量路由和链路状态路由的基本原理已在前面介绍。
- en: '### RIP[#](#rip "Link to this heading")'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '### RIP[#](#rip "链接到这个标题")'
- en: The Routing Information Protocol (RIP) is the simplest routing protocol that
    was standardized for the TCP/IP protocol suite. RIP is defined in [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html).
    Additional information about RIP may be found in [[Malkin1999]](../bibliography.html#malkin1999).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 路由信息协议（RIP）是标准化为 TCP/IP 协议套件的简单路由协议。RIP 定义在 [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)。有关
    RIP 的更多信息，请参阅 [[Malkin1999]](../bibliography.html#malkin1999)。
- en: RIP routers periodically exchange RIP messages. The format of these messages
    is shown below. A RIP message is sent inside a UDP segment whose destination port
    is set to 521. A RIP message contains several fields. The command field indicates
    whether the RIP message is a request or a response. When a router boots, its routing
    table is empty and it cannot forward any packet. To speedup the discovery of the
    network, it can send a request message to the RIP IPv6 multicast address, `FF02::9`.
    All RIP routers listen to this multicast address and any router attached to the
    subnet will reply by sending its own routing table as a sequence of RIP messages.
    In steady state, routers multicast one of more RIP response messages every 30
    seconds. These messages contain the distance vectors that summarize the router’s
    routing table. The current version of RIP is version 2 defined in [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)
    for IPv4 and [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    for IPv6.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RIP路由器定期交换RIP消息。这些消息的格式如下所示。RIP消息在UDP段内发送，其目标端口设置为521。RIP消息包含几个字段。命令字段指示RIP消息是请求还是响应。当路由器启动时，其路由表为空，无法转发任何数据包。为了加快网络发现的进程，它可以向RIP
    IPv6多播地址`FF02::9`发送请求消息。所有RIP路由器都监听这个多播地址，任何连接到子网的路由器都会通过发送自己的路由表作为一系列RIP消息来回复。在稳定状态下，路由器每30秒多播一个或多个RIP响应消息。这些消息包含总结路由器路由表的距离矢量。RIP的当前版本是版本2，定义在
    [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html) 中用于IPv4，以及
    [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html) 中用于IPv6。
- en: '[![../_images/ripng.svg](../Images/6db6a4a10d1008fa61d614059970a21a.png)](../_images/ripng.svg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ripng.svg](../Images/6db6a4a10d1008fa61d614059970a21a.png)](../_images/ripng.svg)'
- en: Fig. 146 The RIP message format[#](#id17 "Link to this image")
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 146 RIP 消息格式[#](#id17 "链接到这张图片")
- en: Each RIP message contains a set of route entries. Each route entry is encoded
    as a 20 bytes field whose format is shown below. RIP was initially designed to
    be suitable for different network layer protocols. Some implementations of RIP
    were used in XNS or IPX networks [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html).
    The format of the route entries used by [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    is shown below. Prefix length is the length of the subnet identifier in bits and
    the metric is encoded as one byte. The maximum metric supported by RIP is 15.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个RIP消息包含一组路由条目。每个路由条目编码为一个20字节的字段，其格式如下所示。RIP最初设计为适用于不同的网络层协议。一些RIP实现被用于XNS或IPX网络
    [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)。[**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    所使用的路由条目格式如下。前缀长度是子网标识符的位数，度量值编码为一个字节。RIP支持的度量值最大为15。
- en: '[![../_images/rip-route-entry-v6.svg](../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png)](../_images/rip-route-entry-v6.svg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/rip-route-entry-v6.svg](../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png)](../_images/rip-route-entry-v6.svg)'
- en: Fig. 147 Format of the RIP IPv6 route entries[#](#id18 "Link to this image")
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 147 RIP IPv6 路由条目格式[#](#id18 "链接到这张图片")
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A note on timers
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计时器
- en: 'The first RIP implementations sent their distance vector exactly every 30 seconds.
    This worked well in most networks, but some researchers noticed that routers were
    sometimes overloaded because they were processing too many distance vectors at
    the same time [[FJ1994]](../bibliography.html#fj1994). They collected packet traces
    in these networks and found that after some time the routers’ timers became synchronized,
    i.e. almost all routers were sending their distance vectors at almost the same
    time. This synchronization of the transmission times of the distance vectors caused
    an overload on the routers’ CPU but also increased the convergence time of the
    protocol in some cases. This was mainly due to the fact that all routers set their
    timers to the same expiration time after having processed the received distance
    vectors. [Sally Floyd](https://www.icir.org/floyd/) and [Van Jacobson](https://en.wikipedia.org/wiki/Van_Jacobson)
    proposed in [[FJ1994]](../bibliography.html#fj1994) a simple solution to solve
    this synchronization problem. Instead of advertising their distance vector exactly
    after 30 seconds, a router should send its next distance vector after a delay
    chosen randomly in the [15,45] interval [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html).
    This randomization of the delays prevents the synchronization that occurs with
    a fixed delay and is now a recommended practice for protocol designers.  ### OSPF[#](#ospf
    "Link to this heading")'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个RIP实现每30秒精确发送一次它们的距离矢量。这在大多数网络中都工作得很好，但一些研究人员注意到，由于同时处理过多的距离矢量，路由器有时会过载[[FJ1994]](../bibliography.html#fj1994)。他们在这些网络中收集了数据包跟踪，并发现经过一段时间后，路由器的计时器变得同步，即几乎所有路由器都在几乎相同的时间发送它们的距离矢量。这种距离矢量传输时间的同步导致路由器CPU过载，在某些情况下也增加了协议的收敛时间。这主要是因为所有路由器在处理接收到的距离矢量后都将它们的计时器设置为相同的过期时间。[Sally
    Floyd](https://www.icir.org/floyd/)和[Van Jacobson](https://en.wikipedia.org/wiki/Van_Jacobson)在[[FJ1994]](../bibliography.html#fj1994)中提出了一种简单的解决方案来解决这个同步问题。路由器不应在30秒后精确地广播它们的距离矢量，而应在[15,45]区间内随机选择延迟后发送下一个距离矢量[**RFC
    2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)。这种延迟的随机化防止了与固定延迟发生的同步，现在已成为协议设计者的推荐做法。###
    OSPF[#](#ospf "链接到这个标题")
- en: Link-state routing protocols are used in IP networks. Open Shortest Path First
    (OSPF), defined in [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html),
    is the link state routing protocol that has been standardized by the IETF. The
    last version of OSPF, which supports IPv6, is defined in [**RFC 5340**](https://datatracker.ietf.org/doc/html/rfc5340.html).
    OSPF is frequently used in enterprise networks and in some ISP networks. However,
    ISP networks often use the IS-IS link-state routing protocol [[ISO10589]](../bibliography.html#iso10589)
    , which was developed for the ISO CLNP protocol but was adapted to be used in
    IP [**RFC 1195**](https://datatracker.ietf.org/doc/html/rfc1195.html) networks
    before the finalization of the standardization of OSPF. A detailed analysis of
    ISIS and OSPF may be found in [[BMO2006]](../bibliography.html#bmo2006) and [[Perlman2000]](../bibliography.html#perlman2000).
    Additional information about OSPF may be found in [[Moy1998]](../bibliography.html#moy1998).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态路由协议在IP网络中使用。定义在[**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)中的开放最短路径优先（OSPF）是已被IETF标准化的链路状态路由协议。支持IPv6的OSPF最后一个版本定义在[**RFC
    5340**](https://datatracker.ietf.org/doc/html/rfc5340.html)中。OSPF常在企业网络和一些ISP网络中使用。然而，ISP网络通常使用IS-IS链路状态路由协议[[ISO10589]](../bibliography.html#iso10589)，该协议是为ISO
    CLNP协议开发的，但在OSPF标准化最终确定之前，已被调整为在IP网络[**RFC 1195**](https://datatracker.ietf.org/doc/html/rfc1195.html)中使用。ISIS和OSPF的详细分析可以在[[BMO2006]](../bibliography.html#bmo2006)和[[Perlman2000]](../bibliography.html#perlman2000)中找到。有关OSPF的更多信息，可以在[[Moy1998]](../bibliography.html#moy1998)中找到。
- en: Compared to the basics of link-state routing protocols that we discussed in
    section [Link state routing](network.html#linkstate), there are some particularities
    of OSPF that are worth discussing. First, in a large network, flooding the information
    about all routers and links to thousands of routers or more may be costly as each
    router needs to store all the information about the entire network. A better approach
    would be to introduce hierarchical routing. Hierarchical routing divides the network
    into regions. All the routers inside a region have detailed information about
    the topology of the region but only learn aggregated information about the topology
    of the other regions and their interconnections. OSPF supports a restricted variant
    of hierarchical routing. In OSPF’s terminology, a region is called an area.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 [链路状态路由](network.html#linkstate) 部分讨论的链路状态路由协议的基本原理相比，OSPF 有一些值得讨论的特殊性。首先，在一个大型网络中，将所有路由器和链路的信息传播到成千上万的路由器可能成本高昂，因为每个路由器都需要存储整个网络的所有信息。一个更好的方法是将网络划分为区域。分层路由将网络划分为区域。区域内的所有路由器都了解该区域的拓扑结构，但只知道其他区域拓扑结构和它们之间互连的汇总信息。OSPF
    支持分层路由的受限变体。在 OSPF 的术语中，一个区域被称为区域。
- en: 'OSPF imposes restrictions on how a network can be divided into areas. An area
    is a set of routers and links that are grouped together. Usually, the topology
    of an area is chosen so that a packet sent by one router inside the area can reach
    any other router in the area without leaving the area [[2]](#fvirtual) . An OSPF
    area contains two types of routers [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF 对如何将网络划分为区域施加了限制。一个区域是一组组合在一起的路由器和链路。通常，选择一个区域的拓扑结构，使得该区域内发送的一个数据包可以到达该区域内的任何其他路由器，而无需离开该区域
    [[2]](#fvirtual)。一个 OSPF 区域包含两种类型的路由器 [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)：
- en: 'Internal router : A router whose directly connected networks belong to the
    area'
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部路由器：一个其直接连接的网络属于该区域的路由器。
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Area border routers : A router that is attached to several areas.'
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域边界路由器：连接到多个区域的路由器。
- en: 'For example, the network shown in figure [Fig. 148](#fig-ospf-areas) has been
    divided into three areas : area 0, containing routers RA, RB, RC and RD, area
    1, containing routers R1, R3, R4, R5 and RA, and area 2 containing R7, R8, R9,
    R10, RB and RC. OSPF areas are identified by a 32 bit integer, which is sometimes
    represented as an IP address. Among the OSPF areas, area 0, also called the backbone
    area, has a special role. The backbone area groups all the area border routers
    (routers RA, RB and RC in the figure below) and the routers that are directly
    connected to the backbone routers but do not belong to another area (router RD
    in the figure below). An important restriction imposed by OSPF is that the path
    between two routers that belong to two different areas (e.g. R1 and R8 in the
    figure below) must pass through the backbone area.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图 [图 148](#fig-ospf-areas) 所示的网络已被划分为三个区域：区域 0，包含路由器 RA、RB、RC 和 RD；区域 1，包含路由器
    R1、R3、R4、R5 和 RA；区域 2 包含 R7、R8、R9、R10、RB 和 RC。OSPF 区域通过一个 32 位整数来识别，有时也用 IP 地址来表示。在
    OSPF 区域中，区域 0，也称为骨干区域，具有特殊的作用。骨干区域将所有区域边界路由器（如图下方的路由器 RA、RB 和 RC）以及直接连接到骨干路由器但不属于其他区域的路由器（如图下方的路由器
    RD）组合在一起。OSPF 强制实施的一个重要限制是，属于两个不同区域（例如图下方的 R1 和 R8）的两个路由器之间的路径必须通过骨干区域。
- en: '[![../_images/ospf-areas.png](../Images/ecfc93d799f6e5b0786b740a7776fc54.png)](../_images/ospf-areas.png)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ospf-areas.png](../Images/ecfc93d799f6e5b0786b740a7776fc54.png)(../_images/ospf-areas.png)'
- en: Fig. 148 OSPF areas[#](#id19 "Link to this image")
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 148 OSPF 区域[#](#id19 "链接到这张图片")
- en: Inside each non-backbone area, routers distribute the topology of the area by
    exchanging link state packets with the other routers in the area. The internal
    routers do not know the topology of other areas, but each router knows how to
    reach the backbone area. Inside an area, the routers only exchange link-state
    packets for all destinations that are reachable inside the area. In OSPF, the
    inter-area routing is done by exchanging distance vectors. This is illustrated
    by the network topology shown in figure [Fig. 149](#fig-net-ospf-areas).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个非骨干区域内部，路由器通过与其他区域内的路由器交换链路状态数据包来分发该区域的拓扑结构。内部路由器不知道其他区域的拓扑结构，但每个路由器都知道如何到达骨干区域。在一个区域内部，路由器只为区域内可达的所有目的地交换链路状态数据包。在
    OSPF 中，区域间路由是通过交换距离向量来完成的。这可以通过图 [图 149](#fig-net-ospf-areas) 所示的网络拓扑结构来说明。
- en: '[![../_images/ospf-area.png](../Images/e2e208cffe57552ed18b52f85b1655ab.png)](../_images/ospf-area.png)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ospf-area.png](../Images/e2e208cffe57552ed18b52f85b1655ab.png)'
- en: Fig. 149 Hierarchical routing with OSPF[#](#id20 "Link to this image")
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图149：使用OSPF的分层路由[#](#id20 "链接到此图像")
- en: 'Let us first consider OSPF routing inside area 2. All routers in the area learn
    a route towards 2001:db8:1234::/48 and 2001:db8:5678::/48. The two area border
    routers, RB and RC, create network summary advertisements. Assuming that all links
    have a unit link metric, these would be:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑区域2内的OSPF路由。该区域内的所有路由器都学习到到达2001:db8:1234::/48和2001:db8:5678::/48的路由。两个区域边界路由器RB和RC创建网络汇总广告。假设所有链路都具有单位链路度量，这些汇总广告将是：
- en: RB advertises 2001:db8:1234::/48 at a distance of 2 and 2001:db8:5678::/48 at
    a distance of 3
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB在距离为2的地方发布2001:db8:1234::/48，在距离为3的地方发布2001:db8:5678::/48
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RC advertises 2001:db8:5678::/48 at a distance of 2 and 2001:db8:1234::/48 at
    a distance of 3
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC在距离为2的地方发布2001:db8:5678::/48，在距离为3的地方发布2001:db8:1234::/48
- en: These summary advertisements are flooded through the backbone area attached
    to routers RB and RC. In its routing table, router RA selects the summary advertised
    by RB to reach 2001:db8:1234::/48 and the summary advertised by RC to reach 2001:db8:5678::/48.
    Inside area 1, router RA advertises a summary indicating that 2001:db8:1234::/48
    and 2001:db8:5678::/48 are both at a distance of 3 from itself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些汇总广告通过连接到路由器RB和RC的主干区域进行泛洪。在RA的路由表中，RA选择RB发布的汇总广告来到达2001:db8:1234::/48，选择RC发布的汇总广告来到达2001:db8:5678::/48。在区域1内，RA发布一个汇总广告，表明2001:db8:1234::/48和2001:db8:5678::/48都距离自身3个距离单位。
- en: 'On the other hand, consider the prefixes 2001:db8:aaaa:0000::/64 and 2001:db8:aaaa:0001::/64
    that are inside area 1. Router RA is the only area border router that is attached
    to this area. This router can create two different network summary advertisements
    :'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，考虑位于区域1内的前缀2001:db8:aaaa:0000::/64和2001:db8:aaaa:0001::/64。路由器RA是唯一连接到该区域的区域边界路由器。该路由器可以创建两个不同的网络汇总广告：
- en: 2001:db8:aaaa:0001::/64 at a distance of 1 and 2001:db8:aaaa:0000::/64 at a
    distance of 2 from RA
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从RA的距离为1的2001:db8:aaaa:0001::/64和从RA的距离为2的2001:db8:aaaa:0000::/64
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 2001:db8:aaaa:0000::/63 at a distance of 2 from RA
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001:db8:aaaa:0000::/63在RA的距离为2
- en: The first summary advertisement provides precise information about the distance
    used to reach each prefix. However, all routers in the network have to maintain
    a route towards 2001:db8:aaaa:0000::/64 and a route towards 2001:db8:aaaa:0001::/64
    that are both via router RA. The second advertisement would improve the scalability
    of OSPF by reducing the number of routes that are advertised across area boundaries.
    However, in practice this requires manual configuration on the border routers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个汇总广告提供了关于到达每个前缀所使用的距离的精确信息。然而，网络中的所有路由器都必须维护一个指向2001:db8:aaaa:0000::/64和指向2001:db8:aaaa:0001::/64的路由，这两个路由都通过路由器RA。第二个广告将提高OSPF的可扩展性，通过减少跨区域边界发布的路由数量。然而，在实践中，这需要在边界路由器上进行手动配置。
- en: The second OSPF particularity that is worth discussing is the support of Local
    Area Networks (LAN). As shown in figure [Fig. 150](#fig-ospf-lan), several routers
    may be attached to the same LAN.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 值得讨论的第二个OSPF特性是支持本地局域网（LAN）。如图[图150](#fig-ospf-lan)所示，多个路由器可能连接到同一个LAN。
- en: '![Figure made with TikZ](../Images/b61c40a915c22075c5f71b026344c0d8.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/b61c40a915c22075c5f71b026344c0d8.png)'
- en: Fig. 150 A LAN with routers
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图150：带有路由器的LAN
- en: 'A first solution to support such a LAN with a link-state routing protocol would
    be to consider that a LAN is equivalent to a full-mesh of point-to-point links
    as if each router can directly reach any other router on the LAN. However, this
    approach has two important drawbacks :'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此类LAN的链路状态路由协议的第一个解决方案是考虑LAN相当于一个全网的点对点链路，就像每个路由器可以直接到达LAN上的任何其他路由器一样。然而，这种方法有两个重要的缺点：
- en: Each router must exchange HELLOs and link state packets with all the other routers
    on the LAN. This increases the number of OSPF packets that are sent and processed
    by each router.
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个路由器必须与LAN上所有其他路由器交换HELLO和链路状态数据包。这增加了每个路由器发送和处理的OSPF数据包数量。
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Remote routers, when looking at the topology distributed by OSPF, consider that
    there is a full-mesh of links between all the LAN routers. Such a full-mesh implies
    a lot of redundancy in case of failure, while in practice the entire LAN may completely
    fail. In case of a failure of the entire LAN, all routers need to detect the failures
    and flood link state packets before the LAN is completely removed from the OSPF
    topology by remote routers.
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程路由器在查看OSPF分发的拓扑时，认为所有局域网路由器之间存在全连接的链路。这种全连接意味着在故障情况下存在大量的冗余，而在实践中，整个局域网可能会完全失效。在局域网完全从远程路由器的OSPF拓扑中移除之前，所有路由器都需要检测故障并泛洪链路状态包。
- en: To better represent LANs and reduce the number of OSPF packets that are exchanged,
    OSPF handles LAN differently. When OSPF routers boot on a LAN, they elect [[3]](#felection)
    one of them as the Designated Router (DR) [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html).
    The DR router represents the local area network, and advertises the LAN’s subnet.
    Furthermore, LAN routers only exchange HELLO packets with the DR. Thanks to the
    utilization of a DR, the topology of the LAN appears as a set of point-to-point
    links connected to the DR router.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地表示局域网并减少交换的OSPF数据包数量，OSPF对局域网的处理方式不同。当OSPF路由器在局域网启动时，它们会选举[[3]](#felection)其中一个作为指定路由器（DR）[**RFC
    2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)。DR路由器代表本地局域网，并通告局域网的子网。此外，局域网路由器只与DR交换HELLO包。得益于DR的使用，局域网的拓扑结构看起来像是一组连接到DR路由器的点对点链路。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: How to quickly detect a link failure ?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如何快速检测链路故障？
- en: 'Network operators expect an OSPF network to be able to quickly recover from
    link or router failures [[VPD2004]](../bibliography.html#vpd2004). In an OSPF
    network, the recovery after a failure is performed in three steps [[FFEB2005]](../bibliography.html#ffeb2005)
    :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '网络运营商期望OSPF网络能够快速从链路或路由器故障中恢复[[VPD2004]](../bibliography.html#vpd2004)。在OSPF网络中，故障后的恢复分为三个步骤[[FFEB2005]](../bibliography.html#ffeb2005)
    :'
- en: the routers that are adjacent to the failure detect it quickly. The default
    solution is to rely on the regular exchange of HELLO packets. However, the interval
    between successive HELLOs is often set to 10 seconds… Setting the HELLO timer
    down to a few milliseconds is difficult as HELLO packets are created and processed
    by the main CPU of the routers and these routers cannot easily generate and process
    a HELLO packet every millisecond on each of their interfaces. A better solution
    is to use a dedicated failure detection protocol such as the Bidirectional Forwarding
    Detection (BFD) protocol defined in [[KW2009]](../bibliography.html#kw2009) that
    can be implemented directly on the router interfaces. Another solution to be able
    to detect the failure is to instrument the physical and the datalink layer so
    that they can interrupt the router when a link fails. Unfortunately, such a solution
    cannot be used on all types of physical and datalink layers.
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻近故障的路由器可以快速检测到它。默认的解决方案是依赖于定期的HELLO包交换。然而，连续HELLO包之间的间隔通常设置为10秒……将HELLO计时器降低到几毫秒是困难的，因为HELLO包是由路由器的主CPU创建和处理的，这些路由器无法轻易地在每个接口上每毫秒生成和处理一个HELLO包。一个更好的解决方案是使用专门的故障检测协议，例如在[[KW2009]](../bibliography.html#kw2009)中定义的双向转发检测（BFD）协议，该协议可以直接在路由器接口上实现。另一种能够检测故障的解决方案是对物理和链路层进行仪器化，以便在链路故障时中断路由器。不幸的是，这种解决方案不能用于所有类型的物理和链路层。
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the routers that have detected the failure flood their updated link state packets
    in the network
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测到故障的路由器会将更新的链路状态包在网络中泛洪
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all routers update their routing table
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有路由器都会更新它们的路由表
- en: A last, but operationally important, point needs to be discussed about intradomain
    routing protocols such as OSPF and IS-IS. Intradomain routing protocols always
    select the shortest path for each destination. In practice, there are often several
    equal paths towards the same destination. When a router computes several equal
    cost paths towards one destination, it can use these paths in different ways.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但操作上很重要的一点是，需要讨论关于OSPF和IS-IS等域内路由协议的问题。域内路由协议始终为每个目的地选择最短路径。在实践中，往往有通往同一目的地的多条等价路径。当路由器计算通往一个目的地的多条等价成本路径时，它可以以不同的方式使用这些路径。
- en: A first approach is to select one of the equal cost paths (e.g. the first or
    the last path found by the SPF computation) and install it in the forwarding table.
    In this case, only one path is used to reach each destination.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是选择一条等价成本路径（例如，SPF计算找到的第一条或最后一条路径）并将其安装到转发表中。在这种情况下，每个目的地只使用一条路径。
- en: A second approach is to install all equal cost paths [[4]](#fmaxpaths) in the
    forwarding table and load-balance the packets on the different paths. Consider
    the case where a router has N different outgoing interfaces to reach destination
    d. A first possibility to load-balance the traffic among these interfaces is to
    use round-robin. Round-robin allows equally balancing the packets among the N
    outgoing interfaces. This equal load-balancing is important in practice because
    it allows better spreading the load throughout the network. However, few networks
    use this round-robin strategy to load-balance traffic on routers. The main drawback
    of round-robin is that packets that belong to the same flow (e.g. TCP connection)
    may be forwarded over different paths. If packets belonging to the same TCP connection
    are sent over different paths, they will probably experience different delays
    and arrive out-of-sequence at their destination. When a TCP receiver detects out-of-order
    segments, it sends duplicate acknowledgments that may cause the sender to initiate
    a fast retransmission and enter congestion avoidance. Thus, out-of-order segments
    may lead to lower TCP performance. This is annoying for a load-balancing technique
    whose objective is to improve the network performance by spreading the load.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在转发表中安装所有等价成本路径 [[4]](#fmaxpaths) 并在这些不同路径上对数据包进行负载均衡。考虑一个路由器有N个不同的出接口来到达目的地d的情况。在这些接口之间负载均衡流量的第一种可能性是使用轮询。轮询允许在N个出接口之间平均分配数据包。这种负载均衡在实践中的重要性在于它允许更好地在整个网络中分配负载。然而，很少有网络使用这种轮询策略在路由器上负载均衡流量。轮询的主要缺点是，属于同一流（例如TCP连接）的数据包可能会被转发到不同的路径。如果属于同一TCP连接的数据包被发送到不同的路径，它们可能会经历不同的延迟，并在目的地以乱序到达。当TCP接收器检测到乱序段时，它会发送重复的确认，这可能导致发送方启动快速重传并进入拥塞避免状态。因此，乱序段可能会导致TCP性能降低。这对于一个旨在通过分散负载来提高网络性能的负载均衡技术来说是很烦恼的。
- en: To efficiently spread the load over different paths, routers need to implement
    per-flow load-balancing. This implies that they must forward all the packets that
    belong to the same flow on the same path. Since a TCP connection is always identified
    by the four-tuple (source and destination addresses, source and destination ports),
    one possibility would be to select an outgoing interface upon arrival of the first
    packet of the flow and store this decision in the router’s memory. Unfortunately,
    such a solution does not scale since the required memory grows with the number
    of TCP connections that pass through the router.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地在不同路径上分配负载，路由器需要实现按流负载均衡。这意味着它们必须在同一路径上转发属于同一流的全部数据包。由于TCP连接始终由四元组（源和目的地址、源和目的端口）标识，一个可能的方法是在流的第一数据包到达时选择一个出接口，并将此决策存储在路由器的内存中。不幸的是，这种解决方案无法扩展，因为所需的内存随着通过路由器的TCP连接数量增长而增长。
- en: 'Fortunately, it is possible to perform per-flow load balancing without maintaining
    any state on the router. Most routers today use hash functions for this purpose
    [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html). When a packet
    arrives, the router extracts the Next Header information and the four-tuple from
    the packet and computes :'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以在不维护路由器上的任何状态的情况下执行按流负载均衡。今天的大多数路由器都使用哈希函数来完成此目的 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html)。当一个数据包到达时，路由器从数据包中提取Next
    Header信息和四元组，并计算：
- en: \(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)
- en: In this formula, N is the number of outgoing interfaces on the equal cost paths
    towards the packet’s destination. Various hash functions are possible, including
    CRC, checksum or MD5 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html).
    Since the hash function is computed over the four-tuple, the same hash value will
    be computed for all packets belonging to the same flow. This prevents reordering
    due to load balancing inside the network. Most routers support this kind of load-balancing
    today [[ACO+2006]](../bibliography.html#aco-2006).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此公式中，N是通往数据包目的地的等价成本路径上的出接口数量。可能的哈希函数包括CRC、校验和或MD5[**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html)。由于哈希函数是在四元组上计算的，因此对于属于同一流的所有数据包，将计算相同的哈希值。这防止了由于网络内部的负载均衡而导致的重新排序。大多数路由器今天都支持这种类型的负载均衡[[ACO+2006]](../bibliography.html#aco-2006)。
- en: 'Footnotes  ### RIP[#](#rip "Link to this heading")'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '脚注  ### RIP[#](#rip "链接到此标题")'
- en: The Routing Information Protocol (RIP) is the simplest routing protocol that
    was standardized for the TCP/IP protocol suite. RIP is defined in [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html).
    Additional information about RIP may be found in [[Malkin1999]](../bibliography.html#malkin1999).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 路由信息协议（RIP）是标准化为TCP/IP协议套件的简单路由协议。RIP在[**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)中定义。有关RIP的更多信息，请参阅[[Malkin1999]](../bibliography.html#malkin1999)。
- en: RIP routers periodically exchange RIP messages. The format of these messages
    is shown below. A RIP message is sent inside a UDP segment whose destination port
    is set to 521. A RIP message contains several fields. The command field indicates
    whether the RIP message is a request or a response. When a router boots, its routing
    table is empty and it cannot forward any packet. To speedup the discovery of the
    network, it can send a request message to the RIP IPv6 multicast address, `FF02::9`.
    All RIP routers listen to this multicast address and any router attached to the
    subnet will reply by sending its own routing table as a sequence of RIP messages.
    In steady state, routers multicast one of more RIP response messages every 30
    seconds. These messages contain the distance vectors that summarize the router’s
    routing table. The current version of RIP is version 2 defined in [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)
    for IPv4 and [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    for IPv6.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: RIP路由器定期交换RIP消息。这些消息的格式如下所示。RIP消息在UDP段内发送，其目标端口设置为521。RIP消息包含几个字段。命令字段指示RIP消息是请求还是响应。当路由器启动时，其路由表为空，它无法转发任何数据包。为了加快网络发现的进程，它可以向RIP
    IPv6多播地址`FF02::9`发送请求消息。所有RIP路由器都监听此多播地址，任何连接到子网的路由器都会通过发送自己的路由表作为一系列RIP消息来回复。在稳定状态下，路由器每30秒多播一个或多个RIP响应消息。这些消息包含总结路由器路由表的距离向量。RIP的当前版本是版本2，它定义在[**RFC
    2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)中用于IPv4，在[**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)中用于IPv6。
- en: '[![../_images/ripng.svg](../Images/6db6a4a10d1008fa61d614059970a21a.png)](../_images/ripng.svg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ripng.svg](../Images/6db6a4a10d1008fa61d614059970a21a.png)](../_images/ripng.svg)'
- en: Fig. 146 The RIP message format[#](#id17 "Link to this image")
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图146 RIP消息格式[#](#id17 "链接到此图像")
- en: Each RIP message contains a set of route entries. Each route entry is encoded
    as a 20 bytes field whose format is shown below. RIP was initially designed to
    be suitable for different network layer protocols. Some implementations of RIP
    were used in XNS or IPX networks [**RFC 2453**](https://datatracker.ietf.org/doc/html/rfc2453.html).
    The format of the route entries used by [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)
    is shown below. Prefix length is the length of the subnet identifier in bits and
    the metric is encoded as one byte. The maximum metric supported by RIP is 15.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个RIP消息包含一组路由条目。每个路由条目编码为一个20字节的字段，其格式如下所示。RIP最初设计为适用于不同的网络层协议。一些RIP的实现被用于XNS或IPX网络[**RFC
    2453**](https://datatracker.ietf.org/doc/html/rfc2453.html)。[**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)使用的路由条目格式如下所示。前缀长度是子网标识符的位数，度量值编码为一个字节。RIP支持的最大度量值为15。
- en: '[![../_images/rip-route-entry-v6.svg](../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png)](../_images/rip-route-entry-v6.svg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/rip-route-entry-v6.svg](../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png)](../_images/rip-route-entry-v6.svg)'
- en: Fig. 147 Format of the RIP IPv6 route entries[#](#id18 "Link to this image")
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图147 RIP IPv6路由条目格式[#](#id18 "链接到此图像")
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A note on timers
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计时器的一个说明
- en: The first RIP implementations sent their distance vector exactly every 30 seconds.
    This worked well in most networks, but some researchers noticed that routers were
    sometimes overloaded because they were processing too many distance vectors at
    the same time [[FJ1994]](../bibliography.html#fj1994). They collected packet traces
    in these networks and found that after some time the routers’ timers became synchronized,
    i.e. almost all routers were sending their distance vectors at almost the same
    time. This synchronization of the transmission times of the distance vectors caused
    an overload on the routers’ CPU but also increased the convergence time of the
    protocol in some cases. This was mainly due to the fact that all routers set their
    timers to the same expiration time after having processed the received distance
    vectors. [Sally Floyd](https://www.icir.org/floyd/) and [Van Jacobson](https://en.wikipedia.org/wiki/Van_Jacobson)
    proposed in [[FJ1994]](../bibliography.html#fj1994) a simple solution to solve
    this synchronization problem. Instead of advertising their distance vector exactly
    after 30 seconds, a router should send its next distance vector after a delay
    chosen randomly in the [15,45] interval [**RFC 2080**](https://datatracker.ietf.org/doc/html/rfc2080.html).
    This randomization of the delays prevents the synchronization that occurs with
    a fixed delay and is now a recommended practice for protocol designers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个RIP实现每30秒精确发送一次它们的距离矢量。这在大多数网络中都工作得很好，但一些研究人员注意到，由于同时处理太多的距离矢量，路由器有时会过载[[FJ1994]](../bibliography.html#fj1994)。他们在这些网络中收集了数据包跟踪，并发现经过一段时间后，路由器的计时器变得同步，即几乎所有路由器都在几乎相同的时间发送它们的距离矢量。这种距离矢量传输时间的同步导致路由器CPU过载，在某些情况下也增加了协议的收敛时间。这主要是因为所有路由器在处理接收到的距离矢量后都将它们的计时器设置为相同的过期时间。[Sally
    Floyd](https://www.icir.org/floyd/)和[Van Jacobson](https://en.wikipedia.org/wiki/Van_Jacobson)在[[FJ1994]](../bibliography.html#fj1994)中提出了一种简单的解决方案来解决这个同步问题。路由器不应在30秒后精确地宣布它们的距离矢量，而应在[15,45]区间内随机选择延迟后发送下一个距离矢量[**RFC
    2080**](https://datatracker.ietf.org/doc/html/rfc2080.html)。这种延迟的随机化防止了与固定延迟发生的同步，并且现在已成为协议设计者的推荐做法。
- en: '### OSPF[#](#ospf "Link to this heading")'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### OSPF[#](#ospf "链接到这个标题")'
- en: Link-state routing protocols are used in IP networks. Open Shortest Path First
    (OSPF), defined in [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html),
    is the link state routing protocol that has been standardized by the IETF. The
    last version of OSPF, which supports IPv6, is defined in [**RFC 5340**](https://datatracker.ietf.org/doc/html/rfc5340.html).
    OSPF is frequently used in enterprise networks and in some ISP networks. However,
    ISP networks often use the IS-IS link-state routing protocol [[ISO10589]](../bibliography.html#iso10589)
    , which was developed for the ISO CLNP protocol but was adapted to be used in
    IP [**RFC 1195**](https://datatracker.ietf.org/doc/html/rfc1195.html) networks
    before the finalization of the standardization of OSPF. A detailed analysis of
    ISIS and OSPF may be found in [[BMO2006]](../bibliography.html#bmo2006) and [[Perlman2000]](../bibliography.html#perlman2000).
    Additional information about OSPF may be found in [[Moy1998]](../bibliography.html#moy1998).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态路由协议在IP网络中使用。开放最短路径优先（OSPF），由[**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)定义，是已被IETF标准化的链路状态路由协议。支持IPv6的OSPF最后一个版本由[**RFC
    5340**](https://datatracker.ietf.org/doc/html/rfc5340.html)定义。OSPF经常在企业网络和一些ISP网络中使用。然而，ISP网络通常使用IS-IS链路状态路由协议[[ISO10589]](../bibliography.html#iso10589)，该协议是为ISO
    CLNP协议开发的，但在OSPF标准化最终确定之前，已被调整为在IP网络[**RFC 1195**](https://datatracker.ietf.org/doc/html/rfc1195.html)中使用。ISIS和OSPF的详细分析可以在[[BMO2006]](../bibliography.html#bmo2006)和[[Perlman2000]](../bibliography.html#perlman2000)中找到。有关OSPF的更多信息可以在[[Moy1998]](../bibliography.html#moy1998)中找到。
- en: Compared to the basics of link-state routing protocols that we discussed in
    section [Link state routing](network.html#linkstate), there are some particularities
    of OSPF that are worth discussing. First, in a large network, flooding the information
    about all routers and links to thousands of routers or more may be costly as each
    router needs to store all the information about the entire network. A better approach
    would be to introduce hierarchical routing. Hierarchical routing divides the network
    into regions. All the routers inside a region have detailed information about
    the topology of the region but only learn aggregated information about the topology
    of the other regions and their interconnections. OSPF supports a restricted variant
    of hierarchical routing. In OSPF’s terminology, a region is called an area.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[链路状态路由](network.html#linkstate)部分讨论的链路状态路由协议的基本原理相比，OSPF有一些值得讨论的特殊性。首先，在一个大型网络中，将所有路由器和链路的信息传播到数千个或更多的路由器可能会很昂贵，因为每个路由器都需要存储整个网络的所有信息。一个更好的方法是将网络划分为区域。分层路由将网络划分为区域。一个区域内的所有路由器都对该区域的拓扑结构有详细的信息，但只知道其他区域拓扑结构和它们之间互连的汇总信息。OSPF支持分层路由的受限变体。在OSPF术语中，一个区域被称为区域。
- en: 'OSPF imposes restrictions on how a network can be divided into areas. An area
    is a set of routers and links that are grouped together. Usually, the topology
    of an area is chosen so that a packet sent by one router inside the area can reach
    any other router in the area without leaving the area [[2]](#fvirtual) . An OSPF
    area contains two types of routers [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF对网络如何划分为区域施加了限制。一个区域是一组组合在一起的路由器和链路。通常，一个区域的拓扑结构被选择，以便区域内的一个路由器发送的数据包可以在不离开区域的情况下到达该区域内的任何其他路由器
    [[2]](#fvirtual) 。OSPF区域包含两种类型的路由器 [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)：
- en: 'Internal router : A router whose directly connected networks belong to the
    area'
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部路由器：直接连接的网络属于该区域的路由器
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Area border routers : A router that is attached to several areas.'
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域边界路由器：连接到多个区域的路由器。
- en: 'For example, the network shown in figure [Fig. 148](#fig-ospf-areas) has been
    divided into three areas : area 0, containing routers RA, RB, RC and RD, area
    1, containing routers R1, R3, R4, R5 and RA, and area 2 containing R7, R8, R9,
    R10, RB and RC. OSPF areas are identified by a 32 bit integer, which is sometimes
    represented as an IP address. Among the OSPF areas, area 0, also called the backbone
    area, has a special role. The backbone area groups all the area border routers
    (routers RA, RB and RC in the figure below) and the routers that are directly
    connected to the backbone routers but do not belong to another area (router RD
    in the figure below). An important restriction imposed by OSPF is that the path
    between two routers that belong to two different areas (e.g. R1 and R8 in the
    figure below) must pass through the backbone area.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图[图. 148](#fig-ospf-areas)所示的网络已被划分为三个区域：区域0，包含路由器RA、RB、RC和RD；区域1，包含路由器R1、R3、R4、R5和RA；区域2包含R7、R8、R9、R10、RB和RC。OSPF区域由一个32位整数标识，有时表示为IP地址。在OSPF区域中，区域0，也称为骨干区域，具有特殊的作用。骨干区域将所有区域边界路由器（如图下方的路由器RA、RB和RC）以及直接连接到骨干路由器但不属于另一个区域的路由器（如图下方的路由器RD）组合在一起。OSPF施加的一个重要限制是，属于两个不同区域（例如图下方的R1和R8）的两个路由器之间的路径必须通过骨干区域。
- en: '[![../_images/ospf-areas.png](../Images/ecfc93d799f6e5b0786b740a7776fc54.png)](../_images/ospf-areas.png)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ospf-areas.png](../Images/ecfc93d799f6e5b0786b740a7776fc54.png)(../_images/ospf-areas.png)'
- en: Fig. 148 OSPF areas[#](#id19 "Link to this image")
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图. 148 OSPF区域[#](#id19 "链接到此图像")
- en: Inside each non-backbone area, routers distribute the topology of the area by
    exchanging link state packets with the other routers in the area. The internal
    routers do not know the topology of other areas, but each router knows how to
    reach the backbone area. Inside an area, the routers only exchange link-state
    packets for all destinations that are reachable inside the area. In OSPF, the
    inter-area routing is done by exchanging distance vectors. This is illustrated
    by the network topology shown in figure [Fig. 149](#fig-net-ospf-areas).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个非骨干区域中，路由器通过与其他区域内的路由器交换链路状态数据包来分发区域的拓扑结构。内部路由器不知道其他区域的拓扑结构，但每个路由器都知道如何到达骨干区域。在一个区域内，路由器只为区域内可达的所有目的地交换链路状态数据包。在OSPF中，区域间路由是通过交换距离向量来完成的。这可以通过图[图.
    149](#fig-net-ospf-areas)所示的网络安全拓扑来表示。
- en: '[![../_images/ospf-area.png](../Images/e2e208cffe57552ed18b52f85b1655ab.png)](../_images/ospf-area.png)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ospf-area.png](../Images/e2e208cffe57552ed18b52f85b1655ab.png)'
- en: Fig. 149 Hierarchical routing with OSPF[#](#id20 "Link to this image")
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 149 使用 OSPF 的分层路由[#](#id20 "链接到此图像")
- en: 'Let us first consider OSPF routing inside area 2. All routers in the area learn
    a route towards 2001:db8:1234::/48 and 2001:db8:5678::/48. The two area border
    routers, RB and RC, create network summary advertisements. Assuming that all links
    have a unit link metric, these would be:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑区域 2 内的 OSPF 路由。该区域内的所有路由器都学习到指向 2001:db8:1234::/48 和 2001:db8:5678::/48
    的路由。两个区域边界路由器 RB 和 RC 创建网络摘要广告。假设所有链路都具有单位链路度量，这些广告将是：
- en: RB advertises 2001:db8:1234::/48 at a distance of 2 and 2001:db8:5678::/48 at
    a distance of 3
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 广告 2001:db8:1234::/48 距离为 2，2001:db8:5678::/48 距离为 3
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RC advertises 2001:db8:5678::/48 at a distance of 2 and 2001:db8:1234::/48 at
    a distance of 3
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC 广告 2001:db8:5678::/48 距离为 2，2001:db8:1234::/48 距离为 3
- en: These summary advertisements are flooded through the backbone area attached
    to routers RB and RC. In its routing table, router RA selects the summary advertised
    by RB to reach 2001:db8:1234::/48 and the summary advertised by RC to reach 2001:db8:5678::/48.
    Inside area 1, router RA advertises a summary indicating that 2001:db8:1234::/48
    and 2001:db8:5678::/48 are both at a distance of 3 from itself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些摘要广告将通过连接到路由器 RB 和 RC 的骨干区域进行泛洪。在其路由表中，路由器 RA 选择 RB 广告的摘要以到达 2001:db8:1234::/48，并选择
    RC 广告的摘要以到达 2001:db8:5678::/48。在区域 1 内，路由器 RA 广告一个摘要，表明 2001:db8:1234::/48 和 2001:db8:5678::/48
    都距离自身 3。
- en: 'On the other hand, consider the prefixes 2001:db8:aaaa:0000::/64 and 2001:db8:aaaa:0001::/64
    that are inside area 1. Router RA is the only area border router that is attached
    to this area. This router can create two different network summary advertisements
    :'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，考虑位于区域 1 内的前缀 2001:db8:aaaa:0000::/64 和 2001:db8:aaaa:0001::/64。RA 是唯一连接到该区域的区域边界路由器。该路由器可以创建两个不同的网络摘要广告：
- en: 2001:db8:aaaa:0001::/64 at a distance of 1 and 2001:db8:aaaa:0000::/64 at a
    distance of 2 from RA
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001:db8:aaaa:0001::/64 距离 RA 为 1，2001:db8:aaaa:0000::/64 距离 RA 为 2
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 2001:db8:aaaa:0000::/63 at a distance of 2 from RA
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001:db8:aaaa:0000::/63 距离 RA 为 2
- en: The first summary advertisement provides precise information about the distance
    used to reach each prefix. However, all routers in the network have to maintain
    a route towards 2001:db8:aaaa:0000::/64 and a route towards 2001:db8:aaaa:0001::/64
    that are both via router RA. The second advertisement would improve the scalability
    of OSPF by reducing the number of routes that are advertised across area boundaries.
    However, in practice this requires manual configuration on the border routers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条摘要广告提供了关于到达每个前缀所使用的距离的精确信息。然而，网络中的所有路由器都必须维护指向 2001:db8:aaaa:0000::/64 和指向
    2001:db8:aaaa:0001::/64 的路由，这两条路由都通过路由器 RA。第二条广告将通过减少跨区域边界广告的路由数量来提高 OSPF 的可扩展性。然而，在实践中，这需要在边界路由器上进行手动配置。
- en: The second OSPF particularity that is worth discussing is the support of Local
    Area Networks (LAN). As shown in figure [Fig. 150](#fig-ospf-lan), several routers
    may be attached to the same LAN.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个值得讨论的 OSPF 特殊性是支持本地局域网（LAN）。如图 [图 150](#fig-ospf-lan) 所示，多个路由器可能连接到同一个局域网。
- en: '![Figure made with TikZ](../Images/b61c40a915c22075c5f71b026344c0d8.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/b61c40a915c22075c5f71b026344c0d8.png)'
- en: Fig. 150 A LAN with routers
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 150 带有路由器的局域网
- en: 'A first solution to support such a LAN with a link-state routing protocol would
    be to consider that a LAN is equivalent to a full-mesh of point-to-point links
    as if each router can directly reach any other router on the LAN. However, this
    approach has two important drawbacks :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此类局域网和链路状态路由协议的第一个解决方案是考虑局域网相当于一个点对点链路的全网状结构，就像每个路由器都可以直接到达局域网上的任何其他路由器一样。然而，这种方法有两个重要的缺点：
- en: Each router must exchange HELLOs and link state packets with all the other routers
    on the LAN. This increases the number of OSPF packets that are sent and processed
    by each router.
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个路由器必须与局域网上的所有其他路由器交换 HELLO 和链路状态数据包。这增加了每个路由器发送和处理的 OSPF 数据包的数量。
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Remote routers, when looking at the topology distributed by OSPF, consider that
    there is a full-mesh of links between all the LAN routers. Such a full-mesh implies
    a lot of redundancy in case of failure, while in practice the entire LAN may completely
    fail. In case of a failure of the entire LAN, all routers need to detect the failures
    and flood link state packets before the LAN is completely removed from the OSPF
    topology by remote routers.
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程路由器在查看OSPF分发的拓扑时，认为所有局域网路由器之间存在全连接的链路。这种全连接意味着在故障情况下存在大量的冗余，而在实践中，整个局域网可能会完全失效。在局域网完全从远程路由器的OSPF拓扑中移除之前，所有路由器都需要检测故障并传播链路状态包。
- en: To better represent LANs and reduce the number of OSPF packets that are exchanged,
    OSPF handles LAN differently. When OSPF routers boot on a LAN, they elect [[3]](#felection)
    one of them as the Designated Router (DR) [**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html).
    The DR router represents the local area network, and advertises the LAN’s subnet.
    Furthermore, LAN routers only exchange HELLO packets with the DR. Thanks to the
    utilization of a DR, the topology of the LAN appears as a set of point-to-point
    links connected to the DR router.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地表示局域网并减少交换的OSPF数据包数量，OSPF对局域网的处理方式不同。当OSPF路由器在局域网启动时，它们会选举 [[3]](#felection)
    其中一个作为指定路由器（DR）[**RFC 2328**](https://datatracker.ietf.org/doc/html/rfc2328.html)。指定路由器代表本地局域网，并通告局域网的子网。此外，局域网路由器只与DR交换HELLO包。得益于DR的使用，局域网的拓扑结构看起来像是一组连接到DR路由器的点对点链路。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: How to quickly detect a link failure ?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如何快速检测链路故障？
- en: 'Network operators expect an OSPF network to be able to quickly recover from
    link or router failures [[VPD2004]](../bibliography.html#vpd2004). In an OSPF
    network, the recovery after a failure is performed in three steps [[FFEB2005]](../bibliography.html#ffeb2005)
    :'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '网络运营商期望OSPF网络能够快速从链路或路由器故障中恢复 [[VPD2004]](../bibliography.html#vpd2004)。在OSPF网络中，故障后的恢复分为三个步骤
    [[FFEB2005]](../bibliography.html#ffeb2005) :'
- en: the routers that are adjacent to the failure detect it quickly. The default
    solution is to rely on the regular exchange of HELLO packets. However, the interval
    between successive HELLOs is often set to 10 seconds… Setting the HELLO timer
    down to a few milliseconds is difficult as HELLO packets are created and processed
    by the main CPU of the routers and these routers cannot easily generate and process
    a HELLO packet every millisecond on each of their interfaces. A better solution
    is to use a dedicated failure detection protocol such as the Bidirectional Forwarding
    Detection (BFD) protocol defined in [[KW2009]](../bibliography.html#kw2009) that
    can be implemented directly on the router interfaces. Another solution to be able
    to detect the failure is to instrument the physical and the datalink layer so
    that they can interrupt the router when a link fails. Unfortunately, such a solution
    cannot be used on all types of physical and datalink layers.
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻近故障的路由器能快速检测到故障。默认的解决方案是依赖于HELLO包的常规交换。然而，连续HELLO包之间的间隔通常设置为10秒……将HELLO计时器降低到几毫秒是困难的，因为HELLO包是由路由器的主CPU创建和处理的，这些路由器无法轻易地在每个接口上每毫秒生成和处理一个HELLO包。一个更好的解决方案是使用如双向转发检测（BFD）协议这样的专用故障检测协议，该协议在
    [[KW2009]](../bibliography.html#kw2009) 中定义，可以直接在路由器接口上实现。另一种能够检测故障的解决方案是对物理层和数据链路层进行测量，以便在链路故障时中断路由器。不幸的是，这种解决方案不能用于所有类型的物理层和数据链路层。
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the routers that have detected the failure flood their updated link state packets
    in the network
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测到故障的路由器会在网络中传播它们更新的链路状态包
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all routers update their routing table
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有路由器更新它们的路由表
- en: A last, but operationally important, point needs to be discussed about intradomain
    routing protocols such as OSPF and IS-IS. Intradomain routing protocols always
    select the shortest path for each destination. In practice, there are often several
    equal paths towards the same destination. When a router computes several equal
    cost paths towards one destination, it can use these paths in different ways.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，需要讨论关于OSPF和IS-IS等域内路由协议的一些问题。域内路由协议始终为每个目的地选择最短路径。在实践中，往往有多个通往同一目的地的等价路径。当路由器计算通往一个目的地的多个等价成本路径时，它可以以不同的方式使用这些路径。
- en: A first approach is to select one of the equal cost paths (e.g. the first or
    the last path found by the SPF computation) and install it in the forwarding table.
    In this case, only one path is used to reach each destination.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的方法是选择一条等价成本路径（例如，SPF计算找到的第一条或最后一条路径）并将其安装到转发表中。在这种情况下，每个目的地只使用一条路径。
- en: A second approach is to install all equal cost paths [[4]](#fmaxpaths) in the
    forwarding table and load-balance the packets on the different paths. Consider
    the case where a router has N different outgoing interfaces to reach destination
    d. A first possibility to load-balance the traffic among these interfaces is to
    use round-robin. Round-robin allows equally balancing the packets among the N
    outgoing interfaces. This equal load-balancing is important in practice because
    it allows better spreading the load throughout the network. However, few networks
    use this round-robin strategy to load-balance traffic on routers. The main drawback
    of round-robin is that packets that belong to the same flow (e.g. TCP connection)
    may be forwarded over different paths. If packets belonging to the same TCP connection
    are sent over different paths, they will probably experience different delays
    and arrive out-of-sequence at their destination. When a TCP receiver detects out-of-order
    segments, it sends duplicate acknowledgments that may cause the sender to initiate
    a fast retransmission and enter congestion avoidance. Thus, out-of-order segments
    may lead to lower TCP performance. This is annoying for a load-balancing technique
    whose objective is to improve the network performance by spreading the load.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是将所有等价成本路径[[4]](#fmaxpaths)安装到转发表中，并在不同路径上负载均衡数据包。考虑一个路由器有N个不同的输出接口来到达目的地d的情况。在这些接口之间负载均衡流量的第一种可能性是使用轮询。轮询允许在N个输出接口之间平均分配数据包。这种负载均衡在实践中的重要性在于它允许更好地在整个网络中分散负载。然而，很少有网络使用这种轮询策略在路由器上负载均衡流量。轮询的主要缺点是，属于同一流（例如，TCP连接）的数据包可能会被转发到不同的路径。如果属于同一TCP连接的数据包被发送到不同的路径，它们可能会经历不同的延迟，并在目的地以乱序到达。当TCP接收器检测到乱序段时，它会发送重复的确认，这可能导致发送方启动快速重传并进入拥塞避免。因此，乱序段可能会导致TCP性能降低。这对于旨在通过分散负载来提高网络性能的负载均衡技术来说是个麻烦事。
- en: To efficiently spread the load over different paths, routers need to implement
    per-flow load-balancing. This implies that they must forward all the packets that
    belong to the same flow on the same path. Since a TCP connection is always identified
    by the four-tuple (source and destination addresses, source and destination ports),
    one possibility would be to select an outgoing interface upon arrival of the first
    packet of the flow and store this decision in the router’s memory. Unfortunately,
    such a solution does not scale since the required memory grows with the number
    of TCP connections that pass through the router.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同路径上高效地分散负载，路由器需要实现按流负载均衡。这意味着它们必须在相同的路径上转发属于同一流的全部数据包。由于TCP连接始终由四元组（源和目的地址、源和目的端口）标识，一个可能的选择是在流的第一数据包到达时选择一个输出接口，并将此决策存储在路由器的内存中。不幸的是，这种解决方案无法扩展，因为所需的内存会随着通过路由器的TCP连接数量增长而增长。
- en: 'Fortunately, it is possible to perform per-flow load balancing without maintaining
    any state on the router. Most routers today use hash functions for this purpose
    [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html). When a packet
    arrives, the router extracts the Next Header information and the four-tuple from
    the packet and computes :'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以在不维护任何路由器状态的情况下执行按流负载均衡。今天的大多数路由器都使用哈希函数来完成此目的[**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html)。当一个数据包到达时，路由器从数据包中提取下一个头部信息以及四元组，并计算：
- en: \(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)
- en: In this formula, N is the number of outgoing interfaces on the equal cost paths
    towards the packet’s destination. Various hash functions are possible, including
    CRC, checksum or MD5 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html).
    Since the hash function is computed over the four-tuple, the same hash value will
    be computed for all packets belonging to the same flow. This prevents reordering
    due to load balancing inside the network. Most routers support this kind of load-balancing
    today [[ACO+2006]](../bibliography.html#aco-2006).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，N 是指向数据包目的地的等价成本路径上出接口的数量。可能的哈希函数包括 CRC、校验和或 MD5 [**RFC 2991**](https://datatracker.ietf.org/doc/html/rfc2991.html)。由于哈希函数是在四元组上计算的，因此属于同一流的所有数据包将计算相同的哈希值。这防止了由于网络内部负载均衡引起的重新排序。如今，大多数路由器都支持这种类型的负载均衡
    [[ACO+2006]](../bibliography.html#aco-2006)。
- en: Footnotes
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
