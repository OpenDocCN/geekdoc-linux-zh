- en: Share data between handles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在句柄之间共享数据
- en: Sometimes applications need to share data between transfers. All easy handles
    added to the same multi handle automatically get a lot of sharing done between
    the handles in that same multi handle, but sometimes that is not exactly what
    you want.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时应用程序需要在传输之间共享数据。添加到同一多句柄的所有简单句柄会自动在同一个多句柄中的句柄之间完成大量的共享，但有时这并不是你想要的。
- en: Multi handle
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多句柄
- en: All easy handles added to the same multi handle automatically share [connection
    cache](ch233.xhtml#transfers__conn__reuse__md) and [dns cache](ch234.xhtml#transfers__conn__names__md).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有添加到同一多句柄的简单句柄自动共享 [连接缓存](ch233.xhtml#transfers__conn__reuse__md) 和 [dns 缓存](ch234.xhtml#transfers__conn__names__md)。
- en: Sharing between easy handles
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单句柄之间的共享
- en: libcurl has a generic “sharing interface”, where the application creates a “share
    object” that then holds data that can be shared by any number of easy handles.
    The data is then stored and read from the shared object instead of kept within
    the handles that are sharing it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 有一个通用的“共享接口”，其中应用程序创建一个“共享对象”，然后可以由任意数量的简单句柄共享数据。数据随后从共享对象中存储和读取，而不是保留在共享数据的句柄中。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The shared object can be set to share all or any of cookies, connection cache,
    dns cache and SSL session id cache.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 共享对象可以设置为共享所有或任何 cookie、连接缓存、dns 缓存和 SSL 会话 ID 缓存。
- en: 'For example, setting up the share to hold cookies and dns cache:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设置共享以保存 cookie 和 dns 缓存：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You then set up the corresponding transfer to use this share object:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后设置相应的传输以使用此共享对象：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Transfers done with this `curl` handle uses and stores its cookie and dns information
    in the `share` handle. You can set several easy handles to share the same share
    object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 `curl` 句柄完成的传输会将其 cookie 和 dns 信息存储在 `share` 句柄中。你可以设置多个简单句柄以共享相同的共享对象。
- en: What to share
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要共享的内容
- en: '`CURL_LOCK_DATA_COOKIE` - set this bit to share cookie jar. Note that each
    easy handle still needs to get its cookie “engine” started properly to start using
    cookies.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_COOKIE` - 设置此位以共享 cookie jar。请注意，每个简单句柄仍然需要正确启动其 cookie “引擎”才能开始使用
    cookie。'
- en: '`CURL_LOCK_DATA_DNS` - the DNS cache is where libcurl stores addresses for
    resolved hostnames for a while to make subsequent lookups faster.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_DNS` - DNS 缓存是 libcurl 存储解析的主机名的地址的地方，以便在后续查找中更快。'
- en: '`CURL_LOCK_DATA_SSL_SESSION` - the SSL session ID cache is where libcurl store
    resume information for SSL connections to be able to resume a previous connection
    faster.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_SSL_SESSION` - SSL 会话 ID 缓存是 libcurl 存储用于 SSL 连接的恢复信息的地方，以便能够更快地恢复之前的连接。'
- en: '`CURL_LOCK_DATA_CONNECT` - when set, this handle uses a shared connection cache
    and thus is more likely to find existing connections to re-use etc, which may
    result in faster performance when doing multiple transfers to the same host in
    a serial manner.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_CONNECT` - 当设置时，此句柄使用共享连接缓存，因此更有可能找到现有的连接以重新使用等，这可能在以串行方式对同一主机进行多次传输时提高性能。'
- en: Locking
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定
- en: If you want have the share object shared by transfers in a multi-threaded environment.
    Perhaps you have a CPU with many cores and you want each core to run its own thread
    and transfer data, but you still want the different transfers to share data. Then
    you need to set the mutex callbacks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在多线程环境中让传输共享共享对象。也许你有一个具有许多核心的 CPU，你希望每个核心运行其自己的线程并传输数据，但你仍然希望不同的传输共享数据。那么你需要设置互斥回调。
- en: If you do not use threading and you *know* you access the shared object in a
    serial one-at-a-time manner you do not need to set any locks. But if there is
    ever more than one transfer that access share object at a time, it needs to get
    mutex callbacks setup to prevent data destruction and possibly even crashes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用线程并且 *知道* 你以串行方式逐个访问共享对象，则不需要设置任何锁。但如果同时有多个传输访问共享对象，则需要设置互斥回调以防止数据损坏甚至崩溃。
- en: 'Since libcurl itself does not know how to lock things or even what threading
    model you are using, you must make sure to do mutex locks that only allows one
    access at a time. A lock callback for a pthreads-using application could look
    similar to:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 libcurl 本身不知道如何锁定事物或甚至不知道你使用的是哪种线程模型，你必须确保只允许一次访问的互斥锁。一个用于 pthreads 应用程序的锁回调可能如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the corresponding unlock callback could look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的解锁回调可能如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unshare
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消共享
- en: A transfer uses the share object during its transfer and share what that object
    has been specified to share with other handles sharing the same object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输过程中，传输使用共享对象，并将该对象被指定共享的内容与其他共享相同对象的句柄共享。
- en: In a subsequent transfer, `CURLOPT_SHARE` can be set to NULL to prevent a transfer
    from continuing to share. It that case, the handle may start the next transfer
    with empty caches for the data that was previously shared.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续传输中，可以将`CURLOPT_SHARE`设置为NULL以防止传输继续共享。在这种情况下，句柄可能以空缓存开始下一次传输，这些缓存是之前共享的数据。
- en: 'Between two transfers, a share object can also get updated to share a different
    set of properties so that the handles that share that object shares a different
    set of data next time. You remove an item to share from a shared object with the
    curl_share_setopt()’s `CURLSHOPT_UNSHARE` option like this when unsharing DNS
    data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在两次传输之间，共享对象也可以更新以共享不同的属性集，这样共享该对象的句柄在下一次共享时将共享不同的数据集。当取消共享DNS数据时，可以使用curl_share_setopt()的`CURLSHOPT_UNSHARE`选项从共享对象中移除要共享的项目：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
