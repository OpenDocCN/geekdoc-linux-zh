- en: Shell Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 功能
- en: 原文：[https://learnbyexample.github.io/cli-computing/shell-features.html](https://learnbyexample.github.io/cli-computing/shell-features.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://learnbyexample.github.io/cli-computing/shell-features.html](https://learnbyexample.github.io/cli-computing/shell-features.html)
- en: This chapter focuses on Bash shell features like quoting mechanisms, wildcards,
    redirections, command grouping, process substitution, command substitution, etc.
    Others will be discussed in later chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍Bash shell功能，如引用机制、通配符、重定向、命令分组、进程替换、命令替换等。其他内容将在后续章节中讨论。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The [example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)
    directory has the scripts and sample input files used in this chapter.'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) [example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)
    目录包含本章中使用的脚本和示例输入文件。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Some of the examples
    in this chapter use commands that will be discussed in later chapters. Basic description
    of what such commands do have been added here and you''ll also see more examples
    in the rest of the chapters.'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 本章中的一些示例使用了将在后续章节中讨论的命令。已在此处添加了此类命令的基本描述，你将在本章的其余部分看到更多示例。'
- en: '[Quoting mechanisms](#quoting-mechanisms)'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[引用机制](#quoting-mechanisms)'
- en: This section will quote (*heh*) the relevant definitions from the [bash manual](https://www.gnu.org/software/bash/manual/bash.html#Quoting)
    and provide some examples for each of the four mechanisms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将引用 (*嘿*) 来自 [bash 手册](https://www.gnu.org/software/bash/manual/bash.html#Quoting)
    的相关定义，并为四种机制中的每一种提供一些示例。
- en: '*1)* **Escape Character**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*1)* **转义字符**'
- en: A non-quoted backslash `\` is the Bash escape character. It preserves the literal
    value of the next character that follows, with the exception of newline.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未引用的反斜杠 `\` 是Bash的转义字符。它保留下一个字符的原始值，除了换行符。
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**metacharacter**: A character that, when unquoted, separates words. A metacharacter
    is a space, tab, newline, or one of the following characters: `|`, `&`, `;`, `(`,
    `)`, `<`, or `>`.'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**元字符**：一个未引用时分隔单词的字符。元字符是空格、制表符、换行符或以下字符之一：`|`、`&`、`;`、`(`、`)`、`<` 或 `>`。'
- en: 'Here''s an example where unquoted shell metacharacter causes an error:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，其中未引用的shell元字符导致错误：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here''s an example where the subtler issue might not be apparent at first
    glance:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，其中微妙的问题可能一开始并不明显：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*2)* **Single Quotes**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*2)* **单引号**'
- en: Enclosing characters in single quotes (`'`) preserves the literal value of each
    character within the quotes. A single quote may not occur between single quotes,
    even when preceded by a backslash.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将字符放在单引号 (`'`) 内会保留引号内每个字符的原始值。单引号之间不能出现单引号，即使前面有反斜杠也是如此。
- en: 'No character is special within single quoted strings. Here''s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串内没有特殊字符。下面是一个示例：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can place strings represented by different quoting mechanisms next to each
    other to concatenate them together. Here''s an example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将由不同引用机制表示的字符串放在一起，以将它们连接起来。下面是一个示例：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*3)* **Double Quotes**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*3)* **双引号**'
- en: Enclosing characters in double quotes (`"`) preserves the literal value of all
    characters within the quotes, with the exception of `$`, `` ` ``, `\`, and, when
    history expansion is enabled, `!`.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将字符放在双引号 (`"`) 内会保留引号内所有字符的原始值，除了 `$`、`` ` ``、`\` 以及当启用历史扩展时 `!`。
- en: 'Here''s an example showing variable interpolation within double quotes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了双引号内的变量插值：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unless you specifically want the shell to interpret the contents of a variable,
    you should always quote the variable to avoid issues due to the presence of shell
    metacharacters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确希望shell解释变量的内容，否则你应该始终引用变量，以避免由于shell元字符的存在而产生的问题。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See also [unix.stackexchange:
    Why does my shell script choke on whitespace or other special characters?](https://unix.stackexchange.com/q/131766/109046).'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 参见 [unix.stackexchange:
    Why does my shell script choke on whitespace or other special characters?](https://unix.stackexchange.com/q/131766/109046)。'
- en: '*4)* **ANSI-C Quoting**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*4)* **ANSI-C 引用**'
- en: Words of the form `$'string'` are treated specially. The word expands to string,
    with backslash-escaped characters replaced as specified by the ANSI C standard.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 形式为 `$'string'` 的单词被特别处理。该单词扩展为字符串，其中反斜杠转义字符按照ANSI C标准进行替换。
- en: This form of quoting helps you use escape sequences like `\t` for tab, `\n`
    for newline and so on. You can also represent characters using their codepoint
    values in octal and hexadecimal formats.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种引号形式可以帮助你使用转义序列，如 `\t` 用于制表符，`\n` 用于换行符等。你也可以使用八进制和十六进制格式表示字符的代码点值。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`printf` is a shell builtin which you can use to format arguments (similar
    to the `printf()` function from the `C` programming language). This command will
    be used in many more examples to come.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 是一个 shell 内置命令，你可以用它来格式化参数（类似于 `C` 编程语言中的 `printf()` 函数）。这个命令将在接下来的更多示例中使用。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See [bash manual: ANSI-C
    Quoting](https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting)
    for complete list of supported escape sequences. See `man ascii` for a table of
    ASCII characters and their numerical representations.'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 查看 [bash 手册：ANSI-C
    引用](https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting) 以获取支持的转义序列的完整列表。查看
    `man ascii` 以获取 ASCII 字符及其数值表示的表格。'
- en: '[Wildcards](#wildcards)'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[通配符](#wildcards)'
- en: It is relatively easy to specify complete filenames as command arguments when
    they are few in number. And you could use features like tab completion and middle
    mouse button click (which pastes the last highlighted text) to assist in such
    cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件数量较少时，指定完整的文件名作为命令参数相对容易。你可以使用像制表符补全和中鼠标按钮点击（粘贴最后高亮文本）这样的功能来辅助这种情况。
- en: But what to do if you have to deal with tens and hundreds of files (or even
    more)? If applicable, one way is to match all the files based on a common pattern
    in their filenames, for example extensions like `.py`, `.txt` and so on. Wildcards
    (globs) will help in such cases. This feature is provided by the shell, and thus
    individual commands need not worry about implementing them. Pattern matching supported
    by wildcards are somewhat similar to regular expressions, but there are fundamental
    and syntactical differences between them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你必须处理成百上千个文件（甚至更多）怎么办？如果适用，一种方法是根据它们文件名中的公共模式匹配所有文件，例如像 `.py`、`.txt` 等扩展名。在这种情况下，通配符（glob）会有所帮助。这个功能由
    shell 提供，因此单个命令无需担心实现它们。通配符支持的匹配模式与正则表达式有些相似，但它们之间存在根本性和语法上的差异。
- en: 'Some of the commonly used wildcards are listed below:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了一些常用的通配符：
- en: '`*` match any character, zero or more times'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 匹配任何字符，零次或多次'
- en: as a special case, `*` won't match the starting `.` of hidden files unless the
    `dotglob` shell option is set
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为特殊情况，`*` 不会匹配隐藏文件开头的 `.`，除非设置了 `dotglob` shell 选项
- en: '`?` match any character exactly once'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 匹配任何字符正好一次'
- en: '`[set149]` match any of these characters once'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[set149]` 匹配这些字符中的任意一个'
- en: '`[^set149]` match any characters *except* the given set of characters'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^set149]` 匹配除了给定字符集之外的任何字符'
- en: you can also use `[!set149]` to negate the character class
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用 `[!set149]` 来否定字符集
- en: '`[a-z]` match a range of characters from `a` to `z`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-z]` 匹配从 `a` 到 `z` 的字符范围'
- en: '`[0-9a-fA-F]` match any hexadecimal character'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0-9a-fA-F]` 匹配任何十六进制字符'
- en: 'And here are some examples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since some characters are special inside the character class, you need special
    placement to treat them as ordinary characters:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符类内部的一些字符是特殊的，你需要特殊的位置来将它们视为普通字符：
- en: '`-` should be the first or the last character in the set'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 应该是集合中的第一个或最后一个字符'
- en: '`^` should be other than the first character'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 应该不是第一个字符'
- en: '`]` should be the first character'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`]` 应该是第一个字符'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A **named character set** is defined by a name enclosed between `[:` and `:]`
    and has to be used within a character class `[]`, along with any other characters
    as needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名字符集** 由 `[:` 和 `:]` 之间的名称定义，并且必须在字符类 `[]` 中使用，以及任何其他所需的字符。'
- en: '| Named set | Description |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 命名集 | 描述 |'
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[:digit:]` | `[0-9]` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `[:digit:]` | `[0-9]` |'
- en: '| `[:lower:]` | `[a-z]` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `[:lower:]` | `[a-z]` |'
- en: '| `[:upper:]` | `[A-Z]` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `[:upper:]` | `[A-Z]` |'
- en: '| `[:alpha:]` | `[a-zA-Z]` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `[:alpha:]` | `[a-zA-Z]` |'
- en: '| `[:alnum:]` | `[0-9a-zA-Z]` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `[:alnum:]` | `[0-9a-zA-Z]` |'
- en: '| `[:word:]` | `[0-9a-zA-Z_]` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `[:word:]` | `[0-9a-zA-Z_]` |'
- en: '| `[:xdigit:]` | `[0-9a-fA-F]` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `[:xdigit:]` | `[0-9a-fA-F]` |'
- en: '| `[:cntrl:]` | control characters — first 32 ASCII characters and 127th (DEL)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `[:cntrl:]` | 控制字符 — 前面的 32 个 ASCII 字符和第 127 个（DEL） |'
- en: '| `[:punct:]` | all the punctuation characters |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `[:punct:]` | 所有标点符号 |'
- en: '| `[:graph:]` | `[:alnum:]` and `[:punct:]` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `[:graph:]` | `[:alnum:]` 和 `[:punct:]` |'
- en: '| `[:print:]` | `[:alnum:]`, `[:punct:]` and space |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `[:print:]` | `[:alnum:]`、`[:punct:]` 和空格 |'
- en: '| `[:ascii:]` | all the ASCII characters |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `[:ascii:]` | 所有 ASCII 字符 |'
- en: '| `[:blank:]` | space and tab characters |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `[:blank:]` | 空格和制表符字符 |'
- en: '| `[:space:]` | whitespace characters |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `[:space:]` | 空白字符 |'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) As mentioned before,
    you can use `echo` to test how the wildcards will expand before using a command
    to act upon the matching files. For example, `echo *.txt` before using commands
    like `rm *.txt`. One difference compared to `ls` is that `echo` will display the
    wildcard as is instead of showing an error if there''s no match.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 如前所述，您可以使用 `echo` 来测试在使用命令对匹配的文件进行操作之前，通配符将如何展开。例如，在使用
    `rm *.txt` 这样的命令之前，先执行 `echo *.txt`。与 `ls` 相比的一个不同之处在于，如果没有任何匹配项，`echo` 将显示通配符本身而不是显示错误。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See [bash manual: Pattern
    Matching](https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching)
    for more details, information on locale stuff and so on.'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 更多详细信息，包括本地化信息等，请参阅
    [bash 手册：模式匹配](https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching)。'
- en: '[Brace Expansion](#brace-expansion)'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[花括号展开](#brace-expansion)'
- en: 'This is not a wildcard feature, you just get expanded strings. Brace expansion
    has two mechanisms for reducing typing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是通配符功能，您只是得到展开的字符串。花括号展开有两个减少输入的机制：
- en: taking out common portions among multiple strings
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个字符串中提取共同部分
- en: generating a range of characters
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成字符范围
- en: Say you want to create two files named `test_x.txt` and `test_y.txt`. These
    two strings have something in common at the start and the end. You can specify
    the unique portions as comma separated strings within a pair of curly braces and
    put the common parts around the braces. Multiple braces can be used as needed.
    Use `echo` for testing purposes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想创建两个名为 `test_x.txt` 和 `test_y.txt` 的文件。这两个字符串在开头和结尾处有共同点。您可以将独特的部分指定为逗号分隔的字符串，放在一对大括号内，并将共同的部分放在大括号周围。根据需要可以使用多个大括号。使用
    `echo` 进行测试。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To generate a range, specify numbers or single characters separated by `..`
    and an optional third argument as the step value. Here are some examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个范围，指定由 `..` 分隔的数字或单个字符，以及可选的第三个参数作为步长值。以下是一些示例：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the use of braces doesn''t match the expansion syntax, it will be left as
    is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大括号的使用不符合展开语法，它将保持原样：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Extended and Recursive globs](#extended-and-recursive-globs)'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[扩展和递归通配符](#extended-and-recursive-globs)'
- en: 'From `man bash`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `man bash`：
- en: '| Extended glob | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 扩展通配符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `?(pattern-list)` | Matches zero or one occurrence of the given patterns
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `?(pattern-list)` | 匹配给定模式零次或一次出现 |'
- en: '| `*(pattern-list)` | Matches zero or more occurrences of the given patterns
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `*(pattern-list)` | 匹配给定模式零次或多次出现 |'
- en: '| `+(pattern-list)` | Matches one or more occurrences of the given patterns
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `+(pattern-list)` | 匹配给定模式一次或多次出现 |'
- en: '| `@(pattern-list)` | Matches one of the given patterns |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `@(pattern-list)` | 匹配给定模式之一 |'
- en: '| `!(pattern-list)` | Matches anything except one of the given patterns |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `!(pattern-list)` | 匹配除了给定模式之一的所有内容 |'
- en: Extended globs are disabled by default. You can use the `shopt` builtin to set/unset
    **sh**ell **opt**ions like `extglob`, `globstar`, etc. You can also check what
    is the current status of such options.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展通配符默认是禁用的。您可以使用 `shopt` 内置命令来设置/取消设置 **sh**ell **opt**ions，如 `extglob`、`globstar`
    等。您还可以检查这些选项的当前状态。
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are some examples, assuming `extglob` option has already been set:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，假设已经设置了 `extglob` 选项：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you enable the `globstar` option, you can recursively match filenames within
    a specified path.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启用 `globstar` 选项，您可以在指定路径内递归地匹配文件名。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Add the `shopt` invocations
    to `~/.bashrc` if you want these settings applied at terminal startup. This will
    be discussed in the [Shell Customization](./shell-customization.html) chapter.'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 如果您想在终端启动时应用这些设置，请将
    `shopt` 调用添加到 `~/.bashrc` 中。这将在 [Shell 自定义](./shell-customization.html) 章节中讨论。'
- en: '[set](#set)'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[set](#set)'
- en: 'The `set` builtin command helps you to set or unset values of shell options
    and positional parameters. Here are some examples for shell options:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 内置命令可以帮助您设置或取消设置 shell 选项和位置参数的值。以下是一些 shell 选项的示例：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You''ll see more examples (for example, `set -x`) in later chapters. See [bash
    manual: Set Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)
    for documentation.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在后面的章节中看到更多示例（例如，`set -x`）。有关文档，请参阅 [bash 手册：Set 内置](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)。
- en: '[Pipelines](#pipelines)'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[管道](#pipelines)'
- en: 'The pipe control operator `|` helps you connect the output of a command as
    the input of another command. This operator vastly reduces the need for temporary
    intermediate files. As discussed previously in the [Unix Philosophy](./command-line-overview.html#unix-philosophy)
    section, command line tools usually specialize in a single task. If you can break
    down a problem into smaller tasks, the pipe operator will come in handy often.
    Here are some examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 管道控制操作符`|`帮助你将一个命令的输出作为另一个命令的输入。这个操作符大大减少了临时中间文件的需求。如前所述，在[Unix 哲学](./command-line-overview.html#unix-philosophy)部分，命令行工具通常专注于单一任务。如果你可以将问题分解成更小的任务，管道操作符将经常派上用场。以下是一些示例：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the above examples, `ls` and `du` perform their own tasks of displaying list
    of files and showing file sizes respectively. After that, the `wc` and `sort`
    commands take care of counting and sorting the lines respectively. In such cases,
    the pipe operator saves you the trouble of dealing with temporary data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`ls`和`du`分别执行显示文件列表和显示文件大小的任务。之后，`wc`和`sort`命令分别负责计数和排序行。在这种情况下，管道操作符可以节省你处理临时数据的问题。
- en: Note that the `%q` format specifier in `printf` helps you quote the arguments
    in a way that is recognizable by the shell. The `-q` option for `ls` substitutes
    nongraphic characters in the filenames with a `?` character. Both of these are
    workarounds to prevent the counting process from getting sidetracked due to characters
    like newline in the filenames.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`printf`中的`%q`格式说明符可以帮助你以shell可识别的方式引用参数。`ls`的`-q`选项将文件名中的非图形字符替换为`?`字符。这两个都是防止由于文件名中的换行符等字符而导致计数过程偏离的解决方案。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The pipe control operator
    `|&` will be discussed later in this chapter.'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 管道控制操作符`|&`将在本章后面讨论。'
- en: '[tee](#tee)'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[tee](#tee)'
- en: 'Sometimes, you might want to display the command output on the terminal as
    well as require the results for later use. In such cases, you can use the `tee`
    command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望同时在终端上显示命令输出并需要结果以供以后使用。在这种情况下，你可以使用`tee`命令：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Redirection](#redirection)'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[重定向](#redirection)'
- en: 'From [bash manual: Redirections](https://www.gnu.org/software/bash/manual/bash.html#Redirections):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[bash 手册：重定向](https://www.gnu.org/software/bash/manual/bash.html#Redirections)：
- en: Before a command is executed, its input and output may be *redirected* using
    a special notation interpreted by the shell. Redirection allows commands' file
    handles to be duplicated, opened, closed, made to refer to different files, and
    can change the files the command reads from and writes to. Redirection may also
    be used to modify file handles in the current shell execution environment.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在执行命令之前，可以使用特殊符号通过shell进行输入和输出的重定向。重定向允许命令的文件句柄被复制、打开、关闭、指向不同的文件，并且可以改变命令读取和写入的文件。重定向还可以用于修改当前shell执行环境中的文件句柄。
- en: 'There are three standard data streams:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个标准数据流：
- en: '**standard input** (`stdin` — file descriptor 0)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准输入** (`stdin` — 文件描述符 0)'
- en: '**standard output** (`stdout` — file descriptor 1)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准输出** (`stdout` — 文件描述符 1)'
- en: '**standard error** (`stderr` — file descriptor 2)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准错误** (`stderr` — 文件描述符 2)'
- en: Both the standard output and error streams are displayed on the terminal by
    default. The `stderr` stream is used when something goes wrong with the command
    usage. Each of these three streams have a predefined [file descriptor](https://en.wikipedia.org/wiki/File_descriptor)
    as mentioned above. In this section, you'll see how to redirect these three streams.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，标准输出和错误流都会在终端上显示。当命令使用出现问题时，会使用`stderr`流。上述三个流都如前所述有预定义的[文件描述符](https://en.wikipedia.org/wiki/File_descriptor)。在本节中，你将了解如何重定向这三个流。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Redirections can be
    placed anywhere, but they are usually used at the start or end of a command. For
    example, the following two commands are equivalent:'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 重定向可以放置在任何位置，但通常用于命令的开始或结束部分。例如，以下两个命令是等效的：'
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Space characters between
    the redirection operators and the filename are optional.'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 在重定向操作符和文件名之间添加空格字符是可选的。'
- en: '[Redirecting output](#redirecting-output)'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[重定向输出](#redirecting-output)'
- en: You can use the `>` operator to redirect the standard output of a command to
    a file. A number prefix can be added to the `>` operator to work with that particular
    file descriptor. Default is `1` (recall that the file descriptor for `stdout`
    is `1`), so `1>` and `>` perform the same operation. Use `>>` to append the output
    to a file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `>` 操作符将命令的标准输出重定向到文件。可以在 `>` 操作符前添加一个数字前缀来与特定的文件描述符一起使用。默认是 `1`（回想一下，`stdout`
    的文件描述符是 `1`），所以 `1>` 和 `>` 执行相同的操作。使用 `>>` 将输出追加到文件。
- en: The filename provided to the `>` and `>>` operators will be created if a regular
    file of that name doesn't exist yet. If the file already exists, `>` will overwrite
    that file whereas `>>` will append the contents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给 `>` 和 `>>` 操作符的文件名将在不存在时创建。如果文件已存在，`>` 将覆盖该文件，而 `>>` 将追加内容。
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) You can use `/dev/null`
    as a filename to discard the output, to provide an empty file as input for a command,
    etc.'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 你可以使用 `/dev/null` 作为文件名来丢弃输出，为命令提供空文件作为输入等。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) You can use `set noclobber`
    to prevent overwriting if a file already exists. When the `noclobber` option is
    set, you can still overwrite a file by using `>|` instead of the `>` operator.'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 你可以使用 `set noclobber`
    来防止覆盖已存在的文件。当设置了 `noclobber` 选项时，你仍然可以通过使用 `>|` 而不是 `>` 操作符来覆盖文件。'
- en: '[Redirecting input](#redirecting-input)'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[重定向输入](#redirecting-input)'
- en: 'Some commands like `tr` and `datamash` can only work with data from the standard
    input. This isn''t an issue when you are piping data from another command, for
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令如 `tr` 和 `datamash` 只能处理来自标准输入的数据。当你从另一个命令中管道数据时，这不是一个问题，例如：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use the `<` redirection operator if you want to pass data from a file
    to such commands. The default prefix here is `0`, which is the file descriptor
    for `stdin` data. Here''s an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将数据从文件传递给这样的命令，可以使用 `<` 重定向操作符。这里的默认前缀是 `0`，它是 `stdin` 数据的文件描述符。以下是一个示例：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In some cases, a tool behaves differently when processing `stdin` data compared
    to file input. Here''s an example with `wc -l` to report the total number of lines
    in the input:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个工具在处理 `stdin` 数据时与文件输入的行为不同。以下是一个使用 `wc -l` 报告输入中总行数的示例：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sometimes, you need to pass `stdin` data as well as other file inputs to a
    command. In such cases, you can use `-` to represent data from the standard input.
    Here''s an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要将 `stdin` 数据以及其他文件输入传递给一个命令。在这种情况下，你可以使用 `-` 来表示来自标准输入的数据。以下是一个示例：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Even though a command accepts file input directly as an argument, redirecting
    can help for interactive usage. Here''s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使命令可以直接接受文件输入作为参数，重定向也可以帮助进行交互式使用。以下是一个示例：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) ![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png)
    Don''t use `cat filename | cmd` for passing file content as `stdin` data, unless
    you need to concatenate data from multiple input files. See [wikipedia: UUOC](https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat)
    and [Useless Use of Cat Award](https://porkmail.org/era/unix/award.html) for more
    details.'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) ![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png)
    不要使用 `cat filename | cmd` 来将文件内容作为 `stdin` 数据传递，除非你需要连接多个输入文件中的数据。有关详细信息，请参阅 [wikipedia:
    UUOC](https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat) 和 [Useless
    Use of Cat Award](https://porkmail.org/era/unix/award.html)。'
- en: '[Redirecting error](#redirecting-error)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[重定向错误](#redirecting-error)'
- en: 'Recall that the file descriptor for `stderr` is `2`. So, you can use `2>` to
    redirect standard error to a file. Use `2>>` if you need to append the contents.
    Here''s an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`stderr` 的文件描述符是 `2`。因此，你可以使用 `2>` 来将标准错误重定向到文件。如果需要追加内容，请使用 `2>>`。以下是一个示例：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Use `/dev/null` as
    a filename if you need to discard the results.'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 如果你需要丢弃结果，请使用 `/dev/null`
    作为文件名。'
- en: '[Combining stdout and stderr](#combining-stdout-and-stderr)'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[合并 stdout 和 stderr](#combining-stdout-and-stderr)'
- en: 'Newer versions of Bash provide these handy shortcuts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的 Bash 提供了这些方便的快捷方式：
- en: '`&>` redirect both `stdout` and `stderr` (overwrite if file already exists)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&>` 同时重定向 `stdout` 和 `stderr`（如果文件已存在则覆盖）'
- en: '`&>>` redirect both `stdout` and `stderr` (append if file already exists)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&>>` 同时重定向 `stdout` 和 `stderr`（如果文件已存在则追加）'
- en: '`|&` pipe both `stdout` and `stderr` as input to another command'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|&` 将 `stdout` 和 `stderr` 作为输入传递给另一个命令'
- en: 'Here''s an example which assumes `xyz.txt` doesn''t exist, thus leading to
    errors:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个假设 `xyz.txt` 不存在的示例，这会导致错误：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And here''s an example with the `|&` operator:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 `|&` 运算符的示例：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For earlier Bash versions, you''ll have to manually redirect the streams:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较早的 Bash 版本，您必须手动重定向流：
- en: '`1>&2` redirects file descriptor `1` (`stdout`) to the file descriptor `2`
    (`stderr`)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1>&2` 将文件描述符 `1` (`stdout`) 重定向到文件描述符 `2` (`stderr`)。'
- en: '`2>&1` redirects file descriptor `2` (`stderr`) to the file descriptor `1`
    (`stdout`)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2>&1` 将文件描述符 `2` (`stderr`) 重定向到文件描述符 `1` (`stdout`)。'
- en: 'Here are some examples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Waiting for stdin](#waiting-for-stdin)'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[等待 stdin](#waiting-for-stdin)'
- en: Sometimes, you might mistype a command without providing input. And instead
    of getting an error, you'll see the cursor patiently waiting for something. This
    isn't the shell hanging up on you. The command is waiting for you to type data,
    so that it can perform its task.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会不小心输入一个命令而没有提供输入。而不是得到一个错误，您会看到光标耐心地等待。这并不是 shell 在挂起您。命令正在等待您输入数据，以便它可以执行其任务。
- en: Say, you typed `cat` and pressed the Enter key. Seeing the blinking cursor,
    you type some text and press the Enter key again. You'll see the text you just
    typed echoed back to you as `stdout` (which is the functionality of the `cat`
    command). This will continue again and again, until you tell the shell that you
    are done. How to do that? Press `Ctrl+d` on a fresh line or press `Ctrl+d` twice
    at the end of a line. In the latter case, you'll not get a newline character at
    the end of the data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您输入了 `cat` 并按下了 Enter 键。看到闪烁的光标，您输入一些文本并再次按下 Enter 键。您将看到您刚刚输入的文本被作为 `stdout`
    反射回来（这是 `cat` 命令的功能）。这会一直重复，直到您告诉 shell 您已完成。如何做到这一点？在空白行上按 `Ctrl+d` 或者在行尾按两次
    `Ctrl+d`。在后一种情况下，您不会在数据末尾得到换行符。
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Getting output immediately
    after each input line depends on the command''s functionality. Commands like `sort`
    and `shuf` will wait for the entire input data before producing the output.'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 在每条输入行后立即获取输出取决于命令的功能。像
    `sort` 和 `shuf` 这样的命令会在产生输出之前等待整个输入数据。'
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s an example which has output redirection as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含输出重定向的示例：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See also [unix.stackexchange:
    difference between Ctrl+c and Ctrl+d](https://unix.stackexchange.com/q/16333/109046).'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 参见 [unix.stackexchange:
    Ctrl+c 和 Ctrl+d 的区别](https://unix.stackexchange.com/q/16333/109046)。'
- en: '[Here Documents](#here-documents)'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Here Documents](#here-documents)'
- en: 'Here Documents is another way to provide `stdin` data. In this case, the termination
    condition is a line matching a predefined string which is specified after the
    `<<` redirection operator. This is especially helpful for automation, since pressing
    `Ctrl+d` interactively isn''t desirable. Here''s an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Here Documents 是提供 `stdin` 数据的另一种方式。在这种情况下，终止条件是匹配 `<<` 重定向运算符后指定的预定义字符串的行。这对于自动化特别有帮助，因为交互式地按
    `Ctrl+d` 并不理想。下面是一个示例：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the above example, the termination string was enclosed in single quotes as
    a good practice. Doing so prevents parameter expansion, command substitution,
    etc. You can also use `\string` for this purpose. If you use `<&LT-` instead of
    `<<`, leading tab characters can be added at the start of input lines without
    being part of the actual data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，终止字符串被单引号包围，这是一种良好的实践。这样做可以防止参数扩展、命令替换等。您也可以使用 `\string` 来实现这个目的。如果您使用
    `<&LT-` 而不是 `<<`，可以在输入行的开头添加前导制表符，而不会成为实际数据的一部分。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Just like `$` and a
    space represents the primary prompt (`PS1` shell variable), `>` and a space at
    the start of lines represents the secondary prompt `PS2` (applicable for multiline
    commands). Don''t type these characters when you use Here Documents in a shell
    script.'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 就像 `$` 和一个空格代表主要提示符（`PS1`
    shell 变量）一样，行首的 `>` 和一个空格代表次要提示符 `PS2`（适用于多行命令）。在 shell 脚本中使用 Here Documents 时，不要输入这些字符。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See [bash manual: Here
    Documents](https://www.gnu.org/software/bash/manual/bash.html#Here-Documents)
    and [stackoverflow: here documents](https://stackoverflow.com/q/2953081/4082052)
    for more examples and details.'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 参见 [bash 手册：Here Documents](https://www.gnu.org/software/bash/manual/bash.html#Here-Documents)
    和 [stackoverflow：here documents](https://stackoverflow.com/q/2953081/4082052)
    以获取更多示例和详细信息。'
- en: '[Here Strings](#here-strings)'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Here Strings](#here-strings)'
- en: 'This is similar to Here Documents, but the string is passed as an argument
    after the `<<<` redirection operator. Here are some examples:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Here Documents 类似，但字符串是在 `<<<` 重定向运算符之后作为参数传递的。以下是一些示例：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Further Reading](#further-reading)'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading)'
- en: '[Short introduction to shell redirection](https://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于 shell 重定向的简短介绍](https://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection)'
- en: '[Illustrated Redirection Tutorial](https://web.archive.org/web/20221231120128/https://wiki.bash-hackers.org/howto/redirection_tutorial)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图解重定向教程](https://web.archive.org/web/20221231120128/https://wiki.bash-hackers.org/howto/redirection_tutorial)'
- en: '[stackoverflow: Redirect a stream to another file descriptor using >&](https://stackoverflow.com/q/818255/4082052)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[stackoverflow：使用 >& 将流重定向到另一个文件描述符](https://stackoverflow.com/q/818255/4082052)'
- en: '[Difference between 2>&1 >foo and >foo 2>&1](https://mywiki.wooledge.org/BashFAQ/055)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2>&1 >foo 和 >foo 2>&1 之间的区别](https://mywiki.wooledge.org/BashFAQ/055)'
- en: '[stackoverflow: Redirect and append both stdout and stderr to a file](https://stackoverflow.com/q/876239/4082052)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[stackoverflow：将标准输出和标准错误重定向到文件](https://stackoverflow.com/q/876239/4082052)'
- en: '[unix.stackexchange: Examples for <> redirection](https://unix.stackexchange.com/q/164391/109046)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[unix.stackexchange：<> 重定向示例](https://unix.stackexchange.com/q/164391/109046)'
- en: '[Grouping commands](#grouping-commands)'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[命令分组](#grouping-commands)'
- en: 'You can use the `(list)` and `{ list; }` compound commands to redirect content
    for several commands. The former is executed in a subshell whereas the latter
    is executed in the current shell context. Spaces around `()` are optional but
    necessary for the `{}` version. From [bash manual: Lists of Commands](https://www.gnu.org/software/bash/manual/bash.html#Lists):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `(list)` 和 `{ list; }` 复合命令来重定向多个命令的内容。前者在子shell中执行，而后者在当前shell上下文中执行。`()`
    周围的空格对于 `{}` 版本是可选的，但对于 `{}` 版本则是必要的。更多信息请参考 [bash 手册：命令列表](https://www.gnu.org/software/bash/manual/bash.html#Lists)。
- en: A `list` is a sequence of one or more pipelines separated by one of the operators
    `;`, `&`, `&&`, or `||`, and optionally terminated by one of `;`, `&`, or a newline.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`list` 是由一个或多个管道序列组成，这些序列由运算符 `;`、`&`、`&&` 或 `||` 分隔，并且可以由 `;`、`&` 或换行符终止。'
- en: 'Here are some examples of command groupings:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些命令分组的示例：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You might wonder why the second command did not use `< sample.txt` instead
    of repeating the filename twice. The reason is that some commands might read more
    than what is required (for buffering purposes) and thus cause issues for the remaining
    commands. In the `sed+sort` example, the `-u` option guarantees that `sed` will
    not to read more than the required data. See [unix.stackexchange: sort but keep
    header line at the top](https://unix.stackexchange.com/q/11856/109046) for more
    examples and details.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么第二个命令没有使用 `< sample.txt` 而是重复了文件名两次。原因是某些命令可能会读取比所需更多的内容（出于缓冲目的），从而给后续命令造成问题。在
    `sed+sort` 示例中，`-u` 选项确保 `sed` 不会读取超过所需的数据。更多示例和详细信息请参阅 [unix.stackexchange：sort
    but keep header line at the top](https://unix.stackexchange.com/q/11856/109046)。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) You don''t need the
    `()` or `{}` groups to see the results of multiple commands on the terminal. Just
    the `;` separator between the commands would be enough. See also [bash manual:
    Command Execution Environment](https://www.gnu.org/software/bash/manual/bash.html#Command-Execution-Environment).'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 您不需要 `()` 或 `{}` 分组来在终端上查看多个命令的结果。只需在命令之间使用
    `;` 分隔符即可。有关更多信息，请参阅 [bash 手册：命令执行环境](https://www.gnu.org/software/bash/manual/bash.html#Command-Execution-Environment)。'
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[List control operators](#list-control-operators)'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[列表控制运算符](#list-control-operators)'
- en: 'You can use these operators to control the execution of the subsequent command
    depending on the exit status of the first command. From [bash manual: Lists of
    Commands](https://www.gnu.org/software/bash/manual/bash.html#Lists):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些运算符根据第一个命令的退出状态来控制后续命令的执行。更多信息请参考 [bash 手册：命令列表](https://www.gnu.org/software/bash/manual/bash.html#Lists)。
- en: AND and OR lists are sequences of one or more pipelines separated by the control
    operators `&&` and `||`, respectively. AND and OR lists are executed with left
    associativity.
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: AND 和 OR 列表是由控制运算符 `&&` 和 `||` 分隔的一个或多个管道序列，分别执行时具有左结合性。
- en: For AND list, the second command will be executed if and only if the first command
    exits with `0` status.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AND 列表，只有当第一个命令以 `0` 状态退出时，第二个命令才会被执行。
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For OR list, the second command will be executed if and only if the first command
    does *not* exit with `0` status.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OR 列表，只有当第一个命令没有以 `0` 状态退出时，第二个命令才会被执行。
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Command substitution](#command-substitution)'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[命令替换](#command-substitution)'
- en: 'Command substitution allows you to use the standard output of a command as
    part of another command. Trailing newlines, if any, will be removed. You can use
    the newer and preferred syntax `$(command)` or the older syntax `` `command` ``.
    Here are some examples:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 命令替换允许你将一个命令的标准输出作为另一个命令的一部分使用。如果有的话，尾随的新行将被删除。你可以使用较新且更受欢迎的语法`$(command)`或较旧的语法``
    `command` ``。以下是一些示例：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s an example with nested substitutions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个嵌套替换的示例：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Difference between the two types of syntax is quoted below from [bash manual:
    Command Substitution](https://www.gnu.org/software/bash/manual/bash.html#Command-Substitution):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从[bash手册：命令替换](https://www.gnu.org/software/bash/manual/bash.html#Command-Substitution)中引用的两种语法类型的区别：
- en: When the old-style backquote form of substitution is used, backslash retains
    its literal meaning except when followed by `$`, `` ` ``, or `\`. The first backquote
    not preceded by a backslash terminates the command substitution. When using the
    $(command) form, all characters between the parentheses make up the command; none
    are treated specially.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用旧式的反引号替换形式时，反斜杠保留其字面意义，除非其后跟有`$`、`` ` ``或`\`。第一个没有反斜杠的前面的反引号终止命令替换。当使用$(command)形式时，括号之间的所有字符组成命令；没有字符被特殊处理。
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Command substitutions may be nested. To nest when using the backquoted form,
    escape the inner backquotes with backslashes.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令替换可以是嵌套的。当使用反引号形式时，使用反斜杠转义内部的反引号。
- en: '[Process substitution](#process-substitution)'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[进程替换](#process-substitution)'
- en: 'Instead of a file argument, you can use command output with process substitution.
    The syntax is `<(list)`. The shell will take care of passing a filename with the
    standard output of those commands. Here''s an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件参数外，你可以使用进程替换来使用命令输出。语法是`<(list)`。shell将负责传递一个包含那些命令标准输出的文件名。以下是一个示例：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For the above example, you could also have used `-` to represent `stdin` piped
    data as seen in an earlier section. Here's an example where two substitutions
    are used. This essentially helps you to avoid managing multiple temporary files,
    similar to how the `|` pipe operator helps for single temporary file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述示例，你也可以使用`-`来表示`stdin`管道数据，如前述章节所示。这里有一个使用两个替换的示例。这实际上帮助你避免管理多个临时文件，类似于`|`管道操作符对单个临时文件的帮助。
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See [this unix.stackexchange
    thread](https://unix.stackexchange.com/q/609375/109046) for examples with the
    `>(list)` form.'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 请参阅[这个unix.stackexchange线程](https://unix.stackexchange.com/q/609375/109046)以获取使用`>(list)`形式的示例。'
- en: '[Exercises](#exercises)'
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Use the `globs.sh`
    script for wildcards related exercises, unless otherwise mentioned.'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 使用`globs.sh`脚本来处理与通配符相关的练习，除非另有说明。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Create a temporary
    directory for exercises that may require you to create some files. You can delete
    such practice directories afterwards.'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 为可能需要创建一些文件的练习创建一个临时目录。之后你可以删除这样的练习目录。'
- en: '**1)** Use the `echo` command to display the text as shown below. Use appropriate
    quoting as necessary.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**1)** 使用`echo`命令以如下所示的方式显示文本。根据需要使用适当的引号。'
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**2)** Use the `echo` command to display the values of the three variables
    in the format as shown below.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**2)** 使用`echo`命令以下面的格式显示三个变量的值。'
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**3)** What will be the output of the command shown below?'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**3)** 以下命令的输出将是什么？'
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**4)** List filenames starting with a digit character.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**4)** 列出以数字字符开头的文件名。'
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**5)** List filenames whose extension do not begin with `t` or `l`. Assume
    extensions will have at least one character.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**5)** 列出扩展名不以`t`或`l`开头的文件名。假设扩展名至少有一个字符。'
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**6)** List filenames whose extension only have a single character.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**6)** 列出扩展名只有一个字符的文件名。'
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**7)** List filenames whose extension is not `txt`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**7)** 列出扩展名不是`txt`的文件名。'
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**8)** Describe the wildcard pattern used in the command shown below.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**8)** 描述以下命令中使用的通配符模式。'
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**9)** List filenames having only lowercase alphabets before the extension.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**9)** 列出扩展名前只有小写字母的文件名。'
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**10)** List filenames starting with `ma` or `he` or `hi`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**10)** 列出以`ma`、`he`或`hi`开头的文件名。'
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**11)** What commands would you use to get the outputs shown below? Assume
    that you do not know the depth of sub-directories.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**11)** 你会使用哪些命令来获取以下显示的输出？假设你不知道子目录的深度。'
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**12)** Create and change to an empty directory. Then, use brace expansion
    along with relevant commands to get the results shown below.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**12)** 创建并切换到一个空目录。然后，使用花括号展开和相关命令来获取以下显示的结果。'
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**13)** What does the `set` builtin command do?'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**13)** `set` 内置命令的作用是什么？'
- en: '**14)** What does the `|` pipe operator do? And when would you add the `tee`
    command?'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**14)** `|` 管道操作符的作用是什么？你会在什么情况下添加 `tee` 命令？'
- en: '**15)** Can you infer what the following command does? *Hint*: see `help printf`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**15)** 你能推断出以下命令的作用吗？*提示*：查看 `help printf`。'
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**16)** Use brace expansion along with relevant commands and shell features
    to get the result shown below. *Hint*: see previous question.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**16)** 使用花括号展开和相关命令以及 shell 功能来获取以下显示的结果。*提示*：查看前一个问题。'
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**17)** With `ip.txt` containing text as shown in the previous question, use
    brace expansion and relevant commands to get the result shown below.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**17)** 在 `ip.txt` 包含之前问题中显示的文本的情况下，使用花括号展开和相关命令来获取以下显示的结果。'
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**18)** What are the differences between `<` and `|` shell operators, if any?'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**18)** 如果有的话，`<` 和 `|` shell 操作符之间有什么区别？'
- en: '**19)** Which character is typically used to represent `stdin` data as a file
    argument?'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**19)** 通常用哪个字符来表示将 `stdin` 数据作为文件参数？'
- en: '**20)** What do the following operators do?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**20)** 以下操作符的作用是什么？'
- en: '*a)* `1>`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*a)* `1>`'
- en: '*b)* `2>`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*b)* `2>`'
- en: '*c)* `&>`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*c)* `&>`'
- en: '*d)* `&>>`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*d)* `&>>`'
- en: '*e)* `|&`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*e)* `|&`'
- en: '**21)** What will be the contents of `op.txt` if you use the following `grep`
    command?'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**21)** 如果你使用以下 `grep` 命令，`op.txt` 的内容将会是什么？'
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**22)** What will be the contents of `op.txt` if you use the following commands?'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**22)** 如果你使用以下命令，`op.txt` 的内容将会是什么？'
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**23)** Correct the command to get the expected output shown below.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**23)** 修正以下命令以获取以下显示的预期输出。'
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**24)** Correct the command to get the expected output shown below.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**24)** 修正以下命令以获取以下显示的预期输出。'
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**25)** What will be the output of the following commands?'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**25)** 以下命令的输出将会是什么？'
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**26)** Correct the command(s) to get the expected output shown below.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**26)** 修正以下命令以获取以下显示的预期输出。'
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**27)** Will the following two commands produce equivalent output? If not,
    why not?'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**27)** 以下两个命令会产生等效的输出吗？如果不，为什么？'
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
