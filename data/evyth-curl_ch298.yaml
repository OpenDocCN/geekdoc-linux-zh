- en: Memory debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存调试
- en: The file `lib/memdebug.c` contains debug-versions of a few functions. Functions
    such as `malloc()`, `free()`, `fopen()`, `fclose()`, etc that somehow deal with
    resources that might give us problems if we leak them. The functions in the memdebug
    system do nothing fancy, they do their normal function and then log information
    about what they just did. The logged data can then be analyzed after a complete
    session,
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `lib/memdebug.c` 包含了一些函数的调试版本。例如 `malloc()`、`free()`、`fopen()`、`fclose()`
    等等，这些函数以某种方式处理可能会给我们带来问题的资源。memdebug 系统中的函数不做任何花哨的事情，它们执行正常功能，然后记录它们刚刚做了什么的信息。这些记录的数据可以在完整会话后进行分析，
- en: '`memanalyze.pl` is the perl script present in `tests/` that analyzes a log
    file generated by the memory tracking system. It detects if resources are allocated
    but never freed and other kinds of errors related to resource management.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`memanalyze.pl` 是位于 `tests/` 中的 perl 脚本，它分析由内存跟踪系统生成的日志文件。它检测资源是否已分配但从未释放，以及其他与资源管理相关的错误。'
- en: Internally, the definition of the preprocessor symbol `DEBUGBUILD` restricts
    code which is only compiled for debug enabled builds. The symbol `CURLDEBUG` is
    used to differentiate code which is *only* used for memory tracking/debugging.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，预处理器符号 `DEBUGBUILD` 的定义限制了仅针对调试启用构建编译的代码。符号 `CURLDEBUG` 用于区分仅用于内存跟踪/调试的代码。
- en: Use `-DCURLDEBUG` when compiling to enable memory debugging, this is also switched
    on by running configure with `--enable-curldebug`. Use `-DDEBUGBUILD` when compiling
    to enable a debug build or run configure with `--enable-debug`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时使用 `-DCURLDEBUG` 以启用内存调试，这也可以通过运行配置脚本并使用 `--enable-curldebug` 来启用。在编译时使用
    `-DDEBUGBUILD` 以启用调试构建，或者运行配置脚本并使用 `--enable-debug`。
- en: '`curl --version` lists the `Debug` feature for debug enabled builds, and lists
    the `TrackMemory` feature for curl debug memory tracking capable builds. These
    features are independent and can be controlled when running the configure script.
    When `--enable-debug` is given both features get enabled, unless some restriction
    prevents memory tracking from being used.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl --version` 列出了调试启用构建的 `Debug` 功能，以及 curl 调试内存跟踪功能 `TrackMemory`。这些功能是独立的，可以在运行配置脚本时进行控制。当提供
    `--enable-debug` 时，这两个功能都会被启用，除非某些限制阻止了内存跟踪的使用。'
- en: Track Down Memory Leaks
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪内存泄漏
- en: … using the memory debug system. In general, we suggest using valgrind a the
    first choice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '…使用内存调试系统。一般来说，我们建议首先使用 valgrind。 '
- en: Single-threaded
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单线程
- en: Please note that this memory leak system is not adjusted to work in more than
    one thread. If you want/need to use it in a multi-threaded app. Please adjust
    accordingly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此内存泄漏系统尚未调整以在多个线程中工作。如果您想在多线程应用程序中使用它，请相应地进行调整。
- en: Build
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: Rebuild libcurl with `-DCURLDEBUG` (usually, rerunning configure with `--enable-debug`
    fixes this). `make clean` first, then `make` so that all files are actually rebuilt
    properly. It also makes sense to build libcurl with the debug option (usually
    `-g` to the compiler) so that debugging it gets easier if you actually do find
    a leak in the library.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-DCURLDEBUG` 重新构建 libcurl（通常，重新运行配置脚本并使用 `--enable-debug` 可以解决这个问题）。首先执行
    `make clean`，然后执行 `make` 以确保所有文件都正确地重新构建。此外，使用带有调试选项（通常是编译器的 `-g`）构建 libcurl 也是有意义的，这样如果实际上在库中找到泄漏，调试会更加容易。
- en: This builds a library that has memory debugging enabled.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这构建了一个启用了内存调试的库。
- en: Modify Your Application
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改您的应用程序
- en: 'Add a line in your application code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序代码中添加一行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This makes the malloc debug system output a full trace of all resources using
    functions to the given filename. Make sure you rebuild your program and that you
    link with the same libcurl you built for this purpose as described above.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 malloc 调试系统输出所有资源使用函数到指定的文件名。确保您重新构建程序，并且与上述描述中为该目的构建的相同 libcurl 链接。
- en: Run Your Application
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行您的应用程序
- en: Run your program as usual. Watch the specified memory trace file grow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规运行您的程序。观察指定的内存跟踪文件增长。
- en: Make your program exit and use the proper libcurl cleanup functions etc. So
    that all non-leaks are returned/freed properly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让您的程序退出并使用适当的 libcurl 清理函数等，以确保所有非泄漏都返回/释放正确。
- en: Analyze the Flow
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析流程
- en: 'Use the `tests/memanalyze.pl` perl script to analyze the dump file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tests/memanalyze.pl` perl 脚本分析转储文件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This now outputs a report on what resources that were allocated but never freed
    etc. This report is fine for posting to the list.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会输出关于已分配但从未释放的资源等的报告。这个报告适合发布到列表中。
- en: If this does not produce any output, no leak was detected in libcurl. Then the
    leak is mostly likely to be in your code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有产生任何输出，libcurl 中未检测到泄漏。那么泄漏很可能是出现在您的代码中。
