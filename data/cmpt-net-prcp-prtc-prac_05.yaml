- en: A reliable transport protocol#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠传输协议#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/reliability.html](https://4ed.computer-networking.info/syllabus/default/hosts/reliability.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/reliability.html](https://4ed.computer-networking.info/syllabus/default/hosts/reliability.html)
- en: A simple reliable protocol[#](#a-simple-reliable-protocol "Link to this heading")
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单可靠协议[#](#a-simple-reliable-protocol "链接到本标题")
- en: In this section, we develop a simple reliable protocol running above the network
    service. To design this protocol, we first assume that the underlying layer provides
    a perfect service. We will then develop solutions to recover from different types
    of errors that affect the network service.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开发了一个在网络服务之上运行的简单可靠协议。为了设计这个协议，我们首先假设底层层提供完美服务。然后，我们将开发解决影响网络服务的不同类型错误的解决方案。
- en: 'The network layer is designed to send and receive packets on behalf of a user.
    We model these interactions by using the DATA.req and DATA.ind primitives. However,
    to simplify the presentation and to avoid confusion between a DATA.req primitive
    issued by the user of the network layer, and a DATA.req issued by the transport
    layer entity itself, we use the following terminology :'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层被设计用来代表用户发送和接收数据包。我们通过使用 DATA.req 和 DATA.ind 原语来模拟这些交互。然而，为了简化演示并避免网络层用户发出的
    DATA.req 原语与传输层实体本身发出的 DATA.req 原语之间的混淆，我们使用以下术语：
- en: the interactions between the user and the transport layer entity are represented
    by using the classical DATA.req and the DATA.ind primitives
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户与传输层实体之间的交互通过使用经典的 DATA.req 和 DATA.ind 原语来表示
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the interactions between the transport layer entity and the sub-layer are represented
    by using send instead of DATA.req and recvd instead of DATA.ind
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 send 代替 DATA.req 和使用 recvd 代替 DATA.ind 来表示传输层实体与子层之间的交互
- en: When running on top of a perfect network, a transport entity can simply issue
    a send(SDU) upon arrival of a DATA.req(SDU) [[1]](#fsdu). Similarly, the receiver
    issues a DATA.ind(SDU) upon receipt of a recvd(SDU). Such a simple protocol is
    sufficient when a single SDU is sent. This is illustrated in the figure below.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的网络之上运行时，传输实体可以在 DATA.req(SDU) 到达时简单地发出 send(SDU) [[1]](#fsdu)。同样，接收者在收到
    recvd(SDU) 时发出 DATA.ind(SDU)。当发送单个 SDU 时，这样一个简单的协议就足够了。这在下图中有说明。
- en: '![msc {'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(SDU)" ] ,
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(SDU)" ] ,
- en: b>>c [ label = "Segment(SDU)", arcskip="1"];
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "段(SDU)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(SDU)" ];
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(SDU)" ];
- en: '}](../Images/ba824d054705364b69646b80420c85eb.png)<map id="e44596b6402c634781fc156189b78b14744a061d"
    name="e44596b6402c634781fc156189b78b14744a061d"></map>'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/ba824d054705364b69646b80420c85eb.png)<map id="e44596b6402c634781fc156189b78b14744a061d"
    name="e44596b6402c634781fc156189b78b14744a061d"></map>'
- en: Unfortunately, this is not always sufficient to ensure a reliable delivery of
    SDUs. Consider the case where a client sends tens of SDUs to a server. If the
    server is faster than the client, it will be able to receive and process all the
    segments sent by the client and deliver their content to its user. However, if
    the server is slower than the client, problems may arise. The transport entity
    contains buffers to store SDUs that have been received as a Data.request but have
    not yet been sent. If the application is faster than the network, the buffer may
    become full. At this point, the operating system suspends the application to let
    the transport entity empty its transmission queue. The transport entity also uses
    a buffer to store the received segments that have not yet been processed by the
    application. If the application is slow to process the data, this buffer may overflow
    and the transport entity will not able to accept any additional segment. The buffers
    of the transport entity have a limited size and if they overflow, the arriving
    segments will be discarded, even if they are correct.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不总是足以确保SDU的可靠交付。考虑这样一个案例，一个客户端向服务器发送了数十个SDU。如果服务器比客户端快，它将能够接收和处理客户端发送的所有段，并将内容交付给用户。然而，如果服务器比客户端慢，可能会出现问题。传输实体包含缓冲区以存储已作为数据请求接收但尚未发送的SDU。如果应用程序比网络快，缓冲区可能会满。在这种情况下，操作系统将挂起应用程序，以便传输实体清空其传输队列。传输实体还使用缓冲区来存储尚未由应用程序处理的接收到的段。如果应用程序处理数据较慢，这个缓冲区可能会溢出，并且传输实体将无法接受任何额外的段。传输实体的缓冲区大小有限，如果它们溢出，到达的段将被丢弃，即使它们是正确的。
- en: 'To solve this problem, a reliable protocol must include a feedback mechanism
    that allows the receiver to inform the sender that it has processed a segment
    and that another one can be sent. This feedback is required even though there
    are no transmission errors. To include such a feedback, our reliable protocol
    must process two types of segments :'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可靠的协议必须包括一个反馈机制，允许接收方通知发送方它已处理一个段，并且可以发送另一个段。即使没有传输错误，也需要这种反馈。为了包含这种反馈，我们的可靠协议必须处理两种类型的段：
- en: data segments carrying a SDU
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有SDU的数据段
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: control segments confirming that the previous segment was correctly processed
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认前一个段已被正确处理的控制段
- en: These control segments are usually called acknowledgments because they acknowledge
    the correct reception of data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制段通常被称为确认，因为它们确认了数据的正确接收。
- en: 'These two types of segments can be distinguished by dividing the segments in
    two parts :'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的段可以通过将段分为两部分来区分：
- en: the header that contains a segment type bit set to 0 in data segments and set
    to 1 in control segments
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个段类型位设置为0的数据段和设置为1的控制段的头部
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the payload that contains the SDU supplied by the application
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含由应用程序提供的SDU的有效负载
- en: Our transport entity can then be modeled as a finite state machine, containing
    two states for the receiver and two states for the sender. [Fig. 47](#fig-fsm1-transport)
    provides a graphical representation of this state machine with the sender above
    and the receiver below.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的传输实体可以被建模为一个有限状态机，包含接收方的两个状态和发送方的两个状态。[图47](#fig-fsm1-transport)提供了这个状态机的图形表示，发送方在上，接收方在下。
- en: '![Figure made with TikZ](../Images/ca317c24a120ea2f84f77bb8205d331e.png)'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/ca317c24a120ea2f84f77bb8205d331e.png)'
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 47 Finite state machines of the simplest reliable protocol (sender above,
    receiver below)
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图47 最简单可靠协议的有限状态机（发送方在上，接收方在下）
- en: The sender FSM shows that the sender has to wait for an acknowledgment from
    the receiver before being able to transmit the next SDU. The figure below illustrates
    the exchange of a few segments between two hosts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方有限状态机显示，发送方必须等待接收方的确认才能传输下一个SDU。下面的图示说明了两个主机之间的一些段交换。
- en: '![msc {'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)"], b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)"], b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ],c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ],c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)" ], b>>c [ label = "D(b)",arcskip="1"];
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)" ], b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ], c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ], c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/15482ac863d12db91aebf9dbd402b97a.png)<map id="60a9f1c91540fca4ffa054e6b58cb88cf03463af"
    name="60a9f1c91540fca4ffa054e6b58cb88cf03463af"></map>'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/15482ac863d12db91aebf9dbd402b97a.png)<map id="60a9f1c91540fca4ffa054e6b58cb88cf03463af"
    name="60a9f1c91540fca4ffa054e6b58cb88cf03463af"></map>'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Services and protocols
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和协议
- en: An important aspect to understand when studying computer networks is the difference
    between a *service* and a *protocol*. For this, it is useful to start with real
    world examples. The traditional Post provides a service where a postman delivers
    letters to recipients. The Post precisely defines which types of letters (size,
    weight, etc) can be delivered by using the Standard Mail service. Furthermore,
    the format of the envelope is specified (position of the sender and recipient
    addresses, position of the stamp). Someone who wants to send a letter must either
    place the letter at a Post Office or inside one of the dedicated mailboxes. The
    letter will then be collected and delivered to its final recipient. Note that
    for the regular service the Post usually does not guarantee the delivery of each
    particular letter. Some letters may be lost, and some letters are delivered to
    the wrong mailbox. If a letter is important, then the sender can use the registered
    service to ensure that the letter will be delivered to its recipient. Some Post
    services also provide an acknowledged service or an express mail service that
    is faster than the regular service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究计算机网络时，理解*服务*和*协议*之间的区别是一个重要的方面。为此，从现实世界的例子开始是有用的。传统的邮政服务提供了一种服务，其中邮递员将信件递送给收件人。邮政精确地定义了可以使用标准邮件服务递送的信件类型（大小、重量等）。此外，信封的格式也被指定（发件人和收件人地址的位置，邮票的位置）。想要发送信件的人必须将信件放在邮局或专用的邮箱中。然后信件将被收集并递送到最终收件人处。请注意，对于常规服务，邮政通常不保证每封特定信件的递送。有些信件可能会丢失，有些信件可能会被递送到错误的邮箱。如果信件很重要，发件人可以使用挂号服务来确保信件能递送到收件人手中。一些邮政服务还提供确认服务或比常规服务更快的快递服务。
- en: Reliable transfer above an imperfect link[#](#reliable-transfer-above-an-imperfect-link
    "Link to this heading")
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不完美的链路上可靠传输[#](#reliable-transfer-above-an-imperfect-link "链接到本标题")
- en: 'The transport layer must deal with several types of errors which can affect
    the segments that it sends. In practice, we mainly have to deal with two types
    of errors in the transport layer :'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层必须处理多种类型的错误，这些错误可能会影响它发送的段。在实践中，我们主要需要在传输层处理两种类型的错误：
- en: Segments can be corrupted by transmission errors
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段可能会因为传输错误而损坏
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Segments can be lost or unexpected segments can appear
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段可能会丢失或出现意外的段
- en: 'To detect errors, a segment is usually divided into two parts :'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测错误，一个段通常被分为两部分：
- en: a header that contains the fields used by the reliable protocol to ensure reliable
    delivery. The header contains a checksum or Cyclical Redundancy Check (CRC) [[Williams1993]](../bibliography.html#williams1993)
    that is used to detect transmission errors
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含可靠协议用于确保可靠递送的字段头部。头部包含一个校验和或循环冗余校验（CRC）[[Williams1993]](../bibliography.html#williams1993)，用于检测传输错误
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a payload that contains the user data
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含用户数据的有效载荷
- en: Some headers also include a length field, which indicates the total length of
    the segment or the length of the payload.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些头部字段还包括一个长度字段，该字段指示段的总长度或有效载荷的长度。
- en: The simplest error detection scheme is the checksum. A checksum is basically
    an arithmetic sum of all the bytes that a segment is composed of. There are different
    types of checksums. For example, an eight bit checksum can be computed as the
    arithmetic sum of all the bytes of (both the header and trailer of) the segment.
    The checksum is computed by the sender before sending the segment and the receiver
    verifies the checksum upon segment reception. The receiver discards segments received
    with an invalid checksum. Checksums can be easily implemented in software, but
    their error detection capabilities are limited. Cyclical Redundancy Checks (CRC)
    have better error detection capabilities [[SGP98]](../bibliography.html#sgp98),
    but require more CPU when implemented in software.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的错误检测方案是校验和。校验和基本上是构成段的全部字节的算术和。有不同类型的校验和。例如，一个8位校验和可以计算为段（包括头部和尾部）所有字节的算术和。校验和由发送者在发送段之前计算，接收者在接收段时验证校验和。接收者丢弃接收到的无效校验和的段。校验和可以很容易地在软件中实现，但它们的错误检测能力有限。循环冗余校验（CRC）具有更好的错误检测能力
    [[SGP98]](../bibliography.html#sgp98)，但在软件实现时需要更多的CPU。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Checksums, CRCs,…
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和、CRCs、…
- en: Most of the protocols in the TCP/IP protocol suite rely on the simple Internet
    checksum in order to verify that a received packet has not been affected by transmission
    errors. Despite its popularity and ease of implementation, the Internet checksum
    is not the only available checksum mechanism. Cyclical Redundancy Checks ([CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check))
    are very powerful error detection schemes that are used notably on disks, by many
    datalink layer protocols and file formats such as `zip` or `png`. They can easily
    be implemented efficiently in hardware and have better error-detection capabilities
    than the Internet checksum [[SGP98]](../bibliography.html#sgp98) . However, CRCs
    are sometimes considered to be too CPU-intensive for software implementations
    and other checksum mechanisms are preferred. The TCP/IP community chose the Internet
    checksum, the OSI community chose the Fletcher checksum [[Sklower89]](../bibliography.html#sklower89).
    Nowadays there are efficient techniques to quickly compute CRCs in software [[Feldmeier95]](../bibliography.html#feldmeier95).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议套件中的大多数协议都依赖于简单的互联网校验和来验证接收到的数据包在传输过程中没有受到影响。尽管它很受欢迎且易于实现，但互联网校验和并不是唯一的校验和机制。循环冗余校验（[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)）是非常强大的错误检测方案，特别在磁盘、许多数据链路层协议和文件格式（如`zip`或`png`）中使用。它们可以很容易地在硬件中高效实现，并且比互联网校验和具有更好的错误检测能力
    [[SGP98]](../bibliography.html#sgp98)。然而，CRC有时被认为对软件实现来说CPU消耗过高，因此更倾向于其他校验和机制。TCP/IP社区选择了互联网校验和，OSI社区选择了Fletcher校验和
    [[Sklower89]](../bibliography.html#sklower89)。如今，有高效的软件计算CRC的技术 [[Feldmeier95]](../bibliography.html#feldmeier95)。
- en: Since the receiver sends an acknowledgment after having received each data segment,
    the simplest solution to deal with losses is to use a retransmission timer. When
    the sender sends a segment, it starts a retransmission timer. The duration of
    this retransmission timer should be larger than the round-trip-time, i.e. the
    delay between the transmission of a data segment and the reception of the corresponding
    acknowledgment. When the retransmission timer expires, the sender assumes that
    the data segment has been lost and retransmits it. This is illustrated in the
    figure below.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收者在收到每个数据段后都会发送一个确认，因此处理丢失的最简单方法是使用重传计时器。当发送者发送一个段时，它启动一个重传计时器。这个重传计时器的持续时间应该大于往返时间，即数据段传输和对应确认接收之间的延迟。当重传计时器到期时，发送者假定数据段已丢失，并重新发送它。这在下图中说明。
- en: '![msc {'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b-x c [ label = "D(b)", arcskip="1", linecolour=red];
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(b)", arcskip="1", linecolour=red];
- en: '|||;'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/eb3e128faed868520ea345c4171d9007.png)<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"
    name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"></map>'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/eb3e128faed868520ea345c4171d9007.png)<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"
    name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"></map>'
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, retransmission timers alone are not sufficient to recover from
    losses. Let us consider, as an example, the situation depicted below where an
    acknowledgment is lost. In this case, the sender retransmits the data segment
    that has not been acknowledged. However, as illustrated in the figure below, the
    receiver considers the retransmission as a new segment whose payload must be delivered
    to its user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅重传计时器不足以从丢失中恢复。让我们考虑以下情况，如图所示，其中确认信息丢失。在这种情况下，发送方重新传输尚未确认的数据段。然而，如图所示，接收方将重传视为新的段，其有效载荷必须交付给其用户。
- en: '![msc {'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c-x b [label= "C(OK)", linecolour=red, arcskip="1"];
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c-x b [label= "C(OK)", linecolour=red, arcskip="1"];
- en: '|||;'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b) !!!!!", linecolour=red ];
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b) !!!!!", linecolour=red ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/f31aca9d4a56211a006ee59b4bbd6581.png)<map id="34c7c055da8716230ba3f29574fb761575e3d9f5"
    name="34c7c055da8716230ba3f29574fb761575e3d9f5"></map>'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f31aca9d4a56211a006ee59b4bbd6581.png)<map id="34c7c055da8716230ba3f29574fb761575e3d9f5"
    name="34c7c055da8716230ba3f29574fb761575e3d9f5"></map>'
- en: To solve this problem, reliable protocols associate a sequence number to each
    data segment. This sequence number is one of the fields found in the header of
    data segments. We use the notation D(x,…) to indicate a data segment whose sequence
    number field is set to value x. The acknowledgments also contain a sequence number
    indicating the data segments that it acknowledges. We use OKx to indicate an acknowledgment
    that confirms the reception of D(x,…). The sequence number is encoded as a bit
    string of fixed length. The simplest reliable protocol is the Alternating Bit
    Protocol (ABP).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可靠的协议将序列号与每个数据段关联。这个序列号是数据段头部中找到的字段之一。我们使用记号D(x,…)来表示序列号字段设置为值x的数据段。确认信息也包含一个序列号，表示它确认的数据段。我们使用OKx来表示确认接收了D(x,…)的确认。序列号被编码为固定长度的比特串。最简单的可靠协议是交替位协议（ABP）。
- en: The Alternating Bit Protocol[#](#the-alternating-bit-protocol "Link to this
    heading")
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交替位协议[#](#the-alternating-bit-protocol "链接到本标题")
- en: The Alternating Bit Protocol uses a single bit to encode the sequence number.
    It can be implemented easily. The sender (resp. the receiver) only require a four-state
    (resp. three-state) Finite State Machine. The sender FSM is represented in [Fig.
    48](#fig-abp-sender-fsm) and the receiver FSM in [Fig. 49](#fig-abp-receiver-fsm).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议使用一个比特来编码序列号。它可以很容易地实现。发送方（分别）只需要一个四状态（分别）有限状态机。发送方有限状态机在[图48](#fig-abp-sender-fsm)中表示，接收方有限状态机在[图49](#fig-abp-receiver-fsm)中表示。
- en: '![Figure made with TikZ](../Images/8fbe25275e0fee019961c542919ef49b.png)'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8fbe25275e0fee019961c542919ef49b.png)'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 48 Alternating bit protocol: Sender FSM'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图48 交替位协议：发送方有限状态机
- en: The initial state of the sender is Wait for D(0,…). In this state, the sender
    waits for a Data.request. The first data segment that it sends uses sequence number
    0. After having sent this segment, the sender waits for an OK0 acknowledgment.
    A data segment is retransmitted upon expiration of the retransmission timer or
    if an acknowledgment with an incorrect sequence number has been received.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者的初始状态是等待D(0,…). 在此状态下，发送者等待数据请求。它发送的第一个数据段使用序列号0。发送此段后，发送者等待OK0确认。如果重传计时器到期或收到序列号不正确的确认，则重新传输数据段。
- en: The receiver first waits for D(0,…). If the segment contains a correct CRC,
    it passes the SDU to its user and sends OK0. If the segment contains an invalid
    CRC, it is immediately discarded. Then, the receiver waits for D(1,…). In this
    state, it may receive a duplicate D(0,…) or a data segment with an invalid CRC.
    In both cases, it returns an OK0 segment to allow the sender to recover from the
    possible loss of the previous OK0 segment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者首先等待D(0,…). 如果段包含正确的CRC校验和，它将SDU传递给其用户并发送OK0。如果段包含无效的CRC校验和，它将立即被丢弃。然后，接收者等待D(1,…).
    在此状态下，它可能接收到重复的D(0,…)或包含无效CRC校验和的数据段。在这两种情况下，它都会返回一个OK0段，以便发送者可以从可能的上一OK0段丢失中恢复。
- en: '![Figure made with TikZ](../Images/3badb5e30f18cd10794dafd6f023ac28.png)'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/3badb5e30f18cd10794dafd6f023ac28.png)'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 49 Alternating bit protocol: Receiver FSM'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图49 交替位协议：接收器FSM
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Corrupted segments must be discarded
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 必须丢弃损坏的段
- en: The receiver FSM of the Alternating bit protocol discards all segments that
    contain an invalid CRC. This is the safest approach since the received segment
    can be completely different from the one sent by the remote host. A receiver should
    not attempt at extracting information from a corrupted segment because it cannot
    know which portion of the segment has been affected by the error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议的接收有限状态机（FSM）会丢弃所有包含无效CRC校验和的段。这是最安全的做法，因为接收到的段可能与远程主机发送的段完全不同。接收者不应该尝试从损坏的段中提取信息，因为它无法知道段的哪个部分受到了错误的影响。
- en: The figure below illustrates the operation of the Alternating Bit Protocol.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了交替位协议的操作。
- en: '![msc {'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="cancel timer"];
- en: '|||;'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ];
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\nstart timer" ];
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="cancel timer"];
- en: '|||;'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(c)\nstart timer" ] ,
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(c)\nstart timer" ] ,
- en: b>>c [ label = "D(0,c)", arcskip="1"];
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,c)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(c)" ];
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(c)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="cancel timer"];
- en: '|||;'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/58f29e8a1f0f64da47ef83b069805c78.png)<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"
    name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"></map>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/58f29e8a1f0f64da47ef83b069805c78.png)<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"
    name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"></map>'
- en: The Alternating Bit Protocol can recover from the losses of data or control
    segments. This is illustrated in the two figures below. The first figure shows
    the loss of one data segment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议可以从数据或控制段的丢失中恢复。这在下面的两个图中得到说明。第一个图显示了数据段的丢失。
- en: '![msc {'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="cancel timer"];
- en: '|||;'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b-x c [ label = "D(1,b)", arcskip="1", linecolour=red];
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(1,b)", arcskip="1", linecolour=red];
- en: '|||;'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/f662cc9a0b114455fe7ce91316c8aedb.png)<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68"
    name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"></map>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/f662cc9a0b114455fe7ce91316c8aedb.png)<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68"
    name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"></map>'
- en: The second figure illustrates how the hosts handle the loss of one control segment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图说明了主机如何处理一个控制段的丢失。
- en: '![msc {'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c-x b [label= "C(OK1)", linecolour=red, arcskip="1"];
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: c-x b [label= "C(OK1)", linecolour=red, arcskip="1"];
- en: '|||;'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "Duplicate segment\nignored", textcolour=red, linecolour=white
    ];
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "Duplicate segment\n被忽略", textcolour=red, linecolour=white ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/3bcb6de20e7b816c3750de577d1012cc.png)<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"
    name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"></map>'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/3bcb6de20e7b816c3750de577d1012cc.png)<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"
    name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"></map>'
- en: The Alternating Bit Protocol can recover from transmission errors and segment
    losses. However, it has one important drawback. Consider two hosts that are directly
    connected by a 50 Kbits/sec satellite link that has a 250 milliseconds propagation
    delay. If these hosts send 1000 bits segments, then the maximum throughput that
    can be achieved by the alternating bit protocol is one segment every \(20+250+250=520\)
    milliseconds if we ignore the transmission time of the acknowledgment. This is
    less than 2 Kbits/sec !
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 交替比特协议可以从传输错误和段丢失中恢复。然而，它有一个重要的缺点。考虑两个通过50 Kbits/sec 卫星链路直接连接的主机，该链路具有250毫秒的传播延迟。如果这些主机发送1000比特的段，那么如果忽略确认的传输时间，交替比特协议可以达到的最大吞吐量是每520毫秒一个段，即\(20+250+250=520\)毫秒。这还不到2
    Kbits/sec！
- en: '[PRE1]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Go-back-n and selective repeat[#](#go-back-n-and-selective-repeat "Link to this
    heading")
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go-back-n和选择性重传[#](#go-back-n-and-selective-repeat "链接到这个标题")
- en: To overcome the performance limitations of the alternating bit protocol, reliable
    protocols rely on pipelining shown in [Fig. 50](#fig-pipelining). This technique
    allows a sender to transmit several consecutive segments without being forced
    to wait for an acknowledgment after each segment. Each data segment contains a
    sequence number encoded as an n bits field.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服交替比特协议的性能限制，可靠协议依赖于图50中所示的管道化技术。这项技术允许发送者在每个段之后不必等待确认就可以连续发送几个段。每个数据段包含一个序列号，该序列号编码为一个n比特字段。
- en: '[![../_images/pipelining2.png](../Images/673705ddb7a242862f06d67fd8c2c097.png)](../_images/pipelining2.png)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/pipelining2.png](../Images/673705ddb7a242862f06d67fd8c2c097.png)](../_images/pipelining2.png)'
- en: Fig. 50 Pipelining improves the performance of reliable protocols[#](#fig-pipelining
    "Link to this image")
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图50 管道化提高了可靠协议的性能[#](#fig-pipelining "链接到这张图片")
- en: Pipelining allows the sender to transmit segments at a higher rate. However
    this higher transmission rate may overload the receiver. In this case, the segments
    sent by the sender will not be correctly received by their final destination.
    The reliable protocols that rely on pipelining allow the sender to transmit W
    unacknowledged segments before being forced to wait for an acknowledgment from
    the receiving entity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 管道化允许发送者以更高的速率传输段。然而，这种更高的传输速率可能会超载接收者。在这种情况下，发送者发送的段将不会被其最终目的地正确接收。依赖于管道化的可靠协议允许发送者在被迫等待接收实体确认之前发送
    W 个未确认的段。
- en: This is implemented by using a sliding window. The sliding window is the set
    of consecutive sequence numbers that the sender can use when transmitting segments
    without being forced to wait for an acknowledgment. [Fig. 51](#fig-sliding-win)
    shows a sliding window containing five segments (6,7,8,9 and 10). Two of these
    sequence numbers (6 and 7) have been used to send segments and only three sequence
    numbers (8, 9 and 10) remain in the sliding window. The sliding window is said
    to be closed once all sequence numbers contained in the sliding window have been
    used.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用滑动窗口实现的。滑动窗口是发送者在发送段时可以使用的连续序列号集合，而无需被迫等待确认。图 51 [图 51](#fig-sliding-win)
    展示了一个包含五个段（6,7,8,9 和 10）的滑动窗口。其中两个序列号（6 和 7）已被用于发送段，而滑动窗口中只剩下三个序列号（8, 9 和 10）。当滑动窗口中包含的所有序列号都被使用后，滑动窗口被认为是关闭的。
- en: '[![../_images/slidingwin2.png](../Images/cff43484e462b0df38ba215dd67e6922.png)](../_images/slidingwin2.png)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/slidingwin2.png](../Images/cff43484e462b0df38ba215dd67e6922.png)'
- en: Fig. 51 The sliding window[#](#id16 "Link to this image")
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 51 滑动窗口[#](#id16 "链接到这张图片")
- en: '[Fig. 52](#fig-sliding-win-ex) illustrates the operation of the sliding window.
    It uses a sliding window of three segments. The sender can thus transmit three
    segments before being forced to wait for an acknowledgment. The sliding window
    moves to the higher sequence numbers upon the reception of each acknowledgment.
    When the first acknowledgment (OK0) is received, it enables the sender to move
    its sliding window to the right and sequence number 3 becomes available. This
    sequence number is used later to transmit the segment containing d.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 52](#fig-sliding-win-ex) 说明了滑动窗口的操作。它使用三个段的滑动窗口。因此，发送者可以在被迫等待确认之前发送三个段。在收到每个确认后，滑动窗口会移动到更高的序列号。当收到第一个确认（OK0）时，它允许发送者将其滑动窗口向右移动，序列号
    3 变得可用。这个序列号后来被用来发送包含 d 的段。'
- en: '[![../_images/gbnwin.png](../Images/b5fde7825c12c07ce8b77cc1e5f37556.png)](../_images/gbnwin.png)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/gbnwin.png](../Images/b5fde7825c12c07ce8b77cc1e5f37556.png)'
- en: Fig. 52 Sliding window example[#](#id17 "Link to this image")
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 52 滑动窗口示例[#](#id17 "链接到这张图片")
- en: In practice, as the segment header includes an n bits field to encode the sequence
    number, only the sequence numbers between \(0\) and \(2^{n}-1\) can be used. This
    implies that, during a long transfer, the same sequence number will be used for
    different segments and the sliding window will wrap. This is illustrated in [Fig.
    53](#fig-sliding-win-modulo) assuming that 2 bits are used to encode the sequence
    number in the segment header. Note that upon reception of OK1, the sender slides
    its window and can use sequence number 0 again.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于段头包括一个用于编码序列号的 n 位字段，因此只能使用 \(0\) 到 \(2^{n}-1\) 之间的序列号。这意味着，在长时间传输过程中，相同的序列号将被用于不同的段，滑动窗口将回绕。这如图
    53 [图 53](#fig-sliding-win-modulo) 所示，假设在段头中使用 2 位来编码序列号。请注意，在收到 OK1 后，发送者滑动其窗口，并可以再次使用序列号
    0。
- en: '[![../_images/gbnwinex.png](../Images/0ef78f3981c477d103876d2f7358bdd3.png)](../_images/gbnwinex.png)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/gbnwinex.png](../Images/0ef78f3981c477d103876d2f7358bdd3.png)'
- en: Fig. 53 Utilization of the sliding window with modulo arithmetic[#](#id18 "Link
    to this image")
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 53 使用模运算的滑动窗口利用[#](#id18 "链接到这张图片")
- en: 'Unfortunately, segment losses do not disappear because a reliable protocol
    uses a sliding window. To recover from losses, a sliding window protocol must
    define :'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于可靠协议使用滑动窗口，段丢失并不会消失。为了从丢失中恢复，滑动窗口协议必须定义：
- en: a heuristic to detect losses
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于检测丢失的启发式方法
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a retransmission strategy to retransmit the lost segments
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种重传策略，用于重传丢失的段
- en: The simplest sliding window protocol uses the go-back-n recovery. Intuitively,
    go-back-n operates as follows. A go-back-n receiver is as simple as possible.
    It only accepts the segments that arrive in-sequence. A go-back-n receiver discards
    any out-of-sequence segment that it receives. When go-back-n receives a data segment,
    it always returns an acknowledgment containing the sequence number of the last
    in-sequence segment that it has received. This acknowledgment is said to be cumulative.
    When a go-back-n receiver sends an acknowledgment for sequence number x, it implicitly
    acknowledges the reception of all segments whose sequence number is earlier than
    x. A key advantage of these cumulative acknowledgments is that it is easy to recover
    from the loss of an acknowledgment. Consider for example a go-back-n receiver
    that received segments 1, 2 and 3. It sent OK1, OK2 and OK3. Unfortunately, OK1
    and OK2 were lost. Thanks to the cumulative acknowledgments, when the sender receives
    OK3, it knows that all three segments have been correctly received.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的滑动窗口协议使用 go-back-n 恢复。直观地说，go-back-n 如下操作。Go-back-n 接收方尽可能简单。它只接受按顺序到达的段。Go-back-n
    接收方丢弃它接收到的任何顺序错误的段。当 go-back-n 接收到数据段时，它总是返回一个包含它已接收的最后顺序段的序列号的确认。这种确认被称为累积的。当一个
    go-back-n 接收方为序列号 x 发送确认时，它隐式地确认了所有序列号早于 x 的段的接收。这些累积确认的一个关键优点是，从确认丢失中恢复很容易。例如，考虑一个接收了段
    1、2 和 3 的 go-back-n 接收方。它发送了 OK1、OK2 和 OK3。不幸的是，OK1 和 OK2 丢失了。多亏了累积确认，当发送方收到 OK3
    时，它知道所有三个段都已正确接收。
- en: '[Fig. 54](#fig-fsm-gbn-receiver) shows the FSM of a simple go-back-n receiver.
    This receiver uses two variables : lastack and next. next is the next expected
    sequence number and lastack the sequence number of the last data segment that
    has been acknowledged. The receiver only accepts the segments that are received
    in sequence. maxseq is the number of different sequence numbers (\(2^n\)).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 54](#fig-fsm-gbn-receiver)显示了简单 go-back-n 接收方的状态机。此接收方使用两个变量：lastack 和 next。next
    是下一个期望的序列号，lastack 是已确认的最后数据段的序列号。接收方只接受按顺序接收到的段。maxseq 是不同序列号的数量(\(2^n\))。'
- en: '![Figure made with TikZ](../Images/129311f9bf007c55636d82806ff9a8ec.png)'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的照片](../Images/129311f9bf007c55636d82806ff9a8ec.png)'
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 54 Go-back-n: receiver FSM'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 54 Go-back-n：接收方状态机
- en: A go-back-n sender is also very simple as shown in [Fig. 55](#fig-fsm-gbn-sender).
    It uses a sending buffer that can store an entire sliding window of segments [[2]](#fsizesliding).
    The segments are sent with increasing sequence numbers (modulo maxseq). The sender
    must wait for an acknowledgment once its sending buffer is full. When a go-back-n
    sender receives an acknowledgment, it removes from the sending buffer all the
    acknowledged segments and uses a retransmission timer to detect segment losses.
    A simple go-back-n sender maintains one retransmission timer per connection. This
    timer is started when the first segment is sent. When the go-back-n sender receives
    an acknowledgment, it restarts the retransmission timer only if there are still
    unacknowledged segments in its sending buffer. When the retransmission timer expires,
    the go-back-n sender assumes that all the unacknowledged segments currently stored
    in its sending buffer have been lost. It thus retransmits all the unacknowledged
    segments in the buffer and restarts its retransmission timer.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Go-back-n 发送方也非常简单，如[图 55](#fig-fsm-gbn-sender)所示。它使用一个发送缓冲区，可以存储整个滑动窗口的段[[2]](#fsizesliding)。段以递增的序列号（模
    maxseq）发送。发送方在其发送缓冲区满后必须等待确认。当 go-back-n 发送方收到确认时，它会从发送缓冲区中移除所有已确认的段，并使用重传计时器来检测段丢失。简单的
    go-back-n 发送方为每个连接维护一个重传计时器。该计时器在发送第一个段时启动。当 go-back-n 发送方收到确认时，只有在其发送缓冲区中仍有未确认的段时，它才会重新启动重传计时器。当重传计时器超时，go-back-n
    发送方假定其发送缓冲区中当前存储的所有未确认段都已丢失。因此，它重新传输缓冲区中的所有未确认段，并重新启动其重传计时器。
- en: '![Figure made with TikZ](../Images/86718f7fdab6919b9def71253750e50a.png)'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的照片](../Images/86718f7fdab6919b9def71253750e50a.png)'
- en: ''
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 55 Go-back-n: sender FSM'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 55 Go-back-n：发送方状态机
- en: The operation of go-back-n is illustrated in [Fig. 56](#fig-gbn-example). In
    this figure, note that upon reception of the out-of-sequence segment D(2,c), the
    receiver returns a cumulative acknowledgment C(OK,0) that acknowledges all the
    segments that have been received in sequence. The lost segment is retransmitted
    upon the expiration of the retransmission timer.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n的操作在[图56](#fig-gbn-example)中说明。在此图中，请注意，在接收到乱序段D(2,c)后，接收器返回累积确认C(OK,0)，确认已按顺序接收的所有段。丢失的段在重传计时器到期后重新传输。
- en: '[![../_images/gbnex2.png](../Images/7c58d5fa667aca0d9275af765599720a.png)](../_images/gbnex2.png)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/gbnex2.png](../Images/7c58d5fa667aca0d9275af765599720a.png)](../_images/gbnex2.png)'
- en: 'Fig. 56 Go-back-n : example[#](#id21 "Link to this image")'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图56 Go-back-n：示例[#](#id21 "链接到此图像")
- en: 'The main advantage of go-back-n is that it can be easily implemented, and it
    can also provide good performance when only a few segments are lost. However,
    when there are many losses, the performance of go-back-n quickly drops for two
    reasons :'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n的主要优势是它易于实现，并且当只有少量段丢失时，它也可以提供良好的性能。然而，当有大量丢失时，go-back-n的性能会迅速下降，原因有两个：
- en: the go-back-n receiver does not accept out-of-sequence segments
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: go-back-n接收器不接受乱序段
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the go-back-n sender retransmits all unacknowledged segments once it has detected
    a loss
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: go-back-n发送器在检测到丢失后，重新传输所有未确认的段
- en: '[PRE4]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Selective repeat is a better strategy to recover from losses. Intuitively, selective
    repeat allows the receiver to accept out-of-sequence segments. Furthermore, when
    a selective repeat sender detects losses, it only retransmits the segments that
    have been lost and not the segments that have already been correctly received.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传是恢复丢失数据的一种更好的策略。直观地说，选择重传允许接收器接受乱序段。此外，当选择重传发送器检测到丢失时，它只重传丢失的段，而不是已经正确接收的段。
- en: A selective repeat receiver maintains a sliding window of W segments and stores
    in a buffer the out-of-sequence segments that it receives. [Fig. 57](#fig-sr-rwin)
    shows a five-segment receive window on a receiver that has already received segments
    7 and 9.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传接收器维护一个包含W个段的滑动窗口，并将接收到的乱序段存储在缓冲区中。[图57](#fig-sr-rwin)显示了一个接收器已经接收了段7和9的五个段接收窗口。
- en: '[![../_images/selrepeatwin2.png](../Images/65c1ca27e931f581cf93b7c9874c2977.png)](../_images/selrepeatwin2.png)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/selrepeatwin2.png](../Images/65c1ca27e931f581cf93b7c9874c2977.png)](../_images/selrepeatwin2.png)'
- en: Fig. 57 The receiving window with selective repeat[#](#id22 "Link to this image")
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图57 选择重传的接收窗口[#](#id22 "链接到此图像")
- en: A selective repeat receiver discards all segments having an invalid CRC, and
    maintains the variable lastack as the sequence number of the last in-sequence
    segment that it has received. The receiver always includes the value of lastack
    in the acknowledgments that it sends. Some protocols also allow the selective
    repeat receiver to acknowledge the out-of-sequence segments that it has received.
    This can be done for example by placing the list of the correctly received, but
    out-of-sequence segments in the acknowledgments together with the lastack value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传接收器丢弃所有具有无效CRC的段，并保持变量lastack为其已接收的最后有序段的序列号。接收器始终在其发送的确认中包含lastack的值。某些协议还允许选择重传接收器确认它已接收的乱序段。例如，可以通过在确认中将正确接收但乱序的段列表与lastack值一起放置来实现。
- en: When a selective repeat receiver receives a data segment, it first verifies
    whether the segment is inside its receiving window. If yes, the segment is placed
    in the receive buffer. If not, the received segment is discarded and an acknowledgment
    containing lastack is sent to the sender. The receiver then removes all consecutive
    segments starting at lastack (if any) from the receive buffer. The payloads of
    these segments are delivered to the user, lastack and the receiving window are
    updated, and an acknowledgment acknowledging the last segment received in sequence
    is sent.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择重传接收器接收到一个数据段时，它首先验证该段是否在其接收窗口内。如果是，该段将被放置在接收缓冲区中。如果不是，接收到的段将被丢弃，并向发送者发送包含lastack的确认。接收器随后从接收缓冲区中移除从lastack开始的（如果有）所有连续段。这些段的负载被交付给用户，lastack和接收窗口被更新，并发送一个确认，确认已按顺序接收的最后一段。
- en: The selective repeat sender maintains a sending buffer that can store up to
    W unacknowledged segments. These segments are sent as long as the sending buffer
    is not full. Several implementations of a selective repeat sender are possible.
    A simple implementation associates one retransmission timer to each segment. The
    timer is started when the segment is sent and canceled upon reception of an acknowledgment
    that covers this segment. When a retransmission timer expires, the corresponding
    segment is retransmitted and this retransmission timer is restarted. When an acknowledgment
    is received, all the segments that are covered by this acknowledgment are removed
    from the sending buffer and the sliding window is updated.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性重传发送者维护一个发送缓冲区，可以存储最多 W 个未确认的段。只要发送缓冲区不满，就会发送这些段。选择性重传发送者的几种实现方式是可能的。一种简单的实现方式是为每个段关联一个重传计时器。当发送段时启动计时器，并在接收到覆盖此段的确认时取消计时器。当重传计时器超时时，相应的段被重新传输，并且这个重传计时器被重新启动。当接收到确认时，所有被此确认覆盖的段将从发送缓冲区中移除，并且滑动窗口被更新。
- en: '[Fig. 58](#fig-sr-example) illustrates the operation of selective repeat when
    segments are lost. In this figure, C(OK,x) is used to indicate that all segments,
    up to and including sequence number x have been received correctly.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 58](#fig-sr-example) 展示了在数据段丢失时选择性重传的操作。在此图中，C(OK,x) 用于表示所有段，包括并至序列号 x 的段都已正确接收。'
- en: '[![../_images/selrepeat.png](../Images/5146331e8d7c7c36361e7fc92750fb1a.png)](../_images/selrepeat.png)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/selrepeat.png](../Images/5146331e8d7c7c36361e7fc92750fb1a.png)](../_images/selrepeat.png)'
- en: 'Fig. 58 Selective repeat : example[#](#id23 "Link to this image")'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 58 选择性重传：示例[#](#id23 "链接到此图像")
- en: Pure cumulative acknowledgments work well with the go-back-n strategy. However,
    with only cumulative acknowledgments a selective repeat sender cannot easily determine
    which segments have been correctly received after a data segment has been lost.
    For example, in the figure above, the second C(OK,0) does not inform explicitly
    the sender of the reception of D(2,c) and the sender could retransmit this segment
    although it has already been received. A possible solution to improve the performance
    of selective repeat is to provide additional information about the received segments
    in the acknowledgments that are returned by the receiver. For example, the receiver
    could add in the returned acknowledgment the list of the sequence numbers of all
    segments that have already been received. Such acknowledgments are sometimes called
    selective acknowledgments. We will provide examples of such acknowledgments in
    the TCP and QUIC protocols later in this book.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 纯累积确认与回退 n 策略配合良好。然而，仅使用累积确认，选择性重传发送者无法轻易确定在数据段丢失后哪些段已被正确接收。例如，在上图中，第二个 C(OK,0)
    并没有明确告知发送者 D(2,c) 的接收情况，而发送者可能会重新传输这个段，尽管它已经被接收。为了提高选择性重传的性能，一个可能的解决方案是在接收者返回的确认中提供关于已接收段的信息。例如，接收者可以在返回的确认中添加已接收所有段的序列号列表。这种确认有时被称为选择性确认。我们将在本书后面的
    TCP 和 QUIC 协议中提供此类确认的示例。
- en: '[PRE5]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Maximum window size with go-back-n and selective repeat
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 回退 n 和选择性重传的最大窗口大小
- en: A reliable protocol that uses n bits to encode its sequence number can send
    up to \(2^n\) successive segments. However, to ensure a reliable delivery of the
    segments, go-back-n and selective repeat cannot use a sending window of \(2^n\)
    segments. Consider first go-back-n and assume that a sender sends \(2^n\) segments.
    These segments are received in-sequence by the destination, but all the returned
    acknowledgments are lost. The sender will retransmit all segments. These segments
    will all be accepted by the receiver and delivered a second time to the user.
    It is easy to see that this problem can be avoided if the maximum size of the
    sending window is \({2^n}-1\) segments. A similar problem occurs with selective
    repeat. However, as the receiver accepts out-of-sequence segments, a sending window
    of \({2^n}-1\) segments is not sufficient to ensure a reliable delivery. It can
    be easily shown that to avoid this problem, a selective repeat sender cannot use
    a window that is larger than \(\frac{2^n}{2}\) segments.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用n位来编码其序列号的可靠协议可以发送多达 \(2^n\) 个连续的段。然而，为了确保段的可信传输，回退n和选择重传不能使用 \(2^n\) 个段的发送窗口。首先考虑回退n，假设发送者发送
    \(2^n\) 个段。这些段按顺序被目的地接收，但所有返回的确认信息都丢失了。发送者将重新传输所有段。这些段都将被接收器接受，并第二次交付给用户。很容易看出，如果发送窗口的最大大小是
    \({2^n}-1\) 个段，则可以避免这个问题。选择重传也存在类似的问题。然而，由于接收器接受非顺序段，\({2^n}-1\) 个段的发送窗口不足以确保可靠交付。可以很容易地证明，为了避免这个问题，选择重传发送者不能使用大于
    \(\frac{2^n}{2}\) 个段的窗口。
- en: Reliable protocols often need to send data in both directions. To reduce the
    overhead caused by the acknowledgments, most reliable protocols use piggybacking.
    Thanks to this technique, an entity can place the acknowledgments and the receive
    window that it advertises for the opposite direction of the data flow inside the
    header of the data segments that it sends. The main advantage of piggybacking
    is that it reduces the overhead as it is not necessary to send a complete segment
    to carry an acknowledgment. This is illustrated in the figure below where the
    acknowledgment number is underlined in the data segments. Piggybacking is only
    used when data flows in both directions. A receiver will generate a pure acknowledgment
    when it does not send data in the opposite direction as shown in the bottom of
    the figure.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠协议通常需要在两个方向上发送数据。为了减少由确认信息引起的开销，大多数可靠协议使用尾随技术。多亏了这项技术，实体可以将确认信息和它为数据流相反方向所声明的接收窗口放置在它发送的数据段头部。尾随的主要优势在于它减少了开销，因为不需要发送一个完整的段来携带确认信息。这在下图中得到了说明，其中确认号在数据段中被加粗。尾随技术仅在数据双向流动时使用。当接收器在相反方向不发送数据时，如图底部所示，它将生成一个纯确认信息。
- en: '[![../_images/piggyback2.png](../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png)](../_images/piggyback2.png)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/piggyback2.png](../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png)](../_images/piggyback2.png)'
- en: Fig. 59 Piggybacking example[#](#id24 "Link to this image")
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图59 尾随示例[#](#id24 "链接到这个图像")
- en: '[PRE6]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Establishing a transport connection[#](#establishing-a-transport-connection
    "Link to this heading")
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立传输连接[#](#establishing-a-transport-connection "链接到这个标题")
- en: Like the connectionless service, the connection-oriented service allows several
    applications running on a given host to exchange data with other hosts. The port
    numbers described earlier for the connectionless service are also used by the
    connection-oriented service to multiplex several applications. Similarly, connection-oriented
    protocols use checksums/CRCs to detect transmission errors and discard segments
    containing an invalid checksum/CRC.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接服务类似，面向连接的服务允许在给定主机上运行的多个应用程序与其他主机交换数据。之前描述的无连接服务所用的端口号也被面向连接的服务用于多路复用多个应用程序。同样，面向连接的协议使用校验和/CRC来检测传输错误并丢弃包含无效校验和/CRC的段。
- en: An important difference between the connectionless service and the connection-oriented
    one is that the transport entities in the latter maintain some state during lifetime
    of the connection. This state is created when a connection is established and
    is removed when it is released.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务和面向连接服务之间的重要区别在于，后者中的传输实体在连接的生命周期内保持一些状态。当建立连接时创建此状态，并在释放时删除。
- en: 'The simplest approach to establish a transport connection would be to define
    two special control segments : CR (Connection Request) and CA (Connection Acknowledgment).
    The CR segment is sent by the transport entity that wishes to initiate a connection.
    If the remote entity wishes to accept the connection, it replies by sending a
    CA segment. The CR and CA segments contain port numbers that allow identifying
    the communicating applications. The transport connection is considered to be established
    once the CA segment has been received. At that point, data segments can be sent
    in both directions.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 建立传输连接的最简单方法可能是定义两个特殊的控制段：CR（连接请求）和CA（连接确认）。CR段由希望发起连接的传输实体发送。如果远程实体希望接受连接，它将通过发送CA段进行回复。CR和CA段包含端口号，这允许识别通信的应用程序。一旦收到CA段，就认为传输连接已经建立。在此点，可以双向发送数据段。
- en: '![msc {'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供商", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "CR", arcskip="1", textcolour=red];
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "CR", arcskip="1", textcolour=red];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "CA", arcskip="1", textcolour=red];
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "CA", arcskip="1", textcolour=red];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接已建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接已建立" ];
- en: '}](../Images/384affb0102503143b8af853578161f2.png)<map id="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"
    name="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"></map>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/384affb0102503143b8af853578161f2.png)<map id="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"
    name="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"></map>'
- en: Unfortunately, this is not sufficient given the unreliability of the network
    layer. Since the network layer is imperfect, the CR or CA segments can be lost,
    delayed, or suffer from transmission errors. To deal with these problems, the
    control segments must be protected by a CRC or a checksum to detect transmission
    errors. Furthermore, since the CA segment acknowledges the reception of the CR
    segment, the CR segment should be protected using a retransmission timer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑到网络层的不可靠性，这仍然是不够的。由于网络层不完美，CR或CA段可能会丢失、延迟或出现传输错误。为了处理这些问题，控制段必须通过CRC或校验和来保护，以检测传输错误。此外，由于CA段确认了CR段的接收，CR段应该使用重传定时器进行保护。
- en: Unfortunately, this scheme is not sufficient to ensure the reliability of the
    transport service. Consider for example a short-lived transport connection where
    a single, but important transfer (e.g. money transfer from a bank account) is
    sent. Such a short-lived connection starts with a CR segment acknowledged by a
    CA segment, then the data segment is sent, acknowledged and the connection terminates.
    Unfortunately, as the network layer service is unreliable, delays combined to
    retransmissions may lead to the situation depicted in the figure below, where
    a delayed CR and data segments from a former connection are accepted by the receiving
    entity as valid segments, and the corresponding data is delivered to the user.
    Duplicating SDUs is not acceptable, and the transport protocol must solve this
    problem.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个方案不足以确保运输服务的可靠性。例如，考虑一个短暂的运输连接，其中发送了一个单一但重要的传输（例如，从银行账户转账）。这样的短暂连接以一个由CA段确认的CR段开始，然后发送数据段，确认并终止连接。不幸的是，由于网络层服务不可靠，延迟加上重传可能导致下图中所示的情况，即接收实体将来自前一个连接的延迟CR和数据段作为有效段接受，并将相应的数据交付给用户。重复SDU是不可接受的，传输协议必须解决这个问题。
- en: '![msc {'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供商", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "CR", arcskip="1", textcolour=red];
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "CR", arcskip="1", textcolour=red];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "CA", arcskip="1", textcolour=red];
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "CA", arcskip="1", textcolour=red];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ] ,
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ];
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ] ,
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ];
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ];
- en: z>>c [ label = "CR", arcskip="1", textcolour=red];
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "CR", arcskip="1", textcolour=red];
- en: c=>d1 [ label = "How to detect duplicates ?" ],
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "如何检测重复？" ],
- en: c>>b [ label = "CA", arcskip="1", textcolour=red];
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "CA", arcskip="1", textcolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: z>>c [ label = "D", arcskip="1"];
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "D", arcskip="1"];
- en: '}](../Images/450730721625aed82431f20387763529.png)<map id="453dea7b2a70bc75af50524c87354c0a129e1d05"
    name="453dea7b2a70bc75af50524c87354c0a129e1d05"></map>'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/450730721625aed82431f20387763529.png)<map id="453dea7b2a70bc75af50524c87354c0a129e1d05"
    name="453dea7b2a70bc75af50524c87354c0a129e1d05"></map>'
- en: To avoid these duplicates, transport protocols require the network layer to
    bound the Maximum Segment Lifetime (MSL). The organization of the network must
    guarantee that no segment remains in the network for longer than MSL seconds.
    For example, on today’s Internet, MSL is expected to be 2 minutes. To avoid duplicate
    transport connections, transport protocol entities must be able to safely distinguish
    between a duplicate CR segment and a new CR segment, without forcing each transport
    entity to remember all the transport connections that it has established in the
    past.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些重复，传输协议要求网络层限制最大段生存时间（MSL）。网络的组织必须保证没有任何段在网络中停留超过MSL秒。例如，在今天的互联网上，MSL预计为2分钟。为了避免重复的传输连接，传输协议实体必须能够安全地区分重复的CR段和新CR段，而无需迫使每个传输实体记住它过去建立的所有传输连接。
- en: 'A classical solution to avoid remembering the previous transport connections
    to detect duplicates is to use a clock inside each transport entity. This transport
    clock has the following characteristics :'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免记住先前的传输连接以检测重复，一个经典的解决方案是在每个传输实体内部使用一个时钟。这个传输时钟具有以下特性：
- en: the transport clock is implemented as a k bits counter and its clock cycle is
    such that \(2^k \times cycle >> MSL\). Furthermore, the transport clock counter
    is incremented every clock cycle and after each connection establishment. This
    clock is illustrated in [Fig. 60](#fig-transport-clock).
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输时钟实现为一个k位计数器，其时钟周期为\(2^k \times cycle >> MSL\)。此外，传输时钟计数器在每个时钟周期和每次连接建立后都会递增。此时钟如图60所示[图60](#fig-transport-clock)。
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the transport clock must continue to be incremented even if the transport entity
    stops or reboots
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使传输实体停止或重启，传输时钟也必须继续递增
- en: '[![../_images/transport-clock.png](../Images/036312a7c0aeea69142b1e45c82f9114.png)](../_images/transport-clock.png)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-clock.png](../Images/036312a7c0aeea69142b1e45c82f9114.png)](../_images/transport-clock.png)'
- en: Fig. 60 Transport clock[#](#id25 "Link to this image")
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图60 传输时钟[#](#id25 "链接到这张图片")
- en: It should be noted that transport clocks do not need and usually are not synchronized
    to the real-time clock. Precisely synchronizing real-time clocks is an interesting
    problem, but it is outside the scope of this document. See [[Mills2006]](../bibliography.html#mills2006)
    for a detailed discussion on synchronizing the real-time clock.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意，传输时钟不需要，通常也不与实时时钟同步。精确同步实时时钟是一个有趣的问题，但它超出了本文档的范围。有关同步实时时钟的详细讨论，请参阅[[Mills2006]](../bibliography.html#mills2006)。
- en: 'This transport clock can be combined with an exchange of three segments, called
    the three way handshake, to detect duplicates. This three way handshake occurs
    as follows :'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个传输时钟可以与三个段的交换结合使用，称为三次握手，以检测重复。这个三次握手如下发生：
- en: The initiating transport entity sends a CR segment. This segment requests the
    establishment of a transport connection. It contains a port number (not shown
    in the figure) and a sequence number (seq=x in the figure below) whose value is
    extracted from the transport clock. The transmission of the CR segment is protected
    by a retransmission timer.
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始传输实体发送一个CR段。此段请求建立传输连接。它包含一个端口号（图中未显示）和一个序列号（图下方的seq=x），其值从传输时钟中提取。CR段的传输由重传定时器保护。
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The remote transport entity processes the CR segment and creates state for the
    connection attempt. At this stage, the remote entity does not yet know whether
    this is a new connection attempt or a duplicate segment. It returns a CA segment
    that contains an acknowledgment number to confirm the reception of the CR segment
    (ack=x in the figure below) and a sequence number (seq=y in the figure below)
    whose value is extracted from its transport clock. At this stage, the connection
    is not yet established.
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程传输实体处理CR段并为连接尝试创建状态。在这个阶段，远程实体还不知道这是新的连接尝试还是重复的段。它返回一个包含确认号以确认CR段接收的CA段（图下方的ack=x）和一个序列号（图下方的seq=y），其值从其传输时钟中提取。在这个阶段，连接尚未建立。
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The initiating entity receives the CA segment. The acknowledgment number of
    this segment confirms that the remote entity has correctly received the CR segment.
    The transport connection is considered to be established by the initiating entity
    and the numbering of the data segments starts at sequence number x. Before sending
    data segments, the initiating entity must acknowledge the received CA segments
    by sending another CA segment.
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始实体接收CA段。此段的确认号确认远程实体已正确接收CR段。初始实体认为传输连接已建立，数据段的编号从序列号x开始。在发送数据段之前，初始实体必须通过发送另一个CA段来确认接收到的CA段。
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The remote entity considers the transport connection to be established after
    having received the segment that acknowledges its CA segment. The numbering of
    the data segments sent by the remote entity starts at sequence number y.
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程实体在接收到确认其CA段的段落后，认为传输连接已经建立。远程实体发送的数据段编号从序列号y开始。
- en: The three way handshake is illustrated in [Fig. 61](#fig-three-way-handshake).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 三次握手在[图61](#fig-three-way-handshake)中说明。
- en: '[![../_images/transport-twh.png](../Images/73ba69b884756214c68976e4bd783556.png)](../_images/transport-twh.png)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-twh.png](../Images/73ba69b884756214c68976e4bd783556.png)](../_images/transport-twh.png)'
- en: Fig. 61 The three-way handshake[#](#id26 "Link to this image")
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图61 三次握手[#](#id26 "链接到这张图片")
- en: Thanks to the three-way handshake, transport entities avoid duplicate transport
    connections. This is illustrated by considering the three scenarios below.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了三次握手，传输实体避免了重复的传输连接。这可以通过考虑以下三个场景来说明。
- en: The first scenario ([Fig. 62](#fig-twa-scenario1)) is when the remote entity
    receives an old CR segment. It considers this CR segment as a connection establishment
    attempt and replies by sending a CA segment. However, the initiating host cannot
    match the received CA segment with a previous connection attempt. It sends a control
    segment (REJECT in the figure below) to cancel the spurious connection attempt.
    The remote entity cancels the connection attempt upon reception of this control
    segment.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景（[图62](#fig-twa-scenario1)）是远程实体接收到一个旧的CR段。它认为这个CR段是连接建立尝试，并通过发送CA段进行回复。然而，初始主机无法将接收到的CA段与先前的连接尝试匹配。它发送一个控制段（图下方的REJECT）来取消虚假的连接尝试。远程实体在接收到这个控制段后取消连接尝试。
- en: '[![../_images/transport-twh-dup.png](../Images/81f6e94d2c77bba094868c0725d75ae7.png)](../_images/transport-twh-dup.png)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-twh-dup.png](../Images/81f6e94d2c77bba094868c0725d75ae7.png)](../_images/transport-twh-dup.png)'
- en: 'Fig. 62 Three-way handshake : recovery from a duplicate CR[#](#id27 "Link to
    this image")'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图62 三次握手：从重复的CR段恢复[#](#id27 "链接到这张图片")
- en: A second scenario, shown in [Fig. 63](#fig-twa-scenario2) is when the initiating
    entity sends a CR segment that does not reach the remote entity and receives a
    duplicate CA segment from a previous connection attempt. This duplicate CA segment
    cannot contain a valid acknowledgment for the CR segment as the sequence number
    of the CR segment was extracted from the transport clock of the initiating entity.
    The CA segment is thus rejected and the CR segment is retransmitted upon expiration
    of the retransmission timer.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图63](#fig-twa-scenario2)中显示的第二个场景是，当发起实体发送的CR段没有到达远程实体，并从之前的连接尝试中收到一个重复的CA段。由于CR段的序列号是从发起实体的传输时钟中提取的，这个重复的CA段不能包含对CR段的有效确认。因此，CA段被拒绝，并在重传计时器到期时重新传输CR段。
- en: '[![../_images/transport-twh-dup2.png](../Images/4a3c5e9fdcb7671a490f8c5fbebda7f5.png)](../_images/transport-twh-dup2.png)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/4a3c5e9fdcb7671a490f8c5fbebda7f5.png)(../_images/transport-twh-dup2.png)'
- en: 'Fig. 63 Three-way handshake : recovery from a duplicate CA[#](#id28 "Link to
    this image")'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图63 三次握手：从重复的CA恢复[#](#id28 "链接到这张图片")
- en: The last scenario shown in [Fig. 64](#fig-twa-scenario3) is less likely, but
    it is important to consider it as well. The remote entity receives an old CR segment.
    It notes the connection attempt and acknowledges it by sending a CA segment. The
    initiating entity does not have a matching connection attempt and replies by sending
    a REJECT. Unfortunately, this segment never reaches the remote entity. Instead,
    the remote entity receives a retransmission of an older CA segment that contains
    the same sequence number as the first CR segment. This CA segment cannot be accepted
    by the remote entity as a confirmation of the transport connection as its acknowledgment
    number cannot have the same value as the sequence number of the first CA segment.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图64](#fig-twa-scenario3)中显示的最后一个场景不太可能发生，但同样需要考虑。远程实体收到一个旧的CR段。它记录连接尝试并通过发送CA段来确认它。发起实体没有匹配的连接尝试，并通过发送REJECT进行回复。不幸的是，这个段从未到达远程实体。相反，远程实体收到一个包含与第一个CR段相同序列号的旧CA段的重新传输。由于确认号不能与第一个CA段的序列号相同，远程实体不能接受这个CA段作为传输连接的确认。
- en: '[![../_images/transport-twh-dup3.png](../Images/9e3c98b89e77408b7654305f9b1a2be3.png)](../_images/transport-twh-dup3.png)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/9e3c98b89e77408b7654305f9b1a2be3.png)(../_images/transport-twh-dup3.png)'
- en: 'Fig. 64 Three-way handshake : recovery from duplicates CR and CA[#](#id29 "Link
    to this image")'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图64 三次握手：从重复的CR和CA恢复[#](#id29 "链接到这张图片")
- en: Transferring data on a transport connection[#](#transferring-data-on-a-transport-connection
    "Link to this heading")
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在传输连接上传输数据[#](#transferring-data-on-a-transport-connection "链接到这个标题")
- en: Now that the transport connection has been established, it can be used to transfer
    data. To ensure a reliable delivery of the data, the transport protocol will include
    sliding windows, retransmission timers and go-back-n or selective repeat. However,
    we cannot simply reuse these techniques because a reliable transport protocol
    also needs to cope with three additional types of errors (i) variable delays,
    (ii) out-f-sequence delivery and (iii) segment duplication.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在传输连接已经建立，它可以用来传输数据。为了确保数据的可靠传输，传输协议将包括滑动窗口、重传计时器和后退N或选择重传。然而，我们不能简单地重用这些技术，因为可靠的传输协议还需要处理三种额外的错误类型（i）可变延迟，（ii）出序交付和（iii）段重复。
- en: When two hosts are connected by a link, the transmission delay or the round-trip-time
    over the link is almost fixed. In a network that can span the globe, the delays
    and the round-trip-times can vary significantly on a per packet basis. This variability
    can be caused by two factors. First, packets sent through a network do not necessarily
    follow the same path to reach their destination. Second, some packets may be queued
    in the buffers of routers when the load is high and these queuing delays can lead
    to increased end-to-end delays.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个主机通过一个链路连接时，链路上的传输延迟或往返时间几乎是固定的。在一个可以跨越全球的网络中，延迟和往返时间可以基于每个数据包而显著变化。这种变化可以由两个因素引起。首先，通过网络发送的数据包不一定遵循相同的路径到达目的地。其次，当负载高时，一些数据包可能会在路由器的缓冲区中排队，这些排队延迟可能导致端到端延迟的增加。
- en: Another problem is that a network does not always deliver packets in sequence.
    This implies that packets may be reordered by the network. Furthermore, the network
    may sometimes duplicate packets.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是一个网络并不总是按顺序交付数据包。这意味着数据包可能被网络重新排序。此外，网络有时可能会重复数据包。
- en: The last issue that needs to be dealt with in the transport layer is the transmission
    of large SDUs. In our example, we have used short SDUs which fit easily inside
    segments. Some applications generate SDUs that are much larger than the maximum
    size of a packet in the network layer. The transport layer needs to include mechanisms
    to fragment and reassemble these large SDUs.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层需要处理最后一个问题，即大SDU的传输。在我们的例子中，我们使用了短SDU，它们可以轻松地放入段中。某些应用程序生成的SDU比网络层中数据包的最大尺寸大得多。传输层需要包括机制来分片和重新组装这些大SDU。
- en: To deal with all these characteristics of the network layer, we need to adapt
    the go-back-n and selective repeat techniques that we have introduced earlier.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理网络层的所有这些特性，我们需要调整我们之前介绍过的回退N和选择重传技术。
- en: The ability to detect transmission errors remains important. Each segment contains
    a CRC/checksum which is computed over the entire segment (header and payload)
    by the sender and inserted in the header. The receiver recomputes the CRC/checksum
    for each received segment and discards all segments with an invalid CRC.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 检测传输错误的能力仍然很重要。每个段都包含一个CRC/校验和，这是由发送方在整个段（头部和有效载荷）上计算的，并插入到头部中。接收方将重新计算每个接收到的段的CRC/校验和，并丢弃所有无效CRC的段。
- en: Reliable transport protocols also use sequence numbers and acknowledgment numbers.
    While our example protocols used one sequence number per segment, some reliable
    transport protocols consider all the data transmitted as a stream of bytes. In
    these protocols, the sequence number placed in the segment header corresponds
    to the position of the first byte of the payload in the bytestream. This sequence
    number allows detecting losses but also enables the receiver to reorder the out-of-sequence
    segments. This is illustrated in the figure below.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的传输协议也使用序列号和确认号。虽然我们的示例协议在每个段中使用一个序列号，但一些可靠的传输协议将所有传输的数据视为字节流。在这些协议中，放置在段头部的序列号对应于有效载荷中第一个字节的字节流位置。这个序列号允许检测丢失，同时也使接收方能够重新排序乱序的段。这在下图中得到了说明。
- en: '![msc {'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(abcde)" ] ,
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(abcde)" ] ,
- en: b>>c [ arcskip="1", label="1:abcde"];
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="1:abcde"];
- en: c=>d [label="DATA.ind(abcde)"];
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [label="DATA.ind(abcde)"];
- en: '|||;'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(fghijkl)" ] ,
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(fghijkl)" ] ,
- en: b>>c [ arcskip="1", label="6:fghijkl"];
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="6:fghijkl"];
- en: c=>d [label="DATA.ind(fghijkl)"];
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [label="DATA.ind(fghijkl)"];
- en: '}](../Images/d415b226c2c0f1663b1289acf10b1351.png)<map id="3c7d33b83d1006864217839e39a4133300ffe3b0"
    name="3c7d33b83d1006864217839e39a4133300ffe3b0"></map>'
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d415b226c2c0f1663b1289acf10b1351.png)<map id="3c7d33b83d1006864217839e39a4133300ffe3b0"
    name="3c7d33b83d1006864217839e39a4133300ffe3b0"></map>'
- en: Using sequence numbers to count bytes has also one advantage when the transport
    layer needs to fragment SDUs in several segments. The figure below shows the fragmentation
    of a large SDU in two segments. Upon reception of the segments, the receiver will
    use the sequence numbers to correctly reorder the data.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当传输层需要在多个段中分片SDU时，使用序列号来计数字节也有一个优点。下面的图示显示了将一个大SDU分片成两个段。在接收到段之后，接收方将使用序列号来正确地重新排序数据。
- en: '![msc {'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(abcdefghijkl)" ] ,
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(abcdefghijkl)" ] ,
- en: b>>c [ arcskip="1", label="1:abcde"];
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="1:abcde"];
- en: '|||;'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ arcskip="1", label="6:fghijkl"];
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="6:fghijkl"];
- en: c=>d [label="DATA.ind(abcdefghijkl)"];
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [label="DATA.ind(abcdefghijkl)"];
- en: '}](../Images/e9784923b6b5cd4438e6db36fa5b219d.png)<map id="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"
    name="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"></map>'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e9784923b6b5cd4438e6db36fa5b219d.png)<map id="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"
    name="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"></map>'
- en: Compared to our simple protocols, reliable transport protocols encode their
    sequence numbers using more bits. 32 bits and 64 bits sequence numbers are frequent
    in the transport layer. This large sequence number space is motivated by two reasons.
    First, since the sequence number is incremented for each transmitted byte, a single
    segment may consume one or several thousands of sequence numbers. Second, a reliable
    transport protocol must be able to detect delayed segments. This can only be done
    if the number of bytes transmitted during the MSL period is smaller than the sequence
    number space. Otherwise, there is a risk of accepting duplicate segments.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的简单协议相比，可靠的传输协议使用更多的位来编码它们的序列号。32位和64位序列号在传输层很常见。这个大的序列号空间有两个原因。首先，由于序列号对每个传输的字节进行递增，一个单独的段可能消耗一个或几个千个序列号。其次，可靠的传输协议必须能够检测延迟的段。这只能在MSS期间传输的字节数小于序列号空间的情况下完成。否则，存在接受重复段的风险。
- en: Go-back-n and selective repeat can be used in the transport layer as in the
    datalink layer. Since the network layer does not guarantee an in-order delivery
    of the packets, a transport entity should always store the segments that it receives
    out-of-sequence. For this reason, most transport protocols will opt for some form
    of selective repeat mechanism.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 回退N和选择重传可以在传输层使用，就像在数据链路层一样。由于网络层不保证数据包的有序交付，传输实体应该始终存储它接收到的非顺序段。因此，大多数传输协议将选择某种选择重传机制。
- en: In simple protocols, the sliding window has usually a fixed size which depends
    on the amount of available buffers. A single transport layer entity serves a large
    and varying number of application processes. Each transport layer entity manages
    a pool of buffers that needs to be shared between all these processes. Transport
    entity are usually implemented inside the operating system kernel and shares memory
    with other parts of the system. Furthermore, a transport layer entity must support
    several (possibly hundreds or thousands) of transport connections at the same
    time. This implies that the memory which can be used to support the sending or
    the receiving buffer of a transport connection may change during the lifetime
    of the connection [[3]](#fautotune) . Thus, a transport protocol must allow the
    sender and the receiver to adjust their window sizes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的协议中，滑动窗口通常具有一个固定的大小，这个大小取决于可用缓冲区的大小。单个传输层实体服务于大量且变化的应用进程。每个传输层实体管理一个需要在这些所有进程间共享的缓冲区池。传输实体通常在操作系统内核内部实现，并与系统的其他部分共享内存。此外，传输层实体必须同时支持多个（可能是数百或数千个）传输连接。这意味着可以用于支持传输连接的发送或接收缓冲区的内存可能会在连接的生命周期内发生变化
    [[3]](#fautotune)。因此，传输协议必须允许发送方和接收方调整它们的窗口大小。
- en: 'To deal with this issue, transport protocols allow the receiver to advertise
    the current size of its receiving window in all the acknowledgments that it sends.
    The receiving window advertised by the receiver bounds the size of the sending
    buffer used by the sender. In practice, the sender maintains two state variables
    : swin, the size of its sending window (that may be adjusted by the system) and
    rwin, the size of the receiving window advertised by the receiver. At any time,
    the number of unacknowledged segments cannot be larger than \(\min(swin,rwin)\)
    [[4]](#facklost) . The utilization of dynamic windows is illustrated in figure
    [Fig. 65](#fig-transport-dynamic-win).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，传输协议允许接收方在它发送的所有确认中宣布其当前接收窗口的大小。接收方宣布的接收窗口限制了发送方使用的发送缓冲区的大小。在实践中，发送方维护两个状态变量：swin，其发送窗口的大小（可能由系统调整）和rwin，接收方宣布的接收窗口的大小。在任何时候，未确认段的数量不能超过
    \(\min(swin,rwin)\) [[4]](#facklost)。动态窗口的使用在图[图65](#fig-transport-dynamic-win)中说明。
- en: '[![../_images/transport-dwin.svg](../Images/b265eb3f8dd59868de804ccf800a887f.png)](../_images/transport-dwin.svg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-dwin.svg](../Images/b265eb3f8dd59868de804ccf800a887f.png)'
- en: Fig. 65 Dynamic receiving window[#](#id30 "Link to this image")
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图65 动态接收窗口[#](#id30 "链接到这张图片")
- en: The receiver may adjust its advertised receive window based on its current memory
    consumption, but also to limit the bandwidth used by the sender. In practice,
    the receive buffer can also shrink as the application may not able to process
    the received data quickly enough. In this case, the receive buffer may be completely
    full and the advertised receive window may shrink to 0. When the sender receives
    an acknowledgment with a receive window set to 0, it is blocked until it receives
    an acknowledgment with a positive receive window. Unfortunately, as shown in [Fig.
    66](#fig-win-deadlock), the loss of this acknowledgment could cause a deadlock
    as the sender waits for an acknowledgment while the receiver is waiting for a
    data segment.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器可能会根据其当前的内存消耗调整其声明的接收窗口，同时也为了限制发送者使用的带宽。在实践中，接收缓冲区也可能缩小，因为应用程序可能无法快速处理接收到的数据。在这种情况下，接收缓冲区可能会完全填满，声明的接收窗口可能会缩小到0。当发送者收到一个将接收窗口设置为0的确认时，它会阻塞，直到它收到一个具有正接收窗口的确认。不幸的是，如图[图66](#fig-win-deadlock)所示，这种确认的丢失可能导致死锁，因为发送者在等待确认的同时，接收者在等待数据段。
- en: '[![../_images/transport-win-deadlock.png](../Images/66586c6dcc13b89a7b00c779de739ebc.png)](../_images/transport-win-deadlock.png)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-win-deadlock.png](../Images/66586c6dcc13b89a7b00c779de739ebc.png)'
- en: Fig. 66 Risk of deadlock with dynamic windows[#](#id31 "Link to this image")
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图66 动态窗口的死锁风险[#](#id31 "链接到这个图像")
- en: 'To solve this problem, transport protocols rely on a special timer : the persistence
    timer. This timer is started by the sender whenever it receives an acknowledgment
    advertising a receive window set to 0. When the timer expires, the sender retransmits
    an old segment in order to force the receiver to send a new acknowledgment, and
    hence send the current receive window size.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，传输协议依赖于一个特殊的计时器：持久计时器。当发送者收到一个声明接收窗口设置为0的确认时，它会启动这个计时器。当计时器到期时，发送者重新传输一个旧的段，以迫使接收者发送一个新的确认，从而发送当前的接收窗口大小。
- en: To conclude our description of the basic mechanisms found in transport protocols,
    we still need to discuss the impact of segments arriving in the wrong order. If
    two consecutive segments are reordered, the receiver relies on their sequence
    numbers to reorder them in its receive buffer. Unfortunately, as transport protocols
    reuse the same sequence number for different segments, if a segment is delayed
    for a prolonged period of time, it might still be accepted by the receiver. This
    is illustrated in [Fig. 67](#fig-transport-ambiguity) where segment D(1,b) is
    delayed.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对传输协议中找到的基本机制的描述，我们还需要讨论段到达顺序错误的影响。如果两个连续的段被重新排序，接收器会依赖于它们的序列号在接收缓冲区中重新排序它们。不幸的是，由于传输协议为不同的段重复使用相同的序列号，如果一个段延迟了很长时间，它仍然可能被接收器接受。这如图[图67](#fig-transport-ambiguity)所示，其中段D(1,b)被延迟。
- en: '[![../_images/transport-ambiguities.png](../Images/47226dd629dc43186633321c93f4871f.png)](../_images/transport-ambiguities.png)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-ambiguities.png](../Images/47226dd629dc43186633321c93f4871f.png)'
- en: Fig. 67 Ambiguities caused by excessive delays[#](#id32 "Link to this image")
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图67 过度延迟引起的歧义[#](#id32 "链接到这个图像")
- en: To deal with this problem, transport protocols combine two solutions. First,
    they use 32 bits or more to encode the sequence number in the segment header.
    This increases the overhead, but also increases the delay between the transmission
    of two different segments having the same sequence number. Second, transport protocols
    require the network layer to enforce a Maximum Segment Lifetime (MSL). The network
    layer must ensure that no packet remains in the network for more than MSL seconds.
    In the Internet the MSL is assumed [[5]](#fmsl) to be 2 minutes [**RFC 793**](https://datatracker.ietf.org/doc/html/rfc793.html).
    Note that this limits the maximum bandwidth of a transport protocol. If it uses
    n bits to encode its sequence numbers, then it cannot send more than \(2^n\) segments
    every MSL seconds.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，传输协议结合了两种解决方案。首先，它们使用32位或更多位来编码段头中的序列号。这增加了开销，但也增加了具有相同序列号的两个不同段之间的延迟。其次，传输协议要求网络层强制执行最大段生存时间（MSL）。网络层必须确保没有数据包在网络中超过MSL秒。在互联网中，MSL被假定为2分钟
    [[5]](#fmsl) [**RFC 793**](https://datatracker.ietf.org/doc/html/rfc793.html)。请注意，这限制了传输协议的最大带宽。如果它使用n位来编码其序列号，那么它就不能在每MSL秒内发送超过\(2^n\)个段。
- en: Closing a transport connection[#](#closing-a-transport-connection "Link to this
    heading")
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭传输连接[#](#closing-a-transport-connection "链接到这个标题")
- en: 'When we discussed the connection-oriented service, we mentioned that there
    are two types of connection releases : abrupt release and graceful release.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论面向连接的服务时，我们提到有两种类型的连接释放：突然释放和优雅释放。
- en: The first solution to release a transport connection is to define a new control
    segment (e.g. the DR segment for Disconnection Request) and consider the connection
    to be released once this segment has been sent or received. This is illustrated
    in [Fig. 68](#fig-abrupt-release).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 释放传输连接的第一个解决方案是定义一个新的控制段（例如，断开请求的 DR 段），并将连接视为在发送或接收此段之后已释放。这如图 68 所示。
- en: '[![../_images/transport-abrupt.png](../Images/2cbf4e00facf50e43973ab7e7a5671dd.png)](../_images/transport-abrupt.png)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-abrupt.png](../Images/2cbf4e00facf50e43973ab7e7a5671dd.png)](../_images/transport-abrupt.png)'
- en: Fig. 68 Abrupt connection release[#](#id33 "Link to this image")
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 68 突然连接释放[#](#id33 "链接到此图像")
- en: As the entity that sends the DR segment cannot know whether the other entity
    has already sent all its data on the connection, SDUs can be lost during such
    an abrupt connection release.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送 DR 段的实体无法知道另一个实体是否已经在连接上发送了所有其数据，因此在这样的突然连接释放过程中可能会丢失 SDUs。
- en: The second method to release a transport connection is to release independently
    the two directions of data transfer. Once a user of the transport service has
    sent all its SDUs, it performs a DISCONNECT.req for its direction of data transfer.
    The transport entity sends a control segment to request the release of the connection
    *after* the delivery of all previous SDUs to the remote user. This is usually
    done by placing in the DR the next sequence number and by delivering the DISCONNECT.ind
    only after all previous DATA.ind. The remote entity confirms the reception of
    the DR segment and the release of the corresponding direction of data transfer
    by returning an acknowledgment. This is illustrated in [Fig. 69](#fig-graceful-release).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 释放传输连接的第二种方法是独立释放数据传输的两个方向。一旦传输服务的用户发送了所有其 SDUs，它就会为其数据传输方向执行 DISCONNECT.req。传输实体发送一个控制段，请求在将所有之前的
    SDUs 交付给远程用户后释放连接。这通常是通过在 DR 中放置下一个序列号，并且只在所有之前的 DATA.ind 交付后发送 DISCONNECT.ind
    来实现的。远程实体通过返回一个确认来确认接收 DR 段和释放相应的数据传输方向。这如图 69 所示。
- en: '[![../_images/transport-graceful.png](../Images/2967c3a8822fc72dfc8c278f20b61f48.png)](../_images/transport-graceful.png)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-graceful.png](../Images/2967c3a8822fc72dfc8c278f20b61f48.png)](../_images/transport-graceful.png)'
- en: Fig. 69 Graceful connection release[#](#id34 "Link to this image")
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 69 优雅连接释放[#](#id34 "链接到此图像")
- en: Footnotes
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: A simple reliable protocol[#](#a-simple-reliable-protocol "Link to this heading")
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种简单的可靠协议[#](#a-simple-reliable-protocol "链接到本标题")
- en: In this section, we develop a simple reliable protocol running above the network
    service. To design this protocol, we first assume that the underlying layer provides
    a perfect service. We will then develop solutions to recover from different types
    of errors that affect the network service.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开发了一个在网络服务之上运行的简单可靠协议。为了设计此协议，我们首先假设底层层提供完美服务。然后，我们将开发解决影响网络服务的不同类型错误的方法。
- en: 'The network layer is designed to send and receive packets on behalf of a user.
    We model these interactions by using the DATA.req and DATA.ind primitives. However,
    to simplify the presentation and to avoid confusion between a DATA.req primitive
    issued by the user of the network layer, and a DATA.req issued by the transport
    layer entity itself, we use the following terminology :'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层被设计用来代表用户发送和接收数据包。我们通过使用 DATA.req 和 DATA.ind 原语来模拟这些交互。然而，为了简化演示并避免网络层用户发出的
    DATA.req 原语与传输层实体本身发出的 DATA.req 之间的混淆，我们使用以下术语：
- en: the interactions between the user and the transport layer entity are represented
    by using the classical DATA.req and the DATA.ind primitives
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户与传输层实体之间的交互是通过使用经典的 DATA.req 和 DATA.ind 原语来表示的
- en: ''
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the interactions between the transport layer entity and the sub-layer are represented
    by using send instead of DATA.req and recvd instead of DATA.ind
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层实体与子层之间的交互是通过使用 send 代替 DATA.req 和使用 recvd 代替 DATA.ind 来表示的
- en: When running on top of a perfect network, a transport entity can simply issue
    a send(SDU) upon arrival of a DATA.req(SDU) [[1]](#fsdu). Similarly, the receiver
    issues a DATA.ind(SDU) upon receipt of a recvd(SDU). Such a simple protocol is
    sufficient when a single SDU is sent. This is illustrated in the figure below.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当在完美的网络之上运行时，传输实体可以在接收到DATA.req(SDU) [[1]](#fsdu)后简单地发出一个send(SDU)。同样，接收者在收到recvd(SDU)后发出DATA.ind(SDU)。当只发送单个SDU时，这样一个简单的协议就足够了。这在下图中有说明。
- en: '![msc {'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(SDU)" ] ,
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(SDU)" ] ,
- en: b>>c [ label = "Segment(SDU)", arcskip="1"];
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Segment(SDU)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(SDU)" ];
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(SDU)" ];
- en: '}](../Images/ba824d054705364b69646b80420c85eb.png)<map id="e44596b6402c634781fc156189b78b14744a061d"
    name="e44596b6402c634781fc156189b78b14744a061d"></map>'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/ba824d054705364b69646b80420c85eb.png)<map id="e44596b6402c634781fc156189b78b14744a061d"
    name="e44596b6402c634781fc156189b78b14744a061d"></map>'
- en: Unfortunately, this is not always sufficient to ensure a reliable delivery of
    SDUs. Consider the case where a client sends tens of SDUs to a server. If the
    server is faster than the client, it will be able to receive and process all the
    segments sent by the client and deliver their content to its user. However, if
    the server is slower than the client, problems may arise. The transport entity
    contains buffers to store SDUs that have been received as a Data.request but have
    not yet been sent. If the application is faster than the network, the buffer may
    become full. At this point, the operating system suspends the application to let
    the transport entity empty its transmission queue. The transport entity also uses
    a buffer to store the received segments that have not yet been processed by the
    application. If the application is slow to process the data, this buffer may overflow
    and the transport entity will not able to accept any additional segment. The buffers
    of the transport entity have a limited size and if they overflow, the arriving
    segments will be discarded, even if they are correct.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不总是足以确保SDU的可靠交付。考虑这样一个情况，客户端向服务器发送了数十个SDU。如果服务器比客户端快，它将能够接收和处理客户端发送的所有段，并将它们的内容交付给用户。然而，如果服务器比客户端慢，可能会出现问题。传输实体包含缓冲区来存储已作为数据请求接收但尚未发送的SDU。如果应用程序比网络快，缓冲区可能会满。在这种情况下，操作系统将挂起应用程序，让传输实体清空其传输队列。传输实体还使用缓冲区来存储尚未由应用程序处理的接收到的段。如果应用程序处理数据较慢，这个缓冲区可能会溢出，传输实体将无法接受任何额外的段。传输实体的缓冲区大小有限，如果它们溢出，到达的段将被丢弃，即使它们是正确的。
- en: 'To solve this problem, a reliable protocol must include a feedback mechanism
    that allows the receiver to inform the sender that it has processed a segment
    and that another one can be sent. This feedback is required even though there
    are no transmission errors. To include such a feedback, our reliable protocol
    must process two types of segments :'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，一个可靠的协议必须包括一个反馈机制，允许接收者通知发送者它已经处理了一个段，并且可以发送另一个段。即使没有传输错误，这种反馈也是必需的。为了包含这种反馈，我们的可靠协议必须处理两种类型的段：
- en: data segments carrying a SDU
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 携带SDU的数据段
- en: ''
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: control segments confirming that the previous segment was correctly processed
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认前一个段正确处理的控制段
- en: These control segments are usually called acknowledgments because they acknowledge
    the correct reception of data.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制段通常被称为确认，因为它们确认了数据的正确接收。
- en: 'These two types of segments can be distinguished by dividing the segments in
    two parts :'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的段可以通过将段分为两部分来区分：
- en: the header that contains a segment type bit set to 0 in data segments and set
    to 1 in control segments
  id: totrans-439
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部包含一个段类型位，在数据段中设置为0，在控制段中设置为1
- en: ''
  id: totrans-440
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the payload that contains the SDU supplied by the application
  id: totrans-442
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含由应用程序提供的SDU的有效负载
- en: Our transport entity can then be modeled as a finite state machine, containing
    two states for the receiver and two states for the sender. [Fig. 47](#fig-fsm1-transport)
    provides a graphical representation of this state machine with the sender above
    and the receiver below.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的传输实体可以被建模为一个有限状态机，包含接收者的两个状态和发送者的两个状态。[图47](#fig-fsm1-transport)提供了这个状态机的图形表示，发送者在上方，接收者在下方。
- en: '![Figure made with TikZ](../Images/ca317c24a120ea2f84f77bb8205d331e.png)'
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/ca317c24a120ea2f84f77bb8205d331e.png)'
- en: ''
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 47 Finite state machines of the simplest reliable protocol (sender above,
    receiver below)
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图47 最简单可靠协议的有限状态机（发送者在上，接收者在下）
- en: The sender FSM shows that the sender has to wait for an acknowledgment from
    the receiver before being able to transmit the next SDU. The figure below illustrates
    the exchange of a few segments between two hosts.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者有限状态机显示发送者必须在收到接收者的确认之前才能传输下一个SDU。下面的图示了两个主机之间交换的一些段。
- en: '![msc {'
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)"], b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)"], b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ],c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ],c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)" ], b>>c [ label = "D(b)",arcskip="1"];
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)" ], b>>c [ label = "D(b)",arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ], c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ], c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/15482ac863d12db91aebf9dbd402b97a.png)<map id="60a9f1c91540fca4ffa054e6b58cb88cf03463af"
    name="60a9f1c91540fca4ffa054e6b58cb88cf03463af"></map>'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/15482ac863d12db91aebf9dbd402b97a.png)<map id="60a9f1c91540fca4ffa054e6b58cb88cf03463af"
    name="60a9f1c91540fca4ffa054e6b58cb88cf03463af"></map>'
- en: Note
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Services and protocols
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和协议
- en: An important aspect to understand when studying computer networks is the difference
    between a *service* and a *protocol*. For this, it is useful to start with real
    world examples. The traditional Post provides a service where a postman delivers
    letters to recipients. The Post precisely defines which types of letters (size,
    weight, etc) can be delivered by using the Standard Mail service. Furthermore,
    the format of the envelope is specified (position of the sender and recipient
    addresses, position of the stamp). Someone who wants to send a letter must either
    place the letter at a Post Office or inside one of the dedicated mailboxes. The
    letter will then be collected and delivered to its final recipient. Note that
    for the regular service the Post usually does not guarantee the delivery of each
    particular letter. Some letters may be lost, and some letters are delivered to
    the wrong mailbox. If a letter is important, then the sender can use the registered
    service to ensure that the letter will be delivered to its recipient. Some Post
    services also provide an acknowledged service or an express mail service that
    is faster than the regular service.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究计算机网络时，理解*服务*和*协议*之间的区别是一个重要的方面。为此，从现实世界的例子开始是有用的。传统的邮政提供一项服务，其中邮递员将信件递送给收件人。邮政精确地定义了可以使用标准邮件服务递送的信件类型（大小、重量等）。此外，信封的格式也被指定（发件人和收件人地址的位置，邮票的位置）。想要发送信件的人必须将信件放在邮局或专用的邮箱中。然后信件将被收集并递送到最终收件人。请注意，对于常规服务，邮政通常不保证每封特定信件的递送。有些信件可能会丢失，有些信件会被送到错误的邮箱。如果信件很重要，发送者可以使用挂号服务来确保信件将被递送到收件人。一些邮政服务还提供已确认服务或比常规服务更快的快递服务。
- en: Reliable transfer above an imperfect link[#](#reliable-transfer-above-an-imperfect-link
    "Link to this heading")
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不完美的链路上进行可靠传输[#](#reliable-transfer-above-an-imperfect-link "链接到本标题")
- en: 'The transport layer must deal with several types of errors which can affect
    the segments that it sends. In practice, we mainly have to deal with two types
    of errors in the transport layer :'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层必须处理可能影响它发送的段落的几种类型的错误。在实践中，我们主要必须在传输层处理两种类型的错误：
- en: Segments can be corrupted by transmission errors
  id: totrans-467
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落可能会因为传输错误而损坏
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Segments can be lost or unexpected segments can appear
  id: totrans-470
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落可能会丢失或出现意外的段
- en: 'To detect errors, a segment is usually divided into two parts :'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测错误，一个段通常被分为两部分：
- en: a header that contains the fields used by the reliable protocol to ensure reliable
    delivery. The header contains a checksum or Cyclical Redundancy Check (CRC) [[Williams1993]](../bibliography.html#williams1993)
    that is used to detect transmission errors
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个头部，它包含可靠协议使用的字段以确保可靠交付。头部包含一个校验和或循环冗余校验（CRC）[[Williams1993]](../bibliography.html#williams1993)，用于检测传输错误
- en: ''
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-474
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a payload that contains the user data
  id: totrans-475
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含用户数据的有效载荷
- en: Some headers also include a length field, which indicates the total length of
    the segment or the length of the payload.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 一些头部还包括一个长度字段，它表示段的总长度或有效载荷的长度。
- en: The simplest error detection scheme is the checksum. A checksum is basically
    an arithmetic sum of all the bytes that a segment is composed of. There are different
    types of checksums. For example, an eight bit checksum can be computed as the
    arithmetic sum of all the bytes of (both the header and trailer of) the segment.
    The checksum is computed by the sender before sending the segment and the receiver
    verifies the checksum upon segment reception. The receiver discards segments received
    with an invalid checksum. Checksums can be easily implemented in software, but
    their error detection capabilities are limited. Cyclical Redundancy Checks (CRC)
    have better error detection capabilities [[SGP98]](../bibliography.html#sgp98),
    but require more CPU when implemented in software.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的错误检测方案是校验和。校验和基本上是构成段的全部字节的算术和。存在不同类型的校验和。例如，一个8位校验和可以计算为段（包括头部和尾部）所有字节的算术和。发送方在发送段之前计算校验和，接收方在接收到段后验证校验和。接收方会丢弃校验和无效的段。校验和可以很容易地在软件中实现，但它们的错误检测能力有限。循环冗余校验（CRC）具有更好的错误检测能力
    [[SGP98]](../bibliography.html#sgp98)，但在软件实现时需要更多的CPU。
- en: Note
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Checksums, CRCs,…
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和、CRC、…
- en: Most of the protocols in the TCP/IP protocol suite rely on the simple Internet
    checksum in order to verify that a received packet has not been affected by transmission
    errors. Despite its popularity and ease of implementation, the Internet checksum
    is not the only available checksum mechanism. Cyclical Redundancy Checks ([CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check))
    are very powerful error detection schemes that are used notably on disks, by many
    datalink layer protocols and file formats such as `zip` or `png`. They can easily
    be implemented efficiently in hardware and have better error-detection capabilities
    than the Internet checksum [[SGP98]](../bibliography.html#sgp98) . However, CRCs
    are sometimes considered to be too CPU-intensive for software implementations
    and other checksum mechanisms are preferred. The TCP/IP community chose the Internet
    checksum, the OSI community chose the Fletcher checksum [[Sklower89]](../bibliography.html#sklower89).
    Nowadays there are efficient techniques to quickly compute CRCs in software [[Feldmeier95]](../bibliography.html#feldmeier95).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议族中的大多数协议都依赖于简单的互联网校验和来验证接收到的数据包在传输过程中没有被错误影响。尽管其流行且易于实现，但互联网校验和并非唯一的校验和机制。循环冗余校验（[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)）是一种非常强大的错误检测方案，特别用于磁盘、许多数据链路层协议以及`zip`或`png`等文件格式。它们可以很容易地在硬件中高效实现，并且比互联网校验和具有更好的错误检测能力
    [[SGP98]](../bibliography.html#sgp98)。然而，CRC有时被认为对软件实现过于CPU密集，因此更倾向于其他校验和机制。TCP/IP社区选择了互联网校验和，OSI社区选择了Fletcher校验和
    [[Sklower89]](../bibliography.html#sklower89)。如今，有高效的软件计算CRC的技术 [[Feldmeier95]](../bibliography.html#feldmeier95)。
- en: Since the receiver sends an acknowledgment after having received each data segment,
    the simplest solution to deal with losses is to use a retransmission timer. When
    the sender sends a segment, it starts a retransmission timer. The duration of
    this retransmission timer should be larger than the round-trip-time, i.e. the
    delay between the transmission of a data segment and the reception of the corresponding
    acknowledgment. When the retransmission timer expires, the sender assumes that
    the data segment has been lost and retransmits it. This is illustrated in the
    figure below.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收方在接收到每个数据段后发送确认，处理丢失的最简单方法是使用重传计时器。发送方在发送段时启动重传计时器。这个重传计时器的持续时间应该大于往返时间，即数据段传输和对应确认接收之间的延迟。当重传计时器到期时，发送方假定数据段已丢失并重新发送它。这在下图中进行了说明。
- en: '![msc {'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动定时器" ] ,
- en: b-x c [ label = "D(b)", arcskip="1", linecolour=red];
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(b)", arcskip="1", linecolour=red];
- en: '|||;'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "定时器到期" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/eb3e128faed868520ea345c4171d9007.png)<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"
    name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"></map>'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/eb3e128faed868520ea345c4171d9007.png)<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"
    name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"></map>'
- en: '[PRE8]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Unfortunately, retransmission timers alone are not sufficient to recover from
    losses. Let us consider, as an example, the situation depicted below where an
    acknowledgment is lost. In this case, the sender retransmits the data segment
    that has not been acknowledged. However, as illustrated in the figure below, the
    receiver considers the retransmission as a new segment whose payload must be delivered
    to its user.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅靠重传定时器不足以从丢失中恢复。让我们考虑以下情况，其中确认信息丢失。在这种情况下，发送器会重传尚未确认的数据段。然而，如图所示，接收器将重传视为新的数据段，其有效载荷必须交付给用户。
- en: '![msc {'
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动定时器" ] ,
- en: b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消定时器"];
- en: '|||;'
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动定时器" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c-x b [label= "C(OK)", linecolour=red, arcskip="1"];
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c-x b [label= "C(OK)", linecolour=red, arcskip="1"];
- en: '|||;'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "定时器到期" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b) !!!!!", linecolour=red ];
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b) !!!!!", linecolour=red ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/f31aca9d4a56211a006ee59b4bbd6581.png)<map id="34c7c055da8716230ba3f29574fb761575e3d9f5"
    name="34c7c055da8716230ba3f29574fb761575e3d9f5"></map>'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f31aca9d4a56211a006ee59b4bbd6581.png)<map id="34c7c055da8716230ba3f29574fb761575e3d9f5"
    name="34c7c055da8716230ba3f29574fb761575e3d9f5"></map>'
- en: To solve this problem, reliable protocols associate a sequence number to each
    data segment. This sequence number is one of the fields found in the header of
    data segments. We use the notation D(x,…) to indicate a data segment whose sequence
    number field is set to value x. The acknowledgments also contain a sequence number
    indicating the data segments that it acknowledges. We use OKx to indicate an acknowledgment
    that confirms the reception of D(x,…). The sequence number is encoded as a bit
    string of fixed length. The simplest reliable protocol is the Alternating Bit
    Protocol (ABP).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可靠的协议将序列号分配给每个数据段。这个序列号是数据段头部中的一个字段。我们使用D(x,…)表示序列号字段设置为x值的数据段。确认信息也包含一个序列号，表示它确认的数据段。我们使用OKx表示确认接收了D(x,…)的确认信息。序列号被编码为固定长度的位字符串。最简单的可靠协议是交替位协议（ABP）。
- en: The Alternating Bit Protocol[#](#the-alternating-bit-protocol "Link to this
    heading")
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交替位协议[#](#the-alternating-bit-protocol "链接到本标题")
- en: The Alternating Bit Protocol uses a single bit to encode the sequence number.
    It can be implemented easily. The sender (resp. the receiver) only require a four-state
    (resp. three-state) Finite State Machine. The sender FSM is represented in [Fig.
    48](#fig-abp-sender-fsm) and the receiver FSM in [Fig. 49](#fig-abp-receiver-fsm).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议使用一个位来编码序列号。它可以很容易地实现。发送器（分别对应接收器）只需要一个四状态（分别对应三状态）的有限状态机。发送器有限状态机在[图48](#fig-abp-sender-fsm)中表示，接收器有限状态机在[图49](#fig-abp-receiver-fsm)中表示。
- en: '![Figure made with TikZ](../Images/8fbe25275e0fee019961c542919ef49b.png)'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8fbe25275e0fee019961c542919ef49b.png)'
- en: ''
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 48 Alternating bit protocol: Sender FSM'
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图48 交替位协议：发送器有限状态机
- en: The initial state of the sender is Wait for D(0,…). In this state, the sender
    waits for a Data.request. The first data segment that it sends uses sequence number
    0. After having sent this segment, the sender waits for an OK0 acknowledgment.
    A data segment is retransmitted upon expiration of the retransmission timer or
    if an acknowledgment with an incorrect sequence number has been received.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者的初始状态是等待D(0,…)。在此状态下，发送者等待数据请求。它发送的第一个数据段使用序列号0。发送此段后，发送者等待OK0确认。如果重传计时器到期或收到序列号不正确的确认，则重新传输数据段。
- en: The receiver first waits for D(0,…). If the segment contains a correct CRC,
    it passes the SDU to its user and sends OK0. If the segment contains an invalid
    CRC, it is immediately discarded. Then, the receiver waits for D(1,…). In this
    state, it may receive a duplicate D(0,…) or a data segment with an invalid CRC.
    In both cases, it returns an OK0 segment to allow the sender to recover from the
    possible loss of the previous OK0 segment.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者首先等待D(0,…)。如果段包含正确的CRC，它将SDU传递给其用户并发送OK0。如果段包含无效的CRC，它将立即被丢弃。然后，接收者等待D(1,…)。在此状态下，它可能接收到重复的D(0,…)或包含无效CRC的数据段。在这两种情况下，它返回一个OK0段，以便发送者可以从可能的OK0段丢失中恢复。
- en: '![Figure made with TikZ](../Images/3badb5e30f18cd10794dafd6f023ac28.png)'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/3badb5e30f18cd10794dafd6f023ac28.png)'
- en: ''
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 49 Alternating bit protocol: Receiver FSM'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图49 交替位协议：接收有限状态机
- en: Note
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Corrupted segments must be discarded
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 损坏的段必须被丢弃
- en: The receiver FSM of the Alternating bit protocol discards all segments that
    contain an invalid CRC. This is the safest approach since the received segment
    can be completely different from the one sent by the remote host. A receiver should
    not attempt at extracting information from a corrupted segment because it cannot
    know which portion of the segment has been affected by the error.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议的接收有限状态机丢弃所有包含无效CRC的段。这是最安全的做法，因为接收到的段可能与远程主机发送的段完全不同。接收者不应尝试从损坏的段中提取信息，因为它无法知道段的哪个部分受到了错误的影响。
- en: The figure below illustrates the operation of the Alternating Bit Protocol.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了交替位协议的操作。
- en: '![msc {'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ];
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ];
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(c)\nstart timer" ] ,
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(c)\n启动计时器" ] ,
- en: b>>c [ label = "D(0,c)", arcskip="1"];
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,c)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(c)" ];
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(c)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/58f29e8a1f0f64da47ef83b069805c78.png)<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"
    name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"></map>'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/58f29e8a1f0f64da47ef83b069805c78.png)<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"
    name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"></map>'
- en: The Alternating Bit Protocol can recover from the losses of data or control
    segments. This is illustrated in the two figures below. The first figure shows
    the loss of one data segment.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议可以从数据或控制段丢失中恢复。这在下述两个图中得到了说明。第一个图显示了数据段丢失的情况。
- en: '![msc {'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b-x c [ label = "D(1,b)", arcskip="1", linecolour=red];
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(1,b)", arcskip="1", linecolour=red];
- en: '|||;'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/f662cc9a0b114455fe7ce91316c8aedb.png)<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68"
    name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"></map>'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/f662cc9a0b114455fe7ce91316c8aedb.png)<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68"
    name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"></map>'
- en: The second figure illustrates how the hosts handle the loss of one control segment.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图示说明了主机如何处理一个控制段的丢失。
- en: '![msc {'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c-x b [label= "C(OK1)", linecolour=red, arcskip="1"];
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: c-x b [label= "C(OK1)", linecolour=red, arcskip="1"];
- en: '|||;'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "Duplicate segment\nignored", textcolour=red, linecolour=white
    ];
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "重复段\n忽略", textcolour=red, linecolour=white ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/3bcb6de20e7b816c3750de577d1012cc.png)<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"
    name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"></map>'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/3bcb6de20e7b816c3750de577d1012cc.png)<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"
    name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"></map>'
- en: The Alternating Bit Protocol can recover from transmission errors and segment
    losses. However, it has one important drawback. Consider two hosts that are directly
    connected by a 50 Kbits/sec satellite link that has a 250 milliseconds propagation
    delay. If these hosts send 1000 bits segments, then the maximum throughput that
    can be achieved by the alternating bit protocol is one segment every \(20+250+250=520\)
    milliseconds if we ignore the transmission time of the acknowledgment. This is
    less than 2 Kbits/sec !
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 交替比特协议可以从传输错误和段丢失中恢复。然而，它有一个重要的缺点。考虑两个通过50 Kbits/sec卫星链路直接连接的主机，该链路具有250毫秒的传播延迟。如果这些主机发送1000比特的段，那么如果忽略确认的传输时间，交替比特协议可以达到的最大吞吐量是每520毫秒一个段，即\(20+250+250=520\)毫秒。这还不到2
    Kbits/sec！
- en: '[PRE9]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Go-back-n and selective repeat[#](#go-back-n-and-selective-repeat "Link to this
    heading")
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go-back-n和选择性重传[#](#go-back-n-and-selective-repeat "链接到这个标题")
- en: To overcome the performance limitations of the alternating bit protocol, reliable
    protocols rely on pipelining shown in [Fig. 50](#fig-pipelining). This technique
    allows a sender to transmit several consecutive segments without being forced
    to wait for an acknowledgment after each segment. Each data segment contains a
    sequence number encoded as an n bits field.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服交替比特协议的性能限制，可靠的协议依赖于[图50](#fig-pipelining)中所示的流水线技术。这项技术允许发送者在每个数据段之后不必等待确认即可连续发送多个数据段。每个数据段包含一个序列号，该序列号编码为一个n位字段。
- en: '[![../_images/pipelining2.png](../Images/673705ddb7a242862f06d67fd8c2c097.png)](../_images/pipelining2.png)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/pipelining2.png](../Images/673705ddb7a242862f06d67fd8c2c097.png)](../_images/pipelining2.png)'
- en: Fig. 50 Pipelining improves the performance of reliable protocols[#](#fig-pipelining
    "Link to this image")
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 图50 流水线提高了可靠协议的性能[#](#fig-pipelining "链接到这张图片")
- en: Pipelining allows the sender to transmit segments at a higher rate. However
    this higher transmission rate may overload the receiver. In this case, the segments
    sent by the sender will not be correctly received by their final destination.
    The reliable protocols that rely on pipelining allow the sender to transmit W
    unacknowledged segments before being forced to wait for an acknowledgment from
    the receiving entity.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 管道化允许发送方以更高的速率传输段。然而，这种更高的传输速率可能会超载接收方。在这种情况下，发送方发送的段将不会被其最终目的地正确接收。依赖于管道化的可靠协议允许发送方在被迫等待接收实体确认之前传输W个未确认的段。
- en: This is implemented by using a sliding window. The sliding window is the set
    of consecutive sequence numbers that the sender can use when transmitting segments
    without being forced to wait for an acknowledgment. [Fig. 51](#fig-sliding-win)
    shows a sliding window containing five segments (6,7,8,9 and 10). Two of these
    sequence numbers (6 and 7) have been used to send segments and only three sequence
    numbers (8, 9 and 10) remain in the sliding window. The sliding window is said
    to be closed once all sequence numbers contained in the sliding window have been
    used.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用滑动窗口来实现的。滑动窗口是发送方在无需等待确认的情况下可以使用的连续序列号集。 [图51](#fig-sliding-win) 显示了一个包含五个段（6,7,8,9和10）的滑动窗口。其中两个序列号（6和7）已被用于发送段，而滑动窗口中只剩下三个序列号（8,
    9和10）。当滑动窗口中的所有序列号都被使用后，滑动窗口被称为关闭。
- en: '[![../_images/slidingwin2.png](../Images/cff43484e462b0df38ba215dd67e6922.png)](../_images/slidingwin2.png)'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/slidingwin2.png](../Images/cff43484e462b0df38ba215dd67e6922.png)'
- en: Fig. 51 The sliding window[#](#id16 "Link to this image")
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 图51 滑动窗口[#](#id16 "链接到这张图片")
- en: '[Fig. 52](#fig-sliding-win-ex) illustrates the operation of the sliding window.
    It uses a sliding window of three segments. The sender can thus transmit three
    segments before being forced to wait for an acknowledgment. The sliding window
    moves to the higher sequence numbers upon the reception of each acknowledgment.
    When the first acknowledgment (OK0) is received, it enables the sender to move
    its sliding window to the right and sequence number 3 becomes available. This
    sequence number is used later to transmit the segment containing d.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '[图52](#fig-sliding-win-ex) 展示了滑动窗口的操作。它使用三个段的滑动窗口。因此，发送方可以在被迫等待确认之前传输三个段。在接收到每个确认后，滑动窗口移动到更高的序列号。当接收到第一个确认（OK0）时，它允许发送方将其滑动窗口向右移动，序列号3变得可用。这个序列号后来被用来传输包含d的段。'
- en: '[![../_images/gbnwin.png](../Images/b5fde7825c12c07ce8b77cc1e5f37556.png)](../_images/gbnwin.png)'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/gbnwin.png](../Images/b5fde7825c12c07ce8b77cc1e5f37556.png)'
- en: Fig. 52 Sliding window example[#](#id17 "Link to this image")
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 图52 滑动窗口示例[#](#id17 "链接到这张图片")
- en: In practice, as the segment header includes an n bits field to encode the sequence
    number, only the sequence numbers between \(0\) and \(2^{n}-1\) can be used. This
    implies that, during a long transfer, the same sequence number will be used for
    different segments and the sliding window will wrap. This is illustrated in [Fig.
    53](#fig-sliding-win-modulo) assuming that 2 bits are used to encode the sequence
    number in the segment header. Note that upon reception of OK1, the sender slides
    its window and can use sequence number 0 again.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，由于段头包含一个n位字段来编码序列号，因此只能使用介于 \(0\) 和 \(2^{n}-1\) 之间的序列号。这意味着，在长时间传输过程中，相同的序列号将被用于不同的段，滑动窗口将回绕。这如图
    [图53](#fig-sliding-win-modulo) 所示，假设在段头中使用2位来编码序列号。请注意，在接收到OK1后，发送方滑动其窗口并可以再次使用序列号0。
- en: '[![../_images/gbnwinex.png](../Images/0ef78f3981c477d103876d2f7358bdd3.png)](../_images/gbnwinex.png)'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/gbnwinex.png](../Images/0ef78f3981c477d103876d2f7358bdd3.png)'
- en: Fig. 53 Utilization of the sliding window with modulo arithmetic[#](#id18 "Link
    to this image")
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 图53 使用模运算的滑动窗口利用情况[#](#id18 "链接到这张图片")
- en: 'Unfortunately, segment losses do not disappear because a reliable protocol
    uses a sliding window. To recover from losses, a sliding window protocol must
    define :'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于可靠协议使用滑动窗口，段丢失并不会消失。为了从丢失中恢复，滑动窗口协议必须定义：
- en: a heuristic to detect losses
  id: totrans-638
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种启发式方法来检测丢失
- en: ''
  id: totrans-639
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-640
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a retransmission strategy to retransmit the lost segments
  id: totrans-641
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种重传策略来重传丢失的段
- en: The simplest sliding window protocol uses the go-back-n recovery. Intuitively,
    go-back-n operates as follows. A go-back-n receiver is as simple as possible.
    It only accepts the segments that arrive in-sequence. A go-back-n receiver discards
    any out-of-sequence segment that it receives. When go-back-n receives a data segment,
    it always returns an acknowledgment containing the sequence number of the last
    in-sequence segment that it has received. This acknowledgment is said to be cumulative.
    When a go-back-n receiver sends an acknowledgment for sequence number x, it implicitly
    acknowledges the reception of all segments whose sequence number is earlier than
    x. A key advantage of these cumulative acknowledgments is that it is easy to recover
    from the loss of an acknowledgment. Consider for example a go-back-n receiver
    that received segments 1, 2 and 3. It sent OK1, OK2 and OK3. Unfortunately, OK1
    and OK2 were lost. Thanks to the cumulative acknowledgments, when the sender receives
    OK3, it knows that all three segments have been correctly received.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的滑动窗口协议使用回退N恢复。直观地说，回退N的操作如下。回退N接收器尽可能简单。它只接受按顺序到达的段。回退N接收器会丢弃它接收到的任何顺序错误的段。当回退N收到数据段时，它总是返回一个包含它已接收的最后顺序段序列号的确认。这种确认被称为累积确认。当一个回退N接收器为序列号x发送确认时，它隐式地确认了所有序列号早于x的段的接收。这些累积确认的一个关键优点是，从确认丢失中恢复很容易。例如，考虑一个接收了段1、2和3的回退N接收器。它发送了OK1、OK2和OK3。不幸的是，OK1和OK2丢失了。多亏了累积确认，当发送器收到OK3时，它知道所有三个段都已正确接收。
- en: '[Fig. 54](#fig-fsm-gbn-receiver) shows the FSM of a simple go-back-n receiver.
    This receiver uses two variables : lastack and next. next is the next expected
    sequence number and lastack the sequence number of the last data segment that
    has been acknowledged. The receiver only accepts the segments that are received
    in sequence. maxseq is the number of different sequence numbers (\(2^n\)).'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '[图54](#fig-fsm-gbn-receiver) 展示了一个简单的回退N接收器的有限状态机。该接收器使用两个变量：lastack和next。next是下一个预期的序列号，lastack是已确认的最后数据段的序列号。接收器只接受按顺序接收到的段。maxseq是不同序列号的数量（\(2^n\)）。'
- en: '![Figure made with TikZ](../Images/129311f9bf007c55636d82806ff9a8ec.png)'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/129311f9bf007c55636d82806ff9a8ec.png)'
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 54 Go-back-n: receiver FSM'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图54 回退N：接收器有限状态机
- en: A go-back-n sender is also very simple as shown in [Fig. 55](#fig-fsm-gbn-sender).
    It uses a sending buffer that can store an entire sliding window of segments [[2]](#fsizesliding).
    The segments are sent with increasing sequence numbers (modulo maxseq). The sender
    must wait for an acknowledgment once its sending buffer is full. When a go-back-n
    sender receives an acknowledgment, it removes from the sending buffer all the
    acknowledged segments and uses a retransmission timer to detect segment losses.
    A simple go-back-n sender maintains one retransmission timer per connection. This
    timer is started when the first segment is sent. When the go-back-n sender receives
    an acknowledgment, it restarts the retransmission timer only if there are still
    unacknowledged segments in its sending buffer. When the retransmission timer expires,
    the go-back-n sender assumes that all the unacknowledged segments currently stored
    in its sending buffer have been lost. It thus retransmits all the unacknowledged
    segments in the buffer and restarts its retransmission timer.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 回退N发送器也非常简单，如[图55](#fig-fsm-gbn-sender)所示。它使用一个发送缓冲区，可以存储整个滑动窗口的段[[2]](#fsizesliding)。段以递增的序列号（模maxseq）发送。发送器在其发送缓冲区满后必须等待确认。当回退N发送器收到确认时，它会从发送缓冲区中删除所有已确认的段，并使用重传定时器来检测段丢失。简单的回退N发送器为每个连接维护一个重传定时器。该定时器在发送第一个段时启动。当回退N发送器收到确认时，它只有在发送缓冲区中仍有未确认的段时才会重新启动重传定时器。当重传定时器超时，回退N发送器假定其发送缓冲区中当前存储的所有未确认段都已丢失。因此，它重新发送缓冲区中的所有未确认段，并重新启动其重传定时器。
- en: '![Figure made with TikZ](../Images/86718f7fdab6919b9def71253750e50a.png)'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/86718f7fdab6919b9def71253750e50a.png)'
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 55 Go-back-n: sender FSM'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图55 回退N：发送器有限状态机
- en: The operation of go-back-n is illustrated in [Fig. 56](#fig-gbn-example). In
    this figure, note that upon reception of the out-of-sequence segment D(2,c), the
    receiver returns a cumulative acknowledgment C(OK,0) that acknowledges all the
    segments that have been received in sequence. The lost segment is retransmitted
    upon the expiration of the retransmission timer.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n的操作在[图56](#fig-gbn-example)中进行了说明。在这张图中，请注意，在接收到乱序段D(2,c)后，接收器返回累积确认C(OK,0)，确认所有已按顺序接收到的段。在重传计时器到期后，丢失的段会被重新传输。
- en: '[![../_images/gbnex2.png](../Images/7c58d5fa667aca0d9275af765599720a.png)](../_images/gbnex2.png)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/gbnex2.png](../Images/7c58d5fa667aca0d9275af765599720a.png)'
- en: 'Fig. 56 Go-back-n : example[#](#id21 "Link to this image")'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 图56 Go-back-n：示例[#](#id21 "链接到这张图片")
- en: 'The main advantage of go-back-n is that it can be easily implemented, and it
    can also provide good performance when only a few segments are lost. However,
    when there are many losses, the performance of go-back-n quickly drops for two
    reasons :'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n的主要优势是它易于实现，并且当只有少量段丢失时，它可以提供良好的性能。然而，当丢失很多时，go-back-n的性能会迅速下降，原因有两个：
- en: the go-back-n receiver does not accept out-of-sequence segments
  id: totrans-655
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: go-back-n接收器不接受乱序段
- en: ''
  id: totrans-656
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the go-back-n sender retransmits all unacknowledged segments once it has detected
    a loss
  id: totrans-658
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: go-back-n发送器一旦检测到丢失，就会重新传输所有未确认的段
- en: '[PRE12]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Selective repeat is a better strategy to recover from losses. Intuitively, selective
    repeat allows the receiver to accept out-of-sequence segments. Furthermore, when
    a selective repeat sender detects losses, it only retransmits the segments that
    have been lost and not the segments that have already been correctly received.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传是一种更好的恢复丢失的策略。直观上，选择重传允许接收器接受乱序段。此外，当选择重传发送器检测到丢失时，它只会重新传输丢失的段，而不会重新传输已经正确接收的段。
- en: A selective repeat receiver maintains a sliding window of W segments and stores
    in a buffer the out-of-sequence segments that it receives. [Fig. 57](#fig-sr-rwin)
    shows a five-segment receive window on a receiver that has already received segments
    7 and 9.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传接收器维护一个包含W个段的滑动窗口，并将它接收到的乱序段存储在缓冲区中。[图57](#fig-sr-rwin)显示了一个接收器已经接收了段7和9的五个段接收窗口。
- en: '[![../_images/selrepeatwin2.png](../Images/65c1ca27e931f581cf93b7c9874c2977.png)](../_images/selrepeatwin2.png)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/selrepeatwin2.png](../Images/65c1ca27e931f581cf93b7c9874c2977.png)'
- en: Fig. 57 The receiving window with selective repeat[#](#id22 "Link to this image")
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 图57 选择重传的接收窗口[#](#id22 "链接到这张图片")
- en: A selective repeat receiver discards all segments having an invalid CRC, and
    maintains the variable lastack as the sequence number of the last in-sequence
    segment that it has received. The receiver always includes the value of lastack
    in the acknowledgments that it sends. Some protocols also allow the selective
    repeat receiver to acknowledge the out-of-sequence segments that it has received.
    This can be done for example by placing the list of the correctly received, but
    out-of-sequence segments in the acknowledgments together with the lastack value.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传接收器会丢弃所有具有无效CRC的段，并保持变量lastack为其已接收的最后有序段的序列号。接收器始终在其发送的确认中包含lastack的值。一些协议还允许选择重传接收器确认它已接收的乱序段。例如，可以通过将正确接收但乱序的段列表与lastack值一起放入确认中来做到这一点。
- en: When a selective repeat receiver receives a data segment, it first verifies
    whether the segment is inside its receiving window. If yes, the segment is placed
    in the receive buffer. If not, the received segment is discarded and an acknowledgment
    containing lastack is sent to the sender. The receiver then removes all consecutive
    segments starting at lastack (if any) from the receive buffer. The payloads of
    these segments are delivered to the user, lastack and the receiving window are
    updated, and an acknowledgment acknowledging the last segment received in sequence
    is sent.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择重传接收器接收到数据段时，它首先验证该段是否在其接收窗口内。如果是，该段将被放置在接收缓冲区中。如果不是，接收到的段将被丢弃，并向发送器发送包含lastack的确认。然后，接收器从接收缓冲区中移除从lastack开始的连续段（如果有）。这些段的负载被传递给用户，lastack和接收窗口被更新，并发送一个确认，确认已按顺序接收的最后一段。
- en: The selective repeat sender maintains a sending buffer that can store up to
    W unacknowledged segments. These segments are sent as long as the sending buffer
    is not full. Several implementations of a selective repeat sender are possible.
    A simple implementation associates one retransmission timer to each segment. The
    timer is started when the segment is sent and canceled upon reception of an acknowledgment
    that covers this segment. When a retransmission timer expires, the corresponding
    segment is retransmitted and this retransmission timer is restarted. When an acknowledgment
    is received, all the segments that are covered by this acknowledgment are removed
    from the sending buffer and the sliding window is updated.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性重传发送者维护一个发送缓冲区，可以存储多达W个未确认的段。只要发送缓冲区不满，就会发送这些段。选择性重传发送者的几种实现方式是可能的。一种简单的实现方式是为每个段关联一个重传定时器。定时器在发送段时启动，并在接收到覆盖此段的确认时取消。当重传定时器超时时，相应的段被重新传输，并且这个重传定时器被重新启动。当接收到确认时，所有被此确认覆盖的段将从发送缓冲区中移除，并且滑动窗口被更新。
- en: '[Fig. 58](#fig-sr-example) illustrates the operation of selective repeat when
    segments are lost. In this figure, C(OK,x) is used to indicate that all segments,
    up to and including sequence number x have been received correctly.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[图58](#fig-sr-example)说明了段丢失时选择性重传的操作。在这个图中，C(OK,x)用来表示所有段，包括序列号x及其之前的段，都已正确接收。'
- en: '[![../_images/selrepeat.png](../Images/5146331e8d7c7c36361e7fc92750fb1a.png)](../_images/selrepeat.png)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/selrepeat.png](../Images/5146331e8d7c7c36361e7fc92750fb1a.png)](../_images/selrepeat.png)'
- en: 'Fig. 58 Selective repeat : example[#](#id23 "Link to this image")'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 图58 选择性重传：示例[#](#id23 "链接到这个图像")
- en: Pure cumulative acknowledgments work well with the go-back-n strategy. However,
    with only cumulative acknowledgments a selective repeat sender cannot easily determine
    which segments have been correctly received after a data segment has been lost.
    For example, in the figure above, the second C(OK,0) does not inform explicitly
    the sender of the reception of D(2,c) and the sender could retransmit this segment
    although it has already been received. A possible solution to improve the performance
    of selective repeat is to provide additional information about the received segments
    in the acknowledgments that are returned by the receiver. For example, the receiver
    could add in the returned acknowledgment the list of the sequence numbers of all
    segments that have already been received. Such acknowledgments are sometimes called
    selective acknowledgments. We will provide examples of such acknowledgments in
    the TCP and QUIC protocols later in this book.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 纯累积确认与回退-n策略配合良好。然而，仅使用累积确认，选择性重传发送者无法轻易确定在数据段丢失后哪些段已被正确接收。例如，在上面的图中，第二个C(OK,0)并没有明确告知发送者D(2,c)已被接收，因此发送者可能会重新传输这个段，尽管它已经被接收。为了提高选择性重传的性能，一个可能的解决方案是在接收者返回的确认中提供关于已接收段的额外信息。例如，接收者可以在返回的确认中添加已接收的所有段的序列号列表。这种确认有时被称为选择性确认。我们将在本书后面的TCP和QUIC协议中提供此类确认的示例。
- en: '[PRE13]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Maximum window size with go-back-n and selective repeat
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n和选择性重传的最大窗口大小
- en: A reliable protocol that uses n bits to encode its sequence number can send
    up to \(2^n\) successive segments. However, to ensure a reliable delivery of the
    segments, go-back-n and selective repeat cannot use a sending window of \(2^n\)
    segments. Consider first go-back-n and assume that a sender sends \(2^n\) segments.
    These segments are received in-sequence by the destination, but all the returned
    acknowledgments are lost. The sender will retransmit all segments. These segments
    will all be accepted by the receiver and delivered a second time to the user.
    It is easy to see that this problem can be avoided if the maximum size of the
    sending window is \({2^n}-1\) segments. A similar problem occurs with selective
    repeat. However, as the receiver accepts out-of-sequence segments, a sending window
    of \({2^n}-1\) segments is not sufficient to ensure a reliable delivery. It can
    be easily shown that to avoid this problem, a selective repeat sender cannot use
    a window that is larger than \(\frac{2^n}{2}\) segments.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用 n 位来编码其序列号的可靠协议可以发送多达 \(2^n\) 个连续的段。然而，为了确保段的可靠交付，回退 n 和选择重传不能使用 \(2^n\)
    个段的发送窗口。首先考虑回退 n，并假设发送者发送 \(2^n\) 个段。这些段按顺序被目的地接收，但所有返回的确认信息都丢失了。发送者将重新发送所有段。这些段都将被接收器接受，并第二次交付给用户。很容易看出，如果发送窗口的最大大小是
    \({2^n}-1\) 个段，这个问题可以避免。与选择重传类似，也会出现类似的问题。然而，由于接收器接受非顺序的段，\({2^n}-1\) 个段的发送窗口不足以确保可靠的交付。可以很容易地证明，为了避免这个问题，选择重传发送者不能使用大于
    \(\frac{2^n}{2}\) 个段的窗口。
- en: Reliable protocols often need to send data in both directions. To reduce the
    overhead caused by the acknowledgments, most reliable protocols use piggybacking.
    Thanks to this technique, an entity can place the acknowledgments and the receive
    window that it advertises for the opposite direction of the data flow inside the
    header of the data segments that it sends. The main advantage of piggybacking
    is that it reduces the overhead as it is not necessary to send a complete segment
    to carry an acknowledgment. This is illustrated in the figure below where the
    acknowledgment number is underlined in the data segments. Piggybacking is only
    used when data flows in both directions. A receiver will generate a pure acknowledgment
    when it does not send data in the opposite direction as shown in the bottom of
    the figure.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠协议通常需要在两个方向上发送数据。为了减少由确认信息引起的开销，大多数可靠协议使用尾随技术。多亏了这项技术，实体可以将确认信息和它为数据流相反方向宣布的接收窗口放置在它发送的数据段头部。尾随的主要优势在于它减少了开销，因为不需要发送一个完整的段来携带确认信息。这在下图中得到了说明，其中确认号在数据段中被加粗。尾随技术仅在数据双向流动时使用。当接收器在相反方向不发送数据时，如图底部所示，它将生成一个纯确认信息。
- en: '[![../_images/piggyback2.png](../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png)](../_images/piggyback2.png)'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/piggyback2.png](../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png)](../_images/piggyback2.png)'
- en: Fig. 59 Piggybacking example[#](#id24 "Link to this image")
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 图 59 尾随示例[#](#id24 "链接到本图像")
- en: '[PRE14]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reliable transfer above an imperfect link[#](#reliable-transfer-above-an-imperfect-link
    "Link to this heading")
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不完美的链路上进行可靠传输[#](#reliable-transfer-above-an-imperfect-link "链接到本标题")
- en: 'The transport layer must deal with several types of errors which can affect
    the segments that it sends. In practice, we mainly have to deal with two types
    of errors in the transport layer :'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层必须处理可能影响它发送的段的多种类型的错误。在实践中，我们主要必须在传输层处理两种类型的错误：
- en: Segments can be corrupted by transmission errors
  id: totrans-682
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落可能会因为传输错误而损坏
- en: ''
  id: totrans-683
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-684
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Segments can be lost or unexpected segments can appear
  id: totrans-685
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落可能会丢失或出现意外的段
- en: 'To detect errors, a segment is usually divided into two parts :'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测错误，一个段通常被分为两部分：
- en: a header that contains the fields used by the reliable protocol to ensure reliable
    delivery. The header contains a checksum or Cyclical Redundancy Check (CRC) [[Williams1993]](../bibliography.html#williams1993)
    that is used to detect transmission errors
  id: totrans-687
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含可靠协议用于确保可靠交付的字段的头部。该头部包含一个校验和或循环冗余校验（CRC）[[Williams1993]](../bibliography.html#williams1993)，用于检测传输错误
- en: ''
  id: totrans-688
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-689
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a payload that contains the user data
  id: totrans-690
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含用户数据的有效载荷
- en: Some headers also include a length field, which indicates the total length of
    the segment or the length of the payload.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 一些头部还包括一个长度字段，该字段指示段的总体长度或有效载荷的长度。
- en: The simplest error detection scheme is the checksum. A checksum is basically
    an arithmetic sum of all the bytes that a segment is composed of. There are different
    types of checksums. For example, an eight bit checksum can be computed as the
    arithmetic sum of all the bytes of (both the header and trailer of) the segment.
    The checksum is computed by the sender before sending the segment and the receiver
    verifies the checksum upon segment reception. The receiver discards segments received
    with an invalid checksum. Checksums can be easily implemented in software, but
    their error detection capabilities are limited. Cyclical Redundancy Checks (CRC)
    have better error detection capabilities [[SGP98]](../bibliography.html#sgp98),
    but require more CPU when implemented in software.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的错误检测方案是校验和。校验和基本上是构成段的全部字节的算术和。有不同类型的校验和。例如，一个8位校验和可以计算为段（包括头部和尾部）所有字节的算术和。校验和在发送段之前由发送者计算，接收者在收到段时验证校验和。接收者丢弃接收到的无效校验和的段。校验和可以很容易地在软件中实现，但它们的错误检测能力有限。循环冗余校验（CRC）具有更好的错误检测能力
    [[SGP98]](../bibliography.html#sgp98)，但在软件实现时需要更多的CPU。
- en: Note
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Checksums, CRCs,…
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和、CRC、…
- en: Most of the protocols in the TCP/IP protocol suite rely on the simple Internet
    checksum in order to verify that a received packet has not been affected by transmission
    errors. Despite its popularity and ease of implementation, the Internet checksum
    is not the only available checksum mechanism. Cyclical Redundancy Checks ([CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check))
    are very powerful error detection schemes that are used notably on disks, by many
    datalink layer protocols and file formats such as `zip` or `png`. They can easily
    be implemented efficiently in hardware and have better error-detection capabilities
    than the Internet checksum [[SGP98]](../bibliography.html#sgp98) . However, CRCs
    are sometimes considered to be too CPU-intensive for software implementations
    and other checksum mechanisms are preferred. The TCP/IP community chose the Internet
    checksum, the OSI community chose the Fletcher checksum [[Sklower89]](../bibliography.html#sklower89).
    Nowadays there are efficient techniques to quickly compute CRCs in software [[Feldmeier95]](../bibliography.html#feldmeier95).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议族中的大多数协议都依赖于简单的互联网校验和来验证接收到的数据包在传输过程中没有被错误影响。尽管它很受欢迎且易于实现，但互联网校验和并不是唯一的校验和机制。循环冗余校验（[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)）是非常强大的错误检测方案，特别在磁盘、许多数据链路层协议以及`zip`或`png`等文件格式中使用。它们可以很容易地在硬件中高效实现，并且比互联网校验和具有更好的错误检测能力
    [[SGP98]](../bibliography.html#sgp98)。然而，CRC有时被认为对软件实现来说CPU消耗过高，因此更倾向于使用其他校验和机制。TCP/IP社区选择了互联网校验和，OSI社区选择了Fletcher校验和
    [[Sklower89]](../bibliography.html#sklower89)。如今，有高效的软件计算CRC的技术 [[Feldmeier95]](../bibliography.html#feldmeier95)。
- en: Since the receiver sends an acknowledgment after having received each data segment,
    the simplest solution to deal with losses is to use a retransmission timer. When
    the sender sends a segment, it starts a retransmission timer. The duration of
    this retransmission timer should be larger than the round-trip-time, i.e. the
    delay between the transmission of a data segment and the reception of the corresponding
    acknowledgment. When the retransmission timer expires, the sender assumes that
    the data segment has been lost and retransmits it. This is illustrated in the
    figure below.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收者在收到每个数据段后发送确认，因此处理丢失的最简单方法是使用重传计时器。当发送者发送一个段时，它启动一个重传计时器。这个重传计时器的持续时间应该大于往返时间，即数据段传输和对应确认接收之间的延迟。当重传计时器到期时，发送者假设数据段已丢失并重新发送它。这在下图中进行了说明。
- en: '![msc {'
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b-x c [ label = "D(b)", arcskip="1", linecolour=red];
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(b)", arcskip="1", linecolour=red];
- en: '|||;'
  id: totrans-712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "timer expires" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/eb3e128faed868520ea345c4171d9007.png)<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"
    name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"></map>'
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/eb3e128faed868520ea345c4171d9007.png)<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"
    name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"></map>'
- en: '[PRE16]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unfortunately, retransmission timers alone are not sufficient to recover from
    losses. Let us consider, as an example, the situation depicted below where an
    acknowledgment is lost. In this case, the sender retransmits the data segment
    that has not been acknowledged. However, as illustrated in the figure below, the
    receiver considers the retransmission as a new segment whose payload must be delivered
    to its user.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅重传计时器不足以从丢失中恢复。让我们考虑以下情况，其中确认信息丢失。在这种情况下，发送方重新传输尚未确认的数据段。然而，如图所示，接收方将重传视为新的段，其有效载荷必须交付给用户。
- en: '![msc {'
  id: totrans-721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-722
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
- en: b>>c [ label = "D(a)", arcskip="1"];
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="cancel timer"];
- en: '|||;'
  id: totrans-733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c-x b [label= "C(OK)", linecolour=red, arcskip="1"];
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c-x b [label= "C(OK)", linecolour=red, arcskip="1"];
- en: '|||;'
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "timer expires" ] ,
- en: b>>c [ label = "D(b)", arcskip="1"];
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b) !!!!!", linecolour=red ];
  id: totrans-741
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b) !!!!!", linecolour=red ];
- en: c>>b [label= "C(OK)", arcskip="1"];
  id: totrans-742
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK)", arcskip="1"];
- en: '|||;'
  id: totrans-743
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/f31aca9d4a56211a006ee59b4bbd6581.png)<map id="34c7c055da8716230ba3f29574fb761575e3d9f5"
    name="34c7c055da8716230ba3f29574fb761575e3d9f5"></map>'
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f31aca9d4a56211a006ee59b4bbd6581.png)<map id="34c7c055da8716230ba3f29574fb761575e3d9f5"
    name="34c7c055da8716230ba3f29574fb761575e3d9f5"></map>'
- en: To solve this problem, reliable protocols associate a sequence number to each
    data segment. This sequence number is one of the fields found in the header of
    data segments. We use the notation D(x,…) to indicate a data segment whose sequence
    number field is set to value x. The acknowledgments also contain a sequence number
    indicating the data segments that it acknowledges. We use OKx to indicate an acknowledgment
    that confirms the reception of D(x,…). The sequence number is encoded as a bit
    string of fixed length. The simplest reliable protocol is the Alternating Bit
    Protocol (ABP).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可靠的协议将序列号分配给每个数据段。这个序列号是数据段头部中找到的字段之一。我们使用表示法D(x,…)来表示序列号字段设置为值x的数据段。确认信息也包含一个序列号，表示它确认的数据段。我们使用OKx来表示确认接收了D(x,…)的确认信息。序列号被编码为固定长度的比特串。最简单的可靠协议是交替位协议（ABP）。
- en: The Alternating Bit Protocol[#](#the-alternating-bit-protocol "Link to this
    heading")
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交替位协议[#](#the-alternating-bit-protocol "链接到本标题")
- en: The Alternating Bit Protocol uses a single bit to encode the sequence number.
    It can be implemented easily. The sender (resp. the receiver) only require a four-state
    (resp. three-state) Finite State Machine. The sender FSM is represented in [Fig.
    48](#fig-abp-sender-fsm) and the receiver FSM in [Fig. 49](#fig-abp-receiver-fsm).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议使用一个比特来编码序列号。它可以很容易地实现。发送方（分别）只需要一个四状态（分别）有限状态机。发送方有限状态机在[图48](#fig-abp-sender-fsm)中表示，接收方有限状态机在[图49](#fig-abp-receiver-fsm)中表示。
- en: '![Figure made with TikZ](../Images/8fbe25275e0fee019961c542919ef49b.png)'
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![Figure made with TikZ](../Images/8fbe25275e0fee019961c542919ef49b.png)'
- en: ''
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 48 Alternating bit protocol: Sender FSM'
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图48 交替位协议：发送方有限状态机
- en: The initial state of the sender is Wait for D(0,…). In this state, the sender
    waits for a Data.request. The first data segment that it sends uses sequence number
    0. After having sent this segment, the sender waits for an OK0 acknowledgment.
    A data segment is retransmitted upon expiration of the retransmission timer or
    if an acknowledgment with an incorrect sequence number has been received.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者的初始状态是等待 D(0,…). 在此状态下，发送者等待 Data.request. 它发送的第一个数据段使用序列号 0. 发送此段之后，发送者等待
    OK0 确认。如果重传计时器到期或收到带有错误序列号的确认，则重新传输数据段。
- en: The receiver first waits for D(0,…). If the segment contains a correct CRC,
    it passes the SDU to its user and sends OK0. If the segment contains an invalid
    CRC, it is immediately discarded. Then, the receiver waits for D(1,…). In this
    state, it may receive a duplicate D(0,…) or a data segment with an invalid CRC.
    In both cases, it returns an OK0 segment to allow the sender to recover from the
    possible loss of the previous OK0 segment.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者首先等待 D(0,…). 如果段包含正确的 CRC，则将其 SDU 传递给其用户并发送 OK0. 如果段包含无效的 CRC，则立即丢弃。然后，接收者等待
    D(1,…). 在此状态下，它可能收到重复的 D(0,…) 或包含无效 CRC 的数据段。在这两种情况下，它返回一个 OK0 段以允许发送者从可能丢失的前一个
    OK0 段中恢复。
- en: '![Figure made with TikZ](../Images/3badb5e30f18cd10794dafd6f023ac28.png)'
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/3badb5e30f18cd10794dafd6f023ac28.png)'
- en: ''
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 49 Alternating bit protocol: Receiver FSM'
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 49 交替位协议：接收者有限状态机
- en: Note
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Corrupted segments must be discarded
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 损坏的段必须被丢弃
- en: The receiver FSM of the Alternating bit protocol discards all segments that
    contain an invalid CRC. This is the safest approach since the received segment
    can be completely different from the one sent by the remote host. A receiver should
    not attempt at extracting information from a corrupted segment because it cannot
    know which portion of the segment has been affected by the error.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议的接收者有限状态机丢弃所有包含无效 CRC 的段。这是最安全的做法，因为接收到的段可能与远程主机发送的段完全不同。接收者不应尝试从损坏的段中提取信息，因为它无法知道段的哪个部分受到了错误的影响。
- en: The figure below illustrates the operation of the Alternating Bit Protocol.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了交替位协议的操作。
- en: '![msc {'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ];
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\nstart timer" ];
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(c)\nstart timer" ] ,
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(c)\nstart timer" ] ,
- en: b>>c [ label = "D(0,c)", arcskip="1"];
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,c)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(c)" ];
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(c)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/58f29e8a1f0f64da47ef83b069805c78.png)<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"
    name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"></map>'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/58f29e8a1f0f64da47ef83b069805c78.png)<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"
    name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"></map>'
- en: The Alternating Bit Protocol can recover from the losses of data or control
    segments. This is illustrated in the two figures below. The first figure shows
    the loss of one data segment.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 交替位协议可以从数据或控制段的丢失中恢复。这在下面的两个图中说明。第一个图显示了一个数据段的丢失。
- en: '![msc {'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b-x c [ label = "D(1,b)", arcskip="1", linecolour=red];
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(1,b)", arcskip="1", linecolour=red];
- en: '|||;'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "计时器到期" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/f662cc9a0b114455fe7ce91316c8aedb.png)<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68"
    name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"></map>'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/f662cc9a0b114455fe7ce91316c8aedb.png)<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68"
    name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"></map>'
- en: The second figure illustrates how the hosts handle the loss of one control segment.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图示说明了主机如何处理一个控制段的丢失。
- en: '![msc {'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(a)\nstart timer" ] ,
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(a)\n启动计时器" ] ,
- en: b>>c [ label = "D(0,a)", arcskip="1"];
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(0,a)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(a)" ];
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(a)" ];
- en: c>>b [label= "C(OK0)", arcskip="1"];
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK0)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(b)\nstart timer" ] ,
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(b)\n启动计时器" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "DATA.ind(b)" ];
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(b)" ];
- en: c-x b [label= "C(OK1)", linecolour=red, arcskip="1"];
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: c-x b [label= "C(OK1)", linecolour=red, arcskip="1"];
- en: '|||;'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ linecolour=white, label = "timer expires" ] ,
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: a=>b [ linecolour=white, label = "计时器到期" ] ,
- en: b>>c [ label = "D(1,b)", arcskip="1"];
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "D(1,b)", arcskip="1"];
- en: c=>d [ label = "Duplicate segment\nignored", textcolour=red, linecolour=white
    ];
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d [ label = "重复段\n忽略", textcolour=red, linecolour=white ];
- en: c>>b [label= "C(OK1)", arcskip="1"];
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [label= "C(OK1)", arcskip="1"];
- en: b->a [linecolour=white, label="cancel timer"];
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: b->a [linecolour=white, label="取消计时器"];
- en: '|||;'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/3bcb6de20e7b816c3750de577d1012cc.png)<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"
    name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"></map>'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/3bcb6de20e7b816c3750de577d1012cc.png)<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"
    name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"></map>'
- en: The Alternating Bit Protocol can recover from transmission errors and segment
    losses. However, it has one important drawback. Consider two hosts that are directly
    connected by a 50 Kbits/sec satellite link that has a 250 milliseconds propagation
    delay. If these hosts send 1000 bits segments, then the maximum throughput that
    can be achieved by the alternating bit protocol is one segment every \(20+250+250=520\)
    milliseconds if we ignore the transmission time of the acknowledgment. This is
    less than 2 Kbits/sec !
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 交替比特协议可以从传输错误和段丢失中恢复。然而，它有一个重要的缺点。考虑两个通过50 Kbits/sec 卫星链路直接连接的主机，该链路具有250毫秒的传播延迟。如果这些主机发送1000比特的段，那么如果忽略确认的传输时间，交替比特协议可以达到的最大吞吐量是每520毫秒一个段，即\(20+250+250=520\)毫秒！这还不到2
    Kbits/sec！
- en: '[PRE17]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Go-back-n and selective repeat[#](#go-back-n-and-selective-repeat "Link to this
    heading")
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go-back-n 和选择性重传[#](#go-back-n-and-selective-repeat "链接到本标题")
- en: To overcome the performance limitations of the alternating bit protocol, reliable
    protocols rely on pipelining shown in [Fig. 50](#fig-pipelining). This technique
    allows a sender to transmit several consecutive segments without being forced
    to wait for an acknowledgment after each segment. Each data segment contains a
    sequence number encoded as an n bits field.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服交替比特协议的性能限制，可靠的协议依赖于如图50所示的流水线技术。这项技术允许发送者在每个段之后不必等待确认即可连续发送多个段。每个数据段包含一个序列号，该序列号编码为一个n位字段。
- en: '[![../_images/pipelining2.png](../Images/673705ddb7a242862f06d67fd8c2c097.png)](../_images/pipelining2.png)'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/pipelining2.png](../Images/673705ddb7a242862f06d67fd8c2c097.png)](../_images/pipelining2.png)'
- en: Fig. 50 Pipelining improves the performance of reliable protocols[#](#fig-pipelining
    "Link to this image")
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 图50 流水线提高了可靠协议的性能[#](#fig-pipelining "链接到本图像")
- en: Pipelining allows the sender to transmit segments at a higher rate. However
    this higher transmission rate may overload the receiver. In this case, the segments
    sent by the sender will not be correctly received by their final destination.
    The reliable protocols that rely on pipelining allow the sender to transmit W
    unacknowledged segments before being forced to wait for an acknowledgment from
    the receiving entity.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 管道化允许发送者以更高的速率传输段。然而，这种更高的传输速率可能会超载接收者。在这种情况下，发送者发送的段将不会被其最终目的地正确接收。依赖于管道化的可靠协议允许发送者在被强制等待接收实体确认之前传输
    W 个未确认的段。
- en: This is implemented by using a sliding window. The sliding window is the set
    of consecutive sequence numbers that the sender can use when transmitting segments
    without being forced to wait for an acknowledgment. [Fig. 51](#fig-sliding-win)
    shows a sliding window containing five segments (6,7,8,9 and 10). Two of these
    sequence numbers (6 and 7) have been used to send segments and only three sequence
    numbers (8, 9 and 10) remain in the sliding window. The sliding window is said
    to be closed once all sequence numbers contained in the sliding window have been
    used.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用滑动窗口实现的。滑动窗口是发送者在发送段时可以使用而不必等待确认的连续序列号集合。[图 51](#fig-sliding-win) 展示了一个包含五个段（6、7、8、9
    和 10）的滑动窗口。其中两个序列号（6 和 7）已被用于发送段，而滑动窗口中只剩下三个序列号（8、9 和 10）。当滑动窗口中的所有序列号都被使用后，滑动窗口被认为是关闭的。
- en: '[![../_images/slidingwin2.png](../Images/cff43484e462b0df38ba215dd67e6922.png)](../_images/slidingwin2.png)'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/slidingwin2.png](../Images/cff43484e462b0df38ba215dd67e6922.png)](../_images/slidingwin2.png)'
- en: Fig. 51 The sliding window[#](#id16 "Link to this image")
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 图 51 滑动窗口[#](#id16 "链接到这张图片")
- en: '[Fig. 52](#fig-sliding-win-ex) illustrates the operation of the sliding window.
    It uses a sliding window of three segments. The sender can thus transmit three
    segments before being forced to wait for an acknowledgment. The sliding window
    moves to the higher sequence numbers upon the reception of each acknowledgment.
    When the first acknowledgment (OK0) is received, it enables the sender to move
    its sliding window to the right and sequence number 3 becomes available. This
    sequence number is used later to transmit the segment containing d.'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 52](#fig-sliding-win-ex) 展示了滑动窗口的操作。它使用三个段的滑动窗口。因此，发送者可以在收到确认之前传输三个段。在收到每个确认后，滑动窗口会移动到更高的序列号。当收到第一个确认（OK0）时，它允许发送者将其滑动窗口向右移动，序列号
    3 变得可用。这个序列号后来被用来传输包含 d 的段。'
- en: '[![../_images/gbnwin.png](../Images/b5fde7825c12c07ce8b77cc1e5f37556.png)](../_images/gbnwin.png)'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/gbnwin.png](../Images/b5fde7825c12c07ce8b77cc1e5f37556.png)](../_images/gbnwin.png)'
- en: Fig. 52 Sliding window example[#](#id17 "Link to this image")
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 图 52 滑动窗口示例[#](#id17 "链接到这张图片")
- en: In practice, as the segment header includes an n bits field to encode the sequence
    number, only the sequence numbers between \(0\) and \(2^{n}-1\) can be used. This
    implies that, during a long transfer, the same sequence number will be used for
    different segments and the sliding window will wrap. This is illustrated in [Fig.
    53](#fig-sliding-win-modulo) assuming that 2 bits are used to encode the sequence
    number in the segment header. Note that upon reception of OK1, the sender slides
    its window and can use sequence number 0 again.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，由于段头包括一个用于编码序列号的 n 位字段，因此只能使用 \(0\) 到 \(2^{n}-1\) 之间的序列号。这意味着，在长时间传输过程中，相同的序列号将用于不同的段，滑动窗口将回绕。这通过
    [图 53](#fig-sliding-win-modulo) 来说明，假设在段头中使用 2 位来编码序列号。请注意，在收到 OK1 后，发送者滑动其窗口，并可以再次使用序列号
    0。
- en: '[![../_images/gbnwinex.png](../Images/0ef78f3981c477d103876d2f7358bdd3.png)](../_images/gbnwinex.png)'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/gbnwinex.png](../Images/0ef78f3981c477d103876d2f7358bdd3.png)](../_images/gbnwinex.png)'
- en: Fig. 53 Utilization of the sliding window with modulo arithmetic[#](#id18 "Link
    to this image")
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 图 53 使用模运算的滑动窗口利用率[#](#id18 "链接到这张图片")
- en: 'Unfortunately, segment losses do not disappear because a reliable protocol
    uses a sliding window. To recover from losses, a sliding window protocol must
    define :'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于可靠协议使用滑动窗口，段丢失并不会消失。为了从丢失中恢复，滑动窗口协议必须定义：
- en: a heuristic to detect losses
  id: totrans-853
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于检测丢失的启发式方法
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-855
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a retransmission strategy to retransmit the lost segments
  id: totrans-856
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种重传策略，用于重传丢失的段
- en: The simplest sliding window protocol uses the go-back-n recovery. Intuitively,
    go-back-n operates as follows. A go-back-n receiver is as simple as possible.
    It only accepts the segments that arrive in-sequence. A go-back-n receiver discards
    any out-of-sequence segment that it receives. When go-back-n receives a data segment,
    it always returns an acknowledgment containing the sequence number of the last
    in-sequence segment that it has received. This acknowledgment is said to be cumulative.
    When a go-back-n receiver sends an acknowledgment for sequence number x, it implicitly
    acknowledges the reception of all segments whose sequence number is earlier than
    x. A key advantage of these cumulative acknowledgments is that it is easy to recover
    from the loss of an acknowledgment. Consider for example a go-back-n receiver
    that received segments 1, 2 and 3. It sent OK1, OK2 and OK3. Unfortunately, OK1
    and OK2 were lost. Thanks to the cumulative acknowledgments, when the sender receives
    OK3, it knows that all three segments have been correctly received.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的滑动窗口协议使用 go-back-n 恢复。直观地说，go-back-n 的工作方式如下。Go-back-n 接收器尽可能简单。它只接受按顺序到达的段。Go-back-n
    接收器会丢弃它接收到的任何顺序错误的段。当 go-back-n 接收到数据段时，它总是返回一个包含它已接收的最后顺序段的序列号的确认。这种确认被称为累积确认。当一个
    go-back-n 接收器为序列号 x 发送确认时，它隐式地确认了所有序列号早于 x 的段的接收。这些累积确认的一个关键优点是，从确认丢失中恢复很容易。例如，考虑一个接收了段
    1、2 和 3 的 go-back-n 接收器。它发送了 OK1、OK2 和 OK3。不幸的是，OK1 和 OK2 丢失了。多亏了累积确认，当发送器收到 OK3
    时，它知道所有三个段都已正确接收。
- en: '[Fig. 54](#fig-fsm-gbn-receiver) shows the FSM of a simple go-back-n receiver.
    This receiver uses two variables : lastack and next. next is the next expected
    sequence number and lastack the sequence number of the last data segment that
    has been acknowledged. The receiver only accepts the segments that are received
    in sequence. maxseq is the number of different sequence numbers (\(2^n\)).'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 54](#fig-fsm-gbn-receiver) 展示了一个简单的 go-back-n 接收器的状态机。此接收器使用两个变量：lastack
    和 next。next 是下一个期望的序列号，lastack 是已确认的最后数据段的序列号。接收器只接受按顺序接收到的段。maxseq 是不同序列号的数量
    (\(2^n\))。'
- en: '![Figure made with TikZ](../Images/129311f9bf007c55636d82806ff9a8ec.png)'
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/129311f9bf007c55636d82806ff9a8ec.png)'
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 54 Go-back-n: receiver FSM'
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 54 Go-back-n：接收器状态机
- en: A go-back-n sender is also very simple as shown in [Fig. 55](#fig-fsm-gbn-sender).
    It uses a sending buffer that can store an entire sliding window of segments [[2]](#fsizesliding).
    The segments are sent with increasing sequence numbers (modulo maxseq). The sender
    must wait for an acknowledgment once its sending buffer is full. When a go-back-n
    sender receives an acknowledgment, it removes from the sending buffer all the
    acknowledged segments and uses a retransmission timer to detect segment losses.
    A simple go-back-n sender maintains one retransmission timer per connection. This
    timer is started when the first segment is sent. When the go-back-n sender receives
    an acknowledgment, it restarts the retransmission timer only if there are still
    unacknowledged segments in its sending buffer. When the retransmission timer expires,
    the go-back-n sender assumes that all the unacknowledged segments currently stored
    in its sending buffer have been lost. It thus retransmits all the unacknowledged
    segments in the buffer and restarts its retransmission timer.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 55](#fig-fsm-gbn-sender) 所示，Go-back-n 发送器也非常简单。它使用一个发送缓冲区，可以存储整个滑动窗口的段
    [[2]](#fsizesliding)。段以递增的序列号（模 maxseq）发送。发送器在其发送缓冲区满时必须等待确认。当 go-back-n 发送器收到确认时，它会从发送缓冲区中移除所有已确认的段，并使用重传计时器来检测段丢失。一个简单的
    go-back-n 发送器为每个连接维护一个重传计时器。该计时器在发送第一个段时启动。当 go-back-n 发送器收到确认时，只有在其发送缓冲区中仍有未确认的段时，它才会重新启动重传计时器。当重传计时器超时时，go-back-n
    发送器假定其发送缓冲区中当前存储的所有未确认段都已丢失。因此，它会重新传输缓冲区中的所有未确认段，并重新启动其重传计时器。
- en: '![Figure made with TikZ](../Images/86718f7fdab6919b9def71253750e50a.png)'
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/86718f7fdab6919b9def71253750e50a.png)'
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 55 Go-back-n: sender FSM'
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 55 Go-back-n：发送器状态机
- en: The operation of go-back-n is illustrated in [Fig. 56](#fig-gbn-example). In
    this figure, note that upon reception of the out-of-sequence segment D(2,c), the
    receiver returns a cumulative acknowledgment C(OK,0) that acknowledges all the
    segments that have been received in sequence. The lost segment is retransmitted
    upon the expiration of the retransmission timer.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n的操作在[图56](#fig-gbn-example)中说明。在此图中，请注意，在接收到非顺序段D(2,c)后，接收器返回累积确认C(OK,0)，确认已按顺序接收的所有段。丢失的段在重传计时器到期后重新传输。
- en: '[![../_images/gbnex2.png](../Images/7c58d5fa667aca0d9275af765599720a.png)](../_images/gbnex2.png)'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/gbnex2.png](../Images/7c58d5fa667aca0d9275af765599720a.png)](../_images/gbnex2.png)'
- en: 'Fig. 56 Go-back-n : example[#](#id21 "Link to this image")'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 图56 go-back-n：示例[#](#id21 "链接到这张图片")
- en: 'The main advantage of go-back-n is that it can be easily implemented, and it
    can also provide good performance when only a few segments are lost. However,
    when there are many losses, the performance of go-back-n quickly drops for two
    reasons :'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: go-back-n的主要优势是它易于实现，并且当只有少量段丢失时，它也能提供良好的性能。然而，当有很多丢失时，go-back-n的性能会迅速下降，原因有两个：
- en: the go-back-n receiver does not accept out-of-sequence segments
  id: totrans-870
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: go-back-n接收器不接受非顺序段
- en: ''
  id: totrans-871
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-872
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the go-back-n sender retransmits all unacknowledged segments once it has detected
    a loss
  id: totrans-873
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: go-back-n发送器一旦检测到丢失，就重新传输所有未确认的段
- en: '[PRE20]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Selective repeat is a better strategy to recover from losses. Intuitively, selective
    repeat allows the receiver to accept out-of-sequence segments. Furthermore, when
    a selective repeat sender detects losses, it only retransmits the segments that
    have been lost and not the segments that have already been correctly received.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传是恢复丢失的更好策略。直观地讲，选择重传允许接收器接受非顺序段。此外，当选择重传发送器检测到丢失时，它只重传丢失的段，而不是已经正确接收的段。
- en: A selective repeat receiver maintains a sliding window of W segments and stores
    in a buffer the out-of-sequence segments that it receives. [Fig. 57](#fig-sr-rwin)
    shows a five-segment receive window on a receiver that has already received segments
    7 and 9.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传接收器维护一个包含W个段的滑动窗口，并将它接收到的非顺序段存储在缓冲区中。[图57](#fig-sr-rwin)显示了一个接收器已经接收了段7和9的五个段接收窗口。
- en: '[![../_images/selrepeatwin2.png](../Images/65c1ca27e931f581cf93b7c9874c2977.png)](../_images/selrepeatwin2.png)'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/selrepeatwin2.png](../Images/65c1ca27e931f581cf93b7c9874c2977.png)](../_images/selrepeatwin2.png)'
- en: Fig. 57 The receiving window with selective repeat[#](#id22 "Link to this image")
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 图57 选择重传的接收窗口[#](#id22 "链接到这张图片")
- en: A selective repeat receiver discards all segments having an invalid CRC, and
    maintains the variable lastack as the sequence number of the last in-sequence
    segment that it has received. The receiver always includes the value of lastack
    in the acknowledgments that it sends. Some protocols also allow the selective
    repeat receiver to acknowledge the out-of-sequence segments that it has received.
    This can be done for example by placing the list of the correctly received, but
    out-of-sequence segments in the acknowledgments together with the lastack value.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重传接收器丢弃所有具有无效CRC的段，并将变量lastack保持为它已接收的最后顺序段的序列号。接收器始终在其发送的确认中包含lastack的值。某些协议还允许选择重传接收器确认它已接收的非顺序段。例如，可以通过在确认中将正确接收但顺序错误的段的列表与lastack值一起放置来实现。
- en: When a selective repeat receiver receives a data segment, it first verifies
    whether the segment is inside its receiving window. If yes, the segment is placed
    in the receive buffer. If not, the received segment is discarded and an acknowledgment
    containing lastack is sent to the sender. The receiver then removes all consecutive
    segments starting at lastack (if any) from the receive buffer. The payloads of
    these segments are delivered to the user, lastack and the receiving window are
    updated, and an acknowledgment acknowledging the last segment received in sequence
    is sent.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择重传接收器接收到一个数据段时，它首先验证该段是否在其接收窗口内。如果是，该段将被放置在接收缓冲区中。如果不是，接收到的段将被丢弃，并向发送者发送包含lastack的确认。接收器随后从接收缓冲区中移除从lastack开始的（如果有）所有连续段。这些段的负载被交付给用户，lastack和接收窗口被更新，并发送一个确认，确认已按顺序接收的最后一段。
- en: The selective repeat sender maintains a sending buffer that can store up to
    W unacknowledged segments. These segments are sent as long as the sending buffer
    is not full. Several implementations of a selective repeat sender are possible.
    A simple implementation associates one retransmission timer to each segment. The
    timer is started when the segment is sent and canceled upon reception of an acknowledgment
    that covers this segment. When a retransmission timer expires, the corresponding
    segment is retransmitted and this retransmission timer is restarted. When an acknowledgment
    is received, all the segments that are covered by this acknowledgment are removed
    from the sending buffer and the sliding window is updated.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重复发送者维护一个发送缓冲区，可以存储最多W个未确认的段。只要发送缓冲区不满，就会发送这些段。可能存在几种选择重复发送者的实现方式。一种简单的实现方式是为每个段关联一个重传定时器。当发送段时启动定时器，并在接收到覆盖此段的确认后取消定时器。当重传定时器超时时，相应的段被重传，并且重传定时器重新启动。当接收到确认时，所有被此确认覆盖的段将从发送缓冲区中移除，并且滑动窗口被更新。
- en: '[Fig. 58](#fig-sr-example) illustrates the operation of selective repeat when
    segments are lost. In this figure, C(OK,x) is used to indicate that all segments,
    up to and including sequence number x have been received correctly.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '[图58](#fig-sr-example)展示了在数据段丢失时选择重复的操作。在此图中，C(OK,x)用于表示所有段，包括序列号x及其之前的所有段都已正确接收。'
- en: '[![../_images/selrepeat.png](../Images/5146331e8d7c7c36361e7fc92750fb1a.png)](../_images/selrepeat.png)'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '![选择重复](../Images/5146331e8d7c7c36361e7fc92750fb1a.png)'
- en: 'Fig. 58 Selective repeat : example[#](#id23 "Link to this image")'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 图58 选择重复：示例[#](#id23 "链接到这张图片")
- en: Pure cumulative acknowledgments work well with the go-back-n strategy. However,
    with only cumulative acknowledgments a selective repeat sender cannot easily determine
    which segments have been correctly received after a data segment has been lost.
    For example, in the figure above, the second C(OK,0) does not inform explicitly
    the sender of the reception of D(2,c) and the sender could retransmit this segment
    although it has already been received. A possible solution to improve the performance
    of selective repeat is to provide additional information about the received segments
    in the acknowledgments that are returned by the receiver. For example, the receiver
    could add in the returned acknowledgment the list of the sequence numbers of all
    segments that have already been received. Such acknowledgments are sometimes called
    selective acknowledgments. We will provide examples of such acknowledgments in
    the TCP and QUIC protocols later in this book.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 纯累积确认与回退-n策略配合良好。然而，仅使用累积确认，选择重复发送者无法轻易确定在数据段丢失后哪些段已被正确接收。例如，在上面的图中，第二个C(OK,0)并没有明确通知发送者D(2,c)已被接收，因此发送者可能会重传这个段，尽管它已经被接收。为了提高选择重复的性能，一种可能的解决方案是在接收者返回的确认中提供有关已接收段的一些额外信息。例如，接收者可以在返回的确认中添加已接收所有段的序列号列表。这种确认有时被称为选择确认。我们将在本书后面的TCP和QUIC协议中提供此类确认的示例。
- en: '[PRE21]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Maximum window size with go-back-n and selective repeat
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 带回退-n和选择重复的最大窗口大小
- en: A reliable protocol that uses n bits to encode its sequence number can send
    up to \(2^n\) successive segments. However, to ensure a reliable delivery of the
    segments, go-back-n and selective repeat cannot use a sending window of \(2^n\)
    segments. Consider first go-back-n and assume that a sender sends \(2^n\) segments.
    These segments are received in-sequence by the destination, but all the returned
    acknowledgments are lost. The sender will retransmit all segments. These segments
    will all be accepted by the receiver and delivered a second time to the user.
    It is easy to see that this problem can be avoided if the maximum size of the
    sending window is \({2^n}-1\) segments. A similar problem occurs with selective
    repeat. However, as the receiver accepts out-of-sequence segments, a sending window
    of \({2^n}-1\) segments is not sufficient to ensure a reliable delivery. It can
    be easily shown that to avoid this problem, a selective repeat sender cannot use
    a window that is larger than \(\frac{2^n}{2}\) segments.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用 n 位来编码其序列号的可靠协议可以发送多达 \(2^n\) 个连续的段。然而，为了确保段的可信传输，后退 N 次和选择重传不能使用 \(2^n\)
    个段的发送窗口。首先考虑后退 N 次方法，假设发送方发送 \(2^n\) 个段。这些段按顺序被目的地接收，但所有返回的确认都丢失了。发送方将重新传输所有段。这些段都将被接收方接受，并第二次交付给用户。很容易看出，如果发送窗口的最大大小是
    \({2^n}-1\) 个段，则可以避免这个问题。选择重传也会出现类似的问题。然而，由于接收方接受非顺序段，\({2^n}-1\) 个段的发送窗口不足以确保可靠交付。可以很容易地证明，为了避免这个问题，选择重传发送方不能使用大于
    \(\frac{2^n}{2}\) 个段的窗口。
- en: Reliable protocols often need to send data in both directions. To reduce the
    overhead caused by the acknowledgments, most reliable protocols use piggybacking.
    Thanks to this technique, an entity can place the acknowledgments and the receive
    window that it advertises for the opposite direction of the data flow inside the
    header of the data segments that it sends. The main advantage of piggybacking
    is that it reduces the overhead as it is not necessary to send a complete segment
    to carry an acknowledgment. This is illustrated in the figure below where the
    acknowledgment number is underlined in the data segments. Piggybacking is only
    used when data flows in both directions. A receiver will generate a pure acknowledgment
    when it does not send data in the opposite direction as shown in the bottom of
    the figure.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠协议通常需要在两个方向上发送数据。为了减少由确认引起的开销，大多数可靠协议使用 piggybacking（尾随）。多亏了这项技术，实体可以将确认和它为数据流相反方向声明的接收窗口放置在它发送的数据段的头部。尾随的主要优点是它减少了开销，因为不需要发送完整的段来携带确认。这在下图中得到了说明，其中确认号在数据段中被下划线标注。尾随仅在数据流双向流动时使用。当接收方在相反方向不发送数据时，如图底部所示，它将生成一个纯确认。
- en: '[![../_images/piggyback2.png](../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png)](../_images/piggyback2.png)'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/piggyback2.png](../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png)](../_images/piggyback2.png)'
- en: Fig. 59 Piggybacking example[#](#id24 "Link to this image")
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 图 59 尾随示例[#](#id24 "链接到本图像")
- en: '[PRE22]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Establishing a transport connection[#](#establishing-a-transport-connection
    "Link to this heading")
  id: totrans-895
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立传输连接[#](#establishing-a-transport-connection "链接到本标题")
- en: Like the connectionless service, the connection-oriented service allows several
    applications running on a given host to exchange data with other hosts. The port
    numbers described earlier for the connectionless service are also used by the
    connection-oriented service to multiplex several applications. Similarly, connection-oriented
    protocols use checksums/CRCs to detect transmission errors and discard segments
    containing an invalid checksum/CRC.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接服务一样，面向连接的服务允许在给定主机上运行的多个应用程序与其他主机交换数据。前面描述的无连接服务中的端口号也被面向连接的服务用于多路复用多个应用程序。同样，面向连接的协议使用校验和/CRC来检测传输错误并丢弃包含无效校验和/CRC的段。
- en: An important difference between the connectionless service and the connection-oriented
    one is that the transport entities in the latter maintain some state during lifetime
    of the connection. This state is created when a connection is established and
    is removed when it is released.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务和面向连接服务之间的重要区别在于，后者在连接生命周期内维护一些状态。这种状态是在建立连接时创建的，并在释放时移除。
- en: 'The simplest approach to establish a transport connection would be to define
    two special control segments : CR (Connection Request) and CA (Connection Acknowledgment).
    The CR segment is sent by the transport entity that wishes to initiate a connection.
    If the remote entity wishes to accept the connection, it replies by sending a
    CA segment. The CR and CA segments contain port numbers that allow identifying
    the communicating applications. The transport connection is considered to be established
    once the CA segment has been received. At that point, data segments can be sent
    in both directions.'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 建立传输连接的最简单方法可能是定义两个特殊的控制段：CR（连接请求）和CA（连接确认）。CR 段落由希望发起连接的传输实体发送。如果远程实体希望接受连接，它将通过发送
    CA 段落进行回复。CR 和 CA 段落包含端口号，这允许识别通信的应用程序。一旦收到 CA 段落，传输连接就被认为是建立的。在此点，可以双向发送数据段。
- en: '![msc {'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "CR", arcskip="1", textcolour=red];
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "CR", arcskip="1", textcolour=red];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "CA", arcskip="1", textcolour=red];
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "CA", arcskip="1", textcolour=red];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接已建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接已建立" ];
- en: '}](../Images/384affb0102503143b8af853578161f2.png)<map id="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"
    name="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"></map>'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/384affb0102503143b8af853578161f2.png)<map id="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"
    name="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"></map>'
- en: Unfortunately, this is not sufficient given the unreliability of the network
    layer. Since the network layer is imperfect, the CR or CA segments can be lost,
    delayed, or suffer from transmission errors. To deal with these problems, the
    control segments must be protected by a CRC or a checksum to detect transmission
    errors. Furthermore, since the CA segment acknowledges the reception of the CR
    segment, the CR segment should be protected using a retransmission timer.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，考虑到网络层的不可靠性，这还不够。由于网络层不完美，CR 或 CA 段落可能会丢失、延迟或遭受传输错误。为了处理这些问题，控制段落必须通过 CRC
    或校验和来保护，以检测传输错误。此外，由于 CA 段落确认了 CR 段落的接收，CR 段落应该使用重传计时器来保护。
- en: Unfortunately, this scheme is not sufficient to ensure the reliability of the
    transport service. Consider for example a short-lived transport connection where
    a single, but important transfer (e.g. money transfer from a bank account) is
    sent. Such a short-lived connection starts with a CR segment acknowledged by a
    CA segment, then the data segment is sent, acknowledged and the connection terminates.
    Unfortunately, as the network layer service is unreliable, delays combined to
    retransmissions may lead to the situation depicted in the figure below, where
    a delayed CR and data segments from a former connection are accepted by the receiving
    entity as valid segments, and the corresponding data is delivered to the user.
    Duplicating SDUs is not acceptable, and the transport protocol must solve this
    problem.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个方案不足以确保传输服务的可靠性。例如，考虑一个短暂的传输连接，其中发送了一个单一但重要的传输（例如，从银行账户转账）。这样的短暂连接以一个被
    CA 段落确认的 CR 段落开始，然后发送数据段，确认并终止连接。不幸的是，由于网络层服务不可靠，延迟加上重传可能会导致下图中描述的情况，即延迟的 CR 和数据段被接收实体作为有效段接受，并将相应的数据交付给用户。重复
    SDU 是不可接受的，传输协议必须解决这个问题。
- en: '![msc {'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "CR", arcskip="1", textcolour=red];
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "CR", arcskip="1", textcolour=red];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "CA", arcskip="1", textcolour=red];
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "CA", arcskip="1", textcolour=red];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ] ,
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ];
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "First connection\nestablished"
    ];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ] ,
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ];
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=red, label = "First connection\nclosed"
    ];
- en: z>>c [ label = "CR", arcskip="1", textcolour=red];
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "CR", arcskip="1", textcolour=red];
- en: c=>d1 [ label = "How to detect duplicates ?" ],
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "如何检测重复？" ],
- en: c>>b [ label = "CA", arcskip="1", textcolour=red];
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "CA", arcskip="1", textcolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: z>>c [ label = "D", arcskip="1"];
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "D", arcskip="1"];
- en: '}](../Images/450730721625aed82431f20387763529.png)<map id="453dea7b2a70bc75af50524c87354c0a129e1d05"
    name="453dea7b2a70bc75af50524c87354c0a129e1d05"></map>'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/450730721625aed82431f20387763529.png)<map id="453dea7b2a70bc75af50524c87354c0a129e1d05"
    name="453dea7b2a70bc75af50524c87354c0a129e1d05"></map>'
- en: To avoid these duplicates, transport protocols require the network layer to
    bound the Maximum Segment Lifetime (MSL). The organization of the network must
    guarantee that no segment remains in the network for longer than MSL seconds.
    For example, on today’s Internet, MSL is expected to be 2 minutes. To avoid duplicate
    transport connections, transport protocol entities must be able to safely distinguish
    between a duplicate CR segment and a new CR segment, without forcing each transport
    entity to remember all the transport connections that it has established in the
    past.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些重复，传输协议要求网络层限制最大段生存时间（MSL）。网络的组织必须保证没有任何段在网络中停留超过 MSL 秒。例如，在今天的互联网上，MSL
    预计为 2 分钟。为了避免重复的传输连接，传输协议实体必须能够安全地区分重复的 CR 段和新的 CR 段，而无需强制每个传输实体记住它过去建立的所有传输连接。
- en: 'A classical solution to avoid remembering the previous transport connections
    to detect duplicates is to use a clock inside each transport entity. This transport
    clock has the following characteristics :'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 避免记住之前的传输连接以检测重复的经典解决方案是在每个传输实体内部使用一个时钟。这个传输时钟具有以下特性：
- en: the transport clock is implemented as a k bits counter and its clock cycle is
    such that \(2^k \times cycle >> MSL\). Furthermore, the transport clock counter
    is incremented every clock cycle and after each connection establishment. This
    clock is illustrated in [Fig. 60](#fig-transport-clock).
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输时钟被实现为一个 k 位计数器，其时钟周期为 \(2^k \times cycle >> MSL\)。此外，传输时钟计数器在每个时钟周期和每次连接建立后都会递增。这个时钟在[图60](#fig-transport-clock)中展示。
- en: ''
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the transport clock must continue to be incremented even if the transport entity
    stops or reboots
  id: totrans-948
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使传输实体停止或重启，传输时钟也必须继续递增
- en: '[![../_images/transport-clock.png](../Images/036312a7c0aeea69142b1e45c82f9114.png)](../_images/transport-clock.png)'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-clock.png](../Images/036312a7c0aeea69142b1e45c82f9114.png)](../_images/transport-clock.png)'
- en: Fig. 60 Transport clock[#](#id25 "Link to this image")
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 图60 传输时钟[#](#id25 "链接到这张图片")
- en: It should be noted that transport clocks do not need and usually are not synchronized
    to the real-time clock. Precisely synchronizing real-time clocks is an interesting
    problem, but it is outside the scope of this document. See [[Mills2006]](../bibliography.html#mills2006)
    for a detailed discussion on synchronizing the real-time clock.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，传输时钟不需要也不通常与实时时钟同步。精确同步实时时钟是一个有趣的问题，但它超出了本文档的范围。有关同步实时时钟的详细讨论，请参阅[[Mills2006]](../bibliography.html#mills2006)。
- en: 'This transport clock can be combined with an exchange of three segments, called
    the three way handshake, to detect duplicates. This three way handshake occurs
    as follows :'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这个传输时钟可以与三个段交换相结合，称为三次握手，以检测重复。这个三次握手如下发生：
- en: The initiating transport entity sends a CR segment. This segment requests the
    establishment of a transport connection. It contains a port number (not shown
    in the figure) and a sequence number (seq=x in the figure below) whose value is
    extracted from the transport clock. The transmission of the CR segment is protected
    by a retransmission timer.
  id: totrans-953
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化传输实体发送CR段。此段请求建立传输连接。它包含端口号（图中未显示）和一个序列号（如图下seq=x所示），其值从传输时钟中提取。CR段的传输由重传定时器保护。
- en: ''
  id: totrans-954
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The remote transport entity processes the CR segment and creates state for the
    connection attempt. At this stage, the remote entity does not yet know whether
    this is a new connection attempt or a duplicate segment. It returns a CA segment
    that contains an acknowledgment number to confirm the reception of the CR segment
    (ack=x in the figure below) and a sequence number (seq=y in the figure below)
    whose value is extracted from its transport clock. At this stage, the connection
    is not yet established.
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远端传输实体处理CR段并为连接尝试创建状态。在此阶段，远端实体尚不知道这是新的连接尝试还是重复的段。它返回一个包含确认号以确认CR段的接收（如图下ack=x所示）和一个序列号（如图下seq=y所示）的CA段，其值从其传输时钟中提取。在此阶段，连接尚未建立。
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The initiating entity receives the CA segment. The acknowledgment number of
    this segment confirms that the remote entity has correctly received the CR segment.
    The transport connection is considered to be established by the initiating entity
    and the numbering of the data segments starts at sequence number x. Before sending
    data segments, the initiating entity must acknowledge the received CA segments
    by sending another CA segment.
  id: totrans-959
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化实体接收CA段。此段的确认号确认远端实体已正确接收CR段。初始化实体认为传输连接已建立，数据段的编号从序列号x开始。在发送数据段之前，初始化实体必须通过发送另一个CA段来确认接收到的CA段。
- en: ''
  id: totrans-960
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The remote entity considers the transport connection to be established after
    having received the segment that acknowledges its CA segment. The numbering of
    the data segments sent by the remote entity starts at sequence number y.
  id: totrans-962
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远端实体在接收到确认其CA段的段落后，认为传输连接已经建立。远端实体发送的数据段编号从序列号y开始。
- en: The three way handshake is illustrated in [Fig. 61](#fig-three-way-handshake).
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 三向握手机制在[图61](#fig-three-way-handshake)中展示。
- en: '[![../_images/transport-twh.png](../Images/73ba69b884756214c68976e4bd783556.png)](../_images/transport-twh.png)'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-twh.png](../Images/73ba69b884756214c68976e4bd783556.png)](../_images/transport-twh.png)'
- en: Fig. 61 The three-way handshake[#](#id26 "Link to this image")
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 图61 三向握手机制[#](#id26 "链接到这张图片")
- en: Thanks to the three-way handshake, transport entities avoid duplicate transport
    connections. This is illustrated by considering the three scenarios below.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了三向握手机制，传输实体避免了重复的传输连接。这通过考虑以下三个场景来展示。
- en: The first scenario ([Fig. 62](#fig-twa-scenario1)) is when the remote entity
    receives an old CR segment. It considers this CR segment as a connection establishment
    attempt and replies by sending a CA segment. However, the initiating host cannot
    match the received CA segment with a previous connection attempt. It sends a control
    segment (REJECT in the figure below) to cancel the spurious connection attempt.
    The remote entity cancels the connection attempt upon reception of this control
    segment.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景([图62](#fig-twa-scenario1))是当远端实体接收到旧的CR段。它将此CR段视为连接建立尝试，并通过发送CA段进行回复。然而，初始化主机无法将接收到的CA段与先前的连接尝试匹配。它发送一个控制段（如图下REJECT所示）以取消虚假的连接尝试。远端实体在接收到此控制段后取消连接尝试。
- en: '[![../_images/transport-twh-dup.png](../Images/81f6e94d2c77bba094868c0725d75ae7.png)](../_images/transport-twh-dup.png)'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-twh-dup.png](../Images/81f6e94d2c77bba094868c0725d75ae7.png)](../_images/transport-twh-dup.png)'
- en: 'Fig. 62 Three-way handshake : recovery from a duplicate CR[#](#id27 "Link to
    this image")'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 图62 三向握手机制：从重复的CR段恢复[#](#id27 "链接到这张图片")
- en: A second scenario, shown in [Fig. 63](#fig-twa-scenario2) is when the initiating
    entity sends a CR segment that does not reach the remote entity and receives a
    duplicate CA segment from a previous connection attempt. This duplicate CA segment
    cannot contain a valid acknowledgment for the CR segment as the sequence number
    of the CR segment was extracted from the transport clock of the initiating entity.
    The CA segment is thus rejected and the CR segment is retransmitted upon expiration
    of the retransmission timer.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种场景，如[图63](#fig-twa-scenario2)所示，是当发起实体发送的CR段没有到达远程实体，并从之前的连接尝试中收到一个重复的CA段。由于CR段的序列号是从发起实体的传输时钟中提取的，这个重复的CA段不能包含对CR段的有效确认。因此，CA段被拒绝，CR段在重传定时器到期时重新发送。
- en: '[![../_images/transport-twh-dup2.png](../Images/4a3c5e9fdcb7671a490f8c5fbebda7f5.png)](../_images/transport-twh-dup2.png)'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-twh-dup2.png](../Images/4a3c5e9fdcb7671a490f8c5fbebda7f5.png)'
- en: 'Fig. 63 Three-way handshake : recovery from a duplicate CA[#](#id28 "Link to
    this image")'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '[图63 三向握手：从重复的CA恢复](#id28 "链接到这张图片")'
- en: The last scenario shown in [Fig. 64](#fig-twa-scenario3) is less likely, but
    it is important to consider it as well. The remote entity receives an old CR segment.
    It notes the connection attempt and acknowledges it by sending a CA segment. The
    initiating entity does not have a matching connection attempt and replies by sending
    a REJECT. Unfortunately, this segment never reaches the remote entity. Instead,
    the remote entity receives a retransmission of an older CA segment that contains
    the same sequence number as the first CR segment. This CA segment cannot be accepted
    by the remote entity as a confirmation of the transport connection as its acknowledgment
    number cannot have the same value as the sequence number of the first CA segment.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图64](#fig-twa-scenario3)中显示的最后一种场景不太可能发生，但同样重要的是要考虑它。远程实体接收到一个旧的CR段。它记录了连接尝试并通过发送CA段来确认它。发起实体没有匹配的连接尝试，并通过发送REJECT来回复。不幸的是，这个段从未到达远程实体。相反，远程实体接收到了一个包含与第一个CR段相同序列号的旧CA段的重新传输。由于确认号不能与第一个CA段的序列号相同，远程实体不能接受这个CA段作为传输连接的确认。
- en: '[![../_images/transport-twh-dup3.png](../Images/9e3c98b89e77408b7654305f9b1a2be3.png)](../_images/transport-twh-dup3.png)'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-twh-dup3.png](../Images/9e3c98b89e77408b7654305f9b1a2be3.png)'
- en: 'Fig. 64 Three-way handshake : recovery from duplicates CR and CA[#](#id29 "Link
    to this image")'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '[图64 三向握手：从重复的CR和CA恢复](#id29 "链接到这张图片")'
- en: Transferring data on a transport connection[#](#transferring-data-on-a-transport-connection
    "Link to this heading")
  id: totrans-976
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在传输连接上传输数据[#](#transferring-data-on-a-transport-connection "链接到这个标题")
- en: Now that the transport connection has been established, it can be used to transfer
    data. To ensure a reliable delivery of the data, the transport protocol will include
    sliding windows, retransmission timers and go-back-n or selective repeat. However,
    we cannot simply reuse these techniques because a reliable transport protocol
    also needs to cope with three additional types of errors (i) variable delays,
    (ii) out-f-sequence delivery and (iii) segment duplication.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在传输连接已经建立，它可以用来传输数据。为了确保数据的可靠传输，传输协议将包括滑动窗口、重传定时器和后退N或选择重传。然而，我们不能简单地重用这些技术，因为可靠的传输协议还需要处理三种额外的错误类型：(i)可变延迟，(ii)出序交付和(iii)段重复。
- en: When two hosts are connected by a link, the transmission delay or the round-trip-time
    over the link is almost fixed. In a network that can span the globe, the delays
    and the round-trip-times can vary significantly on a per packet basis. This variability
    can be caused by two factors. First, packets sent through a network do not necessarily
    follow the same path to reach their destination. Second, some packets may be queued
    in the buffers of routers when the load is high and these queuing delays can lead
    to increased end-to-end delays.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个主机通过一个链路连接时，链路上的传输延迟或往返时间几乎是固定的。在一个可以跨越全球的网络中，延迟和往返时间可以基于每个数据包而显著变化。这种可变性可能由两个因素引起。首先，通过网络发送的数据包不一定遵循相同的路径到达其目的地。其次，当负载高时，一些数据包可能会在路由器的缓冲区中排队，这些排队延迟可能导致端到端延迟的增加。
- en: Another problem is that a network does not always deliver packets in sequence.
    This implies that packets may be reordered by the network. Furthermore, the network
    may sometimes duplicate packets.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是一个网络并不总是按顺序交付数据包。这意味着数据包可能被网络重新排序。此外，网络有时可能会重复数据包。
- en: The last issue that needs to be dealt with in the transport layer is the transmission
    of large SDUs. In our example, we have used short SDUs which fit easily inside
    segments. Some applications generate SDUs that are much larger than the maximum
    size of a packet in the network layer. The transport layer needs to include mechanisms
    to fragment and reassemble these large SDUs.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层需要处理的问题中，最后一个问题是大型SDU的传输。在我们的示例中，我们使用了短SDU，它们很容易适应段。一些应用程序生成的SDU比网络层中数据包的最大尺寸大得多。传输层需要包括分割和重新组装这些大型SDU的机制。
- en: To deal with all these characteristics of the network layer, we need to adapt
    the go-back-n and selective repeat techniques that we have introduced earlier.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理网络层的所有这些特性，我们需要调整我们之前介绍过的回退N和选择重传技术。
- en: The ability to detect transmission errors remains important. Each segment contains
    a CRC/checksum which is computed over the entire segment (header and payload)
    by the sender and inserted in the header. The receiver recomputes the CRC/checksum
    for each received segment and discards all segments with an invalid CRC.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 检测传输错误的能力仍然很重要。每个段都包含一个CRC/校验和，这是发送者通过整个段（头部和有效载荷）计算并插入头部的。接收者将重新计算每个接收到的段的CRC/校验和，并丢弃所有CRC无效的段。
- en: Reliable transport protocols also use sequence numbers and acknowledgment numbers.
    While our example protocols used one sequence number per segment, some reliable
    transport protocols consider all the data transmitted as a stream of bytes. In
    these protocols, the sequence number placed in the segment header corresponds
    to the position of the first byte of the payload in the bytestream. This sequence
    number allows detecting losses but also enables the receiver to reorder the out-of-sequence
    segments. This is illustrated in the figure below.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠传输协议也使用序列号和确认号。虽然我们的示例协议在每个段中使用了单个序列号，但一些可靠传输协议将所有传输的数据视为字节流。在这些协议中，放置在段头中的序列号对应于有效载荷中第一个字节的字节流位置。这个序列号允许检测丢失，同时也使接收者能够重新排序出序的段。这在下图中进行了说明。
- en: '![msc {'
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(abcde)" ] ,
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(abcde)" ] ,
- en: b>>c [ arcskip="1", label="1:abcde"];
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="1:abcde"];
- en: c=>d [label="DATA.ind(abcde)"];
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [label="DATA.ind(abcde)"];
- en: '|||;'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: a=>b [ label = "DATA.req(fghijkl)" ] ,
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(fghijkl)" ] ,
- en: b>>c [ arcskip="1", label="6:fghijkl"];
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="6:fghijkl"];
- en: c=>d [label="DATA.ind(fghijkl)"];
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [label="DATA.ind(fghijkl)"];
- en: '}](../Images/d415b226c2c0f1663b1289acf10b1351.png)<map id="3c7d33b83d1006864217839e39a4133300ffe3b0"
    name="3c7d33b83d1006864217839e39a4133300ffe3b0"></map>'
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图片](../Images/d415b226c2c0f1663b1289acf10b1351.png)<map id="3c7d33b83d1006864217839e39a4133300ffe3b0"
    name="3c7d33b83d1006864217839e39a4133300ffe3b0"></map>'
- en: Using sequence numbers to count bytes has also one advantage when the transport
    layer needs to fragment SDUs in several segments. The figure below shows the fragmentation
    of a large SDU in two segments. Upon reception of the segments, the receiver will
    use the sequence numbers to correctly reorder the data.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 当传输层需要将SDU分成多个段时，使用序列号来计数字节也有一个优点。下图显示了将大型SDU分成两个段的过程。在接收到段后，接收者将使用序列号来正确地重新排序数据。
- en: '![msc {'
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(abcdefghijkl)" ] ,
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(abcdefghijkl)" ] ,
- en: b>>c [ arcskip="1", label="1:abcde"];
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="1:abcde"];
- en: '|||;'
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ arcskip="1", label="6:fghijkl"];
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1", label="6:fghijkl"];
- en: c=>d [label="DATA.ind(abcdefghijkl)"];
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [label="DATA.ind(abcdefghijkl)"];
- en: '}](../Images/e9784923b6b5cd4438e6db36fa5b219d.png)<map id="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"
    name="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"></map>'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e9784923b6b5cd4438e6db36fa5b219d.png)<map id="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"
    name="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"></map>'
- en: Compared to our simple protocols, reliable transport protocols encode their
    sequence numbers using more bits. 32 bits and 64 bits sequence numbers are frequent
    in the transport layer. This large sequence number space is motivated by two reasons.
    First, since the sequence number is incremented for each transmitted byte, a single
    segment may consume one or several thousands of sequence numbers. Second, a reliable
    transport protocol must be able to detect delayed segments. This can only be done
    if the number of bytes transmitted during the MSL period is smaller than the sequence
    number space. Otherwise, there is a risk of accepting duplicate segments.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的简单协议相比，可靠的传输协议使用更多的位来编码它们的序列号。32位和64位序列号在传输层很常见。这个大的序列号空间有两个原因。首先，由于序列号对每个传输的字节进行递增，一个段可能消耗一个或几个千个序列号。其次，可靠的传输协议必须能够检测延迟的段。这只能在MSL期间传输的字节数小于序列号空间的情况下完成。否则，存在接受重复段的风险。
- en: Go-back-n and selective repeat can be used in the transport layer as in the
    datalink layer. Since the network layer does not guarantee an in-order delivery
    of the packets, a transport entity should always store the segments that it receives
    out-of-sequence. For this reason, most transport protocols will opt for some form
    of selective repeat mechanism.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: Go-back-n 和选择重传可以在传输层和链路层中使用。由于网络层不保证数据包按顺序交付，传输实体应该始终存储它接收到的非顺序段。因此，大多数传输协议将选择某种选择重传机制。
- en: In simple protocols, the sliding window has usually a fixed size which depends
    on the amount of available buffers. A single transport layer entity serves a large
    and varying number of application processes. Each transport layer entity manages
    a pool of buffers that needs to be shared between all these processes. Transport
    entity are usually implemented inside the operating system kernel and shares memory
    with other parts of the system. Furthermore, a transport layer entity must support
    several (possibly hundreds or thousands) of transport connections at the same
    time. This implies that the memory which can be used to support the sending or
    the receiving buffer of a transport connection may change during the lifetime
    of the connection [[3]](#fautotune) . Thus, a transport protocol must allow the
    sender and the receiver to adjust their window sizes.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的协议中，滑动窗口通常具有固定的大小，这取决于可用缓冲区的大小。单个传输层实体为大量且变化的应用进程提供服务。每个传输层实体管理一个需要在这些所有进程之间共享的缓冲区池。传输实体通常在操作系统内核中实现，并与系统的其他部分共享内存。此外，传输层实体必须同时支持多个（可能是数百或数千个）传输连接。这意味着可以用于支持传输连接的发送或接收缓冲区的内存可能会在连接的生命周期内发生变化
    [[3]](#fautotune) 。因此，传输协议必须允许发送方和接收方调整它们的窗口大小。
- en: 'To deal with this issue, transport protocols allow the receiver to advertise
    the current size of its receiving window in all the acknowledgments that it sends.
    The receiving window advertised by the receiver bounds the size of the sending
    buffer used by the sender. In practice, the sender maintains two state variables
    : swin, the size of its sending window (that may be adjusted by the system) and
    rwin, the size of the receiving window advertised by the receiver. At any time,
    the number of unacknowledged segments cannot be larger than \(\min(swin,rwin)\)
    [[4]](#facklost) . The utilization of dynamic windows is illustrated in figure
    [Fig. 65](#fig-transport-dynamic-win).'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，传输协议允许接收方在它发送的所有确认中宣布其当前接收窗口的大小。接收方宣布的接收窗口限制了发送方使用的发送缓冲区的大小。在实践中，发送方维护两个状态变量：swin，其发送窗口的大小（可能由系统调整）和rwin，接收方宣布的接收窗口的大小。在任何时候，未确认段的数量不能超过
    \(\min(swin,rwin)\) [[4]](#facklost) 。动态窗口的使用在图[图65](#fig-transport-dynamic-win)中说明。
- en: '[![../_images/transport-dwin.svg](../Images/b265eb3f8dd59868de804ccf800a887f.png)](../_images/transport-dwin.svg)'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-dwin.svg](../Images/b265eb3f8dd59868de804ccf800a887f.png)(../_images/transport-dwin.svg)'
- en: Fig. 65 Dynamic receiving window[#](#id30 "Link to this image")
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 图65 动态接收窗口[#](#id30 "链接到这张图片")
- en: The receiver may adjust its advertised receive window based on its current memory
    consumption, but also to limit the bandwidth used by the sender. In practice,
    the receive buffer can also shrink as the application may not able to process
    the received data quickly enough. In this case, the receive buffer may be completely
    full and the advertised receive window may shrink to 0. When the sender receives
    an acknowledgment with a receive window set to 0, it is blocked until it receives
    an acknowledgment with a positive receive window. Unfortunately, as shown in [Fig.
    66](#fig-win-deadlock), the loss of this acknowledgment could cause a deadlock
    as the sender waits for an acknowledgment while the receiver is waiting for a
    data segment.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者可能会根据其当前的内存消耗调整其广告接收窗口，但也可以限制发送者使用的带宽。在实践中，接收缓冲区也可能缩小，因为应用程序可能无法快速处理接收到的数据。在这种情况下，接收缓冲区可能会完全填满，广告接收窗口可能会缩小到
    0。当发送者收到一个接收窗口设置为 0 的确认时，它会阻塞，直到它收到一个接收窗口为正的确认。不幸的是，如图 66 所示，这个确认的丢失可能导致死锁，因为发送者在等待确认的同时，接收者在等待数据段。
- en: '[![../_images/transport-win-deadlock.png](../Images/66586c6dcc13b89a7b00c779de739ebc.png)](../_images/transport-win-deadlock.png)'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-win-deadlock.png](../Images/66586c6dcc13b89a7b00c779de739ebc.png)'
- en: Fig. 66 Risk of deadlock with dynamic windows[#](#id31 "Link to this image")
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 图 66 动态窗口的死锁风险[#](#id31 "链接到这张图片")
- en: 'To solve this problem, transport protocols rely on a special timer : the persistence
    timer. This timer is started by the sender whenever it receives an acknowledgment
    advertising a receive window set to 0. When the timer expires, the sender retransmits
    an old segment in order to force the receiver to send a new acknowledgment, and
    hence send the current receive window size.'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，传输协议依赖于一个特殊的计时器：持久计时器。这个计时器由发送者在收到一个广告接收窗口设置为 0 的确认时启动。当计时器到期时，发送者重新传输一个旧的段，以迫使接收者发送一个新的确认，从而发送当前的接收窗口大小。
- en: To conclude our description of the basic mechanisms found in transport protocols,
    we still need to discuss the impact of segments arriving in the wrong order. If
    two consecutive segments are reordered, the receiver relies on their sequence
    numbers to reorder them in its receive buffer. Unfortunately, as transport protocols
    reuse the same sequence number for different segments, if a segment is delayed
    for a prolonged period of time, it might still be accepted by the receiver. This
    is illustrated in [Fig. 67](#fig-transport-ambiguity) where segment D(1,b) is
    delayed.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对传输协议中找到的基本机制的描述，我们还需要讨论段到达顺序错误的影响。如果两个连续的段被重新排序，接收者会根据它们的序列号在接收缓冲区中重新排序它们。不幸的是，由于传输协议为不同的段重复使用相同的序列号，如果一个段延迟了很长时间，它仍然可能被接收者接受。这如图
    67 所示，其中段 D(1,b) 被延迟。
- en: '[![../_images/transport-ambiguities.png](../Images/47226dd629dc43186633321c93f4871f.png)](../_images/transport-ambiguities.png)'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/transport-ambiguities.png](../Images/47226dd629dc43186633321c93f4871f.png)'
- en: Fig. 67 Ambiguities caused by excessive delays[#](#id32 "Link to this image")
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 图 67 过度延迟引起的歧义[#](#id32 "链接到这张图片")
- en: To deal with this problem, transport protocols combine two solutions. First,
    they use 32 bits or more to encode the sequence number in the segment header.
    This increases the overhead, but also increases the delay between the transmission
    of two different segments having the same sequence number. Second, transport protocols
    require the network layer to enforce a Maximum Segment Lifetime (MSL). The network
    layer must ensure that no packet remains in the network for more than MSL seconds.
    In the Internet the MSL is assumed [[5]](#fmsl) to be 2 minutes [**RFC 793**](https://datatracker.ietf.org/doc/html/rfc793.html).
    Note that this limits the maximum bandwidth of a transport protocol. If it uses
    n bits to encode its sequence numbers, then it cannot send more than \(2^n\) segments
    every MSL seconds.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，传输协议结合了两种解决方案。首先，它们使用 32 位或更多位来编码段头中的序列号。这增加了开销，但也增加了具有相同序列号的两个不同段之间的延迟。其次，传输协议要求网络层强制执行最大段生存时间（MSL）。网络层必须确保没有数据包在网络中超过
    MSL 秒。在互联网中，MSL 被假设 [[5]](#fmsl) 为 2 分钟 [**RFC 793**](https://datatracker.ietf.org/doc/html/rfc793.html)。请注意，这限制了传输协议的最大带宽。如果它使用
    n 位来编码其序列号，那么它不能在每 MSL 秒内发送超过 \(2^n\) 个段。
- en: Closing a transport connection[#](#closing-a-transport-connection "Link to this
    heading")
  id: totrans-1027
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭传输连接[#](#closing-a-transport-connection "链接到这个标题")
- en: 'When we discussed the connection-oriented service, we mentioned that there
    are two types of connection releases : abrupt release and graceful release.'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论面向连接的服务时，我们提到有两种类型的连接释放：突然释放和优雅释放。
- en: The first solution to release a transport connection is to define a new control
    segment (e.g. the DR segment for Disconnection Request) and consider the connection
    to be released once this segment has been sent or received. This is illustrated
    in [Fig. 68](#fig-abrupt-release).
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 释放传输连接的第一个解决方案是定义一个新的控制段（例如，用于断开请求的DR段），一旦发送或接收了该段，就认为连接已释放。这如图68所示。
- en: '[![../_images/transport-abrupt.png](../Images/2cbf4e00facf50e43973ab7e7a5671dd.png)](../_images/transport-abrupt.png)'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/2cbf4e00facf50e43973ab7e7a5671dd.png)'
- en: Fig. 68 Abrupt connection release[#](#id33 "Link to this image")
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 图68 突然连接释放[#](#id33 "链接到这张图片")
- en: As the entity that sends the DR segment cannot know whether the other entity
    has already sent all its data on the connection, SDUs can be lost during such
    an abrupt connection release.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送DR段的实体无法知道另一个实体是否已经在该连接上发送了所有数据，因此在这样的突然连接释放过程中可能会丢失SDU。
- en: The second method to release a transport connection is to release independently
    the two directions of data transfer. Once a user of the transport service has
    sent all its SDUs, it performs a DISCONNECT.req for its direction of data transfer.
    The transport entity sends a control segment to request the release of the connection
    *after* the delivery of all previous SDUs to the remote user. This is usually
    done by placing in the DR the next sequence number and by delivering the DISCONNECT.ind
    only after all previous DATA.ind. The remote entity confirms the reception of
    the DR segment and the release of the corresponding direction of data transfer
    by returning an acknowledgment. This is illustrated in [Fig. 69](#fig-graceful-release).
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 释放传输连接的第二种方法是独立释放数据传输的两个方向。一旦传输服务的用户发送了所有其SDU，它就为其数据传输方向执行DISCONNECT.req。传输实体发送一个控制段，请求在将所有之前的SDU交付给远程用户后释放连接。这通常通过在DR中放置下一个序列号，并且只在所有之前的DATA.ind交付后发送DISCONNECT.ind来实现。远程实体通过返回一个确认来确认接收了DR段和释放相应的数据传输方向。这如图69所示。
- en: '[![../_images/transport-graceful.png](../Images/2967c3a8822fc72dfc8c278f20b61f48.png)](../_images/transport-graceful.png)'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/2967c3a8822fc72dfc8c278f20b61f48.png)'
- en: Fig. 69 Graceful connection release[#](#id34 "Link to this image")
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 图69 优雅连接释放[#](#id34 "链接到这张图片")
- en: Footnotes
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
