- en: Multipurpose Text Processing Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多用途文本处理工具
- en: 原文：[https://learnbyexample.github.io/cli-computing/multipurpose-text-processing-tools.html](https://learnbyexample.github.io/cli-computing/multipurpose-text-processing-tools.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://learnbyexample.github.io/cli-computing/multipurpose-text-processing-tools.html](https://learnbyexample.github.io/cli-computing/multipurpose-text-processing-tools.html)
- en: Many CLI text processing tools have been in existence for about half a century.
    And newer tools are being written to solve the ever expanding text processing
    problems. Just knowing that a particular tool exists or searching for a tool before
    attempting to write your own solution can be a time saver. Also, popular tools
    are likely to be optimized for speed, hardened against bugs due to wide usage,
    discussed on forums, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行界面（CLI）文本处理工具已经存在了大约半个世纪。而且，为了解决不断扩大的文本处理问题，新的工具正在被编写。仅仅知道某个工具的存在，或者在尝试编写自己的解决方案之前搜索工具，就可以节省时间。此外，流行的工具可能已经针对速度进行了优化，由于广泛使用而增强了抗错误能力，在论坛上进行了讨论，等等。
- en: '`grep` was already covered in the [Searching Files and Filenames](./searching-files-and-filenames.html)
    chapter. In addition, `sed`, `awk` and `perl` are essential tools to solve a wide
    variety of text processing problems from the command line. In this chapter you''ll
    learn field processing, use regular expressions for search and replace requirements,
    perform operations based on multiple lines and files, etc.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`已经在[搜索文件和文件名](./searching-files-and-filenames.html)章节中介绍过了。此外，`sed`、`awk`和`perl`是解决从命令行处理各种文本问题的基本工具。在本章中，你将学习字段处理，使用正则表达式进行搜索和替换，根据多行和文件执行操作等。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The examples presented
    in this chapter only cover some of the functionalities. I''ve written separate
    books to cover these tools with more detailed explanations, examples and exercises.
    See [https://learnbyexample.github.io/books/](https://learnbyexample.github.io/books/)
    for links to these books.'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 本章中提供的示例仅涵盖了一些功能。我已经编写了单独的书籍，以更详细地解释这些工具，包括示例和练习。有关这些书籍的链接，请参阅[https://learnbyexample.github.io/books/](https://learnbyexample.github.io/books/)。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The [example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)
    directory has the sample input files used in this chapter.'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 本章中使用的示例输入文件位于[example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)目录中。'
- en: '[sed](#sed)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[sed](#sed)'
- en: The command name `sed` is derived from **s**tream **ed**itor. Here, stream refers
    to the data being passed via shell pipes. Thus, the command's primary functionality
    is to act as a text editor for **stdin** data with **stdout** as the output target.
    You can also edit file input and save the changes back to the same file if needed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 命令名`sed`来源于**s**tream **ed**itor。在这里，stream指的是通过shell管道传递的数据。因此，该命令的主要功能是作为**stdin**数据的文本编辑器，其输出目标为**stdout**。如果需要，你也可以编辑文件输入并将更改保存回同一文件。
- en: '[Substitution](#substitution)'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[替换](#substitution)'
- en: '`sed` has various commands to manipulate text input. The **substitute** command
    is the most commonly used, whose syntax is `s/REGEXP/REPLACEMENT/FLAGS`. Here
    are some basic examples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`有各种命令来操作文本输入。其中**替换**命令是最常用的，其语法为`s/REGEXP/REPLACEMENT/FLAGS`。以下是一些基本示例：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s an example with file input:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用文件输入的示例：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What if you want to issue multiple substitute commands (or use several other
    `sed` commands)? It will depend on the command being used. Here's an example where
    you can use the `-e` option or separate the commands with a `;` character.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想发出多个替换命令（或使用几个其他`sed`命令），这取决于所使用的命令。以下是一个示例，你可以使用`-e`选项或使用`;`字符分隔命令。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Inplace editing](#inplace-editing)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[原地编辑](#inplace-editing)'
- en: You can use the `-i` option for inplace editing. Pass an argument to this option
    to save the original input as a backup.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-i`选项进行原地编辑。向此选项传递一个参数以将原始输入保存为备份。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Filtering features](#filtering-features)'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[过滤功能](#filtering-features)'
- en: The `sed` command also has features to filter lines based on a search pattern
    like `grep`. And you can apply other `sed` commands for these filtered lines as
    needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令还具有基于搜索模式（如`grep`）过滤行的功能。并且可以根据需要对这些过滤行应用其他`sed`命令。'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can use the `q` and `Q` commands to quit `sed` once a matching line is
    found:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`q`和`Q`命令在找到匹配行后退出`sed`：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Apart from regexp, filtering can also be done based on line numbers, address
    ranges, etc.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正则表达式之外，还可以根据行号、地址范围等进行过滤。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you need to issue multiple commands for filtered lines, you can group those
    commands within `{}` characters. Here''s an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要对过滤行执行多个命令，可以将这些命令组合在 `{}` 字符内。以下是一个示例：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Regexp substitution](#regexp-substitution)'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[正则表达式替换](#regexp-substitution)'
- en: Here are some regexp based substitution examples. The `-E` option enables **ERE**
    (default is **BRE**). Most of the syntax discussed in the [Regular Expressions](./searching-files-and-filenames.html#regular-expressions)
    section for the `grep` command applies for `sed` as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基于正则表达式的替换示例。`-E` 选项启用 **ERE**（默认是 **BRE**）。在 `grep` 命令的 [正则表达式](./searching-files-and-filenames.html#regular-expressions)
    部分中讨论的大多数语法也适用于 `sed`。
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `/` character is idiomatically used as the regexp delimiter. But any character
    other than `\` and the newline character can be used instead. This helps to avoid
    or reduce the need for escaping delimiter characters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 字符通常用作正则表达式的分隔符。但除了反斜杠和换行符之外，任何其他字符都可以用作替代。这有助于避免或减少对分隔符字符进行转义的需求。'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Further Reading](#further-reading)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading)'
- en: My ebook [CLI text processing with GNU sed](https://github.com/learnbyexample/learn_gnused)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的电子书 [使用 GNU sed 进行 CLI 文本处理](https://github.com/learnbyexample/learn_gnused)
- en: See also my blog post [GNU BRE/ERE cheatsheet](https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见我的博客文章 [GNU BRE/ERE 技巧表](https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/)
- en: '[unix.stackexchange: common search and replace examples with sed and other
    tools](https://unix.stackexchange.com/q/112023/109046)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[unix.stackexchange: 使用 sed 和其他工具的常见搜索和替换示例](https://unix.stackexchange.com/q/112023/109046)'
- en: '[awk](#awk)'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[awk](#awk)'
- en: '`awk` is a programming language and widely used for text processing tasks from
    the command line. `awk` provides filtering capabilities like those supported by
    the `grep` and `sed` commands, along with some more nifty features. And similar
    to many command line utilities, `awk` can accept input from both `stdin` and files.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 是一种编程语言，广泛用于从命令行执行文本处理任务。`awk` 提供了与 `grep` 和 `sed` 命令支持的过滤功能类似的功能，以及一些更实用的特性。类似于许多命令行实用程序，`awk`
    可以从 `stdin` 和文件接受输入。'
- en: '[Regexp filtering](#regexp-filtering)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[正则表达式过滤](#regexp-filtering)'
- en: 'To make it easier to use programming features from the command line, there
    are several shortcuts, for example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于从命令行使用编程功能，有一些快捷方式，例如：
- en: '`awk ''/regexp/''` is a shortcut for `awk ''$0 ~ /regexp/{print $0}''`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awk ''/regexp/''` 是 `awk ''$0 ~ /regexp/{print $0}''` 的快捷方式'
- en: '`awk ''!/regexp/''` is a shortcut for `awk ''$0 !~ /regexp/{print $0}''`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awk ''!/regexp/''` 是 `awk ''$0 !~ /regexp/{print $0}''` 的快捷方式'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Awk special variables](#awk-special-variables)'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Awk 特殊变量](#awk-special-variables)'
- en: 'Brief description for some of the special variables are given below:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面简要描述了一些特殊变量的用法：
- en: '`$0` contains the input record content'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0` 包含输入记录内容'
- en: '`$1` first field'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1` 第一字段'
- en: '`$2` second field and so on'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2` 第二字段以及后续字段'
- en: '`FS` input field separator'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FS` 输入字段分隔符'
- en: '`OFS` output field separator'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFS` 输出字段分隔符'
- en: '`NF` number of fields'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NF` 字段数'
- en: '`RS` input record separator'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RS` 输入记录分隔符'
- en: '`ORS` output record separator'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORS` 输出记录分隔符'
- en: '`NR` number of records (i.e. line number) for entire input'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NR` 整个输入的记录数（即行号）'
- en: '`FNR` number of records per file'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FNR` 每个文件中的记录数'
- en: '[Default field processing](#default-field-processing)'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[默认字段处理](#default-field-processing)'
- en: '`awk` automatically splits input into fields based on one or more sequence
    of **space** or **tab** or **newline** characters. In addition, any of these three
    characters at the start or end of input gets trimmed and won''t be part of field
    contents. The fields are accessible using `$N` where `N` is the field number you
    need. You can also pass an expression instead of numeric literals to specify the
    field required.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 会自动根据一个或多个由空格、制表符或换行符组成的序列将输入拆分为字段。此外，输入开头或结尾的任何这三个字符都会被修剪，不会成为字段内容的一部分。字段可以通过
    `$N` 访问，其中 `N` 是您需要的字段编号。您也可以传递一个表达式而不是数字字面量来指定所需的字段。'
- en: 'Here are some examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here's an example of applying a substitution operation for a particular field.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个应用特定字段替换操作的示例。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Condition and Action](#condition-and-action)'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[条件和动作](#condition-and-action)'
- en: 'The examples so far have used a few different ways to construct a typical `awk`
    one-liner. If you haven''t yet grasped the syntax, this generic structure might
    help:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的示例使用了构建典型 `awk` 单行脚本的一些不同方法。如果您还没有掌握语法，这个通用结构可能有所帮助：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If a condition isn't provided, the action is always executed. Within a block,
    you can provide multiple statements separated by a semicolon character. If action
    isn't provided, then by default, contents of `$0` variable is printed if the condition
    evaluates to *true*. Idiomatically, `1` is used to denote a `true` condition in
    one-liners as a shortcut to print the contents of `$0` (as seen in an earlier
    example). When action isn't present, you can use semicolon to terminate the condition
    and start another `condX{actionX}` snippet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供条件，则始终执行操作。在块内，你可以提供多个用分号字符分隔的语句。如果没有提供操作，则默认情况下，如果条件评估为 *true*，则打印 `$0`
    变量的内容。在单行中，通常使用 `1` 来表示 `true` 条件，作为打印 `$0` 内容的快捷方式（如前例所示）。如果没有操作，则可以使用分号来终止条件并开始另一个
    `condX{actionX}` 片段。
- en: You can use a `BEGIN{}` block when you need to execute something before the
    input is read and an `END{}` block to execute something after all of the input
    has been processed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要读取输入之前执行某些操作时，可以使用 `BEGIN{}` 块，而在所有输入处理完毕后执行某些操作时，可以使用 `END{}` 块。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Regexp field processing](#regexp-field-processing)'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[正则表达式字段处理](#regexp-field-processing)'
- en: As seen earlier, `awk` automatically splits input into fields (based on space/tab/newline
    characters) which are accessible using `$N` where `N` is the field number you
    need. You can use the `-F` option or assign the `FS` variable to set a regexp
    based input field separator. Use the `OFS` variable to set the output field separator.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`awk` 会自动根据空格、制表符或换行符将输入拆分为字段，这些字段可以通过 `$N` 访问，其中 `N` 是你需要字段编号。你可以使用 `-F`
    选项或分配 `FS` 变量来设置基于正则表达式的输入字段分隔符。使用 `OFS` 变量来设置输出字段分隔符。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `FS` variable allows you to define the input field *separator*. In contrast,
    `FPAT` (field pattern) allows you to define what should the fields be made up
    of.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FS` 变量允许你定义输入字段 *分隔符*。相比之下，`FPAT`（字段模式）允许你定义字段应由什么组成。'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Record separators](#record-separators)'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[记录分隔符](#record-separators)'
- en: By default, newline is used as the input and output record separators. You can
    change them using the `RS` and `ORS` variables.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，换行符用作输入和输出记录分隔符。你可以使用 `RS` 和 `ORS` 变量来更改它们。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[State machines](#state-machines)'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[状态机](#state-machines)'
- en: The `condX{actionX}` shortcut makes it easy to code state machines concisely.
    This is useful to solve problems that depend on the contents of multiple records.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`condX{actionX}` 简略语法使得编写状态机更加简洁。这对于解决依赖于多个记录内容的问题非常有用。'
- en: 'Here''s an example of printing the matching line as well as `c` number of lines
    that follow:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，打印匹配的行以及随后 `c` 行：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Consider the following input file that has records bounded by distinct markers
    (lines containing `start` and `end`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有不同标记（包含 `start` 和 `end` 的行）的输入文件：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here are some examples of processing such bounded records:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些处理此类有界记录的示例：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s an example of printing two consecutive records only if the first record
    contains `ar` and the second one contains `nice`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，仅当第一个记录包含 `ar` 且第二个记录包含 `nice` 时打印两个连续的记录：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Two files processing](#two-files-processing)'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[两个文件处理](#two-files-processing)'
- en: 'This section focuses on solving problems which depend upon the contents of
    two or more files. These are usually based on comparing records and fields. These
    two files will be used in the examples to follow:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍依赖于两个或多个文件内容的问题解决方法。这些通常基于比较记录和字段。以下示例将使用这两个文件：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *key* features used to find common lines between two files:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在两个文件之间查找公共行的 *关键* 功能：
- en: For two files as input, `NR==FNR` will be *true* only when the first file is
    being processed
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个文件作为输入，`NR==FNR` 仅在处理第一个文件时为 *true*
- en: '`FNR` is record number like `NR` but resets for each input file'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FNR` 是记录号，类似于 `NR`，但会为每个输入文件重置'
- en: '`next` will skip the rest of the code and fetch the next record'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next` 将跳过其余代码并获取下一个记录'
- en: '`a[$0]` by itself is a valid statement, creates an uninitialized element in
    array `a` with `$0` as the key (if the key doesn''t exist yet)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a[$0]` 本身是一个有效的语句，在数组 `a` 中创建一个以 `$0` 为键的未初始化元素（如果键尚不存在）'
- en: '`$0 in a` checks if the given string (`$0` here) exists as a key in the array
    `a`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0 in a` 检查给定的字符串（此处为 `$0`）是否作为键存在于数组 `a` 中'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png) Note that the `NR==FNR`
    logic will fail if the first file is empty. See [this unix.stackexchange thread](https://unix.stackexchange.com/a/237110/109046)
    for workarounds.'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png) 注意，如果第一个文件为空，则 `NR==FNR`
    逻辑将失败。有关解决方案，请参阅 [这个 unix.stackexchange 线程](https://unix.stackexchange.com/a/237110/109046)。'
- en: '[Removing duplicates](#removing-duplicates)'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[移除重复项](#removing-duplicates)'
- en: '`awk ''!a[$0]++''` is one of the most famous `awk` one-liners. It eliminates
    line based duplicates while retaining the input order. The following example shows
    this feature in action along with an illustration of how the logic works.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk ''!a[$0]++''` 是最著名的 `awk` 单行命令之一。它在保留输入顺序的同时消除基于行的重复项。以下示例展示了这一功能的使用，以及逻辑是如何工作的。'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Further Reading](#further-reading-1)'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading-1)'
- en: My ebook [CLI text processing with GNU awk](https://github.com/learnbyexample/learn_gnuawk)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的电子书 [使用 GNU awk 进行 CLI 文本处理](https://github.com/learnbyexample/learn_gnuawk)
- en: See also my blog post [GNU BRE/ERE cheatsheet](https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/)
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见我的博客文章 [GNU BRE/ERE 技巧表](https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/)
- en: '[Online gawk manual](https://www.gnu.org/software/gawk/manual/)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在线 gawk 手册](https://www.gnu.org/software/gawk/manual/)'
- en: My blog post [CLI computation with GNU datamash](https://learnbyexample.github.io/cli-computation-gnu-datamash/)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的博客文章 [使用 GNU datamash 进行 CLI 计算](https://learnbyexample.github.io/cli-computation-gnu-datamash/)
- en: '[perl](#perl)'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[perl](#perl)'
- en: Perl is a scripting language with plenty of builtin features and a strong ecosystem.
    Perl one-liners can be used for text processing, similar to `grep`, `sed`, `awk`
    and more. And similar to many command line utilities, `perl` can accept input
    from both `stdin` and file arguments.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Perl 是一种具有众多内置功能和强大生态系统的脚本语言。Perl 单行命令可用于文本处理，类似于 `grep`、`sed`、`awk` 等。类似于许多命令行实用程序，`perl`
    可以从 `stdin` 和文件参数接受输入。
- en: '[Basic one-liners](#basic-one-liners)'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[基本单行命令](#basic-one-liners)'
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `-e` option accepts code as a command line argument. Many shortcuts are
    available to reduce the amount of typing needed. In the above examples, a regular
    expression has been used to filter the input. When the input string isn''t specified,
    the test is performed against the special variable `$_`, which has the contents
    of the current input line. `$_` is also the default argument for many functions
    like `print` and `length`. To summarize:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 选项接受代码作为命令行参数。有许多快捷方式可以减少输入的字符数。在上面的示例中，已使用正则表达式来过滤输入。当未指定输入字符串时，测试是对特殊变量
    `$_` 执行的，它包含当前输入行的内容。`$_` 也是许多函数（如 `print` 和 `length`）的默认参数。为了总结：'
- en: '`/REGEXP/FLAGS` is a shortcut for `$_ =~ m/REGEXP/FLAGS`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/REGEXP/FLAGS` 是 `$_ =~ m/REGEXP/FLAGS` 的快捷方式'
- en: '`!/REGEXP/FLAGS` is a shortcut for `$_ !~ m/REGEXP/FLAGS`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!/REGEXP/FLAGS` 是 `$_ !~ m/REGEXP/FLAGS` 的快捷方式'
- en: In the examples below, the `-p` option is used instead of `-n`. This helps to
    automatically print the value of `$_` after processing each input line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用 `-p` 选项代替 `-n`。这有助于在处理每行输入后自动打印 `$_` 的值。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Similar to `sed`, you
    can use the `-i` option for inplace editing.'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 与 `sed` 类似，你可以使用 `-i`
    选项进行原地编辑。'
- en: '[Perl special variables](#perl-special-variables)'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Perl 特殊变量](#perl-special-variables)'
- en: 'Brief description for some of the special variables are given below:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简要描述了一些特殊变量的用途：
- en: '`$_` contains the input record content'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$_` 包含输入记录内容'
- en: '`@F` array containing the field contents (with the `-a` and `-F` options)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@F` 包含字段内容的数组（使用 `-a` 和 `-F` 选项）'
- en: '`$F[0]` first field'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$F[0]` 第一个字段'
- en: '`$F[1]` second field and so on'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$F[1]` 第二字段等等'
- en: '`$F[-1]` last field'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$F[-1]` 最后一个字段'
- en: '`$F[-2]` second last field and so on'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$F[-2]` 第二个最后一个字段等等'
- en: '`$#F` index of the last field'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$#F` 最后一个字段的索引'
- en: '`$.` number of records (i.e. line number)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$.` 记录数（即行号）'
- en: '`$1` backreference to the first capture group'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1` 对第一个捕获组的反向引用'
- en: '`$2` backreference to the second capture group and so on'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2` 对第二个捕获组的反向引用等等'
- en: '`$&` backreference to the entire matched portion'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$&` 对整个匹配部分的反向引用'
- en: You'll see examples using such variables in the sections to follow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在接下来的部分中看到使用此类变量的示例。
- en: '[Auto split](#auto-split)'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[自动拆分](#auto-split)'
- en: Here are some examples based on specific fields rather than the entire line.
    The `-a` option will cause the input line to be split based on whitespaces and
    the field contents can be accessed using the `@F` special array variable. Leading
    and trailing whitespaces will be suppressed, so there's no possibility of empty
    fields.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基于特定字段而不是整行的示例。`-a` 选项将导致输入行根据空白字符分割，字段内容可以使用特殊数组变量 `@F` 访问。将抑制前导和尾随空白字符，因此不可能有空字段。
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you use an array within double quotes (like `"@F"` in the example above),
    the fields will be printed with a space character in between. The `join` function
    is one of the ways to print the contents of an array with a custom field separator.
    Here''s an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在双引号内使用数组（如上面示例中的 `"@F"`），字段之间将用空格字符打印。`join` 函数是打印数组内容并使用自定义字段分隔符的一种方法。以下是一个示例：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) In the above examples,
    the `-l` option has been used to remove the record separator (which is newline
    by default) from the input line. The record separator thus removed is added back
    when the `print` function is used.'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 在上述示例中，使用了 `-l` 选项来从输入行中移除记录分隔符（默认为换行符）。当使用
    `print` 函数时，移除的记录分隔符将被添加回。'
- en: '[Regexp field separator](#regexp-field-separator)'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[正则表达式字段分隔符](#regexp-field-separator)'
- en: You can use the `-F` option to specify a regexp pattern for input field separation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-F` 选项指定用于输入字段分隔的正则表达式模式。
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Powerful features](#powerful-features)'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[强大功能](#powerful-features)'
- en: I reach for Perl over `grep`, `sed` and `awk` when I need powerful regexp features
    and make use of the vast builtin functions and libraries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我需要强大的正则表达式功能并使用大量的内置函数和库时，我选择使用 Perl 而不是 `grep`、`sed` 和 `awk`。
- en: 'Here are some examples showing regexp features not present in BRE/ERE:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例展示了 BRE/ERE 中没有的正则表达式功能：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here are some examples showing off builtin features:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些展示内置功能的示例：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Further Reading](#further-reading-2)'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[进一步阅读](#further-reading-2)'
- en: '[perldoc: Perl introduction](https://perldoc.perl.org/perlintro)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[perldoc: Perl 简介](https://perldoc.perl.org/perlintro)'
- en: '[perldoc: Regexp tutorial](https://perldoc.perl.org/perlretut)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[perldoc: 正则表达式教程](https://perldoc.perl.org/perlretut)'
- en: My ebook [Perl One-Liners Guide](https://github.com/learnbyexample/learn_perl_oneliners)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的电子书 [Perl One-Liners Guide](https://github.com/learnbyexample/learn_perl_oneliners)
- en: '[Exercises](#exercises)'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Use the [example_files/text_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files/text_files)
    directory for input files used in the following exercises.'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 使用 [example_files/text_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files/text_files)
    目录中的输入文件进行以下练习。'
- en: '**1)** Replace all occurrences of `0xA0` with `0x50` and `0xFF` with `0x7F`
    for the given input.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**1)** 对于给定的输入，将所有出现的 `0xA0` 替换为 `0x50`，将 `0xFF` 替换为 `0x7F`。'
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**2)** Remove only the third line from the given input.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**2)** 仅从给定输入中删除第三行。'
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**3)** For the input file `sample.txt`, display all lines that contain `it`
    but not `do`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**3)** 对于输入文件 `sample.txt`，显示包含 `it` 但不包含 `do` 的所有行。'
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**4)** For the input file `purchases.txt`, delete all lines containing `tea`.
    Also, replace all occurrences of `coffee` with `milk`. Write back the changes
    to the input file itself. The original contents should get saved to `purchases.txt.orig`.
    Afterwards, restore the contents from this backup file.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**4)** 对于输入文件 `purchases.txt`，删除包含 `tea` 的所有行。也将所有出现的 `coffee` 替换为 `milk`。将更改写回输入文件本身。原始内容应保存到
    `purchases.txt.orig`。之后，从该备份文件恢复内容。'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**5)** For the input file `sample.txt`, display all lines from the start of
    the file till the first occurrence of `are`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**5)** 对于输入文件 `sample.txt`，显示从文件开始到首次出现 `are` 的所有行。'
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**6)** Delete all groups of lines from a line containing `start` to a line
    containing `end` for the `uniform.txt` input file.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**6)** 删除从包含 `start` 的行到包含 `end` 的行之间的所有行组，对于 `uniform.txt` 输入文件。'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**7)** Replace all occurrences of `42` with `[42]` unless it is at the edge
    of a word.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**7)** 将所有出现的 `42` 替换为 `[42]`，除非它位于单词的边缘。'
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**8)** Replace all whole words with `X` that start and end with the same word
    character.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**8)** 将所有以相同单词字符开头和结尾的整个单词替换为 `X`。'
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**9)** For the input file `anchors.txt`, convert markdown anchors to hyperlinks
    as shown below.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**9)** 对于输入文件 `anchors.txt`，将 markdown 锚点转换为如下所示的超链接。'
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**10)** Replace all occurrences of `e` with `3` except the first two matches.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**10)** 将所有出现的 `e` 替换为 `3`，除了前两个匹配项。'
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**11)** The below sample strings use `,` as the delimiter and the field values
    can be empty as well. Use `sed` to replace only the third field with `42`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**11)** 以下示例字符串使用`,`作为分隔符，字段值也可以为空。使用`sed`仅替换第三个字段为`42`。'
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**12)** For the input file `table.txt`, calculate and display the product of
    numbers in the last field of each line. Consider space as the field separator
    for this file.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**12)** 对于输入文件`table.txt`，计算并显示每行最后一个字段中数字的乘积。考虑空格作为此文件的字段分隔符。'
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**13)** Extract the contents between `()` or `)(` from each of the input lines.
    Assume that the `()` characters will be present only once every line.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**13)** 从每条输入行中提取`()`或`)(`之间的内容。假设每行中`()`字符只会出现一次。'
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**14)** For the input file `scores.csv`, display the `Name` and `Physics` fields
    in the format shown below.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**14)** 对于输入文件`scores.csv`，按照以下格式显示`Name`和`Physics`字段。'
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**15)** Extract and display the third and first words in the format shown below.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**15)** 按照以下格式提取并显示第三和第一个单词。'
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**16)** For the input file `scores.csv`, add another column named **GP** which
    is calculated out of 100 by giving 50% weightage to Maths and 25% each for Physics
    and Chemistry.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**16)** 对于输入文件`scores.csv`，添加一个名为**GP**的列，该列通过将50%的权重分配给数学，物理和化学各25%来计算。'
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**17)** From the `para.txt` input file, display all paragraphs containing any
    digit character.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**17)** 从`para.txt`输入文件中，显示包含任何数字字符的所有段落。'
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**18)** Input has the ASCII NUL character as the record separator. Change it
    to dot and newline characters as shown below.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**18)** 输入具有ASCII NUL字符作为记录分隔符。将其更改为点和新行字符，如下所示。'
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**19)** For the input file `sample.txt`, print a matching line containing `do`
    only if `you` is found two lines before. For example, if `do` is found on line
    number 10 and the 8th line contains `you`, then the 10th line should be printed.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**19)** 对于输入文件`sample.txt`，如果在前两行中找到`you`，则打印包含`do`的匹配行。例如，如果`do`在第10行找到，而第8行包含`you`，则第10行应被打印。'
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**20)** For the input file `blocks.txt`, extract contents from a line containing
    exactly `%=%=` until but not including the next such line. The block to be extracted
    is indicated by the variable `n` passed via the `-v` option.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**20)** 对于输入文件`blocks.txt`，从包含恰好`%=%=`的行中提取内容，直到但不包括下一个这样的行。要提取的块由通过`-v`选项传递的变量`n`指示。'
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**21)** Display lines present in `c1.txt` but not in `c2.txt` using the `awk`
    command.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**21)** 使用`awk`命令显示`c1.txt`中存在但不在`c2.txt`中的行。'
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**22)** Display lines from `scores.csv` by matching the first field based on
    a list of names from the `names.txt` file.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**22)** 通过匹配`names.txt`文件中的名称列表来显示`scores.csv`中的行。'
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**23)** Retain only the first copy of duplicate lines from the `duplicates.txt`
    input file. Use only the contents of the last field for determining duplicates.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**23)** 仅保留`duplicates.txt`输入文件中的第一个重复行副本。仅使用最后一个字段的内容来确定重复项。'
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**24)** For the input file `table.txt`, print input lines if the second field
    starts with `b`. Construct solutions using `awk` and `perl`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**24)** 对于输入文件`table.txt`，如果第二个字段以`b`开头，则打印输入行。使用`awk`和`perl`构建解决方案。'
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**25)** For the input file `table.txt`, retain only the second last field.
    Write back the changes to the input file itself. The original contents should
    get saved to `table.txt.bkp`. Afterwards, restore the contents from this backup
    file.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**25)** 对于输入文件`table.txt`，仅保留第二个最后字段。将更改写回输入文件本身。原始内容应保存到`table.txt.bkp`。之后，从该备份文件恢复内容。'
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**26)** Reverse the first field contents of `table.txt` input file.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**26)** 反转`table.txt`输入文件的第一字段内容。'
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**27)** Sort the given comma separated input lexicographically. Change the
    output field separator to a `:` character.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**27)** 按字典顺序对给定的逗号分隔输入进行排序。将输出字段分隔符更改为冒号字符。'
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**28)** Filter fields containing digit characters.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**28)** 过滤包含数字字符的字段。'
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**29)** The input shown below has several words ending with digit characters.
    Change the words containing `test` to match the output shown below. That is, renumber
    the matching portions to `1`, `2`, etc. Words not containing `test` should not
    be changed.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**29)** 下面的输入中有几个以数字结尾的单词。将包含`test`的单词更改为与下面的输出匹配。也就是说，将匹配的部分重新编号为`1`、`2`等。不包含`test`的单词不应更改。'
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**30)** For the input file `table.txt`, change contents of the third field
    to all uppercase. Construct solutions using `sed`, `awk` and `perl`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**30)** 对于输入文件`table.txt`，将第三个字段的内容更改为全部大写。使用`sed`、`awk`和`perl`构建解决方案。'
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
