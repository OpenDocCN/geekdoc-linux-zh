- en: Structs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: This section documents internal structs. Since they are truly internal, we change
    them occasionally which might make this section slightly out of date at times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节记录了内部结构体。由于它们确实是内部的，我们偶尔会更改它们，这可能会使本节在某些时候略显过时。
- en: Curl_easy
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Curl_easy
- en: The `Curl_easy` struct is the one returned to the outside in the external API
    as an opaque `CURL *`. This pointer is usually known as an easy handle in API
    documentations and examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`Curl_easy` 结构体是在外部API中以不透明的 `CURL *` 形式返回的。这个指针通常在API文档和示例中被称为简单句柄。'
- en: Information and state that is related to the actual connection is in the `connectdata`
    struct. When a transfer is about to be made, libcurl either creates a new connection
    or re-uses an existing one. The current connectdata that is used by this handle
    is pointed out by `Curl_easy->conn`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与实际连接相关的信息和状态在 `connectdata` 结构体中。当即将进行传输时，libcurl要么创建一个新的连接，要么重用现有的一个。当前由这个句柄使用的当前连接数据由
    `Curl_easy->conn` 指出。
- en: Data and information that regard this particular single transfer is put in the
    `SingleRequest` sub-struct.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个特定单次传输相关的数据和信息被放入 `SingleRequest` 子结构体中。
- en: When the `Curl_easy` struct is added to a multi handle, as it must be in order
    to do any transfer, the `->multi` member points to the `Curl_multi` struct it
    belongs to. The `->prev` and `->next` members are then used by the multi code
    to keep a linked list of `Curl_easy` structs that are added to that same multi
    handle. libcurl always uses multi so `->multi` points to a `Curl_multi` when a
    transfer is in progress.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Curl_easy` 结构体被添加到多句柄中，为了执行任何传输，它必须这样做，`->multi` 成员指向它所属的 `Curl_multi` 结构体。`->prev`
    和 `->next` 成员随后被多代码用来保持添加到同一多句柄的 `Curl_easy` 结构体的链表。libcurl始终使用多句柄，因此在传输进行时 `->multi`
    指向一个 `Curl_multi`。
- en: '`->mstate` is the multi state of this particular `Curl_easy`. When `multi_runsingle()`
    is called, it acts on this handle according to which state it is in. The mstate
    is also what tells which sockets to return for a specific `Curl_easy` when [`curl_multi_fdset()`][12]
    is called etc.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`->mstate` 是这个特定 `Curl_easy` 的多状态。当调用 `multi_runsingle()` 时，它根据当前状态对此句柄进行操作。mstate
    还告诉在调用 `[curl_multi_fdset()](12)` 等时，为特定的 `Curl_easy` 返回哪些套接字。'
- en: The libcurl source code generally use the name `data` everywhere for the local
    variable that points to the `Curl_easy` struct.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl源代码通常使用 `data` 这个名字来命名指向 `Curl_easy` 结构体的局部变量。
- en: When doing multiplexed HTTP/2 transfers, each `Curl_easy` is associated with
    an individual stream, sharing the same connectdata struct. Multiplexing makes
    it even more important to keep things associated with the right thing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行多路复用的HTTP/2传输时，每个 `Curl_easy` 都与一个单独的流相关联，共享相同的连接数据结构。多路复用使得保持与正确事物关联变得更加重要。
- en: connectdata
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: connectdata
- en: A general idea in libcurl is to keep connections around in a connection cache
    after they have been used in case they are used again and then re-use an existing
    one instead of creating a new one as it creates a significant performance boost.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在libcurl中，一个普遍的想法是在连接使用后将其保留在连接缓存中，以防再次使用，然后重用现有的连接而不是创建一个新的，因为这可以显著提高性能。
- en: Each `connectdata` struct identifies a single physical connection to a server.
    If the connection cannot be kept alive, the connection is closed after use and
    then this struct can be removed from the cache and freed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `connectdata` 结构体标识了对服务器的单个物理连接。如果连接不能保持活动状态，则在使用后关闭连接，然后可以从缓存中删除此结构体并释放它。
- en: Thus, the same `Curl_easy` can be used multiple times and each time select another
    `connectdata` struct to use for the connection. Keep this in mind, as it is then
    important to consider if options or choices are based on the connection or the
    `Curl_easy`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，同一个 `Curl_easy` 可以被多次使用，每次可以选择另一个 `connectdata` 结构体来用于连接。请记住这一点，因为这很重要，需要考虑选项或选择是基于连接还是
    `Curl_easy`。
- en: As a special complexity, some protocols supported by libcurl require a special
    disconnect procedure that is more than just shutting down the socket. It can involve
    sending one or more commands to the server before doing so. Since connections
    are kept in the connection cache after use, the original `Curl_easy` may no longer
    be around when the time comes to shut down a particular connection. For this purpose,
    libcurl holds a special dummy `closure_handle` `Curl_easy` in the `Curl_multi`
    struct to use when needed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种特殊的复杂性，libcurl支持的一些协议需要一种特殊的断开连接程序，这不仅仅是关闭套接字。这可能涉及到在这样做之前向服务器发送一个或多个命令。由于连接在使用后被保留在连接缓存中，因此在关闭特定连接的时候，原始的`Curl_easy`可能已经不再存在。为此，libcurl在`Curl_multi`结构中保留了一个特殊的虚拟`closure_handle`
    `Curl_easy`，以便在需要时使用。
- en: FTP uses two TCP connections for a typical transfer but it keeps both in this
    single struct and thus can be considered a single connection for most internal
    concerns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: FTP使用两个TCP连接进行典型传输，但它将这两个连接都保留在这个单个结构中，因此可以被认为是大多数内部关注的一个单一连接。
- en: The libcurl source code generally uses the name `conn` for the local variable
    that points to the connectdata.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl的源代码通常使用`conn`这个名字来表示指向connectdata的局部变量。
- en: Curl_multi
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Curl_multi
- en: Internally, the easy interface is implemented as a wrapper around multi interface
    functions. This makes everything multi interface.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，easy接口被实现为多接口函数的包装器。这使得一切都是多接口。
- en: '`Curl_multi` is the multi handle struct exposed as the opaque `CURLM *` in
    external APIs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Curl_multi`是多句柄结构，在外部API中以不透明的`CURLM *`暴露。'
- en: This struct holds a list of `Curl_easy` structs that have been added to this
    handle with [`curl_multi_add_handle()`][13]. The start of the list is `->easyp`
    and `->num_easy` is a counter of added `Curl_easy`s.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包含了一个`Curl_easy`结构体的列表，这些结构体是通过`curl_multi_add_handle()`[13]添加到这个句柄的。列表的起始点是`->easyp`，而`->num_easy`是添加的`Curl_easy`的计数器。
- en: '`->msglist` is a linked list of messages to send back when [`curl_multi_info_read()`][14]
    is called. Basically a node is added to that list when an individual `Curl_easy`’s
    transfer has completed.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`->msglist`是一个消息链表，当调用`curl_multi_info_read()`[14]时用来发送回消息。基本上，当单个`Curl_easy`的传输完成时，就会向该列表添加一个节点。'
- en: '`->hostcache` points to the name cache. It is a hash table for looking up name
    to IP. The nodes have a limited lifetime in there and this cache is meant to reduce
    the time for when the same name is wanted within a short period of time.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`->hostcache`指向名称缓存。这是一个用于查找名称到IP的散列表。节点在那里有有限的生存期，这个缓存旨在减少在短时间内需要相同名称的时间。'
- en: '`->timetree` points to a tree of `Curl_easy`s, sorted by the remaining time
    until it should be checked - normally some sort of timeout. Each `Curl_easy` has
    one node in the tree.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`->timetree`指向一个`Curl_easy`的树，按剩余时间直到应该检查排序——通常是某种超时。每个`Curl_easy`在树中有一个节点。'
- en: '`->sockhash` is a hash table to allow fast lookups of socket descriptor for
    which `Curl_easy` uses that descriptor. This is necessary for the `multi_socket`
    API.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`->sockhash`是一个散列表，允许快速查找`Curl_easy`使用的套接字描述符。这对于`multi_socket` API是必要的。'
- en: '`->conn_cache` points to the connection cache. It keeps track of all connections
    that are kept after use. The cache has a maximum size.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`->conn_cache`指向连接缓存。它跟踪所有在使用后被保留的连接。缓存有一个最大大小。'
- en: '`->closure_handle` is described in the `connectdata` section.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`->closure_handle`在`connectdata`部分有描述。'
- en: The libcurl source code generally uses the name `multi` for the variable that
    points to the `Curl_multi` struct.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl的源代码通常使用`multi`这个名字来表示指向`Curl_multi`结构的变量。
- en: Curl_handler
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Curl_handler
- en: Each unique protocol that is supported by libcurl needs to provide at least
    one `Curl_handler` struct. It defines what the protocol is called and what functions
    the main code should call to deal with protocol specific issues. In general, there
    is a source file named `[protocol].c` in which there is a `struct Curl_handler
    Curl_handler_[protocol]` declared. In `url.c` there is then the main array with
    all individual `Curl_handler` structs pointed to from a single array which is
    scanned through when a URL is given to libcurl to work with.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl支持的每个独特协议都需要提供一个至少包含一个`Curl_handler`结构的实现。它定义了协议的名称以及主代码应该调用哪些函数来处理特定协议的问题。通常，有一个名为`[protocol].c`的源文件，其中声明了一个`struct
    Curl_handler Curl_handler_[protocol]`结构。在`url.c`中，有一个主数组，其中包含所有指向单个数组的`Curl_handler`结构体，当给libcurl一个URL进行处理时，会扫描这个数组。
- en: The concrete function pointer prototypes can be found in `lib/urldata.h`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的函数指针原型可以在`lib/urldata.h`中找到。
- en: '`->scheme` is the URL scheme name, usually spelled out in uppercase. That is
    HTTP or FTP etc. SSL versions of the protocol need their own `Curl_handler` setup
    so HTTPS separate from HTTP.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->scheme` 是 URL 方案名称，通常用大写字母拼写。例如 HTTP 或 FTP 等。协议的 SSL 版本需要自己的 `Curl_handler`
    设置，因此 HTTPS 与 HTTP 分开。'
- en: '`->setup_connection` is called to allow the protocol code to allocate protocol
    specific data that then gets associated with that `Curl_easy` for the rest of
    this transfer. It gets freed again at the end of the transfer. It gets called
    before the `connectdata` for the transfer has been selected/created. Most protocols
    allocate its private `struct [PROTOCOL]` here and assign `Curl_easy->req.p.[protocol]`
    to it.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->setup_connection` 被调用以允许协议代码分配特定于协议的数据，这些数据随后与整个传输过程中的 `Curl_easy` 关联。在传输结束时再次释放。它在选择/创建传输的
    `connectdata` 之前被调用。大多数协议在这里分配其私有的 `struct [PROTOCOL]` 并将其分配给 `Curl_easy->req.p.[protocol]`。'
- en: '`->connect_it` allows a protocol to do some specific actions after the TCP
    connect is done, that can still be considered part of the connection phase. Some
    protocols alter the `connectdata->recv[]` and `connectdata->send[]` function pointers
    in this function.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->connect_it` 允许协议在 TCP 连接完成后执行一些特定操作，这些操作仍可被视为连接阶段的一部分。一些协议在此函数中更改 `connectdata->recv[]`
    和 `connectdata->send[]` 函数指针。'
- en: '`->connecting` is similarly a function that keeps getting called as long as
    the protocol considers itself still in the connecting phase.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->connecting` 是一个函数，只要协议认为它仍然处于连接阶段，就会不断被调用。'
- en: '`->do_it` is the function called to issue the transfer request. What we call
    the DO action internally. If the DO is not enough and things need to be kept getting
    done for the entire DO sequence to complete, `->doing` is then usually also provided.
    Each protocol that needs to do multiple commands or similar for do/doing needs
    to implement their own state machines (see SCP, SFTP, FTP). Some protocols (only
    FTP and only due to historical reasons) have a separate piece of the DO state
    called `DO_MORE`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->do_it` 是调用以发出传输请求的函数。我们内部称之为 DO 操作。如果 DO 不足以完成整个 DO 序列，则通常还提供 `->doing`。每个需要执行多个命令或类似操作的协议都需要实现自己的状态机（参见
    SCP、SFTP、FTP）。一些协议（只有 FTP，并且仅由于历史原因）有一个单独的 DO 状态部分，称为 `DO_MORE`。'
- en: '`->doing` keeps getting called while issuing the transfer request command(s)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->doing` 在发出传输请求命令时不断被调用'
- en: '`->done` gets called when the transfer is complete and DONE. That is after
    the main data has been transferred.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->done` 在传输完成并标记为完成时被调用。即在主要数据传输之后。'
- en: '`->do_more` gets called during the `DO_MORE` state. The FTP protocol uses this
    state when setting up the second connection.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->do_more` 在 `DO_MORE` 状态期间被调用。FTP 协议在设置第二个连接时使用此状态。'
- en: '`->proto_getsock`, `->doing_getsock`, `->domore_getsock`, `->perform_getsock`
    Functions that return socket information. Which socket(s) to wait for which I/O
    action(s) during the particular multi state.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->proto_getsock`、`->doing_getsock`、`->domore_getsock`、`->perform_getsock`
    函数返回套接字信息。在特定多状态期间等待哪个套接字进行哪些 I/O 操作。'
- en: '`->disconnect` is called immediately before the TCP connection is shutdown.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->disconnect` 在关闭 TCP 连接之前立即被调用。'
- en: '`->readwrite` gets called during transfer to allow the protocol to do extra
    reads/writes'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->readwrite` 在传输期间被调用，允许协议执行额外的读取/写入操作'
- en: '`->attach` attaches a transfer to the connection.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->attach` 将传输附加到连接上。'
- en: '`->defport` is the default report TCP or UDP port this protocol uses'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->defport` 是此协议使用的默认报告 TCP 或 UDP 端口'
- en: '`->protocol` is one or more bits in the `CURLPROTO_*` set. The SSL versions
    have their base protocol set and then the SSL variation. Like `HTTP|HTTPS`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->protocol` 是 `CURLPROTO_*` 集中的一个或多个位。SSL 版本具有基本协议集和 SSL 变体。例如 `HTTP|HTTPS`。'
- en: '`->flags` is a bitmask with additional information about the protocol that
    makes it get treated differently by the generic engine:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->flags` 是一个掩码，包含有关协议的附加信息，这使得通用引擎以不同的方式处理它：'
- en: '`PROTOPT_SSL` - makes it connect and negotiate SSL'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_SSL` - 使其连接并协商 SSL'
- en: '`PROTOPT_DUAL` - this protocol uses two connections'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_DUAL` - 此协议使用两个连接'
- en: '`PROTOPT_CLOSEACTION` - this protocol has actions to do before closing the
    connection. This flag is no longer used by code, yet still set for a bunch of
    protocol handlers.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_CLOSEACTION` - 此协议在关闭连接之前执行操作。此标志不再由代码使用，但仍被许多协议处理程序设置。'
- en: '`PROTOPT_DIRLOCK` - direction lock. The SSH protocols set this bit to limit
    which direction of socket actions that the main engine concerns itself with.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_DIRLOCK` - 方向锁。SSH 协议设置这个位以限制主引擎关注的套接字动作的方向。'
- en: '`PROTOPT_NONETWORK` - a protocol that does not use the network (read `file:`)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_NONETWORK` - 不使用网络的协议（读取 `file:`）'
- en: '`PROTOPT_NEEDSPWD` - this protocol needs a password and uses a default one
    unless one is provided'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_NEEDSPWD` - 这个协议需要一个密码，如果没有提供，则使用默认密码'
- en: '`PROTOPT_NOURLQUERY` - this protocol cannot handle a query part on the URL
    (?foo=bar)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTOPT_NOURLQUERY` - 这个协议无法处理 URL 上的查询部分（?foo=bar）'
- en: conncache
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: conncache
- en: Is a hash table with connections for later re-use. Each `Curl_easy` has a pointer
    to its connection cache. Each multi handle sets up a connection cache that all
    added `Curl_easy`s share by default.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有连接以供以后重用的哈希表。每个 `Curl_easy` 都有一个指向其连接缓存的指针。每个多处理句柄默认情况下都会设置一个连接缓存，所有添加的
    `Curl_easy`s 都会共享这个缓存。
- en: Curl_share
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Curl_share
- en: The libcurl share API allocates a `Curl_share` struct, exposed to the external
    API as `CURLSH *`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 共享 API 分配一个 `Curl_share` 结构，作为 `CURLSH *` 暴露给外部 API。
- en: The idea is that the struct can have a set of its own versions of caches and
    pools and then by providing this struct in the `CURLOPT_SHARE` option, those specific
    `Curl_easy`s use the caches/pools that this share handle holds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，这个结构可以有自己的缓存和池的版本集，然后通过在 `CURLOPT_SHARE` 选项中提供这个结构，那些特定的 `Curl_easy`s 就会使用这个共享句柄所持有的缓存/池。
- en: Then individual `Curl_easy` structs can be made to share specific things that
    they otherwise would not, such as cookies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以单独的 `Curl_easy` 结构被设置为共享特定的东西，否则它们不会共享，比如 cookies。
- en: The `Curl_share` struct can currently hold cookies, DNS cache and the SSL session
    cache.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Curl_share` 结构目前可以存储 cookies、DNS 缓存和 SSL 会话缓存。'
- en: CookieInfo
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CookieInfo
- en: This is the main cookie struct. It holds all known cookies and related information.
    Each `Curl_easy` has its own private `CookieInfo` even when they are added to
    a multi handle. They can be made to share cookies by using the share API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的 cookie 结构。它包含所有已知的 cookies 和相关信息。即使它们被添加到多处理句柄中，每个 `Curl_easy` 也有自己的私有
    `CookieInfo`。可以通过使用共享 API 使它们共享 cookies。
