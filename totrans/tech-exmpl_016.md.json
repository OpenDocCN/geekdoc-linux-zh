["```go\ntype ParkingSystem struct {\n\tissuedTickets map[string]ParkingTicket\n\tparkingFloor  []*ParkingFloor\n\tisFull        map[ParkingSpotType]bool\n\tentryGates    []Gate\n\texitGates     []Gate\n}\n\nfunc (this *ParkingSystem) addParkingSpot(parkingSpot ParkingSpot) {}\n\nfunc (this *ParkingSystem) bookParkingSpot(pSpotType ParkingSpotType) (ParkingSpot, error) {}\n\nfunc (this *ParkingSystem) issueTicket(pSpotType ParkingSpotType, vehicle Vehicle, entryGate Gate) (*ParkingTicket, error) {}\n\nfunc (this *ParkingSystem) exitVehicle(ticket *ParkingTicket, pGType PaymentGatewayType) {}\n```", "```go\ntype ParkingFloor struct {\n\tparkingSpots    map[ParkingSpotType]*ParkingSpotDLL\n\tparkingSpotsMap map[string]*ParkingSpotDLLNode\n\tisFull          map[ParkingSpotType]bool\n\tfloor           int\n}\n\nfunc (this *ParkingFloor) addParkingSpot(pSpot ParkingSpot) {}\n\nfunc (this *ParkingFloor) bookParkingSpot(pSpotType ParkingSpotType) (ParkingSpot, error) {}\n\nfunc (this *ParkingFloor) freeParkingSpot(pSpot ParkingSpot) {}\n```", "```go\ntype ParkingTicket struct {\n\tvehicle     Vehicle\n\tparkingSpot ParkingSpot\n\tstatus      ParkingTicketStatus\n\tentryTime   time.Time\n\texitTime    time.Time\n\tentryGate   Gate\n\texitGate    Gate\n\tprice       int\n\tpgType      PaymentGatewayType\n}\n\nfunc (this *ParkingTicket) exit(pgType PaymentGatewayType) {}\n```", "```go\ntype ParkingTicketStatus uint8\nconst (\n    active ParkingTicketStatus = iota\n    paid\n)\n```", "```go\ntype ParkingSpot interface {\n\tisFull() bool\n\tgetFloor() int\n\tgetLocation() string\n\tgetParkingSpotType() ParkingSpotType\n\tmarkFull()\n\tmarkFree()\n}\n```", "```go\ntype ParkingSpotType uint8\nconst (\n    carPT ParkingSpotType = iota\n    truckPT\n    motorcyclePT\n)\n```", "```go\ntype CarParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *CarParkingSpot) isFull() bool {}\n\nfunc (this *CarParkingSpot) getFloor() int {}\n\nfunc (this *CarParkingSpot) getLocation() string {}\n\nfunc (this *CarParkingSpot) getParkingSpotType() ParkingSpotType {}\n\nfunc (this *CarParkingSpot) markFull() {}\n\nfunc (this *CarParkingSpot) markFree() {}\n```", "```go\ntype TruckParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *TruckParkingSpot) isFull() bool {}\n\nfunc (this *TruckParkingSpot) getFloor() int {}\n\nfunc (this *TruckParkingSpot) getLocation() string {}\n\nfunc (this *TruckParkingSpot) getParkingSpotType() ParkingSpotType {}\n\nfunc (this *TruckParkingSpot) markFull() {}\n\nfunc (this *TruckParkingSpot) markFree() {}\n```", "```go\ntype MotorCycleParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *MotorCycleParkingSpot) isFull() bool {}\n\nfunc (this *MotorCycleParkingSpot) getFloor() int {}\n\nfunc (this *MotorCycleParkingSpot) getLocation() string {}\n\nfunc (this *MotorCycleParkingSpot) getParkingSpotType() ParkingSpotType {}\n\nfunc (this *MotorCycleParkingSpot) markFull() {}\n\nfunc (this *MotorCycleParkingSpot) markFree() {}\n```", "```go\ntype ParkingRateFactory struct {\n\tparkingRateMap map[VehicleType]ParkingRate\n}\n\nfunc (this *ParkingRateFactory) getParkingRateInstanceByVehicleType(vType VehicleType) ParkingRate {}\n\ntype ParkingRateBase struct {\n\tperHourCharges int\n}\n\ntype ParkingRate interface {\n\tamountToPay(int) int\n}\n\ntype CarParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *CarParkingRate) amountToPay(hours int) int {}\n\ntype TruckParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *TruckParkingRate) amountToPay(hours int) int {}\n\ntype MotorCycleParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *MotorCycleParkingRate) amountToPay(hours int) int {}\n```", "```go\ntype PaymentGatewayType uint8\n\nconst (\n\tcash PaymentGatewayType = iota\n\tcreditCard\n\tdebitCard\n)\n\ntype PaymentGatewayFactory struct {\n\tpaymentGatewayMap map[PaymentGatewayType]PaymentGateway\n}\n\nfunc (this *PaymentGatewayFactory) getPaymentGatewayInstanceByPGType(pgType PaymentGatewayType) PaymentGateway {}\n\ntype PaymentGateway interface {\n\tpay(int)\n}\n\ntype CashPaymentGateway struct {\n}\n\nfunc (this CashPaymentGateway) pay(price int) {}\n\ntype CreditCardPaymentGateway struct {\n}\n\nfunc (this CreditCardPaymentGateway) pay(price int) {}\n\ntype DebitCardPaymentGateway struct {\n}\n\nfunc (this DebitCardPaymentGateway) pay(price int) {}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype ParkingSystem struct {\n\tissuedTickets map[string]ParkingTicket\n\tparkingFloor  []*ParkingFloor\n\tisFull        map[ParkingSpotType]bool\n\tentryGates    []Gate\n\texitGates     []Gate\n}\n\nfunc (this *ParkingSystem) addParkingSpot(parkingSpot ParkingSpot) {\n\tthis.parkingFloor[parkingSpot.getFloor()-1].addParkingSpot(parkingSpot)\n}\n\nfunc (this *ParkingSystem) bookParkingSpot(pSpotType ParkingSpotType) (ParkingSpot, error) {\n\tfor _, pFloor := range this.parkingFloor {\n\t\tpSpot, err := pFloor.bookParkingSpot(pSpotType)\n\t\tif err == nil {\n\t\t\treturn pSpot, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"Cannot issue ticket. All %s parking spot type are full\\n\", pSpotType.toString())\n}\n\nfunc (this *ParkingSystem) issueTicket(pSpotType ParkingSpotType, vehicle Vehicle, entryGate Gate) (*ParkingTicket, error) {\n\tfmt.Printf(\"\\nGoing to issue ticket for vehicle number %s\\n\", vehicle.numberPlate)\n\tpSpot, err := this.bookParkingSpot(pSpotType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tticket := initParkingTicket(vehicle, pSpot, entryGate)\n\treturn ticket, nil\n}\n\nfunc (this *ParkingSystem) printStatus() {\n\tfmt.Println(\"\\nPrinting Status of Parking Spot\")\n\tfor _, pFloor := range this.parkingFloor {\n\t\tpFloor.printStatus()\n\t}\n}\n\nfunc (this *ParkingSystem) exitVehicle(ticket *ParkingTicket, pGType PaymentGatewayType) {\n\tthis.parkingFloor[ticket.parkingSpot.getFloor()-1].freeParkingSpot(ticket.parkingSpot)\n\tticket.exit(pGType)\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype ParkingFloor struct {\n\tparkingSpots    map[ParkingSpotType]*ParkingSpotDLL\n\tparkingSpotsMap map[string]*ParkingSpotDLLNode\n\tisFull          map[ParkingSpotType]bool\n\tfloor           int\n}\n\nfunc initParkingFloor(floor int) *ParkingFloor {\n\treturn &ParkingFloor{\n\t\tfloor:           floor,\n\t\tparkingSpots:    make(map[ParkingSpotType]*ParkingSpotDLL),\n\t\tparkingSpotsMap: make(map[string]*ParkingSpotDLLNode),\n\t\tisFull:          make(map[ParkingSpotType]bool),\n\t}\n}\n\nfunc (this *ParkingFloor) addParkingSpot(pSpot ParkingSpot) {\n\tdll, ok := this.parkingSpots[pSpot.getParkingSpotType()]\n\tif ok {\n\t\tnewNode := &ParkingSpotDLLNode{\n\t\t\tpSpot: pSpot,\n\t\t}\n\t\tdll.AddToFront(newNode)\n\t\tthis.parkingSpotsMap[pSpot.getLocation()] = newNode\n\t\treturn\n\t}\n\n\tdll = &ParkingSpotDLL{}\n\tthis.parkingSpots[pSpot.getParkingSpotType()] = dll\n\tnewNode := &ParkingSpotDLLNode{\n\t\tpSpot: pSpot,\n\t}\n\tthis.parkingSpots[pSpot.getParkingSpotType()].AddToFront(newNode)\n\tthis.parkingSpotsMap[pSpot.getLocation()] = newNode\n}\n\nfunc (this *ParkingFloor) bookParkingSpot(pSpotType ParkingSpotType) (ParkingSpot, error) {\n\tif this.isFull[pSpotType] {\n\t\treturn nil, fmt.Errorf(\"%s Parking Spot is full on %d floor\", pSpotType.toString(), this.floor)\n\t}\n\n\tnextPSpot := this.parkingSpots[pSpotType].Front()\n\tnextPSpot.pSpot.markFull()\n\tthis.parkingSpots[pSpotType].MoveNodeToEnd(nextPSpot)\n\tif this.parkingSpots[pSpotType].Front().pSpot.isFull() {\n\t\tthis.isFull[pSpotType] = true\n\t}\n\treturn nextPSpot.pSpot, nil\n}\n\nfunc (this *ParkingFloor) printStatus() {\n\tfor pSpotType, dll := range this.parkingSpots {\n\t\tfmt.Printf(\"Details of parking spots of type %s on floor %d\\n\", pSpotType.toString(), this.floor)\n\t\tdll.TraverseForward()\n\t}\n}\n\nfunc (this *ParkingFloor) freeParkingSpot(pSpot ParkingSpot) {\n\tnode := this.parkingSpotsMap[pSpot.getLocation()]\n\tnode.pSpot.markFree()\n\tthis.isFull[pSpot.getParkingSpotType()] = false\n\tthis.parkingSpots[pSpot.getParkingSpotType()].MoveNodeToFront(node)\n}\n```", "```go\npackage main\n\ntype ParkingSpot interface {\n\tisFull() bool\n\tgetFloor() int\n\tgetLocation() string\n\tgetParkingSpotType() ParkingSpotType\n\tmarkFull()\n\tmarkFree()\n}\n```", "```go\npackage main\n\ntype ParkingSpotType uint8\n\nconst (\n\tcarPT ParkingSpotType = iota\n\ttruckPT\n\tmotorcyclePT\n)\n\nfunc (s ParkingSpotType) toString() string {\n\tswitch s {\n\tcase carPT:\n\t\treturn \"Car Parking Type\"\n\tcase truckPT:\n\t\treturn \"Truck Parking Type\"\n\tcase motorcyclePT:\n\t\treturn \"Motorcylce Parking Type\"\n\t}\n\treturn \"\"\n}\n\nfunc initParkingSpot(floor int, partkingSpotType ParkingSpotType, location string) ParkingSpot {\n\tswitch partkingSpotType {\n\tcase carPT:\n\t\treturn &CarParkingSpot{full: false,\n\t\t\tfloor:    floor,\n\t\t\tlocation: location,\n\t\t}\n\tcase truckPT:\n\t\treturn &TruckParkingSpot{full: false,\n\t\t\tfloor:    floor,\n\t\t\tlocation: location,\n\t\t}\n\tcase motorcyclePT:\n\t\treturn &MotorCycleParkingSpot{full: false,\n\t\t\tfloor:    floor,\n\t\t\tlocation: location,\n\t\t}\n\t}\n\treturn nil\n}\n```", "```go\npackage main\n\ntype CarParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *CarParkingSpot) isFull() bool {\n\treturn this.full\n}\n\nfunc (this *CarParkingSpot) getFloor() int {\n\treturn this.floor\n}\n\nfunc (this *CarParkingSpot) getLocation() string {\n\treturn this.location\n}\n\nfunc (this *CarParkingSpot) getParkingSpotType() ParkingSpotType {\n\treturn carPT\n}\n\nfunc (this *CarParkingSpot) markFull() {\n\tthis.full = true\n}\n\nfunc (this *CarParkingSpot) markFree() {\n\tthis.full = true\n}\n```", "```go\npackage main\n\ntype TruckParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *TruckParkingSpot) isFull() bool {\n\treturn this.full\n}\n\nfunc (this *TruckParkingSpot) getFloor() int {\n\treturn this.floor\n}\n\nfunc (this *TruckParkingSpot) getLocation() string {\n\treturn this.location\n}\n\nfunc (this *TruckParkingSpot) getParkingSpotType() ParkingSpotType {\n\treturn truckPT\n}\n\nfunc (this *TruckParkingSpot) markFull() {\n\tthis.full = true\n}\n\nfunc (this *TruckParkingSpot) markFree() {\n\tthis.full = true\n}\n```", "```go\npackage main\n\ntype MotorCycleParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *MotorCycleParkingSpot) isFull() bool {\n\treturn this.full\n}\n\nfunc (this *MotorCycleParkingSpot) getFloor() int {\n\treturn this.floor\n}\n\nfunc (this *MotorCycleParkingSpot) getLocation() string {\n\treturn this.location\n}\n\nfunc (this *MotorCycleParkingSpot) getParkingSpotType() ParkingSpotType {\n\treturn motorcyclePT\n}\n\nfunc (this *MotorCycleParkingSpot) markFull() {\n\tthis.full = true\n}\n\nfunc (this *MotorCycleParkingSpot) markFree() {\n\tthis.full = true\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype ParkingTicket struct {\n\tvehicle     Vehicle\n\tparkingSpot ParkingSpot\n\tstatus      ParkingTicketStatus\n\tentryTime   time.Time\n\texitTime    time.Time\n\tentryGate   Gate\n\texitGate    Gate\n\tprice       int\n\tpgType      PaymentGatewayType\n}\n\nfunc initParkingTicket(vehicle Vehicle, pSpot ParkingSpot, entryGate Gate) *ParkingTicket {\n\treturn &ParkingTicket{\n\t\tvehicle:     vehicle,\n\t\tparkingSpot: pSpot,\n\t\tstatus:      active,\n\t\tentryTime:   time.Now(),\n\t\tentryGate:   entryGate,\n\t}\n}\n\nfunc (this *ParkingTicket) exit(pgType PaymentGatewayType) {\n\tfmt.Printf(\"Vehicle with number %s exiting from Parking Lot\\n\", this.vehicle.numberPlate)\n\tthis.exitTime = time.Now()\n\tpRateInstance := pRateFactorySingleInstance.getParkingRateInstanceByVehicleType(this.vehicle.vehicleType)\n\ttotalDurationInHours := int(this.exitTime.Sub(this.entryTime).Hours())\n\tthis.price = pRateInstance.amountToPay(totalDurationInHours) + 1\n\tthis.pgType = pgType\n\tpgInstance := pgFactorySingleInstance.getPaymentGatewayInstanceByPGType(pgType)\n\tpgInstance.pay(this.price)\n\tthis.status = paid\n}\n\nfunc (this *ParkingTicket) print() {\n\tfmt.Printf(\"Issued ticket for vehicle number %s at parking spot %s\\n \", this.vehicle.numberPlate, this.parkingSpot.getLocation())\n\t//fmt.Printf(\"\\nPrinting Ticket\\n\")\n\t//fmt.Printf(\"Status: %s, \\nEntryTime: %s, \\nEntryGate: %d, \\nVehicle: %s, \\nParking Spot: \\n\\n\", this.status.toString(), this.entryTime.String(), this.entryGate, this.vehicle.toString())\n}\n```", "```go\npackage main\n\ntype ParkingTicketStatus uint8\n\nconst (\n\tactive ParkingTicketStatus = iota\n\tpaid\n)\n\nfunc (s ParkingTicketStatus) toString() string {\n\tswitch s {\n\tcase active:\n\t\treturn \"Active\"\n\tcase paid:\n\t\treturn \"Paid\"\n\t}\n\treturn \"\"\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype ParkingSpotDLLNode struct {\n\tpSpot ParkingSpot\n\tprev  *ParkingSpotDLLNode\n\tnext  *ParkingSpotDLLNode\n}\n\ntype ParkingSpotDLL struct {\n\tlen  int\n\ttail *ParkingSpotDLLNode\n\thead *ParkingSpotDLLNode\n}\n\nfunc initDoublyList() *ParkingSpotDLL {\n\treturn &ParkingSpotDLL{}\n}\n\nfunc (d *ParkingSpotDLL) AddToFront(node *ParkingSpotDLLNode) {\n\n\tif d.head == nil {\n\t\td.head = node\n\t\td.tail = node\n\t} else {\n\t\tnode.next = d.head\n\t\td.head.prev = node\n\t\td.head = node\n\t}\n\td.len++\n\treturn\n}\n\nfunc (d *ParkingSpotDLL) RemoveFromFront() {\n\tif d.head == nil {\n\t\treturn\n\t} else if d.head == d.tail {\n\t\td.head = nil\n\t\td.tail = nil\n\t} else {\n\t\td.head = d.head.next\n\t}\n\td.len--\n}\n\nfunc (d *ParkingSpotDLL) AddToEnd(node *ParkingSpotDLLNode) {\n\tnewNode := node\n\tif d.head == nil {\n\t\td.head = newNode\n\t\td.tail = newNode\n\t} else {\n\t\tcurrentNode := d.head\n\t\tfor currentNode.next != nil {\n\t\t\tcurrentNode = currentNode.next\n\t\t}\n\t\tnewNode.prev = currentNode\n\t\tcurrentNode.next = newNode\n\t\td.tail = newNode\n\t}\n\td.len++\n}\nfunc (d *ParkingSpotDLL) Front() *ParkingSpotDLLNode {\n\treturn d.head\n}\n\nfunc (d *ParkingSpotDLL) MoveNodeToEnd(node *ParkingSpotDLLNode) {\n\tprev := node.prev\n\tnext := node.next\n\n\tif prev != nil {\n\t\tprev.next = next\n\t}\n\n\tif next != nil {\n\t\tnext.prev = prev\n\t}\n\tif d.tail == node {\n\t\td.tail = prev\n\t}\n\tif d.head == node {\n\t\td.head = next\n\t}\n\tnode.next = nil\n\tnode.prev = nil\n\td.len--\n\td.AddToEnd(node)\n}\n\nfunc (d *ParkingSpotDLL) MoveNodeToFront(node *ParkingSpotDLLNode) {\n\tprev := node.prev\n\tnext := node.next\n\n\tif prev != nil {\n\t\tprev.next = next\n\t}\n\n\tif next != nil {\n\t\tnext.prev = prev\n\t}\n\tif d.tail == node {\n\t\td.tail = prev\n\t}\n\tif d.head == node {\n\t\td.head = next\n\t}\n\tnode.next = nil\n\tnode.prev = nil\n\td.len--\n\td.AddToFront(node)\n}\n\nfunc (d *ParkingSpotDLL) TraverseForward() error {\n\tif d.head == nil {\n\t\treturn fmt.Errorf(\"TraverseError: List is empty\")\n\t}\n\ttemp := d.head\n\tfor temp != nil {\n\t\tfmt.Printf(\"Location = %v, parkingType = %s, floor = %d full =%t\\n\", temp.pSpot.getLocation(), temp.pSpot.getParkingSpotType().toString(), temp.pSpot.getFloor(), temp.pSpot.isFull())\n\t\ttemp = temp.next\n\t}\n\tfmt.Println()\n\treturn nil\n}\n\nfunc (d *ParkingSpotDLL) Size() int {\n\treturn d.len\n}\n```", "```go\npackage main\n\ntype Gate struct {\n\tfloor    int\n\tgateType GateType\n}\n\nfunc initGate(floor int, gateType GateType) Gate {\n\treturn Gate{\n\t\tfloor:    floor,\n\t\tgateType: gateType,\n\t}\n}\n```", "```go\npackage main\n\ntype GateType uint8\n\nconst (\n\tentryGateType GateType = iota\n\texitGateType  GateType = iota\n)\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n\tnumberPlate string\n\tvehicleType VehicleType\n}\n\nfunc (v Vehicle) toString() string {\n\treturn fmt.Sprintf(\"{NumberPlate: %s, VehicleType: %s}\", v.numberPlate, v.vehicleType.toString())\n}\n```", "```go\npackage main\n\ntype VehicleType uint8\n\nconst (\n\tcar VehicleType = iota\n\ttruck\n\tmotorcycle\n)\n\nfunc (s VehicleType) toString() string {\n\tswitch s {\n\tcase car:\n\t\treturn \"Car\"\n\tcase truck:\n\t\treturn \"Truck\"\n\tcase motorcycle:\n\t\treturn \"Motorcylce\"\n\t}\n\treturn \"\"\n}\n```", "```go\npackage main\n\ntype ParkingRateFactory struct {\n\tparkingRateMap map[VehicleType]ParkingRate\n}\n\nfunc (this *ParkingRateFactory) getParkingRateInstanceByVehicleType(vType VehicleType) ParkingRate {\n\tif this.parkingRateMap[vType] != nil {\n\t\treturn this.parkingRateMap[vType]\n\t}\n\tif vType == car {\n\t\tthis.parkingRateMap[vType] = &CarParkingRate{\n\t\t\tParkingRateBase{perHourCharges: 2},\n\t\t}\n\t\treturn this.parkingRateMap[vType]\n\t}\n\tif vType == truck {\n\t\tthis.parkingRateMap[vType] = &TruckParkingRate{\n\t\t\tParkingRateBase{perHourCharges: 3},\n\t\t}\n\t\treturn this.parkingRateMap[vType]\n\t}\n\tif vType == motorcycle {\n\t\tthis.parkingRateMap[vType] = &MotorCycleParkingRate{\n\t\t\tParkingRateBase{perHourCharges: 1},\n\t\t}\n\t\treturn this.parkingRateMap[vType]\n\t}\n\treturn nil\n}\n\ntype ParkingRateBase struct {\n\tperHourCharges int\n}\n\ntype ParkingRate interface {\n\tamountToPay(int) int\n}\n\ntype CarParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *CarParkingRate) amountToPay(hours int) int {\n\treturn this.perHourCharges * hours\n}\n\ntype TruckParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *TruckParkingRate) amountToPay(hours int) int {\n\treturn this.perHourCharges * hours\n}\n\ntype MotorCycleParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *MotorCycleParkingRate) amountToPay(hours int) int {\n\treturn this.perHourCharges * hours\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype PaymentGatewayType uint8\n\nconst (\n\tcash PaymentGatewayType = iota\n\tcreditCard\n\tdebitCard\n)\n\ntype PaymentGatewayFactory struct {\n\tpaymentGatewayMap map[PaymentGatewayType]PaymentGateway\n}\n\nfunc (this *PaymentGatewayFactory) getPaymentGatewayInstanceByPGType(pgType PaymentGatewayType) PaymentGateway {\n\tif this.paymentGatewayMap[pgType] != nil {\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\tif pgType == cash {\n\t\tthis.paymentGatewayMap[pgType] = &CashPaymentGateway{}\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\tif pgType == creditCard {\n\t\tthis.paymentGatewayMap[pgType] = &CreditCardPaymentGateway{}\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\tif pgType == debitCard {\n\t\tthis.paymentGatewayMap[pgType] = &DebitCardPaymentGateway{}\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\treturn nil\n}\n\ntype PaymentGateway interface {\n\tpay(int)\n}\n\ntype CashPaymentGateway struct {\n}\n\nfunc (this CashPaymentGateway) pay(price int) {\n\tfmt.Printf(\"Paying price of %d$ through cash payment\\n\", price)\n}\n\ntype CreditCardPaymentGateway struct {\n}\n\nfunc (this CreditCardPaymentGateway) pay(price int) {\n\tfmt.Printf(\"Paying price of %d$ through credit card payment\\n\", price)\n}\n\ntype DebitCardPaymentGateway struct {\n}\n\nfunc (this DebitCardPaymentGateway) pay(price int) {\n\tfmt.Printf(\"Paying price of %d$ through debit card payment\\n\", price)\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nvar (\n\tpRateFactorySingleInstance = &ParkingRateFactory{\n\t\tparkingRateMap: make(map[VehicleType]ParkingRate),\n\t}\n\tpgFactorySingleInstance = &PaymentGatewayFactory{\n\t\tpaymentGatewayMap: make(map[PaymentGatewayType]PaymentGateway),\n\t}\n)\n\nfunc main() {\n\n\ttestSmallParkingLot()\n\n\ttestLargeParkingLot()\n\n}\n\nfunc testSmallParkingLot() {\n\tfirstParkingFloor := initParkingFloor(1)\n\tfirstFloorEntryGate1 := initGate(1, entryGateType)\n\tfirstFloorExitGate := initGate(1, exitGateType)\n\tfirstFloorCarParkingSpot1 := initParkingSpot(1, carPT, \"A1\")\n\tfirstFloorCarParkingSpot2 := initParkingSpot(1, carPT, \"A2\")\n\n\tparkingSystem := ParkingSystem{\n\t\tparkingFloor:  []*ParkingFloor{firstParkingFloor},\n\t\tentryGates:    []Gate{firstFloorEntryGate1},\n\t\texitGates:     []Gate{firstFloorExitGate},\n\t\tissuedTickets: make(map[string]ParkingTicket),\n\t}\n\t//Add first floor parkings\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot1)\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot2)\n\n\tcarVehicle1 := Vehicle{\n\t\tnumberPlate: \"C1\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicle2 := Vehicle{\n\t\tnumberPlate: \"C2\",\n\t\tvehicleType: car,\n\t}\n\n\tparkingSystem.printStatus()\n\tcarVehicleTicket1, err := parkingSystem.issueTicket(carPT, carVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket1.print()\n\n\tcarVehicleTicket2, err := parkingSystem.issueTicket(carPT, carVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket2.print()\n\n\tcarVehicle3 := Vehicle{\n\t\tnumberPlate: \"C3\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicleTicket3, err := parkingSystem.issueTicket(carPT, carVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tparkingSystem.printStatus()\n\n\tparkingSystem.exitVehicle(carVehicleTicket1, cash)\n\tparkingSystem.printStatus()\n\n\tcarVehicleTicket3, err = parkingSystem.issueTicket(carPT, carVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket3.print()\n\tparkingSystem.printStatus()\n\n}\n\nfunc testLargeParkingLot() {\n\t//We have two parking floor\n\tfirstParkingFloor := initParkingFloor(1)\n\tsecondParkingFloor := initParkingFloor(2)\n\n\t//We have two entry gates in firstParkingFloor\n\tfirstFloorEntryGate1 := initGate(1, entryGateType)\n\tfirstFloorEntryGate2 := initGate(1, entryGateType)\n\n\t//We have one exit gate on firstParkingFloor\n\tfirstFloorExitGate := initGate(1, exitGateType)\n\n\tparkingSystem := ParkingSystem{\n\t\tparkingFloor:  []*ParkingFloor{firstParkingFloor, secondParkingFloor},\n\t\tentryGates:    []Gate{firstFloorEntryGate1, firstFloorEntryGate2},\n\t\texitGates:     []Gate{firstFloorExitGate},\n\t\tissuedTickets: make(map[string]ParkingTicket),\n\t}\n\n\t//We have two car parking spots, two motorcyle parking spots, 1 truck paring spot on each of the floor\n\tfirstFloorCarParkingSpot1 := initParkingSpot(1, carPT, \"A1\")\n\tfirstFloorCarParkingSpot2 := initParkingSpot(1, carPT, \"A2\")\n\tfirstFloorMotorCycleParkingSpot1 := initParkingSpot(1, motorcyclePT, \"A3\")\n\tfirstFloorMotorCycleParkingSpot2 := initParkingSpot(1, motorcyclePT, \"A4\")\n\tfirstFloorTruckParkingSpot := initParkingSpot(1, truckPT, \"A5\")\n\n\t//We have two car parking spots, two motorcyle parking spots, 1 truck paring spot on each of the floor\n\tsecondFloorCarParkingSpot1 := initParkingSpot(2, carPT, \"B1\")\n\tsecondFloorCarParkingSpot2 := initParkingSpot(2, carPT, \"B2\")\n\tsecondFloorMotorCycleParkingSpot1 := initParkingSpot(2, motorcyclePT, \"B3\")\n\tsecondFloorMotorCycleParkingSpot2 := initParkingSpot(2, motorcyclePT, \"B4\")\n\tsecondFloorTruckParkingSpot := initParkingSpot(2, truckPT, \"B5\")\n\n\t//Add first floor parkings\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot1)\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot2)\n\tparkingSystem.addParkingSpot(firstFloorMotorCycleParkingSpot1)\n\tparkingSystem.addParkingSpot(firstFloorMotorCycleParkingSpot2)\n\tparkingSystem.addParkingSpot(firstFloorTruckParkingSpot)\n\n\t//Add second floor parkings\n\tparkingSystem.addParkingSpot(secondFloorCarParkingSpot1)\n\tparkingSystem.addParkingSpot(secondFloorCarParkingSpot2)\n\tparkingSystem.addParkingSpot(secondFloorMotorCycleParkingSpot1)\n\tparkingSystem.addParkingSpot(secondFloorMotorCycleParkingSpot2)\n\tparkingSystem.addParkingSpot(secondFloorTruckParkingSpot)\n\n\tcarVehicle1 := Vehicle{\n\t\tnumberPlate: \"C1\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicle2 := Vehicle{\n\t\tnumberPlate: \"C2\",\n\t\tvehicleType: car,\n\t}\n\tmotorCycleVehicle1 := Vehicle{\n\t\tnumberPlate: \"M1\",\n\t\tvehicleType: motorcycle,\n\t}\n\tmotorCycleVehicle2 := Vehicle{\n\t\tnumberPlate: \"M2\",\n\t\tvehicleType: motorcycle,\n\t}\n\n\ttruckVehicle1 := Vehicle{\n\t\tnumberPlate: \"T1\",\n\t\tvehicleType: motorcycle,\n\t}\n\n\tparkingSystem.printStatus()\n\tcarVehicleTicket1, err := parkingSystem.issueTicket(carPT, carVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket1.print()\n\tcarVehicleTicket2, err := parkingSystem.issueTicket(carPT, carVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket2.print()\n\tmotorCycleVehicleTicket1, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket1.print()\n\tmotorCycleVehicleTicket2, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket2.print()\n\ttruckVehicleTicket1, err := parkingSystem.issueTicket(truckPT, truckVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\ttruckVehicleTicket1.print()\n\tparkingSystem.printStatus()\n\n\tcarVehicle3 := Vehicle{\n\t\tnumberPlate: \"C3\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicle4 := Vehicle{\n\t\tnumberPlate: \"C4\",\n\t\tvehicleType: car,\n\t}\n\tmotorCycleVehicle3 := Vehicle{\n\t\tnumberPlate: \"M3\",\n\t\tvehicleType: motorcycle,\n\t}\n\tmotorCycleVehicle4 := Vehicle{\n\t\tnumberPlate: \"M4\",\n\t\tvehicleType: motorcycle,\n\t}\n\n\ttruckVehicle2 := Vehicle{\n\t\tnumberPlate: \"T2\",\n\t\tvehicleType: motorcycle,\n\t}\n\tcarVehicleTicket3, err := parkingSystem.issueTicket(carPT, carVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket3.print()\n\tcarVehicleTicket4, err := parkingSystem.issueTicket(carPT, carVehicle4, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket4.print()\n\tmotorCycleVehicleTicket3, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket3.print()\n\tmotorCycleVehicleTicket4, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle4, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket4.print()\n\ttruckVehicleTicket2, err := parkingSystem.issueTicket(truckPT, truckVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\ttruckVehicleTicket2.print()\n\tparkingSystem.printStatus()\n\n\tcarVehicle5 := Vehicle{\n\t\tnumberPlate: \"C5\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicleTicket5, err := parkingSystem.issueTicket(carPT, carVehicle5, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tparkingSystem.printStatus()\n\n\tparkingSystem.exitVehicle(carVehicleTicket1, cash)\n\tparkingSystem.printStatus()\n\n\tcarVehicleTicket5, err = parkingSystem.issueTicket(carPT, carVehicle5, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket5.print()\n\tparkingSystem.printStatus()\n}\n```", "```go\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =false\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =false\n\nGoing to issue ticket for vehicle number C1\nIssued ticket for vehicle number C1 at parking spot A2\nGoing to issue ticket for vehicle number C2\nIssued ticket for vehicle number C2 at parking spot A1\nGoing to issue ticket for vehicle number C3\nCannot issue ticket. All Car Parking Type parking spot type are full\n\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =true\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =true\n\nVehicle with number C1 exiting from Parking Lot\nPaying price of 1$ through cash payment\n\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =true\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =true\n\nGoing to issue ticket for vehicle number C3\nIssued ticket for vehicle number C3 at parking spot A2\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =true\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =true\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype CarParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *CarParkingSpot) isFull() bool {\n\treturn this.full\n}\n\nfunc (this *CarParkingSpot) getFloor() int {\n\treturn this.floor\n}\n\nfunc (this *CarParkingSpot) getLocation() string {\n\treturn this.location\n}\n\nfunc (this *CarParkingSpot) getParkingSpotType() ParkingSpotType {\n\treturn carPT\n}\n\nfunc (this *CarParkingSpot) markFull() {\n\tthis.full = true\n}\n\nfunc (this *CarParkingSpot) markFree() {\n\tthis.full = true\n}\n\ntype ParkingSpotDLLNode struct {\n\tpSpot ParkingSpot\n\tprev  *ParkingSpotDLLNode\n\tnext  *ParkingSpotDLLNode\n}\n\ntype ParkingSpotDLL struct {\n\tlen  int\n\ttail *ParkingSpotDLLNode\n\thead *ParkingSpotDLLNode\n}\n\nfunc initDoublyList() *ParkingSpotDLL {\n\treturn &ParkingSpotDLL{}\n}\n\nfunc (d *ParkingSpotDLL) AddToFront(node *ParkingSpotDLLNode) {\n\n\tif d.head == nil {\n\t\td.head = node\n\t\td.tail = node\n\t} else {\n\t\tnode.next = d.head\n\t\td.head.prev = node\n\t\td.head = node\n\t}\n\td.len++\n\treturn\n}\n\nfunc (d *ParkingSpotDLL) RemoveFromFront() {\n\tif d.head == nil {\n\t\treturn\n\t} else if d.head == d.tail {\n\t\td.head = nil\n\t\td.tail = nil\n\t} else {\n\t\td.head = d.head.next\n\t}\n\td.len--\n}\n\nfunc (d *ParkingSpotDLL) AddToEnd(node *ParkingSpotDLLNode) {\n\tnewNode := node\n\tif d.head == nil {\n\t\td.head = newNode\n\t\td.tail = newNode\n\t} else {\n\t\tcurrentNode := d.head\n\t\tfor currentNode.next != nil {\n\t\t\tcurrentNode = currentNode.next\n\t\t}\n\t\tnewNode.prev = currentNode\n\t\tcurrentNode.next = newNode\n\t\td.tail = newNode\n\t}\n\td.len++\n}\nfunc (d *ParkingSpotDLL) Front() *ParkingSpotDLLNode {\n\treturn d.head\n}\n\nfunc (d *ParkingSpotDLL) MoveNodeToEnd(node *ParkingSpotDLLNode) {\n\tprev := node.prev\n\tnext := node.next\n\n\tif prev != nil {\n\t\tprev.next = next\n\t}\n\n\tif next != nil {\n\t\tnext.prev = prev\n\t}\n\tif d.tail == node {\n\t\td.tail = prev\n\t}\n\tif d.head == node {\n\t\td.head = next\n\t}\n\tnode.next = nil\n\tnode.prev = nil\n\td.len--\n\td.AddToEnd(node)\n}\n\nfunc (d *ParkingSpotDLL) MoveNodeToFront(node *ParkingSpotDLLNode) {\n\tprev := node.prev\n\tnext := node.next\n\n\tif prev != nil {\n\t\tprev.next = next\n\t}\n\n\tif next != nil {\n\t\tnext.prev = prev\n\t}\n\tif d.tail == node {\n\t\td.tail = prev\n\t}\n\tif d.head == node {\n\t\td.head = next\n\t}\n\tnode.next = nil\n\tnode.prev = nil\n\td.len--\n\td.AddToFront(node)\n}\n\nfunc (d *ParkingSpotDLL) TraverseForward() error {\n\tif d.head == nil {\n\t\treturn fmt.Errorf(\"TraverseError: List is empty\")\n\t}\n\ttemp := d.head\n\tfor temp != nil {\n\t\tfmt.Printf(\"Location = %v, parkingType = %s, floor = %d full =%t\\n\", temp.pSpot.getLocation(), temp.pSpot.getParkingSpotType().toString(), temp.pSpot.getFloor(), temp.pSpot.isFull())\n\t\ttemp = temp.next\n\t}\n\tfmt.Println()\n\treturn nil\n}\n\nfunc (d *ParkingSpotDLL) Size() int {\n\treturn d.len\n}\n\ntype Gate struct {\n\tfloor    int\n\tgateType GateType\n}\n\nfunc initGate(floor int, gateType GateType) Gate {\n\treturn Gate{\n\t\tfloor:    floor,\n\t\tgateType: gateType,\n\t}\n}\n\ntype GateType uint8\n\nconst (\n\tentryGateType GateType = iota\n\texitGateType  GateType = iota\n)\n\nvar (\n\tpRateFactorySingleInstance = &ParkingRateFactory{\n\t\tparkingRateMap: make(map[VehicleType]ParkingRate),\n\t}\n\tpgFactorySingleInstance = &PaymentGatewayFactory{\n\t\tpaymentGatewayMap: make(map[PaymentGatewayType]PaymentGateway),\n\t}\n)\n\ntype MotorCycleParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *MotorCycleParkingSpot) isFull() bool {\n\treturn this.full\n}\n\nfunc (this *MotorCycleParkingSpot) getFloor() int {\n\treturn this.floor\n}\n\nfunc (this *MotorCycleParkingSpot) getLocation() string {\n\treturn this.location\n}\n\nfunc (this *MotorCycleParkingSpot) getParkingSpotType() ParkingSpotType {\n\treturn motorcyclePT\n}\n\nfunc (this *MotorCycleParkingSpot) markFull() {\n\tthis.full = true\n}\n\nfunc (this *MotorCycleParkingSpot) markFree() {\n\tthis.full = true\n}\n\ntype ParkingFloor struct {\n\tparkingSpots    map[ParkingSpotType]*ParkingSpotDLL\n\tparkingSpotsMap map[string]*ParkingSpotDLLNode\n\tisFull          map[ParkingSpotType]bool\n\tfloor           int\n}\n\nfunc initParkingFloor(floor int) *ParkingFloor {\n\treturn &ParkingFloor{\n\t\tfloor:           floor,\n\t\tparkingSpots:    make(map[ParkingSpotType]*ParkingSpotDLL),\n\t\tparkingSpotsMap: make(map[string]*ParkingSpotDLLNode),\n\t\tisFull:          make(map[ParkingSpotType]bool),\n\t}\n}\n\nfunc (this *ParkingFloor) addParkingSpot(pSpot ParkingSpot) {\n\tdll, ok := this.parkingSpots[pSpot.getParkingSpotType()]\n\tif ok {\n\t\tnewNode := &ParkingSpotDLLNode{\n\t\t\tpSpot: pSpot,\n\t\t}\n\t\tdll.AddToFront(newNode)\n\t\tthis.parkingSpotsMap[pSpot.getLocation()] = newNode\n\t\treturn\n\t}\n\n\tdll = &ParkingSpotDLL{}\n\tthis.parkingSpots[pSpot.getParkingSpotType()] = dll\n\tnewNode := &ParkingSpotDLLNode{\n\t\tpSpot: pSpot,\n\t}\n\tthis.parkingSpots[pSpot.getParkingSpotType()].AddToFront(newNode)\n\tthis.parkingSpotsMap[pSpot.getLocation()] = newNode\n}\n\nfunc (this *ParkingFloor) bookParkingSpot(pSpotType ParkingSpotType) (ParkingSpot, error) {\n\tif this.isFull[pSpotType] {\n\t\treturn nil, fmt.Errorf(\"%s Parking Spot is full on %d floor\", pSpotType.toString(), this.floor)\n\t}\n\n\tnextPSpot := this.parkingSpots[pSpotType].Front()\n\tnextPSpot.pSpot.markFull()\n\tthis.parkingSpots[pSpotType].MoveNodeToEnd(nextPSpot)\n\tif this.parkingSpots[pSpotType].Front().pSpot.isFull() {\n\t\tthis.isFull[pSpotType] = true\n\t}\n\treturn nextPSpot.pSpot, nil\n}\n\nfunc (this *ParkingFloor) printStatus() {\n\tfor pSpotType, dll := range this.parkingSpots {\n\t\tfmt.Printf(\"Details of parking spots of type %s on floor %d\\n\", pSpotType.toString(), this.floor)\n\t\tdll.TraverseForward()\n\t}\n}\n\nfunc (this *ParkingFloor) freeParkingSpot(pSpot ParkingSpot) {\n\tnode := this.parkingSpotsMap[pSpot.getLocation()]\n\tnode.pSpot.markFree()\n\tthis.isFull[pSpot.getParkingSpotType()] = false\n\tthis.parkingSpots[pSpot.getParkingSpotType()].MoveNodeToFront(node)\n}\n\ntype ParkingRateFactory struct {\n\tparkingRateMap map[VehicleType]ParkingRate\n}\n\nfunc (this *ParkingRateFactory) getParkingRateInstanceByVehicleType(vType VehicleType) ParkingRate {\n\tif this.parkingRateMap[vType] != nil {\n\t\treturn this.parkingRateMap[vType]\n\t}\n\tif vType == car {\n\t\tthis.parkingRateMap[vType] = &CarParkingRate{\n\t\t\tParkingRateBase{perHourCharges: 2},\n\t\t}\n\t\treturn this.parkingRateMap[vType]\n\t}\n\tif vType == truck {\n\t\tthis.parkingRateMap[vType] = &TruckParkingRate{\n\t\t\tParkingRateBase{perHourCharges: 3},\n\t\t}\n\t\treturn this.parkingRateMap[vType]\n\t}\n\tif vType == motorcycle {\n\t\tthis.parkingRateMap[vType] = &MotorCycleParkingRate{\n\t\t\tParkingRateBase{perHourCharges: 1},\n\t\t}\n\t\treturn this.parkingRateMap[vType]\n\t}\n\treturn nil\n}\n\ntype ParkingRateBase struct {\n\tperHourCharges int\n}\n\ntype ParkingRate interface {\n\tamountToPay(int) int\n}\n\ntype CarParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *CarParkingRate) amountToPay(hours int) int {\n\treturn this.perHourCharges * hours\n}\n\ntype TruckParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *TruckParkingRate) amountToPay(hours int) int {\n\treturn this.perHourCharges * hours\n}\n\ntype MotorCycleParkingRate struct {\n\tParkingRateBase\n}\n\nfunc (this *MotorCycleParkingRate) amountToPay(hours int) int {\n\treturn this.perHourCharges * hours\n}\n\ntype ParkingSpot interface {\n\tisFull() bool\n\tgetFloor() int\n\tgetLocation() string\n\tgetParkingSpotType() ParkingSpotType\n\tmarkFull()\n\tmarkFree()\n}\n\ntype ParkingSpotType uint8\n\nconst (\n\tcarPT ParkingSpotType = iota\n\ttruckPT\n\tmotorcyclePT\n)\n\nfunc (s ParkingSpotType) toString() string {\n\tswitch s {\n\tcase carPT:\n\t\treturn \"Car Parking Type\"\n\tcase truckPT:\n\t\treturn \"Truck Parking Type\"\n\tcase motorcyclePT:\n\t\treturn \"Motorcylce Parking Type\"\n\t}\n\treturn \"\"\n}\n\nfunc initParkingSpot(floor int, partkingSpotType ParkingSpotType, location string) ParkingSpot {\n\tswitch partkingSpotType {\n\tcase carPT:\n\t\treturn &CarParkingSpot{full: false,\n\t\t\tfloor:    floor,\n\t\t\tlocation: location,\n\t\t}\n\tcase truckPT:\n\t\treturn &TruckParkingSpot{full: false,\n\t\t\tfloor:    floor,\n\t\t\tlocation: location,\n\t\t}\n\tcase motorcyclePT:\n\t\treturn &MotorCycleParkingSpot{full: false,\n\t\t\tfloor:    floor,\n\t\t\tlocation: location,\n\t\t}\n\t}\n\treturn nil\n}\n\ntype ParkingSystem struct {\n\tissuedTickets map[string]ParkingTicket\n\tparkingFloor  []*ParkingFloor\n\tisFull        map[ParkingSpotType]bool\n\tentryGates    []Gate\n\texitGates     []Gate\n}\n\nfunc (this *ParkingSystem) addParkingSpot(parkingSpot ParkingSpot) {\n\tthis.parkingFloor[parkingSpot.getFloor()-1].addParkingSpot(parkingSpot)\n}\n\nfunc (this *ParkingSystem) bookParkingSpot(pSpotType ParkingSpotType) (ParkingSpot, error) {\n\tfor _, pFloor := range this.parkingFloor {\n\t\tpSpot, err := pFloor.bookParkingSpot(pSpotType)\n\t\tif err == nil {\n\t\t\treturn pSpot, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"Cannot issue ticket. All %s parking spot type are full\\n\", pSpotType.toString())\n}\n\nfunc (this *ParkingSystem) issueTicket(pSpotType ParkingSpotType, vehicle Vehicle, entryGate Gate) (*ParkingTicket, error) {\n\tfmt.Printf(\"\\nGoing to issue ticket for vehicle number %s\\n\", vehicle.numberPlate)\n\tpSpot, err := this.bookParkingSpot(pSpotType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tticket := initParkingTicket(vehicle, pSpot, entryGate)\n\treturn ticket, nil\n}\n\nfunc (this *ParkingSystem) printStatus() {\n\tfmt.Println(\"\\nPrinting Status of Parking Spot\")\n\tfor _, pFloor := range this.parkingFloor {\n\t\tpFloor.printStatus()\n\t}\n}\n\nfunc (this *ParkingSystem) exitVehicle(ticket *ParkingTicket, pGType PaymentGatewayType) {\n\tthis.parkingFloor[ticket.parkingSpot.getFloor()-1].freeParkingSpot(ticket.parkingSpot)\n\tticket.exit(pGType)\n}\n\ntype ParkingTicket struct {\n\tvehicle     Vehicle\n\tparkingSpot ParkingSpot\n\tstatus      ParkingTicketStatus\n\tentryTime   time.Time\n\texitTime    time.Time\n\tentryGate   Gate\n\texitGate    Gate\n\tprice       int\n\tpgType      PaymentGatewayType\n}\n\nfunc initParkingTicket(vehicle Vehicle, pSpot ParkingSpot, entryGate Gate) *ParkingTicket {\n\treturn &ParkingTicket{\n\t\tvehicle:     vehicle,\n\t\tparkingSpot: pSpot,\n\t\tstatus:      active,\n\t\tentryTime:   time.Now(),\n\t\tentryGate:   entryGate,\n\t}\n}\n\nfunc (this *ParkingTicket) exit(pgType PaymentGatewayType) {\n\tfmt.Printf(\"Vehicle with number %s exiting from Parking Lot\\n\", this.vehicle.numberPlate)\n\tthis.exitTime = time.Now()\n\tpRateInstance := pRateFactorySingleInstance.getParkingRateInstanceByVehicleType(this.vehicle.vehicleType)\n\ttotalDurationInHours := int(this.exitTime.Sub(this.entryTime).Hours())\n\tthis.price = pRateInstance.amountToPay(totalDurationInHours) + 1\n\tthis.pgType = pgType\n\tpgInstance := pgFactorySingleInstance.getPaymentGatewayInstanceByPGType(pgType)\n\tpgInstance.pay(this.price)\n\tthis.status = paid\n}\n\nfunc (this *ParkingTicket) print() {\n\tfmt.Printf(\"Issued ticket for vehicle number %s at parking spot %s\\n \", this.vehicle.numberPlate, this.parkingSpot.getLocation())\n\t//fmt.Printf(\"\\nPrinting Ticket\\n\")\n\t//fmt.Printf(\"Status: %s, \\nEntryTime: %s, \\nEntryGate: %d, \\nVehicle: %s, \\nParking Spot: \\n\\n\", this.status.toString(), this.entryTime.String(), this.entryGate, this.vehicle.toString())\n}\n\ntype ParkingTicketStatus uint8\n\nconst (\n\tactive ParkingTicketStatus = iota\n\tpaid\n)\n\nfunc (s ParkingTicketStatus) toString() string {\n\tswitch s {\n\tcase active:\n\t\treturn \"Active\"\n\tcase paid:\n\t\treturn \"Paid\"\n\t}\n\treturn \"\"\n}\n\ntype PaymentGatewayType uint8\n\nconst (\n\tcash PaymentGatewayType = iota\n\tcreditCard\n\tdebitCard\n)\n\ntype PaymentGatewayFactory struct {\n\tpaymentGatewayMap map[PaymentGatewayType]PaymentGateway\n}\n\nfunc (this *PaymentGatewayFactory) getPaymentGatewayInstanceByPGType(pgType PaymentGatewayType) PaymentGateway {\n\tif this.paymentGatewayMap[pgType] != nil {\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\tif pgType == cash {\n\t\tthis.paymentGatewayMap[pgType] = &CashPaymentGateway{}\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\tif pgType == creditCard {\n\t\tthis.paymentGatewayMap[pgType] = &CreditCardPaymentGateway{}\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\tif pgType == debitCard {\n\t\tthis.paymentGatewayMap[pgType] = &DebitCardPaymentGateway{}\n\t\treturn this.paymentGatewayMap[pgType]\n\t}\n\treturn nil\n}\n\ntype PaymentGateway interface {\n\tpay(int)\n}\n\ntype CashPaymentGateway struct {\n}\n\nfunc (this CashPaymentGateway) pay(price int) {\n\tfmt.Printf(\"Paying price of %d$ through cash payment\\n\", price)\n}\n\ntype CreditCardPaymentGateway struct {\n}\n\nfunc (this CreditCardPaymentGateway) pay(price int) {\n\tfmt.Printf(\"Paying price of %d$ through credit card payment\\n\", price)\n}\n\ntype DebitCardPaymentGateway struct {\n}\n\nfunc (this DebitCardPaymentGateway) pay(price int) {\n\tfmt.Printf(\"Paying price of %d$ through debit card payment\\n\", price)\n}\n\ntype TruckParkingSpot struct {\n\tfull     bool\n\tfloor    int\n\tlocation string\n}\n\nfunc (this *TruckParkingSpot) isFull() bool {\n\treturn this.full\n}\n\nfunc (this *TruckParkingSpot) getFloor() int {\n\treturn this.floor\n}\n\nfunc (this *TruckParkingSpot) getLocation() string {\n\treturn this.location\n}\n\nfunc (this *TruckParkingSpot) getParkingSpotType() ParkingSpotType {\n\treturn truckPT\n}\n\nfunc (this *TruckParkingSpot) markFull() {\n\tthis.full = true\n}\n\nfunc (this *TruckParkingSpot) markFree() {\n\tthis.full = true\n}\n\ntype Vehicle struct {\n\tnumberPlate string\n\tvehicleType VehicleType\n}\n\nfunc (v Vehicle) toString() string {\n\treturn fmt.Sprintf(\"{NumberPlate: %s, VehicleType: %s}\", v.numberPlate, v.vehicleType.toString())\n}\n\ntype VehicleType uint8\n\nconst (\n\tcar VehicleType = iota\n\ttruck\n\tmotorcycle\n)\n\nfunc (s VehicleType) toString() string {\n\tswitch s {\n\tcase car:\n\t\treturn \"Car\"\n\tcase truck:\n\t\treturn \"Truck\"\n\tcase motorcycle:\n\t\treturn \"Motorcylce\"\n\t}\n\treturn \"\"\n}\n\nfunc main() {\n\n\ttestSmallParkingLot()\n\n\t//testLargeParkingLot()\n\n}\n\nfunc testSmallParkingLot() {\n\tfirstParkingFloor := initParkingFloor(1)\n\tfirstFloorEntryGate1 := initGate(1, entryGateType)\n\tfirstFloorExitGate := initGate(1, exitGateType)\n\tfirstFloorCarParkingSpot1 := initParkingSpot(1, carPT, \"A1\")\n\tfirstFloorCarParkingSpot2 := initParkingSpot(1, carPT, \"A2\")\n\n\tparkingSystem := ParkingSystem{\n\t\tparkingFloor:  []*ParkingFloor{firstParkingFloor},\n\t\tentryGates:    []Gate{firstFloorEntryGate1},\n\t\texitGates:     []Gate{firstFloorExitGate},\n\t\tissuedTickets: make(map[string]ParkingTicket),\n\t}\n\t//Add first floor parkings\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot1)\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot2)\n\n\tcarVehicle1 := Vehicle{\n\t\tnumberPlate: \"C1\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicle2 := Vehicle{\n\t\tnumberPlate: \"C2\",\n\t\tvehicleType: car,\n\t}\n\n\tparkingSystem.printStatus()\n\tcarVehicleTicket1, err := parkingSystem.issueTicket(carPT, carVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket1.print()\n\n\tcarVehicleTicket2, err := parkingSystem.issueTicket(carPT, carVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket2.print()\n\n\tcarVehicle3 := Vehicle{\n\t\tnumberPlate: \"C3\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicleTicket3, err := parkingSystem.issueTicket(carPT, carVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tparkingSystem.printStatus()\n\n\tparkingSystem.exitVehicle(carVehicleTicket1, cash)\n\tparkingSystem.printStatus()\n\n\tcarVehicleTicket3, err = parkingSystem.issueTicket(carPT, carVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket3.print()\n\tparkingSystem.printStatus()\n\n}\n\nfunc testLargeParkingLot() {\n\t//We have two parking floor\n\tfirstParkingFloor := initParkingFloor(1)\n\tsecondParkingFloor := initParkingFloor(2)\n\n\t//We have two entry gates in firstParkingFloor\n\tfirstFloorEntryGate1 := initGate(1, entryGateType)\n\tfirstFloorEntryGate2 := initGate(1, entryGateType)\n\n\t//We have one exit gate on firstParkingFloor\n\tfirstFloorExitGate := initGate(1, exitGateType)\n\n\tparkingSystem := ParkingSystem{\n\t\tparkingFloor:  []*ParkingFloor{firstParkingFloor, secondParkingFloor},\n\t\tentryGates:    []Gate{firstFloorEntryGate1, firstFloorEntryGate2},\n\t\texitGates:     []Gate{firstFloorExitGate},\n\t\tissuedTickets: make(map[string]ParkingTicket),\n\t}\n\n\t//We have two car parking spots, two motorcyle parking spots, 1 truck paring spot on each of the floor\n\tfirstFloorCarParkingSpot1 := initParkingSpot(1, carPT, \"A1\")\n\tfirstFloorCarParkingSpot2 := initParkingSpot(1, carPT, \"A2\")\n\tfirstFloorMotorCycleParkingSpot1 := initParkingSpot(1, motorcyclePT, \"A3\")\n\tfirstFloorMotorCycleParkingSpot2 := initParkingSpot(1, motorcyclePT, \"A4\")\n\tfirstFloorTruckParkingSpot := initParkingSpot(1, truckPT, \"A5\")\n\n\t//We have two car parking spots, two motorcyle parking spots, 1 truck paring spot on each of the floor\n\tsecondFloorCarParkingSpot1 := initParkingSpot(2, carPT, \"B1\")\n\tsecondFloorCarParkingSpot2 := initParkingSpot(2, carPT, \"B2\")\n\tsecondFloorMotorCycleParkingSpot1 := initParkingSpot(2, motorcyclePT, \"B3\")\n\tsecondFloorMotorCycleParkingSpot2 := initParkingSpot(2, motorcyclePT, \"B4\")\n\tsecondFloorTruckParkingSpot := initParkingSpot(2, truckPT, \"B5\")\n\n\t//Add first floor parkings\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot1)\n\tparkingSystem.addParkingSpot(firstFloorCarParkingSpot2)\n\tparkingSystem.addParkingSpot(firstFloorMotorCycleParkingSpot1)\n\tparkingSystem.addParkingSpot(firstFloorMotorCycleParkingSpot2)\n\tparkingSystem.addParkingSpot(firstFloorTruckParkingSpot)\n\n\t//Add second floor parkings\n\tparkingSystem.addParkingSpot(secondFloorCarParkingSpot1)\n\tparkingSystem.addParkingSpot(secondFloorCarParkingSpot2)\n\tparkingSystem.addParkingSpot(secondFloorMotorCycleParkingSpot1)\n\tparkingSystem.addParkingSpot(secondFloorMotorCycleParkingSpot2)\n\tparkingSystem.addParkingSpot(secondFloorTruckParkingSpot)\n\n\tcarVehicle1 := Vehicle{\n\t\tnumberPlate: \"C1\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicle2 := Vehicle{\n\t\tnumberPlate: \"C2\",\n\t\tvehicleType: car,\n\t}\n\tmotorCycleVehicle1 := Vehicle{\n\t\tnumberPlate: \"M1\",\n\t\tvehicleType: motorcycle,\n\t}\n\tmotorCycleVehicle2 := Vehicle{\n\t\tnumberPlate: \"M2\",\n\t\tvehicleType: motorcycle,\n\t}\n\n\ttruckVehicle1 := Vehicle{\n\t\tnumberPlate: \"T1\",\n\t\tvehicleType: motorcycle,\n\t}\n\n\tparkingSystem.printStatus()\n\tcarVehicleTicket1, err := parkingSystem.issueTicket(carPT, carVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket1.print()\n\tcarVehicleTicket2, err := parkingSystem.issueTicket(carPT, carVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket2.print()\n\tmotorCycleVehicleTicket1, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket1.print()\n\tmotorCycleVehicleTicket2, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket2.print()\n\ttruckVehicleTicket1, err := parkingSystem.issueTicket(truckPT, truckVehicle1, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\ttruckVehicleTicket1.print()\n\tparkingSystem.printStatus()\n\n\tcarVehicle3 := Vehicle{\n\t\tnumberPlate: \"C3\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicle4 := Vehicle{\n\t\tnumberPlate: \"C4\",\n\t\tvehicleType: car,\n\t}\n\tmotorCycleVehicle3 := Vehicle{\n\t\tnumberPlate: \"M3\",\n\t\tvehicleType: motorcycle,\n\t}\n\tmotorCycleVehicle4 := Vehicle{\n\t\tnumberPlate: \"M4\",\n\t\tvehicleType: motorcycle,\n\t}\n\n\ttruckVehicle2 := Vehicle{\n\t\tnumberPlate: \"T2\",\n\t\tvehicleType: motorcycle,\n\t}\n\tcarVehicleTicket3, err := parkingSystem.issueTicket(carPT, carVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket3.print()\n\tcarVehicleTicket4, err := parkingSystem.issueTicket(carPT, carVehicle4, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket4.print()\n\tmotorCycleVehicleTicket3, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle3, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket3.print()\n\tmotorCycleVehicleTicket4, err := parkingSystem.issueTicket(motorcyclePT, motorCycleVehicle4, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tmotorCycleVehicleTicket4.print()\n\ttruckVehicleTicket2, err := parkingSystem.issueTicket(truckPT, truckVehicle2, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\ttruckVehicleTicket2.print()\n\tparkingSystem.printStatus()\n\n\tcarVehicle5 := Vehicle{\n\t\tnumberPlate: \"C5\",\n\t\tvehicleType: car,\n\t}\n\tcarVehicleTicket5, err := parkingSystem.issueTicket(carPT, carVehicle5, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tparkingSystem.printStatus()\n\n\tparkingSystem.exitVehicle(carVehicleTicket1, cash)\n\tparkingSystem.printStatus()\n\n\tcarVehicleTicket5, err = parkingSystem.issueTicket(carPT, carVehicle5, firstFloorEntryGate1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tcarVehicleTicket5.print()\n\tparkingSystem.printStatus()\n}\n```", "```go\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =false\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =false\n\nGoing to issue ticket for vehicle number C1\nIssued ticket for vehicle number C1 at parking spot A2\nGoing to issue ticket for vehicle number C2\nIssued ticket for vehicle number C2 at parking spot A1\nGoing to issue ticket for vehicle number C3\nCannot issue ticket. All Car Parking Type parking spot type are full\n\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =true\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =true\n\nVehicle with number C1 exiting from Parking Lot\nPaying price of 1$ through cash payment\n\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =true\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =true\n\nGoing to issue ticket for vehicle number C3\nIssued ticket for vehicle number C3 at parking spot A2\nPrinting Status of Parking Spot\nDetails of parking spots of type Car Parking Type on floor 1\nLocation = A1, parkingType = Car Parking Type, floor = 1 full =true\nLocation = A2, parkingType = Car Parking Type, floor = 1 full =true\n```"]