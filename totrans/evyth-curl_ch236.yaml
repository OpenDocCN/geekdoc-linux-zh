- en: Proxies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: A proxy in a network context is a middle man, a server in between you as a client
    and the remote server you want to communicate with. The client contacts the middle
    man which then goes on to contact the remote server for you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络环境中，代理是一个中间人，位于您作为客户端和您想要与之通信的远程服务器之间的服务器。客户端联系中间人，然后中间人继续为您联系远程服务器。
- en: This style of proxy use is sometimes used by companies and organizations, in
    which case you are usually required to use them to reach the target server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代理使用方式有时被公司和组织使用，在这种情况下，您通常需要使用它们来访问目标服务器。
- en: There are several different kinds of proxies and different protocols to use
    when communicating with a proxy, and libcurl supports a few of the most common
    proxy protocols. It is important to realize that the protocol used to the proxy
    is not necessarily the same protocol used to the remote server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在与代理通信时，有几种不同的代理类型和不同的协议，libcurl支持其中一些最常用的代理协议。重要的是要认识到，用于代理的协议不一定与用于远程服务器的协议相同。
- en: When setting up a transfer with libcurl you need to point out the server name
    and port number of the proxy. You may find that your favorite browsers can do
    this in slightly more advanced ways than libcurl can, and we get into such details
    in later sections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用libcurl设置传输时，您需要指定代理服务器的名称和端口号。您可能会发现，您喜欢的浏览器在这一点上可能比libcurl更高级，我们将在后面的章节中详细介绍这些细节。
- en: Proxy types
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理类型
- en: 'libcurl supports the two major proxy types: SOCKS and HTTP proxies. More specifically,
    it supports both SOCKS4 and SOCKS5 with or without remote name lookup, as well
    as both HTTP and HTTPS to the local proxy.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl支持两种主要的代理类型：SOCKS和HTTP代理。更具体地说，它支持带有或不带有远程名称查找的SOCKS4和SOCKS5，以及到本地代理的HTTP和HTTPS。
- en: 'The easiest way to specify which kind of proxy you are talking to is to set
    the scheme part of the proxy hostname string (`CURLOPT_PROXY`) to match it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 指定您正在与之通信的代理类型的简单方法是将代理主机名字符串的方案部分（`CURLOPT_PROXY`）设置为匹配它：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`socks4` - means SOCKS4 with local name resolving'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks4` - 表示带有本地名称解析的SOCKS4'
- en: '`socks4a` - means SOCKS4 with proxy’s name resolving'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks4a` - 表示带有代理名称解析的SOCKS4'
- en: '`socks5` - means SOCKS5 with local name resolving'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks5` - 表示带有本地名称解析的SOCKS5'
- en: '`socks5h` - means SOCKS5 with proxy’s name resolving'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks5h` - 表示带有代理名称解析的SOCKS5'
- en: '`http` - means HTTP, which always lets the proxy resolve names'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` - 表示HTTP，这总是让代理解析名称'
- en: '`https` - means HTTPS **to the proxy**, which always lets the proxy resolve
    names.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`https` - 表示代理的HTTPS，这总是让代理解析名称。'
- en: You can also opt to set the type of the proxy with a separate option if you
    prefer to only set the hostname, using `CURLOPT_PROXYTYPE`. Similarly, you can
    set the proxy port number to use with `CURLOPT_PROXYPORT`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢只设置主机名，可以选择使用单独的选项设置代理类型，使用`CURLOPT_PROXYTYPE`。同样，您可以使用`CURLOPT_PROXYPORT`设置要使用的代理端口号。
- en: Local or proxy name lookup
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地或代理名称解析
- en: In a section above you can see that different proxy setups allow the name resolving
    to be done by different parties involved in the transfer. You can in several cases
    either have the client resolve the server hostname and pass on the IP address
    to the proxy to connect to - which of course assumes that the name lookup works
    accurately on the client system - or you can hand over the name to the proxy to
    have the proxy resolve the name; converting it to an IP address to connect to.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的某个部分中，您可以看到不同的代理设置允许不同的参与方在传输中执行名称解析。在几种情况下，您可以选择让客户端解析服务器主机名并将IP地址传递给代理以连接，当然这假设名称查找在客户端系统上工作准确无误
    - 或者您可以将名称交给代理，让代理解析名称；将其转换为要连接的IP地址。
- en: When you are using an HTTP or HTTPS proxy, you always give the name to the proxy
    to resolve.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用HTTP或HTTPS代理时，您始终需要将名称提供给代理以进行解析。
- en: Which proxy?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪个代理？
- en: If your network connection requires the use of a proxy to reach the destination,
    you must figure this out and tell libcurl to use the correct proxy. There is no
    support in libcurl to make it automatically figure out or detect a proxy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网络连接需要使用代理来访问目标，您必须找出这一点，并告诉libcurl使用正确的代理。libcurl没有自动确定或检测代理的支持。
- en: When using a browser, it is popular to provide the proxy with a PAC script or
    other means but none of those are recognized by libcurl.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用浏览器时，提供代理PAC脚本或其他方式是很常见的，但libcurl不识别这些方式。
- en: Proxy environment variables
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理环境变量
- en: If no proxy option has been set, libcurl checks for the existence of specially
    named environment variables before it performs its transfer to see if a proxy
    is requested to get used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置代理选项，libcurl 在执行传输之前会检查是否存在特别命名的环境变量，以查看是否请求使用代理。
- en: 'You can specify the proxy by setting a variable named `[scheme]_proxy` to hold
    the proxy hostname (the same way you would specify the host with `-x`). If you
    want to tell curl to use a proxy when accessing an HTTP server, you set the `http_proxy`
    environment variable. Like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置一个名为 `[scheme]_proxy` 的变量来指定代理主机名（与使用 `-x` 指定主机的方式相同）。如果你想告诉 curl 在访问
    HTTP 服务器时使用代理，你设置 `http_proxy` 环境变量。如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The proxy example above is for HTTP, but can of course also set `ftp_proxy`,
    `https_proxy`, and so on for the specific protocols you want to proxy. All these
    proxy environment variable names except http_proxy can also be specified in uppercase,
    like `HTTPS_PROXY`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代理示例是针对 HTTP 的，但当然也可以为想要代理的特定协议设置 `ftp_proxy`、`https_proxy` 等等。除了 http_proxy
    之外，所有这些代理环境变量名称也可以用大写指定，例如 `HTTPS_PROXY`。
- en: To set a single variable that controls *all* protocols, the `ALL_PROXY` exists.
    If a specific protocol variable one exists, such a one takes precedence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个控制所有协议的单个变量，存在 `ALL_PROXY`。如果存在特定的协议变量，则该变量具有优先级。
- en: When using environment variables to set a proxy, you could easily end up in
    a situation where one or a few hostnames should be excluded from going through
    the proxy. This can be done with the `NO_PROXY` variable - or the corresponding
    `CURLOPT_NOPROXY` libcurl option. Set that to a comma-separated list of hostnames
    that should not use a proxy when being accessed. You can set NO_PROXY to be a
    single asterisk (‘*’) to match all hosts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用环境变量设置代理时，你可能会遇到一种情况，即一个或几个主机名应该被排除在代理之外。这可以通过 `NO_PROXY` 变量或相应的 `CURLOPT_NOPROXY`
    libcurl 选项来实现。将 `NO_PROXY` 设置为一个以逗号分隔的主机名列表，这些主机名在访问时不应使用代理。你可以将 NO_PROXY 设置为单个星号（‘*’）以匹配所有主机。
- en: HTTP proxy
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 代理
- en: The HTTP protocol details exactly how an HTTP proxy should be used. Instead
    of sending the request to the actual remote server, the client (libcurl) instead
    asks the proxy for the specific resource. The connection to the HTTP proxy is
    made using plain unencrypted HTTP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议详细说明了如何使用 HTTP 代理。客户端（libcurl）不是将请求发送到实际远程服务器，而是请求代理提供特定资源。与 HTTP 代理的连接使用未加密的普通
    HTTP。
- en: If an HTTPS resource is requested, libcurl instead issues a `CONNECT` request
    to the proxy. Such a request opens a tunnel through the proxy, where it passes
    data through without understanding it. This way, libcurl can establish a secure
    end-to-end TLS connection even when an HTTP proxy is present.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求 HTTPS 资源，libcurl 将会向代理发送一个 `CONNECT` 请求。这样的请求通过代理打开一个隧道，其中数据通过隧道传输而不被理解。这样，即使存在
    HTTP 代理，libcurl 也能建立安全的端到端 TLS 连接。
- en: You *can* proxy non-HTTP protocols over an HTTP proxy, but since this is mostly
    done by the CONNECT method to tunnel data through it requires that the proxy is
    configured to allow the client to connect to those other particular remote port
    numbers. Many HTTP proxies are setup to inhibit connections to other port numbers
    than 80 and 443.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 HTTP 代理上代理非 HTTP 协议，但这是通过 CONNECT 方法通过它进行隧道传输来完成的，因此需要代理配置为允许客户端连接到那些特定的远程端口号。许多
    HTTP 代理被设置为禁止连接到 80 和 443 之外的端口号。
- en: HTTPS proxy
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS 代理
- en: An HTTPS proxy is similar to an HTTP proxy but allows the client to connect
    to it using a secure HTTPS connection. Since the proxy connection is separate
    from the connection to the remote site even in this situation, as HTTPS to the
    remote site is tunneled through the HTTPS connection to the proxy, libcurl provides
    a whole set of TLS options for the proxy connection that are separate from the
    connection to the remote host.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 代理类似于 HTTP 代理，但允许客户端使用安全的 HTTPS 连接连接到它。由于在这种情况下代理连接与远程站点的连接是分开的，即使在这种情况下，HTTPS
    到远程站点的连接也是通过代理的 HTTPS 连接进行隧道传输的，因此 libcurl 为代理连接提供了一整套与远程主机连接分开的 TLS 选项。
- en: For example, `CURLOPT_PROXY_CAINFO` is the same functionality for the HTTPS
    proxy as `CURLOPT_CAINFO` is for the remote host. `CURLOPT_PROXY_SSL_VERIFYPEER`
    is the proxy version of `CURLOPT_SSL_VERIFYPEER` and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`CURLOPT_PROXY_CAINFO` 对于 HTTPS 代理的功能与 `CURLOPT_CAINFO` 对于远程主机相同。`CURLOPT_PROXY_SSL_VERIFYPEER`
    是 `CURLOPT_SSL_VERIFYPEER` 的代理版本，等等。
- en: HTTPS proxies are still today fairly unusual in organizations and companies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到今天为止，HTTPS 代理在组织和公司中仍然相当不常见。
- en: Proxy authentication
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理认证
- en: Authentication with a proxy means that you need to provide valid credentials
    in the handshake negotiation with the proxy itself. The proxy authentication is
    then in addition to and separate of the possible authentication or lack of authentication
    with the remote host.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理进行身份验证意味着您需要在与代理本身的握手协商中提供有效的凭据。然后，代理身份验证是在可能的远程主机身份验证或缺乏身份验证的基础上额外进行的。
- en: libcurl supports authentication with HTTP, HTTPS and SOCKS5 proxies. The key
    option is then `CURLOPT_PROXYUSERPWD` which sets the username and password to
    use - unless you set it within the `CURLOPT_PROXY` string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 支持 HTTP、HTTPS 和 SOCKS5 代理的身份验证。关键选项是 `CURLOPT_PROXYUSERPWD`，它设置要使用的用户名和密码
    - 除非您在 `CURLOPT_PROXY` 字符串中设置它。
- en: HTTP Proxy headers
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 代理头部
- en: With an HTTP or HTTP proxy, libcurl issues a request to the proxy that includes
    a set of headers. An application can of course modify the headers, just like for
    requests sent to servers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP 或 HTTP 代理时，libcurl 会向代理发送一个包含一组头部的请求。当然，应用程序可以修改这些头部，就像向服务器发送请求一样。
- en: libcurl offers the `CURLOPT_PROXYHEADER` for controlling the headers that are
    sent to a proxy **when there is a separate request sent to the server**. This
    typically means the initial `CONNECT` request sent to a proxy for setting up a
    tunnel through the proxy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 提供了 `CURLOPT_PROXYHEADER` 以控制发送到代理的头部 **当向服务器发送单独的请求时**。这通常意味着发送到代理的初始
    `CONNECT` 请求，用于通过代理设置隧道。
