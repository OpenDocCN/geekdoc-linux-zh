<html><head></head><body>
    <div style="page-break-after: always;"/>
    <h1>The <code>nc</code> command</h1>
    <p>The <code>nc</code> (or netcat) command is used to perform any operation involving TCP (Transmission Control Protocol, connection oriented), UDP (User Datagram Protocol, connection-less, no guarantee of data delivery) or UNIX-domain sockets. It can be thought of as swiss-army knife for communication protocol utilities.</p>
    <h3>Syntax:</h3>
    <pre>
      <code class="language- hljs " data-lang="">nc [options] [ip] [port]
</code>
    </pre>
    <h3>Examples:</h3>
    <h4>1. Open a TCP connection to port 80 of host, using port 1337 as source port with timeout of 5s:</h4>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ nc -p 1337 -w 5 host.ip 80
</code>
    </pre>
    <h4>2. Open a UDP connection to port 80 on host:</h4>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ nc -u host.ip 80
</code>
    </pre>
    <h4>3. Create and listen on UNIX-domain stream socket:</h4>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ nc -lU /var/tmp/dsocket
</code>
    </pre>
    <h4>4. Create a basic server/client model:</h4>
    <p>This creates a connection, with no specific server/client sides with respect to nc, once the connection is established.</p>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ nc -l 1234 <span class="hljs-comment"># in one console</span>

$ nc 127.0.0.1 1234 <span class="hljs-comment"># in another console</span>
</code>
    </pre>
    <h4>5. Build a basic data transfer model:</h4>
    <p>After the file has been transferred, sequentially, the connection closes automatically</p>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ nc -l 1234 &gt; filename.out <span class="hljs-comment"># to start listening in one console and collect data</span>

$ nc host.ip 1234 &lt; filename.in
</code>
    </pre>
    <h4>6. Talk to servers:</h4>
    <p>Basic example of retrieving the homepage of the host, along with headers.</p>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ <span class="hljs-built_in">printf</span>Â <span class="hljs-string">"GET / HTTP/1.0\r\n\r\n"</span> | nc host.ip 80
</code>
    </pre>
    <h4>7. Port scanning:</h4>
    <p>Checking which ports are open and running services on target machines. <code>-z</code> flag commands to inform about those rather than initiate a connection.</p>
    <pre>
      <code class="language-bash hljs bash" data-lang="bash">$ nc -zv host.ip 20-2000 <span class="hljs-comment"># range of ports to check for</span>
</code>
    </pre>
    <h3>Flags and their Functionalities:</h3>
    <table>
      <thead>
        <tr>
          <th>
            <strong>Short Flag</strong>
          </th>
          <th>
            <strong>Description</strong>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <code>-4</code>
          </td>
          <td>Forces nc to use IPv4 addresses</td>
        </tr>
        <tr>
          <td>
            <code>-6</code>
          </td>
          <td>Forces nc to use IPv6 addresses</td>
        </tr>
        <tr>
          <td>
            <code>-b</code>
          </td>
          <td>Allow broadcast</td>
        </tr>
        <tr>
          <td>
            <code>-D</code>
          </td>
          <td>Enable debugging on the socket</td>
        </tr>
        <tr>
          <td>
            <code>-i</code>
          </td>
          <td>Specify time interval delay between lines sent and received</td>
        </tr>
        <tr>
          <td>
            <code>-k</code>
          </td>
          <td>Stay listening for another connection after current is over</td>
        </tr>
        <tr>
          <td>
            <code>-l</code>
          </td>
          <td>Listen for incoming connection instead of initiate one to remote</td>
        </tr>
        <tr>
          <td>
            <code>-T</code>
          </td>
          <td>Specify length of TCP</td>
        </tr>
        <tr>
          <td>
            <code>-p</code>
          </td>
          <td>Specify source port to be used</td>
        </tr>
        <tr>
          <td>
            <code>-r</code>
          </td>
          <td>Specify source and/or destination ports randomly</td>
        </tr>
        <tr>
          <td>
            <code>-s</code>
          </td>
          <td>Specify IP of interface which is used to send the packets</td>
        </tr>
        <tr>
          <td>
            <code>-U</code>
          </td>
          <td>Use UNIX-domain sockets</td>
        </tr>
        <tr>
          <td>
            <code>-u</code>
          </td>
          <td>Use UDP instead of TCP as protocol</td>
        </tr>
        <tr>
          <td>
            <code>-w</code>
          </td>
          <td>Declare a timeout threshold for idle or unestablished connections</td>
        </tr>
        <tr>
          <td>
            <code>-x</code>
          </td>
          <td>Should use specified protocol when talking to proxy server</td>
        </tr>
        <tr>
          <td>
            <code>-z</code>
          </td>
          <td>Specify to scan for listening daemons, without sending any data</td>
        </tr>
      </tbody>
    </table>
  </body></html>