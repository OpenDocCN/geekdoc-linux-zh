<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch214.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="transfers__callbacks__write__md-_-_-write-data" class="level1" data-number="213">
<h1 data-number="213">Write data</h1>
<p>The write callback is set with <code>CURLOPT_WRITEFUNCTION</code>:</p>
<pre><code>curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_callback);</code></pre>
<p>The <code>write_callback</code> function must match this prototype:</p>
<pre><code>size_t write_callback(char *ptr, size_t size, size_t nmemb,
                      void *userdata);</code></pre>
<p>This callback function gets called by libcurl as soon as there is data received that needs to be saved. <em>ptr</em> points to the delivered data, and the size of that data is <em>size</em> multiplied with <em>nmemb</em>.</p>
<p>If this callback is not set, libcurl instead uses ‘fwrite’ by default.</p>
<p>The write callback is passed as much data as possible in all invokes, but it must not make any assumptions. It may be one byte, it may be thousands. The maximum amount of body data that is passed to the write callback is defined in the curl.h header file: <code>CURL_MAX_WRITE_SIZE</code> (the usual default is 16KB). If <code>CURLOPT_HEADER</code> is enabled for this transfer, which makes header data get passed to the write callback, you can get up to <code>CURL_MAX_HTTP_HEADER</code> bytes of header data passed into it. This usually means 100KB.</p>
<p>This function may be called with zero bytes data if the transferred file is empty.</p>
<p>The data passed to this function is not be zero terminated. You cannot, for example, use printf’s <code>%s</code> operator to display the contents nor strcpy to copy it.</p>
<p>This callback should return the number of bytes actually taken care of. If that number differs from the number passed to your callback function, it signals an error condition to the library. This causes the transfer to get aborted and the libcurl function used returns <code>CURLE_WRITE_ERROR</code>.</p>
<p>The user pointer passed in to the callback in the <em>userdata</em> argument is set with <code>CURLOPT_WRITEDATA</code>:</p>
<pre><code>curl_easy_setopt(handle, CURLOPT_WRITEDATA, custom_pointer);</code></pre>
<section id="transfers__callbacks__write__md-_-_-store-in-memory" class="level2" data-number="213.1">
<h2 data-number="213.1">Store in memory</h2>
<p>A popular demand is to store the retrieved response in memory, and the callback explained above supports that. When doing this, just be careful as the response can potentially be enormous.</p>
<p>You implement the callback in a manner similar to:</p>
<pre><code>struct response {
  char *memory;
  size_t size;
};

static size_t
mem_cb(void *contents, size_t size, size_t nmemb, void *userp)
{
  size_t realsize = size * nmemb;
  struct response *mem = (struct response *)userp;

  char *ptr = realloc(mem-&gt;memory, mem-&gt;size + realsize + 1);
  if(!ptr) {
    /* out of memory! */
    printf(&quot;not enough memory (realloc returned NULL)\n&quot;);
    return 0;
  }

  mem-&gt;memory = ptr;
  memcpy(&amp;(mem-&gt;memory[mem-&gt;size]), contents, realsize);
  mem-&gt;size += realsize;
  mem-&gt;memory[mem-&gt;size] = 0;

  return realsize;
}

int main()
{
  struct response chunk = {.memory = malloc(0),
                           .size = 0};

  /* send all data to this function  */
  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, mem_cb);

  /* we pass our &#39;chunk&#39; to the callback function */
  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&amp;chunk);

  free(chunk.memory);
}</code></pre>
<p><span id="transfers__callbacks__read__md"></span></p>
</section>
</section>
</body>
</html>
