<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch234.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="transfers__conn__reuse__md-_-_-connection-reuse" class="level1" data-number="233">
<h1 data-number="233">Connection reuse</h1>
<p>libcurl keeps a pool of old connections alive. When one transfer has completed it keeps N connections alive in a connection pool (sometimes also called connection cache) so that a subsequent transfer that happens to be able to reuse one of the existing connections can use it instead of creating a new one. Reusing a connection instead of creating a new one offers significant benefits in speed and required resources.</p>
<p>When libcurl is about to make a new connection for the purposes of doing a transfer, it first checks to see if there is an existing connection in the pool that it can reuse instead. The connection re-use check is done before any DNS or other name resolving mechanism is used, so it is purely hostname based. If there is an existing live connection to the right hostname, a lot of other properties (port number, protocol, etc) are also checked to see that it can be used.</p>
<section id="transfers__conn__reuse__md-_-_-easy-api-pool" class="level2" data-number="233.1">
<h2 data-number="233.1">Easy API pool</h2>
<p>When you are using the easy API, or, more specifically, <code>curl_easy_perform()</code>, libcurl keeps the pool associated with the specific easy handle. Then reusing the same easy handle ensures libcurl can reuse its connection.</p>
</section>
<section id="transfers__conn__reuse__md-_-_-multi-api-pool" class="level2" data-number="233.2">
<h2 data-number="233.2">Multi API pool</h2>
<p>When you are using the multi API, the connection pool is instead kept associated with the multi handle. This allows you to cleanup and re-create easy handles freely without risking losing the connection pool, and it allows the connection used by one easy handle to get reused by a separate one in a later transfer. Just reuse the multi handle.</p>
</section>
<section id="transfers__conn__reuse__md-_-_-sharing-the-connection-cache" class="level2" data-number="233.3">
<h2 data-number="233.3">Sharing the connection cache</h2>
<p>Since libcurl 7.57.0, applications can use the <a href="ch257.xhtml#helpers__sharing__md">share interface</a> to have otherwise independent transfers share the same connection pool.</p>
</section>
<section id="transfers__conn__reuse__md-_-_-when-connections-are-not-reused-as-you-want" class="level2" data-number="233.4">
<h2 data-number="233.4">When connections are not reused as you want</h2>
<p>libcurl will automatically and always try to reuse connections unless explicitly told not to. There are however several reasons why a connection is <em>not</em> used for a subsequent transfer.</p>
<ul>
<li><p>The server signals that the connection will be closed after this transfer. For example by using the <code>Connection: close</code> HTTP response header or a HTTP/2 or HTTP/3 “go away” frame.</p></li>
<li><p>The HTTP/1 response of a transfer is sent in such a way that a connection close is the only way to detect the end of the body. Or just an HTTP/1 receive error that makes curl deem that it cannot safely reuse the connection anymore.</p></li>
<li><p>The connection is deemed “dead” when libcurl tries to reuse it. It might happen when the server side has closed the connection after the previous transfer was completed. It can also happen if a stateful firewall/NAT or something in the network path drops the connection or if there is HTTP/2 or HTTP/3 traffic (like PING frames) over the connection when unattended.</p></li>
<li><p>The previous transfer is deemed too old to reuse. If <code>CURLOPT_MAXLIFETIME_CONN</code> is set, libcurl will not reuse a connection that is older than the set value in seconds.</p></li>
<li><p>The previous transfer is deemed having idled for too long. By default libcurl never attempts to reuse a connection that has been idle for more than 118 seconds. This time can be changed with <code>CURLOPT_MAXAGE_CONN</code>.</p></li>
<li><p>If the connection pool is full when a transfer ends and a new connection is about to get stored there, the oldest idle connection in the pool is closed and discarded and therefore cannot be reused anymore. Increase the connection pool size with <code>CURLMOPT_MAXCONNECTS</code> or <code>CURLOPT_MAXCONNECTS</code>, depending on which API you are using.</p></li>
<li><p>When using the multi interface, if the previous transfer has not ended when the next transfer is started, and the previous connection cannot be used for multiplexing.</p></li>
</ul>
<p>Etc. Usually you can learn about the reason by enabling <code>CURLOPT_VERBOSE</code> and inspecting what libcurl informs the application.</p>
<p><span id="transfers__conn__names__md"></span></p>
</section>
</section>
</body>
</html>
