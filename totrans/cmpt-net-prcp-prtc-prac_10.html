<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Routing in IP networks#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Routing in IP networks#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/networks/routing.html">https://4ed.computer-networking.info/syllabus/default/networks/routing.html</a></blockquote>

<p>In a large IP network such as the global Internet, routers need to exchange routing information. The Internet is an interconnection of networks, often called domains, that are under different responsibilities. As of 2025, the Internet is composed on more than 100,000 different domains and this number is still growing <a class="footnote-reference brackets" href="#fas" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. A domain can be a small enterprise that manages a few routers in a single building, a larger enterprise with a hundred routers at multiple locations, or a large Internet Service Provider managing thousands of routers. Two classes of routing protocols are used to allow these domains to efficiently exchange routing information.</p>
<figure class="align-center" id="id16">
<a class="reference internal image-reference" href="../_images/small-internet.png"><img alt="../_images/small-internet.png" src="../Images/1bcab7d617ca420273763701fade6b20.png" style="width: 470.4px; height: 227.49999999999997px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/small-internet.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 145 </span><span class="caption-text">Organization of a small Internet</span><a class="headerlink" href="#id16" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The first class of routing protocols are the <cite>intradomain routing protocols</cite> (sometimes also called the interior gateway protocols or <a class="reference internal" href="../glossary.html#term-IGP"><span class="xref std std-term">IGP</span></a>). An intradomain routing protocol is used by all routers inside a domain to exchange routing information about the destinations that are reachable inside the domain. There are several intradomain routing protocols. Some domains use <a class="reference internal" href="../glossary.html#term-RIP"><span class="xref std std-term">RIP</span></a>, which is a distance vector protocol. Other domains use link-state routing protocols such as <a class="reference internal" href="../glossary.html#term-OSPF"><span class="xref std std-term">OSPF</span></a> or <a class="reference internal" href="../glossary.html#term-IS-IS"><span class="xref std std-term">IS-IS</span></a>. Finally, some domains use static routing or proprietary protocols such as <a class="reference internal" href="../glossary.html#term-IGRP"><span class="xref std std-term">IGRP</span></a> or <a class="reference internal" href="../glossary.html#term-EIGRP"><span class="xref std std-term">EIGRP</span></a>.</p>
<p>These intradomain routing protocols usually have two objectives. First, they distribute routing information that corresponds to the shortest path between two routers in the domain. Second, they should allow the routers to quickly recover from link and router failures.</p>
<p>The second class of routing protocols are the <cite>interdomain routing protocols</cite> (sometimes also called the exterior gateway protocols or <a class="reference internal" href="../glossary.html#term-EGP"><span class="xref std std-term">EGP</span></a>). The objective of an interdomain routing protocol is to distribute routing information between domains. For scalability reasons, an interdomain routing protocol must distribute aggregated routing information and considers each domain as a black box.</p>
<p>A very important difference between intradomain and interdomain routing are the <cite>routing policies</cite> that are used by each domain. Inside a single domain, all routers are considered equal, and when several routes are available to reach a given destination prefix, the best route is selected based on technical criteria such as the route with the shortest delay, the route with the minimum number of hops or the route with the highest bandwidth.</p>
<p>When we consider the interconnection of domains that are managed by different organizations, this is no longer true. Each domain implements its own routing policy. A routing policy is composed of three elements : an <cite>import filter</cite> that specifies which routes can be accepted by a domain, an <cite>export filter</cite> that specifies which routes can be advertised by a domain and a ranking algorithm that selects the best route when a domain knows several routes towards the same destination prefix. As we will see later, another important difference is that the objective of the interdomain routing protocol is to find the <cite>cheapest</cite> route towards each destination. There is only one interdomain routing protocol : <a class="reference internal" href="../glossary.html#term-BGP"><span class="xref std std-term">BGP</span></a>.</p>
<section id="intradomain-routing">
<h2>Intradomain routing<a class="headerlink" href="#intradomain-routing" title="Link to this heading">#</a></h2>
<p>In this section, we briefly describe the key features of the two main intradomain unicast routing protocols : RIP and OSPF. The basic principles of distance vector and link-state routing have been presented earlier.</p>
<section id="rip">
<span id="index-0"/><h3>RIP<a class="headerlink" href="#rip" title="Link to this heading">#</a></h3>
<p>The Routing Information Protocol (RIP) is the simplest routing protocol that was standardized for the TCP/IP protocol suite. RIP is defined in <span class="target" id="index-1"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>. Additional information about RIP may be found in <a class="reference internal" href="../bibliography.html#malkin1999" id="id2"><span>[Malkin1999]</span></a>.</p>
<p>RIP routers periodically exchange RIP messages. The format of these messages is shown below. A RIP message is sent inside a UDP segment whose destination port is set to <cite>521</cite>. A RIP message contains several fields. The <cite>command</cite> field indicates whether the RIP message is a request or a response. When a router boots, its routing table is empty and it cannot forward any packet. To speedup the discovery of the network, it can send a request message to the RIP IPv6 multicast address, <code class="docutils literal notranslate"><span class="pre">FF02::9</span></code>. All RIP routers listen to this multicast address and any router attached to the subnet will reply by sending its own routing table as a sequence of RIP messages. In steady state, routers multicast one of more RIP response messages every 30 seconds. These messages contain the distance vectors that summarize the router’s routing table. The current version of RIP is version 2 defined in <span class="target" id="index-2"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a> for IPv4 and <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> for IPv6.</p>
<figure class="align-center" id="id17">
<a class="reference internal image-reference" href="../_images/ripng.svg"><img alt="../_images/ripng.svg" src="../Images/6db6a4a10d1008fa61d614059970a21a.png" style="width: 715.1999999999999px; height: 326.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ripng.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 146 </span><span class="caption-text">The RIP message format</span><a class="headerlink" href="#id17" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Each RIP message contains a set of route entries. Each route entry is encoded as a 20 bytes field whose format is shown below. RIP was initially designed to be suitable for different network layer protocols. Some implementations of RIP were used in XNS or IPX networks <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>. The format of the route entries used by <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> is shown below. <cite>Prefix length</cite> is the length of the subnet identifier in bits and the <cite>metric</cite> is encoded as one byte. The maximum metric supported by RIP is <cite>15</cite>.</p>
<figure class="align-center" id="id18">
<a class="reference internal image-reference" href="../_images/rip-route-entry-v6.svg"><img alt="../_images/rip-route-entry-v6.svg" src="../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png" style="width: 715.1999999999999px; height: 192.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/rip-route-entry-v6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 147 </span><span class="caption-text">Format of the RIP IPv6 route entries</span><a class="headerlink" href="#id18" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A note on timers</p>
<p>The first RIP implementations sent their distance vector exactly every 30 seconds. This worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time <a class="reference internal" href="../bibliography.html#fj1994" id="id3"><span>[FJ1994]</span></a>. They collected packet traces in these networks and found that after some time the routers’ timers became synchronized, i.e. almost all routers were sending their distance vectors at almost the same time. This synchronization of the transmission times of the distance vectors caused an overload on the routers’ CPU but also increased the convergence time of the protocol in some cases. This was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. <a class="reference external" href="https://www.icir.org/floyd/">Sally Floyd</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Van_Jacobson">Van Jacobson</a> proposed in <a class="reference internal" href="../bibliography.html#fj1994" id="id4"><span>[FJ1994]</span></a> a simple solution to solve this synchronization problem. Instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a>. This randomization of the delays prevents the synchronization that occurs with a fixed delay and is now a recommended practice for protocol designers.</p>
</div>
</section>
<section id="ospf">
<span id="index-7"/><h3>OSPF<a class="headerlink" href="#ospf" title="Link to this heading">#</a></h3>
<p>Link-state routing protocols are used in IP networks. Open Shortest Path First (OSPF), defined in <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>, is the link state routing protocol that has been standardized by the IETF. The last version of OSPF, which supports IPv6, is defined in <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5340.html"><strong>RFC 5340</strong></a>. OSPF is frequently used in enterprise networks and in some ISP networks. However, ISP networks often use the IS-IS link-state routing protocol <a class="reference internal" href="../bibliography.html#iso10589" id="id5"><span>[ISO10589]</span></a> , which was developed for the ISO CLNP protocol but was adapted to be used in IP <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1195.html"><strong>RFC 1195</strong></a> networks before the finalization of the standardization of OSPF. A detailed analysis of ISIS and OSPF may be found in <a class="reference internal" href="../bibliography.html#bmo2006" id="id6"><span>[BMO2006]</span></a> and <a class="reference internal" href="../bibliography.html#perlman2000" id="id7"><span>[Perlman2000]</span></a>.  Additional information about OSPF may be found in <a class="reference internal" href="../bibliography.html#moy1998" id="id8"><span>[Moy1998]</span></a>.</p>
<p id="index-11">Compared to the basics of link-state routing protocols that we discussed in section <a class="reference internal" href="network.html#linkstate"><span class="std std-ref">Link state routing</span></a>, there are some particularities of OSPF that are worth discussing. First, in a large network, flooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. A better approach would be to introduce hierarchical routing. Hierarchical routing divides the network into regions. All the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. OSPF supports a restricted variant of hierarchical routing. In OSPF’s terminology, a region is called an <cite>area</cite>.</p>
<p>OSPF imposes restrictions on how a network can be divided into areas. An area is a set of routers and links that are grouped together. Usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area <a class="footnote-reference brackets" href="#fvirtual" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> . An OSPF area contains two types of routers <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Internal router : A router whose directly connected networks belong to the area</p></li>
<li><p>Area border routers : A router that is attached to several areas.</p></li>
</ul>
</div></blockquote>
<p>For example, the network shown in figure <a class="reference internal" href="#fig-ospf-areas"><span class="std std-numref">Fig. 148</span></a> has been divided into three areas : <cite>area 0</cite>, containing routers <cite>RA</cite>, <cite>RB</cite>, <cite>RC</cite> and <cite>RD</cite>, <cite>area 1</cite>, containing routers <cite>R1</cite>, <cite>R3</cite>, <cite>R4</cite>, <cite>R5</cite> and <cite>RA</cite>, and <cite>area 2</cite> containing <cite>R7</cite>, <cite>R8</cite>, <cite>R9</cite>, <cite>R10</cite>, <cite>RB</cite> and <cite>RC</cite>. OSPF areas are identified by a 32 bit integer, which is sometimes represented as an IP address. Among the OSPF areas, <cite>area 0</cite>, also called the <cite>backbone area</cite>, has a special role. The backbone area groups all the area border routers (routers <cite>RA</cite>, <cite>RB</cite> and <cite>RC</cite> in the figure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router <cite>RD</cite> in the figure below). An important restriction imposed by OSPF is that the path between two routers that belong to two different areas (e.g. <cite>R1</cite> and <cite>R8</cite> in the figure below) must pass through the backbone area.</p>
<figure class="align-center" id="id19">
<span id="fig-ospf-areas"/><a class="reference internal image-reference" href="../_images/ospf-areas.png"><img alt="../_images/ospf-areas.png" src="../Images/ecfc93d799f6e5b0786b740a7776fc54.png" style="width: 393.4px; height: 316.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ospf-areas.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 148 </span><span class="caption-text">OSPF areas</span><a class="headerlink" href="#id19" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Inside each non-backbone area, routers distribute the topology of the area by exchanging link state packets with the other routers in the area. The internal routers do not know the topology of other areas, but each router knows how to reach the backbone area. Inside an area, the routers only exchange link-state packets for all destinations that are reachable inside the area. In OSPF, the inter-area routing is done by exchanging distance vectors. This is illustrated by the network topology shown in figure <a class="reference internal" href="#fig-net-ospf-areas"><span class="std std-numref">Fig. 149</span></a>.</p>
<figure class="align-center" id="id20">
<span id="fig-net-ospf-areas"/><a class="reference internal image-reference" href="../_images/ospf-area.png"><img alt="../_images/ospf-area.png" src="../Images/e2e208cffe57552ed18b52f85b1655ab.png" style="width: 409.6px; height: 307.20000000000005px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ospf-area.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 149 </span><span class="caption-text">Hierarchical routing with OSPF</span><a class="headerlink" href="#id20" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Let us first consider OSPF routing inside <cite>area 2</cite>. All routers in the area learn a route towards <cite>2001:db8:1234::/48</cite> and <cite>2001:db8:5678::/48</cite>. The two area border routers, <cite>RB</cite> and <cite>RC</cite>, create network summary advertisements. Assuming that all links have a unit link metric, these would be:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>RB</cite> advertises <cite>2001:db8:1234::/48</cite> at a distance of <cite>2</cite> and <cite>2001:db8:5678::/48</cite> at a distance of <cite>3</cite></p></li>
<li><p><cite>RC</cite> advertises <cite>2001:db8:5678::/48</cite> at a distance of <cite>2</cite> and <cite>2001:db8:1234::/48</cite> at a distance of <cite>3</cite></p></li>
</ul>
</div></blockquote>
<p>These summary advertisements are flooded through the backbone area attached to routers <cite>RB</cite> and <cite>RC</cite>. In its routing table, router <cite>RA</cite> selects the summary advertised by <cite>RB</cite> to reach <cite>2001:db8:1234::/48</cite> and the summary advertised by <cite>RC</cite> to reach <cite>2001:db8:5678::/48</cite>. Inside <cite>area 1</cite>, router <cite>RA</cite> advertises a summary indicating that <cite>2001:db8:1234::/48</cite> and <cite>2001:db8:5678::/48</cite> are both at a distance of <cite>3</cite> from itself.</p>
<p>On the other hand, consider the prefixes <cite>2001:db8:aaaa:0000::/64</cite> and <cite>2001:db8:aaaa:0001::/64</cite> that are inside <cite>area 1</cite>. Router <cite>RA</cite> is the only area border router that is attached to this area. This router can create two different network summary advertisements :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>2001:db8:aaaa:0001::/64</cite> at a distance of <cite>1</cite> and <cite>2001:db8:aaaa:0000::/64</cite> at a distance of <cite>2</cite> from <cite>RA</cite></p></li>
<li><p><cite>2001:db8:aaaa:0000::/63</cite> at a distance of <cite>2</cite> from <cite>RA</cite></p></li>
</ul>
</div></blockquote>
<p>The first summary advertisement provides precise information about the distance used to reach each prefix. However, all routers in the network have to maintain a route towards <cite>2001:db8:aaaa:0000::/64</cite> and a route towards <cite>2001:db8:aaaa:0001::/64</cite> that are both via router <cite>RA</cite>. The second advertisement would improve the scalability of OSPF by reducing the number of routes that are advertised across area boundaries. However, in practice this requires manual configuration on the border routers.</p>
<p id="index-13">The second OSPF particularity that is worth discussing is the support of Local Area Networks (LAN). As shown in figure <a class="reference internal" href="#fig-ospf-lan"><span class="std std-numref">Fig. 150</span></a>, several routers may be attached to the same LAN.</p>
<div class="figure" id="id21" style="text-align: center">
<span id="fig-ospf-lan"/><p><img src="../Images/b61c40a915c22075c5f71b026344c0d8.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-fe58c6dc764c5af8bf29af79c26267de01731443.png"/></p>
<p><span class="caption-number">Fig. 150 </span><span class="caption-text">A LAN with routers</span></p>
</div><p>A first solution to support such a LAN with a link-state routing protocol would be to consider that a LAN is equivalent to a full-mesh of point-to-point links as if each router can directly reach any other router on the LAN. However, this approach has two important drawbacks :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Each router must exchange HELLOs and link state packets with all the other routers on the LAN. This increases the number of OSPF packets that are sent and processed by each router.</p></li>
<li><p>Remote routers, when looking at the topology distributed by OSPF, consider that there is a full-mesh of links between all the LAN routers. Such a full-mesh implies a lot of redundancy in case of failure, while in practice the entire LAN may completely fail. In case of a failure of the entire LAN, all routers need to detect the failures and flood link state packets before the LAN is completely removed from the OSPF topology by remote routers.</p></li>
</ol>
</div></blockquote>
<p>To better represent LANs and reduce the number of OSPF packets that are exchanged, OSPF handles LAN differently. When OSPF routers boot on a LAN, they elect <a class="footnote-reference brackets" href="#felection" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> one of them as the <cite>Designated Router (DR)</cite> <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>. The <cite>DR</cite> router <cite>represents</cite> the local area network, and advertises the LAN’s subnet. Furthermore, LAN routers only exchange HELLO packets with the <cite>DR</cite>. Thanks to the utilization of a <cite>DR</cite>, the topology of the LAN appears as a set of point-to-point links connected to the <cite>DR</cite> router.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>How to quickly detect a link failure ?</p>
<p>Network operators expect an OSPF network to be able to quickly recover from link or router failures <a class="reference internal" href="../bibliography.html#vpd2004" id="id11"><span>[VPD2004]</span></a>. In an OSPF network, the recovery after a failure is performed in three steps <a class="reference internal" href="../bibliography.html#ffeb2005" id="id12"><span>[FFEB2005]</span></a> :</p>
<blockquote>
<div><ul class="simple">
<li><p>the routers that are adjacent to the failure detect it quickly. The default solution is to rely on the regular exchange of HELLO packets. However, the interval between successive HELLOs is often set to 10 seconds… Setting the HELLO timer down to a few milliseconds is difficult as HELLO packets are created and processed by the main CPU of the routers and these routers cannot easily generate and process a HELLO packet every millisecond on each of their interfaces. A better solution is to use a dedicated failure detection protocol such as the Bidirectional Forwarding Detection (BFD) protocol defined in <a class="reference internal" href="../bibliography.html#kw2009" id="id13"><span>[KW2009]</span></a> that can be implemented directly on the router interfaces. Another solution to be able to detect the failure is to instrument the physical and the datalink layer so that they can interrupt the router when a link fails. Unfortunately, such a solution cannot be used on all types of physical and datalink layers.</p></li>
<li><p>the routers that have detected the failure flood their updated link state packets in the network</p></li>
<li><p>all routers update their routing table</p></li>
</ul>
</div></blockquote>
</div>
<p>A last, but operationally important, point needs to be discussed about intradomain routing protocols such as OSPF and IS-IS. Intradomain routing protocols always select the shortest path for each destination. In practice, there are often several equal paths towards the same destination. When a router computes several equal cost paths towards one destination, it can use these paths in different ways.</p>
<p>A first approach is to select one of the equal cost paths (e.g. the first or the last path found by the SPF computation) and install it in the forwarding table. In this case, only one path is used to reach each destination.</p>
<p>A second approach is to install all equal cost paths <a class="footnote-reference brackets" href="#fmaxpaths" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> in the forwarding table and load-balance the packets on the different paths. Consider the case where a router has <cite>N</cite> different outgoing interfaces to reach destination <cite>d</cite>. A first possibility to load-balance the traffic among these interfaces is to use <cite>round-robin</cite>. <cite>Round-robin</cite> allows equally balancing the packets among the <cite>N</cite> outgoing interfaces. This equal load-balancing is important in practice because it allows better spreading the load throughout the network. However, few networks use this <cite>round-robin</cite> strategy to load-balance traffic on routers. The main drawback of <cite>round-robin</cite> is that packets that belong to the same flow (e.g. TCP connection) may be forwarded over different paths. If packets belonging to the same TCP connection are sent over different paths, they will probably experience different delays and arrive out-of-sequence at their destination. When a TCP receiver detects out-of-order segments, it sends duplicate acknowledgments that may cause the sender to initiate a fast retransmission and enter congestion avoidance. Thus, out-of-order segments may lead to lower TCP performance. This is annoying for a load-balancing technique whose objective is to improve the network performance by spreading the load.</p>
<p>To efficiently spread the load over different paths, routers need to implement <cite>per-flow</cite> load-balancing. This implies that they must forward all the packets that belong to the same flow on the same path. Since a TCP connection is always identified by the four-tuple (source and destination addresses, source and destination ports), one possibility would be to select an outgoing interface upon arrival of the first packet of the flow and store this decision in the router’s memory. Unfortunately, such a solution does not scale since the required memory grows with the number of TCP connections that pass through the router.</p>
<p>Fortunately, it is possible to perform <cite>per-flow</cite> load balancing without maintaining any state on the router. Most routers today use hash functions for this purpose <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2991.html"><strong>RFC 2991</strong></a>. When a packet arrives, the router extracts the Next Header information and the four-tuple from the packet and computes :</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)</span></p>
</div></blockquote>
<p>In this formula, <cite>N</cite> is the number of outgoing interfaces on the equal cost paths towards the packet’s destination. Various hash functions are possible, including CRC, checksum or MD5 <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2991.html"><strong>RFC 2991</strong></a>. Since the hash function is computed over the four-tuple, the same hash value will be computed for all packets belonging to the same flow. This prevents reordering due to load balancing inside the network. Most routers support this kind of load-balancing today  <a class="reference internal" href="../bibliography.html#aco-2006" id="id15"><span>[ACO+2006]</span></a>.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://bgp.potaroo.net/index-as.html">http://bgp.potaroo.net/index-as.html</a> for reports on the evolution of the number of Autonomous Systems over time.</p>
</aside>
<aside class="footnote brackets" id="fvirtual" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">2</a><span class="fn-bracket">]</span></span>
<p>OSPF can support <cite>virtual links</cite> to connect routers together that belong to the same area but are not directly connected. However, this goes beyond this introduction to OSPF.</p>
</aside>
<aside class="footnote brackets" id="felection" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">3</a><span class="fn-bracket">]</span></span>
<p>The OSPF Designated Router election procedure is defined in <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>. Each router can be configured with a router priority that influences the election process since the router with the highest priority is preferred when an election is run.</p>
</aside>
<aside class="footnote brackets" id="fmaxpaths" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">4</a><span class="fn-bracket">]</span></span>
<p>In some networks, there are several dozens of paths towards a given destination. Some routers, due to hardware limitations, cannot install more than 8 or 16 paths in their forwarding table. In this case, a subset of the computed paths is installed in the forwarding table.</p>
</aside>
</aside>
</section>
</section>
&#13;

<h2>Intradomain routing<a class="headerlink" href="#intradomain-routing" title="Link to this heading">#</a></h2>
<p>In this section, we briefly describe the key features of the two main intradomain unicast routing protocols : RIP and OSPF. The basic principles of distance vector and link-state routing have been presented earlier.</p>
<section id="rip">
<span id="index-0"/><h3>RIP<a class="headerlink" href="#rip" title="Link to this heading">#</a></h3>
<p>The Routing Information Protocol (RIP) is the simplest routing protocol that was standardized for the TCP/IP protocol suite. RIP is defined in <span class="target" id="index-1"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>. Additional information about RIP may be found in <a class="reference internal" href="../bibliography.html#malkin1999" id="id2"><span>[Malkin1999]</span></a>.</p>
<p>RIP routers periodically exchange RIP messages. The format of these messages is shown below. A RIP message is sent inside a UDP segment whose destination port is set to <cite>521</cite>. A RIP message contains several fields. The <cite>command</cite> field indicates whether the RIP message is a request or a response. When a router boots, its routing table is empty and it cannot forward any packet. To speedup the discovery of the network, it can send a request message to the RIP IPv6 multicast address, <code class="docutils literal notranslate"><span class="pre">FF02::9</span></code>. All RIP routers listen to this multicast address and any router attached to the subnet will reply by sending its own routing table as a sequence of RIP messages. In steady state, routers multicast one of more RIP response messages every 30 seconds. These messages contain the distance vectors that summarize the router’s routing table. The current version of RIP is version 2 defined in <span class="target" id="index-2"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a> for IPv4 and <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> for IPv6.</p>
<figure class="align-center" id="id17">
<a class="reference internal image-reference" href="../_images/ripng.svg"><img alt="../_images/ripng.svg" src="../Images/6db6a4a10d1008fa61d614059970a21a.png" style="width: 715.1999999999999px; height: 326.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ripng.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 146 </span><span class="caption-text">The RIP message format</span><a class="headerlink" href="#id17" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Each RIP message contains a set of route entries. Each route entry is encoded as a 20 bytes field whose format is shown below. RIP was initially designed to be suitable for different network layer protocols. Some implementations of RIP were used in XNS or IPX networks <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>. The format of the route entries used by <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> is shown below. <cite>Prefix length</cite> is the length of the subnet identifier in bits and the <cite>metric</cite> is encoded as one byte. The maximum metric supported by RIP is <cite>15</cite>.</p>
<figure class="align-center" id="id18">
<a class="reference internal image-reference" href="../_images/rip-route-entry-v6.svg"><img alt="../_images/rip-route-entry-v6.svg" src="../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png" style="width: 715.1999999999999px; height: 192.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/rip-route-entry-v6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 147 </span><span class="caption-text">Format of the RIP IPv6 route entries</span><a class="headerlink" href="#id18" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A note on timers</p>
<p>The first RIP implementations sent their distance vector exactly every 30 seconds. This worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time <a class="reference internal" href="../bibliography.html#fj1994" id="id3"><span>[FJ1994]</span></a>. They collected packet traces in these networks and found that after some time the routers’ timers became synchronized, i.e. almost all routers were sending their distance vectors at almost the same time. This synchronization of the transmission times of the distance vectors caused an overload on the routers’ CPU but also increased the convergence time of the protocol in some cases. This was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. <a class="reference external" href="https://www.icir.org/floyd/">Sally Floyd</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Van_Jacobson">Van Jacobson</a> proposed in <a class="reference internal" href="../bibliography.html#fj1994" id="id4"><span>[FJ1994]</span></a> a simple solution to solve this synchronization problem. Instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a>. This randomization of the delays prevents the synchronization that occurs with a fixed delay and is now a recommended practice for protocol designers.</p>
</div>
</section>
<section id="ospf">
<span id="index-7"/><h3>OSPF<a class="headerlink" href="#ospf" title="Link to this heading">#</a></h3>
<p>Link-state routing protocols are used in IP networks. Open Shortest Path First (OSPF), defined in <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>, is the link state routing protocol that has been standardized by the IETF. The last version of OSPF, which supports IPv6, is defined in <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5340.html"><strong>RFC 5340</strong></a>. OSPF is frequently used in enterprise networks and in some ISP networks. However, ISP networks often use the IS-IS link-state routing protocol <a class="reference internal" href="../bibliography.html#iso10589" id="id5"><span>[ISO10589]</span></a> , which was developed for the ISO CLNP protocol but was adapted to be used in IP <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1195.html"><strong>RFC 1195</strong></a> networks before the finalization of the standardization of OSPF. A detailed analysis of ISIS and OSPF may be found in <a class="reference internal" href="../bibliography.html#bmo2006" id="id6"><span>[BMO2006]</span></a> and <a class="reference internal" href="../bibliography.html#perlman2000" id="id7"><span>[Perlman2000]</span></a>.  Additional information about OSPF may be found in <a class="reference internal" href="../bibliography.html#moy1998" id="id8"><span>[Moy1998]</span></a>.</p>
<p id="index-11">Compared to the basics of link-state routing protocols that we discussed in section <a class="reference internal" href="network.html#linkstate"><span class="std std-ref">Link state routing</span></a>, there are some particularities of OSPF that are worth discussing. First, in a large network, flooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. A better approach would be to introduce hierarchical routing. Hierarchical routing divides the network into regions. All the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. OSPF supports a restricted variant of hierarchical routing. In OSPF’s terminology, a region is called an <cite>area</cite>.</p>
<p>OSPF imposes restrictions on how a network can be divided into areas. An area is a set of routers and links that are grouped together. Usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area <a class="footnote-reference brackets" href="#fvirtual" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> . An OSPF area contains two types of routers <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Internal router : A router whose directly connected networks belong to the area</p></li>
<li><p>Area border routers : A router that is attached to several areas.</p></li>
</ul>
</div></blockquote>
<p>For example, the network shown in figure <a class="reference internal" href="#fig-ospf-areas"><span class="std std-numref">Fig. 148</span></a> has been divided into three areas : <cite>area 0</cite>, containing routers <cite>RA</cite>, <cite>RB</cite>, <cite>RC</cite> and <cite>RD</cite>, <cite>area 1</cite>, containing routers <cite>R1</cite>, <cite>R3</cite>, <cite>R4</cite>, <cite>R5</cite> and <cite>RA</cite>, and <cite>area 2</cite> containing <cite>R7</cite>, <cite>R8</cite>, <cite>R9</cite>, <cite>R10</cite>, <cite>RB</cite> and <cite>RC</cite>. OSPF areas are identified by a 32 bit integer, which is sometimes represented as an IP address. Among the OSPF areas, <cite>area 0</cite>, also called the <cite>backbone area</cite>, has a special role. The backbone area groups all the area border routers (routers <cite>RA</cite>, <cite>RB</cite> and <cite>RC</cite> in the figure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router <cite>RD</cite> in the figure below). An important restriction imposed by OSPF is that the path between two routers that belong to two different areas (e.g. <cite>R1</cite> and <cite>R8</cite> in the figure below) must pass through the backbone area.</p>
<figure class="align-center" id="id19">
<span id="fig-ospf-areas"/><a class="reference internal image-reference" href="../_images/ospf-areas.png"><img alt="../_images/ospf-areas.png" src="../Images/ecfc93d799f6e5b0786b740a7776fc54.png" style="width: 393.4px; height: 316.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ospf-areas.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 148 </span><span class="caption-text">OSPF areas</span><a class="headerlink" href="#id19" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Inside each non-backbone area, routers distribute the topology of the area by exchanging link state packets with the other routers in the area. The internal routers do not know the topology of other areas, but each router knows how to reach the backbone area. Inside an area, the routers only exchange link-state packets for all destinations that are reachable inside the area. In OSPF, the inter-area routing is done by exchanging distance vectors. This is illustrated by the network topology shown in figure <a class="reference internal" href="#fig-net-ospf-areas"><span class="std std-numref">Fig. 149</span></a>.</p>
<figure class="align-center" id="id20">
<span id="fig-net-ospf-areas"/><a class="reference internal image-reference" href="../_images/ospf-area.png"><img alt="../_images/ospf-area.png" src="../Images/e2e208cffe57552ed18b52f85b1655ab.png" style="width: 409.6px; height: 307.20000000000005px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ospf-area.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 149 </span><span class="caption-text">Hierarchical routing with OSPF</span><a class="headerlink" href="#id20" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Let us first consider OSPF routing inside <cite>area 2</cite>. All routers in the area learn a route towards <cite>2001:db8:1234::/48</cite> and <cite>2001:db8:5678::/48</cite>. The two area border routers, <cite>RB</cite> and <cite>RC</cite>, create network summary advertisements. Assuming that all links have a unit link metric, these would be:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>RB</cite> advertises <cite>2001:db8:1234::/48</cite> at a distance of <cite>2</cite> and <cite>2001:db8:5678::/48</cite> at a distance of <cite>3</cite></p></li>
<li><p><cite>RC</cite> advertises <cite>2001:db8:5678::/48</cite> at a distance of <cite>2</cite> and <cite>2001:db8:1234::/48</cite> at a distance of <cite>3</cite></p></li>
</ul>
</div></blockquote>
<p>These summary advertisements are flooded through the backbone area attached to routers <cite>RB</cite> and <cite>RC</cite>. In its routing table, router <cite>RA</cite> selects the summary advertised by <cite>RB</cite> to reach <cite>2001:db8:1234::/48</cite> and the summary advertised by <cite>RC</cite> to reach <cite>2001:db8:5678::/48</cite>. Inside <cite>area 1</cite>, router <cite>RA</cite> advertises a summary indicating that <cite>2001:db8:1234::/48</cite> and <cite>2001:db8:5678::/48</cite> are both at a distance of <cite>3</cite> from itself.</p>
<p>On the other hand, consider the prefixes <cite>2001:db8:aaaa:0000::/64</cite> and <cite>2001:db8:aaaa:0001::/64</cite> that are inside <cite>area 1</cite>. Router <cite>RA</cite> is the only area border router that is attached to this area. This router can create two different network summary advertisements :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>2001:db8:aaaa:0001::/64</cite> at a distance of <cite>1</cite> and <cite>2001:db8:aaaa:0000::/64</cite> at a distance of <cite>2</cite> from <cite>RA</cite></p></li>
<li><p><cite>2001:db8:aaaa:0000::/63</cite> at a distance of <cite>2</cite> from <cite>RA</cite></p></li>
</ul>
</div></blockquote>
<p>The first summary advertisement provides precise information about the distance used to reach each prefix. However, all routers in the network have to maintain a route towards <cite>2001:db8:aaaa:0000::/64</cite> and a route towards <cite>2001:db8:aaaa:0001::/64</cite> that are both via router <cite>RA</cite>. The second advertisement would improve the scalability of OSPF by reducing the number of routes that are advertised across area boundaries. However, in practice this requires manual configuration on the border routers.</p>
<p id="index-13">The second OSPF particularity that is worth discussing is the support of Local Area Networks (LAN). As shown in figure <a class="reference internal" href="#fig-ospf-lan"><span class="std std-numref">Fig. 150</span></a>, several routers may be attached to the same LAN.</p>
<div class="figure" id="id21" style="text-align: center">
<span id="fig-ospf-lan"/><p><img src="../Images/b61c40a915c22075c5f71b026344c0d8.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-fe58c6dc764c5af8bf29af79c26267de01731443.png"/></p>
<p><span class="caption-number">Fig. 150 </span><span class="caption-text">A LAN with routers</span></p>
</div><p>A first solution to support such a LAN with a link-state routing protocol would be to consider that a LAN is equivalent to a full-mesh of point-to-point links as if each router can directly reach any other router on the LAN. However, this approach has two important drawbacks :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Each router must exchange HELLOs and link state packets with all the other routers on the LAN. This increases the number of OSPF packets that are sent and processed by each router.</p></li>
<li><p>Remote routers, when looking at the topology distributed by OSPF, consider that there is a full-mesh of links between all the LAN routers. Such a full-mesh implies a lot of redundancy in case of failure, while in practice the entire LAN may completely fail. In case of a failure of the entire LAN, all routers need to detect the failures and flood link state packets before the LAN is completely removed from the OSPF topology by remote routers.</p></li>
</ol>
</div></blockquote>
<p>To better represent LANs and reduce the number of OSPF packets that are exchanged, OSPF handles LAN differently. When OSPF routers boot on a LAN, they elect <a class="footnote-reference brackets" href="#felection" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> one of them as the <cite>Designated Router (DR)</cite> <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>. The <cite>DR</cite> router <cite>represents</cite> the local area network, and advertises the LAN’s subnet. Furthermore, LAN routers only exchange HELLO packets with the <cite>DR</cite>. Thanks to the utilization of a <cite>DR</cite>, the topology of the LAN appears as a set of point-to-point links connected to the <cite>DR</cite> router.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>How to quickly detect a link failure ?</p>
<p>Network operators expect an OSPF network to be able to quickly recover from link or router failures <a class="reference internal" href="../bibliography.html#vpd2004" id="id11"><span>[VPD2004]</span></a>. In an OSPF network, the recovery after a failure is performed in three steps <a class="reference internal" href="../bibliography.html#ffeb2005" id="id12"><span>[FFEB2005]</span></a> :</p>
<blockquote>
<div><ul class="simple">
<li><p>the routers that are adjacent to the failure detect it quickly. The default solution is to rely on the regular exchange of HELLO packets. However, the interval between successive HELLOs is often set to 10 seconds… Setting the HELLO timer down to a few milliseconds is difficult as HELLO packets are created and processed by the main CPU of the routers and these routers cannot easily generate and process a HELLO packet every millisecond on each of their interfaces. A better solution is to use a dedicated failure detection protocol such as the Bidirectional Forwarding Detection (BFD) protocol defined in <a class="reference internal" href="../bibliography.html#kw2009" id="id13"><span>[KW2009]</span></a> that can be implemented directly on the router interfaces. Another solution to be able to detect the failure is to instrument the physical and the datalink layer so that they can interrupt the router when a link fails. Unfortunately, such a solution cannot be used on all types of physical and datalink layers.</p></li>
<li><p>the routers that have detected the failure flood their updated link state packets in the network</p></li>
<li><p>all routers update their routing table</p></li>
</ul>
</div></blockquote>
</div>
<p>A last, but operationally important, point needs to be discussed about intradomain routing protocols such as OSPF and IS-IS. Intradomain routing protocols always select the shortest path for each destination. In practice, there are often several equal paths towards the same destination. When a router computes several equal cost paths towards one destination, it can use these paths in different ways.</p>
<p>A first approach is to select one of the equal cost paths (e.g. the first or the last path found by the SPF computation) and install it in the forwarding table. In this case, only one path is used to reach each destination.</p>
<p>A second approach is to install all equal cost paths <a class="footnote-reference brackets" href="#fmaxpaths" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> in the forwarding table and load-balance the packets on the different paths. Consider the case where a router has <cite>N</cite> different outgoing interfaces to reach destination <cite>d</cite>. A first possibility to load-balance the traffic among these interfaces is to use <cite>round-robin</cite>. <cite>Round-robin</cite> allows equally balancing the packets among the <cite>N</cite> outgoing interfaces. This equal load-balancing is important in practice because it allows better spreading the load throughout the network. However, few networks use this <cite>round-robin</cite> strategy to load-balance traffic on routers. The main drawback of <cite>round-robin</cite> is that packets that belong to the same flow (e.g. TCP connection) may be forwarded over different paths. If packets belonging to the same TCP connection are sent over different paths, they will probably experience different delays and arrive out-of-sequence at their destination. When a TCP receiver detects out-of-order segments, it sends duplicate acknowledgments that may cause the sender to initiate a fast retransmission and enter congestion avoidance. Thus, out-of-order segments may lead to lower TCP performance. This is annoying for a load-balancing technique whose objective is to improve the network performance by spreading the load.</p>
<p>To efficiently spread the load over different paths, routers need to implement <cite>per-flow</cite> load-balancing. This implies that they must forward all the packets that belong to the same flow on the same path. Since a TCP connection is always identified by the four-tuple (source and destination addresses, source and destination ports), one possibility would be to select an outgoing interface upon arrival of the first packet of the flow and store this decision in the router’s memory. Unfortunately, such a solution does not scale since the required memory grows with the number of TCP connections that pass through the router.</p>
<p>Fortunately, it is possible to perform <cite>per-flow</cite> load balancing without maintaining any state on the router. Most routers today use hash functions for this purpose <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2991.html"><strong>RFC 2991</strong></a>. When a packet arrives, the router extracts the Next Header information and the four-tuple from the packet and computes :</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)</span></p>
</div></blockquote>
<p>In this formula, <cite>N</cite> is the number of outgoing interfaces on the equal cost paths towards the packet’s destination. Various hash functions are possible, including CRC, checksum or MD5 <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2991.html"><strong>RFC 2991</strong></a>. Since the hash function is computed over the four-tuple, the same hash value will be computed for all packets belonging to the same flow. This prevents reordering due to load balancing inside the network. Most routers support this kind of load-balancing today  <a class="reference internal" href="../bibliography.html#aco-2006" id="id15"><span>[ACO+2006]</span></a>.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://bgp.potaroo.net/index-as.html">http://bgp.potaroo.net/index-as.html</a> for reports on the evolution of the number of Autonomous Systems over time.</p>
</aside>
<aside class="footnote brackets" id="fvirtual" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">2</a><span class="fn-bracket">]</span></span>
<p>OSPF can support <cite>virtual links</cite> to connect routers together that belong to the same area but are not directly connected. However, this goes beyond this introduction to OSPF.</p>
</aside>
<aside class="footnote brackets" id="felection" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">3</a><span class="fn-bracket">]</span></span>
<p>The OSPF Designated Router election procedure is defined in <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>. Each router can be configured with a router priority that influences the election process since the router with the highest priority is preferred when an election is run.</p>
</aside>
<aside class="footnote brackets" id="fmaxpaths" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">4</a><span class="fn-bracket">]</span></span>
<p>In some networks, there are several dozens of paths towards a given destination. Some routers, due to hardware limitations, cannot install more than 8 or 16 paths in their forwarding table. In this case, a subset of the computed paths is installed in the forwarding table.</p>
</aside>
</aside>
</section>
&#13;

<span id="index-0"/><h3>RIP<a class="headerlink" href="#rip" title="Link to this heading">#</a></h3>
<p>The Routing Information Protocol (RIP) is the simplest routing protocol that was standardized for the TCP/IP protocol suite. RIP is defined in <span class="target" id="index-1"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>. Additional information about RIP may be found in <a class="reference internal" href="../bibliography.html#malkin1999" id="id2"><span>[Malkin1999]</span></a>.</p>
<p>RIP routers periodically exchange RIP messages. The format of these messages is shown below. A RIP message is sent inside a UDP segment whose destination port is set to <cite>521</cite>. A RIP message contains several fields. The <cite>command</cite> field indicates whether the RIP message is a request or a response. When a router boots, its routing table is empty and it cannot forward any packet. To speedup the discovery of the network, it can send a request message to the RIP IPv6 multicast address, <code class="docutils literal notranslate"><span class="pre">FF02::9</span></code>. All RIP routers listen to this multicast address and any router attached to the subnet will reply by sending its own routing table as a sequence of RIP messages. In steady state, routers multicast one of more RIP response messages every 30 seconds. These messages contain the distance vectors that summarize the router’s routing table. The current version of RIP is version 2 defined in <span class="target" id="index-2"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a> for IPv4 and <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> for IPv6.</p>
<figure class="align-center" id="id17">
<a class="reference internal image-reference" href="../_images/ripng.svg"><img alt="../_images/ripng.svg" src="../Images/6db6a4a10d1008fa61d614059970a21a.png" style="width: 715.1999999999999px; height: 326.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ripng.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 146 </span><span class="caption-text">The RIP message format</span><a class="headerlink" href="#id17" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Each RIP message contains a set of route entries. Each route entry is encoded as a 20 bytes field whose format is shown below. RIP was initially designed to be suitable for different network layer protocols. Some implementations of RIP were used in XNS or IPX networks <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2453.html"><strong>RFC 2453</strong></a>. The format of the route entries used by <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a> is shown below. <cite>Prefix length</cite> is the length of the subnet identifier in bits and the <cite>metric</cite> is encoded as one byte. The maximum metric supported by RIP is <cite>15</cite>.</p>
<figure class="align-center" id="id18">
<a class="reference internal image-reference" href="../_images/rip-route-entry-v6.svg"><img alt="../_images/rip-route-entry-v6.svg" src="../Images/c5da0371384a8fe4db87dd7f2d0fc80b.png" style="width: 715.1999999999999px; height: 192.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/rip-route-entry-v6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 147 </span><span class="caption-text">Format of the RIP IPv6 route entries</span><a class="headerlink" href="#id18" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A note on timers</p>
<p>The first RIP implementations sent their distance vector exactly every 30 seconds. This worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time <a class="reference internal" href="../bibliography.html#fj1994" id="id3"><span>[FJ1994]</span></a>. They collected packet traces in these networks and found that after some time the routers’ timers became synchronized, i.e. almost all routers were sending their distance vectors at almost the same time. This synchronization of the transmission times of the distance vectors caused an overload on the routers’ CPU but also increased the convergence time of the protocol in some cases. This was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. <a class="reference external" href="https://www.icir.org/floyd/">Sally Floyd</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Van_Jacobson">Van Jacobson</a> proposed in <a class="reference internal" href="../bibliography.html#fj1994" id="id4"><span>[FJ1994]</span></a> a simple solution to solve this synchronization problem. Instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2080.html"><strong>RFC 2080</strong></a>. This randomization of the delays prevents the synchronization that occurs with a fixed delay and is now a recommended practice for protocol designers.</p>
</div>
&#13;

<span id="index-7"/><h3>OSPF<a class="headerlink" href="#ospf" title="Link to this heading">#</a></h3>
<p>Link-state routing protocols are used in IP networks. Open Shortest Path First (OSPF), defined in <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>, is the link state routing protocol that has been standardized by the IETF. The last version of OSPF, which supports IPv6, is defined in <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5340.html"><strong>RFC 5340</strong></a>. OSPF is frequently used in enterprise networks and in some ISP networks. However, ISP networks often use the IS-IS link-state routing protocol <a class="reference internal" href="../bibliography.html#iso10589" id="id5"><span>[ISO10589]</span></a> , which was developed for the ISO CLNP protocol but was adapted to be used in IP <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1195.html"><strong>RFC 1195</strong></a> networks before the finalization of the standardization of OSPF. A detailed analysis of ISIS and OSPF may be found in <a class="reference internal" href="../bibliography.html#bmo2006" id="id6"><span>[BMO2006]</span></a> and <a class="reference internal" href="../bibliography.html#perlman2000" id="id7"><span>[Perlman2000]</span></a>.  Additional information about OSPF may be found in <a class="reference internal" href="../bibliography.html#moy1998" id="id8"><span>[Moy1998]</span></a>.</p>
<p id="index-11">Compared to the basics of link-state routing protocols that we discussed in section <a class="reference internal" href="network.html#linkstate"><span class="std std-ref">Link state routing</span></a>, there are some particularities of OSPF that are worth discussing. First, in a large network, flooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. A better approach would be to introduce hierarchical routing. Hierarchical routing divides the network into regions. All the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. OSPF supports a restricted variant of hierarchical routing. In OSPF’s terminology, a region is called an <cite>area</cite>.</p>
<p>OSPF imposes restrictions on how a network can be divided into areas. An area is a set of routers and links that are grouped together. Usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area <a class="footnote-reference brackets" href="#fvirtual" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> . An OSPF area contains two types of routers <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Internal router : A router whose directly connected networks belong to the area</p></li>
<li><p>Area border routers : A router that is attached to several areas.</p></li>
</ul>
</div></blockquote>
<p>For example, the network shown in figure <a class="reference internal" href="#fig-ospf-areas"><span class="std std-numref">Fig. 148</span></a> has been divided into three areas : <cite>area 0</cite>, containing routers <cite>RA</cite>, <cite>RB</cite>, <cite>RC</cite> and <cite>RD</cite>, <cite>area 1</cite>, containing routers <cite>R1</cite>, <cite>R3</cite>, <cite>R4</cite>, <cite>R5</cite> and <cite>RA</cite>, and <cite>area 2</cite> containing <cite>R7</cite>, <cite>R8</cite>, <cite>R9</cite>, <cite>R10</cite>, <cite>RB</cite> and <cite>RC</cite>. OSPF areas are identified by a 32 bit integer, which is sometimes represented as an IP address. Among the OSPF areas, <cite>area 0</cite>, also called the <cite>backbone area</cite>, has a special role. The backbone area groups all the area border routers (routers <cite>RA</cite>, <cite>RB</cite> and <cite>RC</cite> in the figure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router <cite>RD</cite> in the figure below). An important restriction imposed by OSPF is that the path between two routers that belong to two different areas (e.g. <cite>R1</cite> and <cite>R8</cite> in the figure below) must pass through the backbone area.</p>
<figure class="align-center" id="id19">
<span id="fig-ospf-areas"/><a class="reference internal image-reference" href="../_images/ospf-areas.png"><img alt="../_images/ospf-areas.png" src="../Images/ecfc93d799f6e5b0786b740a7776fc54.png" style="width: 393.4px; height: 316.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ospf-areas.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 148 </span><span class="caption-text">OSPF areas</span><a class="headerlink" href="#id19" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Inside each non-backbone area, routers distribute the topology of the area by exchanging link state packets with the other routers in the area. The internal routers do not know the topology of other areas, but each router knows how to reach the backbone area. Inside an area, the routers only exchange link-state packets for all destinations that are reachable inside the area. In OSPF, the inter-area routing is done by exchanging distance vectors. This is illustrated by the network topology shown in figure <a class="reference internal" href="#fig-net-ospf-areas"><span class="std std-numref">Fig. 149</span></a>.</p>
<figure class="align-center" id="id20">
<span id="fig-net-ospf-areas"/><a class="reference internal image-reference" href="../_images/ospf-area.png"><img alt="../_images/ospf-area.png" src="../Images/e2e208cffe57552ed18b52f85b1655ab.png" style="width: 409.6px; height: 307.20000000000005px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ospf-area.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 149 </span><span class="caption-text">Hierarchical routing with OSPF</span><a class="headerlink" href="#id20" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Let us first consider OSPF routing inside <cite>area 2</cite>. All routers in the area learn a route towards <cite>2001:db8:1234::/48</cite> and <cite>2001:db8:5678::/48</cite>. The two area border routers, <cite>RB</cite> and <cite>RC</cite>, create network summary advertisements. Assuming that all links have a unit link metric, these would be:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>RB</cite> advertises <cite>2001:db8:1234::/48</cite> at a distance of <cite>2</cite> and <cite>2001:db8:5678::/48</cite> at a distance of <cite>3</cite></p></li>
<li><p><cite>RC</cite> advertises <cite>2001:db8:5678::/48</cite> at a distance of <cite>2</cite> and <cite>2001:db8:1234::/48</cite> at a distance of <cite>3</cite></p></li>
</ul>
</div></blockquote>
<p>These summary advertisements are flooded through the backbone area attached to routers <cite>RB</cite> and <cite>RC</cite>. In its routing table, router <cite>RA</cite> selects the summary advertised by <cite>RB</cite> to reach <cite>2001:db8:1234::/48</cite> and the summary advertised by <cite>RC</cite> to reach <cite>2001:db8:5678::/48</cite>. Inside <cite>area 1</cite>, router <cite>RA</cite> advertises a summary indicating that <cite>2001:db8:1234::/48</cite> and <cite>2001:db8:5678::/48</cite> are both at a distance of <cite>3</cite> from itself.</p>
<p>On the other hand, consider the prefixes <cite>2001:db8:aaaa:0000::/64</cite> and <cite>2001:db8:aaaa:0001::/64</cite> that are inside <cite>area 1</cite>. Router <cite>RA</cite> is the only area border router that is attached to this area. This router can create two different network summary advertisements :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>2001:db8:aaaa:0001::/64</cite> at a distance of <cite>1</cite> and <cite>2001:db8:aaaa:0000::/64</cite> at a distance of <cite>2</cite> from <cite>RA</cite></p></li>
<li><p><cite>2001:db8:aaaa:0000::/63</cite> at a distance of <cite>2</cite> from <cite>RA</cite></p></li>
</ul>
</div></blockquote>
<p>The first summary advertisement provides precise information about the distance used to reach each prefix. However, all routers in the network have to maintain a route towards <cite>2001:db8:aaaa:0000::/64</cite> and a route towards <cite>2001:db8:aaaa:0001::/64</cite> that are both via router <cite>RA</cite>. The second advertisement would improve the scalability of OSPF by reducing the number of routes that are advertised across area boundaries. However, in practice this requires manual configuration on the border routers.</p>
<p id="index-13">The second OSPF particularity that is worth discussing is the support of Local Area Networks (LAN). As shown in figure <a class="reference internal" href="#fig-ospf-lan"><span class="std std-numref">Fig. 150</span></a>, several routers may be attached to the same LAN.</p>
<div class="figure" id="id21" style="text-align: center">
<span id="fig-ospf-lan"/><p><img src="../Images/b61c40a915c22075c5f71b026344c0d8.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-fe58c6dc764c5af8bf29af79c26267de01731443.png"/></p>
<p><span class="caption-number">Fig. 150 </span><span class="caption-text">A LAN with routers</span></p>
</div><p>A first solution to support such a LAN with a link-state routing protocol would be to consider that a LAN is equivalent to a full-mesh of point-to-point links as if each router can directly reach any other router on the LAN. However, this approach has two important drawbacks :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Each router must exchange HELLOs and link state packets with all the other routers on the LAN. This increases the number of OSPF packets that are sent and processed by each router.</p></li>
<li><p>Remote routers, when looking at the topology distributed by OSPF, consider that there is a full-mesh of links between all the LAN routers. Such a full-mesh implies a lot of redundancy in case of failure, while in practice the entire LAN may completely fail. In case of a failure of the entire LAN, all routers need to detect the failures and flood link state packets before the LAN is completely removed from the OSPF topology by remote routers.</p></li>
</ol>
</div></blockquote>
<p>To better represent LANs and reduce the number of OSPF packets that are exchanged, OSPF handles LAN differently. When OSPF routers boot on a LAN, they elect <a class="footnote-reference brackets" href="#felection" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> one of them as the <cite>Designated Router (DR)</cite> <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>. The <cite>DR</cite> router <cite>represents</cite> the local area network, and advertises the LAN’s subnet. Furthermore, LAN routers only exchange HELLO packets with the <cite>DR</cite>. Thanks to the utilization of a <cite>DR</cite>, the topology of the LAN appears as a set of point-to-point links connected to the <cite>DR</cite> router.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>How to quickly detect a link failure ?</p>
<p>Network operators expect an OSPF network to be able to quickly recover from link or router failures <a class="reference internal" href="../bibliography.html#vpd2004" id="id11"><span>[VPD2004]</span></a>. In an OSPF network, the recovery after a failure is performed in three steps <a class="reference internal" href="../bibliography.html#ffeb2005" id="id12"><span>[FFEB2005]</span></a> :</p>
<blockquote>
<div><ul class="simple">
<li><p>the routers that are adjacent to the failure detect it quickly. The default solution is to rely on the regular exchange of HELLO packets. However, the interval between successive HELLOs is often set to 10 seconds… Setting the HELLO timer down to a few milliseconds is difficult as HELLO packets are created and processed by the main CPU of the routers and these routers cannot easily generate and process a HELLO packet every millisecond on each of their interfaces. A better solution is to use a dedicated failure detection protocol such as the Bidirectional Forwarding Detection (BFD) protocol defined in <a class="reference internal" href="../bibliography.html#kw2009" id="id13"><span>[KW2009]</span></a> that can be implemented directly on the router interfaces. Another solution to be able to detect the failure is to instrument the physical and the datalink layer so that they can interrupt the router when a link fails. Unfortunately, such a solution cannot be used on all types of physical and datalink layers.</p></li>
<li><p>the routers that have detected the failure flood their updated link state packets in the network</p></li>
<li><p>all routers update their routing table</p></li>
</ul>
</div></blockquote>
</div>
<p>A last, but operationally important, point needs to be discussed about intradomain routing protocols such as OSPF and IS-IS. Intradomain routing protocols always select the shortest path for each destination. In practice, there are often several equal paths towards the same destination. When a router computes several equal cost paths towards one destination, it can use these paths in different ways.</p>
<p>A first approach is to select one of the equal cost paths (e.g. the first or the last path found by the SPF computation) and install it in the forwarding table. In this case, only one path is used to reach each destination.</p>
<p>A second approach is to install all equal cost paths <a class="footnote-reference brackets" href="#fmaxpaths" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> in the forwarding table and load-balance the packets on the different paths. Consider the case where a router has <cite>N</cite> different outgoing interfaces to reach destination <cite>d</cite>. A first possibility to load-balance the traffic among these interfaces is to use <cite>round-robin</cite>. <cite>Round-robin</cite> allows equally balancing the packets among the <cite>N</cite> outgoing interfaces. This equal load-balancing is important in practice because it allows better spreading the load throughout the network. However, few networks use this <cite>round-robin</cite> strategy to load-balance traffic on routers. The main drawback of <cite>round-robin</cite> is that packets that belong to the same flow (e.g. TCP connection) may be forwarded over different paths. If packets belonging to the same TCP connection are sent over different paths, they will probably experience different delays and arrive out-of-sequence at their destination. When a TCP receiver detects out-of-order segments, it sends duplicate acknowledgments that may cause the sender to initiate a fast retransmission and enter congestion avoidance. Thus, out-of-order segments may lead to lower TCP performance. This is annoying for a load-balancing technique whose objective is to improve the network performance by spreading the load.</p>
<p>To efficiently spread the load over different paths, routers need to implement <cite>per-flow</cite> load-balancing. This implies that they must forward all the packets that belong to the same flow on the same path. Since a TCP connection is always identified by the four-tuple (source and destination addresses, source and destination ports), one possibility would be to select an outgoing interface upon arrival of the first packet of the flow and store this decision in the router’s memory. Unfortunately, such a solution does not scale since the required memory grows with the number of TCP connections that pass through the router.</p>
<p>Fortunately, it is possible to perform <cite>per-flow</cite> load balancing without maintaining any state on the router. Most routers today use hash functions for this purpose <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2991.html"><strong>RFC 2991</strong></a>. When a packet arrives, the router extracts the Next Header information and the four-tuple from the packet and computes :</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(hash(NextHeader,IP_{src},IP_{dst},Port_{src},Port_{dst}) \pmod{N}\)</span></p>
</div></blockquote>
<p>In this formula, <cite>N</cite> is the number of outgoing interfaces on the equal cost paths towards the packet’s destination. Various hash functions are possible, including CRC, checksum or MD5 <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2991.html"><strong>RFC 2991</strong></a>. Since the hash function is computed over the four-tuple, the same hash value will be computed for all packets belonging to the same flow. This prevents reordering due to load balancing inside the network. Most routers support this kind of load-balancing today  <a class="reference internal" href="../bibliography.html#aco-2006" id="id15"><span>[ACO+2006]</span></a>.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://bgp.potaroo.net/index-as.html">http://bgp.potaroo.net/index-as.html</a> for reports on the evolution of the number of Autonomous Systems over time.</p>
</aside>
<aside class="footnote brackets" id="fvirtual" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">2</a><span class="fn-bracket">]</span></span>
<p>OSPF can support <cite>virtual links</cite> to connect routers together that belong to the same area but are not directly connected. However, this goes beyond this introduction to OSPF.</p>
</aside>
<aside class="footnote brackets" id="felection" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">3</a><span class="fn-bracket">]</span></span>
<p>The OSPF Designated Router election procedure is defined in <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2328.html"><strong>RFC 2328</strong></a>. Each router can be configured with a router priority that influences the election process since the router with the highest priority is preferred when an election is run.</p>
</aside>
<aside class="footnote brackets" id="fmaxpaths" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">4</a><span class="fn-bracket">]</span></span>
<p>In some networks, there are several dozens of paths towards a given destination. Some routers, due to hardware limitations, cannot install more than 8 or 16 paths in their forwarding table. In this case, a subset of the computed paths is installed in the forwarding table.</p>
</aside>
</aside>
    
</body>
</html>