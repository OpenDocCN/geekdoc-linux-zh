- en: Chapter 2\. Starting Off With a Sha-Bang
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://tldp.org/LDP/abs/html/sha-bang.html](https://tldp.org/LDP/abs/html/sha-bang.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|   |  **Shell programming is a 1950s juke box . . .*'
  prefs: []
  type: TYPE_NORMAL
- en: '*--Larry Wall**  |'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. [Invoking the script](invoking.html)
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. [Preliminary Exercises](prelimexer.html)
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest case, a script is nothing more than a list of system commands
    stored in a file. At the very least, this saves the effort of retyping that particular
    sequence of commands each time it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2-1\. *cleanup*: A script to clean up log files in /var/log**'
  prefs: []
  type: TYPE_NORMAL
- en: '|  [PRE0]  |'
  prefs: []
  type: TYPE_TB
- en: There is nothing unusual here, only a set of commands that could just as easily
    have been invoked one by one from the command-line on the console or in a terminal
    window. The advantages of placing the commands in a script go far beyond not having
    to retype them time and again. The script becomes a *program* -- a *tool* -- and
    it can easily be modified or customized for a particular application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2-2\. *cleanup*: An improved clean-up script**'
  prefs: []
  type: TYPE_NORMAL
- en: '|  [PRE1]  |'
  prefs: []
  type: TYPE_TB
- en: Now *that's* beginning to look like a real script. But we can go even farther
    . . .
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2-3\. *cleanup*: An enhanced and generalized version of above scripts.**'
  prefs: []
  type: TYPE_NORMAL
- en: '|  [PRE2]  |'
  prefs: []
  type: TYPE_TB
- en: Since you may not wish to wipe out the entire system log, this version of the
    script keeps the last section of the message log intact. You will constantly discover
    ways of fine-tuning previously written scripts for increased effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *sha-bang* ( #!) [[1]](#FTN.AEN205) at the head of a script tells your
    system that this file is a set of commands to be fed to the command interpreter
    indicated. The #! is actually a two-byte [[2]](#FTN.AEN214) *magic number*, a
    special marker that designates a file type, or in this case an executable shell
    script (type `**man magic**` for more details on this fascinating topic). Immediately
    following the *sha-bang* is a *path name*. This is the path to the program that
    interprets the commands in the script, whether it be a shell, a programming language,
    or a utility. This command interpreter then executes the commands in the script,
    starting at the top (the line following the *sha-bang* line), and ignoring comments.
    [[3]](#FTN.AEN226)'
  prefs: []
  type: TYPE_NORMAL
- en: '|  [PRE3]  |'
  prefs: []
  type: TYPE_TB
- en: Each of the above script header lines calls a different command interpreter,
    be it `/bin/sh`, the default shell (**bash** in a Linux system) or otherwise.
    [[4]](#FTN.AEN242) Using `**#!/bin/sh**`, the default Bourne shell in most commercial
    variants of UNIX, makes the script [portable](portabilityissues.html) to non-Linux
    machines, though you [sacrifice Bash-specific features](gotchas.html#BINSH). The
    script will, however, conform to the POSIX [[5]](#FTN.AEN256) **sh** standard.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the path given at the "sha-bang" must be correct, otherwise an error
    message -- usually "Command not found." -- will be the only result of running
    the script. [[6]](#FTN.AEN269)
  prefs: []
  type: TYPE_NORMAL
- en: '#! can be omitted if the script consists only of a set of generic system commands,
    using no internal shell directives. The second example, above, requires the initial
    #!, since the variable assignment line, `**lines=50**`, uses a shell-specific
    construct. [[7]](#FTN.AEN279) Note again that `**#!/bin/sh**` invokes the default
    shell interpreter, which defaults to `/bin/bash` on a Linux machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Tip](../Images/753d054f4c48fb039314a9e5947964cd.png) | This tutorial encourages
    a modular approach to constructing a script. Make note of and collect "boilerplate"
    code snippets that might be useful in future scripts. Eventually you will build
    quite an extensive library of nifty routines. As an example, the following script
    prolog tests whether the script has been invoked with the correct number of parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  [PRE4]  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: Many times, you will write a script that carries out one particular task. The
    first script in this chapter is an example. Later, it might occur to you to generalize
    the script to do other, similar tasks. Replacing the literal ("hard-wired") constants
    by variables is a step in that direction, as is replacing repetitive code blocks
    by [functions](functions.html#FUNCTIONREF). |
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [[1]](sha-bang.html#AEN205) | More commonly seen in the literature as *she-bang*
    or *sh-bang*. This derives from the concatenation of the tokens *sharp* (#) and
    *bang* (!). |'
  prefs: []
  type: TYPE_TB
- en: '| [[2]](sha-bang.html#AEN214) | Some flavors of UNIX (those based on 4.2 BSD)
    allegedly take a four-byte magic number, requiring a blank after the ! -- `**#!
    /bin/sh**`. [According to Sven Mascheck](http://www.in-ulm.de/~mascheck/various/shebang/#details)
    this is probably a myth. |'
  prefs: []
  type: TYPE_TB
- en: '| [[3]](sha-bang.html#AEN226) | The #! line in a shell script will be the first
    thing the command interpreter (**sh** or **bash**) sees. Since this line begins
    with a #, it will be correctly interpreted as a comment when the command interpreter
    finally executes the script. The line has already served its purpose - calling
    the command interpreter.If, in fact, the script includes an *extra* #! line, then
    **bash** will interpret it as a comment.'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  [PRE5]  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| [[4]](sha-bang.html#AEN242) | This allows some cute tricks.'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  [PRE6]  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: Also, try starting a `README` file with a `**#!/bin/more**`, and making it executable.
    The result is a self-listing documentation file. (A [here document](here-docs.html#HEREDOCREF)
    using [cat](basic.html#CATREF) is possibly a better alternative -- see [Example
    19-3](here-docs.html#EX71)). |
  prefs: []
  type: TYPE_NORMAL
- en: '| [[5]](sha-bang.html#AEN256) | **P**ortable **O**perating **S**ystem *I*nterface,
    an attempt to standardize UNI**X**-like OSes. The POSIX specifications are listed
    on the [Open Group site](http://www.opengroup.org/onlinepubs/007904975/toc.htm).
    |'
  prefs: []
  type: TYPE_TB
- en: '| [[6]](sha-bang.html#AEN269) | To avoid this possibility, a script may begin
    with a [#!/bin/env bash](system.html#ENVV2REF) *sha-bang* line. This may be useful
    on UNIX machines where *bash* is not located in `/bin` |'
  prefs: []
  type: TYPE_TB
- en: '| [[7]](sha-bang.html#AEN279) | If *Bash* is your default shell, then the #!
    isn''t necessary at the beginning of a script. However, if launching a script
    from a different shell, such as *tcsh*, then you *will* need the #!. |'
  prefs: []
  type: TYPE_TB
