<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>QUIC#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>QUIC#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/hosts/quic.html">https://4ed.computer-networking.info/syllabus/default/hosts/quic.html</a></blockquote>
<span id="chapter-quic"/>
<p>QUIC <span class="target" id="index-0"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> is the latest transport protocol standardized by the IETF. There are several characteristics that distinguish QUIC from other transport protocols:</p>
<blockquote>
<div><ul class="simple">
<li><p>QUIC supports multiple byte streams like SCTP</p></li>
<li><p>QUIC includes various reliability and congestion control mechanisms like TCP</p></li>
<li><p>QUIC directly integrates the security features of TLS 1.3 <span class="target" id="index-1"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a> instead of simply layering TLS above the transport layer</p></li>
<li><p>QUIC can also be used to carry datagrams <span class="target" id="index-2"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9221.html"><strong>RFC 9221</strong></a></p></li>
<li><p>QUIC runs above UDP in contrast with other transport protocols such as TCP, SCTP or DCCP that run above IP</p></li>
</ul>
</div></blockquote>
<p>From a pure layering viewpoint, QUIC can be illustrated as shown in <a class="reference internal" href="#fig-quic-layers"><span class="std std-numref">Fig. 84</span></a>.</p>
<div class="figure" id="id17" style="text-align: center">
<span id="fig-quic-layers"/><p><img src="../Images/a5847b136176a686e0b1c30e9e363f86.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-615b6ed767e7cab1aa4b49b99e92166d525f18d8.png"/></p>
<p><span class="caption-number">Fig. 84 </span><span class="caption-text">QUIC in the TCP/IP stack</span></p>
</div><p>It is unusual to layer a transport protocol above another one. QUIC opted for this solution for two main reasons. First, on most operating systems, any application can directly use UDP without requiring special privileges. This implies that QUIC can be implemented as a library which can be included directly inside applications. This contrasts with TCP, SCTP or DCCP whose implementations are either part of the operating system kernel or need special privileges to send <cite>raw</cite> packets. The second motivation is that UDP (as well as TCP and ICMP) is supported by most middleboxes while many of them block transport protocols that were not defined when they were designed <a class="reference internal" href="../bibliography.html#bwfedg2020" id="id1"><span>[BWFEDG2020]</span></a>.</p>
<p>It is useful to note that by using UDP, QUIC slightly increases its overhead. Each QUIC packet carries 8 bytes of headers containing the source and destination ports, the length field and a checksum. UDP also comes with a performance penalty compared to TCP. During the last decades, operating system kernels have been optimized to provide high bandwidth using TCP with techniques such as TCP Segmentation Offload (TSO) and Generic Receive Offload (GRO). In parallel, the UDP implementation has not changed significantly and most of the optimizations focused on request-response services such as DNS servers. The situation has changed recently with some effort, notably on Linux, to improve UDP’s raw throughput <a class="reference internal" href="../bibliography.html#dd2018" id="id2"><span>[DD2018]</span></a>.</p>
<section id="frames-and-packets">
<h2>Frames and packets<a class="headerlink" href="#frames-and-packets" title="Link to this heading">#</a></h2>
<p>There is an important difference between QUIC and classical protocols like TCP or UDP. TCP and UDP send segments that are composed of a header followed by a sequence of bytes that constitutes the payload. In contrast and like SCTP, a QUIC packet contains a header followed by one or more frames. The QUIC header is much simpler and shorter than the TCP header. It only carries the information which is required in all QUIC packets. We will describe later the short and long QUIC headers. Each QUIC header starts with one byte that contains some flags and a 32 bits version field. QUIC defines different types of frames that we will discuss in this chapter. Some types of QUIC frames carry user data. Other types of QUIC frames carry control information. Some of these frames are used during the handshake only while others such as acknowledgments can be sent at any time. Each QUIC frame is a sequence of byte that starts with a one byte Type field. <a class="reference internal" href="#fig-quic-packet"><span class="std std-numref">Fig. 85</span></a> shows a QUIC packet containing two frames which is placed inside a UDP datagram. Neither the QUIC header nor the QUIC frames need to be aligned on 32 bits boundaries even if this alignment is convenient for <a class="reference internal" href="#fig-quic-packet"><span class="std std-numref">Fig. 85</span></a>. An important point to note is that a QUIC packet can mix both data and control frames in any order.</p>
<div class="figure" id="id18" style="text-align: center">
<span id="fig-quic-packet"/><p><img src="../Images/67f2552f1552b239338ebf98d5fb0e85.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-ed2f67fd11ab4c57f149a6abb80b6cc76f6dd0d6.png"/></p>
<p><span class="caption-number">Fig. 85 </span><span class="caption-text">A QUIC packet is sent inside a UDP datagram and contains one or more QUIC frames</span></p>
</div></section>
<section id="connection-establishment">
<h2>Connection establishment<a class="headerlink" href="#connection-establishment" title="Link to this heading">#</a></h2>
<p>QUIC uses a four-way handshake to create a QUIC connection. <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a> describes this handshake. The QUIC handshake has three main purposes. First, it allows to negotiate the crypto keys required to both encrypt and authenticate the packets that will be sent later on the connection. This is mainly done using TLS 1.3 <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. Second, it allows to negotiate different options using transport parameters. Third, the server can validate that the client can respond to the address used to send the initial packet. This validation allows to prevent denial of service attacks using spoofed addresses.</p>
<div class="figure" id="id19" style="text-align: center">
<span id="fig-quic-handshake"/><p><img src="../Images/5e44a71ad373032f5a20d036f58c2000.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-9f0472102e8c53ef8c6a54916938c4807df9effa.png"/></p>
<p><span class="caption-number">Fig. 86 </span><span class="caption-text">Simplified QUIC Handshake</span></p>
</div><p>The client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. This packet carries the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the transport parameters proposed by the client for this connection. The server replies with an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing also a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. This one contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. It is immediately followed by one or more <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets containing also a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code>. The contents of this frame is encrypted using the session key derived from the information contained in the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. It mainly contains the certificate and the transport parameters of the server. This frame can be spread over several QUIC packets. The client replies with a <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Finished</span></code> message. The server later confirms the end of the TLS handshake by sending a <code class="docutils literal notranslate"><span class="pre">Handshake_Done</span></code> frame.</p>
<p>Before looking at the details of the negotiation of the cryptographic parameters, it is interesting to see how QUIC counters denial of service attacks that use spoofed addresses. During such attack, host <cite>x</cite> sends packets using the address of host <cite>y</cite> as their source. The main risk of such attacks is that the server could send a large number of packets towards address <cite>y</cite> although the host owning this address did not try to establish a QUIC connection with the server. QUIC prevents such attacks by using two distinct techniques. First, and this is unusual for transport protocols, the Initial QUIC packet sent by the client is large. The first packet sent to create a QUIC connection must contain a UDP payload of at least 1200 bytes <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. Such a packet contains a CRYPTO frame has shown in the figure, but also padding frames to fill the packet. If an attacker wants to send spoofed packets to initiate a connection with a server, it needs to send more than one KByte for each connection attempt. This should be compared with the 40 bytes of the TCP and IPv4 headers that must be sent to initiate a TCP connection. Another advantage of sending a large initial packet, the client can also perform Path MTU discovery and detect routers that could fragment the QUIC packets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Address spoofing</p>
<p>In theory, an Internet host should only send packets using its IPv4 and IPv6 source addresses. In practice, incorrectly configured hosts can use other addresses than their assigned one. Furthermore, attackers often change their source address to hide some of their activities. A frequent situation are denial of service (DoS) attacks. A simple DoS attack is when a host sends a large volume of packets to a victim. If the attacker sends these packets using another address than its official IP address, it makes it more difficult for the victim to identify the source of the attack.</p>
<p>But there is another category of DoS attack that is more worrisome. If an attacker can send a packets using the source address of the victim to a server, the server would return a response to the victim. These attackers use Internet servers that send a large response, possibly using multiple packets to a single request packet. They have exploited protocols such as DNS, NTP or applications such as <a class="reference external" href="https://www.memcached.org/">memcached</a> . The main problem with such attacks is that the server amplifies the volume of the attack generated by the clients. As there are very powerful servers on the Internet, this can be a huge problem and such attacks have reached volumes of hundreds of Gbps. The IETF and network operators have published recommendations to configure access networks to block spoofed packets <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2827.html"><strong>RFC 2827</strong></a>. Unfortunately, there are still portions of the Internet where attackers can send spoofed packets <a class="reference internal" href="../bibliography.html#lbkkkc2019" id="id3"><span>[LBKKKC2019]</span></a>.</p>
</div>
<p>The second mitigation against denial-of-service attacks using spoofed packets operates on the server. When a server receives an initial packet from a client, it may respond with an initial packet as shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a>. This could for example be the case of an enterprise server that receives a request from a host of a known enterprise subnet. The server could also want to validate the client and verify that the client can receive the packets that it sends. For this, it returns a Retry frame and a Token. This token is an opaque field that is constructed in a way that makes it easy for the server to validate the subsequent client packets and difficult for the client to predict the token that a server will create. A possible approach is to compute a secure hash of a message that contains the source IP addresses and ports used by the client, a secret value only known by the server and possibly some timing information to enable the server to ignore older tokens. Faced with the same problem, TCP <cite>syn cookies</cite> are encoded using fewer bits and thus inherently less secure. <a class="reference internal" href="#fig-quic-handshake-retry"><span class="std std-numref">Fig. 87</span></a> shows a QUIC handshake that includes a validation of the client address.</p>
<div class="figure" id="id20" style="text-align: center">
<span id="fig-quic-handshake-retry"/><p><img src="../Images/c3f57d5ce5702e99d69cee08ac7baddb.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-569f0b174611af526a584356e0900b74d003d137.png"/></p>
<p><span class="caption-number">Fig. 87 </span><span class="caption-text">Simplified QUIC Handshake with address validation</span></p>
</div><p>Address validation improves the resilience of servers against denial of service attacks using spoofed addresses, but this comes at the expense of a longer connection establishment delay. QUIC version 1 includes several additional techniques to reduce the impact of address validation while still preventing denial of service attacks.</p>
<section id="identifying-quic-connections">
<h3>Identifying QUIC connections<a class="headerlink" href="#identifying-quic-connections" title="Link to this heading">#</a></h3>
<p>A TCP connection is identified by a four tuple <span class="math notranslate nohighlight">\(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\)</span>. All packets belonging to a given connection carry this information in their IP and TCP headers. As QUIC runs above UDP, a simple approach could have been to use the UDP four tuple to identify each QUIC connection. Although simple, this solution would have severely restricted the flexibility of QUIC and the scalability of QUIC servers. The QUIC designers have opted for locally unique connection identifiers (CID) that are selected by the client and the server. These identifiers are placed in the QUIC packet headers during the handshake. When sending the Initial packet, the client selects a source CID that uniquely identifies the connection on the client and a random destination CID. Upon reception of this packet, the server selects its own connection identifier. It echoes the client selected CID and returns its selected CID. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-cid"><span class="std std-numref">Fig. 88</span></a>.</p>
<div class="figure" id="id21" style="text-align: center">
<span id="fig-quic-handshake-cid"/><p><img src="../Images/5c6ab95bb24bea00f667803dec9da315.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-943d4269d0b439918f506597c12f6399e6a3d0ed.png"/></p>
<p><span class="caption-number">Fig. 88 </span><span class="caption-text">Connection identifiers during a simplified QUIC Handshake</span></p>
</div><p>The connection identifiers selected by the client and the server uniquely identify the QUIC connection. However, in contrast with TCP and UDP, the two identifiers are not present in all packets. Since a host selects a unique identifier for each connection, it only needs this identifier to identify a connection to which a packet belongs. For this reason, the QUIC packets exchanged on a connection after the handshake only contain the destination CID, i.e. the CID selected by the host that receives the packet.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Variable length CIDs</p>
<p>Most transport protocols rely on fixed-length fields because this simplifies the parsing of packet headers. For example, the TCP and UDP port numbers are encoded as a 16 bits field. However, using fixed-length fields also limits the extensibility of the protocol. A TCP server cannot listen to more than <span class="math notranslate nohighlight">\(2^{16}\)</span> different ports.</p>
<p>QUIC has opted for variable length CIDs to support very different use cases. On the server side, the length of the selected connection identifiers will depend on the architecture of the server. Large sites might use a load balancer that distributes the connections to different physical servers. Such a load-balancer can leverage the CID to direct each incoming packet to the server that handles this connection. A simple CID would be composed of a server identifier chosen by the load balancer, e.g. in the high order bits of the CID, followed by a connection identifier selected by the physical server. Other designs are possible, e.g. by encrypting the CID to prevent attacks where malicious clients try to target a specific server.</p>
<p>One the client side, variable lengths CIDs bring another benefit. As clients typically manage a small number of QUIC connections, they can simply rely on the destination port of the packets that they receive to identify the corresponding QUIC connection. This corresponds to a zero-length connection identifier. Such a CID is never sent by the server after the handshake. This limits the byte overhead of the packets that clients receive.</p>
<p>A last point to note about these CIDs is their encoding inside the QUIC packets. The Initial packet contains the length and the value of both connection identifiers. The maximum length for a CID is 20 bytes. However, after the handshake, the packets that are exchanged over the QUIC connection only contain the destination CID without any field indicating its length. The host that has allocated the CID knows the length of the CIDs that it uses and can thus parse the packets that it receives without an explicit length information.</p>
</div>
</section>
<section id="security-keys">
<h3>Security keys<a class="headerlink" href="#security-keys" title="Link to this heading">#</a></h3>
<p>We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys that are used to authenticate and encrypt the packets exchanged over a connection. As shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a>, a QUIC connection starts with the exchange of four frames which can be carried in four or more packets. The first packet sent by the client contains the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> TLS record. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> contains the information required to derive the session keys using Diffie-Hellman or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic Curve Diffie-Hellman <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message also contains TLS or QUIC parameters that the client proposes to use during the connection. The <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> returned by the server contains the certificate that enables the client to validate the server’s identity and the information required to determine the Diffie-Hellman keys. Using these keys, the server also encrypts the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> message that contains the TLS and QUIC parameters that the server has selected based on the ones proposed in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server also constructs the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message that contains a message authentication code computed over the entire TLS handshake. This message is encrypted and authenticated using the session keys derived from the Diffie-Hellman keys. The client and the server recompute the hash of the entire handshake and verify both <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages. If one of these messages is incorrect, this indicates that either the key has not been correctly derived or that some of the TLS messages have been tampered. In these situations, the QUIC connection is terminated with an error message. The simplified TLS handshake used by QUIC is illustrated in <a class="reference internal" href="#fig-quic-tls-handshake"><span class="std std-numref">Fig. 89</span></a>. The TLS messages shown in italics are encrypted using the session keys.</p>
<div class="figure" id="id22" style="text-align: center">
<span id="fig-quic-tls-handshake"/><p><img src="../Images/68b73d74f409bc3b1f789ac93a363aa3.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-7918db6aa498e176259a65bc127c4105ca0aef60.png"/></p>
<p><span class="caption-number">Fig. 89 </span><span class="caption-text">Simplified TLS Handshake within a QUIC connection</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encrypting <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code></p>
<p>When TLS 1.3 is used above TCP, the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> messages are sent in clear because the client and the server have not yet exchanged the session keys. A similar approach could have been used for QUIC, but there was a fear that middleboxes could analyze the contents of these initial QUIC messages and try to interfere with them. To add some burden on these middleboxes, QUIC encrypts the Initial packets using a secret that is derived from the destination connection ID of the client’s first Initial packet. The pseudocode below, extracted from <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9001.html"><strong>RFC 9001</strong></a>, shows how the client and the server keys are derived:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">initial_salt</span> <span class="o">=</span> <span class="mh">0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a</span>
<span class="n">initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Extract</span><span class="p">(</span><span class="n">initial_salt</span><span class="p">,</span>
                        <span class="n">client_dst_connection_id</span><span class="p">)</span>

<span class="n">client_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
             <span class="s2">"client in"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="n">server_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
                           <span class="s2">"server in"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span><span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the keys used to protect the Initial packets are derived from the destination connection ID, any QUIC implementation, including those used on middleboxes, can decrypt the contents of the Initial packets.</p>
</div>
<p>As mentioned earlier, the client and the server can also use the TLS handshake to agree on specific QUIC parameters. These parameters are called <cite>transport parameters</cite> in QUIC <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. 17 different transport parameters are defined in QUIC version 1 <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> and implementations can define their own transport parameters. We will discuss some of them in different sections of this document. A first example is the <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> parameter that indicates the largest UDP payload that an implementation is willing to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations used in a datacenter supporting jumbo Ethernet frames could agree on a much larger <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> without risking packet fragmentation.</p>
<p>Another example of QUIC transport parameters are the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> and the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameters. As explained above, thanks to the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages in the TLS handshake, the client and the servers can verify that their messages have not been tampered. Unfortunately, the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages is only computed based on the contents of the TLS messages (i.e. <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>, <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>, <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> and <code class="docutils literal notranslate"><span class="pre">Finished</span></code>). During the handshake, the client and the servers also propose the source and destination connection identifiers that they plan to use to identify the QUIC session. These identifiers are placed in the packet header and not inside the TLS messages. They are thus not covered by the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message. To still authenticate these identifiers, QUIC encodes them as transport parameters that are included in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> and the <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> messages. The client copies the source connection identifier in the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> transport parameter in its <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server does the same when sending the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>. It also copies in the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameter the destination identifier used by the client to send the packet containing the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>.</p>
</section>
<section id="the-quic-packet-headers">
<h3>The QUIC packet headers<a class="headerlink" href="#the-quic-packet-headers" title="Link to this heading">#</a></h3>
<p>At this point, the QUIC session and the TLS security keys are known by the client and the server. They can start to exchange data. Before looking at how data is carried inside QUIC packets, it is interesting to explore in more details the packet headers that are placed inside each packet. QUIC uses variable length packet headers. Two different header formats exist. The first header format is the long header. This is the header used for the first packets of a QUIC connection.</p>
<p>Internet protocol specifications usually contain figures to represent the format of the packet headers. This graphical format is useful to get a quick grasp at a header containing fixed size fields. However, when a header contains several variable length fields, the graphical representation can become difficult to follow. The QUIC specification <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> uses the textual representation that was also used for the TLS protocol. As an example, let us consider the well-known TCP header. This header is graphically represented as shown in <a class="reference internal" href="#fig-quic-tcp-header"><span class="std std-numref">Fig. 90</span></a>.</p>
<div class="figure" id="id23" style="text-align: center">
<span id="fig-quic-tcp-header"/><p><img src="../Images/8bbfb429b7a940504df39c6677c533c7.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-55e7ccada8e8e238f1ed6e92591efe5c866e3b4a.png"/></p>
<p><span class="caption-number">Fig. 90 </span><span class="caption-text">Graphical representation of the TCP header</span></p>
</div><div class="literal-block-wrapper docutils container" id="fig-quic-tcp-text-header">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">Textual representation of the TCP header</span><a class="headerlink" href="#fig-quic-tcp-text-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">TCP Header Packet {</span>
<span class="go">  Source Port (16),</span>
<span class="go">  Destination Port (16),</span>
<span class="go">  Sequence Number (32),</span>
<span class="go">  Acknowledgment Number (32),</span>
<span class="go">  Offset (4),</span>
<span class="go">  Reserved (6),</span>
<span class="go">  Urgent Flag (1),</span>
<span class="go">  ACK Flag (1),</span>
<span class="go">  Push Flag (1),</span>
<span class="go">  RST Flag (1),</span>
<span class="go">  SYN Flag (1),</span>
<span class="go">  FIN Flag(1),</span>
<span class="go">  Window (16),</span>
<span class="go">  TCP Checksum (16),</span>
<span class="go">  Urgent Pointer (16),</span>
<span class="go">  TCP Options (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The attentive reader will easily understand the correspondence between the two formats. When explaining QUIC, we use the textual representation while we stick to the graphical one for TCP.</p>
<p><a class="reference internal" href="#fig-quic-long-header"><span class="std std-numref">Listing 3</span></a> shows the QUIC long header. It starts with one byte containing the header type in the most significant bit, two bits indicating the packet type and four bits that are specific to each packet packet. Then, 32 bits carry the QUIC version number. The current version of QUIC, defined in <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>, corresponds to version <code class="docutils literal notranslate"><span class="pre">0x00000001</span></code>. The header then contains the destination and source connection identifiers that were described previously and then a payload that is specific to each type.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-long-header">
<div class="code-block-caption"><span class="caption-number">Listing 3 </span><span class="caption-text">The QUIC long header</span><a class="headerlink" href="#fig-quic-long-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,                  /* high order bit of the first byte */</span>
<span class="go">  Fixed Bit (1) = 1,                    /* second order bit of the first byte */</span>
<span class="go">  Long Packet Type (2),                 /* third and fourth high order bits of the first byte */</span>
<span class="go">  Type-Specific Bits (4),               /* low order four bits of the first byte */</span>
<span class="go">  Version (32),                         /* 32 bits version number */</span>
<span class="go">  Destination Connection ID Length (8), /* 8 bits */</span>
<span class="go">  Destination Connection ID (0..160),   /* variable number from 0 up to 160 bits */</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Type-Specific Payload (..),           /* variable length */</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encoding packet numbers</p>
<p>Most transport protocols use fixed fields to encode packet numbers or byte offsets. The size of this field is always a trade-off. On one hand, a small packet number field limits the per packet overhead. On the other hand, a large packet number space is required to ensure that two packets carrying different data do not use the same packet number. TCP uses a 32 bits sequence number field that indicates the position of the first byte of the payload in the bytestream. This 32 bits field became a concern as bandwidth increased to Gbps and beyond <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7323.html"><strong>RFC 7323</strong></a>.</p>
<p>QUIC takes a different approach to sequence numbers. Each packet contains a per-packet sequence number. This number is encoded as a variable-length integer (<code class="docutils literal notranslate"><span class="pre">varint</span></code>). Such a <code class="docutils literal notranslate"><span class="pre">varint</span></code> has a length encoded in the two most significant bits of the first byte. If these bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code>, then the <code class="docutils literal notranslate"><span class="pre">varint</span></code> is encoded in one byte and can contain values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{6}-1\)</span>.  If the two most significant bits are set to <code class="docutils literal notranslate"><span class="pre">01</span></code>, the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{14}-1\)</span> within two bytes. When the two high order bits are set to <code class="docutils literal notranslate"><span class="pre">11</span></code> the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{62}-1\)</span> within four bytes.</p>
<p>There are other important differences between QUIC and other transport protocols when considering packet numbers. First, a QUIC sender must <em>never</em> reuse the same packet number for two different packets sent over a QUIC connection. If data needs to be retransmitted, it will be resent as a frame inside a new packet. Furthermore, since the largest possible packet number is <span class="math notranslate nohighlight">\(2^{62}-1\)</span>, a QUIC sender must close the corresponding connection once it has sent a QUIC packet carrying this packet number. This puts a restriction on the duration of QUIC connections. They cannot last forever in contrast to TCP connections such as those used to support BGP sessions between routers. An application that uses QUIC must be ready to restart a connection from time to time.</p>
</div>
<p>This long header is used for the <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handhsake</span></code> and <code class="docutils literal notranslate"><span class="pre">Retry</span></code> packets. Some of these packet types add new flags in the first byte and additional information after the connection identifiers. <a class="reference internal" href="#fig-quic-initial-header"><span class="std std-numref">Listing 4</span></a> shows the long header of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It contains two bits in the first byte that indicate the length of the packet number field. The packet specific part contains an option token, a length field, a packet number and a payload. The token length, length and packet number are encoded using variable length integers.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-initial-header">
<div class="code-block-caption"><span class="caption-number">Listing 4 </span><span class="caption-text">The QUIC long header of the Initial packet</span><a class="headerlink" href="#fig-quic-initial-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Initial Packet {</span>
<span class="go">  Header Form (1) = 1,                   /* High order bit first byte */</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 0,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),              /* Low order 2 bits of first byte */</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Token Length (i),</span>
<span class="go">  Token (..),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC short header contains fewer fields. The most significant bit of the first byte is set to 1 to indicate that the packet carries a short header. The other flags will be discussed later. The two least significant bits of this byte contain the length of the packet number field. It is interesting to note that in contrast with the long header, there is no explicit indication of the length of the destination connection identifier. This connection identifier has been assigned by the host that receives this packet and it already knows the length of the connection identifiers that it uses.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 5 </span><span class="caption-text">The QUIC short header used by 1-RTT packets</span><a class="headerlink" href="#fig-quic-short-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,                /* High order bit of first byte */</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1),</span>
<span class="go">   Reserved Bits (2),</span>
<span class="go">   Key Phase (1),</span>
<span class="go">   Packet Number Length (2),           /* Low order bits of first byte */</span>
<span class="go">   Destination Connection ID (0..160),</span>
<span class="go">   Packet Number (8..32),</span>
<span class="go">   Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The short header format, depicted in <a class="reference internal" href="#fig-quic-short-header"><span class="std std-numref">Listing 5</span></a>, is used by all QUIC packets once the session keys have been derived. This usually happens after one round-trip-time. These packets are called the 1-RTT packets in the QUIC specification <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. This notation is used to emphasize the fact that QUIC also supports 0-RTT packets, i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Coalescing packets</p>
<p>Besides the connection identifiers, another difference between the short and the long headers is the presence of the <code class="docutils literal notranslate"><span class="pre">Packet</span> <span class="pre">Length</span></code> field in the long header. This field might surprise the reader who is familiar with UDP since UDP also contains a Length field. As each QUIC packet is placed inside a UDP message, the QUIC Length field could seem redundant. This Length field was included in the QUIC long header to allow a QUIC sender to coalesce several consecutive and small packets inside a single UDP message. Some of the frames exchanged during the handshake are rather small. Sending a UDP message for each of these frames would be a waste of resources. Furthermore, a mix of <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> and <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets are exchanged when creating a QUIC connection. It would not be wise to require the utilization of one UDP message to send each of these packets. You might observe this optimization when analyzing packet traces collected on QUIC servers.</p>
</div>
</section>
<section id="rtt-data">
<h3>0-RTT data<a class="headerlink" href="#rtt-data" title="Link to this heading">#</a></h3>
<p>Latency is a key concern for transport protocols. The QUIC/TLS handshake that we have described until now allows the client and the server to agree on security keys within one round-trip-time. However, one round-trip-time can be a long delay for some applications. To minimize the impact of the connection setup time, QUIC allows applications to exchange data during the QUIC/TLS handshake. Such data is called 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client and the server must have previously agreed on a key which can be used to encrypt and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared key that the client and the server have shared without using the QUIC protocol or, and this is the most frequent solution, the key that they negotiated during a previous connection. In practice, the server enables 0-RTT by sending a TLS session ticket to the client <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. A session ticket is an encrypted record that contains information that enables the server to recover all the state information about a session including its session keys. It is also linked to the client’s address to enable the server to verify that a given client reuses the tickets that it has received earlier. Usually, these tickets also contain an expiration date. The client places the received ticket in the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">CLient</span> <span class="pre">Hello</span></code> that it sends in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It uses the pre-shared key corresponding to this ticket to encrypt data and place it in one or more <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets. The server uses the information contained in the ticket to recover the key and decrypt the data of the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-0-rtt-packet"><span class="std std-numref">Listing 6</span></a> shows the format of QUIC’s 0-RTT packet.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-0-rtt-packet">
<div class="code-block-caption"><span class="caption-number">Listing 6 </span><span class="caption-text">The QUIC 0-RTT packet</span><a class="headerlink" href="#fig-quic-0-rtt-packet" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">0-RTT Packet {</span>
<span class="go">  Header Form (1) = 1,                  /* High order bit of the first byte */</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 1,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),            /* Low order bits of the first byte */</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The main benefit of these <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets is that the client can immediately send encrypted data while sending its <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-ortt"><span class="std std-numref">Fig. 91</span></a> where the frames encrypted with the 0-RTT keys are shown in italics. Note that some of these frames can span several packets. <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets are only sent by the QUIC client since the server can send encrypted data immediately after having sent its <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> frames. As explained earlier, the Initial packets are also encrypted but using keys derived from the connection identifiers.</p>
<div class="figure" id="id24" style="text-align: center">
<span id="fig-quic-handshake-ortt"/><p><img src="../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-8755d75d243150f4626ac19898669b538f7aea0c.png"/></p>
<p><span class="caption-number">Fig. 91 </span><span class="caption-text">Simplified QUIC Handshake with 0-RTT data</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Replay attacks and 0-RTT packets</p>
<p>Thanks to the 0-RTT packets, a client can send encrypted data to the server before waiting for the secure handshake. This reduces the latency of the data transfer, but with one important caveat. QUIC does not provide any guarantee that 0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent operations. A detailed discussion of the impact of replay attacks may be found in <a class="reference internal" href="../bibliography.html#maccarthaigh2017" id="id4"><span>[MacCarthaigh2017]</span></a>.</p>
<p>To understand the importance of these replay attacks, let us consider a simple HTTP GET request. Such a request could easily fit inside the 0-RTT packet and thus have lower latency. If a web browser uses it to request a static <code class="docutils literal notranslate"><span class="pre">index.html</span></code> file, there is no harm if the request is received twice by the server. However, if the GET request is part of a REST API and has side effects, then problems could occur depending on the type of side effect. Consider a REST API that allows a user to switch off the lights using his or her smartphone. Replaying this request two or three times will always result in the light being switched off. However, if the user requests to increase the room temperature by one °C, then multiple replays will obviously have different consequences.</p>
</div>
</section>
</section>
<section id="closing-a-quic-connection">
<h2>Closing a QUIC connection<a class="headerlink" href="#closing-a-quic-connection" title="Link to this heading">#</a></h2>
<p>Before exploring how data can be exchanged over a QUIC connection, let us now analyze how a QUIC connection can terminate. QUIC supports three different methods to close a QUIC connection. QUIC’s approach to terminating connection is very different from the approaches used by traditional transport protocol. Before looking at these techniques, it is important to understand how QUIC interacts with Network Address Translation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUIC and Network Address Translation</p>
<p>QUIC runs above UDP and the design of QUIC was heavily influenced by the presence of NATs. NATs, like other middleboxes, maintain per-flow state. For TCP connections, many NATs rely on the <code class="docutils literal notranslate"><span class="pre">SYN</span></code>, <code class="docutils literal notranslate"><span class="pre">FIN</span></code> and <code class="docutils literal notranslate"><span class="pre">RST</span></code> flags to determine when state must be created or removed for a TCP connection. For UDP, this stateful approach is not possible and NATs create a new mapping when they observe the first packet of a flow and remove the mapping once the flow has been idle for sometime. The IETF recommends to maintain NAT mappings during at least two minutes <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4787.html"><strong>RFC 4787</strong></a>, but measurements show that some deployed NATs use shorter timeouts <a class="reference internal" href="../bibliography.html#hnessk2010" id="id5"><span>[HNESSK2010]</span></a> <a class="reference internal" href="../bibliography.html#rwv-2016" id="id6"><span>[RWV+2016]</span></a>. In practice, UDP flows should probably send a packet every 30 seconds to ensure that the on-path NATs preserve their state.</p>
<p>To prevent NATs from changing the mapping associated to the IP addresses and ports used for a QUIC connection, QUIC hosts will need to regularly send data over each established QUIC connection. QUIC defines a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame that allows any QUIC endpoint to send a frame that will trigger a response from the other peer. The <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame does not carry data, but the receiver of a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame needs to acknowledge the packet containing this frame. This creates a bidirectional communication and can prevent NATs from discarding the mapping associated to the QUIC connection.</p>
</div>
<section id="implicit-termination-of-quic-connections">
<h3>Implicit termination of QUIC connections<a class="headerlink" href="#implicit-termination-of-quic-connections" title="Link to this heading">#</a></h3>
<p>Each QUIC implementation keeps in its connection state the timestamp of the last QUIC packet received over this connection. During the connection establishment, the QUIC hosts can also exchange the <code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> parameter that indicates how long (in seconds) a QUIC connection can remain idle before being automatically closed. The first way to close a QUIC connection is to keep it idle for this period of time.</p>
</section>
<section id="explicit-termination-of-a-quic-connection">
<h3>Explicit termination of a QUIC connection<a class="headerlink" href="#explicit-termination-of-a-quic-connection" title="Link to this heading">#</a></h3>
<p>The second technique to terminate a QUIC connection is to use the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. This frame indicates that this connection has been closed abruptly.  The host that receives the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> may respond with one <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. After that, it must stop sending any additional frame. It keeps the connection state for some time, but does not accept any new packet nor retransmit others. The host that sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame indicates that it will neither send nor accept more data. It keeps a subset of the QUIC connection state to be able to retransmit the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame if needed.</p>
<p>A host also sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame to abruptly terminate a connection if it receives an invalid frame or detects a protocol error. In this case, the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame contains a variable length integer that indicates the reason for the termination, the type of the frame that triggered the error and additional information encoded as a text string.</p>
<div class="figure" id="id25" style="text-align: center">
<span id="fig-quic-connection-close"/><p><img src="../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-d2938049bf06c04a3a5990ebbda9f800cc035f2c.png"/></p>
<p><span class="caption-number">Fig. 92 </span><span class="caption-text">A server that refuses a connection</span></p>
</div><p>The QUIC specification also defines a third technique called <cite>stateless reset</cite> to cope with hosts that have lost connection state after a crash or outage. It relies on a 16 bytes stateless token announced together with the connection identifier. See <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> for all the details.</p>
</section>
</section>
<section id="exchanging-data-over-a-quic-connection">
<h2>Exchanging data over a QUIC connection<a class="headerlink" href="#exchanging-data-over-a-quic-connection" title="Link to this heading">#</a></h2>
<p>The data exchanged over is QUIC connection is organized in different streams. A stream is a sequence of bytes. QUIC supports both unidirectional and bidirectional streams. Both the client and the server can create new streams over a QUIC connection. Each stream is identified by a stream identifier. To prevent problems when the client and the server try to create a stream using the same identifier, QUIC restricts the utilization of the stream identifiers based its two low-order bits. A QUIC client can only create streams whose two low order bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code> (bidirectional stream) or <code class="docutils literal notranslate"><span class="pre">10</span></code> (unidirectional stream). Similarly, the low order bits of the server-initiated streams must be set to <code class="docutils literal notranslate"><span class="pre">01</span></code> (bidirectional stream) or <code class="docutils literal notranslate"><span class="pre">11</span></code> (unidirectional streams). The QUIC streams are created implicitly by sending data over the stream with the chosen identifier. The stream identifiers start at the minimum value, i.e. <code class="docutils literal notranslate"><span class="pre">0x00</span></code> to <code class="docutils literal notranslate"><span class="pre">0x03</span></code> for the respective types. If a host sends stream data for stream <code class="docutils literal notranslate"><span class="pre">x</span></code> before having sent data over the lower-numbered streams of that type, then those streams are implicitly created. The stream identifier is encoded using a variable length integer. The largest possible stream identifier is thus <span class="math notranslate nohighlight">\(2^{62}-1\)</span>.</p>
<p>QUIC places all data inside <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that are then placed inside QUIC packets. The structure of a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame is shown in <a class="reference internal" href="#fig-quic-stream-frame"><span class="std std-numref">Listing 7</span></a>. This frame contains the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the Type of the Stream frame <a class="footnote-reference brackets" href="#f-stream-type" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></li>
<li><p>the identifier of the stream</p></li>
<li><p>the offset, i.e. the position of the first byte of the Stream data in the bytestream</p></li>
<li><p>the length of the data</p></li>
<li><p>the Stream Data</p></li>
</ul>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="fig-quic-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 7 </span><span class="caption-text">The QUIC STREAM frame</span><a class="headerlink" href="#fig-quic-stream-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x08..0x0f,</span>
<span class="go">   Stream ID (i),</span>
<span class="go">   Offset (i),</span>
<span class="go">   Length (i),</span>
<span class="go">   Stream Data (..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame carries data, but it can also terminate the corresponding stream. The lowest order bit of the Type field acts as a <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit. When set to zero, it indicates that subsequent data will be sent over this stream. When set to one, it indicates that the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains the last bytes sent over that stream. The stream is closed once the last byte of the stream has been delivered to the user application. Once a QUIC stream has been closed, it cannot be reused again over this connection.</p>
<p>Using this information, the receiver can easily reassemble the data received over the different streams. As an illustration, let us consider a server that has created two streams (stream <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>). The server sends <code class="docutils literal notranslate"><span class="pre">ABCD..</span></code> over stream <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">123</span></code> over stream <code class="docutils literal notranslate"><span class="pre">5</span></code> and closes it after having sent the third digit. The data from these streams could be encoded as shown in <a class="reference internal" href="#fig-quic-streams-example"><span class="std std-numref">Listing 8</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-streams-example">
<div class="code-block-caption"><span class="caption-number">Listing 8 </span><span class="caption-text">Data sent over two different streams</span><a class="headerlink" href="#fig-quic-streams-example" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 0</span>
<span class="go">   Length = 2</span>
<span class="go">   Stream Data = AB</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 5,</span>
<span class="go">   Offset = 0</span>
<span class="go">   Length = 1</span>
<span class="go">   Stream Data = 1</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 2</span>
<span class="go">   Length = 1</span>
<span class="go">   Stream Data = C</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0f,   /* FIN bit is set, end of stream */</span>
<span class="go">   Stream ID = 5,</span>
<span class="go">   Offset = 1</span>
<span class="go">   Length = 2</span>
<span class="go">   Stream Data = 23</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 3</span>
<span class="go">   Length = 4</span>
<span class="go">   Stream Data = DEFG</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The penultimate frame shown in <a class="reference internal" href="#fig-quic-streams-example"><span class="std std-numref">Listing 8</span></a> has the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag set. It marks the end of stream <code class="docutils literal notranslate"><span class="pre">1</span></code> that has transported three bytes in total. The <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag is the normal way to gracefully close a QUIC stream.</p>
<p>There are however cases where an application might need to cancel a stream abruptly without closing the corresponding connection. First, the sending side of a stream can decide to reset the stream. For this, it sends a <code class="docutils literal notranslate"><span class="pre">RESET_STREAM</span></code> frame that carries the identifier of the stream that is canceled. The receiving side of a stream might also need to stop receiving data over a given stream. Consider for example a web browser that has started to download the different images that compose a web while the user has already clicked on another page from the same server. The streams that correspond to these images become useless. In this case, our browser can send a <code class="docutils literal notranslate"><span class="pre">STOP_SENDING</span></code> frame to indicate that it discards the incoming data over the corresponding streams. Upon reception of this frame, the server sends a <code class="docutils literal notranslate"><span class="pre">RESET_STREAM</span></code> frame to indicate that the corresponding stream has been closed.</p>
<section id="flow-control-in-quic">
<h3>Flow control in QUIC<a class="headerlink" href="#flow-control-in-quic" title="Link to this heading">#</a></h3>
<p>Transport protocols usually allocate some resources to each established connection. Each QUIC connection requires memory to store its state, but also buffers to store the packets arrived out-of-order. In practice, the memory available for QUIC implementations is not unlimited and a QUIC receiver must control the amount of packets that the remote host can send at any time. QUIC supports flow control techniques that operate at different levels.</p>
<p>The first level is the connection level.
During the handshake, each host can announce the maximum number of bytes that it agrees to receive initially on the connection using the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter. This parameter contains the number of bytes that the sending host agrees to receive without further notice. If the connection uses more bytes than initially agreed, the receiver can update this limit by sending a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame at any time. This frame contains a variable length integer that encodes the maximum amount of stream data that can be sent over the connection.</p>
<p>The utilization of different streams also consumes resources on a QUIC host. A receiver can also restrict the number of streams that the remote host can create. During the handshake, the <code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> and <code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> transport parameters announce the maximum number of bidirectional and unidirectional streams that the receiving host can accept. This limit can be modified during the connection by sending a <code class="docutils literal notranslate"><span class="pre">MAX_STREAMS</span></code> frame that updates the limit.</p>
<p>Flow control can also take place at the stream level. During the handshake, several transport parameters allow the hosts to advertise the maximum number of bytes that they agree to receive on each stream. Different transport parameters are used to specify the limits that apply to the local/remote and unidirectional/bidirectional streams. These limits can be updated during the connection by sending <code class="docutils literal notranslate"><span class="pre">MAX_STREAM_DATA</span></code> frames. Each of these frames indicates the maximum amount of stream data that can be accepted on a given stream.</p>
<p>These limits restrict the number of streams that a host can create and the amount of bytes that it can send. If a host is blocked by any of these limits, it may sent a control frame to request the remote host to extend the limit. For each type of flow control, there is an associated control frame which can be used to request an extension of the limit.</p>
<p>A host should send a <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame when it reaches the limit on the maximum amount of data set by the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter or a previously received <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame contains the connection limit that caused the transmission to be blocked. In practice, a receiving host should increase the connection-level limit by sending <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frames before reaching the limit. However, since this limit is function of the available memory, a host might not always be able to send a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. <a class="reference internal" href="#fig-quic-example-max-data"><span class="std std-numref">Fig. 93</span></a> provides an example packet flow with the utilization of these frames. We assume that the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter was set to <code class="docutils literal notranslate"><span class="pre">100</span></code> bytes by the client during the handshake and the the server needs to send 900 bytes. The server creates a stream and sends 100 bytes in a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet carrying a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. At this point, the server is blocked.</p>
<div class="figure" id="id26" style="text-align: center">
<span id="fig-quic-example-max-data"/><p><img src="../Images/5b5d3482cca71cc31e8478d8c94c256b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c022aa52c8641e07e76b1f1051d14b43b01af635.png"/></p>
<p><span class="caption-number">Fig. 93 </span><span class="caption-text">QUIC uses <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frames when a connection’s flow control is blocked</span></p>
</div><p>The same applies with the <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frame that is sent when a host reaching the per-stream limit. The <code class="docutils literal notranslate"><span class="pre">STREAMS_BLOCKED</span></code> frame is used when a host has reached the maximum number of established streams.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Connections blocked by flow control are not totally idle</p>
<p>If a QUIC host detects that a connection is blocked by flow control, it should regularly send <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> or <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frames to request the remote host to extend the current limit. The QUIC specification <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> does not recommend precisely how often these frames should be sent when a connection is blocked by flow control. Experience with QUIC deployments will enable the QUIC developers to more precisely define how often these frames should be sent.</p>
<p>A measurement study <a class="reference internal" href="../bibliography.html#mhlq2020" id="id8"><span>[MHLQ2020]</span></a> revealed that QUIC implementations used different strategies for flow control. They identified three main types of behaviors :</p>
<blockquote>
<div><ul class="simple">
<li><p>Static Flow Control: the receive buffer size stays unchanged and the receiver simply increases the maximum allowance linearly</p></li>
<li><p>Growing Flow Control: the size of the receive buffer increases over time as the connection progresses</p></li>
<li><p>Auto-tuning: the size of the receive buffer is adjusted dynamically based on the estimated bandwidth and round-trip times</p></li>
</ul>
</div></blockquote>
<p>In 2020, three quarter of the studied implementations used a Static Flow Control and only one used auto-tuning. Static Flow Control can work, but this is a waste of memory. For example, Google’s Chrome starts with a 15 MBytes receive buffer and updates it linearly <a class="reference internal" href="../bibliography.html#mhlq2020" id="id9"><span>[MHLQ2020]</span></a>. This should be contrasted with TCP implementations that usually start with a window of a few tens of KBytes and adjust it with auto-tuning. Auto-tuning is a key feature of modern TCP implementations <a class="reference internal" href="../bibliography.html#smm1998" id="id10"><span>[SMM1998]</span></a>. It is expected that QUIC implementations will include more advanced heuristics to tune their flow control mechanism.</p>
</div>
</section>
<section id="quic-loss-detection">
<h3>QUIC Loss Detection<a class="headerlink" href="#quic-loss-detection" title="Link to this heading">#</a></h3>
<p>As other transport protocols, QUIC includes mechanisms to detect transmission errors and packet losses. The transmission errors are usually detected by using the UDP checksum or at the datalink layer with the Wi-Fi or Ethernet CRCs. When a transmission error occurs, the corresponding packet is discarded and QUIC considers this error as a packet loss. Researchers have analyzed the performance of checksums and CRCs on real data <a class="reference internal" href="../bibliography.html#sgp98" id="id11"><span>[SGP98]</span></a>.</p>
<p>Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated and a receiver can leverage this AEAD to detect transmission errors that were undetected by the UDP checksum of the CRC of the lower layers. However, these undetected transmission errors are assumed to be rare and if QUIC a detects an invalid AEAD, it will consider that this error was caused by an attack and will stop the connection using a TLS alert <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>.</p>
<p>There are several important differences between the loss detection and retransmission mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers always increase monotonically over a QUIC connection. A QUIC sender never sends twice a packet with the same packet number over a given connection. QUIC encodes the packet numbers as variable length integers and it does not support wrap around in contrast with other transport protocols. The QUIC frames contain the valuable information that needs to be delivered reliably. If a QUIC packet is lost, the frames that it contained will be retransmitted in another QUIC packet that uses a different packet number. Thus, the QUIC packet number serves as a unique identifier of a packet. This simplifies some operations such as measuring the round-trip-time which is more difficult in protocols such as TCP when packets are transmitted <a class="reference internal" href="../bibliography.html#kp91" id="id12"><span>[KP91]</span></a>.</p>
<p>Second, QUIC’s acknowledgments carry more information than the cumulative or selective acknowledgments used by TCP and related protocols. This enables the receiver to provide a more detailed view of the packets that it received. In contrast with TCP <span class="target" id="index-19"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2018.html"><strong>RFC 2018</strong></a>, once a receiver has reported that one packet was correctly received in an acknowledgment, the sender of that packet can discard the corresponding frames.</p>
<p>Third, a QUIC sender autonomously decides which frames it sends inside each packet. A QUIC packet may contain both data and control frames, or only data or only control information. If a QUIC packet is lost, the frames that it contained could be retransmitted in different packets. A QUIC implementation thus needs to buffer the frames and mark the in-flight ones to be able to retransmit them if the corresponding packet was lost.</p>
<p>Fourth, most QUIC packets are explicitly acknowledged. The only exception are the packets that only contain <code class="docutils literal notranslate"><span class="pre">ACK</span></code>, <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> or <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frames. A packet that contains any other QUIC frame is called an ack-eliciting packet because its delivery will be confirmed by the transmission of an acknowledgment. A QUIC packet that carries both an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame will thus be acknowledged.</p>
<p>With this in mind, it is interesting to look at the format of the QUIC acknowledgments and then analyze how they can be used. <a class="reference internal" href="#fig-quic-ack-frame"><span class="std std-numref">Listing 9</span></a> provides the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types are used to distinguish between the acknowledgments that contain information about the received ECN flags (type <code class="docutils literal notranslate"><span class="pre">0x03</span></code>) or only regular acknowledgments (type <code class="docutils literal notranslate"><span class="pre">0x02</span></code>). The first information contained in the ACK frame is the largest packet number that is acknowledged by this ACK frame. This is usually the highest packet number received. The second information is the ACK delay. This is the delay in microseconds between the reception of the packet having the largest acknowledged number by the receiver and the transmission of the acknowledgment. This information is important to ensure that round-trip-times are accurately measured, even if a receiver delays acknowledgments. This is illustrated in <a class="reference internal" href="#fig-quic-ack-delay"><span class="std std-numref">Fig. 94</span></a>. The <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span> <span class="pre">Count</span></code> field contains the number of <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">ranges</span></code> that are included in the QUIC ACK frame. This number can be set to zero if all packets were received in sequence without any gap. In this case, the <code class="docutils literal notranslate"><span class="pre">First</span> <span class="pre">ACK</span> <span class="pre">Range</span></code> field contains the number of the packet that arrived before the <code class="docutils literal notranslate"><span class="pre">Largest</span> <span class="pre">Acknowledged</span></code> packet number.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 9 </span><span class="caption-text">The QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-ack-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02..0x03,</span>
<span class="go">   Largest Acknowledged (i),</span>
<span class="go">   ACK Delay (i),</span>
<span class="go">   ACK Range Count (i),</span>
<span class="go">   First ACK Range (i),</span>
<span class="go">   ACK Range (..) ...,</span>
<span class="go">   [ECN Counts (..)],</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="figure" id="id27" style="text-align: center">
<span id="fig-quic-ack-delay"/><p><img src="../Images/91a1bf7fc5600dfd204d9c3691a03f74.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-5980706b89e969a89f2ce0e7ef4f744e4a9b8928.png"/></p>
<p><span class="caption-number">Fig. 94 </span><span class="caption-text">Utilization of the QUIC ACK delay</span></p>
</div><p>An <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame contains 0 or more <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Ranges</span></code>. The format of an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">range</span></code> is shown in <a class="reference internal" href="#fig-quic-ack-range"><span class="std std-numref">Listing 10</span></a>. Each range indicates first the number of unacknowledged packets since the smallest acknowledged packet in the preceding range (or the first ACK range). The next field indicates the number of consecutive acknowledged packets.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-range">
<div class="code-block-caption"><span class="caption-number">Listing 10 </span><span class="caption-text">A QUIC ACK range</span><a class="headerlink" href="#fig-quic-ack-range" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Range {</span>
<span class="go">   Gap (i),</span>
<span class="go">   ACK Range Length (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>As an example, consider a host that received the following QUIC packets: <code class="docutils literal notranslate"><span class="pre">3,4,6,7,8,9,11,14,16,18</span></code>. To report all the received packets, it will generate the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame shown in <a class="reference internal" href="#fig-quic-sample-ack-frame"><span class="std std-numref">Listing 11</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-sample-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 11 </span><span class="caption-text">Sample QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-sample-ack-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged=18,</span>
<span class="go">   ACK Delay=x,</span>
<span class="go">   ACK Range Count=5,</span>
<span class="go">   First ACK Range=0,</span>
<span class="go">   ACK Range #0 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #1 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #2 [Gap=3, ACK Range Length=1],</span>
<span class="go">   ACK Range #3 [Gap=2, ACK Range Length=4],</span>
<span class="go">   ACK Range #4 [Gap=2, ACK Range Length=2]</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC specification recommends to send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame after having received two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments strategy. However, there is ongoing work to allow the sender to provide more guidelines on when and how <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames should be sent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When should QUIC hosts send acknowledgments</p>
<p>A measurement study <a class="reference internal" href="../bibliography.html#mhlq2020" id="id13"><span>[MHLQ2020]</span></a> analyzed how QUIC implementations generate acknowledgments. Two of the studied implementations sent acknowledgments every N packets (2 for one implementation and 10 for the other). Other  implementations used ack frequencies that varied during the data transfer.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id28">
<img alt="../_images/quic-1.png" class="plot-directive" src="../Images/3a962b543fdebe8ff46dbfacfe31e189.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 95 </span><span class="caption-text">Acknowledgment frequencies for different QUIC servers</span><a class="headerlink" href="#id28" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The acknowledgment frequencies should be compared with TCP that usually acknowledges every second packet. It is likely that QUIC implementations will tune the generation of their acknowledgments in the coming years based on feedback from deployment.</p>
</div>
<p>It is interesting to observe that since the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are sent inside QUIC packets, they can also be acknowledged. Sending an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> in response to another <code class="docutils literal notranslate"><span class="pre">ACK</span></code> could result in an infinite exchange of <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. To prevent this problem, a QUIC sender cannot send an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame in response to a non-eliciting QUIC packet and the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are one of the non-eliciting frame types. Note that if a receiver that receives many <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames and thus sends many <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames wants to obtain information about the reception of its <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, it can simply send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame inside a packet that contains an eliciting frame, e.g. a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. This frame will trigger the receiver to acknowledge it and the previously sent <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames.</p>
<p>In contrast with other reliable transport protocols, QUIC does not use cumulative acknowledgments. As explained earlier, QUIC never retransmits a packet with the same packet number. When a packet is lost, this creates a gap that the receiver reports using an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code>. Such a gap will never be filled by retransmissions and obviously should not be reported by the receiver forever. In practice, a receiver will send the acknowledgment that corresponds to a given packet number several times and then will assume that the acknowledgment has been received. A receiver can also rely on other heuristics to determine that a given <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code> should not be reported anymore. This is the case if the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame was included in a packet that has been acknowledged by the other peer, but also when the gap was noticed several round-trip times ago.</p>
<p>QUIC also allows a receiver to send information about the ECN flags in the received packets. Two flags of the IP header <span class="target" id="index-20"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3168.html"><strong>RFC 3168</strong></a> are reserved to indicate support for Explicit Congestion Notification. The QUIC ECN count field shown in <a class="reference internal" href="#fig-quic-ecn-count"><span class="std std-numref">Listing 12</span></a> contains three counters for the different values of the ECN flags. These counters are incremented upon the reception of each QUIC packet based on the values of the ECN flag of the received packet. Unfortunately, there are still many operational  problems when using ECN in the global Internet <a class="reference internal" href="../bibliography.html#mlbba2018" id="id14"><span>[MLBBA2018]</span></a>. Time will tell whether it is easier to deploy ECN with QUIC than with TCP.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ecn-count">
<div class="code-block-caption"><span class="caption-number">Listing 12 </span><span class="caption-text">A QUIC ECN Count</span><a class="headerlink" href="#fig-quic-ecn-count" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ECN Counts {</span>
<span class="go">   ECT0 Count (i),</span>
<span class="go">   ECT1 Count (i),</span>
<span class="go">   ECN-CE Count (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUIC also acknowledges control frames</p>
<p>Besides the STREAM frames that carry user data, QUIC uses several different frame types to exchange control information. These control frames, like the data frames, are ack-eliciting frames. This implies a host that receives such a frame needs to acknowledge it using an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame.</p>
<p><a class="reference internal" href="#fig-quic-ack-initials"><span class="std std-numref">Fig. 97</span></a> illustrates the beginning of a QUIC connection with the exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets and the corresponding acknowledgments. The client sends its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> inside a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame in an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This is the first packet sent by the client and thus its packet number is 0. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> inside a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame in an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. Since this is the first packet sent by the server, its packet number is also 0. The packet also contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the reception of the packet containing the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Handshake</span></code>, <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> and <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are acknowledged similarly using <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets are acknowledged in other <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets while <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> and <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are acknowledged inside <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets.</p>
</div>
<div class="figure" id="id30" style="text-align: center">
<span id="fig-quic-ack-initials"/><p><img src="../Images/75ed846fe9a217630046fd48dc876f1b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-626d297d8c568bae6dcfb3764695c72d549a86cc.png"/></p>
<p><span class="caption-number">Fig. 97 </span><span class="caption-text">QUIC also acknowledges Initial frames</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all QUIC servers use 0 as the packet number of their first Initial packet</p>
<p>The example shows a QUIC connection where the client sent its Initial packet with packet number 0 and the server also replied with a packet number set to 0. This is what most QUIC implementations do. However, the QUIC specification does not strictly requires this. In fact, <code class="docutils literal notranslate"><span class="pre">facebook</span></code> servers in October 2022 appear to use random packet numbers for the Initial packet that they sent in response to a client. This is probably use to detect or mitigate some forms of attacks since the client must receive the server’s Initial packet to be able to produce a valid acknowledgment.</p>
</div>
<p>To illustrate how QUIC uses acknowledgments, let us consider a simple QUIC connection. The client starts a QUIC connection with a new server, sends a request, receives a response and then closes the connection. There are no losses in this connection. <a class="reference internal" href="#fig-quic-ack-short"><span class="std std-numref">Fig. 98</span></a> illustrates this connection.</p>
<div class="figure" id="id31" style="text-align: center">
<span id="fig-quic-ack-short"/><p><img src="../Images/00d236df000f95dc0877d8231f52d999.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-1fc45a23ddaacb37c26a462d2202c00cd14b01c7.png"/></p>
<p><span class="caption-number">Fig. 98 </span><span class="caption-text">Acknowledgments in a short QUIC connection</span></p>
</div><p>The connection starts when the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code>. The server replies with an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet that contains an acknowledgment and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. The server then sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code>. Since this is the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet, its packet number is set to 0. In practice, it is likely that the server will need to send several packets to carry the certificates contained in this packet. Note that the server cannot send more than 3 packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This limit was introduced in the QUIC specification to restrict the ability of attackers to trigger DDoS attacks by sending spoofed packets to QUIC servers <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. If the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame containing the certificates is too long, the server might need to wait for acknowledgments from the client before sending its last <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The client confirms the reception of the server’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet by sending its last <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet that contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. This is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client and its packet number is thus 1. Since this packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, the server does not return an acknowledgment to confirm its reception.</p>
<p>The client replies to the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet with another <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame and acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server. The client’s <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet is acknowledged by the server. The server starts the data exchange by sending a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet carrying one or more stream frames to create the required streams. Since this is the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server, its packet number is set to 0. The client then sends its request in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. The server replies with a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame with its response. The client ends the connection by sending a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. In the example, the server replies with a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame, but the QUIC specification <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> only indicates that a host may respond with a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> in this case.</p>
</section>
<section id="observing-quic-connections">
<h3>Observing QUIC connections<a class="headerlink" href="#observing-quic-connections" title="Link to this heading">#</a></h3>
<p>We have now reviewed the main components of the QUIC specification. To illustrate it, let us consider a simple scenario where a client opens a QUIC connection with a server. We leverage Maxime Piraux’s QUIC tracker <a class="reference internal" href="../bibliography.html#pdb2018" id="id15"><span>[PDB2018]</span></a>. In this example, we use the packet trace collected using the <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> server on November 22, 2021 at 18:04:52 CET. This trace is available from <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/148">https://quic-tracker.info.ucl.ac.be/traces/20211122/148</a>. You can see the contents of the packets, download it as a <code class="docutils literal notranslate"><span class="pre">.pcap</span></code> trace or visualize it using QLog/QViz <a class="reference internal" href="../bibliography.html#mpql2020" id="id16"><span>[MPQL2020]</span></a> from this web site.</p>
<p>This trace contains 16 packets. The scenario is a simple handshake with an exchange of data.</p>
<figure class="align-default" id="id32">
<img alt="../_images/qtracker-nghttp2-1.png" src="../Images/7e3eb62de8971ff53e65f8fbea028144.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-nghttp2-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 99 </span><span class="caption-text">Sample QUIC tracker trace with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> containing a successful handshake</span><a class="headerlink" href="#id32" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>To initiate the connection, the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> QUIC packet.  It is interesting to analyze the content of this packet. It starts with a long QUIC header shown in <a class="reference internal" href="#fig-trace-quic-header-p1"><span class="std std-numref">Listing 13</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p1">
<div class="code-block-caption"><span class="caption-number">Listing 13 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p1" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 00,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0x6114ca6ecbe483bb,</span>
<span class="go">  Source Connection ID Length (8) = 8,</span>
<span class="go">  Source Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 1226,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (8..) = CRYPTO,</span>
<span class="go">  Type-Specific Payload (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The client proposes a 64 bits connection identifier and uses a random 64 bits identifier for the destination connection identifier. There is no token in this packet since this is the first connection from this client to the server. It is useful to note that the packet number of this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet is set to zero. All QUIC connections start with a packet whose packet number is set to zero in contrast with TCP that uses a random sequence number. The packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame shown in <a class="reference internal" href="#fig-trace-quic-crypto-p1"><span class="std std-numref">Listing 14</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-crypto-p1">
<div class="code-block-caption"><span class="caption-number">Listing 14 </span><span class="caption-text">The CRYPTO frame of the first QUIC packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-crypto-p1" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">CRYPTO Frame {</span>
<span class="go">   Type (i) = 0x06,</span>
<span class="go">   Offset (i) = 0,</span>
<span class="go">   Length (i) = 245,</span>
<span class="go">   Crypto Data = ClientHello</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame starts at offset 0 and has a length of <code class="docutils literal notranslate"><span class="pre">245</span></code> bytes. It contains a TLS 1.3 <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message whose format is specified in <span class="target" id="index-23"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. This <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> includes a 32 bytes secure random number, a set of proposed cipher suites and a series of TLS extensions. One of these extensions carries the QUIC transport parameters proposed by the client. On this connection, the QUIC tracker client proposed the following ones:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_bidi_local</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_uni</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> = 0x80008000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> = 0x1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> = 0x3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> = 0x6710</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">active_connection_id_limit</span></code> = 0x4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_packet_size</span></code> = 0x45c0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inital_source_connection_id</span></code> = 0xc9f54d3c298296b9</p></li>
</ul>
</div></blockquote>
<p>Finally, the first QUIC packet contains a <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> frame with 960 dummy bytes. The entire packet is 1236 bytes long.</p>
<p>The server responds to this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet with two packets. The first one is an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It starts with the header shown in <a class="reference internal" href="#fig-trace-quic-header-p2"><span class="std std-numref">Listing 15</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p2">
<div class="code-block-caption"><span class="caption-number">Listing 15 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 10,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Source Connection ID Length (8) = 18,</span>
<span class="go">  Source Connection ID (0..160) = 0x8d3470255ae3b0b3fad3c40515132a813dfa,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 149,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (...)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This server uses 18 bytes to encode its connection identifier and proposes the first identifier in the long header. The packet payload contains two frames: an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame (<a class="reference internal" href="#fig-trace-quic-ack-p2"><span class="std std-numref">Listing 16</span></a>) acknowledges the reception of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the TLS ServerHello.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-ack-p2">
<div class="code-block-caption"><span class="caption-number">Listing 16 </span><span class="caption-text">The ACK Frame of the first packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-ack-p2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged = 0,</span>
<span class="go">   ACK Delay = 0,</span>
<span class="go">   ACK Range Count = 0,</span>
<span class="go">   First ACK Range = 0</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The payload of these <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets is encrypted using the static key derived from the connection identifiers included in the long header.</p>
<p>The server then sends three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets carrying a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code>. These extensions are encrypted using the TLS key. They mainly contain the server certificate. It is interesting to note that the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> field of the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the server is also set to zero. This is the second, but not the last, packet that we observe with this <code class="docutils literal notranslate"><span class="pre">packet_number</span></code>. QUIC handles packet numbers differently then other protocols. QUIC considers that a QUIC connection is divided in three phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets</p></li>
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets</p></li>
<li><p>The exchange of the other packets (<code class="docutils literal notranslate"><span class="pre">0-RTT</span></code>, <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code>, … packets)</p></li>
</ol>
</div></blockquote>
<p>A QUIC host restarts the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> at zero in each phase. This explains why it is possible to observe different packets (of different types) with the same <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> over a QUIC connection.</p>
<p>The three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server contain the beginning of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> sent by the server. To prevent denial of service attacks, the server cannot send more than three full-length packets in response to a packet sent by the client. The server thus needs to wait for an acknowledgment from the client before sending additional packets.</p>
<p>The client sends two packets to carry these acknowledgments. First, it sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet as the sixth packet of the trace. This packet belongs to the packet numbering space of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets. Its packet number is 1 since this is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The next acknowledgment is carried inside an <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet. It acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets 0-2 sent by the server. Since this is the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the client, its packet number is also 0.</p>
<p>The server then sends the eighth packet that contains the last part of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. By combining the information contained in the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets and the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets, the client can derive the session keys.</p>
<p>The server immediately sends its first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. This packet contains a short header shown in <a class="reference internal" href="#fig-trace-quic-short-header"><span class="std std-numref">Listing 17</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 17 </span><span class="caption-text">The QUIC short header of the first 1-RTT packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-short-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1) = 0,</span>
<span class="go">   Reserved Bits (2)= 00,</span>
<span class="go">   Key Phase (1) = 0,</span>
<span class="go">   Packet Number Length (2)= 0,</span>
<span class="go">   Destination Connection ID = 0xc9f54d3c298296b9,</span>
<span class="go">   Packet Number = 0,</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This short header contains the connection identifier proposed by the client in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. The payload contains <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that create three streams. The client replies with two packets. The tenth packet of the trace is a <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that carries two frames. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Finished</span></code> message that finalizes the TLS handshake. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame acknowledges the four <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server.</p>
<p>The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the client contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server and flow control information. The client sends a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame to restrict the amount of data that the server can send and one <code class="docutils literal notranslate"><span class="pre">MAX_STREAM</span></code> frame for each of the three streams created by the server.</p>
<p>The twelfth packet of the trace is more interesting. It contains five different frames that are sent by the server. First, the server send two <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames that advertise two 18 bytes long connection identifiers which can be used by the client to migrate the connection later. The next frame is the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame that confirms the TLS handshake. The server also sends a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame that contains a 57 bytes long token that the client will be able to use in subsequent connections with the server. The last frame is a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Tickets</span></code>.</p>
<section id="a-closer-look-at-other-quic-handshakes">
<h4>A closer look at other QUIC handshakes<a class="headerlink" href="#a-closer-look-at-other-quic-handshakes" title="Link to this heading">#</a></h4>
<p>It is interesting to analyze how different servers perform the handshake using QUIC tracker. Let us first explore the <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/140">trace collected with cloudflare-quic.com</a> on the same day shown in <a class="reference internal" href="#fig-qtracker-cloudflare"><span class="std std-numref">Fig. 100</span></a>. There are several differences with the nghttp2 trace that we analyzed above. First, the server sends two small packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code>. The first packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. It advertises a 20 bytes long connection identifier. The second packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Hello</span> <span class="pre">Retry</span> <span class="pre">Request</span></code>. This message indicates that the server did not agree with the <code class="docutils literal notranslate"><span class="pre">key_share</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> sent in the first packet. The client acknowledges this packet and sends a new <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> in the fourth packet. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> and then the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in three QUIC packets. The certificate used by <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> is more compact than the one used by <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>.</p>
<figure class="align-default" id="id33">
<span id="fig-qtracker-cloudflare"/><img alt="../_images/qtracker-cloudflare-1.png" src="../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-cloudflare-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 100 </span><span class="caption-text">Sample quic tracker trace from cloudflare-quic.com with a successful handshake</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are also slightly different. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server contains the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame, a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code> messages and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates one stream. The server then sends two short packet. Each of these packets contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates a new stream. These two short packets could have been packed in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server. In contrast with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>, <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> does advertise new connection identifiers.</p>
<p>Our third example is <a class="reference external" href="https://github.com/private-octopus/picoquic">picoquic</a>. The <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/159">QUIC tracker trace with test.privateoctopus.com</a> contains 13 packets.</p>
<figure class="align-default" id="id34">
<span id="fig-qtrack-picoquic-1"/><img alt="../_images/qtracker-picoquic-1.png" src="../Images/2caed6d4f9f898a962846ed3d2e47a9b.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 101 </span><span class="caption-text">Sample QUIC tracker trace from <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with a successful handshake</span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>picoquic uses 64 bits long connection identifiers. It manages to fit its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> within two <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that it sends contains a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. The second <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet contains one <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that advertises one <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code>, three <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames and a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame. This test server does not try to create new streams in contrast with the two others.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Comparing QUIC servers</p>
<p>It is interesting to use the traces collected by QUIC tracker to analyze how different servers have selected some of the optional features of QUIC. A first difference between the servers is the length of the server-selected connection identifiers. The graph below shows that in November 2021 many servers advertised 8 bytes CIDs, but some have opted for much longer CIDs.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id35">
<img alt="../_images/quic-2.png" class="plot-directive" src="../Images/8fa0ce7b276beb5ece519f6198e8c9be.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-2.png"/>
<figcaption>
<p><span class="caption-number">Fig. 102 </span><span class="caption-text">Length of the connection identifiers advertised by different QUIC servers (Nov 2021)</span><a class="headerlink" href="#id35" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
</section>
<section id="observing-0-rtt-data-in-quic">
<h4>Observing 0-RTT data in QUIC<a class="headerlink" href="#observing-0-rtt-data-in-quic" title="Link to this heading">#</a></h4>
<p>The ability to send data immediately was one of the requirements for the design of QUIC. It is interesting to observe how QUIC uses the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets for this purpose. We use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/619">trace collected between QUIC tracker and picoquic as our example</a>. This trace covers two QUIC connections shown in <a class="reference internal" href="#fig-qtrack-picoquic-0rtt"><span class="std std-numref">Fig. 104</span></a>.</p>
<figure class="align-default" id="fig-qtrack-picoquic-0rtt">
<img alt="../_images/qtracker-picoquic-0rtt.png" src="../Images/805be77f81fd67d0f4dbcd3429f9074d.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-0rtt.png"/>
<figcaption>
<p><span class="caption-number">Fig. 104 </span><span class="caption-text">Sample QUIC trace with <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with 0-RTT packets</span><a class="headerlink" href="#fig-qtrack-picoquic-0rtt" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>During the first QUIC connection, QUIC tracker receives one TLS session ticket in the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contained in the 1-RTT packet that the server sent with packet number set to 0. This ticket contains all the information required by the server to retrieve the key in a subsequent connection. QUIC tracker starts the second connection by sending an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> message. A comparison between this <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the one sent to create the first connection shows that the latter contains the <code class="docutils literal notranslate"><span class="pre">psk_key_exchange_modes</span></code> TLS extension. This extension contains the information that enables the server to recover the key required to decrypt the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. In this example, the client sends a <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> that contains the beginning of a simple <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code>.</p>
</section>
<section id="quic-streams">
<h4>QUIC streams<a class="headerlink" href="#quic-streams" title="Link to this heading">#</a></h4>
<p>As QUIC support multiple streams, it is interesting to analyze how the streams are managed over a real QUIC connection. For this example, we use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/375">trace between QUIC tracker and quic.tech</a> summarized in <a class="reference internal" href="#fig-qtrack-quictech"><span class="std std-numref">Fig. 105</span></a>. In the example, the QUIC tracker creates four streams and sends one <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code> request over each of them.</p>
<figure class="align-default" id="fig-qtrack-quictech">
<img alt="../_images/qtracker-quictech-1.png" src="../Images/0b2f8631f4b24e652268e6a998c32faa.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-quictech-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 105 </span><span class="caption-text">Sample QUIC trace with quic.tech using multiple streams</span><a class="headerlink" href="#fig-qtrack-quictech" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this trace, the client creates four streams in its first <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame sent in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-trace-stream-frame"><span class="std std-numref">Listing 18</span></a> shows the first of these <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames. The <code class="docutils literal notranslate"><span class="pre">Type</span></code> of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> is one octet structured as <code class="docutils literal notranslate"><span class="pre">0b00001OLF</span></code> where <code class="docutils literal notranslate"><span class="pre">O</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains an <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field. Bit <code class="docutils literal notranslate"><span class="pre">L</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the frame contains a <code class="docutils literal notranslate"><span class="pre">Length</span></code> field. Finally, the <code class="docutils literal notranslate"><span class="pre">F</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> to mark the end of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code>. In this test, QUIC Tracker sends 17 bytes over each stream and closes it.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 18 </span><span class="caption-text">The first QUIC STREAM frame sent by QUIC Tracker</span><a class="headerlink" href="#fig-quic-trace-stream-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001011,  # Offset=0, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Length = 17,</span>
<span class="go">   Stream Data = GET /index.html\r\n</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The server sends each response in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. <a class="reference internal" href="#fig-quic-trace-stream-frame-2"><span class="std std-numref">Listing 19</span></a> shows the frame returned by the server. Its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> bit is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. It carries the entire HTML page and its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field could have been ignored since this is the first frame of the stream.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame-2">
<div class="code-block-caption"><span class="caption-number">Listing 19 </span><span class="caption-text">The QUIC STREAM frame returned by the server</span><a class="headerlink" href="#fig-quic-trace-stream-frame-2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001111,  # Offset=1, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Offset = 0,</span>
<span class="go">   Length = 462,</span>
<span class="go">   Stream Data = &lt;!DOCTYPE html&gt;...</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f-stream-type" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>All <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames have a type that starts with <code class="docutils literal notranslate"><span class="pre">0b0001...</span></code>. The three low order bits of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame indicate the presence of the <code class="docutils literal notranslate"><span class="pre">Offset</span></code> and <code class="docutils literal notranslate"><span class="pre">Length</span></code> fields. The lowest order bit is the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit.</p>
</aside>
</aside>
</section>
</section>
</section>
&#13;

<h2>Frames and packets<a class="headerlink" href="#frames-and-packets" title="Link to this heading">#</a></h2>
<p>There is an important difference between QUIC and classical protocols like TCP or UDP. TCP and UDP send segments that are composed of a header followed by a sequence of bytes that constitutes the payload. In contrast and like SCTP, a QUIC packet contains a header followed by one or more frames. The QUIC header is much simpler and shorter than the TCP header. It only carries the information which is required in all QUIC packets. We will describe later the short and long QUIC headers. Each QUIC header starts with one byte that contains some flags and a 32 bits version field. QUIC defines different types of frames that we will discuss in this chapter. Some types of QUIC frames carry user data. Other types of QUIC frames carry control information. Some of these frames are used during the handshake only while others such as acknowledgments can be sent at any time. Each QUIC frame is a sequence of byte that starts with a one byte Type field. <a class="reference internal" href="#fig-quic-packet"><span class="std std-numref">Fig. 85</span></a> shows a QUIC packet containing two frames which is placed inside a UDP datagram. Neither the QUIC header nor the QUIC frames need to be aligned on 32 bits boundaries even if this alignment is convenient for <a class="reference internal" href="#fig-quic-packet"><span class="std std-numref">Fig. 85</span></a>. An important point to note is that a QUIC packet can mix both data and control frames in any order.</p>
<div class="figure" id="id18" style="text-align: center">
<span id="fig-quic-packet"/><p><img src="../Images/67f2552f1552b239338ebf98d5fb0e85.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-ed2f67fd11ab4c57f149a6abb80b6cc76f6dd0d6.png"/></p>
<p><span class="caption-number">Fig. 85 </span><span class="caption-text">A QUIC packet is sent inside a UDP datagram and contains one or more QUIC frames</span></p>
</div>&#13;

<h2>Connection establishment<a class="headerlink" href="#connection-establishment" title="Link to this heading">#</a></h2>
<p>QUIC uses a four-way handshake to create a QUIC connection. <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a> describes this handshake. The QUIC handshake has three main purposes. First, it allows to negotiate the crypto keys required to both encrypt and authenticate the packets that will be sent later on the connection. This is mainly done using TLS 1.3 <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. Second, it allows to negotiate different options using transport parameters. Third, the server can validate that the client can respond to the address used to send the initial packet. This validation allows to prevent denial of service attacks using spoofed addresses.</p>
<div class="figure" id="id19" style="text-align: center">
<span id="fig-quic-handshake"/><p><img src="../Images/5e44a71ad373032f5a20d036f58c2000.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-9f0472102e8c53ef8c6a54916938c4807df9effa.png"/></p>
<p><span class="caption-number">Fig. 86 </span><span class="caption-text">Simplified QUIC Handshake</span></p>
</div><p>The client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. This packet carries the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the transport parameters proposed by the client for this connection. The server replies with an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing also a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. This one contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. It is immediately followed by one or more <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets containing also a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code>. The contents of this frame is encrypted using the session key derived from the information contained in the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. It mainly contains the certificate and the transport parameters of the server. This frame can be spread over several QUIC packets. The client replies with a <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Finished</span></code> message. The server later confirms the end of the TLS handshake by sending a <code class="docutils literal notranslate"><span class="pre">Handshake_Done</span></code> frame.</p>
<p>Before looking at the details of the negotiation of the cryptographic parameters, it is interesting to see how QUIC counters denial of service attacks that use spoofed addresses. During such attack, host <cite>x</cite> sends packets using the address of host <cite>y</cite> as their source. The main risk of such attacks is that the server could send a large number of packets towards address <cite>y</cite> although the host owning this address did not try to establish a QUIC connection with the server. QUIC prevents such attacks by using two distinct techniques. First, and this is unusual for transport protocols, the Initial QUIC packet sent by the client is large. The first packet sent to create a QUIC connection must contain a UDP payload of at least 1200 bytes <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. Such a packet contains a CRYPTO frame has shown in the figure, but also padding frames to fill the packet. If an attacker wants to send spoofed packets to initiate a connection with a server, it needs to send more than one KByte for each connection attempt. This should be compared with the 40 bytes of the TCP and IPv4 headers that must be sent to initiate a TCP connection. Another advantage of sending a large initial packet, the client can also perform Path MTU discovery and detect routers that could fragment the QUIC packets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Address spoofing</p>
<p>In theory, an Internet host should only send packets using its IPv4 and IPv6 source addresses. In practice, incorrectly configured hosts can use other addresses than their assigned one. Furthermore, attackers often change their source address to hide some of their activities. A frequent situation are denial of service (DoS) attacks. A simple DoS attack is when a host sends a large volume of packets to a victim. If the attacker sends these packets using another address than its official IP address, it makes it more difficult for the victim to identify the source of the attack.</p>
<p>But there is another category of DoS attack that is more worrisome. If an attacker can send a packets using the source address of the victim to a server, the server would return a response to the victim. These attackers use Internet servers that send a large response, possibly using multiple packets to a single request packet. They have exploited protocols such as DNS, NTP or applications such as <a class="reference external" href="https://www.memcached.org/">memcached</a> . The main problem with such attacks is that the server amplifies the volume of the attack generated by the clients. As there are very powerful servers on the Internet, this can be a huge problem and such attacks have reached volumes of hundreds of Gbps. The IETF and network operators have published recommendations to configure access networks to block spoofed packets <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2827.html"><strong>RFC 2827</strong></a>. Unfortunately, there are still portions of the Internet where attackers can send spoofed packets <a class="reference internal" href="../bibliography.html#lbkkkc2019" id="id3"><span>[LBKKKC2019]</span></a>.</p>
</div>
<p>The second mitigation against denial-of-service attacks using spoofed packets operates on the server. When a server receives an initial packet from a client, it may respond with an initial packet as shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a>. This could for example be the case of an enterprise server that receives a request from a host of a known enterprise subnet. The server could also want to validate the client and verify that the client can receive the packets that it sends. For this, it returns a Retry frame and a Token. This token is an opaque field that is constructed in a way that makes it easy for the server to validate the subsequent client packets and difficult for the client to predict the token that a server will create. A possible approach is to compute a secure hash of a message that contains the source IP addresses and ports used by the client, a secret value only known by the server and possibly some timing information to enable the server to ignore older tokens. Faced with the same problem, TCP <cite>syn cookies</cite> are encoded using fewer bits and thus inherently less secure. <a class="reference internal" href="#fig-quic-handshake-retry"><span class="std std-numref">Fig. 87</span></a> shows a QUIC handshake that includes a validation of the client address.</p>
<div class="figure" id="id20" style="text-align: center">
<span id="fig-quic-handshake-retry"/><p><img src="../Images/c3f57d5ce5702e99d69cee08ac7baddb.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-569f0b174611af526a584356e0900b74d003d137.png"/></p>
<p><span class="caption-number">Fig. 87 </span><span class="caption-text">Simplified QUIC Handshake with address validation</span></p>
</div><p>Address validation improves the resilience of servers against denial of service attacks using spoofed addresses, but this comes at the expense of a longer connection establishment delay. QUIC version 1 includes several additional techniques to reduce the impact of address validation while still preventing denial of service attacks.</p>
<section id="identifying-quic-connections">
<h3>Identifying QUIC connections<a class="headerlink" href="#identifying-quic-connections" title="Link to this heading">#</a></h3>
<p>A TCP connection is identified by a four tuple <span class="math notranslate nohighlight">\(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\)</span>. All packets belonging to a given connection carry this information in their IP and TCP headers. As QUIC runs above UDP, a simple approach could have been to use the UDP four tuple to identify each QUIC connection. Although simple, this solution would have severely restricted the flexibility of QUIC and the scalability of QUIC servers. The QUIC designers have opted for locally unique connection identifiers (CID) that are selected by the client and the server. These identifiers are placed in the QUIC packet headers during the handshake. When sending the Initial packet, the client selects a source CID that uniquely identifies the connection on the client and a random destination CID. Upon reception of this packet, the server selects its own connection identifier. It echoes the client selected CID and returns its selected CID. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-cid"><span class="std std-numref">Fig. 88</span></a>.</p>
<div class="figure" id="id21" style="text-align: center">
<span id="fig-quic-handshake-cid"/><p><img src="../Images/5c6ab95bb24bea00f667803dec9da315.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-943d4269d0b439918f506597c12f6399e6a3d0ed.png"/></p>
<p><span class="caption-number">Fig. 88 </span><span class="caption-text">Connection identifiers during a simplified QUIC Handshake</span></p>
</div><p>The connection identifiers selected by the client and the server uniquely identify the QUIC connection. However, in contrast with TCP and UDP, the two identifiers are not present in all packets. Since a host selects a unique identifier for each connection, it only needs this identifier to identify a connection to which a packet belongs. For this reason, the QUIC packets exchanged on a connection after the handshake only contain the destination CID, i.e. the CID selected by the host that receives the packet.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Variable length CIDs</p>
<p>Most transport protocols rely on fixed-length fields because this simplifies the parsing of packet headers. For example, the TCP and UDP port numbers are encoded as a 16 bits field. However, using fixed-length fields also limits the extensibility of the protocol. A TCP server cannot listen to more than <span class="math notranslate nohighlight">\(2^{16}\)</span> different ports.</p>
<p>QUIC has opted for variable length CIDs to support very different use cases. On the server side, the length of the selected connection identifiers will depend on the architecture of the server. Large sites might use a load balancer that distributes the connections to different physical servers. Such a load-balancer can leverage the CID to direct each incoming packet to the server that handles this connection. A simple CID would be composed of a server identifier chosen by the load balancer, e.g. in the high order bits of the CID, followed by a connection identifier selected by the physical server. Other designs are possible, e.g. by encrypting the CID to prevent attacks where malicious clients try to target a specific server.</p>
<p>One the client side, variable lengths CIDs bring another benefit. As clients typically manage a small number of QUIC connections, they can simply rely on the destination port of the packets that they receive to identify the corresponding QUIC connection. This corresponds to a zero-length connection identifier. Such a CID is never sent by the server after the handshake. This limits the byte overhead of the packets that clients receive.</p>
<p>A last point to note about these CIDs is their encoding inside the QUIC packets. The Initial packet contains the length and the value of both connection identifiers. The maximum length for a CID is 20 bytes. However, after the handshake, the packets that are exchanged over the QUIC connection only contain the destination CID without any field indicating its length. The host that has allocated the CID knows the length of the CIDs that it uses and can thus parse the packets that it receives without an explicit length information.</p>
</div>
</section>
<section id="security-keys">
<h3>Security keys<a class="headerlink" href="#security-keys" title="Link to this heading">#</a></h3>
<p>We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys that are used to authenticate and encrypt the packets exchanged over a connection. As shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a>, a QUIC connection starts with the exchange of four frames which can be carried in four or more packets. The first packet sent by the client contains the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> TLS record. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> contains the information required to derive the session keys using Diffie-Hellman or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic Curve Diffie-Hellman <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message also contains TLS or QUIC parameters that the client proposes to use during the connection. The <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> returned by the server contains the certificate that enables the client to validate the server’s identity and the information required to determine the Diffie-Hellman keys. Using these keys, the server also encrypts the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> message that contains the TLS and QUIC parameters that the server has selected based on the ones proposed in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server also constructs the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message that contains a message authentication code computed over the entire TLS handshake. This message is encrypted and authenticated using the session keys derived from the Diffie-Hellman keys. The client and the server recompute the hash of the entire handshake and verify both <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages. If one of these messages is incorrect, this indicates that either the key has not been correctly derived or that some of the TLS messages have been tampered. In these situations, the QUIC connection is terminated with an error message. The simplified TLS handshake used by QUIC is illustrated in <a class="reference internal" href="#fig-quic-tls-handshake"><span class="std std-numref">Fig. 89</span></a>. The TLS messages shown in italics are encrypted using the session keys.</p>
<div class="figure" id="id22" style="text-align: center">
<span id="fig-quic-tls-handshake"/><p><img src="../Images/68b73d74f409bc3b1f789ac93a363aa3.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-7918db6aa498e176259a65bc127c4105ca0aef60.png"/></p>
<p><span class="caption-number">Fig. 89 </span><span class="caption-text">Simplified TLS Handshake within a QUIC connection</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encrypting <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code></p>
<p>When TLS 1.3 is used above TCP, the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> messages are sent in clear because the client and the server have not yet exchanged the session keys. A similar approach could have been used for QUIC, but there was a fear that middleboxes could analyze the contents of these initial QUIC messages and try to interfere with them. To add some burden on these middleboxes, QUIC encrypts the Initial packets using a secret that is derived from the destination connection ID of the client’s first Initial packet. The pseudocode below, extracted from <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9001.html"><strong>RFC 9001</strong></a>, shows how the client and the server keys are derived:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">initial_salt</span> <span class="o">=</span> <span class="mh">0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a</span>
<span class="n">initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Extract</span><span class="p">(</span><span class="n">initial_salt</span><span class="p">,</span>
                        <span class="n">client_dst_connection_id</span><span class="p">)</span>

<span class="n">client_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
             <span class="s2">"client in"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="n">server_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
                           <span class="s2">"server in"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span><span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the keys used to protect the Initial packets are derived from the destination connection ID, any QUIC implementation, including those used on middleboxes, can decrypt the contents of the Initial packets.</p>
</div>
<p>As mentioned earlier, the client and the server can also use the TLS handshake to agree on specific QUIC parameters. These parameters are called <cite>transport parameters</cite> in QUIC <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. 17 different transport parameters are defined in QUIC version 1 <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> and implementations can define their own transport parameters. We will discuss some of them in different sections of this document. A first example is the <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> parameter that indicates the largest UDP payload that an implementation is willing to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations used in a datacenter supporting jumbo Ethernet frames could agree on a much larger <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> without risking packet fragmentation.</p>
<p>Another example of QUIC transport parameters are the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> and the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameters. As explained above, thanks to the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages in the TLS handshake, the client and the servers can verify that their messages have not been tampered. Unfortunately, the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages is only computed based on the contents of the TLS messages (i.e. <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>, <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>, <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> and <code class="docutils literal notranslate"><span class="pre">Finished</span></code>). During the handshake, the client and the servers also propose the source and destination connection identifiers that they plan to use to identify the QUIC session. These identifiers are placed in the packet header and not inside the TLS messages. They are thus not covered by the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message. To still authenticate these identifiers, QUIC encodes them as transport parameters that are included in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> and the <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> messages. The client copies the source connection identifier in the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> transport parameter in its <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server does the same when sending the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>. It also copies in the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameter the destination identifier used by the client to send the packet containing the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>.</p>
</section>
<section id="the-quic-packet-headers">
<h3>The QUIC packet headers<a class="headerlink" href="#the-quic-packet-headers" title="Link to this heading">#</a></h3>
<p>At this point, the QUIC session and the TLS security keys are known by the client and the server. They can start to exchange data. Before looking at how data is carried inside QUIC packets, it is interesting to explore in more details the packet headers that are placed inside each packet. QUIC uses variable length packet headers. Two different header formats exist. The first header format is the long header. This is the header used for the first packets of a QUIC connection.</p>
<p>Internet protocol specifications usually contain figures to represent the format of the packet headers. This graphical format is useful to get a quick grasp at a header containing fixed size fields. However, when a header contains several variable length fields, the graphical representation can become difficult to follow. The QUIC specification <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> uses the textual representation that was also used for the TLS protocol. As an example, let us consider the well-known TCP header. This header is graphically represented as shown in <a class="reference internal" href="#fig-quic-tcp-header"><span class="std std-numref">Fig. 90</span></a>.</p>
<div class="figure" id="id23" style="text-align: center">
<span id="fig-quic-tcp-header"/><p><img src="../Images/8bbfb429b7a940504df39c6677c533c7.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-55e7ccada8e8e238f1ed6e92591efe5c866e3b4a.png"/></p>
<p><span class="caption-number">Fig. 90 </span><span class="caption-text">Graphical representation of the TCP header</span></p>
</div><div class="literal-block-wrapper docutils container" id="fig-quic-tcp-text-header">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">Textual representation of the TCP header</span><a class="headerlink" href="#fig-quic-tcp-text-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">TCP Header Packet {</span>
<span class="go">  Source Port (16),</span>
<span class="go">  Destination Port (16),</span>
<span class="go">  Sequence Number (32),</span>
<span class="go">  Acknowledgment Number (32),</span>
<span class="go">  Offset (4),</span>
<span class="go">  Reserved (6),</span>
<span class="go">  Urgent Flag (1),</span>
<span class="go">  ACK Flag (1),</span>
<span class="go">  Push Flag (1),</span>
<span class="go">  RST Flag (1),</span>
<span class="go">  SYN Flag (1),</span>
<span class="go">  FIN Flag(1),</span>
<span class="go">  Window (16),</span>
<span class="go">  TCP Checksum (16),</span>
<span class="go">  Urgent Pointer (16),</span>
<span class="go">  TCP Options (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The attentive reader will easily understand the correspondence between the two formats. When explaining QUIC, we use the textual representation while we stick to the graphical one for TCP.</p>
<p><a class="reference internal" href="#fig-quic-long-header"><span class="std std-numref">Listing 3</span></a> shows the QUIC long header. It starts with one byte containing the header type in the most significant bit, two bits indicating the packet type and four bits that are specific to each packet packet. Then, 32 bits carry the QUIC version number. The current version of QUIC, defined in <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>, corresponds to version <code class="docutils literal notranslate"><span class="pre">0x00000001</span></code>. The header then contains the destination and source connection identifiers that were described previously and then a payload that is specific to each type.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-long-header">
<div class="code-block-caption"><span class="caption-number">Listing 3 </span><span class="caption-text">The QUIC long header</span><a class="headerlink" href="#fig-quic-long-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,                  /* high order bit of the first byte */</span>
<span class="go">  Fixed Bit (1) = 1,                    /* second order bit of the first byte */</span>
<span class="go">  Long Packet Type (2),                 /* third and fourth high order bits of the first byte */</span>
<span class="go">  Type-Specific Bits (4),               /* low order four bits of the first byte */</span>
<span class="go">  Version (32),                         /* 32 bits version number */</span>
<span class="go">  Destination Connection ID Length (8), /* 8 bits */</span>
<span class="go">  Destination Connection ID (0..160),   /* variable number from 0 up to 160 bits */</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Type-Specific Payload (..),           /* variable length */</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encoding packet numbers</p>
<p>Most transport protocols use fixed fields to encode packet numbers or byte offsets. The size of this field is always a trade-off. On one hand, a small packet number field limits the per packet overhead. On the other hand, a large packet number space is required to ensure that two packets carrying different data do not use the same packet number. TCP uses a 32 bits sequence number field that indicates the position of the first byte of the payload in the bytestream. This 32 bits field became a concern as bandwidth increased to Gbps and beyond <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7323.html"><strong>RFC 7323</strong></a>.</p>
<p>QUIC takes a different approach to sequence numbers. Each packet contains a per-packet sequence number. This number is encoded as a variable-length integer (<code class="docutils literal notranslate"><span class="pre">varint</span></code>). Such a <code class="docutils literal notranslate"><span class="pre">varint</span></code> has a length encoded in the two most significant bits of the first byte. If these bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code>, then the <code class="docutils literal notranslate"><span class="pre">varint</span></code> is encoded in one byte and can contain values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{6}-1\)</span>.  If the two most significant bits are set to <code class="docutils literal notranslate"><span class="pre">01</span></code>, the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{14}-1\)</span> within two bytes. When the two high order bits are set to <code class="docutils literal notranslate"><span class="pre">11</span></code> the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{62}-1\)</span> within four bytes.</p>
<p>There are other important differences between QUIC and other transport protocols when considering packet numbers. First, a QUIC sender must <em>never</em> reuse the same packet number for two different packets sent over a QUIC connection. If data needs to be retransmitted, it will be resent as a frame inside a new packet. Furthermore, since the largest possible packet number is <span class="math notranslate nohighlight">\(2^{62}-1\)</span>, a QUIC sender must close the corresponding connection once it has sent a QUIC packet carrying this packet number. This puts a restriction on the duration of QUIC connections. They cannot last forever in contrast to TCP connections such as those used to support BGP sessions between routers. An application that uses QUIC must be ready to restart a connection from time to time.</p>
</div>
<p>This long header is used for the <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handhsake</span></code> and <code class="docutils literal notranslate"><span class="pre">Retry</span></code> packets. Some of these packet types add new flags in the first byte and additional information after the connection identifiers. <a class="reference internal" href="#fig-quic-initial-header"><span class="std std-numref">Listing 4</span></a> shows the long header of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It contains two bits in the first byte that indicate the length of the packet number field. The packet specific part contains an option token, a length field, a packet number and a payload. The token length, length and packet number are encoded using variable length integers.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-initial-header">
<div class="code-block-caption"><span class="caption-number">Listing 4 </span><span class="caption-text">The QUIC long header of the Initial packet</span><a class="headerlink" href="#fig-quic-initial-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Initial Packet {</span>
<span class="go">  Header Form (1) = 1,                   /* High order bit first byte */</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 0,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),              /* Low order 2 bits of first byte */</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Token Length (i),</span>
<span class="go">  Token (..),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC short header contains fewer fields. The most significant bit of the first byte is set to 1 to indicate that the packet carries a short header. The other flags will be discussed later. The two least significant bits of this byte contain the length of the packet number field. It is interesting to note that in contrast with the long header, there is no explicit indication of the length of the destination connection identifier. This connection identifier has been assigned by the host that receives this packet and it already knows the length of the connection identifiers that it uses.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 5 </span><span class="caption-text">The QUIC short header used by 1-RTT packets</span><a class="headerlink" href="#fig-quic-short-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,                /* High order bit of first byte */</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1),</span>
<span class="go">   Reserved Bits (2),</span>
<span class="go">   Key Phase (1),</span>
<span class="go">   Packet Number Length (2),           /* Low order bits of first byte */</span>
<span class="go">   Destination Connection ID (0..160),</span>
<span class="go">   Packet Number (8..32),</span>
<span class="go">   Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The short header format, depicted in <a class="reference internal" href="#fig-quic-short-header"><span class="std std-numref">Listing 5</span></a>, is used by all QUIC packets once the session keys have been derived. This usually happens after one round-trip-time. These packets are called the 1-RTT packets in the QUIC specification <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. This notation is used to emphasize the fact that QUIC also supports 0-RTT packets, i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Coalescing packets</p>
<p>Besides the connection identifiers, another difference between the short and the long headers is the presence of the <code class="docutils literal notranslate"><span class="pre">Packet</span> <span class="pre">Length</span></code> field in the long header. This field might surprise the reader who is familiar with UDP since UDP also contains a Length field. As each QUIC packet is placed inside a UDP message, the QUIC Length field could seem redundant. This Length field was included in the QUIC long header to allow a QUIC sender to coalesce several consecutive and small packets inside a single UDP message. Some of the frames exchanged during the handshake are rather small. Sending a UDP message for each of these frames would be a waste of resources. Furthermore, a mix of <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> and <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets are exchanged when creating a QUIC connection. It would not be wise to require the utilization of one UDP message to send each of these packets. You might observe this optimization when analyzing packet traces collected on QUIC servers.</p>
</div>
</section>
<section id="rtt-data">
<h3>0-RTT data<a class="headerlink" href="#rtt-data" title="Link to this heading">#</a></h3>
<p>Latency is a key concern for transport protocols. The QUIC/TLS handshake that we have described until now allows the client and the server to agree on security keys within one round-trip-time. However, one round-trip-time can be a long delay for some applications. To minimize the impact of the connection setup time, QUIC allows applications to exchange data during the QUIC/TLS handshake. Such data is called 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client and the server must have previously agreed on a key which can be used to encrypt and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared key that the client and the server have shared without using the QUIC protocol or, and this is the most frequent solution, the key that they negotiated during a previous connection. In practice, the server enables 0-RTT by sending a TLS session ticket to the client <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. A session ticket is an encrypted record that contains information that enables the server to recover all the state information about a session including its session keys. It is also linked to the client’s address to enable the server to verify that a given client reuses the tickets that it has received earlier. Usually, these tickets also contain an expiration date. The client places the received ticket in the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">CLient</span> <span class="pre">Hello</span></code> that it sends in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It uses the pre-shared key corresponding to this ticket to encrypt data and place it in one or more <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets. The server uses the information contained in the ticket to recover the key and decrypt the data of the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-0-rtt-packet"><span class="std std-numref">Listing 6</span></a> shows the format of QUIC’s 0-RTT packet.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-0-rtt-packet">
<div class="code-block-caption"><span class="caption-number">Listing 6 </span><span class="caption-text">The QUIC 0-RTT packet</span><a class="headerlink" href="#fig-quic-0-rtt-packet" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">0-RTT Packet {</span>
<span class="go">  Header Form (1) = 1,                  /* High order bit of the first byte */</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 1,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),            /* Low order bits of the first byte */</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The main benefit of these <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets is that the client can immediately send encrypted data while sending its <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-ortt"><span class="std std-numref">Fig. 91</span></a> where the frames encrypted with the 0-RTT keys are shown in italics. Note that some of these frames can span several packets. <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets are only sent by the QUIC client since the server can send encrypted data immediately after having sent its <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> frames. As explained earlier, the Initial packets are also encrypted but using keys derived from the connection identifiers.</p>
<div class="figure" id="id24" style="text-align: center">
<span id="fig-quic-handshake-ortt"/><p><img src="../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-8755d75d243150f4626ac19898669b538f7aea0c.png"/></p>
<p><span class="caption-number">Fig. 91 </span><span class="caption-text">Simplified QUIC Handshake with 0-RTT data</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Replay attacks and 0-RTT packets</p>
<p>Thanks to the 0-RTT packets, a client can send encrypted data to the server before waiting for the secure handshake. This reduces the latency of the data transfer, but with one important caveat. QUIC does not provide any guarantee that 0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent operations. A detailed discussion of the impact of replay attacks may be found in <a class="reference internal" href="../bibliography.html#maccarthaigh2017" id="id4"><span>[MacCarthaigh2017]</span></a>.</p>
<p>To understand the importance of these replay attacks, let us consider a simple HTTP GET request. Such a request could easily fit inside the 0-RTT packet and thus have lower latency. If a web browser uses it to request a static <code class="docutils literal notranslate"><span class="pre">index.html</span></code> file, there is no harm if the request is received twice by the server. However, if the GET request is part of a REST API and has side effects, then problems could occur depending on the type of side effect. Consider a REST API that allows a user to switch off the lights using his or her smartphone. Replaying this request two or three times will always result in the light being switched off. However, if the user requests to increase the room temperature by one °C, then multiple replays will obviously have different consequences.</p>
</div>
</section>
&#13;

<h3>Identifying QUIC connections<a class="headerlink" href="#identifying-quic-connections" title="Link to this heading">#</a></h3>
<p>A TCP connection is identified by a four tuple <span class="math notranslate nohighlight">\(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\)</span>. All packets belonging to a given connection carry this information in their IP and TCP headers. As QUIC runs above UDP, a simple approach could have been to use the UDP four tuple to identify each QUIC connection. Although simple, this solution would have severely restricted the flexibility of QUIC and the scalability of QUIC servers. The QUIC designers have opted for locally unique connection identifiers (CID) that are selected by the client and the server. These identifiers are placed in the QUIC packet headers during the handshake. When sending the Initial packet, the client selects a source CID that uniquely identifies the connection on the client and a random destination CID. Upon reception of this packet, the server selects its own connection identifier. It echoes the client selected CID and returns its selected CID. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-cid"><span class="std std-numref">Fig. 88</span></a>.</p>
<div class="figure" id="id21" style="text-align: center">
<span id="fig-quic-handshake-cid"/><p><img src="../Images/5c6ab95bb24bea00f667803dec9da315.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-943d4269d0b439918f506597c12f6399e6a3d0ed.png"/></p>
<p><span class="caption-number">Fig. 88 </span><span class="caption-text">Connection identifiers during a simplified QUIC Handshake</span></p>
</div><p>The connection identifiers selected by the client and the server uniquely identify the QUIC connection. However, in contrast with TCP and UDP, the two identifiers are not present in all packets. Since a host selects a unique identifier for each connection, it only needs this identifier to identify a connection to which a packet belongs. For this reason, the QUIC packets exchanged on a connection after the handshake only contain the destination CID, i.e. the CID selected by the host that receives the packet.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Variable length CIDs</p>
<p>Most transport protocols rely on fixed-length fields because this simplifies the parsing of packet headers. For example, the TCP and UDP port numbers are encoded as a 16 bits field. However, using fixed-length fields also limits the extensibility of the protocol. A TCP server cannot listen to more than <span class="math notranslate nohighlight">\(2^{16}\)</span> different ports.</p>
<p>QUIC has opted for variable length CIDs to support very different use cases. On the server side, the length of the selected connection identifiers will depend on the architecture of the server. Large sites might use a load balancer that distributes the connections to different physical servers. Such a load-balancer can leverage the CID to direct each incoming packet to the server that handles this connection. A simple CID would be composed of a server identifier chosen by the load balancer, e.g. in the high order bits of the CID, followed by a connection identifier selected by the physical server. Other designs are possible, e.g. by encrypting the CID to prevent attacks where malicious clients try to target a specific server.</p>
<p>One the client side, variable lengths CIDs bring another benefit. As clients typically manage a small number of QUIC connections, they can simply rely on the destination port of the packets that they receive to identify the corresponding QUIC connection. This corresponds to a zero-length connection identifier. Such a CID is never sent by the server after the handshake. This limits the byte overhead of the packets that clients receive.</p>
<p>A last point to note about these CIDs is their encoding inside the QUIC packets. The Initial packet contains the length and the value of both connection identifiers. The maximum length for a CID is 20 bytes. However, after the handshake, the packets that are exchanged over the QUIC connection only contain the destination CID without any field indicating its length. The host that has allocated the CID knows the length of the CIDs that it uses and can thus parse the packets that it receives without an explicit length information.</p>
</div>
&#13;

<h3>Security keys<a class="headerlink" href="#security-keys" title="Link to this heading">#</a></h3>
<p>We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys that are used to authenticate and encrypt the packets exchanged over a connection. As shown in <a class="reference internal" href="#fig-quic-handshake"><span class="std std-numref">Fig. 86</span></a>, a QUIC connection starts with the exchange of four frames which can be carried in four or more packets. The first packet sent by the client contains the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> TLS record. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> contains the information required to derive the session keys using Diffie-Hellman or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic Curve Diffie-Hellman <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. The <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message also contains TLS or QUIC parameters that the client proposes to use during the connection. The <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> returned by the server contains the certificate that enables the client to validate the server’s identity and the information required to determine the Diffie-Hellman keys. Using these keys, the server also encrypts the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> message that contains the TLS and QUIC parameters that the server has selected based on the ones proposed in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server also constructs the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message that contains a message authentication code computed over the entire TLS handshake. This message is encrypted and authenticated using the session keys derived from the Diffie-Hellman keys. The client and the server recompute the hash of the entire handshake and verify both <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages. If one of these messages is incorrect, this indicates that either the key has not been correctly derived or that some of the TLS messages have been tampered. In these situations, the QUIC connection is terminated with an error message. The simplified TLS handshake used by QUIC is illustrated in <a class="reference internal" href="#fig-quic-tls-handshake"><span class="std std-numref">Fig. 89</span></a>. The TLS messages shown in italics are encrypted using the session keys.</p>
<div class="figure" id="id22" style="text-align: center">
<span id="fig-quic-tls-handshake"/><p><img src="../Images/68b73d74f409bc3b1f789ac93a363aa3.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-7918db6aa498e176259a65bc127c4105ca0aef60.png"/></p>
<p><span class="caption-number">Fig. 89 </span><span class="caption-text">Simplified TLS Handshake within a QUIC connection</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encrypting <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code></p>
<p>When TLS 1.3 is used above TCP, the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> messages are sent in clear because the client and the server have not yet exchanged the session keys. A similar approach could have been used for QUIC, but there was a fear that middleboxes could analyze the contents of these initial QUIC messages and try to interfere with them. To add some burden on these middleboxes, QUIC encrypts the Initial packets using a secret that is derived from the destination connection ID of the client’s first Initial packet. The pseudocode below, extracted from <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9001.html"><strong>RFC 9001</strong></a>, shows how the client and the server keys are derived:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">initial_salt</span> <span class="o">=</span> <span class="mh">0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a</span>
<span class="n">initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Extract</span><span class="p">(</span><span class="n">initial_salt</span><span class="p">,</span>
                        <span class="n">client_dst_connection_id</span><span class="p">)</span>

<span class="n">client_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
             <span class="s2">"client in"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
<span class="n">server_initial_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">initial_secret</span><span class="p">,</span>
                           <span class="s2">"server in"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span><span class="n">Hash</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the keys used to protect the Initial packets are derived from the destination connection ID, any QUIC implementation, including those used on middleboxes, can decrypt the contents of the Initial packets.</p>
</div>
<p>As mentioned earlier, the client and the server can also use the TLS handshake to agree on specific QUIC parameters. These parameters are called <cite>transport parameters</cite> in QUIC <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. 17 different transport parameters are defined in QUIC version 1 <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> and implementations can define their own transport parameters. We will discuss some of them in different sections of this document. A first example is the <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> parameter that indicates the largest UDP payload that an implementation is willing to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations used in a datacenter supporting jumbo Ethernet frames could agree on a much larger <code class="docutils literal notranslate"><span class="pre">max_udp_payload_size</span></code> without risking packet fragmentation.</p>
<p>Another example of QUIC transport parameters are the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> and the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameters. As explained above, thanks to the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages in the TLS handshake, the client and the servers can verify that their messages have not been tampered. Unfortunately, the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> messages is only computed based on the contents of the TLS messages (i.e. <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>, <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>, <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> and <code class="docutils literal notranslate"><span class="pre">Finished</span></code>). During the handshake, the client and the servers also propose the source and destination connection identifiers that they plan to use to identify the QUIC session. These identifiers are placed in the packet header and not inside the TLS messages. They are thus not covered by the authentication code included in the <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message. To still authenticate these identifiers, QUIC encodes them as transport parameters that are included in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> and the <code class="docutils literal notranslate"><span class="pre">EncryptedExtensions</span></code> messages. The client copies the source connection identifier in the <code class="docutils literal notranslate"><span class="pre">initial_source_connection_id</span></code> transport parameter in its <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>. The server does the same when sending the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code>. It also copies in the <code class="docutils literal notranslate"><span class="pre">original_destination_connection_id</span></code> transport parameter the destination identifier used by the client to send the packet containing the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>.</p>
&#13;

<h3>The QUIC packet headers<a class="headerlink" href="#the-quic-packet-headers" title="Link to this heading">#</a></h3>
<p>At this point, the QUIC session and the TLS security keys are known by the client and the server. They can start to exchange data. Before looking at how data is carried inside QUIC packets, it is interesting to explore in more details the packet headers that are placed inside each packet. QUIC uses variable length packet headers. Two different header formats exist. The first header format is the long header. This is the header used for the first packets of a QUIC connection.</p>
<p>Internet protocol specifications usually contain figures to represent the format of the packet headers. This graphical format is useful to get a quick grasp at a header containing fixed size fields. However, when a header contains several variable length fields, the graphical representation can become difficult to follow. The QUIC specification <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> uses the textual representation that was also used for the TLS protocol. As an example, let us consider the well-known TCP header. This header is graphically represented as shown in <a class="reference internal" href="#fig-quic-tcp-header"><span class="std std-numref">Fig. 90</span></a>.</p>
<div class="figure" id="id23" style="text-align: center">
<span id="fig-quic-tcp-header"/><p><img src="../Images/8bbfb429b7a940504df39c6677c533c7.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-55e7ccada8e8e238f1ed6e92591efe5c866e3b4a.png"/></p>
<p><span class="caption-number">Fig. 90 </span><span class="caption-text">Graphical representation of the TCP header</span></p>
</div><div class="literal-block-wrapper docutils container" id="fig-quic-tcp-text-header">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">Textual representation of the TCP header</span><a class="headerlink" href="#fig-quic-tcp-text-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">TCP Header Packet {</span>
<span class="go">  Source Port (16),</span>
<span class="go">  Destination Port (16),</span>
<span class="go">  Sequence Number (32),</span>
<span class="go">  Acknowledgment Number (32),</span>
<span class="go">  Offset (4),</span>
<span class="go">  Reserved (6),</span>
<span class="go">  Urgent Flag (1),</span>
<span class="go">  ACK Flag (1),</span>
<span class="go">  Push Flag (1),</span>
<span class="go">  RST Flag (1),</span>
<span class="go">  SYN Flag (1),</span>
<span class="go">  FIN Flag(1),</span>
<span class="go">  Window (16),</span>
<span class="go">  TCP Checksum (16),</span>
<span class="go">  Urgent Pointer (16),</span>
<span class="go">  TCP Options (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The attentive reader will easily understand the correspondence between the two formats. When explaining QUIC, we use the textual representation while we stick to the graphical one for TCP.</p>
<p><a class="reference internal" href="#fig-quic-long-header"><span class="std std-numref">Listing 3</span></a> shows the QUIC long header. It starts with one byte containing the header type in the most significant bit, two bits indicating the packet type and four bits that are specific to each packet packet. Then, 32 bits carry the QUIC version number. The current version of QUIC, defined in <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>, corresponds to version <code class="docutils literal notranslate"><span class="pre">0x00000001</span></code>. The header then contains the destination and source connection identifiers that were described previously and then a payload that is specific to each type.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-long-header">
<div class="code-block-caption"><span class="caption-number">Listing 3 </span><span class="caption-text">The QUIC long header</span><a class="headerlink" href="#fig-quic-long-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,                  /* high order bit of the first byte */</span>
<span class="go">  Fixed Bit (1) = 1,                    /* second order bit of the first byte */</span>
<span class="go">  Long Packet Type (2),                 /* third and fourth high order bits of the first byte */</span>
<span class="go">  Type-Specific Bits (4),               /* low order four bits of the first byte */</span>
<span class="go">  Version (32),                         /* 32 bits version number */</span>
<span class="go">  Destination Connection ID Length (8), /* 8 bits */</span>
<span class="go">  Destination Connection ID (0..160),   /* variable number from 0 up to 160 bits */</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Type-Specific Payload (..),           /* variable length */</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Encoding packet numbers</p>
<p>Most transport protocols use fixed fields to encode packet numbers or byte offsets. The size of this field is always a trade-off. On one hand, a small packet number field limits the per packet overhead. On the other hand, a large packet number space is required to ensure that two packets carrying different data do not use the same packet number. TCP uses a 32 bits sequence number field that indicates the position of the first byte of the payload in the bytestream. This 32 bits field became a concern as bandwidth increased to Gbps and beyond <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7323.html"><strong>RFC 7323</strong></a>.</p>
<p>QUIC takes a different approach to sequence numbers. Each packet contains a per-packet sequence number. This number is encoded as a variable-length integer (<code class="docutils literal notranslate"><span class="pre">varint</span></code>). Such a <code class="docutils literal notranslate"><span class="pre">varint</span></code> has a length encoded in the two most significant bits of the first byte. If these bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code>, then the <code class="docutils literal notranslate"><span class="pre">varint</span></code> is encoded in one byte and can contain values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{6}-1\)</span>.  If the two most significant bits are set to <code class="docutils literal notranslate"><span class="pre">01</span></code>, the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{14}-1\)</span> within two bytes. When the two high order bits are set to <code class="docutils literal notranslate"><span class="pre">11</span></code> the <code class="docutils literal notranslate"><span class="pre">varint</span></code> can encode values between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{62}-1\)</span> within four bytes.</p>
<p>There are other important differences between QUIC and other transport protocols when considering packet numbers. First, a QUIC sender must <em>never</em> reuse the same packet number for two different packets sent over a QUIC connection. If data needs to be retransmitted, it will be resent as a frame inside a new packet. Furthermore, since the largest possible packet number is <span class="math notranslate nohighlight">\(2^{62}-1\)</span>, a QUIC sender must close the corresponding connection once it has sent a QUIC packet carrying this packet number. This puts a restriction on the duration of QUIC connections. They cannot last forever in contrast to TCP connections such as those used to support BGP sessions between routers. An application that uses QUIC must be ready to restart a connection from time to time.</p>
</div>
<p>This long header is used for the <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handhsake</span></code> and <code class="docutils literal notranslate"><span class="pre">Retry</span></code> packets. Some of these packet types add new flags in the first byte and additional information after the connection identifiers. <a class="reference internal" href="#fig-quic-initial-header"><span class="std std-numref">Listing 4</span></a> shows the long header of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It contains two bits in the first byte that indicate the length of the packet number field. The packet specific part contains an option token, a length field, a packet number and a payload. The token length, length and packet number are encoded using variable length integers.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-initial-header">
<div class="code-block-caption"><span class="caption-number">Listing 4 </span><span class="caption-text">The QUIC long header of the Initial packet</span><a class="headerlink" href="#fig-quic-initial-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Initial Packet {</span>
<span class="go">  Header Form (1) = 1,                   /* High order bit first byte */</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 0,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),              /* Low order 2 bits of first byte */</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Token Length (i),</span>
<span class="go">  Token (..),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC short header contains fewer fields. The most significant bit of the first byte is set to 1 to indicate that the packet carries a short header. The other flags will be discussed later. The two least significant bits of this byte contain the length of the packet number field. It is interesting to note that in contrast with the long header, there is no explicit indication of the length of the destination connection identifier. This connection identifier has been assigned by the host that receives this packet and it already knows the length of the connection identifiers that it uses.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 5 </span><span class="caption-text">The QUIC short header used by 1-RTT packets</span><a class="headerlink" href="#fig-quic-short-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,                /* High order bit of first byte */</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1),</span>
<span class="go">   Reserved Bits (2),</span>
<span class="go">   Key Phase (1),</span>
<span class="go">   Packet Number Length (2),           /* Low order bits of first byte */</span>
<span class="go">   Destination Connection ID (0..160),</span>
<span class="go">   Packet Number (8..32),</span>
<span class="go">   Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The short header format, depicted in <a class="reference internal" href="#fig-quic-short-header"><span class="std std-numref">Listing 5</span></a>, is used by all QUIC packets once the session keys have been derived. This usually happens after one round-trip-time. These packets are called the 1-RTT packets in the QUIC specification <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. This notation is used to emphasize the fact that QUIC also supports 0-RTT packets, i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Coalescing packets</p>
<p>Besides the connection identifiers, another difference between the short and the long headers is the presence of the <code class="docutils literal notranslate"><span class="pre">Packet</span> <span class="pre">Length</span></code> field in the long header. This field might surprise the reader who is familiar with UDP since UDP also contains a Length field. As each QUIC packet is placed inside a UDP message, the QUIC Length field could seem redundant. This Length field was included in the QUIC long header to allow a QUIC sender to coalesce several consecutive and small packets inside a single UDP message. Some of the frames exchanged during the handshake are rather small. Sending a UDP message for each of these frames would be a waste of resources. Furthermore, a mix of <code class="docutils literal notranslate"><span class="pre">Initial</span></code>, <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> and <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets are exchanged when creating a QUIC connection. It would not be wise to require the utilization of one UDP message to send each of these packets. You might observe this optimization when analyzing packet traces collected on QUIC servers.</p>
</div>
&#13;

<h3>0-RTT data<a class="headerlink" href="#rtt-data" title="Link to this heading">#</a></h3>
<p>Latency is a key concern for transport protocols. The QUIC/TLS handshake that we have described until now allows the client and the server to agree on security keys within one round-trip-time. However, one round-trip-time can be a long delay for some applications. To minimize the impact of the connection setup time, QUIC allows applications to exchange data during the QUIC/TLS handshake. Such data is called 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client and the server must have previously agreed on a key which can be used to encrypt and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared key that the client and the server have shared without using the QUIC protocol or, and this is the most frequent solution, the key that they negotiated during a previous connection. In practice, the server enables 0-RTT by sending a TLS session ticket to the client <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. A session ticket is an encrypted record that contains information that enables the server to recover all the state information about a session including its session keys. It is also linked to the client’s address to enable the server to verify that a given client reuses the tickets that it has received earlier. Usually, these tickets also contain an expiration date. The client places the received ticket in the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">CLient</span> <span class="pre">Hello</span></code> that it sends in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It uses the pre-shared key corresponding to this ticket to encrypt data and place it in one or more <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets. The server uses the information contained in the ticket to recover the key and decrypt the data of the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-0-rtt-packet"><span class="std std-numref">Listing 6</span></a> shows the format of QUIC’s 0-RTT packet.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-0-rtt-packet">
<div class="code-block-caption"><span class="caption-number">Listing 6 </span><span class="caption-text">The QUIC 0-RTT packet</span><a class="headerlink" href="#fig-quic-0-rtt-packet" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">0-RTT Packet {</span>
<span class="go">  Header Form (1) = 1,                  /* High order bit of the first byte */</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type (2) = 1,</span>
<span class="go">  Reserved Bits (2),</span>
<span class="go">  Packet Number Length (2),            /* Low order bits of the first byte */</span>
<span class="go">  Version (32),</span>
<span class="go">  Destination Connection ID Length (8),</span>
<span class="go">  Destination Connection ID (0..160),</span>
<span class="go">  Source Connection ID Length (8),</span>
<span class="go">  Source Connection ID (0..160),</span>
<span class="go">  Length (i),</span>
<span class="go">  Packet Number (8..32),</span>
<span class="go">  Packet Payload (8..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The main benefit of these <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets is that the client can immediately send encrypted data while sending its <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This is illustrated in <a class="reference internal" href="#fig-quic-handshake-ortt"><span class="std std-numref">Fig. 91</span></a> where the frames encrypted with the 0-RTT keys are shown in italics. Note that some of these frames can span several packets. <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets are only sent by the QUIC client since the server can send encrypted data immediately after having sent its <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> frames. As explained earlier, the Initial packets are also encrypted but using keys derived from the connection identifiers.</p>
<div class="figure" id="id24" style="text-align: center">
<span id="fig-quic-handshake-ortt"/><p><img src="../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-8755d75d243150f4626ac19898669b538f7aea0c.png"/></p>
<p><span class="caption-number">Fig. 91 </span><span class="caption-text">Simplified QUIC Handshake with 0-RTT data</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Replay attacks and 0-RTT packets</p>
<p>Thanks to the 0-RTT packets, a client can send encrypted data to the server before waiting for the secure handshake. This reduces the latency of the data transfer, but with one important caveat. QUIC does not provide any guarantee that 0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent operations. A detailed discussion of the impact of replay attacks may be found in <a class="reference internal" href="../bibliography.html#maccarthaigh2017" id="id4"><span>[MacCarthaigh2017]</span></a>.</p>
<p>To understand the importance of these replay attacks, let us consider a simple HTTP GET request. Such a request could easily fit inside the 0-RTT packet and thus have lower latency. If a web browser uses it to request a static <code class="docutils literal notranslate"><span class="pre">index.html</span></code> file, there is no harm if the request is received twice by the server. However, if the GET request is part of a REST API and has side effects, then problems could occur depending on the type of side effect. Consider a REST API that allows a user to switch off the lights using his or her smartphone. Replaying this request two or three times will always result in the light being switched off. However, if the user requests to increase the room temperature by one °C, then multiple replays will obviously have different consequences.</p>
</div>
&#13;

<h2>Closing a QUIC connection<a class="headerlink" href="#closing-a-quic-connection" title="Link to this heading">#</a></h2>
<p>Before exploring how data can be exchanged over a QUIC connection, let us now analyze how a QUIC connection can terminate. QUIC supports three different methods to close a QUIC connection. QUIC’s approach to terminating connection is very different from the approaches used by traditional transport protocol. Before looking at these techniques, it is important to understand how QUIC interacts with Network Address Translation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUIC and Network Address Translation</p>
<p>QUIC runs above UDP and the design of QUIC was heavily influenced by the presence of NATs. NATs, like other middleboxes, maintain per-flow state. For TCP connections, many NATs rely on the <code class="docutils literal notranslate"><span class="pre">SYN</span></code>, <code class="docutils literal notranslate"><span class="pre">FIN</span></code> and <code class="docutils literal notranslate"><span class="pre">RST</span></code> flags to determine when state must be created or removed for a TCP connection. For UDP, this stateful approach is not possible and NATs create a new mapping when they observe the first packet of a flow and remove the mapping once the flow has been idle for sometime. The IETF recommends to maintain NAT mappings during at least two minutes <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4787.html"><strong>RFC 4787</strong></a>, but measurements show that some deployed NATs use shorter timeouts <a class="reference internal" href="../bibliography.html#hnessk2010" id="id5"><span>[HNESSK2010]</span></a> <a class="reference internal" href="../bibliography.html#rwv-2016" id="id6"><span>[RWV+2016]</span></a>. In practice, UDP flows should probably send a packet every 30 seconds to ensure that the on-path NATs preserve their state.</p>
<p>To prevent NATs from changing the mapping associated to the IP addresses and ports used for a QUIC connection, QUIC hosts will need to regularly send data over each established QUIC connection. QUIC defines a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame that allows any QUIC endpoint to send a frame that will trigger a response from the other peer. The <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame does not carry data, but the receiver of a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame needs to acknowledge the packet containing this frame. This creates a bidirectional communication and can prevent NATs from discarding the mapping associated to the QUIC connection.</p>
</div>
<section id="implicit-termination-of-quic-connections">
<h3>Implicit termination of QUIC connections<a class="headerlink" href="#implicit-termination-of-quic-connections" title="Link to this heading">#</a></h3>
<p>Each QUIC implementation keeps in its connection state the timestamp of the last QUIC packet received over this connection. During the connection establishment, the QUIC hosts can also exchange the <code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> parameter that indicates how long (in seconds) a QUIC connection can remain idle before being automatically closed. The first way to close a QUIC connection is to keep it idle for this period of time.</p>
</section>
<section id="explicit-termination-of-a-quic-connection">
<h3>Explicit termination of a QUIC connection<a class="headerlink" href="#explicit-termination-of-a-quic-connection" title="Link to this heading">#</a></h3>
<p>The second technique to terminate a QUIC connection is to use the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. This frame indicates that this connection has been closed abruptly.  The host that receives the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> may respond with one <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. After that, it must stop sending any additional frame. It keeps the connection state for some time, but does not accept any new packet nor retransmit others. The host that sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame indicates that it will neither send nor accept more data. It keeps a subset of the QUIC connection state to be able to retransmit the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame if needed.</p>
<p>A host also sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame to abruptly terminate a connection if it receives an invalid frame or detects a protocol error. In this case, the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame contains a variable length integer that indicates the reason for the termination, the type of the frame that triggered the error and additional information encoded as a text string.</p>
<div class="figure" id="id25" style="text-align: center">
<span id="fig-quic-connection-close"/><p><img src="../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-d2938049bf06c04a3a5990ebbda9f800cc035f2c.png"/></p>
<p><span class="caption-number">Fig. 92 </span><span class="caption-text">A server that refuses a connection</span></p>
</div><p>The QUIC specification also defines a third technique called <cite>stateless reset</cite> to cope with hosts that have lost connection state after a crash or outage. It relies on a 16 bytes stateless token announced together with the connection identifier. See <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> for all the details.</p>
</section>
&#13;

<h3>Implicit termination of QUIC connections<a class="headerlink" href="#implicit-termination-of-quic-connections" title="Link to this heading">#</a></h3>
<p>Each QUIC implementation keeps in its connection state the timestamp of the last QUIC packet received over this connection. During the connection establishment, the QUIC hosts can also exchange the <code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> parameter that indicates how long (in seconds) a QUIC connection can remain idle before being automatically closed. The first way to close a QUIC connection is to keep it idle for this period of time.</p>
&#13;

<h3>Explicit termination of a QUIC connection<a class="headerlink" href="#explicit-termination-of-a-quic-connection" title="Link to this heading">#</a></h3>
<p>The second technique to terminate a QUIC connection is to use the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. This frame indicates that this connection has been closed abruptly.  The host that receives the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> may respond with one <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. After that, it must stop sending any additional frame. It keeps the connection state for some time, but does not accept any new packet nor retransmit others. The host that sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame indicates that it will neither send nor accept more data. It keeps a subset of the QUIC connection state to be able to retransmit the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame if needed.</p>
<p>A host also sends a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame to abruptly terminate a connection if it receives an invalid frame or detects a protocol error. In this case, the <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame contains a variable length integer that indicates the reason for the termination, the type of the frame that triggered the error and additional information encoded as a text string.</p>
<div class="figure" id="id25" style="text-align: center">
<span id="fig-quic-connection-close"/><p><img src="../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-d2938049bf06c04a3a5990ebbda9f800cc035f2c.png"/></p>
<p><span class="caption-number">Fig. 92 </span><span class="caption-text">A server that refuses a connection</span></p>
</div><p>The QUIC specification also defines a third technique called <cite>stateless reset</cite> to cope with hosts that have lost connection state after a crash or outage. It relies on a 16 bytes stateless token announced together with the connection identifier. See <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> for all the details.</p>
&#13;

<h2>Exchanging data over a QUIC connection<a class="headerlink" href="#exchanging-data-over-a-quic-connection" title="Link to this heading">#</a></h2>
<p>The data exchanged over is QUIC connection is organized in different streams. A stream is a sequence of bytes. QUIC supports both unidirectional and bidirectional streams. Both the client and the server can create new streams over a QUIC connection. Each stream is identified by a stream identifier. To prevent problems when the client and the server try to create a stream using the same identifier, QUIC restricts the utilization of the stream identifiers based its two low-order bits. A QUIC client can only create streams whose two low order bits are set to <code class="docutils literal notranslate"><span class="pre">00</span></code> (bidirectional stream) or <code class="docutils literal notranslate"><span class="pre">10</span></code> (unidirectional stream). Similarly, the low order bits of the server-initiated streams must be set to <code class="docutils literal notranslate"><span class="pre">01</span></code> (bidirectional stream) or <code class="docutils literal notranslate"><span class="pre">11</span></code> (unidirectional streams). The QUIC streams are created implicitly by sending data over the stream with the chosen identifier. The stream identifiers start at the minimum value, i.e. <code class="docutils literal notranslate"><span class="pre">0x00</span></code> to <code class="docutils literal notranslate"><span class="pre">0x03</span></code> for the respective types. If a host sends stream data for stream <code class="docutils literal notranslate"><span class="pre">x</span></code> before having sent data over the lower-numbered streams of that type, then those streams are implicitly created. The stream identifier is encoded using a variable length integer. The largest possible stream identifier is thus <span class="math notranslate nohighlight">\(2^{62}-1\)</span>.</p>
<p>QUIC places all data inside <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that are then placed inside QUIC packets. The structure of a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame is shown in <a class="reference internal" href="#fig-quic-stream-frame"><span class="std std-numref">Listing 7</span></a>. This frame contains the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the Type of the Stream frame <a class="footnote-reference brackets" href="#f-stream-type" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></li>
<li><p>the identifier of the stream</p></li>
<li><p>the offset, i.e. the position of the first byte of the Stream data in the bytestream</p></li>
<li><p>the length of the data</p></li>
<li><p>the Stream Data</p></li>
</ul>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="fig-quic-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 7 </span><span class="caption-text">The QUIC STREAM frame</span><a class="headerlink" href="#fig-quic-stream-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x08..0x0f,</span>
<span class="go">   Stream ID (i),</span>
<span class="go">   Offset (i),</span>
<span class="go">   Length (i),</span>
<span class="go">   Stream Data (..),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame carries data, but it can also terminate the corresponding stream. The lowest order bit of the Type field acts as a <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit. When set to zero, it indicates that subsequent data will be sent over this stream. When set to one, it indicates that the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains the last bytes sent over that stream. The stream is closed once the last byte of the stream has been delivered to the user application. Once a QUIC stream has been closed, it cannot be reused again over this connection.</p>
<p>Using this information, the receiver can easily reassemble the data received over the different streams. As an illustration, let us consider a server that has created two streams (stream <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">5</span></code>). The server sends <code class="docutils literal notranslate"><span class="pre">ABCD..</span></code> over stream <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">123</span></code> over stream <code class="docutils literal notranslate"><span class="pre">5</span></code> and closes it after having sent the third digit. The data from these streams could be encoded as shown in <a class="reference internal" href="#fig-quic-streams-example"><span class="std std-numref">Listing 8</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-streams-example">
<div class="code-block-caption"><span class="caption-number">Listing 8 </span><span class="caption-text">Data sent over two different streams</span><a class="headerlink" href="#fig-quic-streams-example" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 0</span>
<span class="go">   Length = 2</span>
<span class="go">   Stream Data = AB</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 5,</span>
<span class="go">   Offset = 0</span>
<span class="go">   Length = 1</span>
<span class="go">   Stream Data = 1</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 2</span>
<span class="go">   Length = 1</span>
<span class="go">   Stream Data = C</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0f,   /* FIN bit is set, end of stream */</span>
<span class="go">   Stream ID = 5,</span>
<span class="go">   Offset = 1</span>
<span class="go">   Length = 2</span>
<span class="go">   Stream Data = 23</span>
<span class="go">}</span>
<span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0x0e,</span>
<span class="go">   Stream ID = 1,</span>
<span class="go">   Offset = 3</span>
<span class="go">   Length = 4</span>
<span class="go">   Stream Data = DEFG</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The penultimate frame shown in <a class="reference internal" href="#fig-quic-streams-example"><span class="std std-numref">Listing 8</span></a> has the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag set. It marks the end of stream <code class="docutils literal notranslate"><span class="pre">1</span></code> that has transported three bytes in total. The <code class="docutils literal notranslate"><span class="pre">FIN</span></code> flag is the normal way to gracefully close a QUIC stream.</p>
<p>There are however cases where an application might need to cancel a stream abruptly without closing the corresponding connection. First, the sending side of a stream can decide to reset the stream. For this, it sends a <code class="docutils literal notranslate"><span class="pre">RESET_STREAM</span></code> frame that carries the identifier of the stream that is canceled. The receiving side of a stream might also need to stop receiving data over a given stream. Consider for example a web browser that has started to download the different images that compose a web while the user has already clicked on another page from the same server. The streams that correspond to these images become useless. In this case, our browser can send a <code class="docutils literal notranslate"><span class="pre">STOP_SENDING</span></code> frame to indicate that it discards the incoming data over the corresponding streams. Upon reception of this frame, the server sends a <code class="docutils literal notranslate"><span class="pre">RESET_STREAM</span></code> frame to indicate that the corresponding stream has been closed.</p>
<section id="flow-control-in-quic">
<h3>Flow control in QUIC<a class="headerlink" href="#flow-control-in-quic" title="Link to this heading">#</a></h3>
<p>Transport protocols usually allocate some resources to each established connection. Each QUIC connection requires memory to store its state, but also buffers to store the packets arrived out-of-order. In practice, the memory available for QUIC implementations is not unlimited and a QUIC receiver must control the amount of packets that the remote host can send at any time. QUIC supports flow control techniques that operate at different levels.</p>
<p>The first level is the connection level.
During the handshake, each host can announce the maximum number of bytes that it agrees to receive initially on the connection using the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter. This parameter contains the number of bytes that the sending host agrees to receive without further notice. If the connection uses more bytes than initially agreed, the receiver can update this limit by sending a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame at any time. This frame contains a variable length integer that encodes the maximum amount of stream data that can be sent over the connection.</p>
<p>The utilization of different streams also consumes resources on a QUIC host. A receiver can also restrict the number of streams that the remote host can create. During the handshake, the <code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> and <code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> transport parameters announce the maximum number of bidirectional and unidirectional streams that the receiving host can accept. This limit can be modified during the connection by sending a <code class="docutils literal notranslate"><span class="pre">MAX_STREAMS</span></code> frame that updates the limit.</p>
<p>Flow control can also take place at the stream level. During the handshake, several transport parameters allow the hosts to advertise the maximum number of bytes that they agree to receive on each stream. Different transport parameters are used to specify the limits that apply to the local/remote and unidirectional/bidirectional streams. These limits can be updated during the connection by sending <code class="docutils literal notranslate"><span class="pre">MAX_STREAM_DATA</span></code> frames. Each of these frames indicates the maximum amount of stream data that can be accepted on a given stream.</p>
<p>These limits restrict the number of streams that a host can create and the amount of bytes that it can send. If a host is blocked by any of these limits, it may sent a control frame to request the remote host to extend the limit. For each type of flow control, there is an associated control frame which can be used to request an extension of the limit.</p>
<p>A host should send a <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame when it reaches the limit on the maximum amount of data set by the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter or a previously received <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame contains the connection limit that caused the transmission to be blocked. In practice, a receiving host should increase the connection-level limit by sending <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frames before reaching the limit. However, since this limit is function of the available memory, a host might not always be able to send a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. <a class="reference internal" href="#fig-quic-example-max-data"><span class="std std-numref">Fig. 93</span></a> provides an example packet flow with the utilization of these frames. We assume that the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter was set to <code class="docutils literal notranslate"><span class="pre">100</span></code> bytes by the client during the handshake and the the server needs to send 900 bytes. The server creates a stream and sends 100 bytes in a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet carrying a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. At this point, the server is blocked.</p>
<div class="figure" id="id26" style="text-align: center">
<span id="fig-quic-example-max-data"/><p><img src="../Images/5b5d3482cca71cc31e8478d8c94c256b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c022aa52c8641e07e76b1f1051d14b43b01af635.png"/></p>
<p><span class="caption-number">Fig. 93 </span><span class="caption-text">QUIC uses <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frames when a connection’s flow control is blocked</span></p>
</div><p>The same applies with the <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frame that is sent when a host reaching the per-stream limit. The <code class="docutils literal notranslate"><span class="pre">STREAMS_BLOCKED</span></code> frame is used when a host has reached the maximum number of established streams.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Connections blocked by flow control are not totally idle</p>
<p>If a QUIC host detects that a connection is blocked by flow control, it should regularly send <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> or <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frames to request the remote host to extend the current limit. The QUIC specification <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> does not recommend precisely how often these frames should be sent when a connection is blocked by flow control. Experience with QUIC deployments will enable the QUIC developers to more precisely define how often these frames should be sent.</p>
<p>A measurement study <a class="reference internal" href="../bibliography.html#mhlq2020" id="id8"><span>[MHLQ2020]</span></a> revealed that QUIC implementations used different strategies for flow control. They identified three main types of behaviors :</p>
<blockquote>
<div><ul class="simple">
<li><p>Static Flow Control: the receive buffer size stays unchanged and the receiver simply increases the maximum allowance linearly</p></li>
<li><p>Growing Flow Control: the size of the receive buffer increases over time as the connection progresses</p></li>
<li><p>Auto-tuning: the size of the receive buffer is adjusted dynamically based on the estimated bandwidth and round-trip times</p></li>
</ul>
</div></blockquote>
<p>In 2020, three quarter of the studied implementations used a Static Flow Control and only one used auto-tuning. Static Flow Control can work, but this is a waste of memory. For example, Google’s Chrome starts with a 15 MBytes receive buffer and updates it linearly <a class="reference internal" href="../bibliography.html#mhlq2020" id="id9"><span>[MHLQ2020]</span></a>. This should be contrasted with TCP implementations that usually start with a window of a few tens of KBytes and adjust it with auto-tuning. Auto-tuning is a key feature of modern TCP implementations <a class="reference internal" href="../bibliography.html#smm1998" id="id10"><span>[SMM1998]</span></a>. It is expected that QUIC implementations will include more advanced heuristics to tune their flow control mechanism.</p>
</div>
</section>
<section id="quic-loss-detection">
<h3>QUIC Loss Detection<a class="headerlink" href="#quic-loss-detection" title="Link to this heading">#</a></h3>
<p>As other transport protocols, QUIC includes mechanisms to detect transmission errors and packet losses. The transmission errors are usually detected by using the UDP checksum or at the datalink layer with the Wi-Fi or Ethernet CRCs. When a transmission error occurs, the corresponding packet is discarded and QUIC considers this error as a packet loss. Researchers have analyzed the performance of checksums and CRCs on real data <a class="reference internal" href="../bibliography.html#sgp98" id="id11"><span>[SGP98]</span></a>.</p>
<p>Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated and a receiver can leverage this AEAD to detect transmission errors that were undetected by the UDP checksum of the CRC of the lower layers. However, these undetected transmission errors are assumed to be rare and if QUIC a detects an invalid AEAD, it will consider that this error was caused by an attack and will stop the connection using a TLS alert <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>.</p>
<p>There are several important differences between the loss detection and retransmission mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers always increase monotonically over a QUIC connection. A QUIC sender never sends twice a packet with the same packet number over a given connection. QUIC encodes the packet numbers as variable length integers and it does not support wrap around in contrast with other transport protocols. The QUIC frames contain the valuable information that needs to be delivered reliably. If a QUIC packet is lost, the frames that it contained will be retransmitted in another QUIC packet that uses a different packet number. Thus, the QUIC packet number serves as a unique identifier of a packet. This simplifies some operations such as measuring the round-trip-time which is more difficult in protocols such as TCP when packets are transmitted <a class="reference internal" href="../bibliography.html#kp91" id="id12"><span>[KP91]</span></a>.</p>
<p>Second, QUIC’s acknowledgments carry more information than the cumulative or selective acknowledgments used by TCP and related protocols. This enables the receiver to provide a more detailed view of the packets that it received. In contrast with TCP <span class="target" id="index-19"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2018.html"><strong>RFC 2018</strong></a>, once a receiver has reported that one packet was correctly received in an acknowledgment, the sender of that packet can discard the corresponding frames.</p>
<p>Third, a QUIC sender autonomously decides which frames it sends inside each packet. A QUIC packet may contain both data and control frames, or only data or only control information. If a QUIC packet is lost, the frames that it contained could be retransmitted in different packets. A QUIC implementation thus needs to buffer the frames and mark the in-flight ones to be able to retransmit them if the corresponding packet was lost.</p>
<p>Fourth, most QUIC packets are explicitly acknowledged. The only exception are the packets that only contain <code class="docutils literal notranslate"><span class="pre">ACK</span></code>, <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> or <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frames. A packet that contains any other QUIC frame is called an ack-eliciting packet because its delivery will be confirmed by the transmission of an acknowledgment. A QUIC packet that carries both an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame will thus be acknowledged.</p>
<p>With this in mind, it is interesting to look at the format of the QUIC acknowledgments and then analyze how they can be used. <a class="reference internal" href="#fig-quic-ack-frame"><span class="std std-numref">Listing 9</span></a> provides the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types are used to distinguish between the acknowledgments that contain information about the received ECN flags (type <code class="docutils literal notranslate"><span class="pre">0x03</span></code>) or only regular acknowledgments (type <code class="docutils literal notranslate"><span class="pre">0x02</span></code>). The first information contained in the ACK frame is the largest packet number that is acknowledged by this ACK frame. This is usually the highest packet number received. The second information is the ACK delay. This is the delay in microseconds between the reception of the packet having the largest acknowledged number by the receiver and the transmission of the acknowledgment. This information is important to ensure that round-trip-times are accurately measured, even if a receiver delays acknowledgments. This is illustrated in <a class="reference internal" href="#fig-quic-ack-delay"><span class="std std-numref">Fig. 94</span></a>. The <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span> <span class="pre">Count</span></code> field contains the number of <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">ranges</span></code> that are included in the QUIC ACK frame. This number can be set to zero if all packets were received in sequence without any gap. In this case, the <code class="docutils literal notranslate"><span class="pre">First</span> <span class="pre">ACK</span> <span class="pre">Range</span></code> field contains the number of the packet that arrived before the <code class="docutils literal notranslate"><span class="pre">Largest</span> <span class="pre">Acknowledged</span></code> packet number.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 9 </span><span class="caption-text">The QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-ack-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02..0x03,</span>
<span class="go">   Largest Acknowledged (i),</span>
<span class="go">   ACK Delay (i),</span>
<span class="go">   ACK Range Count (i),</span>
<span class="go">   First ACK Range (i),</span>
<span class="go">   ACK Range (..) ...,</span>
<span class="go">   [ECN Counts (..)],</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="figure" id="id27" style="text-align: center">
<span id="fig-quic-ack-delay"/><p><img src="../Images/91a1bf7fc5600dfd204d9c3691a03f74.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-5980706b89e969a89f2ce0e7ef4f744e4a9b8928.png"/></p>
<p><span class="caption-number">Fig. 94 </span><span class="caption-text">Utilization of the QUIC ACK delay</span></p>
</div><p>An <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame contains 0 or more <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Ranges</span></code>. The format of an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">range</span></code> is shown in <a class="reference internal" href="#fig-quic-ack-range"><span class="std std-numref">Listing 10</span></a>. Each range indicates first the number of unacknowledged packets since the smallest acknowledged packet in the preceding range (or the first ACK range). The next field indicates the number of consecutive acknowledged packets.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-range">
<div class="code-block-caption"><span class="caption-number">Listing 10 </span><span class="caption-text">A QUIC ACK range</span><a class="headerlink" href="#fig-quic-ack-range" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Range {</span>
<span class="go">   Gap (i),</span>
<span class="go">   ACK Range Length (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>As an example, consider a host that received the following QUIC packets: <code class="docutils literal notranslate"><span class="pre">3,4,6,7,8,9,11,14,16,18</span></code>. To report all the received packets, it will generate the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame shown in <a class="reference internal" href="#fig-quic-sample-ack-frame"><span class="std std-numref">Listing 11</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-sample-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 11 </span><span class="caption-text">Sample QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-sample-ack-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged=18,</span>
<span class="go">   ACK Delay=x,</span>
<span class="go">   ACK Range Count=5,</span>
<span class="go">   First ACK Range=0,</span>
<span class="go">   ACK Range #0 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #1 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #2 [Gap=3, ACK Range Length=1],</span>
<span class="go">   ACK Range #3 [Gap=2, ACK Range Length=4],</span>
<span class="go">   ACK Range #4 [Gap=2, ACK Range Length=2]</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC specification recommends to send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame after having received two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments strategy. However, there is ongoing work to allow the sender to provide more guidelines on when and how <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames should be sent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When should QUIC hosts send acknowledgments</p>
<p>A measurement study <a class="reference internal" href="../bibliography.html#mhlq2020" id="id13"><span>[MHLQ2020]</span></a> analyzed how QUIC implementations generate acknowledgments. Two of the studied implementations sent acknowledgments every N packets (2 for one implementation and 10 for the other). Other  implementations used ack frequencies that varied during the data transfer.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id28">
<img alt="../_images/quic-1.png" class="plot-directive" src="../Images/3a962b543fdebe8ff46dbfacfe31e189.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 95 </span><span class="caption-text">Acknowledgment frequencies for different QUIC servers</span><a class="headerlink" href="#id28" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The acknowledgment frequencies should be compared with TCP that usually acknowledges every second packet. It is likely that QUIC implementations will tune the generation of their acknowledgments in the coming years based on feedback from deployment.</p>
</div>
<p>It is interesting to observe that since the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are sent inside QUIC packets, they can also be acknowledged. Sending an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> in response to another <code class="docutils literal notranslate"><span class="pre">ACK</span></code> could result in an infinite exchange of <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. To prevent this problem, a QUIC sender cannot send an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame in response to a non-eliciting QUIC packet and the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are one of the non-eliciting frame types. Note that if a receiver that receives many <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames and thus sends many <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames wants to obtain information about the reception of its <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, it can simply send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame inside a packet that contains an eliciting frame, e.g. a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. This frame will trigger the receiver to acknowledge it and the previously sent <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames.</p>
<p>In contrast with other reliable transport protocols, QUIC does not use cumulative acknowledgments. As explained earlier, QUIC never retransmits a packet with the same packet number. When a packet is lost, this creates a gap that the receiver reports using an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code>. Such a gap will never be filled by retransmissions and obviously should not be reported by the receiver forever. In practice, a receiver will send the acknowledgment that corresponds to a given packet number several times and then will assume that the acknowledgment has been received. A receiver can also rely on other heuristics to determine that a given <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code> should not be reported anymore. This is the case if the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame was included in a packet that has been acknowledged by the other peer, but also when the gap was noticed several round-trip times ago.</p>
<p>QUIC also allows a receiver to send information about the ECN flags in the received packets. Two flags of the IP header <span class="target" id="index-20"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3168.html"><strong>RFC 3168</strong></a> are reserved to indicate support for Explicit Congestion Notification. The QUIC ECN count field shown in <a class="reference internal" href="#fig-quic-ecn-count"><span class="std std-numref">Listing 12</span></a> contains three counters for the different values of the ECN flags. These counters are incremented upon the reception of each QUIC packet based on the values of the ECN flag of the received packet. Unfortunately, there are still many operational  problems when using ECN in the global Internet <a class="reference internal" href="../bibliography.html#mlbba2018" id="id14"><span>[MLBBA2018]</span></a>. Time will tell whether it is easier to deploy ECN with QUIC than with TCP.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ecn-count">
<div class="code-block-caption"><span class="caption-number">Listing 12 </span><span class="caption-text">A QUIC ECN Count</span><a class="headerlink" href="#fig-quic-ecn-count" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ECN Counts {</span>
<span class="go">   ECT0 Count (i),</span>
<span class="go">   ECT1 Count (i),</span>
<span class="go">   ECN-CE Count (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUIC also acknowledges control frames</p>
<p>Besides the STREAM frames that carry user data, QUIC uses several different frame types to exchange control information. These control frames, like the data frames, are ack-eliciting frames. This implies a host that receives such a frame needs to acknowledge it using an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame.</p>
<p><a class="reference internal" href="#fig-quic-ack-initials"><span class="std std-numref">Fig. 97</span></a> illustrates the beginning of a QUIC connection with the exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets and the corresponding acknowledgments. The client sends its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> inside a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame in an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This is the first packet sent by the client and thus its packet number is 0. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> inside a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame in an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. Since this is the first packet sent by the server, its packet number is also 0. The packet also contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the reception of the packet containing the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Handshake</span></code>, <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> and <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are acknowledged similarly using <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets are acknowledged in other <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets while <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> and <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are acknowledged inside <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets.</p>
</div>
<div class="figure" id="id30" style="text-align: center">
<span id="fig-quic-ack-initials"/><p><img src="../Images/75ed846fe9a217630046fd48dc876f1b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-626d297d8c568bae6dcfb3764695c72d549a86cc.png"/></p>
<p><span class="caption-number">Fig. 97 </span><span class="caption-text">QUIC also acknowledges Initial frames</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all QUIC servers use 0 as the packet number of their first Initial packet</p>
<p>The example shows a QUIC connection where the client sent its Initial packet with packet number 0 and the server also replied with a packet number set to 0. This is what most QUIC implementations do. However, the QUIC specification does not strictly requires this. In fact, <code class="docutils literal notranslate"><span class="pre">facebook</span></code> servers in October 2022 appear to use random packet numbers for the Initial packet that they sent in response to a client. This is probably use to detect or mitigate some forms of attacks since the client must receive the server’s Initial packet to be able to produce a valid acknowledgment.</p>
</div>
<p>To illustrate how QUIC uses acknowledgments, let us consider a simple QUIC connection. The client starts a QUIC connection with a new server, sends a request, receives a response and then closes the connection. There are no losses in this connection. <a class="reference internal" href="#fig-quic-ack-short"><span class="std std-numref">Fig. 98</span></a> illustrates this connection.</p>
<div class="figure" id="id31" style="text-align: center">
<span id="fig-quic-ack-short"/><p><img src="../Images/00d236df000f95dc0877d8231f52d999.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-1fc45a23ddaacb37c26a462d2202c00cd14b01c7.png"/></p>
<p><span class="caption-number">Fig. 98 </span><span class="caption-text">Acknowledgments in a short QUIC connection</span></p>
</div><p>The connection starts when the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code>. The server replies with an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet that contains an acknowledgment and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. The server then sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code>. Since this is the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet, its packet number is set to 0. In practice, it is likely that the server will need to send several packets to carry the certificates contained in this packet. Note that the server cannot send more than 3 packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This limit was introduced in the QUIC specification to restrict the ability of attackers to trigger DDoS attacks by sending spoofed packets to QUIC servers <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. If the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame containing the certificates is too long, the server might need to wait for acknowledgments from the client before sending its last <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The client confirms the reception of the server’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet by sending its last <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet that contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. This is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client and its packet number is thus 1. Since this packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, the server does not return an acknowledgment to confirm its reception.</p>
<p>The client replies to the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet with another <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame and acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server. The client’s <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet is acknowledged by the server. The server starts the data exchange by sending a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet carrying one or more stream frames to create the required streams. Since this is the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server, its packet number is set to 0. The client then sends its request in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. The server replies with a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame with its response. The client ends the connection by sending a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. In the example, the server replies with a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame, but the QUIC specification <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> only indicates that a host may respond with a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> in this case.</p>
</section>
<section id="observing-quic-connections">
<h3>Observing QUIC connections<a class="headerlink" href="#observing-quic-connections" title="Link to this heading">#</a></h3>
<p>We have now reviewed the main components of the QUIC specification. To illustrate it, let us consider a simple scenario where a client opens a QUIC connection with a server. We leverage Maxime Piraux’s QUIC tracker <a class="reference internal" href="../bibliography.html#pdb2018" id="id15"><span>[PDB2018]</span></a>. In this example, we use the packet trace collected using the <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> server on November 22, 2021 at 18:04:52 CET. This trace is available from <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/148">https://quic-tracker.info.ucl.ac.be/traces/20211122/148</a>. You can see the contents of the packets, download it as a <code class="docutils literal notranslate"><span class="pre">.pcap</span></code> trace or visualize it using QLog/QViz <a class="reference internal" href="../bibliography.html#mpql2020" id="id16"><span>[MPQL2020]</span></a> from this web site.</p>
<p>This trace contains 16 packets. The scenario is a simple handshake with an exchange of data.</p>
<figure class="align-default" id="id32">
<img alt="../_images/qtracker-nghttp2-1.png" src="../Images/7e3eb62de8971ff53e65f8fbea028144.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-nghttp2-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 99 </span><span class="caption-text">Sample QUIC tracker trace with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> containing a successful handshake</span><a class="headerlink" href="#id32" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>To initiate the connection, the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> QUIC packet.  It is interesting to analyze the content of this packet. It starts with a long QUIC header shown in <a class="reference internal" href="#fig-trace-quic-header-p1"><span class="std std-numref">Listing 13</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p1">
<div class="code-block-caption"><span class="caption-number">Listing 13 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p1" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 00,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0x6114ca6ecbe483bb,</span>
<span class="go">  Source Connection ID Length (8) = 8,</span>
<span class="go">  Source Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 1226,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (8..) = CRYPTO,</span>
<span class="go">  Type-Specific Payload (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The client proposes a 64 bits connection identifier and uses a random 64 bits identifier for the destination connection identifier. There is no token in this packet since this is the first connection from this client to the server. It is useful to note that the packet number of this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet is set to zero. All QUIC connections start with a packet whose packet number is set to zero in contrast with TCP that uses a random sequence number. The packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame shown in <a class="reference internal" href="#fig-trace-quic-crypto-p1"><span class="std std-numref">Listing 14</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-crypto-p1">
<div class="code-block-caption"><span class="caption-number">Listing 14 </span><span class="caption-text">The CRYPTO frame of the first QUIC packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-crypto-p1" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">CRYPTO Frame {</span>
<span class="go">   Type (i) = 0x06,</span>
<span class="go">   Offset (i) = 0,</span>
<span class="go">   Length (i) = 245,</span>
<span class="go">   Crypto Data = ClientHello</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame starts at offset 0 and has a length of <code class="docutils literal notranslate"><span class="pre">245</span></code> bytes. It contains a TLS 1.3 <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message whose format is specified in <span class="target" id="index-23"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. This <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> includes a 32 bytes secure random number, a set of proposed cipher suites and a series of TLS extensions. One of these extensions carries the QUIC transport parameters proposed by the client. On this connection, the QUIC tracker client proposed the following ones:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_bidi_local</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_uni</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> = 0x80008000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> = 0x1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> = 0x3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> = 0x6710</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">active_connection_id_limit</span></code> = 0x4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_packet_size</span></code> = 0x45c0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inital_source_connection_id</span></code> = 0xc9f54d3c298296b9</p></li>
</ul>
</div></blockquote>
<p>Finally, the first QUIC packet contains a <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> frame with 960 dummy bytes. The entire packet is 1236 bytes long.</p>
<p>The server responds to this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet with two packets. The first one is an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It starts with the header shown in <a class="reference internal" href="#fig-trace-quic-header-p2"><span class="std std-numref">Listing 15</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p2">
<div class="code-block-caption"><span class="caption-number">Listing 15 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 10,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Source Connection ID Length (8) = 18,</span>
<span class="go">  Source Connection ID (0..160) = 0x8d3470255ae3b0b3fad3c40515132a813dfa,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 149,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (...)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This server uses 18 bytes to encode its connection identifier and proposes the first identifier in the long header. The packet payload contains two frames: an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame (<a class="reference internal" href="#fig-trace-quic-ack-p2"><span class="std std-numref">Listing 16</span></a>) acknowledges the reception of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the TLS ServerHello.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-ack-p2">
<div class="code-block-caption"><span class="caption-number">Listing 16 </span><span class="caption-text">The ACK Frame of the first packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-ack-p2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged = 0,</span>
<span class="go">   ACK Delay = 0,</span>
<span class="go">   ACK Range Count = 0,</span>
<span class="go">   First ACK Range = 0</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The payload of these <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets is encrypted using the static key derived from the connection identifiers included in the long header.</p>
<p>The server then sends three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets carrying a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code>. These extensions are encrypted using the TLS key. They mainly contain the server certificate. It is interesting to note that the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> field of the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the server is also set to zero. This is the second, but not the last, packet that we observe with this <code class="docutils literal notranslate"><span class="pre">packet_number</span></code>. QUIC handles packet numbers differently then other protocols. QUIC considers that a QUIC connection is divided in three phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets</p></li>
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets</p></li>
<li><p>The exchange of the other packets (<code class="docutils literal notranslate"><span class="pre">0-RTT</span></code>, <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code>, … packets)</p></li>
</ol>
</div></blockquote>
<p>A QUIC host restarts the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> at zero in each phase. This explains why it is possible to observe different packets (of different types) with the same <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> over a QUIC connection.</p>
<p>The three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server contain the beginning of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> sent by the server. To prevent denial of service attacks, the server cannot send more than three full-length packets in response to a packet sent by the client. The server thus needs to wait for an acknowledgment from the client before sending additional packets.</p>
<p>The client sends two packets to carry these acknowledgments. First, it sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet as the sixth packet of the trace. This packet belongs to the packet numbering space of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets. Its packet number is 1 since this is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The next acknowledgment is carried inside an <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet. It acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets 0-2 sent by the server. Since this is the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the client, its packet number is also 0.</p>
<p>The server then sends the eighth packet that contains the last part of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. By combining the information contained in the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets and the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets, the client can derive the session keys.</p>
<p>The server immediately sends its first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. This packet contains a short header shown in <a class="reference internal" href="#fig-trace-quic-short-header"><span class="std std-numref">Listing 17</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 17 </span><span class="caption-text">The QUIC short header of the first 1-RTT packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-short-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1) = 0,</span>
<span class="go">   Reserved Bits (2)= 00,</span>
<span class="go">   Key Phase (1) = 0,</span>
<span class="go">   Packet Number Length (2)= 0,</span>
<span class="go">   Destination Connection ID = 0xc9f54d3c298296b9,</span>
<span class="go">   Packet Number = 0,</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This short header contains the connection identifier proposed by the client in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. The payload contains <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that create three streams. The client replies with two packets. The tenth packet of the trace is a <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that carries two frames. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Finished</span></code> message that finalizes the TLS handshake. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame acknowledges the four <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server.</p>
<p>The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the client contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server and flow control information. The client sends a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame to restrict the amount of data that the server can send and one <code class="docutils literal notranslate"><span class="pre">MAX_STREAM</span></code> frame for each of the three streams created by the server.</p>
<p>The twelfth packet of the trace is more interesting. It contains five different frames that are sent by the server. First, the server send two <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames that advertise two 18 bytes long connection identifiers which can be used by the client to migrate the connection later. The next frame is the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame that confirms the TLS handshake. The server also sends a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame that contains a 57 bytes long token that the client will be able to use in subsequent connections with the server. The last frame is a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Tickets</span></code>.</p>
<section id="a-closer-look-at-other-quic-handshakes">
<h4>A closer look at other QUIC handshakes<a class="headerlink" href="#a-closer-look-at-other-quic-handshakes" title="Link to this heading">#</a></h4>
<p>It is interesting to analyze how different servers perform the handshake using QUIC tracker. Let us first explore the <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/140">trace collected with cloudflare-quic.com</a> on the same day shown in <a class="reference internal" href="#fig-qtracker-cloudflare"><span class="std std-numref">Fig. 100</span></a>. There are several differences with the nghttp2 trace that we analyzed above. First, the server sends two small packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code>. The first packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. It advertises a 20 bytes long connection identifier. The second packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Hello</span> <span class="pre">Retry</span> <span class="pre">Request</span></code>. This message indicates that the server did not agree with the <code class="docutils literal notranslate"><span class="pre">key_share</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> sent in the first packet. The client acknowledges this packet and sends a new <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> in the fourth packet. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> and then the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in three QUIC packets. The certificate used by <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> is more compact than the one used by <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>.</p>
<figure class="align-default" id="id33">
<span id="fig-qtracker-cloudflare"/><img alt="../_images/qtracker-cloudflare-1.png" src="../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-cloudflare-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 100 </span><span class="caption-text">Sample quic tracker trace from cloudflare-quic.com with a successful handshake</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are also slightly different. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server contains the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame, a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code> messages and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates one stream. The server then sends two short packet. Each of these packets contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates a new stream. These two short packets could have been packed in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server. In contrast with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>, <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> does advertise new connection identifiers.</p>
<p>Our third example is <a class="reference external" href="https://github.com/private-octopus/picoquic">picoquic</a>. The <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/159">QUIC tracker trace with test.privateoctopus.com</a> contains 13 packets.</p>
<figure class="align-default" id="id34">
<span id="fig-qtrack-picoquic-1"/><img alt="../_images/qtracker-picoquic-1.png" src="../Images/2caed6d4f9f898a962846ed3d2e47a9b.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 101 </span><span class="caption-text">Sample QUIC tracker trace from <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with a successful handshake</span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>picoquic uses 64 bits long connection identifiers. It manages to fit its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> within two <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that it sends contains a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. The second <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet contains one <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that advertises one <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code>, three <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames and a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame. This test server does not try to create new streams in contrast with the two others.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Comparing QUIC servers</p>
<p>It is interesting to use the traces collected by QUIC tracker to analyze how different servers have selected some of the optional features of QUIC. A first difference between the servers is the length of the server-selected connection identifiers. The graph below shows that in November 2021 many servers advertised 8 bytes CIDs, but some have opted for much longer CIDs.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id35">
<img alt="../_images/quic-2.png" class="plot-directive" src="../Images/8fa0ce7b276beb5ece519f6198e8c9be.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-2.png"/>
<figcaption>
<p><span class="caption-number">Fig. 102 </span><span class="caption-text">Length of the connection identifiers advertised by different QUIC servers (Nov 2021)</span><a class="headerlink" href="#id35" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
</section>
<section id="observing-0-rtt-data-in-quic">
<h4>Observing 0-RTT data in QUIC<a class="headerlink" href="#observing-0-rtt-data-in-quic" title="Link to this heading">#</a></h4>
<p>The ability to send data immediately was one of the requirements for the design of QUIC. It is interesting to observe how QUIC uses the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets for this purpose. We use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/619">trace collected between QUIC tracker and picoquic as our example</a>. This trace covers two QUIC connections shown in <a class="reference internal" href="#fig-qtrack-picoquic-0rtt"><span class="std std-numref">Fig. 104</span></a>.</p>
<figure class="align-default" id="fig-qtrack-picoquic-0rtt">
<img alt="../_images/qtracker-picoquic-0rtt.png" src="../Images/805be77f81fd67d0f4dbcd3429f9074d.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-0rtt.png"/>
<figcaption>
<p><span class="caption-number">Fig. 104 </span><span class="caption-text">Sample QUIC trace with <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with 0-RTT packets</span><a class="headerlink" href="#fig-qtrack-picoquic-0rtt" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>During the first QUIC connection, QUIC tracker receives one TLS session ticket in the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contained in the 1-RTT packet that the server sent with packet number set to 0. This ticket contains all the information required by the server to retrieve the key in a subsequent connection. QUIC tracker starts the second connection by sending an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> message. A comparison between this <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the one sent to create the first connection shows that the latter contains the <code class="docutils literal notranslate"><span class="pre">psk_key_exchange_modes</span></code> TLS extension. This extension contains the information that enables the server to recover the key required to decrypt the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. In this example, the client sends a <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> that contains the beginning of a simple <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code>.</p>
</section>
<section id="quic-streams">
<h4>QUIC streams<a class="headerlink" href="#quic-streams" title="Link to this heading">#</a></h4>
<p>As QUIC support multiple streams, it is interesting to analyze how the streams are managed over a real QUIC connection. For this example, we use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/375">trace between QUIC tracker and quic.tech</a> summarized in <a class="reference internal" href="#fig-qtrack-quictech"><span class="std std-numref">Fig. 105</span></a>. In the example, the QUIC tracker creates four streams and sends one <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code> request over each of them.</p>
<figure class="align-default" id="fig-qtrack-quictech">
<img alt="../_images/qtracker-quictech-1.png" src="../Images/0b2f8631f4b24e652268e6a998c32faa.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-quictech-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 105 </span><span class="caption-text">Sample QUIC trace with quic.tech using multiple streams</span><a class="headerlink" href="#fig-qtrack-quictech" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this trace, the client creates four streams in its first <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame sent in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-trace-stream-frame"><span class="std std-numref">Listing 18</span></a> shows the first of these <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames. The <code class="docutils literal notranslate"><span class="pre">Type</span></code> of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> is one octet structured as <code class="docutils literal notranslate"><span class="pre">0b00001OLF</span></code> where <code class="docutils literal notranslate"><span class="pre">O</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains an <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field. Bit <code class="docutils literal notranslate"><span class="pre">L</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the frame contains a <code class="docutils literal notranslate"><span class="pre">Length</span></code> field. Finally, the <code class="docutils literal notranslate"><span class="pre">F</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> to mark the end of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code>. In this test, QUIC Tracker sends 17 bytes over each stream and closes it.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 18 </span><span class="caption-text">The first QUIC STREAM frame sent by QUIC Tracker</span><a class="headerlink" href="#fig-quic-trace-stream-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001011,  # Offset=0, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Length = 17,</span>
<span class="go">   Stream Data = GET /index.html\r\n</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The server sends each response in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. <a class="reference internal" href="#fig-quic-trace-stream-frame-2"><span class="std std-numref">Listing 19</span></a> shows the frame returned by the server. Its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> bit is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. It carries the entire HTML page and its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field could have been ignored since this is the first frame of the stream.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame-2">
<div class="code-block-caption"><span class="caption-number">Listing 19 </span><span class="caption-text">The QUIC STREAM frame returned by the server</span><a class="headerlink" href="#fig-quic-trace-stream-frame-2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001111,  # Offset=1, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Offset = 0,</span>
<span class="go">   Length = 462,</span>
<span class="go">   Stream Data = &lt;!DOCTYPE html&gt;...</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f-stream-type" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>All <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames have a type that starts with <code class="docutils literal notranslate"><span class="pre">0b0001...</span></code>. The three low order bits of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame indicate the presence of the <code class="docutils literal notranslate"><span class="pre">Offset</span></code> and <code class="docutils literal notranslate"><span class="pre">Length</span></code> fields. The lowest order bit is the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit.</p>
</aside>
</aside>
</section>
</section>
&#13;

<h3>Flow control in QUIC<a class="headerlink" href="#flow-control-in-quic" title="Link to this heading">#</a></h3>
<p>Transport protocols usually allocate some resources to each established connection. Each QUIC connection requires memory to store its state, but also buffers to store the packets arrived out-of-order. In practice, the memory available for QUIC implementations is not unlimited and a QUIC receiver must control the amount of packets that the remote host can send at any time. QUIC supports flow control techniques that operate at different levels.</p>
<p>The first level is the connection level.
During the handshake, each host can announce the maximum number of bytes that it agrees to receive initially on the connection using the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter. This parameter contains the number of bytes that the sending host agrees to receive without further notice. If the connection uses more bytes than initially agreed, the receiver can update this limit by sending a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame at any time. This frame contains a variable length integer that encodes the maximum amount of stream data that can be sent over the connection.</p>
<p>The utilization of different streams also consumes resources on a QUIC host. A receiver can also restrict the number of streams that the remote host can create. During the handshake, the <code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> and <code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> transport parameters announce the maximum number of bidirectional and unidirectional streams that the receiving host can accept. This limit can be modified during the connection by sending a <code class="docutils literal notranslate"><span class="pre">MAX_STREAMS</span></code> frame that updates the limit.</p>
<p>Flow control can also take place at the stream level. During the handshake, several transport parameters allow the hosts to advertise the maximum number of bytes that they agree to receive on each stream. Different transport parameters are used to specify the limits that apply to the local/remote and unidirectional/bidirectional streams. These limits can be updated during the connection by sending <code class="docutils literal notranslate"><span class="pre">MAX_STREAM_DATA</span></code> frames. Each of these frames indicates the maximum amount of stream data that can be accepted on a given stream.</p>
<p>These limits restrict the number of streams that a host can create and the amount of bytes that it can send. If a host is blocked by any of these limits, it may sent a control frame to request the remote host to extend the limit. For each type of flow control, there is an associated control frame which can be used to request an extension of the limit.</p>
<p>A host should send a <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame when it reaches the limit on the maximum amount of data set by the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter or a previously received <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frame contains the connection limit that caused the transmission to be blocked. In practice, a receiving host should increase the connection-level limit by sending <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frames before reaching the limit. However, since this limit is function of the available memory, a host might not always be able to send a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame. <a class="reference internal" href="#fig-quic-example-max-data"><span class="std std-numref">Fig. 93</span></a> provides an example packet flow with the utilization of these frames. We assume that the <code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> transport parameter was set to <code class="docutils literal notranslate"><span class="pre">100</span></code> bytes by the client during the handshake and the the server needs to send 900 bytes. The server creates a stream and sends 100 bytes in a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet carrying a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. At this point, the server is blocked.</p>
<div class="figure" id="id26" style="text-align: center">
<span id="fig-quic-example-max-data"/><p><img src="../Images/5b5d3482cca71cc31e8478d8c94c256b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c022aa52c8641e07e76b1f1051d14b43b01af635.png"/></p>
<p><span class="caption-number">Fig. 93 </span><span class="caption-text">QUIC uses <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> frames when a connection’s flow control is blocked</span></p>
</div><p>The same applies with the <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frame that is sent when a host reaching the per-stream limit. The <code class="docutils literal notranslate"><span class="pre">STREAMS_BLOCKED</span></code> frame is used when a host has reached the maximum number of established streams.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Connections blocked by flow control are not totally idle</p>
<p>If a QUIC host detects that a connection is blocked by flow control, it should regularly send <code class="docutils literal notranslate"><span class="pre">DATA_BLOCKED</span></code> or <code class="docutils literal notranslate"><span class="pre">STREAM_DATA_BLOCKED</span></code> frames to request the remote host to extend the current limit. The QUIC specification <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> does not recommend precisely how often these frames should be sent when a connection is blocked by flow control. Experience with QUIC deployments will enable the QUIC developers to more precisely define how often these frames should be sent.</p>
<p>A measurement study <a class="reference internal" href="../bibliography.html#mhlq2020" id="id8"><span>[MHLQ2020]</span></a> revealed that QUIC implementations used different strategies for flow control. They identified three main types of behaviors :</p>
<blockquote>
<div><ul class="simple">
<li><p>Static Flow Control: the receive buffer size stays unchanged and the receiver simply increases the maximum allowance linearly</p></li>
<li><p>Growing Flow Control: the size of the receive buffer increases over time as the connection progresses</p></li>
<li><p>Auto-tuning: the size of the receive buffer is adjusted dynamically based on the estimated bandwidth and round-trip times</p></li>
</ul>
</div></blockquote>
<p>In 2020, three quarter of the studied implementations used a Static Flow Control and only one used auto-tuning. Static Flow Control can work, but this is a waste of memory. For example, Google’s Chrome starts with a 15 MBytes receive buffer and updates it linearly <a class="reference internal" href="../bibliography.html#mhlq2020" id="id9"><span>[MHLQ2020]</span></a>. This should be contrasted with TCP implementations that usually start with a window of a few tens of KBytes and adjust it with auto-tuning. Auto-tuning is a key feature of modern TCP implementations <a class="reference internal" href="../bibliography.html#smm1998" id="id10"><span>[SMM1998]</span></a>. It is expected that QUIC implementations will include more advanced heuristics to tune their flow control mechanism.</p>
</div>
&#13;

<h3>QUIC Loss Detection<a class="headerlink" href="#quic-loss-detection" title="Link to this heading">#</a></h3>
<p>As other transport protocols, QUIC includes mechanisms to detect transmission errors and packet losses. The transmission errors are usually detected by using the UDP checksum or at the datalink layer with the Wi-Fi or Ethernet CRCs. When a transmission error occurs, the corresponding packet is discarded and QUIC considers this error as a packet loss. Researchers have analyzed the performance of checksums and CRCs on real data <a class="reference internal" href="../bibliography.html#sgp98" id="id11"><span>[SGP98]</span></a>.</p>
<p>Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated and a receiver can leverage this AEAD to detect transmission errors that were undetected by the UDP checksum of the CRC of the lower layers. However, these undetected transmission errors are assumed to be rare and if QUIC a detects an invalid AEAD, it will consider that this error was caused by an attack and will stop the connection using a TLS alert <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>.</p>
<p>There are several important differences between the loss detection and retransmission mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers always increase monotonically over a QUIC connection. A QUIC sender never sends twice a packet with the same packet number over a given connection. QUIC encodes the packet numbers as variable length integers and it does not support wrap around in contrast with other transport protocols. The QUIC frames contain the valuable information that needs to be delivered reliably. If a QUIC packet is lost, the frames that it contained will be retransmitted in another QUIC packet that uses a different packet number. Thus, the QUIC packet number serves as a unique identifier of a packet. This simplifies some operations such as measuring the round-trip-time which is more difficult in protocols such as TCP when packets are transmitted <a class="reference internal" href="../bibliography.html#kp91" id="id12"><span>[KP91]</span></a>.</p>
<p>Second, QUIC’s acknowledgments carry more information than the cumulative or selective acknowledgments used by TCP and related protocols. This enables the receiver to provide a more detailed view of the packets that it received. In contrast with TCP <span class="target" id="index-19"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2018.html"><strong>RFC 2018</strong></a>, once a receiver has reported that one packet was correctly received in an acknowledgment, the sender of that packet can discard the corresponding frames.</p>
<p>Third, a QUIC sender autonomously decides which frames it sends inside each packet. A QUIC packet may contain both data and control frames, or only data or only control information. If a QUIC packet is lost, the frames that it contained could be retransmitted in different packets. A QUIC implementation thus needs to buffer the frames and mark the in-flight ones to be able to retransmit them if the corresponding packet was lost.</p>
<p>Fourth, most QUIC packets are explicitly acknowledged. The only exception are the packets that only contain <code class="docutils literal notranslate"><span class="pre">ACK</span></code>, <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> or <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frames. A packet that contains any other QUIC frame is called an ack-eliciting packet because its delivery will be confirmed by the transmission of an acknowledgment. A QUIC packet that carries both an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame will thus be acknowledged.</p>
<p>With this in mind, it is interesting to look at the format of the QUIC acknowledgments and then analyze how they can be used. <a class="reference internal" href="#fig-quic-ack-frame"><span class="std std-numref">Listing 9</span></a> provides the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types are used to distinguish between the acknowledgments that contain information about the received ECN flags (type <code class="docutils literal notranslate"><span class="pre">0x03</span></code>) or only regular acknowledgments (type <code class="docutils literal notranslate"><span class="pre">0x02</span></code>). The first information contained in the ACK frame is the largest packet number that is acknowledged by this ACK frame. This is usually the highest packet number received. The second information is the ACK delay. This is the delay in microseconds between the reception of the packet having the largest acknowledged number by the receiver and the transmission of the acknowledgment. This information is important to ensure that round-trip-times are accurately measured, even if a receiver delays acknowledgments. This is illustrated in <a class="reference internal" href="#fig-quic-ack-delay"><span class="std std-numref">Fig. 94</span></a>. The <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span> <span class="pre">Count</span></code> field contains the number of <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">ranges</span></code> that are included in the QUIC ACK frame. This number can be set to zero if all packets were received in sequence without any gap. In this case, the <code class="docutils literal notranslate"><span class="pre">First</span> <span class="pre">ACK</span> <span class="pre">Range</span></code> field contains the number of the packet that arrived before the <code class="docutils literal notranslate"><span class="pre">Largest</span> <span class="pre">Acknowledged</span></code> packet number.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 9 </span><span class="caption-text">The QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-ack-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02..0x03,</span>
<span class="go">   Largest Acknowledged (i),</span>
<span class="go">   ACK Delay (i),</span>
<span class="go">   ACK Range Count (i),</span>
<span class="go">   First ACK Range (i),</span>
<span class="go">   ACK Range (..) ...,</span>
<span class="go">   [ECN Counts (..)],</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="figure" id="id27" style="text-align: center">
<span id="fig-quic-ack-delay"/><p><img src="../Images/91a1bf7fc5600dfd204d9c3691a03f74.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-5980706b89e969a89f2ce0e7ef4f744e4a9b8928.png"/></p>
<p><span class="caption-number">Fig. 94 </span><span class="caption-text">Utilization of the QUIC ACK delay</span></p>
</div><p>An <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame contains 0 or more <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Ranges</span></code>. The format of an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">range</span></code> is shown in <a class="reference internal" href="#fig-quic-ack-range"><span class="std std-numref">Listing 10</span></a>. Each range indicates first the number of unacknowledged packets since the smallest acknowledged packet in the preceding range (or the first ACK range). The next field indicates the number of consecutive acknowledged packets.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ack-range">
<div class="code-block-caption"><span class="caption-number">Listing 10 </span><span class="caption-text">A QUIC ACK range</span><a class="headerlink" href="#fig-quic-ack-range" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Range {</span>
<span class="go">   Gap (i),</span>
<span class="go">   ACK Range Length (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>As an example, consider a host that received the following QUIC packets: <code class="docutils literal notranslate"><span class="pre">3,4,6,7,8,9,11,14,16,18</span></code>. To report all the received packets, it will generate the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame shown in <a class="reference internal" href="#fig-quic-sample-ack-frame"><span class="std std-numref">Listing 11</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-sample-ack-frame">
<div class="code-block-caption"><span class="caption-number">Listing 11 </span><span class="caption-text">Sample QUIC ACK Frame</span><a class="headerlink" href="#fig-quic-sample-ack-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged=18,</span>
<span class="go">   ACK Delay=x,</span>
<span class="go">   ACK Range Count=5,</span>
<span class="go">   First ACK Range=0,</span>
<span class="go">   ACK Range #0 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #1 [Gap=2, ACK Range Length=1],</span>
<span class="go">   ACK Range #2 [Gap=3, ACK Range Length=1],</span>
<span class="go">   ACK Range #3 [Gap=2, ACK Range Length=4],</span>
<span class="go">   ACK Range #4 [Gap=2, ACK Range Length=2]</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The QUIC specification recommends to send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame after having received two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments strategy. However, there is ongoing work to allow the sender to provide more guidelines on when and how <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames should be sent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When should QUIC hosts send acknowledgments</p>
<p>A measurement study <a class="reference internal" href="../bibliography.html#mhlq2020" id="id13"><span>[MHLQ2020]</span></a> analyzed how QUIC implementations generate acknowledgments. Two of the studied implementations sent acknowledgments every N packets (2 for one implementation and 10 for the other). Other  implementations used ack frequencies that varied during the data transfer.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id28">
<img alt="../_images/quic-1.png" class="plot-directive" src="../Images/3a962b543fdebe8ff46dbfacfe31e189.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 95 </span><span class="caption-text">Acknowledgment frequencies for different QUIC servers</span><a class="headerlink" href="#id28" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The acknowledgment frequencies should be compared with TCP that usually acknowledges every second packet. It is likely that QUIC implementations will tune the generation of their acknowledgments in the coming years based on feedback from deployment.</p>
</div>
<p>It is interesting to observe that since the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are sent inside QUIC packets, they can also be acknowledged. Sending an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> in response to another <code class="docutils literal notranslate"><span class="pre">ACK</span></code> could result in an infinite exchange of <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. To prevent this problem, a QUIC sender cannot send an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame in response to a non-eliciting QUIC packet and the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames are one of the non-eliciting frame types. Note that if a receiver that receives many <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames and thus sends many <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames wants to obtain information about the reception of its <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, it can simply send one <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame inside a packet that contains an eliciting frame, e.g. a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. This frame will trigger the receiver to acknowledge it and the previously sent <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames.</p>
<p>In contrast with other reliable transport protocols, QUIC does not use cumulative acknowledgments. As explained earlier, QUIC never retransmits a packet with the same packet number. When a packet is lost, this creates a gap that the receiver reports using an <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code>. Such a gap will never be filled by retransmissions and obviously should not be reported by the receiver forever. In practice, a receiver will send the acknowledgment that corresponds to a given packet number several times and then will assume that the acknowledgment has been received. A receiver can also rely on other heuristics to determine that a given <code class="docutils literal notranslate"><span class="pre">ACK</span> <span class="pre">Range</span></code> should not be reported anymore. This is the case if the <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame was included in a packet that has been acknowledged by the other peer, but also when the gap was noticed several round-trip times ago.</p>
<p>QUIC also allows a receiver to send information about the ECN flags in the received packets. Two flags of the IP header <span class="target" id="index-20"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3168.html"><strong>RFC 3168</strong></a> are reserved to indicate support for Explicit Congestion Notification. The QUIC ECN count field shown in <a class="reference internal" href="#fig-quic-ecn-count"><span class="std std-numref">Listing 12</span></a> contains three counters for the different values of the ECN flags. These counters are incremented upon the reception of each QUIC packet based on the values of the ECN flag of the received packet. Unfortunately, there are still many operational  problems when using ECN in the global Internet <a class="reference internal" href="../bibliography.html#mlbba2018" id="id14"><span>[MLBBA2018]</span></a>. Time will tell whether it is easier to deploy ECN with QUIC than with TCP.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-ecn-count">
<div class="code-block-caption"><span class="caption-number">Listing 12 </span><span class="caption-text">A QUIC ECN Count</span><a class="headerlink" href="#fig-quic-ecn-count" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ECN Counts {</span>
<span class="go">   ECT0 Count (i),</span>
<span class="go">   ECT1 Count (i),</span>
<span class="go">   ECN-CE Count (i),</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUIC also acknowledges control frames</p>
<p>Besides the STREAM frames that carry user data, QUIC uses several different frame types to exchange control information. These control frames, like the data frames, are ack-eliciting frames. This implies a host that receives such a frame needs to acknowledge it using an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame.</p>
<p><a class="reference internal" href="#fig-quic-ack-initials"><span class="std std-numref">Fig. 97</span></a> illustrates the beginning of a QUIC connection with the exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets and the corresponding acknowledgments. The client sends its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> inside a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame in an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This is the first packet sent by the client and thus its packet number is 0. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> inside a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame in an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. Since this is the first packet sent by the server, its packet number is also 0. The packet also contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the reception of the packet containing the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Handshake</span></code>, <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> and <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are acknowledged similarly using <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frames. <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets are acknowledged in other <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets while <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> and <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are acknowledged inside <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets.</p>
</div>
<div class="figure" id="id30" style="text-align: center">
<span id="fig-quic-ack-initials"/><p><img src="../Images/75ed846fe9a217630046fd48dc876f1b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-626d297d8c568bae6dcfb3764695c72d549a86cc.png"/></p>
<p><span class="caption-number">Fig. 97 </span><span class="caption-text">QUIC also acknowledges Initial frames</span></p>
</div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all QUIC servers use 0 as the packet number of their first Initial packet</p>
<p>The example shows a QUIC connection where the client sent its Initial packet with packet number 0 and the server also replied with a packet number set to 0. This is what most QUIC implementations do. However, the QUIC specification does not strictly requires this. In fact, <code class="docutils literal notranslate"><span class="pre">facebook</span></code> servers in October 2022 appear to use random packet numbers for the Initial packet that they sent in response to a client. This is probably use to detect or mitigate some forms of attacks since the client must receive the server’s Initial packet to be able to produce a valid acknowledgment.</p>
</div>
<p>To illustrate how QUIC uses acknowledgments, let us consider a simple QUIC connection. The client starts a QUIC connection with a new server, sends a request, receives a response and then closes the connection. There are no losses in this connection. <a class="reference internal" href="#fig-quic-ack-short"><span class="std std-numref">Fig. 98</span></a> illustrates this connection.</p>
<div class="figure" id="id31" style="text-align: center">
<span id="fig-quic-ack-short"/><p><img src="../Images/00d236df000f95dc0877d8231f52d999.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-1fc45a23ddaacb37c26a462d2202c00cd14b01c7.png"/></p>
<p><span class="caption-number">Fig. 98 </span><span class="caption-text">Acknowledgments in a short QUIC connection</span></p>
</div><p>The connection starts when the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code>. The server replies with an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet that contains an acknowledgment and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code>. The server then sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet containing the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code>. Since this is the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet, its packet number is set to 0. In practice, it is likely that the server will need to send several packets to carry the certificates contained in this packet. Note that the server cannot send more than 3 packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This limit was introduced in the QUIC specification to restrict the ability of attackers to trigger DDoS attacks by sending spoofed packets to QUIC servers <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a>. If the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame containing the certificates is too long, the server might need to wait for acknowledgments from the client before sending its last <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The client confirms the reception of the server’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet by sending its last <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet that contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. This is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client and its packet number is thus 1. Since this packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame, the server does not return an acknowledgment to confirm its reception.</p>
<p>The client replies to the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet with another <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame and acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server. The client’s <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet is acknowledged by the server. The server starts the data exchange by sending a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet carrying one or more stream frames to create the required streams. Since this is the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server, its packet number is set to 0. The client then sends its request in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. The server replies with a <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame with its response. The client ends the connection by sending a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame. In the example, the server replies with a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> frame, but the QUIC specification <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc9000.html"><strong>RFC 9000</strong></a> only indicates that a host may respond with a <code class="docutils literal notranslate"><span class="pre">CONNECTION_CLOSE</span></code> in this case.</p>
&#13;

<h3>Observing QUIC connections<a class="headerlink" href="#observing-quic-connections" title="Link to this heading">#</a></h3>
<p>We have now reviewed the main components of the QUIC specification. To illustrate it, let us consider a simple scenario where a client opens a QUIC connection with a server. We leverage Maxime Piraux’s QUIC tracker <a class="reference internal" href="../bibliography.html#pdb2018" id="id15"><span>[PDB2018]</span></a>. In this example, we use the packet trace collected using the <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> server on November 22, 2021 at 18:04:52 CET. This trace is available from <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/148">https://quic-tracker.info.ucl.ac.be/traces/20211122/148</a>. You can see the contents of the packets, download it as a <code class="docutils literal notranslate"><span class="pre">.pcap</span></code> trace or visualize it using QLog/QViz <a class="reference internal" href="../bibliography.html#mpql2020" id="id16"><span>[MPQL2020]</span></a> from this web site.</p>
<p>This trace contains 16 packets. The scenario is a simple handshake with an exchange of data.</p>
<figure class="align-default" id="id32">
<img alt="../_images/qtracker-nghttp2-1.png" src="../Images/7e3eb62de8971ff53e65f8fbea028144.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-nghttp2-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 99 </span><span class="caption-text">Sample QUIC tracker trace with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code> containing a successful handshake</span><a class="headerlink" href="#id32" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>To initiate the connection, the client sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> QUIC packet.  It is interesting to analyze the content of this packet. It starts with a long QUIC header shown in <a class="reference internal" href="#fig-trace-quic-header-p1"><span class="std std-numref">Listing 13</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p1">
<div class="code-block-caption"><span class="caption-number">Listing 13 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p1" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 00,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0x6114ca6ecbe483bb,</span>
<span class="go">  Source Connection ID Length (8) = 8,</span>
<span class="go">  Source Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 1226,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (8..) = CRYPTO,</span>
<span class="go">  Type-Specific Payload (..)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The client proposes a 64 bits connection identifier and uses a random 64 bits identifier for the destination connection identifier. There is no token in this packet since this is the first connection from this client to the server. It is useful to note that the packet number of this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet is set to zero. All QUIC connections start with a packet whose packet number is set to zero in contrast with TCP that uses a random sequence number. The packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame shown in <a class="reference internal" href="#fig-trace-quic-crypto-p1"><span class="std std-numref">Listing 14</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-crypto-p1">
<div class="code-block-caption"><span class="caption-number">Listing 14 </span><span class="caption-text">The CRYPTO frame of the first QUIC packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-crypto-p1" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">CRYPTO Frame {</span>
<span class="go">   Type (i) = 0x06,</span>
<span class="go">   Offset (i) = 0,</span>
<span class="go">   Length (i) = 245,</span>
<span class="go">   Crypto Data = ClientHello</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame starts at offset 0 and has a length of <code class="docutils literal notranslate"><span class="pre">245</span></code> bytes. It contains a TLS 1.3 <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message whose format is specified in <span class="target" id="index-23"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>. This <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> includes a 32 bytes secure random number, a set of proposed cipher suites and a series of TLS extensions. One of these extensions carries the QUIC transport parameters proposed by the client. On this connection, the QUIC tracker client proposed the following ones:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_bidi_local</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_stream_data_uni</span></code> = 0x80004000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_data</span></code> = 0x80008000</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_bidi</span></code> = 0x1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_max_streams_uni</span></code> = 0x3</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_idle_timeout</span></code> = 0x6710</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">active_connection_id_limit</span></code> = 0x4</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_packet_size</span></code> = 0x45c0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inital_source_connection_id</span></code> = 0xc9f54d3c298296b9</p></li>
</ul>
</div></blockquote>
<p>Finally, the first QUIC packet contains a <code class="docutils literal notranslate"><span class="pre">PADDING</span></code> frame with 960 dummy bytes. The entire packet is 1236 bytes long.</p>
<p>The server responds to this <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet with two packets. The first one is an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. It starts with the header shown in <a class="reference internal" href="#fig-trace-quic-header-p2"><span class="std std-numref">Listing 15</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-header-p2">
<div class="code-block-caption"><span class="caption-number">Listing 15 </span><span class="caption-text">The QUIC header of the first packet sent by the client</span><a class="headerlink" href="#fig-trace-quic-header-p2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">Long Header Packet {</span>
<span class="go">  Header Form (1) = 1,</span>
<span class="go">  Fixed Bit (1) = 1,</span>
<span class="go">  Long Packet Type = 10,</span>
<span class="go">  Type-Specific Bits (4) = 0000,</span>
<span class="go">  Version (32) = 0xff00001d,</span>
<span class="go">  Destination Connection ID Length (8) = 8,</span>
<span class="go">  Destination Connection ID (0..160) = 0xc9f54d3c298296b9,</span>
<span class="go">  Source Connection ID Length (8) = 18,</span>
<span class="go">  Source Connection ID (0..160) = 0x8d3470255ae3b0b3fad3c40515132a813dfa,</span>
<span class="go">  Token Length (i) = 0,</span>
<span class="go">  Length (i) = 149,</span>
<span class="go">  Packet Number (8..32) = 0,</span>
<span class="go">  Packet Payload (...)</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This server uses 18 bytes to encode its connection identifier and proposes the first identifier in the long header. The packet payload contains two frames: an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame and a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame (<a class="reference internal" href="#fig-trace-quic-ack-p2"><span class="std std-numref">Listing 16</span></a>) acknowledges the reception of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the TLS ServerHello.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-ack-p2">
<div class="code-block-caption"><span class="caption-number">Listing 16 </span><span class="caption-text">The ACK Frame of the first packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-ack-p2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">ACK Frame {</span>
<span class="go">   Type (i) = 0x02,</span>
<span class="go">   Largest Acknowledged = 0,</span>
<span class="go">   ACK Delay = 0,</span>
<span class="go">   ACK Range Count = 0,</span>
<span class="go">   First ACK Range = 0</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The payload of these <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets is encrypted using the static key derived from the connection identifiers included in the long header.</p>
<p>The server then sends three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets carrying a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code>. These extensions are encrypted using the TLS key. They mainly contain the server certificate. It is interesting to note that the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> field of the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the server is also set to zero. This is the second, but not the last, packet that we observe with this <code class="docutils literal notranslate"><span class="pre">packet_number</span></code>. QUIC handles packet numbers differently then other protocols. QUIC considers that a QUIC connection is divided in three phases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets</p></li>
<li><p>The exchange of the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets</p></li>
<li><p>The exchange of the other packets (<code class="docutils literal notranslate"><span class="pre">0-RTT</span></code>, <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code>, … packets)</p></li>
</ol>
</div></blockquote>
<p>A QUIC host restarts the <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> at zero in each phase. This explains why it is possible to observe different packets (of different types) with the same <code class="docutils literal notranslate"><span class="pre">packet_number</span></code> over a QUIC connection.</p>
<p>The three <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server contain the beginning of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> sent by the server. To prevent denial of service attacks, the server cannot send more than three full-length packets in response to a packet sent by the client. The server thus needs to wait for an acknowledgment from the client before sending additional packets.</p>
<p>The client sends two packets to carry these acknowledgments. First, it sends an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet as the sixth packet of the trace. This packet belongs to the packet numbering space of the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets. Its packet number is 1 since this is the second <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet sent by the client. The next acknowledgment is carried inside an <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet. It acknowledges the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets 0-2 sent by the server. Since this is the first <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet sent by the client, its packet number is also 0.</p>
<p>The server then sends the eighth packet that contains the last part of the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame. By combining the information contained in the <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets and the <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packets, the client can derive the session keys.</p>
<p>The server immediately sends its first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. This packet contains a short header shown in <a class="reference internal" href="#fig-trace-quic-short-header"><span class="std std-numref">Listing 17</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="fig-trace-quic-short-header">
<div class="code-block-caption"><span class="caption-number">Listing 17 </span><span class="caption-text">The QUIC short header of the first 1-RTT packet sent by the server</span><a class="headerlink" href="#fig-trace-quic-short-header" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">1-RTT Packet {</span>
<span class="go">   Header Form (1) = 0,</span>
<span class="go">   Fixed Bit (1) = 1,</span>
<span class="go">   Spin Bit (1) = 0,</span>
<span class="go">   Reserved Bits (2)= 00,</span>
<span class="go">   Key Phase (1) = 0,</span>
<span class="go">   Packet Number Length (2)= 0,</span>
<span class="go">   Destination Connection ID = 0xc9f54d3c298296b9,</span>
<span class="go">   Packet Number = 0,</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>This short header contains the connection identifier proposed by the client in the first <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. The payload contains <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames that create three streams. The client replies with two packets. The tenth packet of the trace is a <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packet that carries two frames. The <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Finished</span></code> message that finalizes the TLS handshake. The <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame acknowledges the four <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets sent by the server.</p>
<p>The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the client contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame that acknowledges the <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server and flow control information. The client sends a <code class="docutils literal notranslate"><span class="pre">MAX_DATA</span></code> frame to restrict the amount of data that the server can send and one <code class="docutils literal notranslate"><span class="pre">MAX_STREAM</span></code> frame for each of the three streams created by the server.</p>
<p>The twelfth packet of the trace is more interesting. It contains five different frames that are sent by the server. First, the server send two <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames that advertise two 18 bytes long connection identifiers which can be used by the client to migrate the connection later. The next frame is the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame that confirms the TLS handshake. The server also sends a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame that contains a 57 bytes long token that the client will be able to use in subsequent connections with the server. The last frame is a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Tickets</span></code>.</p>
<section id="a-closer-look-at-other-quic-handshakes">
<h4>A closer look at other QUIC handshakes<a class="headerlink" href="#a-closer-look-at-other-quic-handshakes" title="Link to this heading">#</a></h4>
<p>It is interesting to analyze how different servers perform the handshake using QUIC tracker. Let us first explore the <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/140">trace collected with cloudflare-quic.com</a> on the same day shown in <a class="reference internal" href="#fig-qtracker-cloudflare"><span class="std std-numref">Fig. 100</span></a>. There are several differences with the nghttp2 trace that we analyzed above. First, the server sends two small packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code>. The first packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. It advertises a 20 bytes long connection identifier. The second packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Hello</span> <span class="pre">Retry</span> <span class="pre">Request</span></code>. This message indicates that the server did not agree with the <code class="docutils literal notranslate"><span class="pre">key_share</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> sent in the first packet. The client acknowledges this packet and sends a new <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> in the fourth packet. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> and then the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in three QUIC packets. The certificate used by <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> is more compact than the one used by <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>.</p>
<figure class="align-default" id="id33">
<span id="fig-qtracker-cloudflare"/><img alt="../_images/qtracker-cloudflare-1.png" src="../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-cloudflare-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 100 </span><span class="caption-text">Sample quic tracker trace from cloudflare-quic.com with a successful handshake</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are also slightly different. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server contains the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame, a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code> messages and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates one stream. The server then sends two short packet. Each of these packets contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates a new stream. These two short packets could have been packed in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server. In contrast with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>, <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> does advertise new connection identifiers.</p>
<p>Our third example is <a class="reference external" href="https://github.com/private-octopus/picoquic">picoquic</a>. The <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/159">QUIC tracker trace with test.privateoctopus.com</a> contains 13 packets.</p>
<figure class="align-default" id="id34">
<span id="fig-qtrack-picoquic-1"/><img alt="../_images/qtracker-picoquic-1.png" src="../Images/2caed6d4f9f898a962846ed3d2e47a9b.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 101 </span><span class="caption-text">Sample QUIC tracker trace from <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with a successful handshake</span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>picoquic uses 64 bits long connection identifiers. It manages to fit its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> within two <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that it sends contains a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. The second <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet contains one <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that advertises one <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code>, three <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames and a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame. This test server does not try to create new streams in contrast with the two others.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Comparing QUIC servers</p>
<p>It is interesting to use the traces collected by QUIC tracker to analyze how different servers have selected some of the optional features of QUIC. A first difference between the servers is the length of the server-selected connection identifiers. The graph below shows that in November 2021 many servers advertised 8 bytes CIDs, but some have opted for much longer CIDs.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id35">
<img alt="../_images/quic-2.png" class="plot-directive" src="../Images/8fa0ce7b276beb5ece519f6198e8c9be.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-2.png"/>
<figcaption>
<p><span class="caption-number">Fig. 102 </span><span class="caption-text">Length of the connection identifiers advertised by different QUIC servers (Nov 2021)</span><a class="headerlink" href="#id35" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
</section>
<section id="observing-0-rtt-data-in-quic">
<h4>Observing 0-RTT data in QUIC<a class="headerlink" href="#observing-0-rtt-data-in-quic" title="Link to this heading">#</a></h4>
<p>The ability to send data immediately was one of the requirements for the design of QUIC. It is interesting to observe how QUIC uses the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets for this purpose. We use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/619">trace collected between QUIC tracker and picoquic as our example</a>. This trace covers two QUIC connections shown in <a class="reference internal" href="#fig-qtrack-picoquic-0rtt"><span class="std std-numref">Fig. 104</span></a>.</p>
<figure class="align-default" id="fig-qtrack-picoquic-0rtt">
<img alt="../_images/qtracker-picoquic-0rtt.png" src="../Images/805be77f81fd67d0f4dbcd3429f9074d.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-0rtt.png"/>
<figcaption>
<p><span class="caption-number">Fig. 104 </span><span class="caption-text">Sample QUIC trace with <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with 0-RTT packets</span><a class="headerlink" href="#fig-qtrack-picoquic-0rtt" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>During the first QUIC connection, QUIC tracker receives one TLS session ticket in the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contained in the 1-RTT packet that the server sent with packet number set to 0. This ticket contains all the information required by the server to retrieve the key in a subsequent connection. QUIC tracker starts the second connection by sending an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> message. A comparison between this <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the one sent to create the first connection shows that the latter contains the <code class="docutils literal notranslate"><span class="pre">psk_key_exchange_modes</span></code> TLS extension. This extension contains the information that enables the server to recover the key required to decrypt the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. In this example, the client sends a <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> that contains the beginning of a simple <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code>.</p>
</section>
<section id="quic-streams">
<h4>QUIC streams<a class="headerlink" href="#quic-streams" title="Link to this heading">#</a></h4>
<p>As QUIC support multiple streams, it is interesting to analyze how the streams are managed over a real QUIC connection. For this example, we use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/375">trace between QUIC tracker and quic.tech</a> summarized in <a class="reference internal" href="#fig-qtrack-quictech"><span class="std std-numref">Fig. 105</span></a>. In the example, the QUIC tracker creates four streams and sends one <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code> request over each of them.</p>
<figure class="align-default" id="fig-qtrack-quictech">
<img alt="../_images/qtracker-quictech-1.png" src="../Images/0b2f8631f4b24e652268e6a998c32faa.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-quictech-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 105 </span><span class="caption-text">Sample QUIC trace with quic.tech using multiple streams</span><a class="headerlink" href="#fig-qtrack-quictech" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this trace, the client creates four streams in its first <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame sent in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-trace-stream-frame"><span class="std std-numref">Listing 18</span></a> shows the first of these <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames. The <code class="docutils literal notranslate"><span class="pre">Type</span></code> of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> is one octet structured as <code class="docutils literal notranslate"><span class="pre">0b00001OLF</span></code> where <code class="docutils literal notranslate"><span class="pre">O</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains an <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field. Bit <code class="docutils literal notranslate"><span class="pre">L</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the frame contains a <code class="docutils literal notranslate"><span class="pre">Length</span></code> field. Finally, the <code class="docutils literal notranslate"><span class="pre">F</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> to mark the end of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code>. In this test, QUIC Tracker sends 17 bytes over each stream and closes it.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 18 </span><span class="caption-text">The first QUIC STREAM frame sent by QUIC Tracker</span><a class="headerlink" href="#fig-quic-trace-stream-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001011,  # Offset=0, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Length = 17,</span>
<span class="go">   Stream Data = GET /index.html\r\n</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The server sends each response in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. <a class="reference internal" href="#fig-quic-trace-stream-frame-2"><span class="std std-numref">Listing 19</span></a> shows the frame returned by the server. Its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> bit is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. It carries the entire HTML page and its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field could have been ignored since this is the first frame of the stream.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame-2">
<div class="code-block-caption"><span class="caption-number">Listing 19 </span><span class="caption-text">The QUIC STREAM frame returned by the server</span><a class="headerlink" href="#fig-quic-trace-stream-frame-2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001111,  # Offset=1, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Offset = 0,</span>
<span class="go">   Length = 462,</span>
<span class="go">   Stream Data = &lt;!DOCTYPE html&gt;...</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f-stream-type" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>All <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames have a type that starts with <code class="docutils literal notranslate"><span class="pre">0b0001...</span></code>. The three low order bits of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame indicate the presence of the <code class="docutils literal notranslate"><span class="pre">Offset</span></code> and <code class="docutils literal notranslate"><span class="pre">Length</span></code> fields. The lowest order bit is the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit.</p>
</aside>
</aside>
</section>
&#13;

<h4>A closer look at other QUIC handshakes<a class="headerlink" href="#a-closer-look-at-other-quic-handshakes" title="Link to this heading">#</a></h4>
<p>It is interesting to analyze how different servers perform the handshake using QUIC tracker. Let us first explore the <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/140">trace collected with cloudflare-quic.com</a> on the same day shown in <a class="reference internal" href="#fig-qtracker-cloudflare"><span class="std std-numref">Fig. 100</span></a>. There are several differences with the nghttp2 trace that we analyzed above. First, the server sends two small packets in response to the client’s <code class="docutils literal notranslate"><span class="pre">Initial</span></code>. The first packet only contains an <code class="docutils literal notranslate"><span class="pre">ACK</span></code> frame. It advertises a 20 bytes long connection identifier. The second packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Hello</span> <span class="pre">Retry</span> <span class="pre">Request</span></code>. This message indicates that the server did not agree with the <code class="docutils literal notranslate"><span class="pre">key_share</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> sent in the first packet. The client acknowledges this packet and sends a new <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> in the fourth packet. The server replies with a <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Server</span> <span class="pre">Hello</span></code> and then the <code class="docutils literal notranslate"><span class="pre">TLSEncryptedExtensions</span></code> in three QUIC packets. The certificate used by <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> is more compact than the one used by <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>.</p>
<figure class="align-default" id="id33">
<span id="fig-qtracker-cloudflare"/><img alt="../_images/qtracker-cloudflare-1.png" src="../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-cloudflare-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 100 </span><span class="caption-text">Sample quic tracker trace from cloudflare-quic.com with a successful handshake</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packets are also slightly different. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server contains the <code class="docutils literal notranslate"><span class="pre">HANDSHAKE_DONE</span></code> frame, a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame with two <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code> messages and a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates one stream. The server then sends two short packet. Each of these packets contains a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame that creates a new stream. These two short packets could have been packed in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet sent by the server. In contrast with <code class="docutils literal notranslate"><span class="pre">nghttp2.org</span></code>, <code class="docutils literal notranslate"><span class="pre">cloudflare-quic.com</span></code> does advertise new connection identifiers.</p>
<p>Our third example is <a class="reference external" href="https://github.com/private-octopus/picoquic">picoquic</a>. The <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/159">QUIC tracker trace with test.privateoctopus.com</a> contains 13 packets.</p>
<figure class="align-default" id="id34">
<span id="fig-qtrack-picoquic-1"/><img alt="../_images/qtracker-picoquic-1.png" src="../Images/2caed6d4f9f898a962846ed3d2e47a9b.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 101 </span><span class="caption-text">Sample QUIC tracker trace from <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with a successful handshake</span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>picoquic uses 64 bits long connection identifiers. It manages to fit its <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Encrypted</span> <span class="pre">Extensions</span></code> within two <code class="docutils literal notranslate"><span class="pre">Handshake</span></code> packets. The first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet that it sends contains a <code class="docutils literal notranslate"><span class="pre">PING</span></code> frame. The second <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet contains one <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that advertises one <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">New</span> <span class="pre">Session</span> <span class="pre">Ticket</span></code>, three <code class="docutils literal notranslate"><span class="pre">NEW_CONNECTION_ID</span></code> frames and a <code class="docutils literal notranslate"><span class="pre">NEW_TOKEN</span></code> frame. This test server does not try to create new streams in contrast with the two others.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Comparing QUIC servers</p>
<p>It is interesting to use the traces collected by QUIC tracker to analyze how different servers have selected some of the optional features of QUIC. A first difference between the servers is the length of the server-selected connection identifiers. The graph below shows that in November 2021 many servers advertised 8 bytes CIDs, but some have opted for much longer CIDs.</p>
<p>(<a class="reference download internal" download="" href="../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py"><code class="xref download docutils literal notranslate"><span class="pre">Source</span> <span class="pre">code</span></code></a>, <a class="reference download internal" download="" href="../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png"><code class="xref download docutils literal notranslate"><span class="pre">png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png"><code class="xref download docutils literal notranslate"><span class="pre">hires.png</span></code></a>, <a class="reference download internal" download="" href="../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf"><code class="xref download docutils literal notranslate"><span class="pre">pdf</span></code></a>)</p>
<figure class="align-default" id="id35">
<img alt="../_images/quic-2.png" class="plot-directive" src="../Images/8fa0ce7b276beb5ece519f6198e8c9be.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/quic-2.png"/>
<figcaption>
<p><span class="caption-number">Fig. 102 </span><span class="caption-text">Length of the connection identifiers advertised by different QUIC servers (Nov 2021)</span><a class="headerlink" href="#id35" title="Link to this image">#</a></p>
</figcaption>
</figure>
</div>
&#13;

<h4>Observing 0-RTT data in QUIC<a class="headerlink" href="#observing-0-rtt-data-in-quic" title="Link to this heading">#</a></h4>
<p>The ability to send data immediately was one of the requirements for the design of QUIC. It is interesting to observe how QUIC uses the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packets for this purpose. We use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/619">trace collected between QUIC tracker and picoquic as our example</a>. This trace covers two QUIC connections shown in <a class="reference internal" href="#fig-qtrack-picoquic-0rtt"><span class="std std-numref">Fig. 104</span></a>.</p>
<figure class="align-default" id="fig-qtrack-picoquic-0rtt">
<img alt="../_images/qtracker-picoquic-0rtt.png" src="../Images/805be77f81fd67d0f4dbcd3429f9074d.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-picoquic-0rtt.png"/>
<figcaption>
<p><span class="caption-number">Fig. 104 </span><span class="caption-text">Sample QUIC trace with <code class="docutils literal notranslate"><span class="pre">test.privateoctopus.com</span></code> with 0-RTT packets</span><a class="headerlink" href="#fig-qtrack-picoquic-0rtt" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>During the first QUIC connection, QUIC tracker receives one TLS session ticket in the <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame contained in the 1-RTT packet that the server sent with packet number set to 0. This ticket contains all the information required by the server to retrieve the key in a subsequent connection. QUIC tracker starts the second connection by sending an <code class="docutils literal notranslate"><span class="pre">Initial</span></code> packet. This packet contains a <code class="docutils literal notranslate"><span class="pre">CRYPTO</span></code> frame that contains the <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> message. A comparison between this <code class="docutils literal notranslate"><span class="pre">TLS</span> <span class="pre">Client</span> <span class="pre">Hello</span></code> and the one sent to create the first connection shows that the latter contains the <code class="docutils literal notranslate"><span class="pre">psk_key_exchange_modes</span></code> TLS extension. This extension contains the information that enables the server to recover the key required to decrypt the <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> packet. In this example, the client sends a <code class="docutils literal notranslate"><span class="pre">0-RTT</span></code> that contains the beginning of a simple <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code>.</p>
&#13;

<h4>QUIC streams<a class="headerlink" href="#quic-streams" title="Link to this heading">#</a></h4>
<p>As QUIC support multiple streams, it is interesting to analyze how the streams are managed over a real QUIC connection. For this example, we use a <a class="reference external" href="https://quic-tracker.info.ucl.ac.be/traces/20211122/375">trace between QUIC tracker and quic.tech</a> summarized in <a class="reference internal" href="#fig-qtrack-quictech"><span class="std std-numref">Fig. 105</span></a>. In the example, the QUIC tracker creates four streams and sends one <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">GET</span></code> request over each of them.</p>
<figure class="align-default" id="fig-qtrack-quictech">
<img alt="../_images/qtracker-quictech-1.png" src="../Images/0b2f8631f4b24e652268e6a998c32faa.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/qtracker-quictech-1.png"/>
<figcaption>
<p><span class="caption-number">Fig. 105 </span><span class="caption-text">Sample QUIC trace with quic.tech using multiple streams</span><a class="headerlink" href="#fig-qtrack-quictech" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this trace, the client creates four streams in its first <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame sent in the first <code class="docutils literal notranslate"><span class="pre">1-RTT</span></code> packet. <a class="reference internal" href="#fig-quic-trace-stream-frame"><span class="std std-numref">Listing 18</span></a> shows the first of these <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames. The <code class="docutils literal notranslate"><span class="pre">Type</span></code> of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> is one octet structured as <code class="docutils literal notranslate"><span class="pre">0b00001OLF</span></code> where <code class="docutils literal notranslate"><span class="pre">O</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame contains an <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field. Bit <code class="docutils literal notranslate"><span class="pre">L</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the frame contains a <code class="docutils literal notranslate"><span class="pre">Length</span></code> field. Finally, the <code class="docutils literal notranslate"><span class="pre">F</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> to mark the end of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code>. In this test, QUIC Tracker sends 17 bytes over each stream and closes it.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame">
<div class="code-block-caption"><span class="caption-number">Listing 18 </span><span class="caption-text">The first QUIC STREAM frame sent by QUIC Tracker</span><a class="headerlink" href="#fig-quic-trace-stream-frame" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001011,  # Offset=0, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Length = 17,</span>
<span class="go">   Stream Data = GET /index.html\r\n</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p>The server sends each response in a <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame. <a class="reference internal" href="#fig-quic-trace-stream-frame-2"><span class="std std-numref">Listing 19</span></a> shows the frame returned by the server. Its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> bit is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. It carries the entire HTML page and its <code class="docutils literal notranslate"><span class="pre">Offset</span></code> field could have been ignored since this is the first frame of the stream.</p>
<div class="literal-block-wrapper docutils container" id="fig-quic-trace-stream-frame-2">
<div class="code-block-caption"><span class="caption-number">Listing 19 </span><span class="caption-text">The QUIC STREAM frame returned by the server</span><a class="headerlink" href="#fig-quic-trace-stream-frame-2" title="Link to this code">#</a></div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">STREAM Frame {</span>
<span class="go">   Type (i) = 0b00001111,  # Offset=1, Length=1, FIN=1</span>
<span class="go">   Stream ID = 8,</span>
<span class="go">   Offset = 0,</span>
<span class="go">   Length = 462,</span>
<span class="go">   Stream Data = &lt;!DOCTYPE html&gt;...</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f-stream-type" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>All <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frames have a type that starts with <code class="docutils literal notranslate"><span class="pre">0b0001...</span></code>. The three low order bits of the <code class="docutils literal notranslate"><span class="pre">STREAM</span></code> frame indicate the presence of the <code class="docutils literal notranslate"><span class="pre">Offset</span></code> and <code class="docutils literal notranslate"><span class="pre">Length</span></code> fields. The lowest order bit is the <code class="docutils literal notranslate"><span class="pre">FIN</span></code> bit.</p>
</aside>
</aside>
    
</body>
</html>