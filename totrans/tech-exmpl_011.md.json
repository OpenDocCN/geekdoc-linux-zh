["```go\npackage main\n\ntype leaderboard struct {\n\tavl       *AVLTree\n\tleaderMap map[string]int\n}\n\nfunc initLeaderboard() *leaderboard {\n\treturn &leaderboard{\n\t\tavl:       &AVLTree{},\n\t\tleaderMap: make(map[string]int),\n\t}\n}\n\nfunc (this *leaderboard) AddScore(playerId string, scoreToAdd int) {\n\toldScore, ok := this.leaderMap[playerId]\n\tnewScore := oldScore + scoreToAdd\n\tif ok && oldScore != 0 {\n\t\tthis.avl.Remove_Player_From_Score(oldScore, playerId)\n\t\tthis.avl.Add(newScore, playerId)\n\t} else {\n\t\tthis.avl.Add(scoreToAdd, playerId)\n\t}\n\tthis.leaderMap[playerId] = newScore\n}\n\nfunc (this *leaderboard) Reset(playerId string) {\n\toldScore, ok := this.leaderMap[playerId]\n\tif ok && oldScore != 0 {\n\t\tthis.avl.Remove_Player_From_Score(oldScore, playerId)\n\t}\n\tthis.leaderMap[playerId] = 0\n}\n\nfunc (this *leaderboard) TopPlayers(k int) []AVLItem {\n\treturn this.avl.TopPlayers(k)\n\n}\n\nfunc (this *leaderboard) TopSum(k int) int {\n\tsum := this.avl.TopSum(k)\n\treturn sum\n}\n```", "```go\npackage main\n\ntype AVLTree struct {\n\troot *AVLNode\n}\n\nfunc (t *AVLTree) Add(key int, value string) {\n\tt.root = t.root.add(key, value)\n}\n\nfunc (t *AVLTree) Remove(key int) {\n\tt.root = t.root.remove(key)\n}\n\nfunc (t *AVLTree) Search(key int) (node *AVLNode) {\n\treturn t.root.search(key)\n}\n\nfunc (t *AVLTree) TopPlayers(k int) []AVLItem {\n\tcurr := 0\n\toutput, _ := t.root.topPlayers(&curr, k)\n\treturn output\n}\n\nfunc (t *AVLTree) TopSum(k int) int {\n\tcurr := 0\n\tsum, _ := t.root.topSum(&curr, k)\n\treturn sum\n}\n\nfunc (t *AVLTree) Remove_Player_From_Score(oldScore int, playerId string) {\n\t//Get AVL Node for old Score\n\tnode := t.root.search(oldScore)\n\tif node.NumPlayers == 1 {\n\t\tt.root.remove(oldScore)\n\t} else {\n\t\tt.root.remove_player_from_score(oldScore, playerId)\n\t}\n}\n\n// AVLNode structure\ntype AVLNode struct {\n\tScore        int\n\tPlayerIDsMap map[string]bool\n\tNumPlayers   int\n\n\t// height counts nodes (not edges)\n\theight int\n\tleft   *AVLNode\n\tright  *AVLNode\n}\n\ntype AVLItem struct {\n\tScore     int\n\tPlayerIDs []string\n}\n\nfunc (n *AVLNode) topPlayers(curr *int, k int) ([]AVLItem, bool) {\n\toutput := make([]AVLItem, 0)\n\tif n.right != nil {\n\t\to, br := n.right.topPlayers(curr, k)\n\t\toutput = append(output, o...)\n\t\tif br {\n\t\t\treturn output, true\n\t\t}\n\t}\n\n\ti := 0\n\tplayerIds := make([]string, 0)\n\tfor playerId, _ := range n.PlayerIDsMap {\n\t\tif *curr < k && i < n.NumPlayers {\n\t\t\tplayerIds = append(playerIds, playerId)\n\t\t\t*curr = *curr + 1\n\t\t\ti++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\toutput = append(output, AVLItem{n.Score, playerIds})\n\n\tif *curr == k {\n\t\treturn output, true\n\t}\n\n\tif n.left != nil {\n\t\to, br := n.left.topPlayers(curr, k)\n\t\toutput = append(output, o...)\n\t\tif br {\n\t\t\treturn output, true\n\t\t}\n\t}\n\n\treturn output, false\n}\n\nfunc (n *AVLNode) topSum(curr *int, k int) (int, bool) {\n\tsum := 0\n\tif n.right != nil {\n\t\ts, br := n.right.topSum(curr, k)\n\t\tsum = sum + s\n\t\tif br {\n\t\t\treturn sum, true\n\t\t}\n\t}\n\n\tless := 0\n\n\tif k-*curr < n.NumPlayers {\n\t\tless = k - *curr\n\t} else {\n\t\tless = n.NumPlayers\n\t}\n\n\tsum = sum + n.Score*less\n\t*curr = *curr + less\n\n\tif *curr == k {\n\t\treturn sum, true\n\t}\n\n\tif n.left != nil {\n\t\ts, br := n.left.topSum(curr, k)\n\t\tsum = sum + s\n\t\tif br {\n\t\t\treturn sum, true\n\t\t}\n\t}\n\n\treturn sum, false\n}\n\n// Adds a new node\nfunc (n *AVLNode) add(score int, playerID string) *AVLNode {\n\tif n == nil {\n\t\tm := make(map[string]bool)\n\t\tm[playerID] = true\n\t\treturn &AVLNode{score, m, 1, 1, nil, nil}\n\t}\n\n\tif score < n.Score {\n\t\tn.left = n.left.add(score, playerID)\n\t} else if score > n.Score {\n\t\tn.right = n.right.add(score, playerID)\n\t} else {\n\t\t// if same key exists update value\n\t\tn.NumPlayers = n.NumPlayers + 1\n\t\tn.PlayerIDsMap[playerID] = true\n\t}\n\treturn n.rebalanceTree()\n}\n\n// Removes a node\nfunc (n *AVLNode) remove(score int) *AVLNode {\n\tif n == nil {\n\t\treturn nil\n\t}\n\tif score < n.Score {\n\t\tn.left = n.left.remove(score)\n\t} else if score > n.Score {\n\t\tn.right = n.right.remove(score)\n\t} else {\n\t\tif n.left != nil && n.right != nil {\n\t\t\t// node to delete found with both children;\n\t\t\t// replace values with smallest node of the right sub-tree\n\t\t\trightMinNode := n.right.findSmallest()\n\t\t\tn.Score = rightMinNode.Score\n\t\t\tn.PlayerIDsMap = rightMinNode.PlayerIDsMap\n\t\t\tn.NumPlayers = rightMinNode.NumPlayers\n\t\t\t// delete smallest node that we replaced\n\t\t\tn.right = n.right.remove(rightMinNode.Score)\n\t\t} else if n.left != nil {\n\t\t\t// node only has left child\n\t\t\tn = n.left\n\t\t} else if n.right != nil {\n\t\t\t// node only has right child\n\t\t\tn = n.right\n\t\t} else {\n\t\t\t// node has no children\n\t\t\tn = nil\n\t\t\treturn n\n\t\t}\n\n\t}\n\treturn n.rebalanceTree()\n}\n\n// Remove player from score\nfunc (n *AVLNode) remove_player_from_score(score int, playerId string) {\n\tif n == nil {\n\t\treturn\n\t}\n\tif score < n.Score {\n\t\tn.left.remove_player_from_score(score, playerId)\n\t} else if score > n.Score {\n\t\tn.right.remove_player_from_score(score, playerId)\n\t} else {\n\t\tn.NumPlayers = n.NumPlayers - 1\n\t\tdelete(n.PlayerIDsMap, playerId)\n\t}\n\treturn\n}\n\n// Searches for a node\nfunc (n *AVLNode) search(score int) *AVLNode {\n\tif n == nil {\n\t\treturn nil\n\t}\n\tif score < n.Score {\n\t\treturn n.left.search(score)\n\t} else if score > n.Score {\n\t\treturn n.right.search(score)\n\t} else {\n\t\treturn n\n\t}\n}\n\nfunc (n *AVLNode) getHeight() int {\n\tif n == nil {\n\t\treturn 0\n\t}\n\treturn n.height\n}\n\nfunc (n *AVLNode) recalculateHeight() {\n\tn.height = 1 + max(n.left.getHeight(), n.right.getHeight())\n}\n\n// Checks if node is balanced and rebalance\nfunc (n *AVLNode) rebalanceTree() *AVLNode {\n\tif n == nil {\n\t\treturn n\n\t}\n\tn.recalculateHeight()\n\n\t// check balance factor and rotateLeft if right-heavy and rotateRight if left-heavy\n\tbalanceFactor := n.left.getHeight() - n.right.getHeight()\n\tif balanceFactor == -2 {\n\t\t// check if child is left-heavy and rotateRight first\n\t\tif n.right.left.getHeight() > n.right.right.getHeight() {\n\t\t\tn.right = n.right.rotateRight()\n\t\t}\n\t\treturn n.rotateLeft()\n\t} else if balanceFactor == 2 {\n\t\t// check if child is right-heavy and rotateLeft first\n\t\tif n.left.right.getHeight() > n.left.left.getHeight() {\n\t\t\tn.left = n.left.rotateLeft()\n\t\t}\n\t\treturn n.rotateRight()\n\t}\n\treturn n\n}\n\n// Rotate nodes left to balance node\nfunc (n *AVLNode) rotateLeft() *AVLNode {\n\tnewRoot := n.right\n\tn.right = newRoot.left\n\tnewRoot.left = n\n\n\tn.recalculateHeight()\n\tnewRoot.recalculateHeight()\n\treturn newRoot\n}\n\n// Rotate nodes right to balance node\nfunc (n *AVLNode) rotateRight() *AVLNode {\n\tnewRoot := n.left\n\tn.left = newRoot.right\n\tnewRoot.right = n\n\n\tn.recalculateHeight()\n\tnewRoot.recalculateHeight()\n\treturn newRoot\n}\n\n// Finds the smallest child (based on the key) for the current node\nfunc (n *AVLNode) findSmallest() *AVLNode {\n\tif n.left != nil {\n\t\treturn n.left.findSmallest()\n\t} else {\n\t\treturn n\n\t}\n}\n\n// Returns max number - TODO: std lib seemed to only have a method for floats!\nfunc max(a int, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tleaderboard := initLeaderboard()\n\n\tleaderboard.AddScore(\"a\", 1)\n\tleaderboard.AddScore(\"b\", 2)\n\tleaderboard.AddScore(\"c\", 3)\n\tleaderboard.AddScore(\"d\", 4)\n\tleaderboard.AddScore(\"e\", 4)\n\n\tleaderboard.AddScore(\"f\", 10)\n\n\tk := 4\n\toutput := leaderboard.TopPlayers(k)\n\tfor i := 0; i < len(output); i++ {\n\t\tfmt.Printf(\"PlayerIDs: %v, Score: %d\\n\", output[i].PlayerIDs, output[i].Score)\n\t}\n\ttopSum := leaderboard.TopSum(k)\n\tfmt.Printf(\"Sum: %d\", topSum)\n\n\tleaderboard.AddScore(\"f\", 15)\n\n\tfmt.Println(\"\\n\")\n\tk = 7\n\toutput = leaderboard.TopPlayers(k)\n\tfor i := 0; i < len(output); i++ {\n\t\tfmt.Printf(\"PlayerIDs: %v, Score: %d\\n\", output[i].PlayerIDs, output[i].Score)\n\t}\n\ttopSum = leaderboard.TopSum(k)\n\tfmt.Printf(\"Sum: %d\", topSum)\n\n}\n```", "```go\nPlayerIDs: [f], Score: 10\nPlayerIDs: [d e], Score: 4\nPlayerIDs: [c], Score: 3\nSum: 21\n\nPlayerIDs: [f], Score: 25\nPlayerIDs: [e d], Score: 4\nPlayerIDs: [c], Score: 3\nPlayerIDs: [b], Score: 2\nPlayerIDs: [a], Score: 1\nSum: 39\n```"]