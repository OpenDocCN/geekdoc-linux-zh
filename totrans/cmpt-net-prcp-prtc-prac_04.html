<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Network security#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Network security#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/hosts/security.html">https://4ed.computer-networking.info/syllabus/default/hosts/security.html</a></blockquote>
<span id="index-0"/>
<p>In the early days, data networks were mainly used by researchers and security was not a concern. A few users were connected and capable of using the network. Almost all the devices attached to the network were openly accessible and users were trusted. As the utilization of the networks grew, security concerns started to appear. In universities, researchers and professors did not always trust their students and required some forms of access control. On standalone computers, the common access control mechanism is the password. A <cite>username</cite> is assigned to each user and when this user wants to access the computer, he or she needs to provide his/her <cite>username</cite> and his/her <cite>password</cite>. Most passwords are composed of a sequence of characters. The strength of the password is function of the difficulty of guessing the  characters chosen by each user. Various guidelines have been defined on how  to select a good password <a class="footnote-reference brackets" href="#fpasswords" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Some systems require regular modifications of the passwords chosen by their users.</p>
<p>When the first computers were attached to data networks, applications were
developed to enable them to access to remote computers through the network.
To authenticate the remote users, these applications have also relied on
usernames and passwords. When a user connects to a distant computer, she
sends her username through the network and then provides her password
to confirm her <cite>identity</cite>. This authentication scheme is presented
in the time sequence diagram below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/ee7754cb2df3b43180ffc3b27a683d83.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(I'm Alice)\n\n&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(I'm Alice)\n\n&quot; ];&#10;&#10;d=&gt;c [ label = &quot;DATA.req(Password:)\n\n&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;DATA.ind(Password:)\n\n&quot; ];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(1234xyz$)\n\n&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(1234xyz$)\n\n&quot; ];&#10;&#10;d=&gt;c [ label = &quot;DATA.req(Access)\n\n&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;DATA.ind(Access)\n\n&quot; ];&#10;}" usemap="#155fbd15184cf522dc2c2ef20abe46b4639509c2" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-155fbd15184cf522dc2c2ef20abe46b4639509c2.png"/>
<map id="155fbd15184cf522dc2c2ef20abe46b4639509c2" name="155fbd15184cf522dc2c2ef20abe46b4639509c2"/></p>
</div></blockquote>
<div class="admonition note" id="index-1">
<p class="admonition-title">Note</p>
<p>Alice and Bob</p>
<p>Alice and Bob are the first names that are used in examples for
security techniques. They first appeared in a seminal paper by Diffie
and Hellman <a class="reference internal" href="../bibliography.html#dh1976" id="id2"><span>[DH1976]</span></a>. Since then, Alice and Bob are the most
frequently used names to represent the users who interact with a network.
Other characters such as Eve or Mallory have been added over the years.
We will explain their respective roles later.</p>
</div>
<section id="security-threats">
<h2>Security threats<a class="headerlink" href="#security-threats" title="Link to this heading">#</a></h2>
<p>When analyzing security issues in computer networks, it is useful to
reason about the
capabilities of the attacker who wants to exploit some breach in the security
of the network. There are different types of attackers. Some
have generic capabilities, others are specific to a given technology or network
protocol. In this section, we discuss some important threats that a network architect must take into account.</p>
<p id="index-2">The first type of attacker is called the <cite>passive attacker</cite>.
A <cite>passive attacker</cite> is someone able to observe and usually store the information (e.g. the packets)
exchanged in a given network or subset of it (e.g. a specific link). This
attacker has access to all the data passing through this specific
link. This is the most basic type of attacker and many network technologies
are vulnerable to such attacks. In the above example, a passive
attacker could easily capture the password sent by Alice and reuse it later
to be authenticated as Alice on the remote computer. This is illustrated
in the figure below where we do not show anymore the <code class="docutils literal notranslate"><span class="pre">DATA.req</span></code> and
<code class="docutils literal notranslate"><span class="pre">DATA.ind</span></code> primitives but only the messages exchanged.
Throughout this chapter, we will always use <cite>Eve</cite> as a user who is
able to eavesdrop the data passing in front of her.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f4b5846cad3728586ed1ef7e20d24afb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Eve&quot;, linecolour=red],&#10;d [label=&quot;&quot;, linecolour=white],&#10;e [label=&quot;Bob&quot;, linecolour=black],&#10;f [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;e [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;e=&gt;f [ label = &quot;&quot; ];&#10;&#10;e=&gt;f [ label = &quot;&quot; ] ,&#10;e&gt;&gt;b [ label = &quot;Password:\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;e [ label = &quot;1234xyz$\n\n&quot;, arcskip=&quot;1&quot;];&#10;e=&gt;f [ label = &quot;&quot; ];&#10;&#10;e=&gt;f [ label = &quot;&quot; ] ,&#10;e&gt;&gt;b [ label = &quot;Access\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#17921862b047d560c7fe7db8be3c8ccaa1e34782" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-17921862b047d560c7fe7db8be3c8ccaa1e34782.png"/>
<map id="17921862b047d560c7fe7db8be3c8ccaa1e34782" name="17921862b047d560c7fe7db8be3c8ccaa1e34782"/></p>
</div></blockquote>
<p>In the above example, <cite>Eve</cite> can capture all the packets exchanged by
Bob and Alice. This implies that Eve can discover Alice’s username and
Alice’s password. With this information, Eve can then authenticate as
Alice on Bob’s computer and do whatever Alice is authorized to do. This
is a major problem from a security point of view. To prevent this attack,
Alice should never send her password in clear over a network where someone
could eavesdrop the information. In some networks, such as an open wireless
network, an attacker can easily collect all the data sent by a particular user. In other networks, this is a bit more complex depending on the network
technology used, but various software packages exist to automate this process.
As will be described later, the best approach to prevent this type of attack
is to rely on cryptographic techniques to ensure that passwords are never
sent in clear.</p>
<div class="admonition note" id="index-3">
<p class="admonition-title">Note</p>
<p>Pervasive monitoring</p>
<p>In the previous example, we have explained how Eve could capture data from
a particular user. This is not the only attack of this type. In 2013, based
on documents collected by Edward Snowden, the press revealed that several
governmental agencies were collecting lots of data on various links that
compose the global Internet <a class="reference internal" href="../bibliography.html#greenwald2014" id="id3"><span>[Greenwald2014]</span></a>. Thanks to this massive amount
of data, these
governmental agencies have been able to extract lots of information about
the behavior of Internet users. Like Eve, they are in a position to extract
passwords, usernames and other privacy sensitive data from all the packets
that they have captured. However, it seems that these agencies were often
more interested in various meta data, e.g. information showing with whom a
given user communicates than the actual data exchanged. These revelations
have shocked the Internet community and the <a class="reference external" href="https://www.ietf.org">Internet Engineering Task Force</a> that manages the standardization of Internet
protocols has declared in <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7258.html"><strong>RFC 7258</strong></a> that such pervasive monitoring is
an attack that need to be countered in the development of new protocols.
Several new protocols and extensions to existing ones
are being developed to counter these attacks.</p>
</div>
<p id="index-5">Eavesdropping and pervasive monitoring are not the only possible attacks against
a network. Another type of attacker is the active attacker. In the literature,
these attacks are often called <cite>Man in the middle</cite> or <cite>MITM</cite> attacks. Such attacks
occur when one user, let us call him <cite>Mallory</cite>, has managed to configure the
network so that he can both capture and modify the packets exchanged by two
users. The simplest scenario is when Mallory controls a router that is on the
path used by both Alice and Bob. For example, Alice could be connected to a WiFi
access router controlled by Mallory and Bob would be a regular server on the Internet.</p>
<div class="figure" style="text-align: center"><p><img src="../Images/c7ceeff3d8a02de071eac1377ed85bc7.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2da503f59e9d59459633c14a7ae833ad16530010.png"/></p>
</div><p>As Mallory receives all the packets sent by both Bob and Alice, he can modify
them at will. For example, he could modify the commands sent by Alice to the
server managed by Bob and change the responses sent by the server. This type of
attack is very powerful and sometimes difficult to counter without relying
on advanced cryptographic techniques.</p>
<p id="index-6">The last type of attack that we consider in this introduction are the <cite>Denial
of Service</cite> or DoS attacks.
During such an attack, the attacker generates enough packets to
saturate a given service and prevent it from operating correctly. The simplest
Denial of Service attack is to send more packets that the bandwidth of the
link that attaches the target to the network. The target could be a single
server, a company or even an entire country. If these packets all come from the
same source, then the victim can identify the attacker and contact the
law enforcement authorities. In practice, such denial of service attacks do
not originate from a single source. The attacker usually compromises a (possibly very large) set of sources and forces them to send packets to saturate a given target. Since the attacking traffic comes from a wide range of sources, it is difficult for the victim to locate the culprit and also to counter the attack. Saturating a link is the simplest example of <cite>Distributed Denial of Service (DDoS)</cite> attacks.</p>
<p>In practice, there is a possibility of denial of service attacks as soon as
there is a limited resource somewhere in the network.
This resource can be the bandwidth of a
link, but it could also be the computational power of a server, its memory or
even the size of tables used by a given protocol implementation. Defending
against real DoS attacks can be difficult, especially if the attacker
controls a large number of sources that are used to launch the attacks. In terms
of bandwidth, DoS attacks composed of a few Gbps to a few tens of
Gbps of traffic are frequent on the Internet. In 2015,
<a class="reference external" href="http://www.github.com">github.com</a> suffered from a distributed DoS that
reached a top bandwidth of 400 Gbps according to some
<a class="reference external" href="http://www.techworld.com/news/security/worlds-largest-ddos-attack-reached-400gbps-says-arbor-networks-3595715/">reports</a>.</p>
<p id="index-7">When designing network protocols and applications that will be deployed on a
large scale, it is important to take those DDoS attacks into account. Attackers
use different strategies to launch DDoS attacks. Some have managed to gain
control of a large number of sources by injecting malware on them. Others,
and this is where protocol designers have an important role to play, simply
exploit design flaws in some protocols. Consider a simple request-response
protocol where the client sends a request and the server replies with a
response. Often the response is larger or much larger than the request sent
by the client. Consider that such a simple protocol is used over a datagram
network. When Alice sends a datagram to Bob containing her request, Bob
extracts both the request and Alice’s address from the packet. He then sends
his response in a single packet destined to Alice. Mallory would like to create a
DoS attack against Alice without being identified. Since he has studied
the specification of this protocol, he can
send a request to Bob inside a packet having Alice’s address
as its source address. Bob will process the request and send his (large)
response to Alice. If the response has the same size as the request, Mallory
is producing a <cite>reflection attack</cite> since his packets are reflected by Bob. Alice
would think that she is attacked by Bob. If there are many servers that operate
the same service as Bob, Mallory could hide behind a large number of
such reflectors. Unfortunately, the reflection attack can also become an
amplification attack. This happens when the response sent by Bob is larger
than the request that it has received. If the response is <span class="math notranslate nohighlight">\(k\)</span> times larger than
the request, then when Mallory consumes 1 Gbps of bandwidth to send
requests, his victim receives <span class="math notranslate nohighlight">\(k\)</span> Gbps of attack traffic. Such amplification
attacks are a very important problem and protocol designers should ensure that
they never send a large response before having received the proof that the
request that they have received originated from the source indicated in
the request.</p>
</section>
<section id="cryptographic-primitives">
<h2>Cryptographic primitives<a class="headerlink" href="#cryptographic-primitives" title="Link to this heading">#</a></h2>
<p>Cryptography techniques have initially been defined and used by spies and armies
to exchange secret information in manner that ensures that adversaries cannot
decode the information even if they capture the message or the person carrying the
message. A wide range of techniques have been defined. The first techniques
relied on their secrecy to operate. One of the first encryption schemes is
attributed to Julius Caesar. When he sent confidential information to his
generals, he would encode each message by replacing each letter with another
letter that is <span class="math notranslate nohighlight">\(n\)</span> positions after this letter in the alphabet. For example,
the message <cite>SECRET</cite> becomes <cite>VHFUHW</cite> when encoded using Caesar’s cipher.
This technique could have puzzled some soldiers during Caesar’s wars, but today
even young kids can recover the original message from the ciphered one.</p>
<p id="index-8">The security of the Caesar cipher depends on the confidentiality of the
algorithm, but experience has shown that it is impossible to assume that
an algorithm will remain secret, even for military applications. Instead,
cryptographic techniques must be designed by assuming that the algorithm will
be public and known to anyone. However, its behavior must be controlled by a small
parameter, known as the key, that will only be known by the users who
need to communicate secretly. This principle is attributed to Auguste Kerckhoff,
a French cryptographer who first documented it :</p>
<blockquote>
<div><p><cite>A cryptographic algorithm should be secure even if the attacker knows
everything about the system, except one parameter known as the secret key.</cite></p>
</div></blockquote>
<p>This principle is important because it remains the basic assumption of all
cryptographers. Any system that relies on the secrecy of its algorithm
to be considered secure is doomed to fail and be broken one day.</p>
<p>With the Kerckhoff principle, we can now discuss a simple but powerful
encryption scheme that relies on the <cite>XOR</cite> logic operation. This operation is
easily implemented in hardware and is supported by all microprocessors. Given a
secret, <span class="math notranslate nohighlight">\(K\)</span>, it is possible to encode a message <cite>M</cite> by computing
<span class="math notranslate nohighlight">\(C_M = K \oplus M\)</span>. The receiver of this messages can recover the original
message as since <span class="math notranslate nohighlight">\(M = K \oplus (K \oplus M)\)</span>. This <cite>XOR</cite> operation is the
key operation of the perfect cipher that is also called the Vernam cipher or
the one-time pad. This cipher relies on a key that contains purely random
bits. The encrypted message is then produced by XORing all the bits of the
message with all the bits of the key. Since the key is random, it is impossible
for an attacker to recover the original text (or plain text) from the encrypted
one. From a security viewpoint, the one-time-pad is the best solution provided that
the key is as long as the message.</p>
<p>Unfortunately, it is difficult to use this cipher in practice since the key must be as
long as the message that needs to be transmitted. If the key is smaller than the
message and the message is divided into blocks that have the same length as
the key, then the scheme becomes less secure since the same key is used to
decrypt different parts of the message. In practice, <cite>XOR</cite> is often one of the
basic operations used by encryption schemes. To be usable, the deployed
encryption schemes use keys that are composed of a small number of bits, typically
56, 64, 128, 256, …</p>
<p>A secret key encryption scheme is a perfectly reversible
functions, i.e. given an encryption function <cite>E</cite>, there is an associated
decryption function <cite>D</cite> such that <span class="math notranslate nohighlight">\(\forall K, \forall M : D(K, E(K,M))=M\)</span>.</p>
<p id="index-9">Various secret key cryptographic functions have been proposed, implemented and
deployed. The most popular ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p>DES, the Data Encryption Standard that became a standard in 1977 and has
been widely used by industry. It uses 56 bits keys that are not considered
sufficiently secure nowadays since attackers can launch brute-force
attacks by testing all possible keys. Triple DES combines three 56 bits keys,
making the brute force attacks more difficult.</p></li>
<li><p>RC4 is an encryption scheme defined in the late 1980s by Ron Rivest for RSA
Security. Given the speed of its software implementation, it has been included in
various protocols and implementations. However, cryptographers have
identified several weaknesses in this algorithm. It is now deprecated
and should not be used anymore <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7465.html"><strong>RFC 7465</strong></a>.</p></li>
<li><p>AES or the Advanced Encryption Standard is an encryption scheme that was
designed by the Belgian cryptographers Joan Daemen and Vincent Rijmen
in 2001 <a class="reference internal" href="../bibliography.html#dr2002" id="id4"><span>[DR2002]</span></a>. This algorithm  has been standardized by the U.S.
National Institute
of Standards and Technology (NIST). It is now used by a wide range of
applications and various hardware and software implementations exist. Many
microprocessors include special instructions that ease the implementation
of AES. AES divides the message to be encrypted in blocks of 128 bits and
uses keys of length 128, 192 or 256 bits. The block size and the key length
are important parameters of an encryption scheme. The block size indicates
the smallest message that can be encrypted and forces the sender to divide
each message in blocks of the supported size. If the message is larger than
an integer number of blocks, then the message must be padded before being
encrypted and this padding must be removed after decryption. The key size
indicates the resistance of the encryption scheme against brute force
attacks, i.e. attacks where the attacker tries all possible keys to find
the correct one.</p></li>
</ul>
</div></blockquote>
<p>AES is widely used as of this writing, but other secret key encryption schemes
continue to appear. ChaCha20, proposed by D. Bernstein is now used by
several internet protocols <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7539.html"><strong>RFC 7539</strong></a>. A detailed discussion of encryption
schemes is outside the scope of this book. We will consider encryption schemes
as black boxes whose operation depends on a single key. A detailed overview
of several of these schemes may be found in <a class="reference internal" href="../bibliography.html#mvv2011" id="id5"><span>[MVV2011]</span></a>.</p>
<p id="index-12">In the 1970s, Diffie and Hellman proposed in their seminal paper <a class="reference internal" href="../bibliography.html#dh1976" id="id6"><span>[DH1976]</span></a>, a
different type of encryption : <cite>public key cryptography</cite>. In public key
cryptography, each user has two different keys :</p>
<blockquote>
<div><ul class="simple">
<li><p>a public key (<span class="math notranslate nohighlight">\(K_{pub}\)</span>) that he can distribute to everyone</p></li>
<li><p>a private key (<span class="math notranslate nohighlight">\(K_{priv}\)</span>) that he needs to store in a secure
manner and never reveal to anyone</p></li>
</ul>
</div></blockquote>
<p>These two keys are generated together and they are linked by a complex
mathematical relationship that is such that it is computationally difficult
to compute <span class="math notranslate nohighlight">\(K_{priv}\)</span> from <span class="math notranslate nohighlight">\(K_{pub}\)</span>.</p>
<p>A public key cryptographic scheme is a combination of two functions :</p>
<blockquote>
<div><ul class="simple">
<li><p>an encryption function, <span class="math notranslate nohighlight">\(E_{p}\)</span>, that takes a key and a message as parameters</p></li>
<li><p>a decryption function, <span class="math notranslate nohighlight">\(D_{p}\)</span>, that takes a key and a message as parameters</p></li>
</ul>
</div></blockquote>
<p>The public key is used to encrypt a message so that it can only be read by
the intended recipient. For example, let us consider two users : Alice and Bob.
Alice (resp. Bob) uses the keys <span class="math notranslate nohighlight">\(A_{priv}\)</span> and <span class="math notranslate nohighlight">\(A_{pub}\)</span> (resp.
<span class="math notranslate nohighlight">\(B_{priv}\)</span> and <span class="math notranslate nohighlight">\(B_{pub}\)</span>). To send a secure message <cite>M</cite> to Alice,
Bob computes <span class="math notranslate nohighlight">\(CM=E_p(A_{pub},M)\)</span> and Alice can decrypt it by using
<span class="math notranslate nohighlight">\(D_p(A_{priv},CM)=D_p(A_{priv},E_p(A_{pub},M))=M\)</span>.</p>
<p>Several public key encryption schemes have been proposed. Two of them have
reached wide deployment :</p>
<blockquote>
<div><ul class="simple">
<li><p>The Rivest Shamir Adleman (RSA) algorithm <a class="footnote-reference brackets" href="#frsa" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> proposed in
<a class="reference internal" href="../bibliography.html#rsa1978" id="id8"><span>[RSA1978]</span></a> that relies on modular exponentiation with large integers.</p></li>
<li><p>The Elliptic Curve Cryptography techniques <a class="footnote-reference brackets" href="#fecc" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> that rely on special
properties of elliptic curves.</p></li>
</ul>
</div></blockquote>
<p>Another interesting property of public key cryptography is its ability to
compute <cite>signatures</cite> that can be used to authenticate a message. This capability
comes from the utilization of two different keys that are linked together.
If Alice wants to sign a message <cite>M</cite>, she can compute
<span class="math notranslate nohighlight">\(SM=E_p(A_{priv},M)\)</span>. Anyone who receives this signed messaged can extract
its content as <span class="math notranslate nohighlight">\(D_p(A_{pub},SM)=D_p(A_{pub},E_p(A_{priv},M))=M\)</span>. Everyone
can use <span class="math notranslate nohighlight">\(A_{pub}\)</span> to check that the message was signed by using
Alice’s private key (<span class="math notranslate nohighlight">\(A_{priv}\)</span>). Since this key is only known
by Alice, the ability to decrypt <cite>SM</cite> is a proof that the message was signed
by Alice herself.</p>
<p>In practice, encrypting a message to sign it can be computationally costly,
in particular if the message is a large file. A faster solution would be
to summarize the document and only sign the summary of the document. A naive
approach could be based on a checksum or CRC computed over the message. Alice
would then compute <span class="math notranslate nohighlight">\(C=Checksum(M)\)</span> and <span class="math notranslate nohighlight">\(SC=E_p(A_{priv},C)\)</span>. She
would then send both <cite>M</cite> and <cite>SC</cite> to the recipient of the message who can
easily compute <cite>C</cite> from <cite>SC</cite> and verify the authenticity of the message. Unfortunately,
this solution does not protect Alice and the message’s recipient against
a man-in-the-middle attack. If Mallory can intercept the message sent by Alice,
he can easily modify Alice’s message and tweak it so that it has the same
checksum as the original one. The CRCs, although more complex to compute,
suffer from the same problem.</p>
<p>To efficiently sign messages, Alice needs to be able to compute a summary
of her message in a way that makes prohibits an attacker from generating a
different message that has the same summary. <cite>Cryptographic hash functions</cite>
were designed to solve this problem. The ideal hash function is a function
that returns a different number for every possible input. In practice, it
is impossible to find such a function. Cryptographic hash functions are an
approximation of this perfect summarization function. They
compute a summary of a given message in 128, 160, 256 bits or more. They also
exhibit the <cite>avalanche effect</cite>. This effect indicates that a small change in
the message causes a large change in the hash value. Finally hash functions
are very difficult to invert. Knowing a hash value, it is computationally very
difficult to find the corresponding input message. Several hash functions have
been proposed by cryptographers. The most popular ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p>MD5, originally proposed in <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>. It has been used in a wide range of
applications. In 2010, attacks against MD5 were published and this hash
function is now deprecated.</p></li>
<li><p>SHA-1 is a cryptographic hash function that was standardized by the
NIST in 1995. It outputs 160 bits results. It is now used in a variety
of network protocols.</p></li>
<li><p>SHA-2 is another family of cryptographic hash functions designed by the NIST.
Different variants of SHA-2 can produce has values of 224, 256, 384 or 512
bits.</p></li>
</ul>
</div></blockquote>
<p>Another important point about cryptographic algorithms is that often these
algorithms require random numbers to operate correctly (e.g. to generate
keys). Generating good random numbers is difficult and any implementation
of cryptographic algorithms should also include a secure random number
generator. <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4086.html"><strong>RFC 4086</strong></a> provides useful recommendations.</p>
</section>
<section id="cryptographic-protocols">
<h2>Cryptographic protocols<a class="headerlink" href="#cryptographic-protocols" title="Link to this heading">#</a></h2>
<p>We can now combine the cryptographic operations described in the previous section
to build some protocols to securely exchange
information. Let us first go back to the problem of authenticating
Alice on Bob’s computer. We have shown earlier that using
a simple password for this purpose is insecure in the presence of attackers.</p>
<p>A naive approach would be to rely on hash functions. Since hash functions
are non-invertible, Alice and Bob could decide to use them to exchange Alice’s
password in a secure manner. Then, Alice could be authenticated by using
the following exchange.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/8ce774d886954a61fe3332c085b81a4f.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Prove it\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Hash(passwd)\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Access granted\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#e9d4cd4a36e66a6415dde6e83ecc95535122af78" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-e9d4cd4a36e66a6415dde6e83ecc95535122af78.png"/>
<map id="e9d4cd4a36e66a6415dde6e83ecc95535122af78" name="e9d4cd4a36e66a6415dde6e83ecc95535122af78"/></p>
</div></blockquote>
<p id="index-15">Since the hash function cannot be inverted, an eavesdropper cannot extract
Alice’s password by simply observing the data exchanged. However, Alice’s
real password is not the objective of an attacker. The main objective for
Mallory is to be authenticated as Alice. If Mallory can capture
<cite>Hash(passwd)</cite>, he can simply replay this data, without being able to invert
the hash function. This is called a <cite>replay attack</cite>.</p>
<p>To counter this replay attack, we need to ensure that Alice never sends the
same information twice to Bob. A possible mode of operation is shown below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/d68b2f1363c49e52d5bce558f315b1ad.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:764192\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Hash(764192||passwd)\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Access\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#20f577439fc03098f4163306e3e3d06fd0e01a3f" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-20f577439fc03098f4163306e3e3d06fd0e01a3f.png"/>
<map id="20f577439fc03098f4163306e3e3d06fd0e01a3f" name="20f577439fc03098f4163306e3e3d06fd0e01a3f"/></p>
</div></blockquote>
<p id="index-16">To authenticate herself, Alice sends her user identifier to Bob. Bob replies with
a random number as a challenge to verify that Alice knows the shared secret
(i.e. her password). Alice replies with the result of the computation
of a hash function (e.g. SHA-1) over a string that is the concatenation
between the random number chosen by Bob and Alice’s password. The random
number chosen by Bob is often called a <cite>nonce</cite> since this is a number
that should only be used once. Bob performs the
same computation locally and can check the message returned by Alice.
This type of authentication scheme has been used in various protocols. It
prevents replay attacks. If Eve captures the messages exchanged by
Alice and Bob, she cannot recover Alice’s password from the messages exchanged
since hash functions are non-invertible. Furthermore, she cannot replay the
hashed value since Bob will always send a different nonce.</p>
<p>Unfortunately, this solution forces Bob to store Alice’s password in clear. Any
breach in the security of Bob’s computer would reveal Alice’s password. Such
breaches unfortunately occur and some of them have led to the dissemination of
millions of passwords.</p>
<p id="index-17">A better approach would be to authenticate Alice without storing her password
in clear on Bob’s computer. For this, Alice computes a <cite>hash chain</cite>
as proposed by Lamport in <a class="reference internal" href="../bibliography.html#lamport1981" id="id10"><span>[Lamport1981]</span></a>. A hash
chain is a sequence of applications of a hash function (<cite>H</cite>) on an input string. If
Alice’s password is <cite>P</cite>, then her 10 steps hash chain is :
<span class="math notranslate nohighlight">\(H(H(H(H(H(H(H(H(H(H(P))))))))))\)</span>. The result of this hash chain will
be stored on Bob’s computer together with the value <cite>10</cite>. This number is the
maximum number of remaining authentications for Alice on Bob’s computer.
To authenticate Alice, Bob sends the remaining number of authentications, i.e.
<cite>10</cite> in this example. Since Alice knows her password, <cite>P</cite>, she can compute
<span class="math notranslate nohighlight">\(H^9(P)=H(H(H(H(H(H(H(H(H(P)))))))))\)</span> and send this information to Bob.
Bob computes the hash of the value received from Alice (<span class="math notranslate nohighlight">\(H(H^9(P))\)</span>)
and verifies that this value is equal to the value stored in his database. It
then decrements the number of authorized authentications and stores
<span class="math notranslate nohighlight">\(H^9(P)\)</span> in his database. Bob is now ready for the next authentication
of Alice. When the number of authorized authentications reaches zero, the
hash chain needs to be reinitialized. If Eve captures <span class="math notranslate nohighlight">\((H^n(P))\)</span>, she
cannot use it to authenticate herself as Alice on Bob’s computer because
Bob will have decremented its number of authorized authentications. Furthermore,
given that hash functions are not invertible, Eve cannot compute
<span class="math notranslate nohighlight">\(H^{n-1}(P)\)</span> from <span class="math notranslate nohighlight">\(H^{n}(P)\)</span>.</p>
<p>The two protocols above prevent eavesdropping attacks, but not man-in-the-middle
attacks. If Mallory can intercept the messages sent by Alice, he could force
her to reveal <span class="math notranslate nohighlight">\(H^n(P)\)</span> and then use this information to authenticate
as Alice on Bob’s computer. In practice, hash chains should only be used when
the communicating users know that there cannot be any man-in-the-middle on
their communication.</p>
<p>Public key cryptography provides another possibility to allow Alice
to authenticate herself on Bob’s computer. Assume again that Alice and
Bob know each other from previous encounters. Alice knows Bob’s public key
(<span class="math notranslate nohighlight">\(Bob_{pub}\)</span>) and Bob also knows Alice’s key (<span class="math notranslate nohighlight">\(Alice_{pub}\)</span>). To
authenticate herself, Alice could send her user identifier. Bob would reply
with a random number encrypted with Alice’s public key :
<span class="math notranslate nohighlight">\(E_p(Alice_{pub},R)\)</span>. Alice can decrypt this message to recover <cite>R</cite>
and sends <span class="math notranslate nohighlight">\(E_p(Bob_{pub},R)\)</span>. Bob decrypts the nonce and confirms that
Alice knows <span class="math notranslate nohighlight">\(Alice_{priv}\)</span>. If an eavesdropper captures the
messages exchanged, he cannot recover the value <cite>R</cite> which could be used as
a key to encrypt the information with a secret key algorithm.
This is illustrated in the time sequence diagram below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f7eeac697813279f3277f20eb023de49.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;E_p(Alice_{pub},R)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Bob_{pub},R)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#6027ccdd0a4dba418aa8843c8ac153fd6a422bd7" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6027ccdd0a4dba418aa8843c8ac153fd6a422bd7.png"/>
<map id="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7" name="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"/></p>
</div></blockquote>
<p>A drawback of this approach is that Bob is forced to perform two
public key computations : one encryption to send the random nonce
to Alice and one decryption to recover the nonce encrypted by Alice.
If these computations are costly from a CPU viewpoint, this creates
a risk of Denial of Service Attacks were attackers could try to
access Bob’s computer and force it to perform such costly computations.
Bob is more at risk than Alice in this situation and he should not perform
complex operations before being sure that he is talking with Alice.
An alternative is shown in the time sequence diagram below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/5d0252030a1e74f0aa10edc4572b381d.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;R\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R)\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#26127d2d1ccdbf50c7d1c6d967ea621292da9631" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-26127d2d1ccdbf50c7d1c6d967ea621292da9631.png"/>
<map id="26127d2d1ccdbf50c7d1c6d967ea621292da9631" name="26127d2d1ccdbf50c7d1c6d967ea621292da9631"/></p>
</div></blockquote>
<p>Here, Bob simply sends a random nonce to Alice and verifies her signature.
Since the random nonce and the signature could be captured by an eavesdropper,
they cannot be used as a secret key to encrypt further data. However
Bob could propose a secret key and send it encrypted with Alice’s
public key in response to the signed nonce that he received.</p>
<p>The solution described above works provided that Bob and Alice know their
respective public keys before communicating. Otherwise, the protocol is not secure against
man-in-the-middle attackers. Consider Mallory sitting in the middle
between Alice and Bob and assume that neither Alice nor Bob knows
the other’s public key.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/0638f4c9db9fea46091250d1fe48d4c9.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;x [label=&quot;&quot;, linecolour=white],&#10;y [label=&quot;Mallory&quot;, textcolour=&quot;red&quot;, linecolour=red],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot; &quot; ] ,&#10;b&gt;&gt;y [ label = &quot;I'm Alice key=Alice_{pub}&quot;, arcskip=&quot;1&quot; ];&#10;y&gt;&gt;c [ label = &quot;I'm Alice key=Mallory_{pub}&quot;, textcolour=&quot;red&quot;, arcskip=&quot;1&quot; ];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;R&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;y [ label = &quot;E_p(Alice_{priv},R)&quot;, arcskip=&quot;1&quot;];&#10;y&gt;&gt;c [ label = &quot;E_p(Mallory_{priv},R)&quot;, textcolour=&quot;red&quot;,  arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Access&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#1ee9ab4ade7fb05cf8774418033d3c5fb2944924" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-1ee9ab4ade7fb05cf8774418033d3c5fb2944924.png"/>
<map id="1ee9ab4ade7fb05cf8774418033d3c5fb2944924" name="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"/></p>
</div></blockquote>
<p>In the above example, Alice sends her public key, (<span class="math notranslate nohighlight">\(Alice_{pub}\)</span>), in
her first message together with her identity. Mallory intercepts the message
and replaces Alice’s key with his own key, (<span class="math notranslate nohighlight">\(Mallory_{pub}\)</span>). Bob
replies with a nonce, <cite>R</cite>. Alice then signs the random
nonce to prove that she knows <span class="math notranslate nohighlight">\(Alice_{priv}\)</span>. Mallory discards the
information and instead computes <span class="math notranslate nohighlight">\(E_p(Mallory_{priv},R)\)</span>. Bob now
thinks that he is discussing with Alice while Mallory sits in the middle.</p>
<p>There are situations where symmetric authentication is required. In this case,
each user must perform some computation with his/her private key. A possible
exchange is the following. Alice sends her certificate to Bob. Bob replies with
a nonce, <span class="math notranslate nohighlight">\(R1\)</span>, and provides his certificate. Alice encrypts <span class="math notranslate nohighlight">\(R1\)</span> with
her private key and generates a nonce, <span class="math notranslate nohighlight">\(R2\)</span>. Bob verifies Alice’s computation
and encrypts <span class="math notranslate nohighlight">\(R2\)</span> with his private key. Alice verifies the computation and
both have been authenticated.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/682391126620ce67dffa1f33ee972f1b.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:R1&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R1),R2&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;E_p(Bob_{priv},R2)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#dc928c892b0c31362bbfde7cc4e2025e18374729" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-dc928c892b0c31362bbfde7cc4e2025e18374729.png"/>
<map id="dc928c892b0c31362bbfde7cc4e2025e18374729" name="dc928c892b0c31362bbfde7cc4e2025e18374729"/></p>
</div></blockquote>
<p>The protocol described above works, but it takes a long time for Bob to authenticate
Alice and for Alice to authenticate Bob. A faster authentication could be the following.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/d9c1e952550357ddf872d47493c46bd4.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice, R2&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:R1,E_p(Bob_{priv},R2)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R1)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#b006024cf4bbd5812ac6af177e9c613098b52e42" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b006024cf4bbd5812ac6af177e9c613098b52e42.png"/>
<map id="b006024cf4bbd5812ac6af177e9c613098b52e42" name="b006024cf4bbd5812ac6af177e9c613098b52e42"/></p>
</div></blockquote>
<p>Alice sends her random nonce, <span class="math notranslate nohighlight">\(R2\)</span>. Bob signs <span class="math notranslate nohighlight">\(R2\)</span> and sends his nonce :
<span class="math notranslate nohighlight">\(R1\)</span>. Alice signs <span class="math notranslate nohighlight">\(R1\)</span> and both are authenticated.</p>
<p>Now consider that Mallory wants to be authenticated as Alice. The above protocol
has a subtle flaw that could be exploited by Mallory. This flaw can be exploited if
Alice and Bob can act as both client and server. Knowing this, Mallory could operate
as follows. Mallory starts an authentication with Bob faking himself as Alice.
He sends a first message to Bob including Alice’s identity.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/0129748f31a23c4c1ec10d426878fd81.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Mallory&quot;, textcolour=&quot;red&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice,RA&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:RB,E_p(Bob_{priv},RA)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#b30892ea80e85d5226bffe1067bd495dabafda9e" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b30892ea80e85d5226bffe1067bd495dabafda9e.png"/>
<map id="b30892ea80e85d5226bffe1067bd495dabafda9e" name="b30892ea80e85d5226bffe1067bd495dabafda9e"/></p>
</div></blockquote>
<p>In this exchange, Bob authenticates himself by signing the <span class="math notranslate nohighlight">\(RA\)</span> nonce that was
sent by Mallory. Now, to authenticate as Alice, Mallory needs to compute
the signature of nonce <span class="math notranslate nohighlight">\(RB\)</span> with Alice’s private key. Mallory does not
know Alice’s key, but he could exploit the protocol to force Alice to
perform the required computation. For this, Mallory can start an
authentication to Alice as shown below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/cd66745b390b62a38dfe355eb3a5cc12.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Mallory&quot;, textcolour=&quot;red&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Alice&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Mallory,RB&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:RX,E_p(Alice_{priv},RB)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#48be047a9645ab6feb54e3f2716ac4f1e148d8e7" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-48be047a9645ab6feb54e3f2716ac4f1e148d8e7.png"/>
<map id="48be047a9645ab6feb54e3f2716ac4f1e148d8e7" name="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"/></p>
</div></blockquote>
<p>In this example, Mallory has forced Alice to compute
<span class="math notranslate nohighlight">\(E_p(Alice_{priv},RB)\)</span> which is the information required to
finalize the first exchange and be authenticated as Alice. This
illustrates a common problem with authentication schemes when the same
information can be used for different purposes. The problem comes from
the fact that Alice agrees to compute her signature on a nonce chosen
by Bob (and relayed by Mallory). This problem occurs if the nonce is a
simple integer without any structure. If the nonce includes some structure
such as some information about Alice and Bob’s identities or even a
single bit indicating whether the nonce was chosen by a user acting as
a client (i.e. starting the authentication) or as a server, then the
protocol is not vulnerable anymore.</p>
<p id="index-18">To cope with some of the above mentioned problems,
public-key cryptography is usually combined with
certificates. A <cite>certificate</cite> is a data structure that includes a signature from
a trusted third party. A simple explanation of the utilization of certificates
is to consider that Alice and Bob both know Ted. Ted is trusted by these
two users and both have stored Ted’s public key : <span class="math notranslate nohighlight">\(Ted_{pub}\)</span>. Since they
both know Ted’s key, he can issue certificates. A certificate is mainly a
cryptographic link between the identity of a user and his/her public key.
Such a certificate can be computed in different ways. A simple solution is for
Ted to generate a file that contains the following information
for each certified user :</p>
<blockquote>
<div><ul class="simple">
<li><p>his/her identity</p></li>
<li><p>his/her public key</p></li>
<li><p>a hash of the entire file signed with Ted’s private key</p></li>
</ul>
</div></blockquote>
<p>Then, knowing Ted’s public key, anyone can verify the validity of a certificate.
When a user sends his/her public key, he/she must also attach the certificate to
prove the link between his/her identity and the public key. In practice,
certificates are more complex than this.
Certificates will often be used to authenticate the
server and sometimes to authenticate the client.</p>
<p>A possible protocol could then be the following. Alice sends
<span class="math notranslate nohighlight">\(Cert(Alice_{pub},Ted)\)</span>. Bob replies with a random nonce.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/64eccedf6350698b6491b83ea9b24e73.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Cert(Alice_{pub},Ted)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;R&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot;] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#3b6facf99117568ccbf6aa8408c70dddc156d855" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-3b6facf99117568ccbf6aa8408c70dddc156d855.png"/>
<map id="3b6facf99117568ccbf6aa8408c70dddc156d855" name="3b6facf99117568ccbf6aa8408c70dddc156d855"/></p>
</div></blockquote>
<p>Until now, we have only discussed the authentication problem. This is an
important but not sufficient step to have a secure communication between two
users through an insecure network. To securely exchange information, Alice
and Bob need to both :</p>
<blockquote>
<div><ul class="simple">
<li><p>mutually authenticate each other</p></li>
<li><p>agree on a way to encrypt the messages that they will exchange</p></li>
</ul>
</div></blockquote>
<p>Let us first explore how this could be realized by using public-key
cryptography. We assume that Alice and Bob have both a public-private
key pair and the corresponding certificates signed by a trusted
third party : Ted.</p>
<p>A possible protocol would be the following.
Alice sends <span class="math notranslate nohighlight">\(Cert(Alice_{pub},Ted)\)</span>. This certificate provides Alice’s
identity and her public key.
Bob replies with the certificate containing his own public key :
<span class="math notranslate nohighlight">\(Cert(Bob_{pub},Ted)\)</span>. At this point, they both know the
other public key and could use it to send encrypted messages.
Alice would send <span class="math notranslate nohighlight">\(E_p(Bob_{pub},M1)\)</span> and Bob would send
<span class="math notranslate nohighlight">\(E_p(Alice_{pub},M2)\)</span>. In practice, using public key encryption
techniques to encrypt a large number of messages is inefficient because
these cryptosystems require a large number of computations. It is more
efficient to use secret key cryptosystems for most of the data and only
use a public key cryptosystem to encrypt the random secret keys that
will be used by the secret key encryption scheme.</p>
</section>
<section id="key-exchange">
<h2>Key exchange<a class="headerlink" href="#key-exchange" title="Link to this heading">#</a></h2>
<p>When users want to communicate securely through a network,
they need to exchange information such as the keys that will be
used by an encryption algorithm even in the presence of an
eavesdropper. The most widely used algorithm that allows
two users to safely exchange an integer in the presence of
an eavesdropper is the one proposed by Diffie and Hellman <a class="reference internal" href="../bibliography.html#dh1976" id="id11"><span>[DH1976]</span></a>.
It operates with (large) integers. Two of them are public, the modulus, p,
which is prime and the base, g, which must be a primitive root of p.
The communicating users select a random integer, <span class="math notranslate nohighlight">\(a\)</span> for Alice and <span class="math notranslate nohighlight">\(b\)</span> for
Bob. The exchange starts as :</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice selects a random integer, <span class="math notranslate nohighlight">\(a\)</span> and sends
<span class="math notranslate nohighlight">\(A=g^{a} \mod p\)</span> to Bob</p></li>
<li><p>Bob selects a random integer, <span class="math notranslate nohighlight">\(b\)</span> and sends
<span class="math notranslate nohighlight">\(B=g^{b} \mod p\)</span> to Alice</p></li>
<li><p>From her knowledge of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, Alice can compute
<span class="math notranslate nohighlight">\(Secret=B^{a} \mod p= (g^{b} \mod p) ^{a} \mod p=g^{a \times b} \mod p\)</span></p></li>
<li><p>From is knowledge of <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(A\)</span>, Bob can compute
<span class="math notranslate nohighlight">\(Secret=A^{b} \mod p=(g^{a} \mod p) ^{b} \mod p=g^{a \times b} \mod p\)</span></p></li>
</ul>
</div></blockquote>
<p>The security of this protocol relies on the difficulty of computing
discrete logarithms, i.e. from the knowledge of <span class="math notranslate nohighlight">\(A\)</span> (resp. <span class="math notranslate nohighlight">\(B\)</span>),
it is very difficult to extract <span class="math notranslate nohighlight">\(\log(A)=\log(g^{a} \mod p)=a\)</span>
(resp. <span class="math notranslate nohighlight">\(\log(B)=\log(g^{b} \mod p)=b\)</span>).</p>
<p>An example of the utilization of the Diffie-Hellman key exchange is
shown below. Before starting the exchange, Alice
and Bob agree on a modulus (<span class="math notranslate nohighlight">\(p=23\)</span>) and a base (<span class="math notranslate nohighlight">\(g=5\)</span>). These two
numbers are public. They are typically part of the standard that defines
the protocol that uses the key exchange.</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice chooses a secret integer : <span class="math notranslate nohighlight">\(a=8\)</span> and sends
<span class="math notranslate nohighlight">\(A= g^{a} \mod p= 5^{8} \mod 23=16\)</span> to Bob</p></li>
<li><p>Bob chooses a secret integer : <span class="math notranslate nohighlight">\(b=13\)</span> and sends
<span class="math notranslate nohighlight">\(B= g^{b} \mod p=5^{13} \mod 23=21\)</span> to Alice</p></li>
<li><p>Alice computes <span class="math notranslate nohighlight">\(S_{A}=B^{a} \mod p= 21^{8} \mod 23=3\)</span></p></li>
<li><p>Bob computes <span class="math notranslate nohighlight">\(S_{B}=A^{b} \mod p= 16^{13} \mod 23=3\)</span></p></li>
</ul>
</div></blockquote>
<p>Alice and Bob have agreed on the secret information <span class="math notranslate nohighlight">\(3\)</span> without
having sent it explicitly through the network. If the integers used are
large enough and have good properties, then even Eve who can capture all
the messages sent by Alice and Bob cannot recover the secret key that
they have exchanged. There is no formal proof of the security of
the algorithm, but mathematicians have tried to solve similar problems with
integers during centuries without finding an efficient algorithm. As
long as the integers that are used are random and large enough, the only
possible attack for Eve is to test all possible integers that could have
been chosen by Alice and Bob. This is computationally very expensive.
This algorithm is widely used in security protocols to agree on a secret key.</p>
<p>Unfortunately, the Diffie-Hellman key exchange alone cannot cope with man-in-the
middle attacks. Consider Mallory who sits in the middle between Alice and
Bob and can easily capture and modify their messages. The modulus
and the base are public. They are thus known by Mallory as well. He
could then operate as follows :</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice chooses a secret integer and sends <span class="math notranslate nohighlight">\(A= g^{a} \mod p\)</span> to Mallory</p></li>
<li><p>Mallory generates a secret integer, <span class="math notranslate nohighlight">\(m\)</span> and sends <span class="math notranslate nohighlight">\(M=g^{m} \mod p\)</span> to Bob</p></li>
<li><p>Bob chooses a secret integer and sends <span class="math notranslate nohighlight">\(B=g^{b} \mod p\)</span> to Mallory</p></li>
<li><p>Mallory computes <span class="math notranslate nohighlight">\(S_{A}=A^{m} \mod p\)</span> and <span class="math notranslate nohighlight">\(S_{B}=B^{m} \mod p\)</span></p></li>
<li><p>Alice computes <span class="math notranslate nohighlight">\(S_{A}=M^{a} \mod p\)</span> and uses this key to communicate with Mallory (acting as Bob)</p></li>
<li><p>Bob computes <span class="math notranslate nohighlight">\(S_{B}=M^{b} \mod p\)</span> and uses this key to communicate with Mallory (acting as Alice)</p></li>
</ul>
</div></blockquote>
<p>When Alice sends a message, she encrypts it with <span class="math notranslate nohighlight">\(S_{A}\)</span>. Mallory
decrypts it with <span class="math notranslate nohighlight">\(S_{A}\)</span> and encrypts the plaintext with
<span class="math notranslate nohighlight">\(S_{B}\)</span>. When Bob receives the message, he can decrypt it
by using <span class="math notranslate nohighlight">\(S_{B}\)</span>.</p>
<p>To safely use the Diffie-Hellman key exchange, Alice and Bob must use
an <cite>authenticated</cite> exchange. Some of the information sent by Alice or Bob
must be signed with a public key known by the other user. In practice,
it is often important for Alice to authenticate Bob. If Bob has a
certificate signed by Ted, the authenticated key exchange could
be organized as follows.</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice chooses a secret integer : <span class="math notranslate nohighlight">\(a\)</span> and sends
<span class="math notranslate nohighlight">\(A= g^{a} \mod p\)</span> to Bob</p></li>
<li><p>Bob chooses a secret integer : <span class="math notranslate nohighlight">\(b\)</span>, computes
<span class="math notranslate nohighlight">\(B= g^{b} \mod p\)</span> and sends
<span class="math notranslate nohighlight">\(Cert(Bob,Bob_{pub},Ted), E_p(Bob_{priv},B)\)</span> to Alice</p></li>
<li><p>Alice checks the signature (with <span class="math notranslate nohighlight">\(Bob_{pub}\)</span>)
and the certificate and computes <span class="math notranslate nohighlight">\(S_{A}=B^{a} \mod p\)</span></p></li>
<li><p>Bob computes <span class="math notranslate nohighlight">\(S_{B}=A^{b} \mod p\)</span></p></li>
</ul>
</div></blockquote>
<p>This prevents the attack mentioned above since Mallory cannot create a
fake certificate and cannot sign a value by using Bob’s private key. Given
the risk of man-in-the-middle attacks, the Diffie-Hellman key exchange
mechanism should never be used without authentication.</p>
</section>
<section id="the-secure-shell-ssh">
<span id="index-19"/><h2>The secure shell (ssh)<a class="headerlink" href="#the-secure-shell-ssh" title="Link to this heading">#</a></h2>
<p id="index-20"><span id="remote-login"/>One of the initial motivations for building computer networks was
to allow users to access remote computers over the networks. In the 1960s
and 1970s, the mainframes and the emerging minicomputers were composed
of a central unit and a set of terminals connected through serial
lines or modems. The simplest protocol that was designed to access
remote computers over a network is probably <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc854.html"><strong>RFC 854</strong></a>.
<a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> runs over TCP and a telnet server listens on port <cite>23</cite> by
default. The TCP connection used by telnet is bidirectional, both the client
and the server can send data over it. The data exchanged over such a
connection is essentially the characters that are typed by the user on the
client machine and the text output of the processes running on the server
machine with a few exceptions (e.g. control characters, characters to control
the terminal like VT-100, …) . The default character set for
telnet is the ASCII character set, but the extensions specified
in <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5198.html"><strong>RFC 5198</strong></a> support the utilization
of Unicode characters.</p>
<p>From a security viewpoint, the main drawback of <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> is that all
the information, including the usernames, passwords and commands,
is sent in cleartext over a TCP connection. This implies that
an eavesdropper could easily capture the passwords used by anyone
on an unprotected network. Various software tools exist to
automate this collection of information. For this reason,
<a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> is rarely used today to access remote computers.
It is usually replaced by <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> or similar protocols.</p>
<p>The secure shell protocol was designed in the mid 1990s by T. Ylonen
to counter the eavesdropping attacks against <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> and
similar protocols <a class="reference internal" href="../bibliography.html#ylonen1996" id="id12"><span>[Ylonen1996]</span></a>. <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> became quickly popular and system
administrators encouraged its usage. The original version of <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a>
was freely available. After a few years, his author created a company
to distribute it commercially, but other programmers continued to
develop an open-source version of <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> called
<a class="reference external" href="http://www.openssh.com">OpenSSH</a>.
Over the years, <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> evolved
and became a flexible applicable whose usage extends beyond remote
login to support features such as file transfers, protocol tunneling, …
In this section, we only discuss the basic features of <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> and explain
how it differs from <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a>. Entire books have been written to describe
<a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> in details <a class="reference internal" href="../bibliography.html#bs2005" id="id13"><span>[BS2005]</span></a>. An overview of the protocol
appeared in <a class="reference internal" href="../bibliography.html#stallings2009" id="id14"><span>[Stallings2009]</span></a>.</p>
<p>The <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> protocol runs directly above the TCP protocol.
Once the TCP bytestream
has been established, the client and the server exchange messages. The
first message exchanged is an ASCII line that announces the version of the
protocol and the version of the software implementation used by the client
and the server. These two lines are useful when debugging interoperability
problems and other issues.</p>
<p>The next message is the <code class="docutils literal notranslate"><span class="pre">SSH_MSG_KEX_INIT</span></code> message that is used
to negotiate the cryptographic algorithms that will be used for the
<code class="docutils literal notranslate"><span class="pre">ssh</span></code> session. It is very important for security protocols to
include mechanisms that enable a negotiation of the cryptographic
algorithms that are used. First, these
algorithms provide different levels of security. Some algorithms might
be considered totally secure and are recommended today while they could
become deprecated a few years later after the publication of some
attacks. Second, these algorithms provide different levels of
performance and have different CPU and memory impacts.</p>
<p>In practice, an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> implementation supports four types of
cryptographic algorithms :</p>
<blockquote>
<div><ul class="simple">
<li><p>key exchange</p></li>
<li><p>encryption</p></li>
<li><p>Message Authentication Code (MAC)</p></li>
<li><p>compression</p></li>
</ul>
</div></blockquote>
<p>The <a class="reference external" href="https://www.iana.org">IANA</a> maintains a <a class="reference external" href="http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml#ssh-parameters-16">list of the cryptographic algorithms</a>
that can be used by <code class="docutils literal notranslate"><span class="pre">ssh</span></code> implementations. For each type of algorithm,
the client provides an ordered list of the algorithms that it supports
and agrees to use. The server compares the received list with its own list.
The outcome of the negotiation is a set of four algorithms <a class="footnote-reference brackets" href="#fnull" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>
that will be combined for this session.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/6c5012af9e2d96b7ddb2c31a55acbaec.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;SSH-clientP-clientS comments&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;SSH-serverP-serverS comments&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;SSH_MSG_KEX_INIT&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;SSH_MSG_KEX_INIT&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#6ae6d4bce6070be0fd3cb65a88d797c93f775d1d" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6ae6d4bce6070be0fd3cb65a88d797c93f775d1d.png"/>
<map id="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d" name="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"/></p>
</div></blockquote>
<p>This negotiation of the cryptographic algorithms allows the implementations
to evolve when new algorithms are proposed. If a client is upgraded, it can
announce a new algorithm as its preferred one even if the server is not
yet upgraded.</p>
<p>Once the cryptographic algorithms have been negotiated, the key exchange algorithm is
used to negotiate a secret key that will be shared by the client and the server.
These key exchange algorithms include some variations over
the basic algorithms. As an example, let us analyze how the
Diffie-Hellman key exchange algorithm is used within the
<code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol. In this case, each host has both a private and a public key.  (Note that
<span class="math notranslate nohighlight">\(g\)</span> is a generator for the subgroup of the Galois field of order <span class="math notranslate nohighlight">\(p\)</span>, where
<span class="math notranslate nohighlight">\(p\)</span> is a prime number, and || is the concatenation operator.  For additional background
information, see <a class="reference internal" href="../bibliography.html#schneier1996" id="id16"><span>[Schneier1996]</span></a>.)</p>
<blockquote>
<div><ul class="simple">
<li><p>the client generates the random number <span class="math notranslate nohighlight">\(a\)</span> and sends
<span class="math notranslate nohighlight">\(A=g^{a} \mod p\)</span> to the server</p></li>
<li><p>the server generates the random number <span class="math notranslate nohighlight">\(b\)</span>. It then computes
<span class="math notranslate nohighlight">\(B=g^{b} \mod p\)</span>, <span class="math notranslate nohighlight">\(K=B^{a} \mod p\)</span> and signs with its private
key <span class="math notranslate nohighlight">\(hash(V_{Client} || V_{Server} || KEX\_INIT_{Client} || KEX\_INIT_{Server} || Server_{pub} || A || B || K )\)</span>
where <span class="math notranslate nohighlight">\(V_{Server}\)</span> (resp. <span class="math notranslate nohighlight">\(V_{Client}\)</span>) is the initial
messages sent by the client (resp. server), <span class="math notranslate nohighlight">\(KEX\_INIT_{Client}\)</span>
(resp.  <span class="math notranslate nohighlight">\(KEX\_INIT_{Server}\)</span>) is the key exchange message sent by
the client (resp. server) and <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(K\)</span> are the
messages of the Diffie-Hellman key exchange</p></li>
<li><p>the client can recompute <span class="math notranslate nohighlight">\(K=A^{b} \mod p\)</span> and verify the
signature provided by the server</p></li>
</ul>
</div></blockquote>
<p>This is a slightly modified authenticated Diffie-Hellman key exchange
with two interesting points. The first point is that
when the server authenticates the key exchange it does not provide a
certificate. This is because <code class="docutils literal notranslate"><span class="pre">ssh</span></code> assumes that the client will store
inside its cache the public key of the servers that it uses on a
regular basis. This assumption is valid for a protocol like <code class="docutils literal notranslate"><span class="pre">ssh</span></code>
because users typically use it to interact with a small number of
servers, typically a few or a few tens. Storing this information does
not require a lot of storage. In practice, most <code class="docutils literal notranslate"><span class="pre">ssh</span></code> clients will
accept to connect to remote servers without knowing their public key before
the connection. In this case, the client issues a warning to the user who
can decide to accept or reject the key. This warning can be associated
with a fingerprint of the key, either as a sequence of letters or as
an ASCII art which can be posted on the web or elsewhere <a class="footnote-reference brackets" href="#fdnsssh" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> by the
system administrator of the server. If a client connects to a server
whose public key does not match the stored one, a stronger warning is
issued because this could indicate a man-in-the-middle attack or that
the remote server has been compromised. It can also indicate that the server
has been upgraded and that a new key has been generated during this upgrade.</p>
<p id="index-23">The second point is that the server authenticates not only the result
of the Diffie-Hellman exchange but also a hash of all the information
sent and received during the exchange. This is important to prevent
<cite>downgrade attacks</cite>. A <cite>downgrade attack</cite> is an attack where an
active attacker modifies the messages sent by the communicating hosts
(typically the client) to request the utilization of weaker encryption
algorithms. Consider a client that supports two encryption schemes. The
preferred one uses 128 bits secret keys and the second one is an old
encryption scheme that uses 48 bits keys. This second algorithm is
kept for backward compatibility with older implementations. If an attacker
can remove the preferred algorithm from the list of encryption algorithms
supported by the client, he can force the server to use a weaker
encryption scheme that will be easier to break. Thanks
to the hash that covers all the messages exchanged by the server,
the downgrade attack cannot occur against <code class="docutils literal notranslate"><span class="pre">ssh</span></code>. Algorithm agility is
a key requirement for security protocols that need to evolve when
encryption algorithms are broken by researchers. This agility cannot be
used without care and signing a hash of all the messages exchanged
is a technique that is frequently used to prevent downgrade attacks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Single use keys</p>
<p>Thanks to the Diffie-Hellman key exchange, the client and the
servers share key <span class="math notranslate nohighlight">\(K\)</span>. A naive implementation would probably
directly use this key for all the cryptographic algorithms that
have been negotiated for this session. Like most security protocols,
<code class="docutils literal notranslate"><span class="pre">ssh</span></code> does not directly use key <span class="math notranslate nohighlight">\(K\)</span>. Instead, it uses
the negotiated hash function with different parameters <a class="footnote-reference brackets" href="#fsshkeys" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>
to allow the
client and the servers to compute six keys from <span class="math notranslate nohighlight">\(K\)</span> :</p>
<blockquote>
<div><ul class="simple">
<li><p>a key used by the client (resp. server) to encrypt the data that
it sends</p></li>
<li><p>a key used by the client (resp. server) to authenticate the
data that it sends</p></li>
<li><p>a key used by the client (resp. server) to initialize the
negotiated encryption scheme (if required by this scheme)</p></li>
</ul>
</div></blockquote>
<p>It is common practice among designers of security protocols to never
use the same key for different purposes. For example, allowing the
client and the server to use the same key to encrypt data could
enable an attacker to launch a replay attack by sending to the
client data that it has itself encrypted.</p>
</div>
<p>At this point, all the messages sent over the TCP connection will be encrypted
with the negotiated keys. The <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol uses messages
that are encoded according to the Binary Packet Protocol defined in
<span class="target" id="index-24"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4253.html"><strong>RFC 4253</strong></a>. Each of these messages contains the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> : this is the length of the message in bytes, excluding the MAC
and length fields</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span> <span class="pre">length</span></code> : this is the number of random bytes that have been added
at the end of the message.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">payload</span></code> : the data (after optional compression) passed by the user</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span></code> : random bytes added in each message (at least four) to
ensure that the message length is a multiple of the block size
used by the negotiated encryption algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAC</span></code> : this field is present if a Message Authentication Code has been
negotiated for the session (in practice, using <code class="docutils literal notranslate"><span class="pre">ssh</span></code> without
authentication is risky and this field should always be present). Note
that to compute the MAC, an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> implementation must maintain
a message counter. This counter is incremented by one every time a
message is sent and the MAC is computed with the negotiated authentication
algorithm using the MAC key over the concatenation of
the message counter and the cleartext message.
The message counter is not transmitted,
but the recipient can easily recover its value. The <code class="docutils literal notranslate"><span class="pre">MAC</span></code> is computed as
<span class="math notranslate nohighlight">\(mac = MAC(key, sequence\_number || unencrypted\_message)\)</span> where the
key is the negotiated authentication key.</p></li>
</ul>
</div></blockquote>
<div class="admonition note" id="index-25">
<p class="admonition-title">Note</p>
<p>Authenticating messages with HMAC</p>
<p><cite>ssh</cite> is one example of a protocol that uses Message Authentication Codes
(MAC) to authenticates the messages that are sent. A naive implementation
of such a MAC would be to simply use a hash function like SHA-1. However,
such a construction would not be safe from a security viewpoint. Internet
protocols usually rely on the HMAC construction defined in <span class="target" id="index-26"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a>.
It works with any hash function (<cite>H</cite>) and a key (<cite>K</cite>). As an example, let
us consider HMAC with the SHA-1 hash function. SHA-1 uses 20 bytes
blocks and the block size will play an important role in the operation
of HMAC. We first require the key to be as long as the block size. Since this
key is the output of the key generation algorithm, this is one parameter
of this algorithm.</p>
<p>HMAC uses two padding strings : <cite>ipad</cite> (resp. <cite>opad</cite>)  which is a
string containing 20 times byte <code class="docutils literal notranslate"><span class="pre">0x36</span></code> (resp. byte <code class="docutils literal notranslate"><span class="pre">0x5C</span></code>). The HMAC
is then computed as <span class="math notranslate nohighlight">\(H[K \oplus opad, H(K \oplus ipad, data) ]\)</span>
where <span class="math notranslate nohighlight">\(\oplus\)</span> denotes the bitwise XOR operation. This computation
has been shown to be stronger than the naive <span class="math notranslate nohighlight">\(H(K,data)\)</span> against
some types of cryptographic attacks.</p>
</div>
<p>Among the various features of the <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol, it is interesting
to mention how users are authenticated by the server. The <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol
supports the classical username/password authentication (but both
the username and the password are transmitted over the secure encrypted
channel). In addition, <code class="docutils literal notranslate"><span class="pre">ssh</span></code> supports two authentication mechanisms that
rely on public keys. To use the first one, each user needs to generate
his/her own public/private key pair and store the public key on the server.
To be authenticated, the user needs to sign a message containing his/her
public key by using his/her private key. The server can easily verify the
validity of the signature since it already knows the user’s public key.
The second authentication scheme is designed for hosts that trust each
other. Each host has a public/private key pair and stores the public keys
of the other hosts that it trusts. This is typically used in environments
such as university labs where each user could access any of the available
computers. If Alice has logged on <code class="docutils literal notranslate"><span class="pre">computer1</span></code> and wants to execute a
command on <code class="docutils literal notranslate"><span class="pre">computer2</span></code>, she can create an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> session on this computer
and type (again) her password. With the host-based authentication scheme,
<code class="docutils literal notranslate"><span class="pre">computer1</span></code> signs a message with its private key to confirm that
it has already authenticated Alice. <code class="docutils literal notranslate"><span class="pre">computer2</span></code> would then accept
Alice’s session without asking for her credentials.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol includes other features that are beyond the
scope of this book. Additional details may be found in <a class="reference internal" href="../bibliography.html#bs2005" id="id19"><span>[BS2005]</span></a>.</p>
</section>
<section id="transport-layer-security">
<span id="tls"/><h2>Transport Layer Security<a class="headerlink" href="#transport-layer-security" title="Link to this heading">#</a></h2>
<p id="index-27">The Transport Layer Security family of protocols were initially
proposed under the name Secure Socket Layer (SSL). The first deployments
used this name and many researchers still refer to this security
protocol as SSL <a class="reference internal" href="../bibliography.html#fkc1996" id="id20"><span>[FKC1996]</span></a>. In this chapter, we use the official name that was
standardized by the IETF: TLS for <cite>Transport Layer Security</cite>.</p>
<p>The TLS protocol was designed to be usable by a wide range of applications
that use the transport layer to reliably exchange information. TLS is mainly
used over the TCP protocol. There are variants of TLS that operate
over SCTP <span class="target" id="index-28"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3436.html"><strong>RFC 3436</strong></a> or UDP <span class="target" id="index-29"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6347.html"><strong>RFC 6347</strong></a>,
but these are outside the scope of  this chapter.</p>
<p>A TLS session operates over a TCP connection. TLS is responsible for the
encryption and the authentication of the SDUs exchanged by the application
layer protocol while TCP provides the reliable delivery of this encrypted
and authenticated bytestream. TLS is used by many different
application layer protocols. The most frequent ones are HTTP (HTTP over TLS
is called HTTPS), SMTP <span class="target" id="index-30"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3207.html"><strong>RFC 3207</strong></a> or POP and IMAP <span class="target" id="index-31"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2595.html"><strong>RFC 2595</strong></a>, but proprietary application-layer protocols also use TLS <a class="reference internal" href="../bibliography.html#am2019" id="id21"><span>[AM2019]</span></a>.</p>
<p>A TLS session can be initiated in two different ways. First, the application
can use a dedicated TCP port number for application layer protocol x-over-TLS.
This is the solution used by many HTTP servers that reserve port <span class="math notranslate nohighlight">\(443\)</span>
for HTTP over TLS. This solution works, but it requires to reserve two ports
for each application : one where the application-layer protocol is used
directly over TCP and another one where the application-layer protocol
is used over TLS. Given the limited number of TCP ports that are available,
this is not a scalable solution. The table below provides some of
the reserved port numbers for application layer protocols on top of TLS.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Application</p></th>
<th class="head"><p>TCP port</p></th>
<th class="head"><p>TLS port</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>POP3</p></td>
<td><p>110</p></td>
<td><p>995</p></td>
</tr>
<tr class="row-odd"><td><p>IMAP</p></td>
<td><p>143</p></td>
<td><p>993</p></td>
</tr>
<tr class="row-even"><td><p>NNTP</p></td>
<td><p>119</p></td>
<td><p>563</p></td>
</tr>
<tr class="row-odd"><td><p>HTTP</p></td>
<td><p>80</p></td>
<td><p>443</p></td>
</tr>
<tr class="row-even"><td><p>FTP</p></td>
<td><p>21</p></td>
<td><p>990</p></td>
</tr>
</tbody>
</table>
</div>
<p>A second approach to initiate a TLS session is to use the standard
TCP port number for the application layer protocol and define a special
message in this protocol to trigger the start of the
TLS session. This is the solution used for SMTP with the <code class="docutils literal notranslate"><span class="pre">STARTTLS</span></code> message.
This extension to SMTP <span class="target" id="index-32"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3207.html"><strong>RFC 3207</strong></a> defines the new STARTTLS command.
The client can issue this command to indicate to the server that
it wants to start a TLS session as shown in the example below
captured during a session on port 25.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">220 server.example.org ESMTP</span>
<span class="go">EHLO client.example.net</span>
<span class="go">250-server.example.org</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-SIZE 250000000</span>
<span class="go">250-ETRN</span>
<span class="go">250-STARTTLS</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-8BITMIME</span>
<span class="go">250 DSN</span>
<span class="go">STARTTLS</span>
<span class="go">220 2.0.0 Ready to start TLS</span>
</pre></div>
</div>
<p>In the remaining parts of this chapter, we assume that the TLS session
starts immediately after the establishment of the TCP connection. This
corresponds to the deployments on web servers. We focus our presentation
of TLS on this very popular use case. TLS is a complex protocol that
supports other features than the one used by web servers. A more detailed
presentation of TLS may be found in <a class="reference internal" href="../bibliography.html#kps2002" id="id22"><span>[KPS2002]</span></a> and <a class="reference internal" href="../bibliography.html#ristic2015" id="id23"><span>[Ristic2015]</span></a>.</p>
<p>A TLS session is divided in two phases: the handshake and the data transfer.
During the handshake, the client
and the server negotiate the security parameters and the keys that will
be used to secure the data transfer. During the second phase, all the messages
exchanged are encrypted and authenticated with the negotiated algorithms
and keys.</p>
<section id="the-tls-handshake">
<h3>The TLS handshake<a class="headerlink" href="#the-tls-handshake" title="Link to this heading">#</a></h3>
<p>When used to interact with a regular web server, the TLS handshake has
three important objectives:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Securely negotiate the cryptographic algorithms that will be used by the
client and the server over the TLS session</p></li>
<li><p>Verify that the client interacts with a valid server</p></li>
<li><p>Securely agree on the keys that will be used to encrypt and authenticate
the messages exchanged over the TLS session</p></li>
</ol>
</div></blockquote>
<p>The TLS handshake is a four-way handshake illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/300581e55a5559d21fa138b6759650ca.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random], Certificate&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Finished=MAC(MasterSecret||Handshake)&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, linecolour=&quot;red&quot;, textcolour=&quot;red&quot;];&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, linecolour=&quot;red&quot;, textcolour=&quot;red&quot;];&#10;}" usemap="#6851383dfd7cb6f84e42dde9992fdd9303de35d3" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6851383dfd7cb6f84e42dde9992fdd9303de35d3.png"/>
<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3" name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"/></p>
</div></blockquote>
<p>In a nutshell, the client starts the TLS handshake by proposing a random nonce. The server replies with its random nonce and a certificate that binds its name to a public key. The client generates a MasterSecret that will be used later to derive the session keys and encrypts it with the public key of the server. It also generates a <cite>Finished</cite> message that contains a MAC of all the messages exchanged to allow the server to detect any modification of the messages sent by the client. The server also sends its own <cite>Finished</cite> message. At that point, the client and the server sent encrypted records thanks to the keys derived from the MasterSecret.</p>
<p id="index-33">Let us first discuss the negotiation of the cryptographic algorithms and
parameters. Like all security protocols, TLS includes some agility in its
design since new cryptographic algorithms appear over the years and
some older algorithms become deprecated once cryptanalysts find flaws.
The TLS handshakes starts with the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message
that is sent by the client. This message carries the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Protocol version number</cite>: this is the version of the TLS protocol supported
by the client. The server should use the same version of the TLS protocol as
the client, but may opt for an older version. Both versions 1.2 and 1.3 of TLS are deployed today. Older versions are being deprecated.</p></li>
<li><p><cite>Random number</cite>: security protocols rely on random numbers. The client
sends a 32 bytes long random number where usually four of these bytes
correspond
to the client’s clock. This random number is used, together with the
server’s random number, as a seed to generate the security keys.</p></li>
<li><p><cite>Cipher suites</cite> : this ordered list contains the set of cryptographic
algorithms that are supported by the client, with the most preferred one
listed first. In contrast with <code class="docutils literal notranslate"><span class="pre">ssh</span></code> that allows negotiating independent
algorithms for encryption, key exchange and authentication, TLS relies on
suites that combine these algorithms together. Many cryptographic suites
have been defined for TLS. Various recommendations
have been published on the security of some of these suites <span class="target" id="index-34"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525</strong></a>.</p></li>
<li><p><cite>Compression algorithm</cite> : the client may propose the utilization of a
specific compression algorithm (e.g. zlib). In theory, compressing the data
before encrypting it is an intelligent way to reduce the amount of data
exchanged. Unfortunately, its implementation in TLS has caused several security problems <a class="reference internal" href="../bibliography.html#phg2013" id="id24"><span>[PHG2013]</span></a>. For
this reason, compression is usually disabled in TLS <span class="target" id="index-35"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525</strong></a>.</p></li>
<li><p><cite>Extensions</cite> : TLS supports various extensions in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>
message. These extensions <span class="target" id="index-36"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a> are important to allow the protocol
to evolve, but many of them go beyond the scope of this chapter.</p></li>
</ul>
</div></blockquote>
<div class="admonition note" id="index-37">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Server</span> <span class="pre">Name</span> <span class="pre">Indication</span> <span class="pre">(SNI)</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Server</span> <span class="pre">Name</span> <span class="pre">Indication</span> <span class="pre">(SNI)</span></code> extension defined in <span class="target" id="index-38"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a>
is an important TLS extension for web servers.
It is used by the client to indicate the name of the server
that it wishes to contact. The IP address associated to this name
has been queried from the DNS and used to establish the TCP connection.
Why should the client indicate the server name in the TLS
<code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> ?  The motivation is the same as for the <code class="docutils literal notranslate"><span class="pre">Host</span></code>
header line in HTTP/1.0. With the SNI extension, a single TLS server
can support several web sites that use different domain names. Thanks
to the SNI extension, the server knows the concerned domain name at
the start of the TLS session. Without this extension, hosting providers
would have been forced use one IP address per TLS-enabled server.</p>
</div>
<p id="index-39">The server replies to the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> with several messages:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code> message that contains the protocol version chosen by
the server (assumed to be the same as the client version in this chapter),
the 32 random bytes chosen by the server, the <cite>Cipher Suite</cite> selected by
the server from the list advertised by the client
and a <cite>Session Id</cite>. This <cite>Session Id</cite> is an identifier which
is chosen by the server. It identifies the TLS session and the
security parameters (algorithms and keys) negotiated for this session.
It is used to support session resumption.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">Certificate</span></code> message provides the certificate (or usually a chain of
certificates) that binds a domain name to the public key used by
the server. TLS uses the server certificates
to authenticate the server. It relies on a Public Key Infrastructure that
is composed of a set of root certification authorities that
issue certificates to certification authorities that in the end
issue certificates to servers. TLS clients are usually configured with
the public keys of several root certification authorities and use
this information to validate the certificates that they receive from
servers. For historical reasons, the TLS certificates are encoded
in ASN.1 format. The details of the ASN.1 syntax <a class="reference internal" href="../bibliography.html#dubuisson2000" id="id25"><span>[Dubuisson2000]</span></a>
are outside the scope of this book.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message is used by the server to transmit the
information that is required to perform the key exchange. The content
of this message is function of the selected key exchange algorithm.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerHelloDone</span></code> indicates that the server has sent all the messages
for the first phase of the handshake.</p></li>
</ul>
</div></blockquote>
<p id="index-40">At this point, it is time to describe the TLS key exchange. TLS supports
different key exchange mechanisms that can be negotiated as part of the
selection of the cipher suite. We focus on two of them to highlight
their differences:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSA</span></code>. This key exchange algorithm uses the encryption capabilities of
the RSA public-key algorithm. The client has validated the server’s
public key thanks to the <code class="docutils literal notranslate"><span class="pre">Certificate</span></code> message. It then generates
a (48 bytes) random number, encrypts it with the server public key
and sends the encrypted number to the server in the <code class="docutils literal notranslate"><span class="pre">ClientKeyExchange</span></code>
message. The server uses its private key to decrypt the random
number. At this point, the client and the server share the same
(48 bytes long) secret and use it to derive the secret keys required
to encrypt and authenticate data in the second phase. With this
key exchange algorithm, the server does not need to send a
<code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>. This key exchange algorithm is the Ephemeral Diffie Hellman
key exchange with RSA signatures to authenticate the key exchange. It
operates as a classical authenticated Diffie Hellman key exchange.
If this key exchange
has been selected by the server, it sends its Diffie Hellman parameters
in the <code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message and signs them with its private
key. The client then continues the key exchange and sends the results of
its own computation in the <code class="docutils literal notranslate"><span class="pre">ClientKeyExchange</span></code> message. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>
is thus an authenticated Diffie Hellman key exchange where the initial
message is sent by the server (instead of the client as in our first example
but since the protocol is symmetric, this does not matter).</p></li>
</ul>
</div></blockquote>
<p id="index-41">An important difference between <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> and <code class="docutils literal notranslate"><span class="pre">RSA</span></code> is their reaction
against attacks. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> is considered by many to be stronger than <code class="docutils literal notranslate"><span class="pre">RSA</span></code>
because it supports <cite>Perfect Forward Secrecy</cite>. This property is important
against attackers that are able to eavesdrop all the (encrypted) data
sent and received by a server. Consider that Terrence is such an attacker
that has stored all the packets exchanged by Bob’s server during the last
six months. If he manages, by any means, to obtain Bob’s private key, he
will be able to decrypt all the keys used to secure the TLS sessions with
Bob’s server during this period. With <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>, a similar attack is
less devastating. If Terrence knows Bob’s private key, he will be able to launch
a man-in-the-middle attack against future TLS sessions with Bob’s server.
However, he will not be able to recover the keys used for all the past
sessions that he captured.</p>
<div class="admonition note" id="index-42">
<p class="admonition-title">Note</p>
<p>Perfect Forward Secrecy</p>
<p>Perfect Forward Secrecy (PFS) is an important property for key
exchange protocols. A protocol provides PFS if its design guarantees that
the keys used for former sessions will not be compromised even if the
private key of the server is compromised. This is a very important
property. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> provides Perfect Forward Secrecy, but the
<code class="docutils literal notranslate"><span class="pre">RSA</span></code> key exchange does not provide this property. In practice,
<code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> is costly from a computational viewpoint. Recent implementations
of TLS thus prefer  <code class="docutils literal notranslate"><span class="pre">ECDHE_RSA</span></code> or <code class="docutils literal notranslate"><span class="pre">ECDHE_ECDSA</span></code> when
Perfect Forward Secrecy is required.</p>
</div>
<p>All the information required for the key exchange has now been transmitted.
There are two important messages that will be sent by the client and the server
to conclude the handshake and start the data transfer phase.</p>
<p>The client sends the <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message followed by the <code class="docutils literal notranslate"><span class="pre">Finished</span></code>
message. The <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message indicates that the client has received
all the information required to generate the security keys for this TLS
session. This messages can also appear later in the session to indicate a
change in the encryption algorithms that are used, but this usage is outside
the scope of this book. The <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message is more important. It confirms
to the server that the TLS handshake has been performed correctly and that no
attacker has been able to modify the data sent by the client or the server.
This is the first message that is encrypted with the selected security keys.
It contains a hash of all the messages that were exchanged during the handshake.</p>
<p>The server also sends a <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message followed by a <code class="docutils literal notranslate"><span class="pre">Finished</span></code>
message.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TLS Cipher suites</p>
<p>A TLS cipher suite is usually represented as an ASCII string
that starts with TLS and contains the acronym of the key exchange algorithm,
the encryption scheme with the key size and its mode of operation and
the authentication algorithm. For example,
<code class="docutils literal notranslate"><span class="pre">TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</span></code> is a TLS cipher suite that uses
the <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> key exchange algorithm with 128 bits AES in GCM mode for
encryption and SHA-256 for authentication. The official list of TLS
cipher suites is maintained by IANA <a class="footnote-reference brackets" href="#fianatls" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>. The NULL acronym
indicates that no algorithm has been specified. For example,
<code class="docutils literal notranslate"><span class="pre">TLS_ECDH_RSA_WITH_NULL_SHA</span></code> is a cipher suite that does not use
any encryption but still uses the <code class="docutils literal notranslate"><span class="pre">ECDH_RSA</span></code> key exchange and
<code class="docutils literal notranslate"><span class="pre">SHA</span></code> for authentication.</p>
</div>
</section>
<section id="the-tls-record-protocol">
<h3>The TLS record protocol<a class="headerlink" href="#the-tls-record-protocol" title="Link to this heading">#</a></h3>
<p>The handshake is now finished. The client and the server will exchange
authenticated and encrypted records. TLS defines different formats for the
records depending on the cryptographic algorithms that have been negotiated
for the session. A detailed discussion of these different types of
records is outside the scope of this introduction. For illustration, we
briefly describe one record format.</p>
<p>As other security protocols, TLS uses different keys to encrypt and
authenticate records. These keys are derived from the MasterSecret that
is either randomly generated by the client after the <code class="docutils literal notranslate"><span class="pre">RSA</span></code> key exchange
or derived from the Diffie Hellman parameters after the <code class="docutils literal notranslate"><span class="pre">DH_RSA</span></code>
key exchange. The exact algorithm used to derive the keys is defined
in <span class="target" id="index-43"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a>.</p>
<p>A TLS record is always composed of four different fields :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>Type</cite> that indicates the type of record. The most frequent type
is <cite>application data</cite> which corresponds to a record containing encrypted
data. The other types are <cite>handshake</cite>, <cite>change_cipher_spec</cite> and
<cite>alert</cite>.</p></li>
<li><p>a <cite>Protocol Version</cite> field that indicates the version of the TLS protocol
used. This version is composed of two sub fields : a major and a
minor version number.</p></li>
<li><p>a <cite>Length</cite> field. A TLS record cannot be longer than 16,384 bytes.</p></li>
<li><p>a <cite>TLSPlainText</cite> that contains the encrypted data</p></li>
</ul>
</div></blockquote>
<p>TLS supports several methods to encrypted records. The selected
method depends on the cryptographic algorithms that have been negotiated for
the TLS session. A detailed presentation of the different methods that can
be used to produce the <cite>TLSPlainText</cite> from the user data is outside the scope
of this book. As an example, we study one method: Stream Encryption. This
method is used with cryptographic algorithms which can operate on a stream
of bytes. The method starts with a sequence of bytes provided by the
user application: the plain text. The first step is to compute the
authentication code to verify the integrity of the data. For this, TLS
computes <span class="math notranslate nohighlight">\(MAC(SeqNum, Header, PlainText)\)</span> using HMAC
where <cite>SeqNum</cite> is a sequence
number which is incremented by one for each new TLS record transmitted. The
<cite>Header</cite> is the header of the TLS record described above and <cite>PlainText</cite> is
the information that needs to be encrypted. Note that the sequence number
is maintained at the two endpoints of the TLS session, but it is not transmitted
inside the TLS record. This sequence number is used to prevent replay attacks.</p>
<div class="admonition note" id="index-44">
<p class="admonition-title">Note</p>
<p>MAC-then-encrypt or Encrypt-then-MAC</p>
<p>When secure protocols use Message Authentication and Encryption, they
need to specify how these two algorithms are combined. A first
solution, which is used by the current version of TLS, is to compute
the authentication code and then encrypt both the data and the
authentication code. A drawback of this approach is that the receiver
of an encrypted TLS record must first attempt to decrypt data that
has potentially been modified by an attacker before being able
to verify the authenticity of the record. A better approach is
for the sender to first encrypt the data and then compute the
authentication code over the encrypted data. This is the encrypt-then-MAC
approach proposed in <span class="target" id="index-45"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7366.html"><strong>RFC 7366</strong></a>. With encrypt-then-MAC, the receiver
first checks the authentication code before attempting to decrypt the
record.</p>
</div>
</section>
<section id="improving-tls">
<h3>Improving TLS<a class="headerlink" href="#improving-tls" title="Link to this heading">#</a></h3>
<p>During the last two decades, the deployment of TLS has continued to grow. The early TLS servers were only used for critical services such as e-commerce websites or online banks. As CPU performance improved, it became much more cost-effective to use TLS to secure non-critical parts of web servers, including the delivery of HTML pages and even video services. There is now a growing number of applications that rely on TLS <a class="reference internal" href="../bibliography.html#am2019" id="id27"><span>[AM2019]</span></a>.</p>
<p>In 2013, the statistics collected by the Firefox Telemetry project <a class="footnote-reference brackets" href="#ftelemetry" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> revealed that 30% of the web pages loaded by Firefox users were done over HTTPS. In October 2019, 80% of the web pages are loaded over HTTPS. In six years, HTTPS became the dominant protocol to access web services. Another look at the deployment of HTTPS on web sites may be found in <a class="reference internal" href="../bibliography.html#helme2019" id="id29"><span>[Helme2019]</span></a>.</p>
<p>Measurement studies that analyzed the evolution of TLS over the years have identified several important changes in the TLS ecosystem <a class="reference internal" href="../bibliography.html#kra2018" id="id30"><span>[KRA2018]</span></a>. First, the preferred cryptographic algorithms have changed. While RC4 was used by 60% of the connections in 2012, its usage has dropped since 2015. AES started to be deployed in 2013 and is now used for more than 90% of the connections. The deployed versions of TLS have also changed. TLS 1.0 and TLS 1.1 are now rarely used. The deployment of TLS 1.2 started in 2013 and reached 70% of the connections in 2015. Version 1.3 of TLS, that is described below, is also widely deployed.</p>
<p>Another interesting fact is the key exchange schemes. In 2012, RSA was the dominant solution, used by more than 80% of the observed connections <a class="reference internal" href="../bibliography.html#kra2018" id="id31"><span>[KRA2018]</span></a>. In 2013, Edward Snowden revealed the surveillance activities of several governments. These revelations had a huge impact on the Internet community. The IETF, which standardizes Internet protocols, considered in <span class="target" id="index-46"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7258.html"><strong>RFC 7258</strong></a> that such pervasive monitoring was an attack. Since then, several IETF working groups have developed solutions to counter pervasive monitoring. One of these solutions is to encourage <cite>Perfect Forward Security</cite>. Within TLS, this implies replacing RSA by an authenticated Diffie Hellman key exchange such as ECDHE. Measurements indicate
that since summer 2014, ECDHE is more popular than RSA. In 2018, more than 90% of the observed TLS connections used ECDHE.</p>
<p>The last point is the difficulty of deploying TLS servers <a class="reference internal" href="../bibliography.html#kms2017" id="id32"><span>[KMS2017]</span></a>. When TLS servers are installed, the system administrator needs to obtain certificates and configure a range of servers. Initially, getting certificates was complex and costly, but initiatives such as <a class="reference external" href="https://letsencrypt.org">https://letsencrypt.org</a> have simplified this workflow.</p>
<p>In 2014, the IETF TLS working started to work on the development of version 1.3 of the TLS protocol. Their main objectives <a class="reference internal" href="../bibliography.html#rescorla2015" id="id33"><span>[Rescorla2015]</span></a> for this new version were:</p>
<blockquote>
<div><ul class="simple">
<li><p>simplify the design by removing unused or unsafe protocol features</p></li>
<li><p>improve the security of TLS by leveraging the lessons learned from TLS 1.2 and some documented attacks</p></li>
<li><p>improve the privacy of the protocol</p></li>
<li><p>reduce the latency of TLS</p></li>
</ul>
</div></blockquote>
<p>Since 2014, latency has become an important concern for web services. As access networks bandwidth continue to grow, latency is becoming a key factor that affects the performance of interactive web services. With TLS 1.2, the download of a web page requires a minimum of four round-trip-times, one to create the underlying TCP connection, one to exchange the ClientHello/ServerHello, one to exchange the keys and then one to send the HTTP GET and retrieve the response. This can be very long when the server is not near the client. TLS 1.3 aimed at reducing this handshake to one round-trip-time and even zero by placing some of the cryptographic handshake in the TCP handshake. This part will be discussed in the TCP chapter. We focus here on the reducing the TLS handshake to a single round-trip-time.</p>
<p>To simplify both the design and the implementations, TLS 1.3 uses only a small number of cipher suites. Five of them are specified in <span class="target" id="index-47"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a> and <code class="docutils literal notranslate"><span class="pre">TLS_AES_128_GCM_SHA256</span></code> must be supported by all implementations. To ensure privacy, all cipher suites that did not provide Perfect Forward Secrecy have been removed. Compression has also been removed from TLS since several attacks on TLS 1.2 exploited its compression capability <span class="target" id="index-48"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7457.html"><strong>RFC 7457</strong></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enterprises, privacy and TLS</p>
<p>By supporting only cipher suites that provide Perfect Forward Secrecy in TLS 1.3, the IETF aims at protecting the privacy of users against a wide range of attacks. However, this choice has resulted in intense debates in some enterprises. Some enterprises, notably in financial organizations, have deployed TLS, but wish to be able to decrypt TLS traffic for various security-related activities. These enterprises tried to lobby within the IETF to maintain RSA-based cipher suites that do not provide Perfect Forward Secrecy. Their arguments did not convince the IETF. Eventually, these enterprises moved to ETSI, another standardization body, and convinced them to adopt <cite>entreprise TLS</cite>, a variant of TLS 1.3 that does not provide Perfect Forward Secrecy <a class="reference internal" href="../bibliography.html#etls2018" id="id34"><span>[eTLS2018]</span></a>.</p>
</div>
<p>The TLS 1.3 handshake differs from the TLS 1.2 handshake in several ways. First, the TLS 1.3 handshake requires a single round-trip-time when the client connects for the first time to a server. To achieve this, the TLS designers look at the TLS 1.2 handshake in details and found that the first round-trip-time is mainly used to select the set of cryptographic algorithms and the cryptographic exchange scheme that will be used over the TLS session. TLS 1.3 drastically simplifies this negotiation by requiring to use the Diffie Hellman exchange with a small set of possible parameters. This means that the client can guess the parameters used by the server (i.e. the modulus, p and the base g) and immediately start the Diffie Hellman exchange. A simplified version of the TLS 1.3 handshake is shown in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/e5ae4c8c184c7b414c018f2972f772de.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#7c40afa8b5d3bc7ec147430dbd78098f688a7eb0" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-7c40afa8b5d3bc7ec147430dbd78098f688a7eb0.png"/>
<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0" name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"/></p>
</div></blockquote>
<p>There are several important differences with the TLS 1.2 handshake. First, the Diffie Hellman key exchange is required in TLS 1.3 and this exchange is initiated by the client (before having validated the server identity). To initiate the Diffie Hellman key exchange, the client needs to guess the modulus and the base that can be accepted by the server. Either the client uses standard parameters that most server supports or the client remembers the last modulus/base that it used with this particular server. If the client guessed incorrectly, the server replies with the parameters that it expects and one round-trip-time is lost. When the server sends its <cite>ServerHello</cite>, it already knows the session key. This implies that the server can encrypt all subsequent messages. After one round-trip-time, all data exchanged over the TLS 1.3 session is encrypted and authenticated. In TLS 1.3, the server certificate is encrypted with the session key, as well as the <cite>Finished</cite> message. The server signs the handshake to confirm that it owns the public key of its certificate. If the server wants to send application data, it can already encrypt it and send it to the client. Upon reception of the server Certificate, the client verifies it and checks the signature of the handshake and the <cite>Finished</cite> message. The client confirms the end of the handshake by sending its own <cite>Finished</cite> message. At that time, the client can send encrypted data. This means that the client only had to wait one round-trip-time before sending encrypted data. This is much faster than with TLS 1.2.</p>
<p>For some applications, waiting one round-trip-time before being able to send data is too long. TLS 1.3 allows the client to send encrypted data immediately after the <cite>ClientHello</cite>, without having to wait for the <cite>ServerHello</cite> message. At this point in the handshake, the client cannot know the key that will be derived by the Diffie Hellman key exchange. The trick is that the server and the client need to have previously agreed on a <cite>pre-shared-key</cite>. This key could be negotiated out of band, but usually it was exchanged over a previous TLS session between the client and the server. Both the client and the server can store this key in their cache. When the client creates a new TLS session to a server, it checks whether it already knows a pre-shared key for this server. If so, the client announces the identifier of this key in its <cite>ClientHello</cite> message. Thanks to this identifier, the server can recover the key and use it to decrypt the 0-rtt Encrypted record. A simplified version of the 0-rtt TLS 1.3 handshake <a class="footnote-reference brackets" href="#fhandshake" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> is shown in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/37315cb85580d2a0a41ccf2aa6b695ae.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c,server_conf=abcd]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;0-rtt Encrypted record&quot;, textcolour=&quot;magenta&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#04ec071344c2fae0632e2d690c2782c9017b631e" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-04ec071344c2fae0632e2d690c2782c9017b631e.png"/>
<map id="04ec071344c2fae0632e2d690c2782c9017b631e" name="04ec071344c2fae0632e2d690c2782c9017b631e"/></p>
</div></blockquote>
<p>On the web, TLS clients use certificates to authenticate servers but the clients are not authenticated. However, there are environments such as enterprise networks where servers may need to authenticate clients as well. A popular deployment is to authenticate remote clients who wish to access the enterprise network through a Virtual Private Network service. Some of these services run above TLS (or more precisely a variant of TLS named DTLS that runs above UDP <a class="reference internal" href="../bibliography.html#mor2004" id="id36"><span>[MoR2004]</span></a> but is outside the scope of this chapter). In such services, each client is authenticated thanks to a public key and a certificate that is trusted by the servers. To establish a TLS session, such a client needs to prove that it owns the public key associated with the certificate. This is done by the server thanks to the CertificateRequest message. The TLS handshake becomes the following one:</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/6b610706117d1538fe4793f16be928b1.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c,server_conf=abcd]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;0-rtt Encrypted record&quot;, textcolour=&quot;magenta&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;CertificateRequest, Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Certificate, Sign(Kc, Handshake), Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#36d37bda46d72f2f438e0e029b02b9c54e69fa82" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-36d37bda46d72f2f438e0e029b02b9c54e69fa82.png"/>
<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82" name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"/></p>
</div></blockquote>
<p>The server sends a CertificatRequest message. The client returns its certificate and signs the Handshake with is private key. This confirms to the server that the client owns the public key indicated in its certificate.</p>
<p>There are many more differences between TLS 1.2 and TLS 1.3. Additional details may be found in their respective specifications, <span class="target" id="index-49"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a> and <span class="target" id="index-50"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>.</p>
</section>
</section>
<section id="securing-the-domain-name-system">
<span id="dnssec"/><h2>Securing the Domain Name System<a class="headerlink" href="#securing-the-domain-name-system" title="Link to this heading">#</a></h2>
<p>The Domain Name System provides a critical service in the Internet
infrastructure since it maps the domain names that are used by end users
onto IP addresses. Since end users rely on names to identify the servers
that they connect to, any incorrect information distributed by the DNS
would direct end users’ connections to invalid destinations. Unfortunately,
several attacks of this kind occurred in the past. A detailed analysis
of the security threats against the DNS appeared in <span class="target" id="index-51"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3833.html"><strong>RFC 3833</strong></a>. We consider
three of these threats in this section and leave the others to <span class="target" id="index-52"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3833.html"><strong>RFC 3833</strong></a>.</p>
<p>The first type of attack is <cite>eavesdropping</cite>. An attacker who can capture
packets sent to a DNS resolver or a DNS server can gain valuable information
about the DNS names that are used by a given end user. If the attacker can
capture all the packets sent to a DNS resolver, he/she can collect a lot of
meta data about the domain names used by the end user. Preventing this type
of attack has not been an objective of the initial design of the DNS.
There are currently discussions with the IETF to carry DNS messages over
TLS sessions to protect against such attacks. However, these solutions
are not yet widely deployed.</p>
<p>The second type of attack is the <cite>man-in-the-middle</cite> attack. Consider that
Alice is sending DNS requests to her DNS resolver. Unfortunately, Mallory
sits in front of this resolver and can capture and modify all the packets
sent by Alice to her resolver. In this case, Mallory can easily modify
the DNS responses sent by the resolver to redirect Alice’s packets to
a different IP address controlled by Mallory. This enables Mallory
to observe (and possibly modify) all the packets sent and received by
Alice. In practice, executing this attack is not simple since DNS resolvers
are usually installed in protected datacenters. However, if Mallory controls
the WiFi access point that Alice uses to access the Internet, he could easily
modify the packets on this access point and some software packages
automate this type of attacks.</p>
<p>If Mallory cannot control a router on the path
between Alice and her resolver, she could still launch a different attack.
To understand this attack, it is important to correctly understand how
the DNS protocol operates and the roles of the different fields of
the DNS header which is reproduced in <a class="reference internal" href="#fig-dns-header2"><span class="std std-numref">Fig. 46</span></a>.</p>
<figure class="align-center" id="id39">
<span id="fig-dns-header2"/><a class="reference internal image-reference" href="../_images/dnsheader.svg"><img alt="../_images/dnsheader.svg" src="../Images/21a7bad41190434264bf8afe39a2de6a.png" style="width: 445.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/dnsheader.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 46 </span><span class="caption-text">DNS header</span><a class="headerlink" href="#id39" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The first field of the header is the <cite>Identification</cite> field. When Alice
sends a DNS request, she places a 16-bits integer in this field and
remembers it. When she receives a response, she uses this <cite>Identification</cite>
field to locate the initial DNS request that she sent. The response is
only used if its <cite>Identification</cite> matches a pending DNS request (containing
the same question).</p>
<p id="index-53">Mallory has studied the DNS protocol and understands how it works. If he
can predict a popular domain for which Alice will regularly send DNS requests,
then he can prepare a set of DNS responses that map the name requested
by Alice to an IP address controlled by Mallory instead of the legitimate
DNS response. Each DNS response has a different <cite>Identification</cite>. Since there
are only 65,536 values for the <cite>Identification</cite> field, it is possible
for Mallory to
send them to Alice hoping that one of them will be received while Alice
is waiting for a DNS response with the same identifier. In the past,
it was difficult to send 65,536 DNS responses quickly enough. However, with
the high speed links that are available today, this is not an issue anymore.
A second concern for Mallory is that he must be able to send
the DNS responses as if they were coming directly from the DNS resolver.
This implies that Mallory must be able to send IP packets that appear to
originate from a different address. Although networks should be configured
to prevent this type of attack, this is not always the case and there
are networks where it is possible for a host to send packets with a
different source IP address <a class="footnote-reference brackets" href="#fspoof" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. If the attack targets a single
end user, e.g. Alice, this is annoying for this user. However, if the
attacker can target a DNS resolver that serves an entire company or an
entire ISP, the impact of the attack can be much larger in particular if
the injected DNS response carries a long TTL and thus resides in the
resolver’s cache for a long period of time.</p>
<p>Fortunately, designers of DNS servers and resolvers have found solutions to mitigate this type
of attack. The easiest approach would have been to update the format of the
DNS requests and responses to include a larger <cite>Identifier</cite> field.
Unfortunately, this elegant solution was not possible with the DNS because
the DNS messages do not include any version number that would have enabled
such a change. Since the DNS messages are exchanged inside UDP segments,
the DNS developers found an alternate solution to counter this attack.
There are two ways for the DNS library used by Alice to send her DNS requests.
A first solution is to bind one UDP source port and always send the
DNS requests from this source port (the destination port is always port
<code class="docutils literal notranslate"><span class="pre">53</span></code>). The advantage of this solution is that Alice’s DNS library can
easily receive the DNS responses by listening to her chosen port.
Unfortunately, once the attacker has found the source port used by Alice,
he only needs to send 65,536 DNS responses to inject an invalid response.
Fortunately, Alice can send her DNS requests in a different way. Instead
of using the same source port for all DNS requests, she can use a different
source port for each request. In practice, each DNS request will be sent
from a different source port. From an implementation viewpoint, this
implies that Alice’s DNS library will need to listen to one different port
number for each pending DNS request. This increases the complexity of
her implementation. From a security viewpoint there is a clear benefit
since the attacker needs to guess both the 16 bits <cite>Identifier</cite> and the
16 bits <cite>UDP source port</cite> to inject a fake DNS response. To generate all
possible DNS responses, the attacker would need to generate almost
<span class="math notranslate nohighlight">\(2^{32}\)</span> different messages, which is excessive in today’s networks.
Most DNS implementations use this second approach to prevent these cache
poisoning attacks.</p>
<p>These attacks affect the DNS messages that are exchanged between a client
and its resolver or between a resolver and name servers. Another type of
attack exploits the possibility of providing several resource records inside
one DNS response. A frequent optimization used by DNS servers and resolvers
is to include several related resource records in each response. For
example, if a client sends a DNS query for an <cite>NS</cite> record, it usually
receives in the response both the queried record, i.e. the name of
the DNS server that serves the queried domain, and the IP addresses of this
server. Some DNS servers return several <cite>NS</cite> records and the associated IP
addresses. The <cite>cache poisoning</cite> attack exploits this DNS optimization.</p>
<p>Let us illustrate it on an example.
Assume that Alice frequently uses the <cite>example.net</cite> domain and in
particular the
web server whose name is <cite>www.example.net</cite>. Mallory would like to redirect
the TCP connections established by Alice towards <cite>www.example.net</cite> to one
IP address that he controls. Assume that Mallory controls the
<cite>mallory.net</cite> domain. Mallory can tune the DNS server of his domain and add
special DNS records to the responses that it sends. An attack could go
roughly as follows. Mallory forces Alice to visit the <cite>www.mallory.net</cite> web
site. He can achieve this by sending a spam message to Alice or buying
advertisements on a web site visited by Alice and redirect one of these
advertisements to <cite>www.mallory.net</cite>. When visiting the advertisement, Alice’s
DNS resolver will send a DNS request for <cite>www.mallory.net</cite>. Since Mallory
control the DNS server, he can easily add in the response a <cite>AAAA</cite>
record that associates <cite>www.example.net</cite> to the IP address controlled by
Mallory. If Alice’s DNS library does not check the returned response,
the cache entry for <cite>www.example.net</cite> will be replaced by the <cite>AAAA</cite> record
sent by Mallory.</p>
<p>To cope with these security threats and improve the security of the
DNS, the IETF has defined several extensions that are known as DNSSEC.
DNSSEC exploits public-key cryptography to authenticate the content
of the DNS records that are sent by DNS servers and resolvers. DNSEC is
defined in three main documents <span class="target" id="index-54"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4033.html"><strong>RFC 4033</strong></a>, <span class="target" id="index-55"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4034.html"><strong>RFC 4034</strong></a>, <span class="target" id="index-56"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4035.html"><strong>RFC 4035</strong></a>.
With DNSSEC, each DNS zone uses one public-private key pair. This key pair
is only used to sign and authenticate DNS records. The DNS records are
not encrypted and DNSSEC does not provide any confidentiality. Other DNS
extensions are being developed to ensure the confidentiality of the
information exchanged between a client and its resolvers <span class="target" id="index-57"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7626.html"><strong>RFC 7626</strong></a>.
Some of these extensions exchange DNS records over a TLS session which
provides the required confidentiality, but they are not yet deployed
and outside the scope of this chapter.</p>
<p>DNSSEC defines four new types of DNS records that are used together to
authenticate the information distributed by the DNS.</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>DNSKEY</cite> record allows storing the public key associated with
a zone. This record is encoded as a TLV and includes a <cite>Base64</cite>
representation of the key and the identification of the public key
algorithm. This allows the <cite>DNSKEY</cite> record to support different public
key algorithms.</p></li>
<li><p>the <cite>RRSIG</cite> record is used to encode the signature of a DNS record. This
record contains several sub-fields. The most important ones are the
algorithm used to generate the signature, the identifier of the public
key used to sign the record, the original TTL of the signed record and
the validity period for the signature.</p></li>
<li><p>the <cite>DS</cite> record contains a hash of a public key. It is used by a parent
zone to certify the public key used by one of its child zones.</p></li>
<li><p>the <cite>NSEC</cite> record is used when non-existent domain names are queried.
Its usage will be explained later</p></li>
</ul>
</div></blockquote>
<p>The simplest way to understand the operation of DNSSEC is to rely on a simple
example. Let us consider the <cite>example.org</cite> domain and assume that Alice
wants to retrieve the <cite>AAAA</cite> record for <cite>www.example.org</cite> using DNSSEC.</p>
<p id="index-58">The security of DNSSEC relies on <cite>anchored keys</cite>. An <cite>anchored key</cite> is a
public key that is considered as trusted by a resolver. In our example,
we assume that Alice’s resolver has obtained the public key of the servers
that manage the root zone in a secure way. This key
has been distributed outside of the DNS, e.g. it has been published in a
newspaper or has been received in a sealed letter.</p>
<p>To obtain an authenticated record for <cite>www.example.org</cite>, Alice’s resolver
first needs to retrieve the <cite>NS</cite> which is responsible for the <cite>.org</cite>
Top-Level Domain (TLD). This record is served by the DNS root server
and Alice’s resolver can retrieve the signature (<cite>RRSIG</cite> record) for this
<cite>NS</cite> record. Since Alice knows the <cite>DNSKEY</cite> of the root, she can verify
the validity of this signature.</p>
<p>The next step is to contact <cite>ns.org</cite>, the <cite>NS</cite> responsible for
the <cite>.org</cite> TLD to retrieve the <cite>NS</cite> record for the <cite>example.org</cite> domain.
This record is accompanied by a <cite>RRSIG</cite> record that authenticates it. This
<cite>RRSIG</cite> record is signed with the key of the <cite>.org</cite> domain. Alice’s resolver
can retrieve this public key as the <cite>DNSKEY</cite> record for the <cite>.org</cite>, but how
can it trust this key since it is distributed by using the DNS and
could have been modified by attackers ? DNSSEC solves this problem by
using the <cite>DS</cite> record that is stored in the parent zone (in this case,
the root zone). This record contains a hash of a public key that
is signed with a <cite>RRSIG</cite> signature. Since Alice’s resolver’s
trusts the root key, it can validate the signature of the <cite>DS</cite> record
for the <cite>.org</cite> domain. It can then retrieve the <cite>DNSKEY</cite> record for this
domain from the DNS and compare the hash of this key with the <cite>DS</cite> record.
If they match, the public key of the <cite>.org</cite> domain can be trusted.
The same technique is used to obtain and validate the key of
the <cite>example.org</cite> domain. Once this key is trusted, Alice’s resolver
can request the <cite>AAAA</cite> record for <cite>www.example.org</cite> and validate its
signature.</p>
<p>Thanks to the <cite>DS</cite> record, a resolver can validate the public keys of client
zones as long as their is a chain of <cite>DS</cite> -&gt; <cite>DNSKEY</cite> records from an
anchored key. If the resolver trusts the public key of the root zone, it
can validate all DNS replies for which this chain exists.</p>
<p>There are several details of the operation of DNSSEC that are worth
being discussed. First, a server that supports DNSSEC must have a
public-private key pair. The public key is distributed with the
<cite>DNSKEY</cite> record. The private key is never distributed and it does not
even need to be stored on the server that uses the public key. DNSSEC does
not require the DNSSEC servers to perform any operation that requires
a private key in real time. All the <cite>RRSIG</cite> records can be computed
offline, possibly on a different server than the server that returns
the DNSSEC replies. The initial motivation for this design choice was
the CPU complexity of computing the <cite>RRSIG</cite> signatures for zones that
contain millions of records. In the early days of DNSSEC, this was an
operational constraint. Today, this is less an issue, but avoiding
costly signature operations in real time has two important benefits.
First, this reduces the risk of denial of service attacks since an attacker
cannot force a DNSSEC server to perform computationally intensive signing
operations. Second, the private key can be stored offline, which means that
even if an attacker gains access to the DNSSEC server, it cannot retrieve
its private key. Using offline signatures for the <cite>RRSIG</cite> records has some
practical implications that are reflected in the content of this
record. First, each <cite>RRSIG</cite> record contains the original TTL of the
signed record.
When DNS resolvers cache records, they change the value of the TTL of
these cached records and then return the modified records to their clients.
When a resolver receives a signed DNS record, it must replace the
received TTL of the record with the original TTL (and check that the
received TTL is smaller than the original one) before checking the
signature. Second, the <cite>RRSIG</cite> records contain a validity period, i.e.
a starting time and an ending time for the validity of the signature. This
period is specified as two timestamps. This period is only the
validity of the signature. It does not affect the TTL of the signed record
and is independent from the TTL. In practice, the validity period is
important to allow DNS server operators to update their public/private
keys. When such a key is changed, e.g. because the private could have been
compromised, there is some period of time during which records signed
with the two keys coexist in the network. The validity period allows
ensuring that old signatures do not remain in DNS caches for ever.</p>
<p id="index-59">The last record introduced by DNSSEC is the <cite>NSEC</cite> record. It is used to
authenticate a negative response returned by a DNS server. If a resolver
requests a domain name that is not defined in the zone, the server
replies with an error message. The designers of the original version
of the DNS thought that these errors would not be very frequent
and resolvers were not required to cache those negative responses.
However, operational experience showed that queries for invalid domain
names are more frequent than initially expected and a large fraction
of the load on some servers is caused by repeated queries for invalid
names. Typical examples include queries for invalid TLDs to the root
DNS servers or queries caused by configuration errors <a class="reference internal" href="../bibliography.html#wf2003" id="id38"><span>[WF2003]</span></a>.
Current DNS deployments allow resolvers to cache those negative answers
to reduce the load on the entire DNS <span class="target" id="index-60"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2308.html"><strong>RFC 2308</strong></a>.</p>
<p>The simplest way to allow a DNSSEC server to return signed negative responses
would be for the server to return a signed response that contains the
received query and some information indicating the error.
The client could then easily check the validity of the negative response.
Unfortunately, this would force the DNSSEC server to generate signatures
in real time. This implies that the private key must be stored in the
server memory, which leads to risks if an attacker can take control
of the server. Furthermore, those signatures are computationally complex
and a simple denial of service attack would be to send invalid queries
to a DNSSEC server.</p>
<p>Given the above security risks, DNSSEC opted for a different approach that
allows the negative replies to be authenticated by using offline signatures.
The <cite>NSEC</cite> record exploits the lexicographical ordering of all the domain
names. To understand its usage, consider a simple domain that contains
three names (the associated <cite>AAAA</cite> and other records that are not
shown) :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">alpha.example.org</span>
<span class="go">beta.example.org</span>
<span class="go">gamma.example.org</span>
</pre></div>
</div>
<p>In this domain, the DNSSEC server adds three <cite>NSEC</cite> records. A <cite>RRSIG</cite>
signature is also computed for each of these records.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">alpha.example.org</span>
<span class="go">alpha.example.org NSEC beta.example.org</span>

<span class="go">beta.example.org</span>
<span class="go">beta.example.org NSEC gamma.example.org</span>

<span class="go">gamma.example.org</span>
<span class="go">gamma.example.org NSEC alpha.example.org</span>
</pre></div>
</div>
<p>If a resolver queries <cite>delta.example.org</cite>, the server will parse its
zone. If this name were present, it would have been placed, in lexicographical
order, between the <cite>beta.example.org</cite> and the <cite>gamma.example.org</cite> names.
To confirm that the <cite>delta.example.org</cite> name does not exist, the server
returns the <cite>NSEC</cite> record for <cite>beta.example.org</cite> that indicates that the
next valid name after <cite>beta.example.org</cite> is <cite>gamma.example.org</cite>. If
the server receives a query for <cite>pi.example.org</cite>, this is the <cite>NSEC</cite> record
for <cite>gamma.example.org</cite> that will be returned. Since this record
contains a name that is before <cite>pi.example.org</cite> in lexicographical
order, this indicates that <cite>pi.example.org</cite> does not exist.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fpasswords" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The wikipedia page on passwords provides many of these references :
<a class="reference external" href="https://en.wikipedia.org/wiki/Password_strength">https://en.wikipedia.org/wiki/Password_strength</a></p>
</aside>
<aside class="footnote brackets" id="frsa" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">2</a><span class="fn-bracket">]</span></span>
<p>A detailed explanation of the operation of the RSA algorithm is
outside the scope of this e-book. Various tutorials such as the
<a class="reference external" href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA page</a>
on wikipedia provide examples and tutorial information.</p>
</aside>
<aside class="footnote brackets" id="fecc" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">3</a><span class="fn-bracket">]</span></span>
<p>A detailed explanation of the ECC cryptosystems is outside the
scope of this e-book. A simple introduction may be found on
<a class="reference external" href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Andrea Corbellini’s blog</a>. There have been deployments of ECC recently because
ECC schemes usually require shorter keys than RSA and consume less
CPU.</p>
</aside>
<aside class="footnote brackets" id="fnull" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">4</a><span class="fn-bracket">]</span></span>
<p>For some of the algorithms, it is possible to negotiate the
utilization of no algorithm. This happens frequently for the
compression algorithm that is not always used. For this,
both the client and the server must announce <code class="docutils literal notranslate"><span class="pre">null</span></code>
in their ordered list of supported algorithms.</p>
</aside>
<aside class="footnote brackets" id="fdnsssh" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">5</a><span class="fn-bracket">]</span></span>
<p>For example, <span class="target" id="index-61"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4255.html"><strong>RFC 4255</strong></a> describes a DNS record that can be
used to associate an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> fingerprint to a DNS name.</p>
</aside>
<aside class="footnote brackets" id="fsshkeys" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">6</a><span class="fn-bracket">]</span></span>
<p>The exact algorithms used for the computation of these
keys are defined in <span class="target" id="index-62"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4253.html"><strong>RFC 4253</strong></a></p>
</aside>
<aside class="footnote brackets" id="fianatls" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">7</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4</a></p>
</aside>
<aside class="footnote brackets" id="fhandshake" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id35">8</a><span class="fn-bracket">]</span></span>
<p>A detailed explanation of the TLS 1.3 handshake may be found at <a class="reference external" href="https://tls13.ulfheim.net/">https://tls13.ulfheim.net/</a></p>
</aside>
<aside class="footnote brackets" id="ftelemetry" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">9</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="https://letsencrypt.org/stats/">https://letsencrypt.org/stats/</a> for a graph and <a class="reference external" href="https://docs.telemetry.mozilla.org/datasets/other/ssl/reference.html">https://docs.telemetry.mozilla.org/datasets/other/ssl/reference.html</a> for additional information on the dataset</p>
</aside>
<aside class="footnote brackets" id="fspoof" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">10</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://spoofer.caida.org/summary.php">http://spoofer.caida.org/summary.php</a> for an ongoing measurement study that analyses the networks where an attacker could send packets with any source IP address.</p>
</aside>
</aside>
</section>
&#13;

<h2>Security threats<a class="headerlink" href="#security-threats" title="Link to this heading">#</a></h2>
<p>When analyzing security issues in computer networks, it is useful to
reason about the
capabilities of the attacker who wants to exploit some breach in the security
of the network. There are different types of attackers. Some
have generic capabilities, others are specific to a given technology or network
protocol. In this section, we discuss some important threats that a network architect must take into account.</p>
<p id="index-2">The first type of attacker is called the <cite>passive attacker</cite>.
A <cite>passive attacker</cite> is someone able to observe and usually store the information (e.g. the packets)
exchanged in a given network or subset of it (e.g. a specific link). This
attacker has access to all the data passing through this specific
link. This is the most basic type of attacker and many network technologies
are vulnerable to such attacks. In the above example, a passive
attacker could easily capture the password sent by Alice and reuse it later
to be authenticated as Alice on the remote computer. This is illustrated
in the figure below where we do not show anymore the <code class="docutils literal notranslate"><span class="pre">DATA.req</span></code> and
<code class="docutils literal notranslate"><span class="pre">DATA.ind</span></code> primitives but only the messages exchanged.
Throughout this chapter, we will always use <cite>Eve</cite> as a user who is
able to eavesdrop the data passing in front of her.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f4b5846cad3728586ed1ef7e20d24afb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Eve&quot;, linecolour=red],&#10;d [label=&quot;&quot;, linecolour=white],&#10;e [label=&quot;Bob&quot;, linecolour=black],&#10;f [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;e [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;e=&gt;f [ label = &quot;&quot; ];&#10;&#10;e=&gt;f [ label = &quot;&quot; ] ,&#10;e&gt;&gt;b [ label = &quot;Password:\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;e [ label = &quot;1234xyz$\n\n&quot;, arcskip=&quot;1&quot;];&#10;e=&gt;f [ label = &quot;&quot; ];&#10;&#10;e=&gt;f [ label = &quot;&quot; ] ,&#10;e&gt;&gt;b [ label = &quot;Access\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#17921862b047d560c7fe7db8be3c8ccaa1e34782" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-17921862b047d560c7fe7db8be3c8ccaa1e34782.png"/>
<map id="17921862b047d560c7fe7db8be3c8ccaa1e34782" name="17921862b047d560c7fe7db8be3c8ccaa1e34782"/></p>
</div></blockquote>
<p>In the above example, <cite>Eve</cite> can capture all the packets exchanged by
Bob and Alice. This implies that Eve can discover Alice’s username and
Alice’s password. With this information, Eve can then authenticate as
Alice on Bob’s computer and do whatever Alice is authorized to do. This
is a major problem from a security point of view. To prevent this attack,
Alice should never send her password in clear over a network where someone
could eavesdrop the information. In some networks, such as an open wireless
network, an attacker can easily collect all the data sent by a particular user. In other networks, this is a bit more complex depending on the network
technology used, but various software packages exist to automate this process.
As will be described later, the best approach to prevent this type of attack
is to rely on cryptographic techniques to ensure that passwords are never
sent in clear.</p>
<div class="admonition note" id="index-3">
<p class="admonition-title">Note</p>
<p>Pervasive monitoring</p>
<p>In the previous example, we have explained how Eve could capture data from
a particular user. This is not the only attack of this type. In 2013, based
on documents collected by Edward Snowden, the press revealed that several
governmental agencies were collecting lots of data on various links that
compose the global Internet <a class="reference internal" href="../bibliography.html#greenwald2014" id="id3"><span>[Greenwald2014]</span></a>. Thanks to this massive amount
of data, these
governmental agencies have been able to extract lots of information about
the behavior of Internet users. Like Eve, they are in a position to extract
passwords, usernames and other privacy sensitive data from all the packets
that they have captured. However, it seems that these agencies were often
more interested in various meta data, e.g. information showing with whom a
given user communicates than the actual data exchanged. These revelations
have shocked the Internet community and the <a class="reference external" href="https://www.ietf.org">Internet Engineering Task Force</a> that manages the standardization of Internet
protocols has declared in <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7258.html"><strong>RFC 7258</strong></a> that such pervasive monitoring is
an attack that need to be countered in the development of new protocols.
Several new protocols and extensions to existing ones
are being developed to counter these attacks.</p>
</div>
<p id="index-5">Eavesdropping and pervasive monitoring are not the only possible attacks against
a network. Another type of attacker is the active attacker. In the literature,
these attacks are often called <cite>Man in the middle</cite> or <cite>MITM</cite> attacks. Such attacks
occur when one user, let us call him <cite>Mallory</cite>, has managed to configure the
network so that he can both capture and modify the packets exchanged by two
users. The simplest scenario is when Mallory controls a router that is on the
path used by both Alice and Bob. For example, Alice could be connected to a WiFi
access router controlled by Mallory and Bob would be a regular server on the Internet.</p>
<div class="figure" style="text-align: center"><p><img src="../Images/c7ceeff3d8a02de071eac1377ed85bc7.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2da503f59e9d59459633c14a7ae833ad16530010.png"/></p>
</div><p>As Mallory receives all the packets sent by both Bob and Alice, he can modify
them at will. For example, he could modify the commands sent by Alice to the
server managed by Bob and change the responses sent by the server. This type of
attack is very powerful and sometimes difficult to counter without relying
on advanced cryptographic techniques.</p>
<p id="index-6">The last type of attack that we consider in this introduction are the <cite>Denial
of Service</cite> or DoS attacks.
During such an attack, the attacker generates enough packets to
saturate a given service and prevent it from operating correctly. The simplest
Denial of Service attack is to send more packets that the bandwidth of the
link that attaches the target to the network. The target could be a single
server, a company or even an entire country. If these packets all come from the
same source, then the victim can identify the attacker and contact the
law enforcement authorities. In practice, such denial of service attacks do
not originate from a single source. The attacker usually compromises a (possibly very large) set of sources and forces them to send packets to saturate a given target. Since the attacking traffic comes from a wide range of sources, it is difficult for the victim to locate the culprit and also to counter the attack. Saturating a link is the simplest example of <cite>Distributed Denial of Service (DDoS)</cite> attacks.</p>
<p>In practice, there is a possibility of denial of service attacks as soon as
there is a limited resource somewhere in the network.
This resource can be the bandwidth of a
link, but it could also be the computational power of a server, its memory or
even the size of tables used by a given protocol implementation. Defending
against real DoS attacks can be difficult, especially if the attacker
controls a large number of sources that are used to launch the attacks. In terms
of bandwidth, DoS attacks composed of a few Gbps to a few tens of
Gbps of traffic are frequent on the Internet. In 2015,
<a class="reference external" href="http://www.github.com">github.com</a> suffered from a distributed DoS that
reached a top bandwidth of 400 Gbps according to some
<a class="reference external" href="http://www.techworld.com/news/security/worlds-largest-ddos-attack-reached-400gbps-says-arbor-networks-3595715/">reports</a>.</p>
<p id="index-7">When designing network protocols and applications that will be deployed on a
large scale, it is important to take those DDoS attacks into account. Attackers
use different strategies to launch DDoS attacks. Some have managed to gain
control of a large number of sources by injecting malware on them. Others,
and this is where protocol designers have an important role to play, simply
exploit design flaws in some protocols. Consider a simple request-response
protocol where the client sends a request and the server replies with a
response. Often the response is larger or much larger than the request sent
by the client. Consider that such a simple protocol is used over a datagram
network. When Alice sends a datagram to Bob containing her request, Bob
extracts both the request and Alice’s address from the packet. He then sends
his response in a single packet destined to Alice. Mallory would like to create a
DoS attack against Alice without being identified. Since he has studied
the specification of this protocol, he can
send a request to Bob inside a packet having Alice’s address
as its source address. Bob will process the request and send his (large)
response to Alice. If the response has the same size as the request, Mallory
is producing a <cite>reflection attack</cite> since his packets are reflected by Bob. Alice
would think that she is attacked by Bob. If there are many servers that operate
the same service as Bob, Mallory could hide behind a large number of
such reflectors. Unfortunately, the reflection attack can also become an
amplification attack. This happens when the response sent by Bob is larger
than the request that it has received. If the response is <span class="math notranslate nohighlight">\(k\)</span> times larger than
the request, then when Mallory consumes 1 Gbps of bandwidth to send
requests, his victim receives <span class="math notranslate nohighlight">\(k\)</span> Gbps of attack traffic. Such amplification
attacks are a very important problem and protocol designers should ensure that
they never send a large response before having received the proof that the
request that they have received originated from the source indicated in
the request.</p>
&#13;

<h2>Cryptographic primitives<a class="headerlink" href="#cryptographic-primitives" title="Link to this heading">#</a></h2>
<p>Cryptography techniques have initially been defined and used by spies and armies
to exchange secret information in manner that ensures that adversaries cannot
decode the information even if they capture the message or the person carrying the
message. A wide range of techniques have been defined. The first techniques
relied on their secrecy to operate. One of the first encryption schemes is
attributed to Julius Caesar. When he sent confidential information to his
generals, he would encode each message by replacing each letter with another
letter that is <span class="math notranslate nohighlight">\(n\)</span> positions after this letter in the alphabet. For example,
the message <cite>SECRET</cite> becomes <cite>VHFUHW</cite> when encoded using Caesar’s cipher.
This technique could have puzzled some soldiers during Caesar’s wars, but today
even young kids can recover the original message from the ciphered one.</p>
<p id="index-8">The security of the Caesar cipher depends on the confidentiality of the
algorithm, but experience has shown that it is impossible to assume that
an algorithm will remain secret, even for military applications. Instead,
cryptographic techniques must be designed by assuming that the algorithm will
be public and known to anyone. However, its behavior must be controlled by a small
parameter, known as the key, that will only be known by the users who
need to communicate secretly. This principle is attributed to Auguste Kerckhoff,
a French cryptographer who first documented it :</p>
<blockquote>
<div><p><cite>A cryptographic algorithm should be secure even if the attacker knows
everything about the system, except one parameter known as the secret key.</cite></p>
</div></blockquote>
<p>This principle is important because it remains the basic assumption of all
cryptographers. Any system that relies on the secrecy of its algorithm
to be considered secure is doomed to fail and be broken one day.</p>
<p>With the Kerckhoff principle, we can now discuss a simple but powerful
encryption scheme that relies on the <cite>XOR</cite> logic operation. This operation is
easily implemented in hardware and is supported by all microprocessors. Given a
secret, <span class="math notranslate nohighlight">\(K\)</span>, it is possible to encode a message <cite>M</cite> by computing
<span class="math notranslate nohighlight">\(C_M = K \oplus M\)</span>. The receiver of this messages can recover the original
message as since <span class="math notranslate nohighlight">\(M = K \oplus (K \oplus M)\)</span>. This <cite>XOR</cite> operation is the
key operation of the perfect cipher that is also called the Vernam cipher or
the one-time pad. This cipher relies on a key that contains purely random
bits. The encrypted message is then produced by XORing all the bits of the
message with all the bits of the key. Since the key is random, it is impossible
for an attacker to recover the original text (or plain text) from the encrypted
one. From a security viewpoint, the one-time-pad is the best solution provided that
the key is as long as the message.</p>
<p>Unfortunately, it is difficult to use this cipher in practice since the key must be as
long as the message that needs to be transmitted. If the key is smaller than the
message and the message is divided into blocks that have the same length as
the key, then the scheme becomes less secure since the same key is used to
decrypt different parts of the message. In practice, <cite>XOR</cite> is often one of the
basic operations used by encryption schemes. To be usable, the deployed
encryption schemes use keys that are composed of a small number of bits, typically
56, 64, 128, 256, …</p>
<p>A secret key encryption scheme is a perfectly reversible
functions, i.e. given an encryption function <cite>E</cite>, there is an associated
decryption function <cite>D</cite> such that <span class="math notranslate nohighlight">\(\forall K, \forall M : D(K, E(K,M))=M\)</span>.</p>
<p id="index-9">Various secret key cryptographic functions have been proposed, implemented and
deployed. The most popular ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p>DES, the Data Encryption Standard that became a standard in 1977 and has
been widely used by industry. It uses 56 bits keys that are not considered
sufficiently secure nowadays since attackers can launch brute-force
attacks by testing all possible keys. Triple DES combines three 56 bits keys,
making the brute force attacks more difficult.</p></li>
<li><p>RC4 is an encryption scheme defined in the late 1980s by Ron Rivest for RSA
Security. Given the speed of its software implementation, it has been included in
various protocols and implementations. However, cryptographers have
identified several weaknesses in this algorithm. It is now deprecated
and should not be used anymore <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7465.html"><strong>RFC 7465</strong></a>.</p></li>
<li><p>AES or the Advanced Encryption Standard is an encryption scheme that was
designed by the Belgian cryptographers Joan Daemen and Vincent Rijmen
in 2001 <a class="reference internal" href="../bibliography.html#dr2002" id="id4"><span>[DR2002]</span></a>. This algorithm  has been standardized by the U.S.
National Institute
of Standards and Technology (NIST). It is now used by a wide range of
applications and various hardware and software implementations exist. Many
microprocessors include special instructions that ease the implementation
of AES. AES divides the message to be encrypted in blocks of 128 bits and
uses keys of length 128, 192 or 256 bits. The block size and the key length
are important parameters of an encryption scheme. The block size indicates
the smallest message that can be encrypted and forces the sender to divide
each message in blocks of the supported size. If the message is larger than
an integer number of blocks, then the message must be padded before being
encrypted and this padding must be removed after decryption. The key size
indicates the resistance of the encryption scheme against brute force
attacks, i.e. attacks where the attacker tries all possible keys to find
the correct one.</p></li>
</ul>
</div></blockquote>
<p>AES is widely used as of this writing, but other secret key encryption schemes
continue to appear. ChaCha20, proposed by D. Bernstein is now used by
several internet protocols <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7539.html"><strong>RFC 7539</strong></a>. A detailed discussion of encryption
schemes is outside the scope of this book. We will consider encryption schemes
as black boxes whose operation depends on a single key. A detailed overview
of several of these schemes may be found in <a class="reference internal" href="../bibliography.html#mvv2011" id="id5"><span>[MVV2011]</span></a>.</p>
<p id="index-12">In the 1970s, Diffie and Hellman proposed in their seminal paper <a class="reference internal" href="../bibliography.html#dh1976" id="id6"><span>[DH1976]</span></a>, a
different type of encryption : <cite>public key cryptography</cite>. In public key
cryptography, each user has two different keys :</p>
<blockquote>
<div><ul class="simple">
<li><p>a public key (<span class="math notranslate nohighlight">\(K_{pub}\)</span>) that he can distribute to everyone</p></li>
<li><p>a private key (<span class="math notranslate nohighlight">\(K_{priv}\)</span>) that he needs to store in a secure
manner and never reveal to anyone</p></li>
</ul>
</div></blockquote>
<p>These two keys are generated together and they are linked by a complex
mathematical relationship that is such that it is computationally difficult
to compute <span class="math notranslate nohighlight">\(K_{priv}\)</span> from <span class="math notranslate nohighlight">\(K_{pub}\)</span>.</p>
<p>A public key cryptographic scheme is a combination of two functions :</p>
<blockquote>
<div><ul class="simple">
<li><p>an encryption function, <span class="math notranslate nohighlight">\(E_{p}\)</span>, that takes a key and a message as parameters</p></li>
<li><p>a decryption function, <span class="math notranslate nohighlight">\(D_{p}\)</span>, that takes a key and a message as parameters</p></li>
</ul>
</div></blockquote>
<p>The public key is used to encrypt a message so that it can only be read by
the intended recipient. For example, let us consider two users : Alice and Bob.
Alice (resp. Bob) uses the keys <span class="math notranslate nohighlight">\(A_{priv}\)</span> and <span class="math notranslate nohighlight">\(A_{pub}\)</span> (resp.
<span class="math notranslate nohighlight">\(B_{priv}\)</span> and <span class="math notranslate nohighlight">\(B_{pub}\)</span>). To send a secure message <cite>M</cite> to Alice,
Bob computes <span class="math notranslate nohighlight">\(CM=E_p(A_{pub},M)\)</span> and Alice can decrypt it by using
<span class="math notranslate nohighlight">\(D_p(A_{priv},CM)=D_p(A_{priv},E_p(A_{pub},M))=M\)</span>.</p>
<p>Several public key encryption schemes have been proposed. Two of them have
reached wide deployment :</p>
<blockquote>
<div><ul class="simple">
<li><p>The Rivest Shamir Adleman (RSA) algorithm <a class="footnote-reference brackets" href="#frsa" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> proposed in
<a class="reference internal" href="../bibliography.html#rsa1978" id="id8"><span>[RSA1978]</span></a> that relies on modular exponentiation with large integers.</p></li>
<li><p>The Elliptic Curve Cryptography techniques <a class="footnote-reference brackets" href="#fecc" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> that rely on special
properties of elliptic curves.</p></li>
</ul>
</div></blockquote>
<p>Another interesting property of public key cryptography is its ability to
compute <cite>signatures</cite> that can be used to authenticate a message. This capability
comes from the utilization of two different keys that are linked together.
If Alice wants to sign a message <cite>M</cite>, she can compute
<span class="math notranslate nohighlight">\(SM=E_p(A_{priv},M)\)</span>. Anyone who receives this signed messaged can extract
its content as <span class="math notranslate nohighlight">\(D_p(A_{pub},SM)=D_p(A_{pub},E_p(A_{priv},M))=M\)</span>. Everyone
can use <span class="math notranslate nohighlight">\(A_{pub}\)</span> to check that the message was signed by using
Alice’s private key (<span class="math notranslate nohighlight">\(A_{priv}\)</span>). Since this key is only known
by Alice, the ability to decrypt <cite>SM</cite> is a proof that the message was signed
by Alice herself.</p>
<p>In practice, encrypting a message to sign it can be computationally costly,
in particular if the message is a large file. A faster solution would be
to summarize the document and only sign the summary of the document. A naive
approach could be based on a checksum or CRC computed over the message. Alice
would then compute <span class="math notranslate nohighlight">\(C=Checksum(M)\)</span> and <span class="math notranslate nohighlight">\(SC=E_p(A_{priv},C)\)</span>. She
would then send both <cite>M</cite> and <cite>SC</cite> to the recipient of the message who can
easily compute <cite>C</cite> from <cite>SC</cite> and verify the authenticity of the message. Unfortunately,
this solution does not protect Alice and the message’s recipient against
a man-in-the-middle attack. If Mallory can intercept the message sent by Alice,
he can easily modify Alice’s message and tweak it so that it has the same
checksum as the original one. The CRCs, although more complex to compute,
suffer from the same problem.</p>
<p>To efficiently sign messages, Alice needs to be able to compute a summary
of her message in a way that makes prohibits an attacker from generating a
different message that has the same summary. <cite>Cryptographic hash functions</cite>
were designed to solve this problem. The ideal hash function is a function
that returns a different number for every possible input. In practice, it
is impossible to find such a function. Cryptographic hash functions are an
approximation of this perfect summarization function. They
compute a summary of a given message in 128, 160, 256 bits or more. They also
exhibit the <cite>avalanche effect</cite>. This effect indicates that a small change in
the message causes a large change in the hash value. Finally hash functions
are very difficult to invert. Knowing a hash value, it is computationally very
difficult to find the corresponding input message. Several hash functions have
been proposed by cryptographers. The most popular ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p>MD5, originally proposed in <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1321.html"><strong>RFC 1321</strong></a>. It has been used in a wide range of
applications. In 2010, attacks against MD5 were published and this hash
function is now deprecated.</p></li>
<li><p>SHA-1 is a cryptographic hash function that was standardized by the
NIST in 1995. It outputs 160 bits results. It is now used in a variety
of network protocols.</p></li>
<li><p>SHA-2 is another family of cryptographic hash functions designed by the NIST.
Different variants of SHA-2 can produce has values of 224, 256, 384 or 512
bits.</p></li>
</ul>
</div></blockquote>
<p>Another important point about cryptographic algorithms is that often these
algorithms require random numbers to operate correctly (e.g. to generate
keys). Generating good random numbers is difficult and any implementation
of cryptographic algorithms should also include a secure random number
generator. <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4086.html"><strong>RFC 4086</strong></a> provides useful recommendations.</p>
&#13;

<h2>Cryptographic protocols<a class="headerlink" href="#cryptographic-protocols" title="Link to this heading">#</a></h2>
<p>We can now combine the cryptographic operations described in the previous section
to build some protocols to securely exchange
information. Let us first go back to the problem of authenticating
Alice on Bob’s computer. We have shown earlier that using
a simple password for this purpose is insecure in the presence of attackers.</p>
<p>A naive approach would be to rely on hash functions. Since hash functions
are non-invertible, Alice and Bob could decide to use them to exchange Alice’s
password in a secure manner. Then, Alice could be authenticated by using
the following exchange.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/8ce774d886954a61fe3332c085b81a4f.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Prove it\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Hash(passwd)\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Access granted\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#e9d4cd4a36e66a6415dde6e83ecc95535122af78" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-e9d4cd4a36e66a6415dde6e83ecc95535122af78.png"/>
<map id="e9d4cd4a36e66a6415dde6e83ecc95535122af78" name="e9d4cd4a36e66a6415dde6e83ecc95535122af78"/></p>
</div></blockquote>
<p id="index-15">Since the hash function cannot be inverted, an eavesdropper cannot extract
Alice’s password by simply observing the data exchanged. However, Alice’s
real password is not the objective of an attacker. The main objective for
Mallory is to be authenticated as Alice. If Mallory can capture
<cite>Hash(passwd)</cite>, he can simply replay this data, without being able to invert
the hash function. This is called a <cite>replay attack</cite>.</p>
<p>To counter this replay attack, we need to ensure that Alice never sends the
same information twice to Bob. A possible mode of operation is shown below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/d68b2f1363c49e52d5bce558f315b1ad.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:764192\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Hash(764192||passwd)\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Access\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#20f577439fc03098f4163306e3e3d06fd0e01a3f" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-20f577439fc03098f4163306e3e3d06fd0e01a3f.png"/>
<map id="20f577439fc03098f4163306e3e3d06fd0e01a3f" name="20f577439fc03098f4163306e3e3d06fd0e01a3f"/></p>
</div></blockquote>
<p id="index-16">To authenticate herself, Alice sends her user identifier to Bob. Bob replies with
a random number as a challenge to verify that Alice knows the shared secret
(i.e. her password). Alice replies with the result of the computation
of a hash function (e.g. SHA-1) over a string that is the concatenation
between the random number chosen by Bob and Alice’s password. The random
number chosen by Bob is often called a <cite>nonce</cite> since this is a number
that should only be used once. Bob performs the
same computation locally and can check the message returned by Alice.
This type of authentication scheme has been used in various protocols. It
prevents replay attacks. If Eve captures the messages exchanged by
Alice and Bob, she cannot recover Alice’s password from the messages exchanged
since hash functions are non-invertible. Furthermore, she cannot replay the
hashed value since Bob will always send a different nonce.</p>
<p>Unfortunately, this solution forces Bob to store Alice’s password in clear. Any
breach in the security of Bob’s computer would reveal Alice’s password. Such
breaches unfortunately occur and some of them have led to the dissemination of
millions of passwords.</p>
<p id="index-17">A better approach would be to authenticate Alice without storing her password
in clear on Bob’s computer. For this, Alice computes a <cite>hash chain</cite>
as proposed by Lamport in <a class="reference internal" href="../bibliography.html#lamport1981" id="id10"><span>[Lamport1981]</span></a>. A hash
chain is a sequence of applications of a hash function (<cite>H</cite>) on an input string. If
Alice’s password is <cite>P</cite>, then her 10 steps hash chain is :
<span class="math notranslate nohighlight">\(H(H(H(H(H(H(H(H(H(H(P))))))))))\)</span>. The result of this hash chain will
be stored on Bob’s computer together with the value <cite>10</cite>. This number is the
maximum number of remaining authentications for Alice on Bob’s computer.
To authenticate Alice, Bob sends the remaining number of authentications, i.e.
<cite>10</cite> in this example. Since Alice knows her password, <cite>P</cite>, she can compute
<span class="math notranslate nohighlight">\(H^9(P)=H(H(H(H(H(H(H(H(H(P)))))))))\)</span> and send this information to Bob.
Bob computes the hash of the value received from Alice (<span class="math notranslate nohighlight">\(H(H^9(P))\)</span>)
and verifies that this value is equal to the value stored in his database. It
then decrements the number of authorized authentications and stores
<span class="math notranslate nohighlight">\(H^9(P)\)</span> in his database. Bob is now ready for the next authentication
of Alice. When the number of authorized authentications reaches zero, the
hash chain needs to be reinitialized. If Eve captures <span class="math notranslate nohighlight">\((H^n(P))\)</span>, she
cannot use it to authenticate herself as Alice on Bob’s computer because
Bob will have decremented its number of authorized authentications. Furthermore,
given that hash functions are not invertible, Eve cannot compute
<span class="math notranslate nohighlight">\(H^{n-1}(P)\)</span> from <span class="math notranslate nohighlight">\(H^{n}(P)\)</span>.</p>
<p>The two protocols above prevent eavesdropping attacks, but not man-in-the-middle
attacks. If Mallory can intercept the messages sent by Alice, he could force
her to reveal <span class="math notranslate nohighlight">\(H^n(P)\)</span> and then use this information to authenticate
as Alice on Bob’s computer. In practice, hash chains should only be used when
the communicating users know that there cannot be any man-in-the-middle on
their communication.</p>
<p>Public key cryptography provides another possibility to allow Alice
to authenticate herself on Bob’s computer. Assume again that Alice and
Bob know each other from previous encounters. Alice knows Bob’s public key
(<span class="math notranslate nohighlight">\(Bob_{pub}\)</span>) and Bob also knows Alice’s key (<span class="math notranslate nohighlight">\(Alice_{pub}\)</span>). To
authenticate herself, Alice could send her user identifier. Bob would reply
with a random number encrypted with Alice’s public key :
<span class="math notranslate nohighlight">\(E_p(Alice_{pub},R)\)</span>. Alice can decrypt this message to recover <cite>R</cite>
and sends <span class="math notranslate nohighlight">\(E_p(Bob_{pub},R)\)</span>. Bob decrypts the nonce and confirms that
Alice knows <span class="math notranslate nohighlight">\(Alice_{priv}\)</span>. If an eavesdropper captures the
messages exchanged, he cannot recover the value <cite>R</cite> which could be used as
a key to encrypt the information with a secret key algorithm.
This is illustrated in the time sequence diagram below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f7eeac697813279f3277f20eb023de49.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;E_p(Alice_{pub},R)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Bob_{pub},R)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#6027ccdd0a4dba418aa8843c8ac153fd6a422bd7" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6027ccdd0a4dba418aa8843c8ac153fd6a422bd7.png"/>
<map id="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7" name="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"/></p>
</div></blockquote>
<p>A drawback of this approach is that Bob is forced to perform two
public key computations : one encryption to send the random nonce
to Alice and one decryption to recover the nonce encrypted by Alice.
If these computations are costly from a CPU viewpoint, this creates
a risk of Denial of Service Attacks were attackers could try to
access Bob’s computer and force it to perform such costly computations.
Bob is more at risk than Alice in this situation and he should not perform
complex operations before being sure that he is talking with Alice.
An alternative is shown in the time sequence diagram below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/5d0252030a1e74f0aa10edc4572b381d.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;R\n\n&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R)\n\n&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#26127d2d1ccdbf50c7d1c6d967ea621292da9631" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-26127d2d1ccdbf50c7d1c6d967ea621292da9631.png"/>
<map id="26127d2d1ccdbf50c7d1c6d967ea621292da9631" name="26127d2d1ccdbf50c7d1c6d967ea621292da9631"/></p>
</div></blockquote>
<p>Here, Bob simply sends a random nonce to Alice and verifies her signature.
Since the random nonce and the signature could be captured by an eavesdropper,
they cannot be used as a secret key to encrypt further data. However
Bob could propose a secret key and send it encrypted with Alice’s
public key in response to the signed nonce that he received.</p>
<p>The solution described above works provided that Bob and Alice know their
respective public keys before communicating. Otherwise, the protocol is not secure against
man-in-the-middle attackers. Consider Mallory sitting in the middle
between Alice and Bob and assume that neither Alice nor Bob knows
the other’s public key.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/0638f4c9db9fea46091250d1fe48d4c9.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;x [label=&quot;&quot;, linecolour=white],&#10;y [label=&quot;Mallory&quot;, textcolour=&quot;red&quot;, linecolour=red],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot; &quot; ] ,&#10;b&gt;&gt;y [ label = &quot;I'm Alice key=Alice_{pub}&quot;, arcskip=&quot;1&quot; ];&#10;y&gt;&gt;c [ label = &quot;I'm Alice key=Mallory_{pub}&quot;, textcolour=&quot;red&quot;, arcskip=&quot;1&quot; ];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;R&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;y [ label = &quot;E_p(Alice_{priv},R)&quot;, arcskip=&quot;1&quot;];&#10;y&gt;&gt;c [ label = &quot;E_p(Mallory_{priv},R)&quot;, textcolour=&quot;red&quot;,  arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Access&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#1ee9ab4ade7fb05cf8774418033d3c5fb2944924" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-1ee9ab4ade7fb05cf8774418033d3c5fb2944924.png"/>
<map id="1ee9ab4ade7fb05cf8774418033d3c5fb2944924" name="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"/></p>
</div></blockquote>
<p>In the above example, Alice sends her public key, (<span class="math notranslate nohighlight">\(Alice_{pub}\)</span>), in
her first message together with her identity. Mallory intercepts the message
and replaces Alice’s key with his own key, (<span class="math notranslate nohighlight">\(Mallory_{pub}\)</span>). Bob
replies with a nonce, <cite>R</cite>. Alice then signs the random
nonce to prove that she knows <span class="math notranslate nohighlight">\(Alice_{priv}\)</span>. Mallory discards the
information and instead computes <span class="math notranslate nohighlight">\(E_p(Mallory_{priv},R)\)</span>. Bob now
thinks that he is discussing with Alice while Mallory sits in the middle.</p>
<p>There are situations where symmetric authentication is required. In this case,
each user must perform some computation with his/her private key. A possible
exchange is the following. Alice sends her certificate to Bob. Bob replies with
a nonce, <span class="math notranslate nohighlight">\(R1\)</span>, and provides his certificate. Alice encrypts <span class="math notranslate nohighlight">\(R1\)</span> with
her private key and generates a nonce, <span class="math notranslate nohighlight">\(R2\)</span>. Bob verifies Alice’s computation
and encrypts <span class="math notranslate nohighlight">\(R2\)</span> with his private key. Alice verifies the computation and
both have been authenticated.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/682391126620ce67dffa1f33ee972f1b.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:R1&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R1),R2&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;E_p(Bob_{priv},R2)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#dc928c892b0c31362bbfde7cc4e2025e18374729" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-dc928c892b0c31362bbfde7cc4e2025e18374729.png"/>
<map id="dc928c892b0c31362bbfde7cc4e2025e18374729" name="dc928c892b0c31362bbfde7cc4e2025e18374729"/></p>
</div></blockquote>
<p>The protocol described above works, but it takes a long time for Bob to authenticate
Alice and for Alice to authenticate Bob. A faster authentication could be the following.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/d9c1e952550357ddf872d47493c46bd4.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice, R2&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:R1,E_p(Bob_{priv},R2)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R1)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#b006024cf4bbd5812ac6af177e9c613098b52e42" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b006024cf4bbd5812ac6af177e9c613098b52e42.png"/>
<map id="b006024cf4bbd5812ac6af177e9c613098b52e42" name="b006024cf4bbd5812ac6af177e9c613098b52e42"/></p>
</div></blockquote>
<p>Alice sends her random nonce, <span class="math notranslate nohighlight">\(R2\)</span>. Bob signs <span class="math notranslate nohighlight">\(R2\)</span> and sends his nonce :
<span class="math notranslate nohighlight">\(R1\)</span>. Alice signs <span class="math notranslate nohighlight">\(R1\)</span> and both are authenticated.</p>
<p>Now consider that Mallory wants to be authenticated as Alice. The above protocol
has a subtle flaw that could be exploited by Mallory. This flaw can be exploited if
Alice and Bob can act as both client and server. Knowing this, Mallory could operate
as follows. Mallory starts an authentication with Bob faking himself as Alice.
He sends a first message to Bob including Alice’s identity.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/0129748f31a23c4c1ec10d426878fd81.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Mallory&quot;, textcolour=&quot;red&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Alice,RA&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:RB,E_p(Bob_{priv},RA)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#b30892ea80e85d5226bffe1067bd495dabafda9e" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b30892ea80e85d5226bffe1067bd495dabafda9e.png"/>
<map id="b30892ea80e85d5226bffe1067bd495dabafda9e" name="b30892ea80e85d5226bffe1067bd495dabafda9e"/></p>
</div></blockquote>
<p>In this exchange, Bob authenticates himself by signing the <span class="math notranslate nohighlight">\(RA\)</span> nonce that was
sent by Mallory. Now, to authenticate as Alice, Mallory needs to compute
the signature of nonce <span class="math notranslate nohighlight">\(RB\)</span> with Alice’s private key. Mallory does not
know Alice’s key, but he could exploit the protocol to force Alice to
perform the required computation. For this, Mallory can start an
authentication to Alice as shown below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/cd66745b390b62a38dfe355eb3a5cc12.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Mallory&quot;, textcolour=&quot;red&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Alice&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;I'm Mallory,RB&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;Challenge:RX,E_p(Alice_{priv},RB)&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#48be047a9645ab6feb54e3f2716ac4f1e148d8e7" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-48be047a9645ab6feb54e3f2716ac4f1e148d8e7.png"/>
<map id="48be047a9645ab6feb54e3f2716ac4f1e148d8e7" name="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"/></p>
</div></blockquote>
<p>In this example, Mallory has forced Alice to compute
<span class="math notranslate nohighlight">\(E_p(Alice_{priv},RB)\)</span> which is the information required to
finalize the first exchange and be authenticated as Alice. This
illustrates a common problem with authentication schemes when the same
information can be used for different purposes. The problem comes from
the fact that Alice agrees to compute her signature on a nonce chosen
by Bob (and relayed by Mallory). This problem occurs if the nonce is a
simple integer without any structure. If the nonce includes some structure
such as some information about Alice and Bob’s identities or even a
single bit indicating whether the nonce was chosen by a user acting as
a client (i.e. starting the authentication) or as a server, then the
protocol is not vulnerable anymore.</p>
<p id="index-18">To cope with some of the above mentioned problems,
public-key cryptography is usually combined with
certificates. A <cite>certificate</cite> is a data structure that includes a signature from
a trusted third party. A simple explanation of the utilization of certificates
is to consider that Alice and Bob both know Ted. Ted is trusted by these
two users and both have stored Ted’s public key : <span class="math notranslate nohighlight">\(Ted_{pub}\)</span>. Since they
both know Ted’s key, he can issue certificates. A certificate is mainly a
cryptographic link between the identity of a user and his/her public key.
Such a certificate can be computed in different ways. A simple solution is for
Ted to generate a file that contains the following information
for each certified user :</p>
<blockquote>
<div><ul class="simple">
<li><p>his/her identity</p></li>
<li><p>his/her public key</p></li>
<li><p>a hash of the entire file signed with Ted’s private key</p></li>
</ul>
</div></blockquote>
<p>Then, knowing Ted’s public key, anyone can verify the validity of a certificate.
When a user sends his/her public key, he/she must also attach the certificate to
prove the link between his/her identity and the public key. In practice,
certificates are more complex than this.
Certificates will often be used to authenticate the
server and sometimes to authenticate the client.</p>
<p>A possible protocol could then be the following. Alice sends
<span class="math notranslate nohighlight">\(Cert(Alice_{pub},Ted)\)</span>. Bob replies with a random nonce.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/64eccedf6350698b6491b83ea9b24e73.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Alice&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Bob&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Cert(Alice_{pub},Ted)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;R&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot;] ,&#10;b&gt;&gt;c [ label = &quot;E_p(Alice_{priv},R)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;}" usemap="#3b6facf99117568ccbf6aa8408c70dddc156d855" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-3b6facf99117568ccbf6aa8408c70dddc156d855.png"/>
<map id="3b6facf99117568ccbf6aa8408c70dddc156d855" name="3b6facf99117568ccbf6aa8408c70dddc156d855"/></p>
</div></blockquote>
<p>Until now, we have only discussed the authentication problem. This is an
important but not sufficient step to have a secure communication between two
users through an insecure network. To securely exchange information, Alice
and Bob need to both :</p>
<blockquote>
<div><ul class="simple">
<li><p>mutually authenticate each other</p></li>
<li><p>agree on a way to encrypt the messages that they will exchange</p></li>
</ul>
</div></blockquote>
<p>Let us first explore how this could be realized by using public-key
cryptography. We assume that Alice and Bob have both a public-private
key pair and the corresponding certificates signed by a trusted
third party : Ted.</p>
<p>A possible protocol would be the following.
Alice sends <span class="math notranslate nohighlight">\(Cert(Alice_{pub},Ted)\)</span>. This certificate provides Alice’s
identity and her public key.
Bob replies with the certificate containing his own public key :
<span class="math notranslate nohighlight">\(Cert(Bob_{pub},Ted)\)</span>. At this point, they both know the
other public key and could use it to send encrypted messages.
Alice would send <span class="math notranslate nohighlight">\(E_p(Bob_{pub},M1)\)</span> and Bob would send
<span class="math notranslate nohighlight">\(E_p(Alice_{pub},M2)\)</span>. In practice, using public key encryption
techniques to encrypt a large number of messages is inefficient because
these cryptosystems require a large number of computations. It is more
efficient to use secret key cryptosystems for most of the data and only
use a public key cryptosystem to encrypt the random secret keys that
will be used by the secret key encryption scheme.</p>
&#13;

<h2>Key exchange<a class="headerlink" href="#key-exchange" title="Link to this heading">#</a></h2>
<p>When users want to communicate securely through a network,
they need to exchange information such as the keys that will be
used by an encryption algorithm even in the presence of an
eavesdropper. The most widely used algorithm that allows
two users to safely exchange an integer in the presence of
an eavesdropper is the one proposed by Diffie and Hellman <a class="reference internal" href="../bibliography.html#dh1976" id="id11"><span>[DH1976]</span></a>.
It operates with (large) integers. Two of them are public, the modulus, p,
which is prime and the base, g, which must be a primitive root of p.
The communicating users select a random integer, <span class="math notranslate nohighlight">\(a\)</span> for Alice and <span class="math notranslate nohighlight">\(b\)</span> for
Bob. The exchange starts as :</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice selects a random integer, <span class="math notranslate nohighlight">\(a\)</span> and sends
<span class="math notranslate nohighlight">\(A=g^{a} \mod p\)</span> to Bob</p></li>
<li><p>Bob selects a random integer, <span class="math notranslate nohighlight">\(b\)</span> and sends
<span class="math notranslate nohighlight">\(B=g^{b} \mod p\)</span> to Alice</p></li>
<li><p>From her knowledge of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, Alice can compute
<span class="math notranslate nohighlight">\(Secret=B^{a} \mod p= (g^{b} \mod p) ^{a} \mod p=g^{a \times b} \mod p\)</span></p></li>
<li><p>From is knowledge of <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(A\)</span>, Bob can compute
<span class="math notranslate nohighlight">\(Secret=A^{b} \mod p=(g^{a} \mod p) ^{b} \mod p=g^{a \times b} \mod p\)</span></p></li>
</ul>
</div></blockquote>
<p>The security of this protocol relies on the difficulty of computing
discrete logarithms, i.e. from the knowledge of <span class="math notranslate nohighlight">\(A\)</span> (resp. <span class="math notranslate nohighlight">\(B\)</span>),
it is very difficult to extract <span class="math notranslate nohighlight">\(\log(A)=\log(g^{a} \mod p)=a\)</span>
(resp. <span class="math notranslate nohighlight">\(\log(B)=\log(g^{b} \mod p)=b\)</span>).</p>
<p>An example of the utilization of the Diffie-Hellman key exchange is
shown below. Before starting the exchange, Alice
and Bob agree on a modulus (<span class="math notranslate nohighlight">\(p=23\)</span>) and a base (<span class="math notranslate nohighlight">\(g=5\)</span>). These two
numbers are public. They are typically part of the standard that defines
the protocol that uses the key exchange.</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice chooses a secret integer : <span class="math notranslate nohighlight">\(a=8\)</span> and sends
<span class="math notranslate nohighlight">\(A= g^{a} \mod p= 5^{8} \mod 23=16\)</span> to Bob</p></li>
<li><p>Bob chooses a secret integer : <span class="math notranslate nohighlight">\(b=13\)</span> and sends
<span class="math notranslate nohighlight">\(B= g^{b} \mod p=5^{13} \mod 23=21\)</span> to Alice</p></li>
<li><p>Alice computes <span class="math notranslate nohighlight">\(S_{A}=B^{a} \mod p= 21^{8} \mod 23=3\)</span></p></li>
<li><p>Bob computes <span class="math notranslate nohighlight">\(S_{B}=A^{b} \mod p= 16^{13} \mod 23=3\)</span></p></li>
</ul>
</div></blockquote>
<p>Alice and Bob have agreed on the secret information <span class="math notranslate nohighlight">\(3\)</span> without
having sent it explicitly through the network. If the integers used are
large enough and have good properties, then even Eve who can capture all
the messages sent by Alice and Bob cannot recover the secret key that
they have exchanged. There is no formal proof of the security of
the algorithm, but mathematicians have tried to solve similar problems with
integers during centuries without finding an efficient algorithm. As
long as the integers that are used are random and large enough, the only
possible attack for Eve is to test all possible integers that could have
been chosen by Alice and Bob. This is computationally very expensive.
This algorithm is widely used in security protocols to agree on a secret key.</p>
<p>Unfortunately, the Diffie-Hellman key exchange alone cannot cope with man-in-the
middle attacks. Consider Mallory who sits in the middle between Alice and
Bob and can easily capture and modify their messages. The modulus
and the base are public. They are thus known by Mallory as well. He
could then operate as follows :</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice chooses a secret integer and sends <span class="math notranslate nohighlight">\(A= g^{a} \mod p\)</span> to Mallory</p></li>
<li><p>Mallory generates a secret integer, <span class="math notranslate nohighlight">\(m\)</span> and sends <span class="math notranslate nohighlight">\(M=g^{m} \mod p\)</span> to Bob</p></li>
<li><p>Bob chooses a secret integer and sends <span class="math notranslate nohighlight">\(B=g^{b} \mod p\)</span> to Mallory</p></li>
<li><p>Mallory computes <span class="math notranslate nohighlight">\(S_{A}=A^{m} \mod p\)</span> and <span class="math notranslate nohighlight">\(S_{B}=B^{m} \mod p\)</span></p></li>
<li><p>Alice computes <span class="math notranslate nohighlight">\(S_{A}=M^{a} \mod p\)</span> and uses this key to communicate with Mallory (acting as Bob)</p></li>
<li><p>Bob computes <span class="math notranslate nohighlight">\(S_{B}=M^{b} \mod p\)</span> and uses this key to communicate with Mallory (acting as Alice)</p></li>
</ul>
</div></blockquote>
<p>When Alice sends a message, she encrypts it with <span class="math notranslate nohighlight">\(S_{A}\)</span>. Mallory
decrypts it with <span class="math notranslate nohighlight">\(S_{A}\)</span> and encrypts the plaintext with
<span class="math notranslate nohighlight">\(S_{B}\)</span>. When Bob receives the message, he can decrypt it
by using <span class="math notranslate nohighlight">\(S_{B}\)</span>.</p>
<p>To safely use the Diffie-Hellman key exchange, Alice and Bob must use
an <cite>authenticated</cite> exchange. Some of the information sent by Alice or Bob
must be signed with a public key known by the other user. In practice,
it is often important for Alice to authenticate Bob. If Bob has a
certificate signed by Ted, the authenticated key exchange could
be organized as follows.</p>
<blockquote>
<div><ul class="simple">
<li><p>Alice chooses a secret integer : <span class="math notranslate nohighlight">\(a\)</span> and sends
<span class="math notranslate nohighlight">\(A= g^{a} \mod p\)</span> to Bob</p></li>
<li><p>Bob chooses a secret integer : <span class="math notranslate nohighlight">\(b\)</span>, computes
<span class="math notranslate nohighlight">\(B= g^{b} \mod p\)</span> and sends
<span class="math notranslate nohighlight">\(Cert(Bob,Bob_{pub},Ted), E_p(Bob_{priv},B)\)</span> to Alice</p></li>
<li><p>Alice checks the signature (with <span class="math notranslate nohighlight">\(Bob_{pub}\)</span>)
and the certificate and computes <span class="math notranslate nohighlight">\(S_{A}=B^{a} \mod p\)</span></p></li>
<li><p>Bob computes <span class="math notranslate nohighlight">\(S_{B}=A^{b} \mod p\)</span></p></li>
</ul>
</div></blockquote>
<p>This prevents the attack mentioned above since Mallory cannot create a
fake certificate and cannot sign a value by using Bob’s private key. Given
the risk of man-in-the-middle attacks, the Diffie-Hellman key exchange
mechanism should never be used without authentication.</p>
&#13;

<span id="index-19"/><h2>The secure shell (ssh)<a class="headerlink" href="#the-secure-shell-ssh" title="Link to this heading">#</a></h2>
<p id="index-20"><span id="remote-login"/>One of the initial motivations for building computer networks was
to allow users to access remote computers over the networks. In the 1960s
and 1970s, the mainframes and the emerging minicomputers were composed
of a central unit and a set of terminals connected through serial
lines or modems. The simplest protocol that was designed to access
remote computers over a network is probably <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc854.html"><strong>RFC 854</strong></a>.
<a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> runs over TCP and a telnet server listens on port <cite>23</cite> by
default. The TCP connection used by telnet is bidirectional, both the client
and the server can send data over it. The data exchanged over such a
connection is essentially the characters that are typed by the user on the
client machine and the text output of the processes running on the server
machine with a few exceptions (e.g. control characters, characters to control
the terminal like VT-100, …) . The default character set for
telnet is the ASCII character set, but the extensions specified
in <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5198.html"><strong>RFC 5198</strong></a> support the utilization
of Unicode characters.</p>
<p>From a security viewpoint, the main drawback of <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> is that all
the information, including the usernames, passwords and commands,
is sent in cleartext over a TCP connection. This implies that
an eavesdropper could easily capture the passwords used by anyone
on an unprotected network. Various software tools exist to
automate this collection of information. For this reason,
<a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> is rarely used today to access remote computers.
It is usually replaced by <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> or similar protocols.</p>
<p>The secure shell protocol was designed in the mid 1990s by T. Ylonen
to counter the eavesdropping attacks against <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a> and
similar protocols <a class="reference internal" href="../bibliography.html#ylonen1996" id="id12"><span>[Ylonen1996]</span></a>. <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> became quickly popular and system
administrators encouraged its usage. The original version of <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a>
was freely available. After a few years, his author created a company
to distribute it commercially, but other programmers continued to
develop an open-source version of <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> called
<a class="reference external" href="http://www.openssh.com">OpenSSH</a>.
Over the years, <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> evolved
and became a flexible applicable whose usage extends beyond remote
login to support features such as file transfers, protocol tunneling, …
In this section, we only discuss the basic features of <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> and explain
how it differs from <a class="reference internal" href="../glossary.html#term-telnet"><span class="xref std std-term">telnet</span></a>. Entire books have been written to describe
<a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> in details <a class="reference internal" href="../bibliography.html#bs2005" id="id13"><span>[BS2005]</span></a>. An overview of the protocol
appeared in <a class="reference internal" href="../bibliography.html#stallings2009" id="id14"><span>[Stallings2009]</span></a>.</p>
<p>The <a class="reference internal" href="../glossary.html#term-ssh"><span class="xref std std-term">ssh</span></a> protocol runs directly above the TCP protocol.
Once the TCP bytestream
has been established, the client and the server exchange messages. The
first message exchanged is an ASCII line that announces the version of the
protocol and the version of the software implementation used by the client
and the server. These two lines are useful when debugging interoperability
problems and other issues.</p>
<p>The next message is the <code class="docutils literal notranslate"><span class="pre">SSH_MSG_KEX_INIT</span></code> message that is used
to negotiate the cryptographic algorithms that will be used for the
<code class="docutils literal notranslate"><span class="pre">ssh</span></code> session. It is very important for security protocols to
include mechanisms that enable a negotiation of the cryptographic
algorithms that are used. First, these
algorithms provide different levels of security. Some algorithms might
be considered totally secure and are recommended today while they could
become deprecated a few years later after the publication of some
attacks. Second, these algorithms provide different levels of
performance and have different CPU and memory impacts.</p>
<p>In practice, an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> implementation supports four types of
cryptographic algorithms :</p>
<blockquote>
<div><ul class="simple">
<li><p>key exchange</p></li>
<li><p>encryption</p></li>
<li><p>Message Authentication Code (MAC)</p></li>
<li><p>compression</p></li>
</ul>
</div></blockquote>
<p>The <a class="reference external" href="https://www.iana.org">IANA</a> maintains a <a class="reference external" href="http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml#ssh-parameters-16">list of the cryptographic algorithms</a>
that can be used by <code class="docutils literal notranslate"><span class="pre">ssh</span></code> implementations. For each type of algorithm,
the client provides an ordered list of the algorithms that it supports
and agrees to use. The server compares the received list with its own list.
The outcome of the negotiation is a set of four algorithms <a class="footnote-reference brackets" href="#fnull" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>
that will be combined for this session.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/6c5012af9e2d96b7ddb2c31a55acbaec.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;SSH-clientP-clientS comments&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;SSH-serverP-serverS comments&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;&#10;a=&gt;b [ label = &quot;&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;SSH_MSG_KEX_INIT&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;&quot; ];&#10;&#10;d=&gt;c [ label = &quot;&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;SSH_MSG_KEX_INIT&quot;, arcskip=&quot;1&quot;];&#10;b=&gt;a [ label = &quot;&quot; ];&#10;}" usemap="#6ae6d4bce6070be0fd3cb65a88d797c93f775d1d" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6ae6d4bce6070be0fd3cb65a88d797c93f775d1d.png"/>
<map id="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d" name="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"/></p>
</div></blockquote>
<p>This negotiation of the cryptographic algorithms allows the implementations
to evolve when new algorithms are proposed. If a client is upgraded, it can
announce a new algorithm as its preferred one even if the server is not
yet upgraded.</p>
<p>Once the cryptographic algorithms have been negotiated, the key exchange algorithm is
used to negotiate a secret key that will be shared by the client and the server.
These key exchange algorithms include some variations over
the basic algorithms. As an example, let us analyze how the
Diffie-Hellman key exchange algorithm is used within the
<code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol. In this case, each host has both a private and a public key.  (Note that
<span class="math notranslate nohighlight">\(g\)</span> is a generator for the subgroup of the Galois field of order <span class="math notranslate nohighlight">\(p\)</span>, where
<span class="math notranslate nohighlight">\(p\)</span> is a prime number, and || is the concatenation operator.  For additional background
information, see <a class="reference internal" href="../bibliography.html#schneier1996" id="id16"><span>[Schneier1996]</span></a>.)</p>
<blockquote>
<div><ul class="simple">
<li><p>the client generates the random number <span class="math notranslate nohighlight">\(a\)</span> and sends
<span class="math notranslate nohighlight">\(A=g^{a} \mod p\)</span> to the server</p></li>
<li><p>the server generates the random number <span class="math notranslate nohighlight">\(b\)</span>. It then computes
<span class="math notranslate nohighlight">\(B=g^{b} \mod p\)</span>, <span class="math notranslate nohighlight">\(K=B^{a} \mod p\)</span> and signs with its private
key <span class="math notranslate nohighlight">\(hash(V_{Client} || V_{Server} || KEX\_INIT_{Client} || KEX\_INIT_{Server} || Server_{pub} || A || B || K )\)</span>
where <span class="math notranslate nohighlight">\(V_{Server}\)</span> (resp. <span class="math notranslate nohighlight">\(V_{Client}\)</span>) is the initial
messages sent by the client (resp. server), <span class="math notranslate nohighlight">\(KEX\_INIT_{Client}\)</span>
(resp.  <span class="math notranslate nohighlight">\(KEX\_INIT_{Server}\)</span>) is the key exchange message sent by
the client (resp. server) and <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(K\)</span> are the
messages of the Diffie-Hellman key exchange</p></li>
<li><p>the client can recompute <span class="math notranslate nohighlight">\(K=A^{b} \mod p\)</span> and verify the
signature provided by the server</p></li>
</ul>
</div></blockquote>
<p>This is a slightly modified authenticated Diffie-Hellman key exchange
with two interesting points. The first point is that
when the server authenticates the key exchange it does not provide a
certificate. This is because <code class="docutils literal notranslate"><span class="pre">ssh</span></code> assumes that the client will store
inside its cache the public key of the servers that it uses on a
regular basis. This assumption is valid for a protocol like <code class="docutils literal notranslate"><span class="pre">ssh</span></code>
because users typically use it to interact with a small number of
servers, typically a few or a few tens. Storing this information does
not require a lot of storage. In practice, most <code class="docutils literal notranslate"><span class="pre">ssh</span></code> clients will
accept to connect to remote servers without knowing their public key before
the connection. In this case, the client issues a warning to the user who
can decide to accept or reject the key. This warning can be associated
with a fingerprint of the key, either as a sequence of letters or as
an ASCII art which can be posted on the web or elsewhere <a class="footnote-reference brackets" href="#fdnsssh" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> by the
system administrator of the server. If a client connects to a server
whose public key does not match the stored one, a stronger warning is
issued because this could indicate a man-in-the-middle attack or that
the remote server has been compromised. It can also indicate that the server
has been upgraded and that a new key has been generated during this upgrade.</p>
<p id="index-23">The second point is that the server authenticates not only the result
of the Diffie-Hellman exchange but also a hash of all the information
sent and received during the exchange. This is important to prevent
<cite>downgrade attacks</cite>. A <cite>downgrade attack</cite> is an attack where an
active attacker modifies the messages sent by the communicating hosts
(typically the client) to request the utilization of weaker encryption
algorithms. Consider a client that supports two encryption schemes. The
preferred one uses 128 bits secret keys and the second one is an old
encryption scheme that uses 48 bits keys. This second algorithm is
kept for backward compatibility with older implementations. If an attacker
can remove the preferred algorithm from the list of encryption algorithms
supported by the client, he can force the server to use a weaker
encryption scheme that will be easier to break. Thanks
to the hash that covers all the messages exchanged by the server,
the downgrade attack cannot occur against <code class="docutils literal notranslate"><span class="pre">ssh</span></code>. Algorithm agility is
a key requirement for security protocols that need to evolve when
encryption algorithms are broken by researchers. This agility cannot be
used without care and signing a hash of all the messages exchanged
is a technique that is frequently used to prevent downgrade attacks.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Single use keys</p>
<p>Thanks to the Diffie-Hellman key exchange, the client and the
servers share key <span class="math notranslate nohighlight">\(K\)</span>. A naive implementation would probably
directly use this key for all the cryptographic algorithms that
have been negotiated for this session. Like most security protocols,
<code class="docutils literal notranslate"><span class="pre">ssh</span></code> does not directly use key <span class="math notranslate nohighlight">\(K\)</span>. Instead, it uses
the negotiated hash function with different parameters <a class="footnote-reference brackets" href="#fsshkeys" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>
to allow the
client and the servers to compute six keys from <span class="math notranslate nohighlight">\(K\)</span> :</p>
<blockquote>
<div><ul class="simple">
<li><p>a key used by the client (resp. server) to encrypt the data that
it sends</p></li>
<li><p>a key used by the client (resp. server) to authenticate the
data that it sends</p></li>
<li><p>a key used by the client (resp. server) to initialize the
negotiated encryption scheme (if required by this scheme)</p></li>
</ul>
</div></blockquote>
<p>It is common practice among designers of security protocols to never
use the same key for different purposes. For example, allowing the
client and the server to use the same key to encrypt data could
enable an attacker to launch a replay attack by sending to the
client data that it has itself encrypted.</p>
</div>
<p>At this point, all the messages sent over the TCP connection will be encrypted
with the negotiated keys. The <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol uses messages
that are encoded according to the Binary Packet Protocol defined in
<span class="target" id="index-24"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4253.html"><strong>RFC 4253</strong></a>. Each of these messages contains the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> : this is the length of the message in bytes, excluding the MAC
and length fields</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span> <span class="pre">length</span></code> : this is the number of random bytes that have been added
at the end of the message.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">payload</span></code> : the data (after optional compression) passed by the user</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span></code> : random bytes added in each message (at least four) to
ensure that the message length is a multiple of the block size
used by the negotiated encryption algorithm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAC</span></code> : this field is present if a Message Authentication Code has been
negotiated for the session (in practice, using <code class="docutils literal notranslate"><span class="pre">ssh</span></code> without
authentication is risky and this field should always be present). Note
that to compute the MAC, an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> implementation must maintain
a message counter. This counter is incremented by one every time a
message is sent and the MAC is computed with the negotiated authentication
algorithm using the MAC key over the concatenation of
the message counter and the cleartext message.
The message counter is not transmitted,
but the recipient can easily recover its value. The <code class="docutils literal notranslate"><span class="pre">MAC</span></code> is computed as
<span class="math notranslate nohighlight">\(mac = MAC(key, sequence\_number || unencrypted\_message)\)</span> where the
key is the negotiated authentication key.</p></li>
</ul>
</div></blockquote>
<div class="admonition note" id="index-25">
<p class="admonition-title">Note</p>
<p>Authenticating messages with HMAC</p>
<p><cite>ssh</cite> is one example of a protocol that uses Message Authentication Codes
(MAC) to authenticates the messages that are sent. A naive implementation
of such a MAC would be to simply use a hash function like SHA-1. However,
such a construction would not be safe from a security viewpoint. Internet
protocols usually rely on the HMAC construction defined in <span class="target" id="index-26"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a>.
It works with any hash function (<cite>H</cite>) and a key (<cite>K</cite>). As an example, let
us consider HMAC with the SHA-1 hash function. SHA-1 uses 20 bytes
blocks and the block size will play an important role in the operation
of HMAC. We first require the key to be as long as the block size. Since this
key is the output of the key generation algorithm, this is one parameter
of this algorithm.</p>
<p>HMAC uses two padding strings : <cite>ipad</cite> (resp. <cite>opad</cite>)  which is a
string containing 20 times byte <code class="docutils literal notranslate"><span class="pre">0x36</span></code> (resp. byte <code class="docutils literal notranslate"><span class="pre">0x5C</span></code>). The HMAC
is then computed as <span class="math notranslate nohighlight">\(H[K \oplus opad, H(K \oplus ipad, data) ]\)</span>
where <span class="math notranslate nohighlight">\(\oplus\)</span> denotes the bitwise XOR operation. This computation
has been shown to be stronger than the naive <span class="math notranslate nohighlight">\(H(K,data)\)</span> against
some types of cryptographic attacks.</p>
</div>
<p>Among the various features of the <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol, it is interesting
to mention how users are authenticated by the server. The <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol
supports the classical username/password authentication (but both
the username and the password are transmitted over the secure encrypted
channel). In addition, <code class="docutils literal notranslate"><span class="pre">ssh</span></code> supports two authentication mechanisms that
rely on public keys. To use the first one, each user needs to generate
his/her own public/private key pair and store the public key on the server.
To be authenticated, the user needs to sign a message containing his/her
public key by using his/her private key. The server can easily verify the
validity of the signature since it already knows the user’s public key.
The second authentication scheme is designed for hosts that trust each
other. Each host has a public/private key pair and stores the public keys
of the other hosts that it trusts. This is typically used in environments
such as university labs where each user could access any of the available
computers. If Alice has logged on <code class="docutils literal notranslate"><span class="pre">computer1</span></code> and wants to execute a
command on <code class="docutils literal notranslate"><span class="pre">computer2</span></code>, she can create an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> session on this computer
and type (again) her password. With the host-based authentication scheme,
<code class="docutils literal notranslate"><span class="pre">computer1</span></code> signs a message with its private key to confirm that
it has already authenticated Alice. <code class="docutils literal notranslate"><span class="pre">computer2</span></code> would then accept
Alice’s session without asking for her credentials.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ssh</span></code> protocol includes other features that are beyond the
scope of this book. Additional details may be found in <a class="reference internal" href="../bibliography.html#bs2005" id="id19"><span>[BS2005]</span></a>.</p>
&#13;

<span id="tls"/><h2>Transport Layer Security<a class="headerlink" href="#transport-layer-security" title="Link to this heading">#</a></h2>
<p id="index-27">The Transport Layer Security family of protocols were initially
proposed under the name Secure Socket Layer (SSL). The first deployments
used this name and many researchers still refer to this security
protocol as SSL <a class="reference internal" href="../bibliography.html#fkc1996" id="id20"><span>[FKC1996]</span></a>. In this chapter, we use the official name that was
standardized by the IETF: TLS for <cite>Transport Layer Security</cite>.</p>
<p>The TLS protocol was designed to be usable by a wide range of applications
that use the transport layer to reliably exchange information. TLS is mainly
used over the TCP protocol. There are variants of TLS that operate
over SCTP <span class="target" id="index-28"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3436.html"><strong>RFC 3436</strong></a> or UDP <span class="target" id="index-29"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6347.html"><strong>RFC 6347</strong></a>,
but these are outside the scope of  this chapter.</p>
<p>A TLS session operates over a TCP connection. TLS is responsible for the
encryption and the authentication of the SDUs exchanged by the application
layer protocol while TCP provides the reliable delivery of this encrypted
and authenticated bytestream. TLS is used by many different
application layer protocols. The most frequent ones are HTTP (HTTP over TLS
is called HTTPS), SMTP <span class="target" id="index-30"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3207.html"><strong>RFC 3207</strong></a> or POP and IMAP <span class="target" id="index-31"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2595.html"><strong>RFC 2595</strong></a>, but proprietary application-layer protocols also use TLS <a class="reference internal" href="../bibliography.html#am2019" id="id21"><span>[AM2019]</span></a>.</p>
<p>A TLS session can be initiated in two different ways. First, the application
can use a dedicated TCP port number for application layer protocol x-over-TLS.
This is the solution used by many HTTP servers that reserve port <span class="math notranslate nohighlight">\(443\)</span>
for HTTP over TLS. This solution works, but it requires to reserve two ports
for each application : one where the application-layer protocol is used
directly over TCP and another one where the application-layer protocol
is used over TLS. Given the limited number of TCP ports that are available,
this is not a scalable solution. The table below provides some of
the reserved port numbers for application layer protocols on top of TLS.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Application</p></th>
<th class="head"><p>TCP port</p></th>
<th class="head"><p>TLS port</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>POP3</p></td>
<td><p>110</p></td>
<td><p>995</p></td>
</tr>
<tr class="row-odd"><td><p>IMAP</p></td>
<td><p>143</p></td>
<td><p>993</p></td>
</tr>
<tr class="row-even"><td><p>NNTP</p></td>
<td><p>119</p></td>
<td><p>563</p></td>
</tr>
<tr class="row-odd"><td><p>HTTP</p></td>
<td><p>80</p></td>
<td><p>443</p></td>
</tr>
<tr class="row-even"><td><p>FTP</p></td>
<td><p>21</p></td>
<td><p>990</p></td>
</tr>
</tbody>
</table>
</div>
<p>A second approach to initiate a TLS session is to use the standard
TCP port number for the application layer protocol and define a special
message in this protocol to trigger the start of the
TLS session. This is the solution used for SMTP with the <code class="docutils literal notranslate"><span class="pre">STARTTLS</span></code> message.
This extension to SMTP <span class="target" id="index-32"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3207.html"><strong>RFC 3207</strong></a> defines the new STARTTLS command.
The client can issue this command to indicate to the server that
it wants to start a TLS session as shown in the example below
captured during a session on port 25.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">220 server.example.org ESMTP</span>
<span class="go">EHLO client.example.net</span>
<span class="go">250-server.example.org</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-SIZE 250000000</span>
<span class="go">250-ETRN</span>
<span class="go">250-STARTTLS</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-8BITMIME</span>
<span class="go">250 DSN</span>
<span class="go">STARTTLS</span>
<span class="go">220 2.0.0 Ready to start TLS</span>
</pre></div>
</div>
<p>In the remaining parts of this chapter, we assume that the TLS session
starts immediately after the establishment of the TCP connection. This
corresponds to the deployments on web servers. We focus our presentation
of TLS on this very popular use case. TLS is a complex protocol that
supports other features than the one used by web servers. A more detailed
presentation of TLS may be found in <a class="reference internal" href="../bibliography.html#kps2002" id="id22"><span>[KPS2002]</span></a> and <a class="reference internal" href="../bibliography.html#ristic2015" id="id23"><span>[Ristic2015]</span></a>.</p>
<p>A TLS session is divided in two phases: the handshake and the data transfer.
During the handshake, the client
and the server negotiate the security parameters and the keys that will
be used to secure the data transfer. During the second phase, all the messages
exchanged are encrypted and authenticated with the negotiated algorithms
and keys.</p>
<section id="the-tls-handshake">
<h3>The TLS handshake<a class="headerlink" href="#the-tls-handshake" title="Link to this heading">#</a></h3>
<p>When used to interact with a regular web server, the TLS handshake has
three important objectives:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Securely negotiate the cryptographic algorithms that will be used by the
client and the server over the TLS session</p></li>
<li><p>Verify that the client interacts with a valid server</p></li>
<li><p>Securely agree on the keys that will be used to encrypt and authenticate
the messages exchanged over the TLS session</p></li>
</ol>
</div></blockquote>
<p>The TLS handshake is a four-way handshake illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/300581e55a5559d21fa138b6759650ca.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random], Certificate&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Finished=MAC(MasterSecret||Handshake)&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, linecolour=&quot;red&quot;, textcolour=&quot;red&quot;];&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, linecolour=&quot;red&quot;, textcolour=&quot;red&quot;];&#10;}" usemap="#6851383dfd7cb6f84e42dde9992fdd9303de35d3" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6851383dfd7cb6f84e42dde9992fdd9303de35d3.png"/>
<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3" name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"/></p>
</div></blockquote>
<p>In a nutshell, the client starts the TLS handshake by proposing a random nonce. The server replies with its random nonce and a certificate that binds its name to a public key. The client generates a MasterSecret that will be used later to derive the session keys and encrypts it with the public key of the server. It also generates a <cite>Finished</cite> message that contains a MAC of all the messages exchanged to allow the server to detect any modification of the messages sent by the client. The server also sends its own <cite>Finished</cite> message. At that point, the client and the server sent encrypted records thanks to the keys derived from the MasterSecret.</p>
<p id="index-33">Let us first discuss the negotiation of the cryptographic algorithms and
parameters. Like all security protocols, TLS includes some agility in its
design since new cryptographic algorithms appear over the years and
some older algorithms become deprecated once cryptanalysts find flaws.
The TLS handshakes starts with the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message
that is sent by the client. This message carries the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Protocol version number</cite>: this is the version of the TLS protocol supported
by the client. The server should use the same version of the TLS protocol as
the client, but may opt for an older version. Both versions 1.2 and 1.3 of TLS are deployed today. Older versions are being deprecated.</p></li>
<li><p><cite>Random number</cite>: security protocols rely on random numbers. The client
sends a 32 bytes long random number where usually four of these bytes
correspond
to the client’s clock. This random number is used, together with the
server’s random number, as a seed to generate the security keys.</p></li>
<li><p><cite>Cipher suites</cite> : this ordered list contains the set of cryptographic
algorithms that are supported by the client, with the most preferred one
listed first. In contrast with <code class="docutils literal notranslate"><span class="pre">ssh</span></code> that allows negotiating independent
algorithms for encryption, key exchange and authentication, TLS relies on
suites that combine these algorithms together. Many cryptographic suites
have been defined for TLS. Various recommendations
have been published on the security of some of these suites <span class="target" id="index-34"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525</strong></a>.</p></li>
<li><p><cite>Compression algorithm</cite> : the client may propose the utilization of a
specific compression algorithm (e.g. zlib). In theory, compressing the data
before encrypting it is an intelligent way to reduce the amount of data
exchanged. Unfortunately, its implementation in TLS has caused several security problems <a class="reference internal" href="../bibliography.html#phg2013" id="id24"><span>[PHG2013]</span></a>. For
this reason, compression is usually disabled in TLS <span class="target" id="index-35"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525</strong></a>.</p></li>
<li><p><cite>Extensions</cite> : TLS supports various extensions in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>
message. These extensions <span class="target" id="index-36"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a> are important to allow the protocol
to evolve, but many of them go beyond the scope of this chapter.</p></li>
</ul>
</div></blockquote>
<div class="admonition note" id="index-37">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Server</span> <span class="pre">Name</span> <span class="pre">Indication</span> <span class="pre">(SNI)</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Server</span> <span class="pre">Name</span> <span class="pre">Indication</span> <span class="pre">(SNI)</span></code> extension defined in <span class="target" id="index-38"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a>
is an important TLS extension for web servers.
It is used by the client to indicate the name of the server
that it wishes to contact. The IP address associated to this name
has been queried from the DNS and used to establish the TCP connection.
Why should the client indicate the server name in the TLS
<code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> ?  The motivation is the same as for the <code class="docutils literal notranslate"><span class="pre">Host</span></code>
header line in HTTP/1.0. With the SNI extension, a single TLS server
can support several web sites that use different domain names. Thanks
to the SNI extension, the server knows the concerned domain name at
the start of the TLS session. Without this extension, hosting providers
would have been forced use one IP address per TLS-enabled server.</p>
</div>
<p id="index-39">The server replies to the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> with several messages:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code> message that contains the protocol version chosen by
the server (assumed to be the same as the client version in this chapter),
the 32 random bytes chosen by the server, the <cite>Cipher Suite</cite> selected by
the server from the list advertised by the client
and a <cite>Session Id</cite>. This <cite>Session Id</cite> is an identifier which
is chosen by the server. It identifies the TLS session and the
security parameters (algorithms and keys) negotiated for this session.
It is used to support session resumption.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">Certificate</span></code> message provides the certificate (or usually a chain of
certificates) that binds a domain name to the public key used by
the server. TLS uses the server certificates
to authenticate the server. It relies on a Public Key Infrastructure that
is composed of a set of root certification authorities that
issue certificates to certification authorities that in the end
issue certificates to servers. TLS clients are usually configured with
the public keys of several root certification authorities and use
this information to validate the certificates that they receive from
servers. For historical reasons, the TLS certificates are encoded
in ASN.1 format. The details of the ASN.1 syntax <a class="reference internal" href="../bibliography.html#dubuisson2000" id="id25"><span>[Dubuisson2000]</span></a>
are outside the scope of this book.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message is used by the server to transmit the
information that is required to perform the key exchange. The content
of this message is function of the selected key exchange algorithm.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerHelloDone</span></code> indicates that the server has sent all the messages
for the first phase of the handshake.</p></li>
</ul>
</div></blockquote>
<p id="index-40">At this point, it is time to describe the TLS key exchange. TLS supports
different key exchange mechanisms that can be negotiated as part of the
selection of the cipher suite. We focus on two of them to highlight
their differences:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSA</span></code>. This key exchange algorithm uses the encryption capabilities of
the RSA public-key algorithm. The client has validated the server’s
public key thanks to the <code class="docutils literal notranslate"><span class="pre">Certificate</span></code> message. It then generates
a (48 bytes) random number, encrypts it with the server public key
and sends the encrypted number to the server in the <code class="docutils literal notranslate"><span class="pre">ClientKeyExchange</span></code>
message. The server uses its private key to decrypt the random
number. At this point, the client and the server share the same
(48 bytes long) secret and use it to derive the secret keys required
to encrypt and authenticate data in the second phase. With this
key exchange algorithm, the server does not need to send a
<code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>. This key exchange algorithm is the Ephemeral Diffie Hellman
key exchange with RSA signatures to authenticate the key exchange. It
operates as a classical authenticated Diffie Hellman key exchange.
If this key exchange
has been selected by the server, it sends its Diffie Hellman parameters
in the <code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message and signs them with its private
key. The client then continues the key exchange and sends the results of
its own computation in the <code class="docutils literal notranslate"><span class="pre">ClientKeyExchange</span></code> message. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>
is thus an authenticated Diffie Hellman key exchange where the initial
message is sent by the server (instead of the client as in our first example
but since the protocol is symmetric, this does not matter).</p></li>
</ul>
</div></blockquote>
<p id="index-41">An important difference between <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> and <code class="docutils literal notranslate"><span class="pre">RSA</span></code> is their reaction
against attacks. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> is considered by many to be stronger than <code class="docutils literal notranslate"><span class="pre">RSA</span></code>
because it supports <cite>Perfect Forward Secrecy</cite>. This property is important
against attackers that are able to eavesdrop all the (encrypted) data
sent and received by a server. Consider that Terrence is such an attacker
that has stored all the packets exchanged by Bob’s server during the last
six months. If he manages, by any means, to obtain Bob’s private key, he
will be able to decrypt all the keys used to secure the TLS sessions with
Bob’s server during this period. With <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>, a similar attack is
less devastating. If Terrence knows Bob’s private key, he will be able to launch
a man-in-the-middle attack against future TLS sessions with Bob’s server.
However, he will not be able to recover the keys used for all the past
sessions that he captured.</p>
<div class="admonition note" id="index-42">
<p class="admonition-title">Note</p>
<p>Perfect Forward Secrecy</p>
<p>Perfect Forward Secrecy (PFS) is an important property for key
exchange protocols. A protocol provides PFS if its design guarantees that
the keys used for former sessions will not be compromised even if the
private key of the server is compromised. This is a very important
property. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> provides Perfect Forward Secrecy, but the
<code class="docutils literal notranslate"><span class="pre">RSA</span></code> key exchange does not provide this property. In practice,
<code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> is costly from a computational viewpoint. Recent implementations
of TLS thus prefer  <code class="docutils literal notranslate"><span class="pre">ECDHE_RSA</span></code> or <code class="docutils literal notranslate"><span class="pre">ECDHE_ECDSA</span></code> when
Perfect Forward Secrecy is required.</p>
</div>
<p>All the information required for the key exchange has now been transmitted.
There are two important messages that will be sent by the client and the server
to conclude the handshake and start the data transfer phase.</p>
<p>The client sends the <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message followed by the <code class="docutils literal notranslate"><span class="pre">Finished</span></code>
message. The <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message indicates that the client has received
all the information required to generate the security keys for this TLS
session. This messages can also appear later in the session to indicate a
change in the encryption algorithms that are used, but this usage is outside
the scope of this book. The <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message is more important. It confirms
to the server that the TLS handshake has been performed correctly and that no
attacker has been able to modify the data sent by the client or the server.
This is the first message that is encrypted with the selected security keys.
It contains a hash of all the messages that were exchanged during the handshake.</p>
<p>The server also sends a <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message followed by a <code class="docutils literal notranslate"><span class="pre">Finished</span></code>
message.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TLS Cipher suites</p>
<p>A TLS cipher suite is usually represented as an ASCII string
that starts with TLS and contains the acronym of the key exchange algorithm,
the encryption scheme with the key size and its mode of operation and
the authentication algorithm. For example,
<code class="docutils literal notranslate"><span class="pre">TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</span></code> is a TLS cipher suite that uses
the <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> key exchange algorithm with 128 bits AES in GCM mode for
encryption and SHA-256 for authentication. The official list of TLS
cipher suites is maintained by IANA <a class="footnote-reference brackets" href="#fianatls" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>. The NULL acronym
indicates that no algorithm has been specified. For example,
<code class="docutils literal notranslate"><span class="pre">TLS_ECDH_RSA_WITH_NULL_SHA</span></code> is a cipher suite that does not use
any encryption but still uses the <code class="docutils literal notranslate"><span class="pre">ECDH_RSA</span></code> key exchange and
<code class="docutils literal notranslate"><span class="pre">SHA</span></code> for authentication.</p>
</div>
</section>
<section id="the-tls-record-protocol">
<h3>The TLS record protocol<a class="headerlink" href="#the-tls-record-protocol" title="Link to this heading">#</a></h3>
<p>The handshake is now finished. The client and the server will exchange
authenticated and encrypted records. TLS defines different formats for the
records depending on the cryptographic algorithms that have been negotiated
for the session. A detailed discussion of these different types of
records is outside the scope of this introduction. For illustration, we
briefly describe one record format.</p>
<p>As other security protocols, TLS uses different keys to encrypt and
authenticate records. These keys are derived from the MasterSecret that
is either randomly generated by the client after the <code class="docutils literal notranslate"><span class="pre">RSA</span></code> key exchange
or derived from the Diffie Hellman parameters after the <code class="docutils literal notranslate"><span class="pre">DH_RSA</span></code>
key exchange. The exact algorithm used to derive the keys is defined
in <span class="target" id="index-43"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a>.</p>
<p>A TLS record is always composed of four different fields :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>Type</cite> that indicates the type of record. The most frequent type
is <cite>application data</cite> which corresponds to a record containing encrypted
data. The other types are <cite>handshake</cite>, <cite>change_cipher_spec</cite> and
<cite>alert</cite>.</p></li>
<li><p>a <cite>Protocol Version</cite> field that indicates the version of the TLS protocol
used. This version is composed of two sub fields : a major and a
minor version number.</p></li>
<li><p>a <cite>Length</cite> field. A TLS record cannot be longer than 16,384 bytes.</p></li>
<li><p>a <cite>TLSPlainText</cite> that contains the encrypted data</p></li>
</ul>
</div></blockquote>
<p>TLS supports several methods to encrypted records. The selected
method depends on the cryptographic algorithms that have been negotiated for
the TLS session. A detailed presentation of the different methods that can
be used to produce the <cite>TLSPlainText</cite> from the user data is outside the scope
of this book. As an example, we study one method: Stream Encryption. This
method is used with cryptographic algorithms which can operate on a stream
of bytes. The method starts with a sequence of bytes provided by the
user application: the plain text. The first step is to compute the
authentication code to verify the integrity of the data. For this, TLS
computes <span class="math notranslate nohighlight">\(MAC(SeqNum, Header, PlainText)\)</span> using HMAC
where <cite>SeqNum</cite> is a sequence
number which is incremented by one for each new TLS record transmitted. The
<cite>Header</cite> is the header of the TLS record described above and <cite>PlainText</cite> is
the information that needs to be encrypted. Note that the sequence number
is maintained at the two endpoints of the TLS session, but it is not transmitted
inside the TLS record. This sequence number is used to prevent replay attacks.</p>
<div class="admonition note" id="index-44">
<p class="admonition-title">Note</p>
<p>MAC-then-encrypt or Encrypt-then-MAC</p>
<p>When secure protocols use Message Authentication and Encryption, they
need to specify how these two algorithms are combined. A first
solution, which is used by the current version of TLS, is to compute
the authentication code and then encrypt both the data and the
authentication code. A drawback of this approach is that the receiver
of an encrypted TLS record must first attempt to decrypt data that
has potentially been modified by an attacker before being able
to verify the authenticity of the record. A better approach is
for the sender to first encrypt the data and then compute the
authentication code over the encrypted data. This is the encrypt-then-MAC
approach proposed in <span class="target" id="index-45"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7366.html"><strong>RFC 7366</strong></a>. With encrypt-then-MAC, the receiver
first checks the authentication code before attempting to decrypt the
record.</p>
</div>
</section>
<section id="improving-tls">
<h3>Improving TLS<a class="headerlink" href="#improving-tls" title="Link to this heading">#</a></h3>
<p>During the last two decades, the deployment of TLS has continued to grow. The early TLS servers were only used for critical services such as e-commerce websites or online banks. As CPU performance improved, it became much more cost-effective to use TLS to secure non-critical parts of web servers, including the delivery of HTML pages and even video services. There is now a growing number of applications that rely on TLS <a class="reference internal" href="../bibliography.html#am2019" id="id27"><span>[AM2019]</span></a>.</p>
<p>In 2013, the statistics collected by the Firefox Telemetry project <a class="footnote-reference brackets" href="#ftelemetry" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> revealed that 30% of the web pages loaded by Firefox users were done over HTTPS. In October 2019, 80% of the web pages are loaded over HTTPS. In six years, HTTPS became the dominant protocol to access web services. Another look at the deployment of HTTPS on web sites may be found in <a class="reference internal" href="../bibliography.html#helme2019" id="id29"><span>[Helme2019]</span></a>.</p>
<p>Measurement studies that analyzed the evolution of TLS over the years have identified several important changes in the TLS ecosystem <a class="reference internal" href="../bibliography.html#kra2018" id="id30"><span>[KRA2018]</span></a>. First, the preferred cryptographic algorithms have changed. While RC4 was used by 60% of the connections in 2012, its usage has dropped since 2015. AES started to be deployed in 2013 and is now used for more than 90% of the connections. The deployed versions of TLS have also changed. TLS 1.0 and TLS 1.1 are now rarely used. The deployment of TLS 1.2 started in 2013 and reached 70% of the connections in 2015. Version 1.3 of TLS, that is described below, is also widely deployed.</p>
<p>Another interesting fact is the key exchange schemes. In 2012, RSA was the dominant solution, used by more than 80% of the observed connections <a class="reference internal" href="../bibliography.html#kra2018" id="id31"><span>[KRA2018]</span></a>. In 2013, Edward Snowden revealed the surveillance activities of several governments. These revelations had a huge impact on the Internet community. The IETF, which standardizes Internet protocols, considered in <span class="target" id="index-46"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7258.html"><strong>RFC 7258</strong></a> that such pervasive monitoring was an attack. Since then, several IETF working groups have developed solutions to counter pervasive monitoring. One of these solutions is to encourage <cite>Perfect Forward Security</cite>. Within TLS, this implies replacing RSA by an authenticated Diffie Hellman key exchange such as ECDHE. Measurements indicate
that since summer 2014, ECDHE is more popular than RSA. In 2018, more than 90% of the observed TLS connections used ECDHE.</p>
<p>The last point is the difficulty of deploying TLS servers <a class="reference internal" href="../bibliography.html#kms2017" id="id32"><span>[KMS2017]</span></a>. When TLS servers are installed, the system administrator needs to obtain certificates and configure a range of servers. Initially, getting certificates was complex and costly, but initiatives such as <a class="reference external" href="https://letsencrypt.org">https://letsencrypt.org</a> have simplified this workflow.</p>
<p>In 2014, the IETF TLS working started to work on the development of version 1.3 of the TLS protocol. Their main objectives <a class="reference internal" href="../bibliography.html#rescorla2015" id="id33"><span>[Rescorla2015]</span></a> for this new version were:</p>
<blockquote>
<div><ul class="simple">
<li><p>simplify the design by removing unused or unsafe protocol features</p></li>
<li><p>improve the security of TLS by leveraging the lessons learned from TLS 1.2 and some documented attacks</p></li>
<li><p>improve the privacy of the protocol</p></li>
<li><p>reduce the latency of TLS</p></li>
</ul>
</div></blockquote>
<p>Since 2014, latency has become an important concern for web services. As access networks bandwidth continue to grow, latency is becoming a key factor that affects the performance of interactive web services. With TLS 1.2, the download of a web page requires a minimum of four round-trip-times, one to create the underlying TCP connection, one to exchange the ClientHello/ServerHello, one to exchange the keys and then one to send the HTTP GET and retrieve the response. This can be very long when the server is not near the client. TLS 1.3 aimed at reducing this handshake to one round-trip-time and even zero by placing some of the cryptographic handshake in the TCP handshake. This part will be discussed in the TCP chapter. We focus here on the reducing the TLS handshake to a single round-trip-time.</p>
<p>To simplify both the design and the implementations, TLS 1.3 uses only a small number of cipher suites. Five of them are specified in <span class="target" id="index-47"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a> and <code class="docutils literal notranslate"><span class="pre">TLS_AES_128_GCM_SHA256</span></code> must be supported by all implementations. To ensure privacy, all cipher suites that did not provide Perfect Forward Secrecy have been removed. Compression has also been removed from TLS since several attacks on TLS 1.2 exploited its compression capability <span class="target" id="index-48"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7457.html"><strong>RFC 7457</strong></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enterprises, privacy and TLS</p>
<p>By supporting only cipher suites that provide Perfect Forward Secrecy in TLS 1.3, the IETF aims at protecting the privacy of users against a wide range of attacks. However, this choice has resulted in intense debates in some enterprises. Some enterprises, notably in financial organizations, have deployed TLS, but wish to be able to decrypt TLS traffic for various security-related activities. These enterprises tried to lobby within the IETF to maintain RSA-based cipher suites that do not provide Perfect Forward Secrecy. Their arguments did not convince the IETF. Eventually, these enterprises moved to ETSI, another standardization body, and convinced them to adopt <cite>entreprise TLS</cite>, a variant of TLS 1.3 that does not provide Perfect Forward Secrecy <a class="reference internal" href="../bibliography.html#etls2018" id="id34"><span>[eTLS2018]</span></a>.</p>
</div>
<p>The TLS 1.3 handshake differs from the TLS 1.2 handshake in several ways. First, the TLS 1.3 handshake requires a single round-trip-time when the client connects for the first time to a server. To achieve this, the TLS designers look at the TLS 1.2 handshake in details and found that the first round-trip-time is mainly used to select the set of cryptographic algorithms and the cryptographic exchange scheme that will be used over the TLS session. TLS 1.3 drastically simplifies this negotiation by requiring to use the Diffie Hellman exchange with a small set of possible parameters. This means that the client can guess the parameters used by the server (i.e. the modulus, p and the base g) and immediately start the Diffie Hellman exchange. A simplified version of the TLS 1.3 handshake is shown in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/e5ae4c8c184c7b414c018f2972f772de.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#7c40afa8b5d3bc7ec147430dbd78098f688a7eb0" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-7c40afa8b5d3bc7ec147430dbd78098f688a7eb0.png"/>
<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0" name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"/></p>
</div></blockquote>
<p>There are several important differences with the TLS 1.2 handshake. First, the Diffie Hellman key exchange is required in TLS 1.3 and this exchange is initiated by the client (before having validated the server identity). To initiate the Diffie Hellman key exchange, the client needs to guess the modulus and the base that can be accepted by the server. Either the client uses standard parameters that most server supports or the client remembers the last modulus/base that it used with this particular server. If the client guessed incorrectly, the server replies with the parameters that it expects and one round-trip-time is lost. When the server sends its <cite>ServerHello</cite>, it already knows the session key. This implies that the server can encrypt all subsequent messages. After one round-trip-time, all data exchanged over the TLS 1.3 session is encrypted and authenticated. In TLS 1.3, the server certificate is encrypted with the session key, as well as the <cite>Finished</cite> message. The server signs the handshake to confirm that it owns the public key of its certificate. If the server wants to send application data, it can already encrypt it and send it to the client. Upon reception of the server Certificate, the client verifies it and checks the signature of the handshake and the <cite>Finished</cite> message. The client confirms the end of the handshake by sending its own <cite>Finished</cite> message. At that time, the client can send encrypted data. This means that the client only had to wait one round-trip-time before sending encrypted data. This is much faster than with TLS 1.2.</p>
<p>For some applications, waiting one round-trip-time before being able to send data is too long. TLS 1.3 allows the client to send encrypted data immediately after the <cite>ClientHello</cite>, without having to wait for the <cite>ServerHello</cite> message. At this point in the handshake, the client cannot know the key that will be derived by the Diffie Hellman key exchange. The trick is that the server and the client need to have previously agreed on a <cite>pre-shared-key</cite>. This key could be negotiated out of band, but usually it was exchanged over a previous TLS session between the client and the server. Both the client and the server can store this key in their cache. When the client creates a new TLS session to a server, it checks whether it already knows a pre-shared key for this server. If so, the client announces the identifier of this key in its <cite>ClientHello</cite> message. Thanks to this identifier, the server can recover the key and use it to decrypt the 0-rtt Encrypted record. A simplified version of the 0-rtt TLS 1.3 handshake <a class="footnote-reference brackets" href="#fhandshake" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> is shown in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/37315cb85580d2a0a41ccf2aa6b695ae.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c,server_conf=abcd]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;0-rtt Encrypted record&quot;, textcolour=&quot;magenta&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#04ec071344c2fae0632e2d690c2782c9017b631e" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-04ec071344c2fae0632e2d690c2782c9017b631e.png"/>
<map id="04ec071344c2fae0632e2d690c2782c9017b631e" name="04ec071344c2fae0632e2d690c2782c9017b631e"/></p>
</div></blockquote>
<p>On the web, TLS clients use certificates to authenticate servers but the clients are not authenticated. However, there are environments such as enterprise networks where servers may need to authenticate clients as well. A popular deployment is to authenticate remote clients who wish to access the enterprise network through a Virtual Private Network service. Some of these services run above TLS (or more precisely a variant of TLS named DTLS that runs above UDP <a class="reference internal" href="../bibliography.html#mor2004" id="id36"><span>[MoR2004]</span></a> but is outside the scope of this chapter). In such services, each client is authenticated thanks to a public key and a certificate that is trusted by the servers. To establish a TLS session, such a client needs to prove that it owns the public key associated with the certificate. This is done by the server thanks to the CertificateRequest message. The TLS handshake becomes the following one:</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/6b610706117d1538fe4793f16be928b1.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c,server_conf=abcd]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;0-rtt Encrypted record&quot;, textcolour=&quot;magenta&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;CertificateRequest, Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Certificate, Sign(Kc, Handshake), Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#36d37bda46d72f2f438e0e029b02b9c54e69fa82" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-36d37bda46d72f2f438e0e029b02b9c54e69fa82.png"/>
<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82" name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"/></p>
</div></blockquote>
<p>The server sends a CertificatRequest message. The client returns its certificate and signs the Handshake with is private key. This confirms to the server that the client owns the public key indicated in its certificate.</p>
<p>There are many more differences between TLS 1.2 and TLS 1.3. Additional details may be found in their respective specifications, <span class="target" id="index-49"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a> and <span class="target" id="index-50"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>.</p>
</section>
&#13;

<h3>The TLS handshake<a class="headerlink" href="#the-tls-handshake" title="Link to this heading">#</a></h3>
<p>When used to interact with a regular web server, the TLS handshake has
three important objectives:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Securely negotiate the cryptographic algorithms that will be used by the
client and the server over the TLS session</p></li>
<li><p>Verify that the client interacts with a valid server</p></li>
<li><p>Securely agree on the keys that will be used to encrypt and authenticate
the messages exchanged over the TLS session</p></li>
</ol>
</div></blockquote>
<p>The TLS handshake is a four-way handshake illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/300581e55a5559d21fa138b6759650ca.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random], Certificate&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Finished=MAC(MasterSecret||Handshake)&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, linecolour=&quot;red&quot;, textcolour=&quot;red&quot;];&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, linecolour=&quot;red&quot;, textcolour=&quot;red&quot;];&#10;}" usemap="#6851383dfd7cb6f84e42dde9992fdd9303de35d3" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-6851383dfd7cb6f84e42dde9992fdd9303de35d3.png"/>
<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3" name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"/></p>
</div></blockquote>
<p>In a nutshell, the client starts the TLS handshake by proposing a random nonce. The server replies with its random nonce and a certificate that binds its name to a public key. The client generates a MasterSecret that will be used later to derive the session keys and encrypts it with the public key of the server. It also generates a <cite>Finished</cite> message that contains a MAC of all the messages exchanged to allow the server to detect any modification of the messages sent by the client. The server also sends its own <cite>Finished</cite> message. At that point, the client and the server sent encrypted records thanks to the keys derived from the MasterSecret.</p>
<p id="index-33">Let us first discuss the negotiation of the cryptographic algorithms and
parameters. Like all security protocols, TLS includes some agility in its
design since new cryptographic algorithms appear over the years and
some older algorithms become deprecated once cryptanalysts find flaws.
The TLS handshakes starts with the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> message
that is sent by the client. This message carries the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Protocol version number</cite>: this is the version of the TLS protocol supported
by the client. The server should use the same version of the TLS protocol as
the client, but may opt for an older version. Both versions 1.2 and 1.3 of TLS are deployed today. Older versions are being deprecated.</p></li>
<li><p><cite>Random number</cite>: security protocols rely on random numbers. The client
sends a 32 bytes long random number where usually four of these bytes
correspond
to the client’s clock. This random number is used, together with the
server’s random number, as a seed to generate the security keys.</p></li>
<li><p><cite>Cipher suites</cite> : this ordered list contains the set of cryptographic
algorithms that are supported by the client, with the most preferred one
listed first. In contrast with <code class="docutils literal notranslate"><span class="pre">ssh</span></code> that allows negotiating independent
algorithms for encryption, key exchange and authentication, TLS relies on
suites that combine these algorithms together. Many cryptographic suites
have been defined for TLS. Various recommendations
have been published on the security of some of these suites <span class="target" id="index-34"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525</strong></a>.</p></li>
<li><p><cite>Compression algorithm</cite> : the client may propose the utilization of a
specific compression algorithm (e.g. zlib). In theory, compressing the data
before encrypting it is an intelligent way to reduce the amount of data
exchanged. Unfortunately, its implementation in TLS has caused several security problems <a class="reference internal" href="../bibliography.html#phg2013" id="id24"><span>[PHG2013]</span></a>. For
this reason, compression is usually disabled in TLS <span class="target" id="index-35"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525</strong></a>.</p></li>
<li><p><cite>Extensions</cite> : TLS supports various extensions in the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code>
message. These extensions <span class="target" id="index-36"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a> are important to allow the protocol
to evolve, but many of them go beyond the scope of this chapter.</p></li>
</ul>
</div></blockquote>
<div class="admonition note" id="index-37">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Server</span> <span class="pre">Name</span> <span class="pre">Indication</span> <span class="pre">(SNI)</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Server</span> <span class="pre">Name</span> <span class="pre">Indication</span> <span class="pre">(SNI)</span></code> extension defined in <span class="target" id="index-38"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a>
is an important TLS extension for web servers.
It is used by the client to indicate the name of the server
that it wishes to contact. The IP address associated to this name
has been queried from the DNS and used to establish the TCP connection.
Why should the client indicate the server name in the TLS
<code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> ?  The motivation is the same as for the <code class="docutils literal notranslate"><span class="pre">Host</span></code>
header line in HTTP/1.0. With the SNI extension, a single TLS server
can support several web sites that use different domain names. Thanks
to the SNI extension, the server knows the concerned domain name at
the start of the TLS session. Without this extension, hosting providers
would have been forced use one IP address per TLS-enabled server.</p>
</div>
<p id="index-39">The server replies to the <code class="docutils literal notranslate"><span class="pre">ClientHello</span></code> with several messages:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerHello</span></code> message that contains the protocol version chosen by
the server (assumed to be the same as the client version in this chapter),
the 32 random bytes chosen by the server, the <cite>Cipher Suite</cite> selected by
the server from the list advertised by the client
and a <cite>Session Id</cite>. This <cite>Session Id</cite> is an identifier which
is chosen by the server. It identifies the TLS session and the
security parameters (algorithms and keys) negotiated for this session.
It is used to support session resumption.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">Certificate</span></code> message provides the certificate (or usually a chain of
certificates) that binds a domain name to the public key used by
the server. TLS uses the server certificates
to authenticate the server. It relies on a Public Key Infrastructure that
is composed of a set of root certification authorities that
issue certificates to certification authorities that in the end
issue certificates to servers. TLS clients are usually configured with
the public keys of several root certification authorities and use
this information to validate the certificates that they receive from
servers. For historical reasons, the TLS certificates are encoded
in ASN.1 format. The details of the ASN.1 syntax <a class="reference internal" href="../bibliography.html#dubuisson2000" id="id25"><span>[Dubuisson2000]</span></a>
are outside the scope of this book.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message is used by the server to transmit the
information that is required to perform the key exchange. The content
of this message is function of the selected key exchange algorithm.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">ServerHelloDone</span></code> indicates that the server has sent all the messages
for the first phase of the handshake.</p></li>
</ul>
</div></blockquote>
<p id="index-40">At this point, it is time to describe the TLS key exchange. TLS supports
different key exchange mechanisms that can be negotiated as part of the
selection of the cipher suite. We focus on two of them to highlight
their differences:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSA</span></code>. This key exchange algorithm uses the encryption capabilities of
the RSA public-key algorithm. The client has validated the server’s
public key thanks to the <code class="docutils literal notranslate"><span class="pre">Certificate</span></code> message. It then generates
a (48 bytes) random number, encrypts it with the server public key
and sends the encrypted number to the server in the <code class="docutils literal notranslate"><span class="pre">ClientKeyExchange</span></code>
message. The server uses its private key to decrypt the random
number. At this point, the client and the server share the same
(48 bytes long) secret and use it to derive the secret keys required
to encrypt and authenticate data in the second phase. With this
key exchange algorithm, the server does not need to send a
<code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>. This key exchange algorithm is the Ephemeral Diffie Hellman
key exchange with RSA signatures to authenticate the key exchange. It
operates as a classical authenticated Diffie Hellman key exchange.
If this key exchange
has been selected by the server, it sends its Diffie Hellman parameters
in the <code class="docutils literal notranslate"><span class="pre">ServerKeyExchange</span></code> message and signs them with its private
key. The client then continues the key exchange and sends the results of
its own computation in the <code class="docutils literal notranslate"><span class="pre">ClientKeyExchange</span></code> message. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>
is thus an authenticated Diffie Hellman key exchange where the initial
message is sent by the server (instead of the client as in our first example
but since the protocol is symmetric, this does not matter).</p></li>
</ul>
</div></blockquote>
<p id="index-41">An important difference between <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> and <code class="docutils literal notranslate"><span class="pre">RSA</span></code> is their reaction
against attacks. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> is considered by many to be stronger than <code class="docutils literal notranslate"><span class="pre">RSA</span></code>
because it supports <cite>Perfect Forward Secrecy</cite>. This property is important
against attackers that are able to eavesdrop all the (encrypted) data
sent and received by a server. Consider that Terrence is such an attacker
that has stored all the packets exchanged by Bob’s server during the last
six months. If he manages, by any means, to obtain Bob’s private key, he
will be able to decrypt all the keys used to secure the TLS sessions with
Bob’s server during this period. With <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code>, a similar attack is
less devastating. If Terrence knows Bob’s private key, he will be able to launch
a man-in-the-middle attack against future TLS sessions with Bob’s server.
However, he will not be able to recover the keys used for all the past
sessions that he captured.</p>
<div class="admonition note" id="index-42">
<p class="admonition-title">Note</p>
<p>Perfect Forward Secrecy</p>
<p>Perfect Forward Secrecy (PFS) is an important property for key
exchange protocols. A protocol provides PFS if its design guarantees that
the keys used for former sessions will not be compromised even if the
private key of the server is compromised. This is a very important
property. <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> provides Perfect Forward Secrecy, but the
<code class="docutils literal notranslate"><span class="pre">RSA</span></code> key exchange does not provide this property. In practice,
<code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> is costly from a computational viewpoint. Recent implementations
of TLS thus prefer  <code class="docutils literal notranslate"><span class="pre">ECDHE_RSA</span></code> or <code class="docutils literal notranslate"><span class="pre">ECDHE_ECDSA</span></code> when
Perfect Forward Secrecy is required.</p>
</div>
<p>All the information required for the key exchange has now been transmitted.
There are two important messages that will be sent by the client and the server
to conclude the handshake and start the data transfer phase.</p>
<p>The client sends the <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message followed by the <code class="docutils literal notranslate"><span class="pre">Finished</span></code>
message. The <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message indicates that the client has received
all the information required to generate the security keys for this TLS
session. This messages can also appear later in the session to indicate a
change in the encryption algorithms that are used, but this usage is outside
the scope of this book. The <code class="docutils literal notranslate"><span class="pre">Finished</span></code> message is more important. It confirms
to the server that the TLS handshake has been performed correctly and that no
attacker has been able to modify the data sent by the client or the server.
This is the first message that is encrypted with the selected security keys.
It contains a hash of all the messages that were exchanged during the handshake.</p>
<p>The server also sends a <code class="docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code> message followed by a <code class="docutils literal notranslate"><span class="pre">Finished</span></code>
message.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>TLS Cipher suites</p>
<p>A TLS cipher suite is usually represented as an ASCII string
that starts with TLS and contains the acronym of the key exchange algorithm,
the encryption scheme with the key size and its mode of operation and
the authentication algorithm. For example,
<code class="docutils literal notranslate"><span class="pre">TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</span></code> is a TLS cipher suite that uses
the <code class="docutils literal notranslate"><span class="pre">DHE_RSA</span></code> key exchange algorithm with 128 bits AES in GCM mode for
encryption and SHA-256 for authentication. The official list of TLS
cipher suites is maintained by IANA <a class="footnote-reference brackets" href="#fianatls" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>. The NULL acronym
indicates that no algorithm has been specified. For example,
<code class="docutils literal notranslate"><span class="pre">TLS_ECDH_RSA_WITH_NULL_SHA</span></code> is a cipher suite that does not use
any encryption but still uses the <code class="docutils literal notranslate"><span class="pre">ECDH_RSA</span></code> key exchange and
<code class="docutils literal notranslate"><span class="pre">SHA</span></code> for authentication.</p>
</div>
&#13;

<h3>The TLS record protocol<a class="headerlink" href="#the-tls-record-protocol" title="Link to this heading">#</a></h3>
<p>The handshake is now finished. The client and the server will exchange
authenticated and encrypted records. TLS defines different formats for the
records depending on the cryptographic algorithms that have been negotiated
for the session. A detailed discussion of these different types of
records is outside the scope of this introduction. For illustration, we
briefly describe one record format.</p>
<p>As other security protocols, TLS uses different keys to encrypt and
authenticate records. These keys are derived from the MasterSecret that
is either randomly generated by the client after the <code class="docutils literal notranslate"><span class="pre">RSA</span></code> key exchange
or derived from the Diffie Hellman parameters after the <code class="docutils literal notranslate"><span class="pre">DH_RSA</span></code>
key exchange. The exact algorithm used to derive the keys is defined
in <span class="target" id="index-43"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a>.</p>
<p>A TLS record is always composed of four different fields :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>Type</cite> that indicates the type of record. The most frequent type
is <cite>application data</cite> which corresponds to a record containing encrypted
data. The other types are <cite>handshake</cite>, <cite>change_cipher_spec</cite> and
<cite>alert</cite>.</p></li>
<li><p>a <cite>Protocol Version</cite> field that indicates the version of the TLS protocol
used. This version is composed of two sub fields : a major and a
minor version number.</p></li>
<li><p>a <cite>Length</cite> field. A TLS record cannot be longer than 16,384 bytes.</p></li>
<li><p>a <cite>TLSPlainText</cite> that contains the encrypted data</p></li>
</ul>
</div></blockquote>
<p>TLS supports several methods to encrypted records. The selected
method depends on the cryptographic algorithms that have been negotiated for
the TLS session. A detailed presentation of the different methods that can
be used to produce the <cite>TLSPlainText</cite> from the user data is outside the scope
of this book. As an example, we study one method: Stream Encryption. This
method is used with cryptographic algorithms which can operate on a stream
of bytes. The method starts with a sequence of bytes provided by the
user application: the plain text. The first step is to compute the
authentication code to verify the integrity of the data. For this, TLS
computes <span class="math notranslate nohighlight">\(MAC(SeqNum, Header, PlainText)\)</span> using HMAC
where <cite>SeqNum</cite> is a sequence
number which is incremented by one for each new TLS record transmitted. The
<cite>Header</cite> is the header of the TLS record described above and <cite>PlainText</cite> is
the information that needs to be encrypted. Note that the sequence number
is maintained at the two endpoints of the TLS session, but it is not transmitted
inside the TLS record. This sequence number is used to prevent replay attacks.</p>
<div class="admonition note" id="index-44">
<p class="admonition-title">Note</p>
<p>MAC-then-encrypt or Encrypt-then-MAC</p>
<p>When secure protocols use Message Authentication and Encryption, they
need to specify how these two algorithms are combined. A first
solution, which is used by the current version of TLS, is to compute
the authentication code and then encrypt both the data and the
authentication code. A drawback of this approach is that the receiver
of an encrypted TLS record must first attempt to decrypt data that
has potentially been modified by an attacker before being able
to verify the authenticity of the record. A better approach is
for the sender to first encrypt the data and then compute the
authentication code over the encrypted data. This is the encrypt-then-MAC
approach proposed in <span class="target" id="index-45"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7366.html"><strong>RFC 7366</strong></a>. With encrypt-then-MAC, the receiver
first checks the authentication code before attempting to decrypt the
record.</p>
</div>
&#13;

<h3>Improving TLS<a class="headerlink" href="#improving-tls" title="Link to this heading">#</a></h3>
<p>During the last two decades, the deployment of TLS has continued to grow. The early TLS servers were only used for critical services such as e-commerce websites or online banks. As CPU performance improved, it became much more cost-effective to use TLS to secure non-critical parts of web servers, including the delivery of HTML pages and even video services. There is now a growing number of applications that rely on TLS <a class="reference internal" href="../bibliography.html#am2019" id="id27"><span>[AM2019]</span></a>.</p>
<p>In 2013, the statistics collected by the Firefox Telemetry project <a class="footnote-reference brackets" href="#ftelemetry" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> revealed that 30% of the web pages loaded by Firefox users were done over HTTPS. In October 2019, 80% of the web pages are loaded over HTTPS. In six years, HTTPS became the dominant protocol to access web services. Another look at the deployment of HTTPS on web sites may be found in <a class="reference internal" href="../bibliography.html#helme2019" id="id29"><span>[Helme2019]</span></a>.</p>
<p>Measurement studies that analyzed the evolution of TLS over the years have identified several important changes in the TLS ecosystem <a class="reference internal" href="../bibliography.html#kra2018" id="id30"><span>[KRA2018]</span></a>. First, the preferred cryptographic algorithms have changed. While RC4 was used by 60% of the connections in 2012, its usage has dropped since 2015. AES started to be deployed in 2013 and is now used for more than 90% of the connections. The deployed versions of TLS have also changed. TLS 1.0 and TLS 1.1 are now rarely used. The deployment of TLS 1.2 started in 2013 and reached 70% of the connections in 2015. Version 1.3 of TLS, that is described below, is also widely deployed.</p>
<p>Another interesting fact is the key exchange schemes. In 2012, RSA was the dominant solution, used by more than 80% of the observed connections <a class="reference internal" href="../bibliography.html#kra2018" id="id31"><span>[KRA2018]</span></a>. In 2013, Edward Snowden revealed the surveillance activities of several governments. These revelations had a huge impact on the Internet community. The IETF, which standardizes Internet protocols, considered in <span class="target" id="index-46"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7258.html"><strong>RFC 7258</strong></a> that such pervasive monitoring was an attack. Since then, several IETF working groups have developed solutions to counter pervasive monitoring. One of these solutions is to encourage <cite>Perfect Forward Security</cite>. Within TLS, this implies replacing RSA by an authenticated Diffie Hellman key exchange such as ECDHE. Measurements indicate
that since summer 2014, ECDHE is more popular than RSA. In 2018, more than 90% of the observed TLS connections used ECDHE.</p>
<p>The last point is the difficulty of deploying TLS servers <a class="reference internal" href="../bibliography.html#kms2017" id="id32"><span>[KMS2017]</span></a>. When TLS servers are installed, the system administrator needs to obtain certificates and configure a range of servers. Initially, getting certificates was complex and costly, but initiatives such as <a class="reference external" href="https://letsencrypt.org">https://letsencrypt.org</a> have simplified this workflow.</p>
<p>In 2014, the IETF TLS working started to work on the development of version 1.3 of the TLS protocol. Their main objectives <a class="reference internal" href="../bibliography.html#rescorla2015" id="id33"><span>[Rescorla2015]</span></a> for this new version were:</p>
<blockquote>
<div><ul class="simple">
<li><p>simplify the design by removing unused or unsafe protocol features</p></li>
<li><p>improve the security of TLS by leveraging the lessons learned from TLS 1.2 and some documented attacks</p></li>
<li><p>improve the privacy of the protocol</p></li>
<li><p>reduce the latency of TLS</p></li>
</ul>
</div></blockquote>
<p>Since 2014, latency has become an important concern for web services. As access networks bandwidth continue to grow, latency is becoming a key factor that affects the performance of interactive web services. With TLS 1.2, the download of a web page requires a minimum of four round-trip-times, one to create the underlying TCP connection, one to exchange the ClientHello/ServerHello, one to exchange the keys and then one to send the HTTP GET and retrieve the response. This can be very long when the server is not near the client. TLS 1.3 aimed at reducing this handshake to one round-trip-time and even zero by placing some of the cryptographic handshake in the TCP handshake. This part will be discussed in the TCP chapter. We focus here on the reducing the TLS handshake to a single round-trip-time.</p>
<p>To simplify both the design and the implementations, TLS 1.3 uses only a small number of cipher suites. Five of them are specified in <span class="target" id="index-47"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a> and <code class="docutils literal notranslate"><span class="pre">TLS_AES_128_GCM_SHA256</span></code> must be supported by all implementations. To ensure privacy, all cipher suites that did not provide Perfect Forward Secrecy have been removed. Compression has also been removed from TLS since several attacks on TLS 1.2 exploited its compression capability <span class="target" id="index-48"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7457.html"><strong>RFC 7457</strong></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enterprises, privacy and TLS</p>
<p>By supporting only cipher suites that provide Perfect Forward Secrecy in TLS 1.3, the IETF aims at protecting the privacy of users against a wide range of attacks. However, this choice has resulted in intense debates in some enterprises. Some enterprises, notably in financial organizations, have deployed TLS, but wish to be able to decrypt TLS traffic for various security-related activities. These enterprises tried to lobby within the IETF to maintain RSA-based cipher suites that do not provide Perfect Forward Secrecy. Their arguments did not convince the IETF. Eventually, these enterprises moved to ETSI, another standardization body, and convinced them to adopt <cite>entreprise TLS</cite>, a variant of TLS 1.3 that does not provide Perfect Forward Secrecy <a class="reference internal" href="../bibliography.html#etls2018" id="id34"><span>[eTLS2018]</span></a>.</p>
</div>
<p>The TLS 1.3 handshake differs from the TLS 1.2 handshake in several ways. First, the TLS 1.3 handshake requires a single round-trip-time when the client connects for the first time to a server. To achieve this, the TLS designers look at the TLS 1.2 handshake in details and found that the first round-trip-time is mainly used to select the set of cryptographic algorithms and the cryptographic exchange scheme that will be used over the TLS session. TLS 1.3 drastically simplifies this negotiation by requiring to use the Diffie Hellman exchange with a small set of possible parameters. This means that the client can guess the parameters used by the server (i.e. the modulus, p and the base g) and immediately start the Diffie Hellman exchange. A simplified version of the TLS 1.3 handshake is shown in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/e5ae4c8c184c7b414c018f2972f772de.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#7c40afa8b5d3bc7ec147430dbd78098f688a7eb0" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-7c40afa8b5d3bc7ec147430dbd78098f688a7eb0.png"/>
<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0" name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"/></p>
</div></blockquote>
<p>There are several important differences with the TLS 1.2 handshake. First, the Diffie Hellman key exchange is required in TLS 1.3 and this exchange is initiated by the client (before having validated the server identity). To initiate the Diffie Hellman key exchange, the client needs to guess the modulus and the base that can be accepted by the server. Either the client uses standard parameters that most server supports or the client remembers the last modulus/base that it used with this particular server. If the client guessed incorrectly, the server replies with the parameters that it expects and one round-trip-time is lost. When the server sends its <cite>ServerHello</cite>, it already knows the session key. This implies that the server can encrypt all subsequent messages. After one round-trip-time, all data exchanged over the TLS 1.3 session is encrypted and authenticated. In TLS 1.3, the server certificate is encrypted with the session key, as well as the <cite>Finished</cite> message. The server signs the handshake to confirm that it owns the public key of its certificate. If the server wants to send application data, it can already encrypt it and send it to the client. Upon reception of the server Certificate, the client verifies it and checks the signature of the handshake and the <cite>Finished</cite> message. The client confirms the end of the handshake by sending its own <cite>Finished</cite> message. At that time, the client can send encrypted data. This means that the client only had to wait one round-trip-time before sending encrypted data. This is much faster than with TLS 1.2.</p>
<p>For some applications, waiting one round-trip-time before being able to send data is too long. TLS 1.3 allows the client to send encrypted data immediately after the <cite>ClientHello</cite>, without having to wait for the <cite>ServerHello</cite> message. At this point in the handshake, the client cannot know the key that will be derived by the Diffie Hellman key exchange. The trick is that the server and the client need to have previously agreed on a <cite>pre-shared-key</cite>. This key could be negotiated out of band, but usually it was exchanged over a previous TLS session between the client and the server. Both the client and the server can store this key in their cache. When the client creates a new TLS session to a server, it checks whether it already knows a pre-shared key for this server. If so, the client announces the identifier of this key in its <cite>ClientHello</cite> message. Thanks to this identifier, the server can recover the key and use it to decrypt the 0-rtt Encrypted record. A simplified version of the 0-rtt TLS 1.3 handshake <a class="footnote-reference brackets" href="#fhandshake" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a> is shown in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/37315cb85580d2a0a41ccf2aa6b695ae.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c,server_conf=abcd]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;0-rtt Encrypted record&quot;, textcolour=&quot;magenta&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#04ec071344c2fae0632e2d690c2782c9017b631e" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-04ec071344c2fae0632e2d690c2782c9017b631e.png"/>
<map id="04ec071344c2fae0632e2d690c2782c9017b631e" name="04ec071344c2fae0632e2d690c2782c9017b631e"/></p>
</div></blockquote>
<p>On the web, TLS clients use certificates to authenticate servers but the clients are not authenticated. However, there are environments such as enterprise networks where servers may need to authenticate clients as well. A popular deployment is to authenticate remote clients who wish to access the enterprise network through a Virtual Private Network service. Some of these services run above TLS (or more precisely a variant of TLS named DTLS that runs above UDP <a class="reference internal" href="../bibliography.html#mor2004" id="id36"><span>[MoR2004]</span></a> but is outside the scope of this chapter). In such services, each client is authenticated thanks to a public key and a certificate that is trusted by the servers. To establish a TLS session, such a client needs to prove that it owns the public key associated with the certificate. This is done by the server thanks to the CertificateRequest message. The TLS handshake becomes the following one:</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/6b610706117d1538fe4793f16be928b1.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Client&quot;,linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Server&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;b&gt;&gt;c [ label = &quot;ClientHello[Random, g^c,server_conf=abcd]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;0-rtt Encrypted record&quot;, textcolour=&quot;magenta&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;&#10;c&gt;&gt;b [ label = &quot;ServerHello[Random, g^s]&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;c&gt;&gt;b [ label = &quot;CertificateRequest, Certificate, Sign(K,Handshake), Finished, Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Certificate, Sign(Kc, Handshake), Finished&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;c&gt;&gt;b [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;b&gt;&gt;c [ label = &quot;Encrypted Record&quot;, textcolour=&quot;red&quot;, linecolour=&quot;red&quot;, arcskip=&quot;2&quot;];&#10;|||;&#10;|||;&#10;}" usemap="#36d37bda46d72f2f438e0e029b02b9c54e69fa82" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-36d37bda46d72f2f438e0e029b02b9c54e69fa82.png"/>
<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82" name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"/></p>
</div></blockquote>
<p>The server sends a CertificatRequest message. The client returns its certificate and signs the Handshake with is private key. This confirms to the server that the client owns the public key indicated in its certificate.</p>
<p>There are many more differences between TLS 1.2 and TLS 1.3. Additional details may be found in their respective specifications, <span class="target" id="index-49"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a> and <span class="target" id="index-50"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8446.html"><strong>RFC 8446</strong></a>.</p>
&#13;

<span id="dnssec"/><h2>Securing the Domain Name System<a class="headerlink" href="#securing-the-domain-name-system" title="Link to this heading">#</a></h2>
<p>The Domain Name System provides a critical service in the Internet
infrastructure since it maps the domain names that are used by end users
onto IP addresses. Since end users rely on names to identify the servers
that they connect to, any incorrect information distributed by the DNS
would direct end users’ connections to invalid destinations. Unfortunately,
several attacks of this kind occurred in the past. A detailed analysis
of the security threats against the DNS appeared in <span class="target" id="index-51"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3833.html"><strong>RFC 3833</strong></a>. We consider
three of these threats in this section and leave the others to <span class="target" id="index-52"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3833.html"><strong>RFC 3833</strong></a>.</p>
<p>The first type of attack is <cite>eavesdropping</cite>. An attacker who can capture
packets sent to a DNS resolver or a DNS server can gain valuable information
about the DNS names that are used by a given end user. If the attacker can
capture all the packets sent to a DNS resolver, he/she can collect a lot of
meta data about the domain names used by the end user. Preventing this type
of attack has not been an objective of the initial design of the DNS.
There are currently discussions with the IETF to carry DNS messages over
TLS sessions to protect against such attacks. However, these solutions
are not yet widely deployed.</p>
<p>The second type of attack is the <cite>man-in-the-middle</cite> attack. Consider that
Alice is sending DNS requests to her DNS resolver. Unfortunately, Mallory
sits in front of this resolver and can capture and modify all the packets
sent by Alice to her resolver. In this case, Mallory can easily modify
the DNS responses sent by the resolver to redirect Alice’s packets to
a different IP address controlled by Mallory. This enables Mallory
to observe (and possibly modify) all the packets sent and received by
Alice. In practice, executing this attack is not simple since DNS resolvers
are usually installed in protected datacenters. However, if Mallory controls
the WiFi access point that Alice uses to access the Internet, he could easily
modify the packets on this access point and some software packages
automate this type of attacks.</p>
<p>If Mallory cannot control a router on the path
between Alice and her resolver, she could still launch a different attack.
To understand this attack, it is important to correctly understand how
the DNS protocol operates and the roles of the different fields of
the DNS header which is reproduced in <a class="reference internal" href="#fig-dns-header2"><span class="std std-numref">Fig. 46</span></a>.</p>
<figure class="align-center" id="id39">
<span id="fig-dns-header2"/><a class="reference internal image-reference" href="../_images/dnsheader.svg"><img alt="../_images/dnsheader.svg" src="../Images/21a7bad41190434264bf8afe39a2de6a.png" style="width: 445.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/dnsheader.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 46 </span><span class="caption-text">DNS header</span><a class="headerlink" href="#id39" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The first field of the header is the <cite>Identification</cite> field. When Alice
sends a DNS request, she places a 16-bits integer in this field and
remembers it. When she receives a response, she uses this <cite>Identification</cite>
field to locate the initial DNS request that she sent. The response is
only used if its <cite>Identification</cite> matches a pending DNS request (containing
the same question).</p>
<p id="index-53">Mallory has studied the DNS protocol and understands how it works. If he
can predict a popular domain for which Alice will regularly send DNS requests,
then he can prepare a set of DNS responses that map the name requested
by Alice to an IP address controlled by Mallory instead of the legitimate
DNS response. Each DNS response has a different <cite>Identification</cite>. Since there
are only 65,536 values for the <cite>Identification</cite> field, it is possible
for Mallory to
send them to Alice hoping that one of them will be received while Alice
is waiting for a DNS response with the same identifier. In the past,
it was difficult to send 65,536 DNS responses quickly enough. However, with
the high speed links that are available today, this is not an issue anymore.
A second concern for Mallory is that he must be able to send
the DNS responses as if they were coming directly from the DNS resolver.
This implies that Mallory must be able to send IP packets that appear to
originate from a different address. Although networks should be configured
to prevent this type of attack, this is not always the case and there
are networks where it is possible for a host to send packets with a
different source IP address <a class="footnote-reference brackets" href="#fspoof" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. If the attack targets a single
end user, e.g. Alice, this is annoying for this user. However, if the
attacker can target a DNS resolver that serves an entire company or an
entire ISP, the impact of the attack can be much larger in particular if
the injected DNS response carries a long TTL and thus resides in the
resolver’s cache for a long period of time.</p>
<p>Fortunately, designers of DNS servers and resolvers have found solutions to mitigate this type
of attack. The easiest approach would have been to update the format of the
DNS requests and responses to include a larger <cite>Identifier</cite> field.
Unfortunately, this elegant solution was not possible with the DNS because
the DNS messages do not include any version number that would have enabled
such a change. Since the DNS messages are exchanged inside UDP segments,
the DNS developers found an alternate solution to counter this attack.
There are two ways for the DNS library used by Alice to send her DNS requests.
A first solution is to bind one UDP source port and always send the
DNS requests from this source port (the destination port is always port
<code class="docutils literal notranslate"><span class="pre">53</span></code>). The advantage of this solution is that Alice’s DNS library can
easily receive the DNS responses by listening to her chosen port.
Unfortunately, once the attacker has found the source port used by Alice,
he only needs to send 65,536 DNS responses to inject an invalid response.
Fortunately, Alice can send her DNS requests in a different way. Instead
of using the same source port for all DNS requests, she can use a different
source port for each request. In practice, each DNS request will be sent
from a different source port. From an implementation viewpoint, this
implies that Alice’s DNS library will need to listen to one different port
number for each pending DNS request. This increases the complexity of
her implementation. From a security viewpoint there is a clear benefit
since the attacker needs to guess both the 16 bits <cite>Identifier</cite> and the
16 bits <cite>UDP source port</cite> to inject a fake DNS response. To generate all
possible DNS responses, the attacker would need to generate almost
<span class="math notranslate nohighlight">\(2^{32}\)</span> different messages, which is excessive in today’s networks.
Most DNS implementations use this second approach to prevent these cache
poisoning attacks.</p>
<p>These attacks affect the DNS messages that are exchanged between a client
and its resolver or between a resolver and name servers. Another type of
attack exploits the possibility of providing several resource records inside
one DNS response. A frequent optimization used by DNS servers and resolvers
is to include several related resource records in each response. For
example, if a client sends a DNS query for an <cite>NS</cite> record, it usually
receives in the response both the queried record, i.e. the name of
the DNS server that serves the queried domain, and the IP addresses of this
server. Some DNS servers return several <cite>NS</cite> records and the associated IP
addresses. The <cite>cache poisoning</cite> attack exploits this DNS optimization.</p>
<p>Let us illustrate it on an example.
Assume that Alice frequently uses the <cite>example.net</cite> domain and in
particular the
web server whose name is <cite>www.example.net</cite>. Mallory would like to redirect
the TCP connections established by Alice towards <cite>www.example.net</cite> to one
IP address that he controls. Assume that Mallory controls the
<cite>mallory.net</cite> domain. Mallory can tune the DNS server of his domain and add
special DNS records to the responses that it sends. An attack could go
roughly as follows. Mallory forces Alice to visit the <cite>www.mallory.net</cite> web
site. He can achieve this by sending a spam message to Alice or buying
advertisements on a web site visited by Alice and redirect one of these
advertisements to <cite>www.mallory.net</cite>. When visiting the advertisement, Alice’s
DNS resolver will send a DNS request for <cite>www.mallory.net</cite>. Since Mallory
control the DNS server, he can easily add in the response a <cite>AAAA</cite>
record that associates <cite>www.example.net</cite> to the IP address controlled by
Mallory. If Alice’s DNS library does not check the returned response,
the cache entry for <cite>www.example.net</cite> will be replaced by the <cite>AAAA</cite> record
sent by Mallory.</p>
<p>To cope with these security threats and improve the security of the
DNS, the IETF has defined several extensions that are known as DNSSEC.
DNSSEC exploits public-key cryptography to authenticate the content
of the DNS records that are sent by DNS servers and resolvers. DNSEC is
defined in three main documents <span class="target" id="index-54"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4033.html"><strong>RFC 4033</strong></a>, <span class="target" id="index-55"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4034.html"><strong>RFC 4034</strong></a>, <span class="target" id="index-56"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4035.html"><strong>RFC 4035</strong></a>.
With DNSSEC, each DNS zone uses one public-private key pair. This key pair
is only used to sign and authenticate DNS records. The DNS records are
not encrypted and DNSSEC does not provide any confidentiality. Other DNS
extensions are being developed to ensure the confidentiality of the
information exchanged between a client and its resolvers <span class="target" id="index-57"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7626.html"><strong>RFC 7626</strong></a>.
Some of these extensions exchange DNS records over a TLS session which
provides the required confidentiality, but they are not yet deployed
and outside the scope of this chapter.</p>
<p>DNSSEC defines four new types of DNS records that are used together to
authenticate the information distributed by the DNS.</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>DNSKEY</cite> record allows storing the public key associated with
a zone. This record is encoded as a TLV and includes a <cite>Base64</cite>
representation of the key and the identification of the public key
algorithm. This allows the <cite>DNSKEY</cite> record to support different public
key algorithms.</p></li>
<li><p>the <cite>RRSIG</cite> record is used to encode the signature of a DNS record. This
record contains several sub-fields. The most important ones are the
algorithm used to generate the signature, the identifier of the public
key used to sign the record, the original TTL of the signed record and
the validity period for the signature.</p></li>
<li><p>the <cite>DS</cite> record contains a hash of a public key. It is used by a parent
zone to certify the public key used by one of its child zones.</p></li>
<li><p>the <cite>NSEC</cite> record is used when non-existent domain names are queried.
Its usage will be explained later</p></li>
</ul>
</div></blockquote>
<p>The simplest way to understand the operation of DNSSEC is to rely on a simple
example. Let us consider the <cite>example.org</cite> domain and assume that Alice
wants to retrieve the <cite>AAAA</cite> record for <cite>www.example.org</cite> using DNSSEC.</p>
<p id="index-58">The security of DNSSEC relies on <cite>anchored keys</cite>. An <cite>anchored key</cite> is a
public key that is considered as trusted by a resolver. In our example,
we assume that Alice’s resolver has obtained the public key of the servers
that manage the root zone in a secure way. This key
has been distributed outside of the DNS, e.g. it has been published in a
newspaper or has been received in a sealed letter.</p>
<p>To obtain an authenticated record for <cite>www.example.org</cite>, Alice’s resolver
first needs to retrieve the <cite>NS</cite> which is responsible for the <cite>.org</cite>
Top-Level Domain (TLD). This record is served by the DNS root server
and Alice’s resolver can retrieve the signature (<cite>RRSIG</cite> record) for this
<cite>NS</cite> record. Since Alice knows the <cite>DNSKEY</cite> of the root, she can verify
the validity of this signature.</p>
<p>The next step is to contact <cite>ns.org</cite>, the <cite>NS</cite> responsible for
the <cite>.org</cite> TLD to retrieve the <cite>NS</cite> record for the <cite>example.org</cite> domain.
This record is accompanied by a <cite>RRSIG</cite> record that authenticates it. This
<cite>RRSIG</cite> record is signed with the key of the <cite>.org</cite> domain. Alice’s resolver
can retrieve this public key as the <cite>DNSKEY</cite> record for the <cite>.org</cite>, but how
can it trust this key since it is distributed by using the DNS and
could have been modified by attackers ? DNSSEC solves this problem by
using the <cite>DS</cite> record that is stored in the parent zone (in this case,
the root zone). This record contains a hash of a public key that
is signed with a <cite>RRSIG</cite> signature. Since Alice’s resolver’s
trusts the root key, it can validate the signature of the <cite>DS</cite> record
for the <cite>.org</cite> domain. It can then retrieve the <cite>DNSKEY</cite> record for this
domain from the DNS and compare the hash of this key with the <cite>DS</cite> record.
If they match, the public key of the <cite>.org</cite> domain can be trusted.
The same technique is used to obtain and validate the key of
the <cite>example.org</cite> domain. Once this key is trusted, Alice’s resolver
can request the <cite>AAAA</cite> record for <cite>www.example.org</cite> and validate its
signature.</p>
<p>Thanks to the <cite>DS</cite> record, a resolver can validate the public keys of client
zones as long as their is a chain of <cite>DS</cite> -&gt; <cite>DNSKEY</cite> records from an
anchored key. If the resolver trusts the public key of the root zone, it
can validate all DNS replies for which this chain exists.</p>
<p>There are several details of the operation of DNSSEC that are worth
being discussed. First, a server that supports DNSSEC must have a
public-private key pair. The public key is distributed with the
<cite>DNSKEY</cite> record. The private key is never distributed and it does not
even need to be stored on the server that uses the public key. DNSSEC does
not require the DNSSEC servers to perform any operation that requires
a private key in real time. All the <cite>RRSIG</cite> records can be computed
offline, possibly on a different server than the server that returns
the DNSSEC replies. The initial motivation for this design choice was
the CPU complexity of computing the <cite>RRSIG</cite> signatures for zones that
contain millions of records. In the early days of DNSSEC, this was an
operational constraint. Today, this is less an issue, but avoiding
costly signature operations in real time has two important benefits.
First, this reduces the risk of denial of service attacks since an attacker
cannot force a DNSSEC server to perform computationally intensive signing
operations. Second, the private key can be stored offline, which means that
even if an attacker gains access to the DNSSEC server, it cannot retrieve
its private key. Using offline signatures for the <cite>RRSIG</cite> records has some
practical implications that are reflected in the content of this
record. First, each <cite>RRSIG</cite> record contains the original TTL of the
signed record.
When DNS resolvers cache records, they change the value of the TTL of
these cached records and then return the modified records to their clients.
When a resolver receives a signed DNS record, it must replace the
received TTL of the record with the original TTL (and check that the
received TTL is smaller than the original one) before checking the
signature. Second, the <cite>RRSIG</cite> records contain a validity period, i.e.
a starting time and an ending time for the validity of the signature. This
period is specified as two timestamps. This period is only the
validity of the signature. It does not affect the TTL of the signed record
and is independent from the TTL. In practice, the validity period is
important to allow DNS server operators to update their public/private
keys. When such a key is changed, e.g. because the private could have been
compromised, there is some period of time during which records signed
with the two keys coexist in the network. The validity period allows
ensuring that old signatures do not remain in DNS caches for ever.</p>
<p id="index-59">The last record introduced by DNSSEC is the <cite>NSEC</cite> record. It is used to
authenticate a negative response returned by a DNS server. If a resolver
requests a domain name that is not defined in the zone, the server
replies with an error message. The designers of the original version
of the DNS thought that these errors would not be very frequent
and resolvers were not required to cache those negative responses.
However, operational experience showed that queries for invalid domain
names are more frequent than initially expected and a large fraction
of the load on some servers is caused by repeated queries for invalid
names. Typical examples include queries for invalid TLDs to the root
DNS servers or queries caused by configuration errors <a class="reference internal" href="../bibliography.html#wf2003" id="id38"><span>[WF2003]</span></a>.
Current DNS deployments allow resolvers to cache those negative answers
to reduce the load on the entire DNS <span class="target" id="index-60"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2308.html"><strong>RFC 2308</strong></a>.</p>
<p>The simplest way to allow a DNSSEC server to return signed negative responses
would be for the server to return a signed response that contains the
received query and some information indicating the error.
The client could then easily check the validity of the negative response.
Unfortunately, this would force the DNSSEC server to generate signatures
in real time. This implies that the private key must be stored in the
server memory, which leads to risks if an attacker can take control
of the server. Furthermore, those signatures are computationally complex
and a simple denial of service attack would be to send invalid queries
to a DNSSEC server.</p>
<p>Given the above security risks, DNSSEC opted for a different approach that
allows the negative replies to be authenticated by using offline signatures.
The <cite>NSEC</cite> record exploits the lexicographical ordering of all the domain
names. To understand its usage, consider a simple domain that contains
three names (the associated <cite>AAAA</cite> and other records that are not
shown) :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">alpha.example.org</span>
<span class="go">beta.example.org</span>
<span class="go">gamma.example.org</span>
</pre></div>
</div>
<p>In this domain, the DNSSEC server adds three <cite>NSEC</cite> records. A <cite>RRSIG</cite>
signature is also computed for each of these records.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="go">alpha.example.org</span>
<span class="go">alpha.example.org NSEC beta.example.org</span>

<span class="go">beta.example.org</span>
<span class="go">beta.example.org NSEC gamma.example.org</span>

<span class="go">gamma.example.org</span>
<span class="go">gamma.example.org NSEC alpha.example.org</span>
</pre></div>
</div>
<p>If a resolver queries <cite>delta.example.org</cite>, the server will parse its
zone. If this name were present, it would have been placed, in lexicographical
order, between the <cite>beta.example.org</cite> and the <cite>gamma.example.org</cite> names.
To confirm that the <cite>delta.example.org</cite> name does not exist, the server
returns the <cite>NSEC</cite> record for <cite>beta.example.org</cite> that indicates that the
next valid name after <cite>beta.example.org</cite> is <cite>gamma.example.org</cite>. If
the server receives a query for <cite>pi.example.org</cite>, this is the <cite>NSEC</cite> record
for <cite>gamma.example.org</cite> that will be returned. Since this record
contains a name that is before <cite>pi.example.org</cite> in lexicographical
order, this indicates that <cite>pi.example.org</cite> does not exist.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fpasswords" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The wikipedia page on passwords provides many of these references :
<a class="reference external" href="https://en.wikipedia.org/wiki/Password_strength">https://en.wikipedia.org/wiki/Password_strength</a></p>
</aside>
<aside class="footnote brackets" id="frsa" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">2</a><span class="fn-bracket">]</span></span>
<p>A detailed explanation of the operation of the RSA algorithm is
outside the scope of this e-book. Various tutorials such as the
<a class="reference external" href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA page</a>
on wikipedia provide examples and tutorial information.</p>
</aside>
<aside class="footnote brackets" id="fecc" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">3</a><span class="fn-bracket">]</span></span>
<p>A detailed explanation of the ECC cryptosystems is outside the
scope of this e-book. A simple introduction may be found on
<a class="reference external" href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Andrea Corbellini’s blog</a>. There have been deployments of ECC recently because
ECC schemes usually require shorter keys than RSA and consume less
CPU.</p>
</aside>
<aside class="footnote brackets" id="fnull" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">4</a><span class="fn-bracket">]</span></span>
<p>For some of the algorithms, it is possible to negotiate the
utilization of no algorithm. This happens frequently for the
compression algorithm that is not always used. For this,
both the client and the server must announce <code class="docutils literal notranslate"><span class="pre">null</span></code>
in their ordered list of supported algorithms.</p>
</aside>
<aside class="footnote brackets" id="fdnsssh" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">5</a><span class="fn-bracket">]</span></span>
<p>For example, <span class="target" id="index-61"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4255.html"><strong>RFC 4255</strong></a> describes a DNS record that can be
used to associate an <code class="docutils literal notranslate"><span class="pre">ssh</span></code> fingerprint to a DNS name.</p>
</aside>
<aside class="footnote brackets" id="fsshkeys" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">6</a><span class="fn-bracket">]</span></span>
<p>The exact algorithms used for the computation of these
keys are defined in <span class="target" id="index-62"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4253.html"><strong>RFC 4253</strong></a></p>
</aside>
<aside class="footnote brackets" id="fianatls" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">7</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4</a></p>
</aside>
<aside class="footnote brackets" id="fhandshake" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id35">8</a><span class="fn-bracket">]</span></span>
<p>A detailed explanation of the TLS 1.3 handshake may be found at <a class="reference external" href="https://tls13.ulfheim.net/">https://tls13.ulfheim.net/</a></p>
</aside>
<aside class="footnote brackets" id="ftelemetry" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">9</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="https://letsencrypt.org/stats/">https://letsencrypt.org/stats/</a> for a graph and <a class="reference external" href="https://docs.telemetry.mozilla.org/datasets/other/ssl/reference.html">https://docs.telemetry.mozilla.org/datasets/other/ssl/reference.html</a> for additional information on the dataset</p>
</aside>
<aside class="footnote brackets" id="fspoof" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">10</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://spoofer.caida.org/summary.php">http://spoofer.caida.org/summary.php</a> for an ongoing measurement study that analyses the networks where an attacker could send packets with any source IP address.</p>
</aside>
</aside>
    
</body>
</html>