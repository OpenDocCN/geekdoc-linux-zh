["```sh cat $filename >/dev/null\n# Contents of the file will not list to stdout.\n```", "```sh rm $badname 2>/dev/null\n#           So error messages [stderr] deep-sixed.\n```", "```sh cat $filename 2>/dev/null >/dev/null\n# If \"$filename\" does not exist, there will be no error message output.\n# If \"$filename\" does exist, the contents of the file will not list to stdout.\n# Therefore, no output at all will result from the above line of code.\n#\n#  This can be useful in situations where the return code from a command\n#+ needs to be tested, but no output is desired.\n#\n# cat $filename &>/dev/null\n#     also works, as Baris Cicek points out.\n```", "```sh cat /dev/null > /var/log/messages\n#  : > /var/log/messages   has same effect, but does not spawn a new process.\n\ncat /dev/null > /var/log/wtmp\n```", "```sh # Obsolete Netscape browser.\n# Same principle applies to newer browsers.\n\nif [ -f ~/.netscape/cookies ]  # Remove, if exists.\nthen\n  rm -f ~/.netscape/cookies\nfi\n\nln -s /dev/null ~/.netscape/cookies\n# All cookies now get sent to a black hole, rather than saved to disk.\n```", "```sh #!/bin/bash\n# Creating a swap file.\n\n#  A swap file provides a temporary storage cache\n#+ which helps speed up certain filesystem operations.\n\nROOT_UID=0         # Root has $UID 0.\nE_WRONG_USER=85    # Not root?\n\nFILE=/swap\nBLOCKSIZE=1024\nMINBLOCKS=40\nSUCCESS=0\n\n# This script must be run as root.\nif [ \"$UID\" -ne \"$ROOT_UID\" ]\nthen\n  echo; echo \"You must be root to run this script.\"; echo\n  exit $E_WRONG_USER\nfi  \n\nblocks=${1:-$MINBLOCKS}          #  Set to default of 40 blocks,\n                                 #+ if nothing specified on command-line.\n# This is the equivalent of the command block below.\n# --------------------------------------------------\n# if [ -n \"$1\" ]\n# then\n#   blocks=$1\n# else\n#   blocks=$MINBLOCKS\n# fi\n# --------------------------------------------------\n\nif [ \"$blocks\" -lt $MINBLOCKS ]\nthen\n  blocks=$MINBLOCKS              # Must be at least 40 blocks long.\nfi  \n\n######################################################################\necho \"Creating swap file of size $blocks blocks (KB).\"\ndd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks  # Zero out file.\nmkswap $FILE $blocks             # Designate it a swap file.\nswapon $FILE                     # Activate swap file.\nretcode=$?                       # Everything worked?\n#  Note that if one or more of these commands fails,\n#+ then it could cause nasty problems.\n######################################################################\n\n#  Exercise:\n#  Rewrite the above block of code so that if it does not execute\n#+ successfully, then:\n#    1) an error message is echoed to stderr,\n#    2) all temporary files are cleaned up, and\n#    3) the script exits in an orderly fashion with an\n#+      appropriate error code.\n\necho \"Swap file created and activated.\"\n\nexit $retcode\n```", "```sh #!/bin/bash\n# ramdisk.sh\n\n#  A \"ramdisk\" is a segment of system RAM memory\n#+ which acts as if it were a filesystem.\n#  Its advantage is very fast access (read/write time).\n#  Disadvantages: volatility, loss of data on reboot or powerdown,\n#+                less RAM available to system.\n#\n#  Of what use is a ramdisk?\n#  Keeping a large dataset, such as a table or dictionary on ramdisk,\n#+ speeds up data lookup, since memory access is much faster than disk access.\n\nE_NON_ROOT_USER=70             # Must run as root.\nROOTUSER_NAME=root\n\nMOUNTPT=/mnt/ramdisk           # Create with mkdir /mnt/ramdisk.\nSIZE=2000                      # 2K blocks (change as appropriate)\nBLOCKSIZE=1024                 # 1K (1024 byte) block size\nDEVICE=/dev/ram0               # First ram device\n\nusername=`id -nu`\nif [ \"$username\" != \"$ROOTUSER_NAME\" ]\nthen\n  echo \"Must be root to run \\\"`basename $0`\\\".\"\n  exit $E_NON_ROOT_USER\nfi\n\nif [ ! -d \"$MOUNTPT\" ]         #  Test whether mount point already there,\nthen                           #+ so no error if this script is run\n  mkdir $MOUNTPT               #+ multiple times.\nfi\n\n##############################################################################\ndd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE  # Zero out RAM device.\n                                                      # Why is this necessary?\nmke2fs $DEVICE                 # Create an ext2 filesystem on it.\nmount $DEVICE $MOUNTPT         # Mount it.\nchmod 777 $MOUNTPT             # Enables ordinary user to access ramdisk.\n                               # However, must be root to unmount it.\n##############################################################################\n# Need to test whether above commands succeed. Could cause problems otherwise.\n# Exercise: modify this script to make it safer.\n\necho \"\\\"$MOUNTPT\\\" now available for use.\"\n# The ramdisk is now accessible for storing files, even by an ordinary user.\n\n#  Caution, the ramdisk is volatile, and its contents will disappear\n#+ on reboot or power loss.\n#  Copy anything you want saved to a regular directory.\n\n# After reboot, run this script to again set up ramdisk.\n# Remounting /mnt/ramdisk without the other steps will not work.\n\n#  Suitably modified, this script can by invoked in /etc/rc.d/rc.local,\n#+ to set up ramdisk automatically at bootup.\n#  That may be appropriate on, for example, a database server.\n\nexit 0\n```"]