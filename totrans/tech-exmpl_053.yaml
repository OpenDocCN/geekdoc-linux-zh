- en: CAP Theorem in Distributed Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://techbyexample.com/cap-theorem-distributed-systems/](https://techbyexample.com/cap-theorem-distributed-systems/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '[Overview](#Overview "Overview")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consistency](#Consistency "Consistency")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Availability](#Availability "Availability")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partition Tolerance](#Partition_Tolerance "Partition Tolerance")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CAP Theorem](#CAP_Theorem "CAP Theorem")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consistency and Availability](#Consistency_and_Availability "Consistency and
    Availability")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Consistency and Partition Tolerant](#Consistency_and_Partition_Tolerant "Consistency
    and Partition Tolerant")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Availability and Partition Tolerant](#Availability_and_Partition_Tolerant
    "Availability and Partition Tolerant")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The formula for Strong Consistency](#The_formula_for_Strong_Consistency "The
    formula for Strong Consistency")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Number of Nodes or Replicas](#Number_of_Nodes_or_Replicas "Number of Nodes
    or Replicas")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Write Quoram](#Write_Quoram "Write Quoram")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Read Quoram](#Read_Quoram "Read Quoram")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The number of nodes is 1](#The_number_of_nodes_is_1 "The number of nodes is
    1")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The number of nodes is 2](#The_number_of_nodes_is_2 "The number of nodes is
    2")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Write Quoram is 2 and Read Quoram is 1](#Write_Quoram_is_2_and_Read_Quoram_is_1
    "Write Quoram is 2 and Read Quoram is 1")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Write Quoram is 1 and Read Quoram is 2](#Write_Quoram_is_1_and_Read_Quoram_is_2
    "Write Quoram is 1 and Read Quoram is 2")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Write Quoram is 2 and Read Quoram is 2](#Write_Quoram_is_2_and_Read_Quoram_is_2
    "Write Quoram is 2 and Read Quoram is 2")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Write Quoram is 1 and Read Quoram is 1](#Write_Quoram_is_1_and_Read_Quoram_is_1
    "Write Quoram is 1 and Read Quoram is 1")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Proof of CAP Theorem](#Proof_of_CAP_Theorem "Proof of CAP Theorem")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How consistency is achieved at the cost of Availability](#How_consistency_is_achieved_at_the_cost_of_Availability
    "How consistency is achieved at the cost of Availability")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How availability is achieved at the cost of Consistency](#How_availability_is_achieved_at_the_cost_of_Consistency
    "How availability is achieved at the cost of Consistency")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A distributed system is a system in which that has multiple nodes connected
    to each other through the network. CAP theorem is a fundamental theorem in distributed
    systems and has three things
  prefs: []
  type: TYPE_NORMAL
- en: C stands for Consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stands for Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P stands for Partition Tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It states that you can only achieve only two of the three things mentioned.
    Why is that?. Let’s first understand each of the above terms before understanding
    why only two of them can be achieved,
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means all nodes are consistent with respect to data. Essentially all nodes
    see the same view of data. So every read will return the most recent write. Once
    the writing of any value is successful then the subsequent read will that value
  prefs: []
  type: TYPE_NORMAL
- en: '**Availability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your distributed system should be able to send a non-error response in a reasonable
    amount of time to every request. That response is not guaranteed to be the latest
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition Tolerance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your system continues to work in case of network partition happens. It means
    that even if there is some network issue between the nodes and there are some
    message failures, packets drop, then also the system continues to operate. It
    is not that the system shuts down. In other words, the system is tolerant of network
    partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a system should be tolerant of network partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have understood all the terms let’s see what the CAP theorem states
  prefs: []
  type: TYPE_NORMAL
- en: '**CAP Theorem**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CAP theorem states that in a distributed system, you will only be able to achieve
    two of any three properties above
  prefs: []
  type: TYPE_NORMAL
- en: CA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, a distributed system can’t be consistent, available, and partition
    tolerant at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: This is illustrated in the graph below
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1cb9381d0d8d92b472c43044907a3b12.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Consistency and Availability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your system is not tolerant to network partitions then it is possible to
    achieve both Consistency and Availability
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency and Partition Tolerant**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your system is tolerant to network partitions then you can achieve consistency
    at the cost of availability
  prefs: []
  type: TYPE_NORMAL
- en: '**Availability and Partition Tolerant**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your system is tolerant to network partitions then you can achieve availability
    at the cost of consistency
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier that the system has to be partition tolerant as the
    network is bound to be failed and communication between nodes is bound to be lost. It
    should continue to work despite network failure or message loss. As **P** should
    always be true for a system hence we can only achieve either **C** or **A**. In
    other words, we can only achieve **Consistency** or **Availability** when your
    system is **Partition Tolerant**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example to understand why either **Consistency** or **Availability**
    has to be sacrificed when a system is **Partition Tolerant**. We will try to prove
    the CAP theorem in this tutorial using an example.
  prefs: []
  type: TYPE_NORMAL
- en: But even to understand the example correctly, we first need to understand the
    term **Consistency** in **CAP** correctly. When we refer to consistency here we
    are referring to Strong Consistency here.
  prefs: []
  type: TYPE_NORMAL
- en: A system is strongly consistent if it is reading the most updated write. It
    never returns out of date or stale values. To take an example consider a distributed
    system with two nodes.  We will see an example of a consistent case as well as
    an inconsistent case
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of a consistent case**'
  prefs: []
  type: TYPE_NORMAL
- en: Both the nodes n0 and n1 contain the value of data item ‘A’ as 1\. Read from
    either of the nodes will return the value of ‘A’ as 1\. Now the value of ‘A’ is
    updated to 2 on both the nodes. Again a read from either of the nodes will return
    value f ‘A’ as 2\. Everything is consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of an inconsistent case**'
  prefs: []
  type: TYPE_NORMAL
- en: Both the nodes n0 and n1 contain the value of data item ‘A’ as 1\. Read from
    either of the nodes will return the value of ‘A’ as 1\. Now the value of ‘A’ is
    updated to 2 on the first node but not on the second. So a read from the first
    node will return the value of ‘A’ as 2 while a read from node2 will return the
    value as ‘1’. This is an example of an inconsistent state
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the formula for strong consistency now
  prefs: []
  type: TYPE_NORMAL
- en: '**The formula for Strong Consistency**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand strong consistency in Databases we need to understand three terms
    first
  prefs: []
  type: TYPE_NORMAL
- en: Number of Nodes or Replicas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read Quoram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of Nodes or Replicas**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the number of Nodes that exist in your system. When we say node here
    then that essentially means the number of replicas that have the same data
  prefs: []
  type: TYPE_NORMAL
- en: '**Write Quoram**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the minimum number of nodes to which write will happen before it is returned
    as a success.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read Quoram**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the minimum number of nodes from which the read will happen before it
    is returned as a success. If the value returned by those minimum number of nodes
    is not the same then that read will be rejected
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically if the sum of **Write Quoram** and **Read Quoram** is greater
    than the number of read nodes then the system is said to be strongly consistent.
  prefs: []
  type: TYPE_NORMAL
- en: That is if Write Quoram is W and Read Quoram is R and the number of nodes is
    N, then
  prefs: []
  type: TYPE_NORMAL
- en: The system is strongly consistent if W+R > N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system is not guaranteed to be strongly consistent if W+R<=N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, if there is a node common between Write Quoram nodes and Read
    Quoram nodes then the system will be strongly consistent. That common node will
    reject the stale reads. A node is always common between Write Quoram and Read
    Quoram whenever W+R > N. It is not mathematically difficult to know why.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see by some examples how this formula holds. We are going to see the following
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: The number of nodes is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of nodes is 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of nodes is 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of nodes is 1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, the only combination of Write and Read Quoram possible is 1 and
    1\. The Sum of Write Quoram and Read Quoram is greater than the read node. Since
    there is a single instance, read is always the latest because read and write are
    happening on the same instance
  prefs: []
  type: TYPE_NORMAL
- en: '**The number of nodes is 2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this, there are further four cases.
  prefs: []
  type: TYPE_NORMAL
- en: Write Quoram is 2 and Read Quoram is 1 – **Strongly Consistent**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 1 and Read Quoram is 2 – **Strongly Consistent**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 2 and Read Quoram is 2 – **Strongly Consistent**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 1 and Read Quoram is 1 – **Not Strongly Consistent**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write Quoram is 2 and Read Quoram is 1**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the sum of Write Quoram and Read Quoram is 3 which is greater
    than the number of nodes hence system should be strongly consistent. In this case,
    since write is happening on both the nodes, hence read from either of the nodes
    will return the same data and the system overall will be strongly consistent
  prefs: []
  type: TYPE_NORMAL
- en: '**Write Quoram is 1 and Read Quoram is 2**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, in this case, the sum of Write Quoram and Read Quoram is 3 which is greater
    than the number of nodes hence system should be strongly consistent. In this case,
    write is happening only on a single instance. But read is happening from both
    the nodes. Imagine a case where the initial value of a data named A is 1\. Both
    the nodes have a value of A as 1\. Now write happened on the first node and the
    value of A is changed to 2\. Since Write Quoram is 1 hence write will happen on
    the first node and it will return successfully. Imaging before node 2 could sync
    up with the latest data on node 1, a read happened. Since Read Quoram is 2 it
    is going to read from both the nodes. The first node will return the value of
    A as 2 while the second node will return the value of A as 1\. Since the value
    returned by both the nodes is not the same, the system will reject that read to
    maintain strong consistency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Write Quoram is 2 and Read Quoram is 2**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, in this case, the sum of Write Quoram and Read Quoram is 4 which is greater
    than the number of nodes hence system should be strongly consistent. In this case,
    since write is happening on both the nodes and read also from both the nodes.
    Therefore the read will be the latest every time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Write Quoram is 1 and Read Quoram is 1**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, in this case, the sum of Write Quoram and Read Quoram is 2 which is equal
    to the Number of nodes hence system is not strongly consistent.  Write happened
    on node 1\. A read happened on node 2 before data could be synced to node 2\.
    This read is stale data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Proof of CAP Theorem**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you are aware of the strong consistency, let’s now try to understand the
    CAP theorem in a better way. Assume you have two nodes in the system. Both are
    connected to each other and both are in sync.
  prefs: []
  type: TYPE_NORMAL
- en: As we already know with the above formulas that with two nodes, the system will
    be strongly consistent when
  prefs: []
  type: TYPE_NORMAL
- en: Write Quoram is 2 and Read Quoram is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 1 and Read Quoram is 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 2 and Read Quoram is 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the system will not be strongly consistent when
  prefs: []
  type: TYPE_NORMAL
- en: Write Quoram is 1 and Read Quoram is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already mentioned that in a distributed system that is partitioned tolerant,
    it is only possible to achieve either consistency or availability. Let’s see how.
    Imagine a network partition happened between the two nodes and the second node
    is not available
  prefs: []
  type: TYPE_NORMAL
- en: '**How consistency is achieved at the cost of Availability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here the number of nodes is 2\. Hence two achieve strong consistency we have
    three options
  prefs: []
  type: TYPE_NORMAL
- en: Write Quoram is 2 and Read Quoram is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 1 and Read Quoram is 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write Quoram is 2 and Read Quoram is 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case since Write Quoram is 2 hence it must write to both the nodes.
    But since the second node is not available. Hence it will reject the write. Hence
    the system is not available for write
  prefs: []
  type: TYPE_NORMAL
- en: In the second case since Read Quoram is 2 hence it must read from both the nodes.
    But since the second node is not available. Hence it will reject the read. Hence
    the system is not available for reading
  prefs: []
  type: TYPE_NORMAL
- en: In the third case since Write Quoram is 2 hence it must write to both the nodes
    and since Read Quoram is 2 hence it must read from both the nodes. But since the
    second node is not available. Hence it will reject both read and write. Hence
    the system is not available for reading as well as writing
  prefs: []
  type: TYPE_NORMAL
- en: From the three cases, you can deduce that we get strong consistency at the cost
    of availability in the case of network partitions. Thus we only achieve **C**
    and **P** here. We are not able to get **A** in any case
  prefs: []
  type: TYPE_NORMAL
- en: '**How availability is achieved at the cost of Consistency**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To achieve availability we must give up consistency. Here the number of nodes
    is 2\. Hence there is one option in which the system will not be strongly consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Write Quoram is 1 and Read Quoram is 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case since Write Quoram is 1, hence it can write to node 1\. Also,
    the Read Quoram is 1, and hence it can read from node 1\. Hence the system is
    available. The sum of Write Quoram and Read Quoram is 2 which is equal to the
    number of nodes.  We know by the formula that when the sum of Write Quoram and
    Read Quoram is less than equal to the number of nodes, then the system is not
    strongly consistent. Hence in this case we have availability but the system is
    not consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Thus we only achieve **A** and **P** here. We are not able to get **C** here
  prefs: []
  type: TYPE_NORMAL
- en: This is the proof of the CAP theorem
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is all about the CAP theorem in a distributed system. Hope you have liked
    this article. Please share feedback in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Check out our system design tutorial series [System Design Questions](https://techbyexample.com/system-design-questions/)'
  prefs: []
  type: TYPE_NORMAL
