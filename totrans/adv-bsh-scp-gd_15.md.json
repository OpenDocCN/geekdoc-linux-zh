["```sh script_name=`basename $0`\necho \"The name of this script is $script_name.\"\n```", "```sh rm `cat filename`   # \"filename\" contains a list of files to delete.\n#\n# S. C. points out that \"arg list too long\" error might result.\n# Better is              xargs rm -- < filename \n# ( -- covers those cases where \"filename\" begins with a \"-\" )\n\ntextfile_listing=`ls *.txt`\n# Variable contains names of all *.txt files in current working directory.\necho $textfile_listing\n\ntextfile_listing2=$(ls *.txt)   # The alternative form of command substitution.\necho $textfile_listing2\n# Same result.\n\n# A possible problem with putting a list of files into a single string\n# is that a newline may creep in.\n#\n# A safer way to assign a list of files to a parameter is with an array.\n#      shopt -s nullglob    # If no match, filename expands to nothing.\n#      textfile_listing=( *.txt )\n#\n# Thanks, S.C.\n```", "```sh COMMAND `echo a b`     # 2 args: a and b\n\nCOMMAND \"`echo a b`\"   # 1 arg: \"a b\"\n\nCOMMAND `echo`         # no arg\n\nCOMMAND \"`echo`\"       # one empty arg\n\n# Thanks, S.C.\n```", "```sh # cd \"`pwd`\"  # This should always work.\n# However...\n\nmkdir 'dir with trailing newline\n'\n\ncd 'dir with trailing newline\n'\n\ncd \"`pwd`\"  # Error message:\n# bash: cd: /tmp/file with trailing newline: No such file or directory\n\ncd \"$PWD\"   # Works fine.\n\nold_tty_setting=$(stty -g)   # Save old terminal setting.\necho \"Hit a key \"\nstty -icanon -echo           # Disable \"canonical\" mode for terminal.\n                             # Also, disable *local* echo.\nkey=$(dd bs=1 count=1 2> /dev/null)   # Using 'dd' to get a keypress.\nstty \"$old_tty_setting\"      # Restore old setting. \necho \"You hit ${#key} key.\"  # ${#variable} = number of characters in $variable\n#\n# Hit any key except RETURN, and the output is \"You hit 1 key.\"\n# Hit RETURN, and it's \"You hit 0 key.\"\n# The newline gets eaten in the command substitution.\n\n#Code snippet by Stphane Chazelas.\n```", "```sh dir_listing=`ls -l`\necho $dir_listing     # unquoted\n\n# Expecting a nicely ordered directory listing.\n\n# However, what you get is:\n# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo\n# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh\n\n# The newlines disappeared.\n\necho \"$dir_listing\"   # quoted\n# -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt\n# -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh\n# -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh\n```", "```sh variable1=`<file1`      #  Set \"variable1\" to contents of \"file1\".\nvariable2=`cat file2`   #  Set \"variable2\" to contents of \"file2\".\n                        #  This, however, forks a new process,\n                        #+ so the line of code executes slower than the above version.\n\n#  Note that the variables may contain embedded whitespace,\n#+ or even (horrors), control characters.\n\n#  It is not necessary to explicitly assign a variable.\necho \"` <$0`\"           # Echoes the script itself to stdout.\n```", "```sh #  Excerpts from system file, /etc/rc.d/rc.sysinit\n#+ (on a Red Hat Linux installation)\n\nif [ -f /fsckoptions ]; then\n        fsckoptions=`cat /fsckoptions`\n...\nfi\n#\n#\nif [ -e \"/proc/ide/${disk[$device]}/media\" ] ; then\n             hdmedia=`cat /proc/ide/${disk[$device]}/media`\n...\nfi\n#\n#\nif [ ! -n \"`uname -r &#124; grep -- \"-\"`\" ]; then\n       ktag=\"`cat /proc/version`\"\n...\nfi\n#\n#\nif [ $usb = \"1\" ]; then\n    sleep 5\n    mouseoutput=`cat /proc/bus/usb/devices 2>/dev/null&#124;grep -E \"^I.*Cls=03.*Prot=02\"`\n    kbdoutput=`cat /proc/bus/usb/devices 2>/dev/null&#124;grep -E \"^I.*Cls=03.*Prot=01\"`\n...\nfi\n```", "```sh #!/bin/bash\n# stupid-script-tricks.sh: Don't try this at home, folks.\n# From \"Stupid Script Tricks,\" Volume I.\n\nexit 99  ### Comment out this line if you dare.\n\ndangerous_variable=`cat /boot/vmlinuz`   # The compressed Linux kernel itself.\n\necho \"string-length of \\$dangerous_variable = ${#dangerous_variable}\"\n# string-length of $dangerous_variable = 794151\n# (Newer kernels are bigger.)\n# Does not give same count as 'wc -c /boot/vmlinuz'.\n\n# echo \"$dangerous_variable\"\n# Don't try this! It would hang the script.\n\n#  The document author is aware of no useful applications for\n#+ setting a variable to the contents of a binary file.\n\nexit 0\n```", "```sh #!/bin/bash\n# csubloop.sh: Setting a variable to the output of a loop.\n\nvariable1=`for i in 1 2 3 4 5\ndo\n  echo -n \"$i\"                 #  The 'echo' command is critical\ndone`                          #+ to command substitution here.\n\necho \"variable1 = $variable1\"  # variable1 = 12345\n\ni=0\nvariable2=`while [ \"$i\" -lt 10 ]\ndo\n  echo -n \"$i\"                 # Again, the necessary 'echo'.\n  let \"i += 1\"                 # Increment.\ndone`\n\necho \"variable2 = $variable2\"  # variable2 = 0123456789\n\n#  Demonstrates that it's possible to embed a loop\n#+ inside a variable declaration.\n\nexit 0\n```", "```sh #include <stdio.h>\n\n/*  \"Hello, world.\" C program  */\t\t\n\nint main()\n{\n  printf( \"Hello, world.\\n\" );\n  return (0);\n}\n```", "```sh bash$ **gcc -o hello hello.c**\n\n```", "```sh #!/bin/bash\n# hello.sh\t\t\n\ngreeting=`./hello`\necho $greeting\n```", "```sh bash$ **sh hello.sh**\nHello, world.\n\n```", "```sh output=$(sed -n /\"$1\"/p $file)   # From \"grp.sh\"\texample.\n\n# Setting a variable to the contents of a text file.\nFile_contents1=$(cat $file1)      \nFile_contents2=$(<$file2)        # Bash permits this also.\n```", "```sh bash$ **echo `echo \\\\`**\n `bash$` `**echo $(echo \\\\)**`\n`\\` \n```", "```sh word_count=$( wc -w $(echo * &#124; awk '{print $8}') )\n```", "```sh #!/bin/bash\n# agram2.sh\n# Example of nested command substitution.\n\n#  Uses \"anagram\" utility\n#+ that is part of the author's \"yawl\" word list package.\n#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz\n#  http://bash.deta.in/yawl-0.3.2.tar.gz\n\nE_NOARGS=86\nE_BADARG=87\nMINLEN=7\n\nif [ -z \"$1\" ]\nthen\n  echo \"Usage $0 LETTERSET\"\n  exit $E_NOARGS         # Script needs a command-line argument.\nelif [ ${#1} -lt $MINLEN ]\nthen\n  echo \"Argument must have at least $MINLEN letters.\"\n  exit $E_BADARG\nfi\n\nFILTER='.......'         # Must have at least 7 letters.\n#       1234567\nAnagrams=( $(echo $(anagram $1 &#124; grep $FILTER) ) )\n#          $(     $(  nested command sub.    ) )\n#        (              array assignment         )\n\necho\necho \"${#Anagrams[*]}  7+ letter anagrams found\"\necho\necho ${Anagrams[0]}      # First anagram.\necho ${Anagrams[1]}      # Second anagram.\n                         # Etc.\n\n# echo \"${Anagrams[*]}\"  # To list all the anagrams in a single line . . .\n\n#  Look ahead to the Arrays chapter for enlightenment on\n#+ what's going on here.\n\n# See also the agram.sh script for an exercise in anagram finding.\n\nexit $?\n```", "```sh word_count=` wc -w \\`echo * &#124; awk '{print $8}'\\` `\n```"]