["```\n sudo apt-get install build-essential nasm genisoimage bochs bochs-sdl\n```", "```\n __attribute__((packed))\n```", "```\n global loader                   ; the entry symbol for ELF\n\n    MAGIC_NUMBER equ 0x1BADB002     ; define the magic number constant\n    FLAGS        equ 0x0 ; multiboot flags\n    CHECKSUM     equ -MAGIC_NUMBER  ; calculate the checksum\n                                    ; (magic number + checksum + flags should equal 0)\n\n    section .text:                  ; start of the text (code) section\n    align 4                         ; the code must be 4 byte aligned\n        dd MAGIC_NUMBER             ; write the magic number to the machine code,\n        dd FLAGS                    ; the flags,\n        dd CHECKSUM                 ; and the checksum\n\n loader:                         ; the loader label (defined as entry point in linker script)\n        mov eax, 0xCAFEBABE         ; place the number 0xCAFEBABE in the register eax\n .loop:\n        jmp .loop                   ; loop forever\n```", "```\n nasm -f elf32 loader.s\n```", "```\nENTRY(loader)                /* the name of the entry label */\n\nSECTIONS {\n    . = 0x00100000;          /* the code should be loaded at 1 MB */\n\n    .text ALIGN (0x1000) :   /* align at 4 KB */\n    {\n        *(.text)             /* all text sections from all files */\n    }\n\n    .rodata ALIGN (0x1000) : /* align at 4 KB */\n    {\n        *(.rodata*)          /* all read-only data sections from all files */\n    }\n\n    .data ALIGN (0x1000) :   /* align at 4 KB */\n    {\n        *(.data)             /* all data sections from all files */\n    }\n\n    .bss ALIGN (0x1000) :    /* align at 4 KB */\n    {\n        *(COMMON)            /* all COMMON sections from all files */\n        *(.bss)              /* all bss sections from all files */\n    }\n}\n```", "```\n ld -T link.ld -melf_i386 loader.o -o kernel.elf\n```", "```\n mkdir -p iso/boot/grub              # create the folder structure\n    cp stage2_eltorito iso/boot/grub/   # copy the bootloader\n    cp kernel.elf iso/boot/             # copy the kernel\n```", "```\n default=0\n    timeout=0\n\n    title os\n    kernel /boot/kernel.elf\n```", "```\n iso\n    |-- boot\n      |-- grub\n      | |-- menu.lst\n      | |-- stage2_eltorito\n      |-- kernel.elf\n```", "```\n genisoimage -R                              \\\n                -b boot/grub/stage2_eltorito    \\\n                -no-emul-boot                   \\\n                -boot-load-size 4               \\\n                -A os                           \\\n                -input-charset utf8             \\\n                -quiet                          \\\n                -boot-info-table                \\\n                -o os.iso                       \\\n                iso\n```", "```\n megs:            32\n    display_library: sdl\n    romimage:        file=/usr/share/bochs/BIOS-bochs-latest\n    vgaromimage:     file=/usr/share/bochs/VGABIOS-lgpl-latest\n    ata0-master:     type=cdrom, path=os.iso, status=inserted\n    boot:            cdrom\n    log:             bochslog.txt\n    clock:           sync=realtime, time0=local\n    cpu:             count=1, ips=1000000\n```", "```\n bochs -f bochsrc.txt -q\n```", "```\n cat bochslog.txt\n```", "```\n KERNEL_STACK_SIZE equ 4096                  ; size of stack in bytes\n\n    section .bss\n    align 4                                     ; align at 4 bytes\n kernel_stack:                               ; label points to beginning of memory\n        resb KERNEL_STACK_SIZE                  ; reserve stack for the kernel\n```", "```\n mov esp, kernel_stack + KERNEL_STACK_SIZE   ; point esp to the start of the\n                                                ; stack (end of memory area)\n```", "```\n /* The C function */\n    int sum_of_three(int arg1, int arg2, int arg3)\n    {\n        return arg1 + arg2 + arg3;\n    }\n```", "```\n ; The assembly code\n    external sum_of_three   ; the function sum_of_three is defined elsewhere\n\n    push dword 3            ; arg3\n    push dword 2            ; arg2\n    push dword 1            ; arg1\n    call sum_of_three       ; call the function, the result will be in eax\n```", "```\nBit:     | 31     24 | 23          8 | 7     0 |\nContent: | index     | address       | config  |\n```", "```\n struct example {\n        unsigned char config;   /* bit 0 - 7   */\n        unsigned short address; /* bit 8 - 23  */\n        unsigned char index;    /* bit 24 - 31 */\n    };\n```", "```\n struct example {\n        unsigned char config;   /* bit 0 - 7   */\n        unsigned short address; /* bit 8 - 23  */\n        unsigned char index;    /* bit 24 - 31 */\n    } __attribute__((packed));\n```", "```\n -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -nostartfiles\n    -nodefaultlibs\n```", "```\n -Wall -Wextra -Werror\n```", "```\n OBJECTS = loader.o kmain.o\n    CC = gcc\n    CFLAGS = -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector \\\n             -nostartfiles -nodefaultlibs -Wall -Wextra -Werror -c\n    LDFLAGS = -T link.ld -melf_i386\n    AS = nasm\n    ASFLAGS = -f elf\n\n    all: kernel.elf\n\n    kernel.elf: $(OBJECTS)\n        ld $(LDFLAGS) $(OBJECTS) -o kernel.elf\n\n    os.iso: kernel.elf\n        cp kernel.elf iso/boot/kernel.elf\n        genisoimage -R                              \\\n                    -b boot/grub/stage2_eltorito \\\n                    -no-emul-boot \\\n                    -boot-load-size 4 \\\n                    -A os \\\n                    -input-charset utf8 \\\n                    -quiet \\\n                    -boot-info-table \\\n                    -o os.iso \\\n                    iso\n\n    run: os.iso\n        bochs -f bochsrc.txt -q\n\n    %.o: %.c\n        $(CC) $(CFLAGS)  $< -o $@\n\n    %.o: %.s\n        $(AS) $(ASFLAGS) $< -o $@\n\n    clean:\n        rm -rf *.o kernel.elf os.iso\n```", "```\n .\n    |-- bochsrc.txt\n    |-- iso\n    |   |-- boot\n    |     |-- grub\n    |       |-- menu.lst\n    |       |-- stage2_eltorito\n    |-- kmain.c\n    |-- loader.s\n    |-- Makefile\n```", "```\nBit:     | 15 14 13 12 11 10 9 8 | 7 6 5 4 | 3 2 1 0 |\nContent: | ASCII                 | FG      | BG      |\n```", "```\n mov [0x000B8000], 0x4128\n```", "```\n 0x000B8000 + 16 = 0x000B8010\n```", "```\n fb[0] = 'A';\n    fb[1] = 0x28;\n```", "```\n /** fb_write_cell:\n *  Writes a character with the given foreground and background to position i\n *  in the framebuffer.\n *\n * @param  i The location in the framebuffer\n * @param  c The character\n * @param  fg The foreground color\n * @param  bg The background color\n */\n    void fb_write_cell(unsigned int i, char c, unsigned char fg, unsigned char bg)\n    {\n        fb[i] = c;\n        fb[i + 1] = ((fg & 0x0F) << 4) | (bg & 0x0F)\n    }\n```", "```\n #define FB_GREEN     2\n    #define FB_DARK_GREY 8\n\n    fb_write_cell(0, 'A', FB_GREEN, FB_DARK_GREY);\n```", "```\n out 0x3D4, 14      ; 14 tells the framebuffer to expect the highest 8 bits of the position\n    out 0x3D5, 0x00 ; sending the highest 8 bits of 0x0050\n    out 0x3D4, 15      ; 15 tells the framebuffer to expect the lowest 8 bits of the position\n    out 0x3D5, 0x50 ; sending the lowest 8 bits of 0x0050\n```", "```\n global outb             ; make the label outb visible outside this file\n\n    ; outb - send a byte to an I/O port\n    ; stack: [esp + 8] the data byte\n    ;        [esp + 4] the I/O port\n    ;        [esp    ] return address\n outb:\n        mov al, [esp + 8]    ; move the data to be sent into the al register\n        mov dx, [esp + 4]    ; move the address of the I/O port into the dx register\n        out dx, al           ; send the data to the I/O port\n        ret                  ; return to the calling function\n```", "```\n #ifndef INCLUDE_IO_H\n    #define INCLUDE_IO_H\n\n    /** outb:\n *  Sends the given data to the given I/O port. Defined in io.s\n *\n * @param  port The I/O port to send the data to\n * @param  data The data to send to the I/O port\n */\n    void outb(unsigned short port, unsigned char data);\n\n    #endif /* INCLUDE_IO_H */\n```", "```\n #include \"io.h\"\n\n    /* The I/O ports */\n    #define FB_COMMAND_PORT         0x3D4\n    #define FB_DATA_PORT            0x3D5\n\n    /* The I/O port commands */\n    #define FB_HIGH_BYTE_COMMAND    14\n    #define FB_LOW_BYTE_COMMAND     15\n\n    /** fb_move_cursor:\n *  Moves the cursor of the framebuffer to the given position\n *\n * @param  pos The new position of the cursor\n */\n    void fb_move_cursor(unsigned short pos)\n    {\n        outb(FB_COMMAND_PORT, FB_HIGH_BYTE_COMMAND);\n        outb(FB_DATA_PORT,    ((pos >> 8) & 0x00FF));\n        outb(FB_COMMAND_PORT, FB_LOW_BYTE_COMMAND);\n        outb(FB_DATA_PORT,    pos & 0x00FF);\n    }\n```", "```\n int write(char *buf, unsigned int len);\n```", "```\n #include \"io.h\" /* io.h is implement in the section \"Moving the cursor\" */\n\n    /* The I/O ports */\n\n    /* All the I/O ports are calculated relative to the data port. This is because\n * all serial ports (COM1, COM2, COM3, COM4) have their ports in the same\n * order, but they start at different values.\n */\n\n    #define SERIAL_COM1_BASE                0x3F8 /* COM1 base port */\n\n    #define SERIAL_DATA_PORT(base)          (base)\n    #define SERIAL_FIFO_COMMAND_PORT(base)  (base + 2)\n    #define SERIAL_LINE_COMMAND_PORT(base)  (base + 3)\n    #define SERIAL_MODEM_COMMAND_PORT(base) (base + 4)\n    #define SERIAL_LINE_STATUS_PORT(base)   (base + 5)\n\n    /* The I/O port commands */\n\n    /* SERIAL_LINE_ENABLE_DLAB:\n * Tells the serial port to expect first the highest 8 bits on the data port,\n * then the lowest 8 bits will follow\n */\n    #define SERIAL_LINE_ENABLE_DLAB         0x80\n\n    /** serial_configure_baud_rate:\n *  Sets the speed of the data being sent. The default speed of a serial\n *  port is 115200 bits/s. The argument is a divisor of that number, hence\n *  the resulting speed becomes (115200 / divisor) bits/s.\n *\n * @param  com The COM port to configure\n * @param  divisor The divisor\n */\n    void serial_configure_baud_rate(unsigned short com, unsigned short divisor)\n    {\n        outb(SERIAL_LINE_COMMAND_PORT(com),\n             SERIAL_LINE_ENABLE_DLAB);\n        outb(SERIAL_DATA_PORT(com),\n             (divisor >> 8) & 0x00FF);\n        outb(SERIAL_DATA_PORT(com),\n             divisor & 0x00FF);\n    }\n```", "```\nBit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |\nContent: | d | b | prty  | s | dl  |\n```", "```\n /** serial_configure_line:\n *  Configures the line of the given serial port. The port is set to have a\n *  data length of 8 bits, no parity bits, one stop bit and break control\n *  disabled.\n *\n * @param  com The serial port to configure\n */\n    void serial_configure_line(unsigned short com)\n    {\n        /* Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |\n * Content: | d | b | prty  | s | dl  |\n * Value:   | 0 | 0 | 0 0 0 | 0 | 1 1 | = 0x03\n */\n        outb(SERIAL_LINE_COMMAND_PORT(com), 0x03);\n    }\n```", "```\nBit:     | 7 6 | 5  | 4 | 3   | 2   | 1   | 0 |\nContent: | lvl | bs | r | dma | clt | clr | e |\n```", "```\nBit:     | 7 | 6 | 5  | 4  | 3   | 2   | 1   | 0   |\nContent: | r | r | af | lb | ao2 | ao1 | rts | dtr |\n```", "```\n global inb\n\n    ; inb - returns a byte from the given I/O port\n    ; stack: [esp + 4] The address of the I/O port\n    ;        [esp    ] The return address\n inb:\n        mov dx, [esp + 4]       ; move the address of the I/O port to the dx register\n        in  al, dx              ; read a byte from the I/O port and store it in the al register\n        ret                     ; return the read byte\n```", "```\n /* in file io.h */\n\n    /** inb:\n *  Read a byte from an I/O port.\n *\n * @param  port The address of the I/O port\n * @return The read byte\n */\n    unsigned char inb(unsigned short port);\n```", "```\n #include \"io.h\"\n\n    /** serial_is_transmit_fifo_empty:\n *  Checks whether the transmit FIFO queue is empty or not for the given COM\n *  port.\n *\n * @param  com The COM port\n * @return 0 if the transmit FIFO queue is not empty\n *          1 if the transmit FIFO queue is empty\n */\n    int serial_is_transmit_fifo_empty(unsigned int com)\n    {\n        /* 0x20 = 0010 0000 */\n        return inb(SERIAL_LINE_STATUS_PORT(com)) & 0x20;\n    }\n```", "```\n com1: enabled=1, mode=file, dev=com1.out\n```", "```\n func:\n        mov eax, [esp+4]\n        mov ebx, [eax]\n        add ebx, 8\n        mov [eax], ebx\n        ret\n```", "```\n func:\n        mov eax, [ss:esp+4]\n        mov ebx, [ds:eax]\n        add ebx, 8\n        mov [ds:eax], ebx\n        ret\n```", "```\n struct gdt {\n        unsigned int address;\n        unsigned short size;\n    } __attribute__((packed));\n```", "```\n lgdt [eax]\n```", "```\nBit:     | 15                                3 | 2  | 1 0 |\nContent: | offset (index)                      | ti | rpl |\n```", "```\n mov ds, 0x10\n    mov ss, 0x10\n    mov es, 0x10\n    .\n    .\n    .\n```", "```\n ; code here uses the previous cs\n    jmp 0x08:flush_cs   ; specify cs when jumping to flush_cs\n\n flush_cs:\n        ; now we've changed cs to 0x08\n```", "```\nBit:     | 31              16 | 15 | 14 13 | 12 | 11 | 10 9 8 | 7 6 5 | 4 3 2 1 0 |\nContent: | offset high        | P  | DPL   | 0  | D  | 1  1 0 | 0 0 0 | reserved  |\n```", "```\nBit:     | 31              16 | 15              0 |\nContent: | segment selector   | offset low        |\n```", "```\n 0xDEAD8E00\n    0x0008BEEF\n```", "```\n idt[0] = 0xDEAD8E00\n    idt[1] = 0x0008BEEF\n```", "```\n [esp + 12] eflags\n    [esp + 8]  cs\n    [esp + 4]  eip\n    [esp]      error code?\n```", "```\n struct cpu_state {\n        unsigned int eax;\n        unsigned int ebx;\n        unsigned int ecx;\n        .\n        .\n        .\n        unsigned int esp;\n    } __attribute__((packed));\n\n    struct stack_state {\n        unsigned int error_code;\n        unsigned int eip;\n        unsigned int cs;\n        unsigned int eflags;\n    } __attribute__((packed));\n\n    void interrupt_handler(struct cpu_state cpu, struct stack_state stack, unsigned int interrupt);\n```", "```\n %macro no_error_code_interrupt_handler %1\n    global interrupt_handler_%1\n    interrupt_handler_%1:\n        push    dword 0                     ; push 0 as error code\n        push    dword %1                    ; push the interrupt number\n        jmp     common_interrupt_handler    ; jump to the common handler\n    %endmacro\n\n    %macro error_code_interrupt_handler %1\n    global interrupt_handler_%1\n    interrupt_handler_%1:\n        push    dword %1                    ; push the interrupt number\n        jmp     common_interrupt_handler    ; jump to the common handler\n    %endmacro\n\n common_interrupt_handler:               ; the common parts of the generic interrupt handler\n        ; save the registers\n        push    eax\n        push    ebx\n        .\n        .\n        .\n        push    ebp\n\n        ; call the C function\n        call    interrupt_handler\n\n        ; restore the registers\n        pop     ebp\n        .\n        .\n        .\n        pop     ebx\n        pop     eax\n\n        ; restore the esp\n        add     esp, 8\n\n        ; return to the code that got interrupted\n        iret\n\n    no_error_code_interrupt_handler 0       ; create handler for interrupt 0\n    no_error_code_interrupt_handler 1       ; create handler for interrupt 1\n    .\n    .\n    .\n    error_code_handler              7       ; create handler for interrupt 7\n    .\n    .\n    .\n```", "```\n global  load_idt\n\n    ; load_idt - Loads the interrupt descriptor table (IDT).\n    ; stack: [esp + 4] the address of the first entry in the IDT\n    ;        [esp    ] the return address\n load_idt:\n        mov     eax, [esp+4]    ; load the address of the IDT into register eax\n        lidt    eax             ; load the IDT\n        ret                     ; return to the calling function\n```", "```\n #include \"io.h\"\n\n    #define PIC1_PORT_A 0x20\n    #define PIC2_PORT_A 0xA0\n\n    /* The PIC interrupts have been remapped */\n    #define PIC1_START_INTERRUPT 0x20\n    #define PIC2_START_INTERRUPT 0x28\n    #define PIC2_END_INTERRUPT   PIC2_START_INTERRUPT + 7\n\n    #define PIC_ACK     0x20\n\n    /** pic_acknowledge:\n *  Acknowledges an interrupt from either PIC 1 or PIC 2.\n *\n * @param  num The number of the interrupt\n */\n    void pic_acknowledge(unsigned integer interrupt)\n    {\n        if (interrupt < PIC1_START_INTERRUPT || interrupt > PIC2_END_INTERRUPT) {\n          return;\n        }\n\n        if (interrupt < PIC2_START_INTERRUPT) {\n          outb(PIC1_PORT_A, PIC_ACK);\n        } else {\n          outb(PIC2_PORT_A, PIC_ACK);\n        }\n    }\n```", "```\n #include \"io.h\"\n\n    #define KBD_DATA_PORT   0x60\n\n    /** read_scan_code:\n *  Reads a scan code from the keyboard\n *\n * @return The scan code (NOT an ASCII character!)\n */\n    unsigned char read_scan_code(void)\n    {\n        return inb(KBD_DATA_PORT);\n    }\n```", "```\n module /modules/program\n```", "```\n mkdir -p iso/modules\n```", "```\n ; in file `loader.s`\n\n    MAGIC_NUMBER    equ 0x1BADB002      ; define the magic number constant\n    ALIGN_MODULES   equ 0x00000001 ; tell GRUB to align modules\n\n    ; calculate the checksum (all options + checksum should equal 0)\n    CHECKSUM        equ -(MAGIC_NUMBER + ALIGN_MODULES)\n\n    section .text:                      ; start of the text (code) section\n    align 4                             ; the code must be 4 byte aligned\n        dd MAGIC_NUMBER                 ; write the magic number\n        dd ALIGN_MODULES                ; write the align modules instruction\n        dd CHECKSUM                     ; write the checksum\n```", "```\n ; set eax to some distinguishable number, to read from the log afterwards\n    mov eax, 0xDEADBEEF\n\n    ; enter infinite loop, nothing more to do\n    ; $ means \"beginning of line\", ie. the same instruction\n    jmp $\n```", "```\n nasm -f bin program.s -o program\n```", "```\n int kmain(/* additional arguments */ unsigned int ebx)\n    {\n        multiboot_info_t *mbinfo = (multiboot_info_t *) ebx;\n        unsigned int address_of_module = mbinfo->mods_addr;\n    }\n```", "```\n typedef void (*call_module_t)(void);\n    /* ... */\n    call_module_t start_program = (call_module_t) address_of_module;\n    start_program();\n    /* we'll never get here, unless the module code returns */\n```", "```\n ; eax has the address of the page directory\n    mov cr3, eax\n\n    mov ebx, cr4        ; read current cr4\n    or  ebx, 0x00000010 ; set PSE\n    mov cr4, ebx        ; update cr4\n\n    mov ebx, cr0        ; read current cr0\n    or  ebx, 0x80000000 ; set PG\n    mov cr0, ebx        ; update cr0\n\n    ; now paging is enabled\n```", "```\n ; invalidate any TLB references to virtual address 0\n    invlpg [0]\n```", "```\n ENTRY(loader)           /* the name of the entry symbol */\n\n    . = 0xC0100000          /* the code should be relocated to 3GB + 1MB */\n\n    /* align at 4 KB and load at 1 MB */\n    .text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.text)            /* all text sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .rodata ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.rodata*)         /* all read-only data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .data ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.data)            /* all data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .bss ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(COMMON)           /* all COMMON sections from all files */\n        *(.bss)             /* all bss sections from all files */\n    }\n```", "```\n ; assembly code executing at around 0x00100000\n    ; enable paging for both actual location of kernel\n    ; and its higher-half virtual location\n\n    lea ebx, [higher_half] ; load the address of the label in ebx\n    jmp ebx                ; jump to the label\n\n higher_half:\n        ; code here executes in the higher half kernel\n        ; eip is larger than 0xC0000000\n        ; can continue kernel initialisation, calling C code, etc.\n```", "```\n ENTRY(loader)           /* the name of the entry symbol */\n\n    . = 0xC0100000          /* the code should be relocated to 3 GB + 1 MB */\n\n    /* these labels get exported to the code files */\n    kernel_virtual_start = .;\n    kernel_physical_start = . - 0xC0000000;\n\n    /* align at 4 KB and load at 1 MB */\n    .text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.text)            /* all text sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .rodata ALIGN (0x1000) : AT(ADDR(.rodata)-0xC0000000)\n    {\n        *(.rodata*)         /* all read-only data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .data ALIGN (0x1000) : AT(ADDR(.data)-0xC0000000)\n    {\n        *(.data)            /* all data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .bss ALIGN (0x1000) : AT(ADDR(.bss)-0xC0000000)\n    {\n        *(COMMON)           /* all COMMON sections from all files */\n        *(.bss)             /* all bss sections from all files */\n    }\n\n    kernel_virtual_end = .;\n    kernel_physical_end = . - 0xC0000000;\n```", "```\n extern kernel_virtual_start\n    extern kernel_virtual_end\n    extern kernel_physical_start\n    extern kernel_physical_end\n\n    ; ...\n\n    push kernel_physical_end\n    push kernel_physical_start\n    push kernel_virtual_end\n    push kernel_virtual_start\n\n    call kmain\n```", "```\n void kernel_virtual_start(void);\n\n    /* ... */\n\n    unsigned int vaddr = (unsigned int) &kernel_virtual_start;\n```", "```\n (768 << 22) | (1023 << 12) | 0x000 = 0xC03FF000\n```", "```\n [esp + 16]  ss      ; the stack segment selector we want for user mode\n    [esp + 12]  esp     ; the user mode stack pointer\n    [esp +  8]  eflags  ; the control flags we want to use in user mode\n    [esp +  4]  cs      ; the code segment selector\n    [esp +  0]  eip     ; the instruction pointer of user mode code to execute\n```", "```\n USER_MODE_CODE_SEGMENT_SELECTOR equ 0x18\n    USER_MODE_DATA_SEGMENT_SELECTOR equ 0x20\n    mov cs, USER_MODE_CODE_SEGMENT_SELECTOR | 0x3\n    mov ss, USER_MODE_DATA_SEGMENT_SELECTOR | 0x3\n```", "```\n extern main\n\n    section .text\n        ; push argv\n        ; push argc\n        call main\n        ; main has returned, eax is return value\n        jmp  $    ; loop forever\n```", "```\n OUTPUT_FORMAT(\"binary\")    /* output flat binary */\n\n    SECTIONS\n    {\n        . = 0;                 /* relocate to address 0 */\n\n        .text ALIGN(4):\n        {\n            start.o(.text)     /* include the .text section of start.o */\n            *(.text)           /* include all other .text sections */\n        }\n\n        .data ALIGN(4):\n        {\n            *(.data)\n        }\n\n        .rodata ALIGN(4):\n        {\n            *(.rodata*)\n        }\n    }\n```", "```\n -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -nostartfiles\n    -nodefaultlibs\n```", "```\n -T link.ld -melf_i386  # emulate 32 bits ELF, the binary output is specified\n                           # in the linker script\n```"]