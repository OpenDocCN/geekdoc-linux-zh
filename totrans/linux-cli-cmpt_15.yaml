- en: Shell Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 脚本
- en: 原文：[https://learnbyexample.github.io/cli-computing/shell-scripting.html](https://learnbyexample.github.io/cli-computing/shell-scripting.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://learnbyexample.github.io/cli-computing/shell-scripting.html](https://learnbyexample.github.io/cli-computing/shell-scripting.html)
- en: This chapter will cover the basics of shell scripting with `bash`. You'll learn
    about declaring variables, control structures, working with arguments passed to
    a script, getting user input and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用 `bash` 的 Shell 脚本基础知识。您将学习如何声明变量、控制结构、处理传递给脚本的参数、获取用户输入等等。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The [example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)
    directory has all the shell scripts discussed in this chapter. However, it is
    recommended that you type the scripts manually using your favorite text editor
    and refer to the `example_files/shell_scripting` directory only when necessary.'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) [example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)
    目录包含了本章讨论的所有 Shell 脚本。然而，建议您使用您喜欢的文本编辑器手动输入脚本，并在必要时才参考 `example_files/shell_scripting`
    目录。'
- en: '[Need for scripting](#need-for-scripting)'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[脚本需求](#need-for-scripting)'
- en: 'From [wikipedia: Scripting language](https://en.wikipedia.org/wiki/Scripting_language):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '来自 [wikipedia: Scripting language](https://en.wikipedia.org/wiki/Scripting_language):'
- en: A scripting language or script language is a programming language for a runtime
    system that automates the execution of tasks that would otherwise be performed
    individually by a human operator. Scripting languages are usually interpreted
    at runtime rather than compiled.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 脚本语言或脚本语言是一种用于运行时系统的编程语言，它自动化了本应由人类操作员单独执行的任务。脚本语言通常在运行时解释，而不是编译。
- en: Typical scripting languages are intended to be very fast to learn and write
    in, either as short source code files or interactively in a read–eval–print loop
    (REPL, language shell). This generally implies relatively simple syntax and semantics;
    typically a "script" (code written in the scripting language) is executed from
    start to finish, as a "script", with no explicit entry point.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 典型的脚本语言旨在非常快速地学习和编写，无论是作为短源代码文件还是通过交互式地读取-评估-打印循环（REPL，语言壳）。这通常意味着相对简单的语法和语义；通常，“脚本”（用脚本语言编写的代码）从头到尾作为“脚本”执行，没有明确的入口点。
- en: 'From [wikipedia: Shell script](https://en.wikipedia.org/wiki/Shell_script):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '来自 [wikipedia: Shell script](https://en.wikipedia.org/wiki/Shell_script):'
- en: A shell script is a computer program designed to be run by the Unix shell, a
    command-line interpreter. The various dialects of shell scripts are considered
    to be scripting languages. Typical operations performed by shell scripts include
    file manipulation, program execution, and printing text. A script which sets up
    the environment, runs the program, and does any necessary cleanup or logging,
    is called a wrapper.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Shell 脚本是一种为 Unix Shell（一种命令行解释器）设计的计算机程序。Shell 脚本的多种方言被认为是脚本语言。Shell 脚本通常执行的操作包括文件操作、程序执行和打印文本。设置环境、运行程序以及进行任何必要的清理或记录的脚本被称为包装器。
- en: See also [Difference between scripting and programming languages](https://stackoverflow.com/q/17253545/4082052).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [脚本与编程语言之间的区别](https://stackoverflow.com/q/17253545/4082052)。
- en: '[Executable script](#executable-script)'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可执行脚本](#executable-script)'
- en: 'There are several ways you can execute commands from a file. This section shows
    an example of creating an executable script. Consider this sample script saved
    in a file named `hello.sh`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从文件中执行命令的几种方式。本节展示了创建可执行脚本的一个示例。考虑以下示例脚本，它保存在名为 `hello.sh` 的文件中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line in the above script has two parts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的脚本的第一行包含两部分：
- en: '`/bin/bash` is the path of the `bash` interpreter'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin/bash` 是 `bash` 解释器的路径'
- en: you can use `type bash` to get the path on your system
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `type bash` 来获取系统上的路径
- en: '`#!` is known as [shebang or hashbang](https://en.wikipedia.org/wiki/Shebang_(Unix))
    which directs the program loader to use the interpreter path provided'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!`被称为[shebang 或 hashbang](https://en.wikipedia.org/wiki/Shebang_(Unix))，它指示程序加载器使用提供的解释器路径'
- en: 'see also [stackoverflow: comparison between #!/usr/bin/env and #!/bin/bash?](https://stackoverflow.com/q/21612980/4082052)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参见 [stackoverflow: #!/usr/bin/env 与 #!/bin/bash 之间的比较？](https://stackoverflow.com/q/21612980/4082052)'
- en: the `#` character starts a comment, `#!` is only special at the start of the
    script
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`字符开始一个注释，`#!`仅在脚本的开始处是特殊的'
- en: 'Use `chmod` to add executable permission to the file and then run the script:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `chmod` 为文件添加可执行权限，然后运行脚本：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want to use just the script name to execute it, the file has to be located
    in one of the `PATH` folders. Otherwise, you'll have to provide the script's path
    (absolute or relative) in order to execute it (as shown in the above illustration).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想使用脚本名称来执行它，该文件必须位于 `PATH` 文件夹之一中。否则，您必须提供脚本路径（绝对或相对），以便执行（如上图所示）。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `.sh` is typically
    used as the file extension for shell scripts. It is also common to *not* have
    an extension at all, especially for executable scripts.'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `.sh` 通常用作 shell 脚本的文件扩展名。不使用扩展名也很常见，尤其是对于可执行脚本。'
- en: '[Passing file argument to bash](#passing-file-argument-to-bash)'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[传递文件参数给 bash](#passing-file-argument-to-bash)'
- en: You can also just pass a regular file as an argument to the `bash` command.
    In this case, the shebang isn't needed (though it wouldn't cause any issues either,
    since it will be treated as a comment).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将常规文件作为参数传递给 `bash` 命令。在这种情况下，不需要 shebang（尽管它也不会造成任何问题，因为它将被视为注释）。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Sourcing script](#sourcing-script)'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[source 脚本](#sourcing-script)'
- en: Yet another way to execute a script is to *source* it using the `source` (or
    `.`) builtin command. A major difference from the previous methods is that the
    script is executed in the current shell environment context instead of a sub-shell.
    A common use case is sourcing `~/.bashrc` and alias/functions (if they are saved
    in a separate file).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种执行脚本的方法是使用 `source`（或 `.`）内置命令来 *source* 它。与之前的方法相比，主要区别在于脚本是在当前 shell 环境上下文中执行，而不是在子
    shell 中执行。一个常见的用例是 source `~/.bashrc` 和别名/函数（如果它们保存在单独的文件中）。
- en: 'Here''s an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `fc` is a builtin command
    to manipulate the history of commands you''ve used from the terminal. See [bash
    manual: History Builtins](https://www.gnu.org/software/bash/manual/bash.html#Bash-History-Builtins)
    for more details.'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `fc` 是一个用于操作从终端使用的命令历史的内置命令。有关更多详细信息，请参阅
    [bash 手册：历史内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-History-Builtins)。'
- en: '[Comments](#comments)'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[注释](#comments)'
- en: Single line comments can be inserted after the `#` character, either at the
    start of a line or after an instruction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单行注释可以插入到 `#` 字符之后，可以是行的开头或指令之后。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See this [unix.stackexchange
    thread](https://unix.stackexchange.com/q/37411/109046) for emulating multiline
    comments.'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 有关模拟多行注释的信息，请参阅 [unix.stackexchange
    线程](https://unix.stackexchange.com/q/37411/109046)。'
- en: '[Variables](#variables)'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[变量](#variables)'
- en: 'Here''s a basic example of assigning a variable and accessing its value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个基本示例，展示如何分配变量和访问其值：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As seen above, you need to use the `$` prefix while accessing the value stored
    in a variable. You can use the `${variable}` syntax to distinguish between the
    variable and other parts of the string. Using appropriate quotes is recommended,
    unless otherwise necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，在访问存储在变量中的值时，需要使用 `$` 前缀。您可以使用 `${variable}` 语法来区分变量和字符串的其他部分。除非必要，否则建议使用适当的引号。
- en: 'You can append to a variable by using the `+=` operator. Here''s an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `+=` 运算符向变量追加内容。以下是一个示例：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can use the `declare` builtin to add attributes to variables. For example,
    the `-i` option for treating the variable as an integer, `-r` option for readonly,
    etc. These attributes can change the behavior of operators like `=` and `+=` for
    those variables. See [bash manual: Shell-Parameters](https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameters)
    and [bash manual: declare](https://www.gnu.org/software/bash/manual/bash.html#index-declare)
    for more details.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `declare` 内置命令向变量添加属性。例如，`-i` 选项用于将变量作为整数处理，`-r` 选项用于只读等。这些属性可以改变这些变量的
    `=` 和 `+=` 运算符的行为。有关更多详细信息，请参阅 [bash 手册：Shell 参数](https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameters)
    和 [bash 手册：declare](https://www.gnu.org/software/bash/manual/bash.html#index-declare)。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) ![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png)
    Assigning variables is one of the most common source for errors. Unlike most programming
    languages, spaces are *not* allowed around the `=` sign. That is because space
    is a shell metacharacter. Another common issue is using quotes (or not) around
    the value. Here are some examples:'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) ![警告](../Images/b5314b4a0acf0f436c4bf59486793342.png)
    赋值变量是错误最常见的来源之一。与大多数编程语言不同，`=` 符号周围不允许有空格。这是因为空格是一个shell元字符。另一个常见问题是使用（或不使用）引号来包围值。以下是一些示例：'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Arrays](#arrays)'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[数组](#arrays)'
- en: 'From [bash manual: Arrays](https://www.gnu.org/software/bash/manual/bash.html#Arrays):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [bash 手册：数组](https://www.gnu.org/software/bash/manual/bash.html#Arrays)：
- en: Bash provides one-dimensional indexed and associative array variables. Any variable
    may be used as an indexed array; the `declare` builtin will explicitly declare
    an array. There is no maximum limit on the size of an array, nor any requirement
    that members be indexed or assigned contiguously. Indexed arrays are referenced
    using integers and are zero-based; associative arrays use arbitrary strings.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Bash提供了一维索引和关联数组变量。任何变量都可以用作索引数组；`declare` 内置命令将显式声明一个数组。数组的大小没有最大限制，成员也不需要连续索引或分配。索引数组使用整数引用，且从零开始；关联数组使用任意字符串。
- en: 'Here''s an example of assigning an indexed array and various ways of accessing
    the elements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个分配索引数组和访问元素的各种方式的示例：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Parameter Expansion](#parameter-expansion)'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[参数扩展](#parameter-expansion)'
- en: Bash provides several useful ways to extract and modify the contents of parameters
    and variables (including arrays). Some of these features will be discussed in
    this section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Bash提供了几种有用的方法来提取和修改参数和变量（包括数组）的内容。本节将讨论这些功能的一些内容。
- en: '*1)* Substring extraction using `${parameter:offset}` syntax to get all characters
    from the given index:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*1)* 使用 `${parameter:offset}` 语法提取从给定索引开始的所有字符：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When applied to arrays, substring extraction will give you those elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于数组时，子字符串提取将给出以下元素：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*2)* Substring extraction using `${parameter:offset:length}` syntax to get
    specific number of characters from the given index:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*2)* 使用 `${parameter:offset:length}` 语法提取特定数量的字符，从给定的索引开始：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*3)* `${#parameter}` will give you the length of the string and `${#array[@]}`
    will give you the number of elements in the array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*3)* `${#parameter}` 将给出字符串的长度，而 `${#array[@]}` 将给出数组中的元素数量：'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*4)* `${parameter#glob}` will remove the shortest match from the start of the
    string. You can also use extended globs if enabled via the `shopt` builtin. `${parameter##glob}`
    will remove the longest match from the start of the string. Here are some examples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*4)* `${parameter#glob}` 将从字符串的开始处移除最短的匹配项。如果您通过 `shopt` 内置命令启用了扩展通配符，您也可以使用扩展通配符。`${parameter##glob}`
    将从字符串的开始处移除最长的匹配项。以下是一些示例：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*5)* You can use `${parameter%glob}` to remove the shortest match from the
    end of the string. `${parameter%%glob}` will remove the longest match from the
    end of the string.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*5)* 您可以使用 `${parameter%glob}` 从字符串的末尾移除最短的匹配项。`${parameter%%glob}` 将从字符串的末尾移除最长的匹配项。'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*6)* `${parameter/glob/string}` replaces the first matching occurrence with
    the given replacement string and `${parameter//glob/string}` will replace all
    the matching occurrences. You can leave out the `/string` portion when you want
    to delete the matching occurrences. The `glob` will match the longest portion,
    similar to greedy behavior in regular expressions. Here are some examples:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*6)* `${parameter/glob/string}` 将替换第一个匹配项为给定的替换字符串，而 `${parameter//glob/string}`
    将替换所有匹配项。当您想要删除匹配项时，可以省略 `/string` 部分。`glob` 将匹配最长部分，类似于正则表达式中的贪婪行为。以下是一些示例：'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*7)* You can use `${parameter/#glob/string}` to match only at the start of
    the string and `${parameter/%glob/string}` to match only at the end of the string.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*7)* 您可以使用 `${parameter/#glob/string}` 仅在字符串的开始处进行匹配，并使用 `${parameter/%glob/string}`
    仅在字符串的末尾进行匹配。'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*8)* `${parameter^glob}` can change only the first character to uppercase if
    matched by the glob. `${parameter^^glob}` changes all the matching characters
    to uppercase (anywhere in the input string). You should provide a glob that only
    matches one character in length. If the glob is omitted, entire parameter will
    be matched. These rules also apply to the lowercase and swap case versions discussed
    later.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*8)* `${parameter^glob}` 如果匹配 glob，则只能将第一个字符转换为大写。`${parameter^^glob}` 将所有匹配的字符转换为大写（输入字符串的任何位置）。您应该提供一个只匹配一个字符长度的
    glob。如果省略 glob，则整个参数将被匹配。这些规则也适用于稍后讨论的小写和大小写转换版本。'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*9)* To change the characters to lowercase, use `,` and `,,` as shown below:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*9)* 要将字符转换为小写，使用 `,` 和 `,,` 如下所示：'
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*10)* To swap case, use `~` and `~~` as shown below. Note that this seems to
    be deprecated, since it is no longer mentioned in the `bash` manual.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*10)* 要交换大小写，使用 `~` 和 `~~` 如下所示。注意，这似乎已被弃用，因为它不再在 `bash` 手册中提及。'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) See [bash manual: Shell
    Parameter Expansion](https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion)
    for more details and other types of expansions.'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 有关更多详细信息和其他类型的展开，请参阅
    [bash 手册：Shell 参数展开](https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion)。'
- en: '[Command Line Arguments](#command-line-arguments)'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[命令行参数](#command-line-arguments)'
- en: Command line arguments passed to a script (or a function) are saved in positional
    parameters starting with `1`, `2`, `3` etc. `0` contains the name of the shell
    or shell script. `@` contains all the positional parameters starting from `1`.
    Use `#` to get the number of positional parameters. Similar to variables, you
    need to use a `$` prefix to get the value stored in these parameters. If the parameter
    number requires more than a single digit, you have to necessarily enclose them
    in `{}` (for example, `${12}` to get the value of the twelfth parameter).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给脚本（或函数）的命令行参数将保存为以 `1`、`2`、`3` 等开始的定位参数。`0` 包含 shell 或 shell 脚本名称。`@` 包含从
    `1` 开始的所有定位参数。使用 `#` 获取定位参数的数量。类似于变量，您需要使用 `$` 前缀来获取这些参数中存储的值。如果参数编号需要超过单个数字，则必须将它们括在
    `{}` 中（例如，`${12}` 以获取第十二个参数的值）。
- en: 'Here''s an example script that accepts two arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个接受两个参数的示例脚本：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Further Reading**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '[unix.stackexchange: shell script choking on whitespace or other special characters](https://unix.stackexchange.com/q/131766/109046)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[unix.stackexchange：shell 脚本在空白或其他特殊字符上卡住](https://unix.stackexchange.com/q/131766/109046)'
- en: '[bash manual: Special Parameters](https://www.gnu.org/software/bash/manual/bash.html#Special-Parameters)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bash 手册：特殊参数](https://www.gnu.org/software/bash/manual/bash.html#Special-Parameters)'
- en: '[Conditional Expressions](#conditional-expressions)'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[条件表达式](#conditional-expressions)'
- en: You can test a condition within `[[` and `]]` to get a success (`0`) or failure
    (`1` or higher) exit status and take action accordingly. Bash provides several
    options and operators that you can use. Space is required after `[[` and before
    `]]` for this compound command to function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `[[` 和 `]]` 内测试条件，以获取成功（`0`）或失败（`1` 或更高）的退出状态，并据此采取行动。Bash 提供了您可以使用的一些选项和运算符。在此复合命令中，`[[`
    和 `]]` 之间需要有空格。
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Operators `;`, `&&`
    and `||` will be used in this section to keep the examples terser. `if-else` and
    other control structures will be discussed later.'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 在本节中，将使用运算符 `;`、`&&`
    和 `||` 以使示例更简洁。`if-else` 和其他控制结构将在稍后讨论。'
- en: '[Options](#options)'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[选项](#options)'
- en: The `-e` option checks if the given path argument exists or not. Add a `!` prefix
    to negate the condition.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 选项检查给定的路径参数是否存在。添加一个 `!` 前缀以否定条件。'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can use the `-d` and `-f` options to check if the path is a valid directory
    and file respectively. The `-s` option checks if the file exists and its size
    is greater than zero. The `-x` option checks if the file exists and is executable.
    See `help test` and [bash manual: Conditional Expressions](https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions)
    for a complete list of such options.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `-d` 和 `-f` 选项分别检查路径是否为有效目录和文件。`-s` 选项检查文件是否存在且大小大于零。`-x` 选项检查文件是否存在且可执行。有关此类选项的完整列表，请参阅
    `help test` 和 [bash 手册：条件表达式](https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions)。
- en: '[String comparisons](#string-comparisons)'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[字符串比较](#string-comparisons)'
- en: '`s1 = s2` or `s1 == s2` checks if two strings are equal'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s1 = s2` 或 `s1 == s2` 检查两个字符串是否相等'
- en: unquoted portions of `s2` will be treated as a wildcard while testing against
    `s1`
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s2`未引用的部分在测试与`s1`时将被视为通配符'
- en: '`extglob` would be considered as enabled for such comparisons'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于此类比较，`extglob`将被视为已启用
- en: '`s1 != s2` checks if strings are *not* equal'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s1 != s2`检查字符串是否**不**相等'
- en: unquoted portions of `s2` will be treated as a wildcard while testing against
    `s1`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s2`未引用的部分在测试与`s1`时将被视为通配符'
- en: '`extglob` would be considered as enabled for such comparisons'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于此类比较，`extglob`将被视为已启用
- en: '`s1 < s2` checks if `s1` sorts before `s2` lexicographically'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s1 < s2`检查`s1`在字典序上是否排在`s2`之前'
- en: '`s1 > s2` checks if `s1` sorts after `s2` lexicographically'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s1 > s2`检查`s1`在字典序上是否排在`s2`之后'
- en: '`s1 =~ s2` checks if `s1` matches the POSIX extended regular expression provided
    by `s2`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s1 =~ s2`检查`s1`是否与`s2`提供的POSIX扩展正则表达式匹配'
- en: exit status will be `2` if `s2` is not a valid regexp
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`s2`不是一个有效的正则表达式，则退出状态将为`2`
- en: 'Here are some examples for equal and not-equal comparisons:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些等于和不等于比较的示例：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here are some examples for greater-than and less-than comparisons:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些大于和小于比较的示例：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here are some examples for regexp comparison. You can use the special array
    `BASH_REMATCH` to retrieve specific portions of the string that was matched. Index
    `0` gives entire matched portion, `1` gives the portion matched by the first capture
    group and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些正则表达式比较的示例。你可以使用特殊的数组`BASH_REMATCH`来检索匹配的字符串的特定部分。索引`0`给出整个匹配部分，`1`给出第一个捕获组匹配的部分，依此类推。
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Numeric comparisons](#numeric-comparisons)'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Numeric comparisons](#numeric-comparisons)'
- en: '`n1 -eq n2` checks if two numbers are equal'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n1 -eq n2`检查两个数字是否相等'
- en: '`n1 -ne n2` checks if two numbers are *not* equal'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n1 -ne n2`检查两个数字是否**不**相等'
- en: '`n1 -gt n2` checks if `n1` is greater than `n2`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n1 -gt n2`检查`n1`是否大于`n2`'
- en: '`n1 -ge n2` checks if `n1` is greater than or equal to `n2`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n1 -ge n2`检查`n1`是否大于或等于`n2`'
- en: '`n1 -lt n2` checks if `n1` is less than `n2`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n1 -lt n2`检查`n1`是否小于`n2`'
- en: '`n1 -le n2` checks if `n1` is less than or equal to `n2`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n1 -le n2`检查`n1`是否小于或等于`n2`'
- en: These operators support only integer comparisons.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符仅支持整数比较。
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Numeric arithmetic operations and comparisons can also be performed within
    the `((` and `))` compound command. Here are some sample comparisons:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`((`和`))`复合命令中也可以执行数值算术运算和比较。以下是一些示例比较：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Note that the `$` prefix
    was *not* used for variables in the above examples. See [bash manual: Shell Arithmetic](https://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic)
    for more details.'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 注意，在上面的示例中未使用`$`前缀来表示变量。有关更多详细信息，请参阅[bash
    手册：Shell 算术](https://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic)。'
- en: '[Accepting user input interactively](#accepting-user-input-interactively)'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Accepting user input interactively](#accepting-user-input-interactively)'
- en: 'You can use the `read` builtin command to accept input from the user interactively.
    If multiple variables are given as arguments to the `read` command, values will
    be assigned based on whitespace separation by default. Any pending values will
    be assigned to the last variable. Here are some examples:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的`read`命令来交互式地接受用户输入。如果将多个变量作为`read`命令的参数，则默认根据空白分隔分配值。任何挂起的值都将分配给最后一个变量。以下是一些示例：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `-p` option helps you to add a user prompt. Here is an example of getting
    two arguments from the user:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`选项可以帮助你添加用户提示。以下是从用户那里获取两个参数的示例：'
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) You can use the `-a`
    option to assign an array, the `-d` option to specify a custom delimiter instead
    of newline for terminating user input and so on. See `help read` and [bash manual:
    Builtins](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins) for
    more details.'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 你可以使用`-a`选项来分配数组，使用`-d`选项来指定自定义分隔符以代替换行符来终止用户输入等。有关更多详细信息，请参阅`help
    read`和[bash 手册：内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)。'
- en: '[if then else](#if-then-else)'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[if then else](#if-then-else)'
- en: 'The keywords needed to construct an `if` control structure are `if`, `then`,
    `fi` and optionally `else` and `elif`. You can use compound commands like `[[`
    and `((` to provide the test condition. You can also directly use a command''s
    exit status. Here''s an example script:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造`if`控制结构所需的关键字是`if`、`then`、`fi`，可选的还有`else`和`elif`。你可以使用`[[`和`((`这样的复合命令来提供测试条件。你也可以直接使用命令的退出状态。以下是一个示例脚本：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`1>&2` is used in the above script to redirect error messages to the `stderr`
    stream. Sample script invocations are shown below:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，`1>&2` 用于将错误消息重定向到 `stderr` 流。以下是一些脚本调用示例：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sometimes you just need to know if the intended command operation was successful
    or not and then take an action depending on the outcome. In such cases, you can
    provide the command directly after the `if` keyword. Note that `stdout` and `stderr`
    of the command will still be active unless redirected or suppressed using appropriate
    options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只需要知道预期的命令操作是否成功，然后根据结果采取行动。在这种情况下，你可以在 `if` 关键字之后直接提供命令。请注意，除非使用适当的选项重定向或抑制，否则命令的
    `stdout` 和 `stderr` 仍然会保持活跃。
- en: 'For example, the `grep` command supports the `-q` option to suppress `stdout`.
    Here''s a script using that feature:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`grep` 命令支持 `-q` 选项来抑制 `stdout`。以下是一个使用该功能的脚本示例：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Sample invocations for the above script:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本的调用示例：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[for loop](#for-loop)'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[for 循环](#for-loop)'
- en: 'To construct a `for` loop, you''ll need the `for`, `do` and `done` keywords.
    Here are some examples:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个 `for` 循环，你需要 `for`、`do` 和 `done` 关键字。以下是一些示例：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As seen in the above examples, the space separated arguments provided after
    the `in` keyword are automatically assigned to the variable provided after the
    `for` keyword during each iteration.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述示例所示，在 `in` 关键字之后提供的空格分隔的参数将在每次迭代时自动分配给 `for` 关键字之后提供的变量。
- en: 'Here''s a modified example of the last example that accepts user provided command
    line arguments:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上一个示例的修改版本，它接受用户提供的命令行参数：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here''s an example of iterating over an array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个遍历数组的示例：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) You can use `continue`
    and `break` to alter the loop flow depending on specific conditions. See [bash
    manual: Bourne Shell Builtins](https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins)
    for more details.'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 你可以使用 `continue` 和 `break`
    根据特定条件改变循环流程。请参阅 [bash 手册：Bourne Shell 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins)
    以获取更多详细信息。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `for file;` is same
    as `for file in "$@";` since `in "$@"` is the default. I''d recommend using the
    explicit version.'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `for file;` 与 `for file
    in "$@";` 相同，因为 `in "$@"` 是默认值。我建议使用显式版本。'
- en: '[while loop](#while-loop)'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[while 循环](#while-loop)'
- en: Here's a simple `while` loop construct. You'll see a more practical example
    later in this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `while` 循环结构。你将在本章后面看到更实用的示例。
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Reading a file](#reading-a-file)'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[读取文件](#reading-a-file)'
- en: 'The `while` loop in combination with the `read` builtin can be used to process
    the content of a file. Here''s an example of reading input contents line by line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `while` 循环与内置的 `read` 命令结合使用可以处理文件的正文内容。以下是一个逐行读取输入内容的示例：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The intention in the above script is to treat each input line literally. So,
    the `IFS` (input field separator) special variable is set to an empty string to
    prevent stripping of leading and trailing whitespaces. The `-r` option to the
    `read` builtin allows `\` in the input to be treated literally. Note that the
    input filename is accepted as the first command line argument and redirected as
    `stdin` to the `while` loop. You also need to make sure that the last line of
    the input ends with a newline character, otherwise the last line won't be processed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中的意图是逐字处理每个输入行。因此，将 `IFS`（输入字段分隔符）特殊变量设置为空字符串，以防止删除前导和尾随空格。`read` 命令的 `-r`
    选项允许输入中的 `\` 被逐字处理。请注意，输入文件名作为第一个命令行参数接受，并重定向为 `stdin` 到 `while` 循环。你还需要确保输入的最后一行以换行符结束，否则最后一行将不会被处理。
- en: 'You can change `IFS` to split the input line into different fields and specify
    appropriate number of variables to the `read` builtin. Here''s an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `IFS` 改变以将输入行分割成不同的字段，并指定适当的变量数量给 `read` 命令。以下是一个示例：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can pass a number to the `-n` option for the `read` builtin to process
    the input that many characters at a time. Here''s an example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `read` 命令的 `-n` 选项传递一个数字，以便每次处理这么多字符的输入。以下是一个示例：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The `xargs` command
    can also be used for some of the cases discussed above. See [unix.stackexchange:
    parse each line of a text file as a command argument](https://unix.stackexchange.com/q/149726/109046)
    for examples.'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) `xargs` 命令也可以用于上述讨论的一些情况。请参阅
    [unix.stackexchange: 将文本文件的每一行作为命令参数解析](https://unix.stackexchange.com/q/149726/109046)
    以获取示例。'
- en: '[Functions](#functions)'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[函数](#functions)'
- en: 'From [bash manual: Shell Functions](https://www.gnu.org/software/bash/manual/bash.html#Shell-Functions):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [bash 手册：Shell 函数](https://www.gnu.org/software/bash/manual/bash.html#Shell-Functions)：
- en: Shell functions are a way to group commands for later execution using a single
    name for the group. They are executed just like a "regular" command. When the
    name of a shell function is used as a simple command name, the list of commands
    associated with that function name is executed. Shell functions are executed in
    the current shell context; no new process is created to interpret them.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Shell 函数是一种将命令分组以便以后使用单个名称执行的方法。它们就像“常规”命令一样执行。当使用 shell 函数的名称作为简单命令名称时，将执行与该函数名称关联的命令列表。Shell
    函数在当前 shell 上下文中执行；不会创建新进程来解释它们。
- en: 'You can use either of the syntax shown below to declare functions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下任一语法来声明函数：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Arguments to functions are passed in the same manner as those discussed earlier
    for shell scripts. Here''s an example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数传递方式与之前讨论的 shell 脚本中的方式相同。以下是一个例子：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the above example, `echo` is used to display the command that will be executed.
    Remove `echo` if you want this script to actually create new images with the given
    parameters. The function accepts one to three arguments and uses default values
    when some of the arguments are not passed. Here''s the output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，`echo` 用于显示将要执行的命令。如果您想使此脚本实际使用给定参数创建新图像，请删除 `echo`。该函数接受一到三个参数，并在某些参数未传递时使用默认值。以下是输出：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Use `mogrify` instead
    of `convert` if you want to modify the input image inplace instead of creating
    a new image. These image manipulation commands are part of the [ImageMagick](https://imagemagick.org/)
    suite. As an exercise, modify the above function to generate an error if the arguments
    passed do not match the expected usage. You can also accept an output image name
    (or perhaps a different suffix) as an additional argument.'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 如果您想就地修改输入图像而不是创建新图像，请使用
    `mogrify` 而不是 `convert`。这些图像处理命令是 [ImageMagick](https://imagemagick.org/) 套件的一部分。作为练习，修改上述函数以在传递的参数与预期用法不匹配时生成错误。您还可以接受一个输出图像名称（或可能是一个不同的后缀）作为附加参数。'
- en: The shell script and user defined functions (which in turn might call itself
    or another function) can both have positional arguments. In such cases, the shell
    takes cares of restoring positional arguments to the earlier state once a function
    completes its tasks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: shell 脚本和用户定义的函数（这些函数可能又会调用自身或另一个函数）都可以有位置参数。在这种情况下，shell 会确保在函数完成任务后恢复位置参数到早期状态。
- en: Functions have exit status as well, which is based on the last executed command
    by default. You can use the `return` builtin to provide your own custom exit status.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也有退出状态，默认情况下基于最后执行的命令。您可以使用 `return` 内置命令提供自己的自定义退出状态。
- en: '[Debugging](#debugging)'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[调试](#debugging)'
- en: 'You can use the following `bash` options for debugging purposes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下 `bash` 选项进行调试：
- en: '`-x` print commands and their arguments as they are executed'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x` 在执行时打印命令及其参数'
- en: '`-v` verbose option, print shell input lines as they are read'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 详细选项，打印读取的 shell 输入行'
- en: 'Here''s an example with the `bash -x` option:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 `bash -x` 选项的例子：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The lines starting with `+` show the command being executed with expanded values
    if applicable (the `search` variable to `grep -q` for example). Multiple `+` will
    be used if there are multiple expansions. Here''s how `bash -xv` would behave
    for the same script:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `+` 开头的行显示了如果适用（例如，`search` 变量用于 `grep -q`）正在执行的命令及其展开值。如果有多个展开，将使用多个 `+`。以下是
    `bash -xv` 对同一脚本的行为：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) You can also use `set
    -x` or `set -v` or `set -xv` from within the script to debug from a particular
    point onwards. You can turn off such debugging by using `+` instead of `-` as
    the option prefix (for example, `set +x`).'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 您也可以在脚本内部使用 `set -x`
    或 `set -v` 或 `set -xv` 从特定点开始进行调试。您可以通过使用 `+` 而不是 `-` 作为选项前缀来关闭此类调试（例如，`set +x`）。'
- en: '[shellcheck](#shellcheck)'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[shellcheck](#shellcheck)'
- en: '[shellcheck](https://www.shellcheck.net/) is a static analysis tool that gives
    warnings and suggestions for scripts. You can use it online or install the tool
    for offline use. Given the various `bash` gotchas, this tool is highly recommended
    for both beginners and advanced users.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[shellcheck](https://www.shellcheck.net/) 是一个静态分析工具，为脚本提供警告和建议。您可以在网上使用它，或者安装工具以供离线使用。鉴于各种
    `bash` 的陷阱，此工具非常推荐初学者和高级用户使用。'
- en: 'Consider this script:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下脚本：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here''s how `shellcheck` reports the issue:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `shellcheck` 报告问题的方法：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) If the script doesn''t
    have a shebang, you can use the `-s` option (`shellcheck -s bash` for example)
    to specify the shell application.'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 如果脚本没有 shebang，您可以使用
    `-s` 选项（例如 `shellcheck -s bash`）来指定 shell 应用程序。'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) ![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png)
    Note that `shellcheck` will not catch all types of issues. And suggestions should
    not be blindly accepted without understanding if it makes sense in the given context.'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) ![警告](../Images/b5314b4a0acf0f436c4bf59486793342.png)
    注意，`shellcheck` 不会捕获所有类型的问题。并且，如果没有理解在给定上下文中是否合理，就不应盲目接受建议。'
- en: '[Resource lists](#resource-lists)'
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[资源列表](#resource-lists)'
- en: 'Here are some more learning resources:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的学习资源：
- en: '**Shell Scripting**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell 脚本**'
- en: '[Bash Guide](https://mywiki.wooledge.org/BashGuide) — aspires to teach good
    practice techniques for using Bash, and writing simple scripts'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash 指南](https://mywiki.wooledge.org/BashGuide) — 致力于教授使用 Bash 的良好实践技术，以及编写简单的脚本'
- en: '[Bash Scripting Tutorial](https://ryanstutorials.net/bash-scripting-tutorial/)
    — solid foundation in how to write Bash scripts, to get the computer to do complex,
    repetitive tasks for you'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash 脚本教程](https://ryanstutorials.net/bash-scripting-tutorial/) — 在如何编写 Bash
    脚本方面打下坚实的基础，以便让计算机为您完成复杂、重复的任务'
- en: '[bash-handbook](https://github.com/denysdovhan/bash-handbook) — for those who
    want to learn Bash without diving in too deeply'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bash-handbook](https://github.com/denysdovhan/bash-handbook) — 对于那些不想深入研究
    Bash 的人来说'
- en: '[Serious Shell Programming](https://freebsdfrau.gitbook.io/serious-shell-programming/)
    — focuses on POSIX-compliant Bourne Shell for portability'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[严肃的 Shell 编程](https://freebsdfrau.gitbook.io/serious-shell-programming/) —
    专注于 POSIX 兼容的 Bourne Shell 以实现可移植性'
- en: '**Handy tools, tips and reference**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**实用工具、技巧和参考**'
- en: '[shellcheck](https://www.shellcheck.net/) — linting tool to avoid common mistakes
    and improve your script'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[shellcheck](https://www.shellcheck.net/) — 检查工具，以避免常见错误并提高您的脚本质量'
- en: '[Bash reference cheatsheet](https://devmanual.gentoo.org/tools-reference/bash/index.html)
    — nicely formatted and explained well'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash 参考速查表](https://devmanual.gentoo.org/tools-reference/bash/index.html)
    — 格式良好，解释得当'
- en: '[Bash scripting cheatsheet](https://devhints.io/bash) — quick reference to
    getting started with Bash scripting'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash 脚本速查表](https://devhints.io/bash) — Bash 脚本入门的快速参考'
- en: 'Comprehensive lists on the `mywiki.wooledge.org` website:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `mywiki.wooledge.org` 网站上的综合列表：
- en: '[Bash FAQ](https://mywiki.wooledge.org/BashFAQ)'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash FAQ](https://mywiki.wooledge.org/BashFAQ)'
- en: '[Bash Practices](https://mywiki.wooledge.org/BashGuide/Practices)'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash 实践](https://mywiki.wooledge.org/BashGuide/Practices)'
- en: '[Bash Pitfalls](https://mywiki.wooledge.org/BashPitfalls)'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bash 陷阱](https://mywiki.wooledge.org/BashPitfalls)'
- en: '[Google shell style guide](https://google.github.io/styleguide/shellguide.html)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google Shell 风格指南](https://google.github.io/styleguide/shellguide.html)'
- en: Reliability and robustness
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性和健壮性
- en: '[safe ways to do things in bash](https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md)'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 bash 中安全做事的方法](https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md)'
- en: '[better scripting](https://robertmuth.blogspot.com/2012/08/better-bash-scripting-in-15-minutes.html)'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更好的脚本编写](https://robertmuth.blogspot.com/2012/08/better-bash-scripting-in-15-minutes.html)'
- en: '[robust scripting](https://www.davidpashley.com/articles/writing-robust-shell-scripts/)'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[健壮的脚本编写](https://www.davidpashley.com/articles/writing-robust-shell-scripts/)'
- en: '**Specific topics**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**特定主题**'
- en: Reading files
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件
- en: '[Robust way to read files for various use cases](https://mywiki.wooledge.org/BashFAQ/001)'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[针对各种用例的健壮的读取文件方法](https://mywiki.wooledge.org/BashFAQ/001)'
- en: '[Loop through the lines of two files in parallel](https://unix.stackexchange.com/q/82541/109046)'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并行遍历两个文件的行](https://unix.stackexchange.com/q/82541/109046)'
- en: '[arrays](https://mywiki.wooledge.org/BashGuide/Arrays)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数组](https://mywiki.wooledge.org/BashGuide/Arrays)'
- en: '[nameref](https://unix.stackexchange.com/q/288886/109046)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[nameref](https://unix.stackexchange.com/q/288886/109046)'
- en: also see this [FAQ](https://mywiki.wooledge.org/BashFAQ/006)
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也请参阅此 [FAQ](https://mywiki.wooledge.org/BashFAQ/006)
- en: getopts
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: getopts
- en: '[getopts tutorial](https://web.archive.org/web/20221226035414/https://wiki.bash-hackers.org/howto/getopts_tutorial)'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[getopts 教程](https://web.archive.org/web/20221226035414/https://wiki.bash-hackers.org/howto/getopts_tutorial)'
- en: '[handling command-line arguments](https://mywiki.wooledge.org/BashFAQ/035)'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理命令行参数](https://mywiki.wooledge.org/BashFAQ/035)'
- en: '[stackoverflow: getopts example](https://stackoverflow.com/q/16483119/4082052)'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[stackoverflow: getopts 示例](https://stackoverflow.com/q/16483119/4082052)'
- en: '[Sending and Trapping Signals](https://mywiki.wooledge.org/SignalTrap)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[发送和捕获信号](https://mywiki.wooledge.org/SignalTrap)'
- en: '[Exercises](#exercises)'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Use a temporary working
    directory before attempting the exercises. You can delete such practice directories
    afterwards.'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![信息](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) 在尝试练习之前使用临时工作目录。之后可以删除此类练习目录。'
- en: '**1)** What''s wrong with the script shown below? Also, will the error go away
    if you use `bash try.sh` instead?'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**1)** 下面的脚本有什么问题？如果你使用 `bash try.sh` 替代，错误会消失吗？'
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**2)** Will the command shown below work? If so, what would be the output?'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**2)** 以下命令会工作吗？如果是，输出会是什么？'
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**3)** When would you `source` a script instead of using `bash` or creating
    an executable using shebang?'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**3)** 在什么情况下你会使用 `source` 脚本而不是使用 `bash` 或通过 shebang 创建可执行文件？'
- en: '**4)** How would you display the contents of a variable with `shake` appended?'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**4)** 你会如何显示带有 `shake` 后缀的变量的内容？'
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**5)** What changes would you make to the code shown below to get the expected
    output?'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**5)** 你会如何修改以下代码以获得预期的输出？'
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**6)** Is the following code valid? If so, what would be the output of the
    `echo` command?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**6)** 以下代码是否有效？如果是，`echo` 命令的输出会是什么？'
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**7)** How would you get the last three characters of a variable''s contents?'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**7)** 你会如何获取一个变量的最后三个字符？'
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**8)** Will the second `echo` command give an error? If not, what will be the
    output?'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**8)** 第二个 `echo` 命令会出错吗？如果没有，输出会是什么？'
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**9)** For the given array, use parameter expansion to remove characters until
    the first/last space.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**9)** 对于给定的数组，使用参数扩展来删除直到第一个/最后一个空格的字符。'
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**10)** Use parameter expansion to get the expected outputs shown below.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**10)** 使用参数扩展来获取以下显示的预期输出。'
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**11)** Is it possible to achieve the expected outputs shown below using parameter
    expansion? If so, how?'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**11)** 是否可以使用参数扩展来实现以下预期的输出？如果是，如何实现？'
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**12)** For the given input, change case as per the expected outputs shown
    below.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**12)** 对于给定的输入，按照以下显示的预期输出更改大小写。'
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**13)** Why does the conditional expression shown below fail?'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**13)** 为什么下面的条件表达式失败了？'
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**14)** What is the difference between the `==` and `=~` string comparison
    operators?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**14)** `==` 和 `=~` 字符串比较操作符之间的区别是什么？'
- en: '**15)** Why does the conditional expression used below show `failed` both times?
    Modify the expressions such that the first one correctly says `matched` instead
    of `failed`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**15)** 为什么下面的条件表达式两次都显示 `failed`？修改表达式，使得第一个正确显示 `matched` 而不是 `failed`。'
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**16)** Extract the digits that follow a `:` character for the given variable
    contents.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**16)** 提取给定变量内容中 `:` 字符后面的数字。'
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**17)** Modify the expression shown below to correctly report `true` instead
    of `false`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**17)** 如何修改以下表达式以正确报告 `true` 而不是 `false`？'
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**18)** Write a shell script named `array.sh` that accepts array input from
    the user followed by another input as index. Display the corresponding value at
    that index. Couple of examples are shown below.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**18)** 编写一个名为 `array.sh` 的 shell 脚本，该脚本接受用户输入的数组，然后是另一个作为索引的输入。显示该索引处的对应值。以下显示了几个示例。'
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**19)** Write a shell script named `case.sh` that accepts exactly two command
    line arguments. The first argument can be `lower`, `upper` or `swap` and this
    should be used to transform the contents of the second argument. Examples script
    invocations are shown below, including what should happen if the command line
    arguments do not meet the script expectations.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**19)** 编写一个名为 `case.sh` 的 shell 脚本，该脚本接受恰好两个命令行参数。第一个参数可以是 `lower`、`upper`
    或 `swap`，并应用于转换第二个参数的内容。以下显示了脚本调用示例，包括如果命令行参数不符合脚本预期会发生什么。'
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**20)** Write a shell script named `loop.sh` that displays the number of lines
    for each of the files passed as command line arguments.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**20)** 编写一个名为 `loop.sh` 的 shell 脚本，该脚本显示作为命令行参数传递的每个文件的行数。'
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**21)** Write a shell script named `read_file.sh` that reads a file line by
    line to be passed as an argument to the `paste -sd,` command. Can you also write
    a solution using the `xargs` command instead of a script?'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**21)** 编写一个名为 `read_file.sh` 的 shell 脚本，该脚本逐行读取文件并将其作为参数传递给 `paste -sd,` 命令。你能否也使用
    `xargs` 命令而不是脚本编写一个解决方案？'
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**22)** Write a function named `add_path` which prefixes the path of the current
    working directory to the arguments it receives and displays the results. Examples
    are shown below.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**22)** 编写一个名为 `add_path` 的函数，该函数将当前工作目录的路径添加到它接收的参数之前，并显示结果。以下是一些示例。'
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**23)** What do the options `bash -x` and `bash -v` do?'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**23)** 选项 `bash -x` 和 `bash -v` 的作用是什么？'
- en: '**24)** What is `shellcheck` and when would you use it?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**24)** 什么是 `shellcheck` 以及你会在什么情况下使用它？'
