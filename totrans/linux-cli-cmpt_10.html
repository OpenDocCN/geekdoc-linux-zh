<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Managing Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Managing Processes</h1>
<blockquote>原文：<a href="https://learnbyexample.github.io/cli-computing/managing-processes.html">https://learnbyexample.github.io/cli-computing/managing-processes.html</a></blockquote><p>This chapter gives a basic overview of process management for interactive usage only. Handling processes for other use cases, such as system administration, requires a more robust solution (see <a href="https://mywiki.wooledge.org/ProcessManagement">mywiki.wooledge: Process Management</a> to get started for such use cases).</p><h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2><p>Here are some definitions that will be handy to know for this chapter's contents:</p><ul><li><strong>Program</strong> is a set of instructions written to perform a task</li><li><strong>Process</strong> is any running program</li><li><strong>Daemon</strong> are background processes</li><li><strong>Job</strong> is a process that is not a daemon <ul><li>i.e. jobs are interactive programs under user control</li></ul></li></ul><h2 id="running-jobs-in-background"><a class="header" href="#running-jobs-in-background">Running jobs in background</a></h2><p>Some commands and scripts can take more than few minutes to complete, and you might still need to continue using the shell. If you are not dependent on the current shell environment, you could just open another shell instance and continue working.</p><p>Another option is to push the job to the background, either at the time of command invocation itself or after the fact. Make sure to redirect standard output and error to avoid interfering with your continued interactive usage. Appending <code>&amp;</code> to the command will execute it in the background.</p><pre><code class="language-bash">$ tkdiff ip.txt ip.txt.bkp &amp;
[1] 12726
</code></pre><p>In the above example, <code>[1]</code> refers to the job number and <code>12726</code> is the PID (process ID). You can use the <code>jobs</code> and <code>ps</code> commands to track active jobs:</p><pre><code class="language-bash">$ jobs
[1]+  Running                 tkdiff ip.txt ip.txt.bkp &amp;

$ ps
    PID TTY          TIME CMD
   9657 pts/1    00:00:00 bash
  12726 pts/1    00:00:00 wish
  12730 pts/1    00:00:00 ps
</code></pre><p>But what if you forgot to append <code>&amp;</code> to the command? You can follow these steps:</p><ul><li><code>Ctrl+z</code> — suspend the current running job</li><li><code>bg</code> — push the recently suspended job to the background</li><li>continue using shell</li><li><code>fg</code> — bring the recently pushed background job to the foreground <ul><li>you can use <code>fg %n</code> to bring the <code>n</code>th job number to the foreground</li></ul></li></ul><p>Here's a demo that you can try:</p><pre><code class="language-bash"># sleep for 30 seconds (used here for illustration purposes)
# press Ctrl+z to suspend this job
# you'll get the job number, status and the command in the output
$ sleep 30
^Z
[1]+  Stopped                 sleep 30

# bg puts the job considered as the current by the shell to the background
$ bg
[1]+ sleep 30 &amp;

# use 'jobs' or 'ps' to check list of jobs
# '+' after the job number is used to indicate the current job
$ jobs
[1]+  Running                 sleep 30 &amp;
$ ps
    PID TTY          TIME CMD
   2380 pts/0    00:00:00 bash
   6160 pts/0    00:00:00 sleep
   6162 pts/0    00:00:00 ps

# fg brings the most recently pushed background job to the foreground
$ fg
sleep 30
$ 
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <code>jobs</code>, <code>bg</code> and <code>fg</code> are shell builtins. See <a href="https://www.gnu.org/software/bash/manual/bash.html#Job-Control">bash manual: Job Control</a> for more details. See also <a href="https://www.digitalocean.com/community/tutorials/how-to-use-bash-s-job-control-to-manage-foreground-and-background-processes">this tutorial on job control</a>.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See also <a href="https://mywiki.wooledge.org/ProcessManagement#I_want_to_run_something_in_the_background_and_then_log_out.">I want to run something in the background and then log out</a> — <code>screen</code>, <code>tmux</code>, <code>nohup</code>, <code>disown</code>, etc.</p></blockquote><h2 id="ps"><a class="header" href="#ps">ps</a></h2><p>The <code>ps</code> command gives a snapshot of the current processes. A few examples were already seen earlier in this chapter. Here's an example with the <code>-f</code> option (full-format listing):</p><pre><code class="language-bash">$ ps -f
UID          PID    PPID  C STIME TTY          TIME CMD
learnby+   12299   12298  0 16:39 pts/0    00:00:00 bash
learnby+   12311   12299  0 16:39 pts/0    00:00:00 ps -f
</code></pre><p>The fields in the above example are effective user ID (UID), process ID (PID), parent process ID (PPID), processor utilization (C), starting time (STIME), controlling terminal (TTY), cumulative CPU time (TIME) and command with all its arguments (CMD). You can use the <code>-o</code> option to customize the fields you want. The <code>--sort</code> option will help you to sort based on specific fields. See <a href="https://www.mankier.com/1/ps#Standard_Format_Specifiers">ps manual: Standard Format Specifiers</a> for complete list of formats available.</p><p>The <code>-e</code> (or <code>-A</code>) option selects all processes. This option is typically used in combination with <code>grep</code> for filtering:</p><pre><code class="language-bash">$ ps -e | grep 'vim'
   6195 ?        00:03:13 gvim
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See also <a href="https://linuxjourney.com/lesson/monitor-processes-ps-command">linuxjourney: ps tutorial</a>.</p></blockquote><h2 id="pgrep"><a class="header" href="#pgrep">pgrep</a></h2><p>The <code>pgrep</code> command helps you filter processes based on their name and attributes. By default, it matches against the process name, for example:</p><pre><code class="language-bash">$ ps -e | grep 'vim'
   2006 ?        00:00:27 gvim
   3992 pts/2    00:00:00 vim

$ pgrep 'vim'
2006
3992
</code></pre><p>You can use the <code>-l</code> option to display the process name as well (PID is shown by default).</p><pre><code class="language-bash">$ pgrep -l 'vim'
2006 gvim
3992 vim
</code></pre><p>To match the process name exactly (instead of matching anywhere), use the <code>-x</code> option.</p><pre><code class="language-bash">$ pgrep -x 'vim'
3992
</code></pre><p>The <code>-a</code> option will list the full command line (the <code>-l</code> option seen earlier gives only the name, not the arguments).</p><pre><code class="language-bash">$ pgrep -a 'vim'
2006 gvim -p notes.txt src/managing-processes.md
3992 vim substitution.md
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> There are several more options like filtering based on effective UID, PPID, etc. See <a href="https://www.mankier.com/1/pgrep">pgrep manual</a> for more details.</p></blockquote><h2 id="kill"><a class="header" href="#kill">kill</a></h2><p>Sometimes, a process might not be responding to your interaction attempts, might be taking too long, accidentally uses too much memory, and so on. You can use the <code>kill</code> command to manage such processes.</p><p>As mentioned at the beginning of this chapter, these examples are suggested for interactive processes initiated by you (shell scripts, for example, will require different strategies). Be 100% sure before you attempt to send signals to manage processes.</p><p>You can pass signals by name or by their associated number. Use <code>kill -l</code> to get a full list of signals. See also <a href="https://unix.stackexchange.com/q/317492/109046">unix.stackexchange: List of Signals</a> and <a href="https://unix.stackexchange.com/q/6332/109046">unix.stackexchange: What causes various signals to be sent?</a>.</p><pre><code class="language-bash"># first 20 signals (out of 64) listed below
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
...
</code></pre><p>You can use the PID or job number to specify the process to which the signal has to be sent. By default, <code>SIGTERM</code> (<code>15</code>) is sent, which is a polite way to ask the program to terminate. Here's an example:</p><pre><code class="language-bash"># 'sleep' is used here to emulate a long running process
# press Ctrl+z to suspend this command
$ sleep 100
^Z
[1]+  Stopped                 sleep 100

# terminate job number 1
# by default, SIGTERM is sent
$ kill %1
# just press Enter
$
[1]+  Terminated              sleep 100
</code></pre><p>Note that in the above example, pressing <code>Ctrl+z</code> actually sends the <code>SIGTSTP</code> (<code>20</code>) signal. Programs usually handle such signals to find a safer spot to suspend. Pressing <code>Ctrl+c</code> sends the <code>SIGINT</code> (<code>2</code>) signal, usually used to abort a process (depends on how the program handles it). You can use <code>Ctrl+\</code> to send <code>SIGQUIT</code> (<code>3</code>), typically used to ask the program to quit and give a <a href="https://en.wikipedia.org/wiki/Core_dump">core dump</a>. See also <a href="https://stackoverflow.com/q/690415/4082052">stackoverflow: gracefully shutdown processes</a>.</p><p>Here's an illustration to show how to pass signals by their names and numerical values:</p><pre><code class="language-bash">$ sleep 100 &amp;
[1] 10051

# suspend the above job, similar to using Ctrl+z
# -20 refers to the signal number 20, i.e. SIGTSTP
# 10051 is the PID
$ kill -20 10051

[1]+  Stopped                 sleep 100

# resume the job in background
$ bg
[1]+ sleep 100 &amp;

# the -s option allows you to specify signal by its name
# '-s SIGTERM' is optional here, since that is the default
$ kill -s SIGTERM 10051
$ 
[1]+  Terminated              sleep 100
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> If you need to terminate a process at all costs, you can use <code>SIGKILL</code> (<code>9</code>). This is a signal that cannot be blocked by programs. Use <code>Ctrl+z</code> to suspend a runaway job and then apply <code>kill -9</code> instead of trying to abort such jobs using <code>Ctrl+c</code>. See also <a href="https://unix.stackexchange.com/q/8916/109046">unix.stackexchange: why kill -9 should be avoided</a>.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Note that your system will likely have several different implementations of the <code>kill</code> command. The shell builtin version was discussed in this section.</p></blockquote><h2 id="top"><a class="header" href="#top">top</a></h2><p>The <code>top</code> command displays processes in a tabular format along with information like PID, process name, memory usage and so on. Here's a sample screenshot:</p><p align="center"><img alt="sample screenshot for the top command" src="../Images/f5b01783dbf406f68a37befbd1efa1f7.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/top_example.png"/></p><p>This command opens an interactive session, and automatically updates the information being displayed as well. You can press <code>M</code> (uppercase) to sort the processes by memory usage. Press <code>e</code> repeatedly to display memory sizes in terms of mega/giga/etc. Press <code>h</code> for help and press <code>q</code> to quit the session.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Press <code>W</code> (uppercase) to write the current settings to the <code>toprc</code> configuration file and quit. The next time you use the <code>top</code> command, it will be displayed in the format that was saved.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See also alternative implementations like <a href="https://github.com/htop-dev/htop/">htop</a> and <a href="https://github.com/aristocratos/btop">btop</a>.</p></blockquote><h2 id="free"><a class="header" href="#free">free</a></h2><p>The <code>free</code> command displays information about your system memory. Here's an example:</p><pre><code class="language-bash"># -h option shows the results in human readable format
$ free -h
              total        used        free      shared  buff/cache   available
Mem:          7.6Gi       2.4Gi       2.3Gi       267Mi       2.9Gi       4.7Gi
Swap:         3.6Gi          0B       3.6Gi
</code></pre><h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2><ul><li><a href="https://mywiki.wooledge.org/ProcessManagement">mywiki.wooledge: Process Management</a></li><li><a href="https://ryanstutorials.net/linuxtutorial/processes.php">ryanstutorials: Process Management</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-ps-kill-and-nice-to-manage-processes-in-linux">digitalocean: Managing Linux Processes</a></li><li><a href="https://www.linuxatemyram.com/">Linux ate my ram</a> — Linux is borrowing unused memory for disk caching. This makes it look like you are low on memory, but you are not! Everything is fine!</li></ul><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2><p><strong>1)</strong> How would you invoke a command to be executed in the background? And what would you do to push a job to the background after it has already been launched? What commands can you use to track active jobs?</p><p><strong>2)</strong> What do the <code>+</code> and <code>-</code> symbols next to job numbers indicate?</p><p><strong>3)</strong> When would you use <code>fg %n</code> and <code>bg %n</code> instead of just <code>fg</code> and <code>bg</code> respectively?</p><p><strong>4)</strong> Which option will help you customize the output fields needed for the <code>ps</code> command?</p><p><strong>5)</strong> What's the difference between <code>pgrep -a</code> and <code>pgrep -l</code> options?</p><p><strong>6)</strong> If the job number is <code>2</code>, would you use <code>kill %2</code> or <code>kill 2</code> to send <code>SIGTERM</code> to that process?</p><p><strong>7)</strong> Which signal does the <code>Ctrl+c</code> shortcut send to the currently running process?</p><p><strong>8)</strong> Which command helps you to continuously monitor processes, along with details like PID, memory usage, etc?</p><p><strong>9)</strong> Which key will help you manipulate kill tasks from within the <code>top</code> session?</p><p><strong>10)</strong> What does the <code>free</code> command do?</p>    
</body>
</html>