<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch063.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="cmdline__urls__fragment__md-_-_-fragment" class="level1" data-number="62">
<h1 data-number="62">Fragment</h1>
<p>URLs offer a fragment part. That is usually seen as a hash symbol (<code>#</code>) and a name for a specific name within a webpage in browsers. An example of such a URL might look like:</p>
<pre><code>https://www.example.com/info.html#the-plot</code></pre>
<p>curl supports fragments fine when a URL is passed to it, but the fragment part is never actually sent over the wire so it does not make a difference to curlâ€™s operations whether it is present or not.</p>
<p>If you want to make the <code>#</code> character as part of the path and not separating the fragment, make sure to pass it URL-encoded, as <code>%23</code>:</p>
<pre><code>curl https://www.example.com/info.html%23the-plot</code></pre>
<section id="cmdline__urls__fragment__md-_-_-a-fragment-trick" class="level2" data-number="62.1">
<h2 data-number="62.1">A fragment trick</h2>
<p>The fact that the fragment part is not actually used over the network can be taken advantage of when you craft command lines.</p>
<p>For example, if you want to request the same URL from a server 10 times, you can make a loop and put the loop instruction in the fragment part. Like this:</p>
<pre><code>curl https://example.com/#[1-10]</code></pre>
<p><span id="cmdline__urls__browsers__md"></span></p>
</section>
</section>
</body>
</html>
