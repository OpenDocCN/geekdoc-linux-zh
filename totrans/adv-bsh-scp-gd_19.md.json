["```sh #!/bin/bash\n# spawn.sh\n\nPIDS=$(pidof sh $0)  # Process IDs of the various instances of this script.\nP_array=( $PIDS )    # Put them in an array (why?).\necho $PIDS           # Show process IDs of parent and child processes.\nlet \"instances = ${#P_array[*]} - 1\"  # Count elements, less 1.\n                                      # Why subtract 1?\necho \"$instances instance(s) of this script running.\"\necho \"[Hit Ctl-C to exit.]\"; echo\n\nsleep 1              # Wait.\nsh $0                # Play it again, Sam.\n\nexit 0               # Not necessary; script will never get to here.\n                     # Why not?\n\n#  After exiting with a Ctl-C,\n#+ do all the spawned instances of the script die?\n#  If so, why?\n\n# Note:\n# ----\n# Be careful not to run this script too long.\n# It will eventually eat up too many system resources.\n\n#  Is having a script spawn multiple instances of itself\n#+ an advisable scripting technique.\n#  Why or why not?\n```", "```sh #!/bin/bash\n\necho \"This line uses the \\\"echo\\\" builtin.\"\n/bin/echo \"This line uses the /bin/echo system command.\"\n```", "```sh echo Hello\necho $a\n```", "```sh if echo \"$VAR\" &#124; grep -q txt   # if [[ $VAR = *txt* ]]\nthen\n  echo \"$VAR contains the substring sequence \\\"txt\\\"\"\nfi\n```", "```sh bash$ **ls -l /usr/share/apps/kjezz/sounds**\n-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au\n -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au\n\nbash$ **echo `ls -l /usr/share/apps/kjezz/sounds`**\ntotal 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...\n\n```", "```sh # Embedding a linefeed?\necho \"Why doesn't this string \\n split on two lines?\"\n# Doesn't split.\n\n# Let's try something else.\n\necho\n\necho $\"A line of text containing\na linefeed.\"\n# Prints as two distinct lines (embedded linefeed).\n# But, is the \"$\" variable prefix really necessary?\n\necho\n\necho \"This string splits\non two lines.\"\n# No, the \"$\" is not needed.\n\necho\necho \"---------------\"\necho\n\necho -n $\"Another line of text containing\na linefeed.\"\n# Prints as two distinct lines (embedded linefeed).\n# Even the -n option fails to suppress the linefeed here.\n\necho\necho\necho \"---------------\"\necho\necho\n\n# However, the following doesn't work as expected.\n# Why not? Hint: Assignment to a variable.\nstring1=$\"Yet another line of text containing\na linefeed (maybe).\"\n\necho $string1\n# Yet another line of text containing a linefeed (maybe).\n#                                    ^\n# Linefeed becomes a space.\n\n# Thanks, Steve Parker, for pointing this out.\n```", "```sh bash$ **type -a echo**\necho is a shell builtin\n echo is /bin/echo\n\n```", "```sh #!/bin/bash\n# printf demo\n\ndeclare -r PI=3.14159265358979     # Read-only variable, i.e., a constant.\ndeclare -r DecimalConstant=31373\n\nMessage1=\"Greetings,\"\nMessage2=\"Earthling.\"\n\necho\n\nprintf \"Pi to 2 decimal places = %1.2f\" $PI\necho\nprintf \"Pi to 9 decimal places = %1.9f\" $PI  # It even rounds off correctly.\n\nprintf \"\\n\"                                  # Prints a line feed,\n                                             # Equivalent to 'echo' . . .\n\nprintf \"Constant = \\t%d\\n\" $DecimalConstant  # Inserts tab (\\t).\n\nprintf \"%s %s \\n\" $Message1 $Message2\n\necho\n\n# ==========================================#\n# Simulation of C function, sprintf().\n# Loading a variable with a formatted string.\n\necho \n\nPi12=$(printf \"%1.12f\" $PI)\necho \"Pi to 12 decimal places = $Pi12\"      # Roundoff error!\n\nMsg=`printf \"%s %s \\n\" $Message1 $Message2`\necho $Msg; echo $Msg\n\n#  As it happens, the 'sprintf' function can now be accessed\n#+ as a loadable module to Bash,\n#+ but this is not portable.\n\nexit 0\n```", "```sh E_BADDIR=85\n\nvar=nonexistent_directory\n\nerror()\n{\n  printf \"$@\" >&2\n  # Formats positional params passed, and sends them to stderr.\n  echo\n  exit $E_BADDIR\n}\n\ncd $var &#124;&#124; error $\"Can't cd to %s.\" \"$var\"\n\n# Thanks, S.C.\n```", "```sh #!/bin/bash\n# \"Reading\" variables.\n\necho -n \"Enter the value of variable 'var1': \"\n# The -n option to echo suppresses newline.\n\nread var1\n# Note no '$' in front of var1, since it is being set.\n\necho \"var1 = $var1\"\n\necho\n\n# A single 'read' statement can set multiple variables.\necho -n \"Enter the values of variables 'var2' and 'var3' \"\necho =n \"(separated by a space or tab): \"\nread var2 var3\necho \"var2 = $var2      var3 = $var3\"\n#  If you input only one value,\n#+ the other variable(s) will remain unset (null).\n\nexit 0\n```", "```sh #!/bin/bash\n# read-novar.sh\n\necho\n\n# -------------------------- #\necho -n \"Enter a value: \"\nread var\necho \"\\\"var\\\" = \"$var\"\"\n# Everything as expected here.\n# -------------------------- #\n\necho\n\n# ------------------------------------------------------------------- #\necho -n \"Enter another value: \"\nread           #  No variable supplied for 'read', therefore...\n               #+ Input to 'read' assigned to default variable, $REPLY.\nvar=\"$REPLY\"\necho \"\\\"var\\\" = \"$var\"\"\n# This is equivalent to the first code block.\n# ------------------------------------------------------------------- #\n\necho\necho \"=========================\"\necho\n\n#  This example is similar to the \"reply.sh\" script.\n#  However, this one shows that $REPLY is available\n#+ even after a 'read' to a variable in the conventional way.\n\n# ================================================================= #\n\n#  In some instances, you might wish to discard the first value read.\n#  In such cases, simply ignore the $REPLY variable.\n\n{ # Code block.\nread            # Line 1, to be discarded.\nread line2      # Line 2, saved in variable.\n  } <$0\necho \"Line 2 of this script is:\"\necho \"$line2\"   #   # read-novar.sh\necho            #   #!/bin/bash  line discarded.\n\n# See also the soundcard-on.sh script.\n\nexit 0\n```", "```sh #!/bin/bash\n\necho\n\necho \"Enter a string terminated by a \\\\, then press <ENTER>.\"\necho \"Then, enter a second string (no \\\\ this time), and again press <ENTER>.\"\n\nread var1     # The \"\\\" suppresses the newline, when reading $var1.\n              #     first line \\\n              #     second line\n\necho \"var1 = $var1\"\n#     var1 = first line second line\n\n#  For each line terminated by a \"\\\"\n#+ you get a prompt on the next line to continue feeding characters into var1.\n\necho; echo\n\necho \"Enter another string terminated by a \\\\ , then press <ENTER>.\"\nread -r var2  # The -r option causes the \"\\\" to be read literally.\n              #     first line \\\n\necho \"var2 = $var2\"\n#     var2 = first line \\\n\n# Data entry terminates with the first <ENTER>.\n\necho \n\nexit 0\n```", "```sh # Read a keypress without hitting ENTER.\n\nread -s -n1 -p \"Hit a key \" keypress\necho; echo \"Keypress was \"\\\"$keypress\\\"\".\"\n\n# -s option means do not echo input.\n# -n N option means accept only N characters of input.\n# -p option means echo the following prompt before reading input.\n\n# Using these options is tricky, since they need to be in the correct order.\n```", "```sh #!/bin/bash\n# arrow-detect.sh: Detects the arrow keys, and a few more.\n# Thank you, Sandro Magi, for showing me how.\n\n# --------------------------------------------\n# Character codes generated by the keypresses.\narrowup='\\[A'\narrowdown='\\[B'\narrowrt='\\[C'\narrowleft='\\[D'\ninsert='\\[2'\ndelete='\\[3'\n# --------------------------------------------\n\nSUCCESS=0\nOTHER=65\n\necho -n \"Press a key...  \"\n# May need to also press ENTER if a key not listed above pressed.\nread -n3 key                      # Read 3 characters.\n\necho -n \"$key\" &#124; grep \"$arrowup\"  #Check if character code detected.\nif [ \"$?\" -eq $SUCCESS ]\nthen\n  echo \"Up-arrow key pressed.\"\n  exit $SUCCESS\nfi\n\necho -n \"$key\" &#124; grep \"$arrowdown\"\nif [ \"$?\" -eq $SUCCESS ]\nthen\n  echo \"Down-arrow key pressed.\"\n  exit $SUCCESS\nfi\n\necho -n \"$key\" &#124; grep \"$arrowrt\"\nif [ \"$?\" -eq $SUCCESS ]\nthen\n  echo \"Right-arrow key pressed.\"\n  exit $SUCCESS\nfi\n\necho -n \"$key\" &#124; grep \"$arrowleft\"\nif [ \"$?\" -eq $SUCCESS ]\nthen\n  echo \"Left-arrow key pressed.\"\n  exit $SUCCESS\nfi\n\necho -n \"$key\" &#124; grep \"$insert\"\nif [ \"$?\" -eq $SUCCESS ]\nthen\n  echo \"\\\"Insert\\\" key pressed.\"\n  exit $SUCCESS\nfi\n\necho -n \"$key\" &#124; grep \"$delete\"\nif [ \"$?\" -eq $SUCCESS ]\nthen\n  echo \"\\\"Delete\\\" key pressed.\"\n  exit $SUCCESS\nfi\n\necho \" Some other key pressed.\"\n\nexit $OTHER\n\n# ========================================= #\n\n#  Mark Alexander came up with a simplified\n#+ version of the above script (Thank you!).\n#  It eliminates the need for grep.\n\n#!/bin/bash\n\n  uparrow=$'\\x1b[A'\n  downarrow=$'\\x1b[B'\n  leftarrow=$'\\x1b[D'\n  rightarrow=$'\\x1b[C'\n\n  read -s -n3 -p \"Hit an arrow key: \" x\n\n  case \"$x\" in\n  $uparrow)\n     echo \"You pressed up-arrow\"\n     ;;\n  $downarrow)\n     echo \"You pressed down-arrow\"\n     ;;\n  $leftarrow)\n     echo \"You pressed left-arrow\"\n     ;;\n  $rightarrow)\n     echo \"You pressed right-arrow\"\n     ;;\n  esac\n\nexit $?\n\n# ========================================= #\n\n# Antonio Macchi has a simpler alternative.\n\n#!/bin/bash\n\nwhile true\ndo\n  read -sn1 a\n  test \"$a\" == `echo -en \"\\e\"` &#124;&#124; continue\n  read -sn1 a\n  test \"$a\" == \"[\" &#124;&#124; continue\n  read -sn1 a\n  case \"$a\" in\n    A)  echo \"up\";;\n    B)  echo \"down\";;\n    C)  echo \"right\";;\n    D)  echo \"left\";;\n  esac\ndone\n\n# ========================================= #\n\n#  Exercise:\n#  --------\n#  1) Add detection of the \"Home,\" \"End,\" \"PgUp,\" and \"PgDn\" keys.\n```", "```sh #!/bin/bash\n\nread var1 <data-file\necho \"var1 = $var1\"\n# var1 set to the entire first line of the input file \"data-file\"\n\nread var2 var3 <data-file\necho \"var2 = $var2   var3 = $var3\"\n# Note non-intuitive behavior of \"read\" here.\n# 1) Rewinds back to the beginning of input file.\n# 2) Each variable is now set to a corresponding string,\n#    separated by whitespace, rather than to an entire line of text.\n# 3) The final variable gets the remainder of the line.\n# 4) If there are more variables to be set than whitespace-terminated strings\n#    on the first line of the file, then the excess variables remain empty.\n\necho \"------------------------------------------------\"\n\n# How to resolve the above problem with a loop:\nwhile read line\ndo\n  echo \"$line\"\ndone <data-file\n# Thanks, Heiner Steven for pointing this out.\n\necho \"------------------------------------------------\"\n\n# Use $IFS (Internal Field Separator variable) to split a line of input to\n# \"read\", if you do not want the default to be whitespace.\n\necho \"List of all users:\"\nOIFS=$IFS; IFS=:       # /etc/passwd uses \":\" for field separator.\nwhile read name passwd uid gid fullname ignore\ndo\n  echo \"$name ($fullname)\"\ndone </etc/passwd   # I/O redirection.\nIFS=$OIFS              # Restore original $IFS.\n# This code snippet also by Heiner Steven.\n\n#  Setting the $IFS variable within the loop itself\n#+ eliminates the need for storing the original $IFS\n#+ in a temporary variable.\n#  Thanks, Dim Segebart, for pointing this out.\necho \"------------------------------------------------\"\necho \"List of all users:\"\n\nwhile IFS=: read name passwd uid gid fullname ignore\ndo\n  echo \"$name ($fullname)\"\ndone </etc/passwd   # I/O redirection.\n\necho\necho \"\\$IFS still $IFS\"\n\nexit 0\n```", "```sh cat file1 file2 &#124;\nwhile read line\ndo\necho $line\ndone\n```", "```sh #!/bin/sh\n# readpipe.sh\n# This example contributed by Bjon Eriksson.\n\n### shopt -s lastpipe\n\nlast=\"(null)\"\ncat $0 &#124;\nwhile read line\ndo\n    echo \"{$line}\"\n    last=$line\ndone\n\necho\necho \"++++++++++++++++++++++\"\nprintf \"\\nAll done, last: $last\\n\" #  The output of this line\n                                   #+ changes if you uncomment line 5.\n                                   #  (Bash, version -ge 4.2 required.)\n\nexit 0  # End of code.\n        # (Partial) output of script follows.\n        # The 'echo' supplies extra brackets.\n\n#############################################\n\n./readpipe.sh \n\n{#!/bin/sh}\n{last=\"(null)\"}\n{cat $0 &#124;}\n{while read line}\n{do}\n{echo \"{$line}\"}\n{last=$line}\n{done}\n{printf \"nAll done, last: $lastn\"}\n\nAll done, last: (null)\n\nThe variable (last) is set within the loop/subshell\nbut its value does not persist outside the loop.\n```", "```sh find $1 \\( -name \"*$2\" -o -name \".*$2\" \\) -print &#124;\nwhile read f; do\n. . .\n```", "```sh (cd /source/directory && tar cf - . ) &#124; (cd /dest/directory && tar xpvf -)\n```", "```sh bash$ **cd //**\nbash$ **pwd**\n//\n\n```", "```sh #!/bin/bash\n\ndir1=/usr/local\ndir2=/var/spool\n\npushd $dir1\n# Will do an automatic 'dirs' (list directory stack to stdout).\necho \"Now in directory `pwd`.\" # Uses back-quoted 'pwd'.\n\n# Now, do some stuff in directory 'dir1'.\npushd $dir2\necho \"Now in directory `pwd`.\"\n\n# Now, do some stuff in directory 'dir2'.\necho \"The top entry in the DIRSTACK array is $DIRSTACK.\"\npopd\necho \"Now back in directory `pwd`.\"\n\n# Now, do some more stuff in directory 'dir1'.\npopd\necho \"Now back in original working directory `pwd`.\"\n\nexit 0\n\n# What happens if you don't 'popd' -- then exit the script?\n# Which directory do you end up in? Why?\n```", "```sh #!/bin/bash\n\necho\n\nlet a=11            # Same as 'a=11'\nlet a=a+5           # Equivalent to  let \"a = a + 5\"\n                    # (Double quotes and spaces make it more readable.)\necho \"11 + 5 = $a\"  # 16\n\nlet \"a <<= 3\"       # Equivalent to  let \"a = a << 3\"\necho \"\\\"\\$a\\\" (=16) left-shifted 3 places = $a\"\n                    # 128\n\nlet \"a /= 4\"        # Equivalent to  let \"a = a / 4\"\necho \"128 / 4 = $a\" # 32\n\nlet \"a -= 5\"        # Equivalent to  let \"a = a - 5\"\necho \"32 - 5 = $a\"  # 27\n\nlet \"a *=  10\"      # Equivalent to  let \"a = a * 10\"\necho \"27 * 10 = $a\" # 270\n\nlet \"a %= 8\"        # Equivalent to  let \"a = a % 8\"\necho \"270 modulo 8 = $a  (270 / 8 = 33, remainder $a)\"\n                    # 6\n\n# Does \"let\" permit C-style operators?\n# Yes, just as the (( ... )) double-parentheses construct does.\n\nlet a++             # C-style (post) increment.\necho \"6++ = $a\"     # 6++ = 7\nlet a--             # C-style decrement.\necho \"7-- = $a\"     # 7-- = 6\n# Of course, ++a, etc., also allowed . . .\necho\n\n# Trinary operator.\n\n# Note that $a is 6, see above.\nlet \"t = a<7?7:11\"   # True\necho $t  # 7\n\nlet a++\nlet \"t = a<7?7:11\"   # False\necho $t  #     11\n\nexit\n```", "```sh # Evgeniy Ivanov points out:\n\nvar=0\necho $?     # 0\n            # As expected.\n\nlet var++\necho $?     # 1\n            # The command was successful, so why isn't $?=0 ???\n            # Anomaly!\n\nlet var++\necho $?     # 0\n            # As expected.\n\n# Likewise . . .\n\nlet var=0\necho $?     # 1\n            # The command was successful, so why isn't $?=0 ???\n\n#  However, as Jeff Gorak points out,\n#+ this is part of the design spec for 'let' . . .\n# \"If the last ARG evaluates to 0, let returns 1;\n#  let returns 0 otherwise.\" ['help let']\n```", "```sh bash$ **command_string=\"ps ax\"**\nbash$ **process=\"ps ax\"**\nbash$ **eval \"$command_string\" &#124; grep \"$process\"**\n26973 pts/3    R+     0:00 grep --color ps ax\n 26974 pts/3    R+     0:00 ps ax\n\n```", "```sh a='$b'\nb='$c'\nc=d\n\necho $a             # $b\n                    # First level.\neval echo $a        # $c\n                    # Second level.\neval eval echo $a   # d\n                    # Third level.\n\n# Thank you, E. Choroba.\n```", "```sh #!/bin/bash\n# Exercising \"eval\" ...\n\ny=`eval ls -l`  #  Similar to y=`ls -l`\necho $y         #+ but linefeeds removed because \"echoed\" variable is unquoted.\necho\necho \"$y\"       #  Linefeeds preserved when variable is quoted.\n\necho; echo\n\ny=`eval df`     #  Similar to y=`df`\necho $y         #+ but linefeeds removed.\n\n#  When LF's not preserved, it may make it easier to parse output,\n#+ using utilities such as \"awk\".\n\necho\necho \"===========================================================\"\necho\n\neval \"`seq 3 &#124; sed -e 's/.*/echo var&=ABCDEFGHIJ/'`\"\n# var1=ABCDEFGHIJ\n# var2=ABCDEFGHIJ\n# var3=ABCDEFGHIJ\n\necho\necho \"===========================================================\"\necho\n\n# Now, showing how to do something useful with \"eval\" . . .\n# (Thank you, E. Choroba!)\n\nversion=3.4     #  Can we split the version into major and minor\n                #+ part in one command?\necho \"version = $version\"\neval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='\n                                    #  The substitution yields '3; minor=4'\n                                    #+ so eval does minor=4, major=3\necho Major: $major, minor: $minor   #  Major: 3, minor: 4\n```", "```sh #!/bin/bash\n# arr-choice.sh\n\n#  Passing arguments to a function to select\n#+ one particular variable out of a group.\n\narr0=( 10 11 12 13 14 15 )\narr1=( 20 21 22 23 24 25 )\narr2=( 30 31 32 33 34 35 )\n#       0  1  2  3  4  5      Element number (zero-indexed)\n\nchoose_array ()\n{\n  eval array_member=\\${arr${array_number}[element_number]}\n  #                 ^       ^^^^^^^^^^^^\n  #  Using eval to construct the name of a variable,\n  #+ in this particular case, an array name.\n\n  echo \"Element $element_number of array $array_number is $array_member\"\n} #  Function can be rewritten to take parameters.\n\narray_number=0    # First array.\nelement_number=3\nchoose_array      # 13\n\narray_number=2    # Third array.\nelement_number=4\nchoose_array      # 34\n\narray_number=3    # Null array (arr3 not allocated).\nelement_number=4\nchoose_array      # (null)\n\n# Thank you, Antonio Macchi, for pointing this out.\n```", "```sh #!/bin/bash\n# echo-params.sh\n\n# Call this script with a few command-line parameters.\n# For example:\n#     sh echo-params.sh first second third fourth fifth\n\nparams=$#              # Number of command-line parameters.\nparam=1                # Start at first command-line param.\n\nwhile [ \"$param\" -le \"$params\" ]\ndo\n  echo -n \"Command-line parameter \"\n  echo -n \\$$param     #  Gives only the *name* of variable.\n#         ^^^          #  $1, $2, $3, etc.\n                       #  Why?\n                       #  \\$ escapes the first \"$\"\n                       #+ so it echoes literally,\n                       #+ and $param dereferences \"$param\" . . .\n                       #+ . . . as expected.\n  echo -n \" = \"\n  eval echo \\$$param   #  Gives the *value* of variable.\n# ^^^^      ^^^        #  The \"eval\" forces the *evaluation*\n                       #+ of \\$$\n                       #+ as an indirect variable reference.\n\n(( param ++ ))         # On to the next.\ndone\n\nexit $?\n\n# =================================================\n\n$ sh echo-params.sh first second third fourth fifth\nCommand-line parameter $1 = first\nCommand-line parameter $2 = second\nCommand-line parameter $3 = third\nCommand-line parameter $4 = fourth\nCommand-line parameter $5 = fifth\n```", "```sh #!/bin/bash\n# Killing ppp to force a log-off.\n# For dialup connection, of course.\n\n# Script should be run as root user.\n\nSERPORT=ttyS3\n#  Depending on the hardware and even the kernel version,\n#+ the modem port on your machine may be different --\n#+ /dev/ttyS1 or /dev/ttyS2.\n\nkillppp=\"eval kill -9 `ps ax &#124; awk '/ppp/ { print $1 }'`\"\n#                     -------- process ID of ppp -------  \n\n$killppp                     # This variable is now a command.\n\n# The following operations must be done as root user.\n\nchmod 666 /dev/$SERPORT      # Restore r+w permissions, or else what?\n#  Since doing a SIGKILL on ppp changed the permissions on the serial port,\n#+ we restore permissions to previous state.\n\nrm /var/lock/LCK..$SERPORT   # Remove the serial port lock file. Why?\n\nexit $?\n\n# Exercises:\n# ---------\n# 1) Have script check whether root user is invoking it.\n# 2) Do a check on whether the process to be killed\n#+   is actually running before attempting to kill it.   \n# 3) Write an alternate version of this script based on 'fuser':\n#+      if [ fuser -s /dev/modem ]; then . . .\n```", "```sh #!/bin/bash\n# A version of \"rot13\" using 'eval'.\n# Compare to \"rot13.sh\" example.\n\nsetvar_rot_13()              # \"rot13\" scrambling\n{\n  local varname=$1 varvalue=$2\n  eval $varname='$(echo \"$varvalue\" &#124; tr a-z n-za-m)'\n}\n\nsetvar_rot_13 var \"foobar\"   # Run \"foobar\" through rot13.\necho $var                    # sbbone\n\nsetvar_rot_13 var \"$var\"     # Run \"sbbone\" through rot13.\n                             # Back to original variable.\necho $var                    # foobar\n\n# This example by Stephane Chazelas.\n# Modified by document author.\n\nexit 0\n```", "```sh eval ${1}+=\\\"${x} ${y} \\\"\n```", "```sh eval var=\\$$var\n```", "```sh #!/bin/bash\n# ex34.sh\n# Script \"set-test\"\n\n# Invoke this script with three command-line parameters,\n# for example, \"sh ex34.sh one two three\".\n\necho\necho \"Positional parameters before  set \\`uname -a\\` :\"\necho \"Command-line argument #1 = $1\"\necho \"Command-line argument #2 = $2\"\necho \"Command-line argument #3 = $3\"\n\nset `uname -a` # Sets the positional parameters to the output\n               # of the command `uname -a`\n\necho\necho +++++\necho $_        # +++++\n# Flags set in script.\necho $-        # hB\n#                Anomalous behavior?\necho\n\necho \"Positional parameters after  set \\`uname -a\\` :\"\n# $1, $2, $3, etc. reinitialized to result of `uname -a`\necho \"Field #1 of 'uname -a' = $1\"\necho \"Field #2 of 'uname -a' = $2\"\necho \"Field #3 of 'uname -a' = $3\"\necho \\#\\#\\#\necho $_        # ###\necho\n\nexit 0\n```", "```sh #!/bin/bash\n# revposparams.sh: Reverse positional parameters.\n# Script by Dan Jacobson, with stylistic revisions by document author.\n\nset a\\ b c d\\ e;\n#     ^      ^     Spaces escaped \n#       ^ ^        Spaces not escaped\nOIFS=$IFS; IFS=:;\n#              ^   Saving old IFS and setting new one.\n\necho\n\nuntil [ $# -eq 0 ]\ndo          #      Step through positional parameters.\n  echo \"### k0 = \"$k\"\"     # Before\n  k=$1:$k;  #      Append each pos param to loop variable.\n#     ^\n  echo \"### k = \"$k\"\"      # After\n  echo\n  shift;\ndone\n\nset $k  #  Set new positional parameters.\necho -\necho $# #  Count of positional parameters.\necho -\necho\n\nfor i   #  Omitting the \"in list\" sets the variable -- i --\n        #+ to the positional parameters.\ndo\n  echo $i  # Display new positional parameters.\ndone\n\nIFS=$OIFS  # Restore IFS.\n\n#  Question:\n#  Is it necessary to set an new IFS, internal field separator,\n#+ in order for this script to work properly?\n#  What happens if you don't? Try it.\n#  And, why use the new IFS -- a colon -- in line 17,\n#+ to append to the loop variable?\n#  What is the purpose of this?\n\nexit 0\n\n$ ./revposparams.sh\n\n### k0 = \n### k = a b\n\n### k0 = a b\n### k = c a b\n\n### k0 = c a b\n### k = d e c a b\n\n-\n3\n-\n\nd e\nc\na b\n```", "```sh bash$ **set**\nAUTHORCOPY=/home/bozo/posts\n BASH=/bin/bash\n BASH_VERSION=$'2.05.8(1)-release'\n ...\n XAUTHORITY=/home/bozo/.Xauthority\n _=/etc/bashrc\n variable22=abc\n variable23=xzy\n\n```", "```sh #!/bin/bash\n\nvariable=\"one two three four five\"\n\nset -- $variable\n# Sets positional parameters to the contents of \"$variable\".\n\nfirst_param=$1\nsecond_param=$2\nshift; shift        # Shift past first two positional params.\n# shift 2             also works.\nremaining_params=\"$*\"\n\necho\necho \"first parameter = $first_param\"             # one\necho \"second parameter = $second_param\"           # two\necho \"remaining parameters = $remaining_params\"   # three four five\n\necho; echo\n\n# Again.\nset -- $variable\nfirst_param=$1\nsecond_param=$2\necho \"first parameter = $first_param\"             # one\necho \"second parameter = $second_param\"           # two\n\n# ======================================================\n\nset --\n# Unsets positional parameters if no variable specified.\n\nfirst_param=$1\nsecond_param=$2\necho \"first parameter = $first_param\"             # (null value)\necho \"second parameter = $second_param\"           # (null value)\n\nexit 0\n```", "```sh bash$ **unset PATH**\n\nbash$ **echo $PATH**\n\nbash$ \n```", "```sh #!/bin/bash\n# unset.sh: Unsetting a variable.\n\nvariable=hello                       #  Initialized.\necho \"variable = $variable\"\n\nunset variable                       #  Unset.\n                                     #  In this particular context,\n                                     #+ same effect as:   variable=\necho \"(unset) variable = $variable\"  #  $variable is null.\n\nif [ -z \"$variable\" ]                #  Try a string-length test.\nthen\n  echo \"\\$variable has zero length.\"\nfi\n\nexit 0\n```", "```sh #!/bin/bash\n\n#  Yet another version of the \"column totaler\" script (col-totaler.sh)\n#+ that adds up a specified column (of numbers) in the target file.\n#  This uses the environment to pass a script variable to 'awk' . . .\n#+ and places the awk script in a variable.\n\nARGS=2\nE_WRONGARGS=85\n\nif [ $# -ne \"$ARGS\" ] # Check for proper number of command-line args.\nthen\n   echo \"Usage: `basename $0` filename column-number\"\n   exit $E_WRONGARGS\nfi\n\nfilename=$1\ncolumn_number=$2\n\n#===== Same as original script, up to this point =====#\n\nexport column_number\n# Export column number to environment, so it's available for retrieval.\n\n# -----------------------------------------------\nawkscript='{ total += $ENVIRON[\"column_number\"] }\nEND { print total }'\n# Yes, a variable can hold an awk script.\n# -----------------------------------------------\n\n# Now, run the awk script.\nawk \"$awkscript\" \"$filename\"\n\n# Thanks, Stephane Chazelas.\n\nexit 0\n```", "```sh bash$ **export var=(a b); echo ${var[0]}**\n(a b)\n\nbash$ **var=(a b); export var; echo ${var[0]}**\na\n\n```", "```sh while getopts \":abcde:fg\" Option\n# Initial declaration.\n# a, b, c, d, e, f, and g are the options (flags) expected.\n# The : after option 'e' shows it will have an argument passed with it.\ndo\n  case $Option in\n    a ) # Do something with variable 'a'.\n    b ) # Do something with variable 'b'.\n    ...\n    e)  # Do something with 'e', and also with $OPTARG,\n        # which is the associated argument passed with option 'e'.\n    ...\n    g ) # Do something with variable 'g'.\n  esac\ndone\nshift $(($OPTIND - 1))\n# Move argument pointer to next.\n\n# All this is not nearly as complicated as it looks <grin>.\n```", "```sh #!/bin/bash\n# ex33.sh: Exercising getopts and OPTIND\n#          Script modified 10/09/03 at the suggestion of Bill Gradwohl.\n\n# Here we observe how 'getopts' processes command-line arguments to script.\n# The arguments are parsed as \"options\" (flags) and associated arguments.\n\n# Try invoking this script with:\n#   'scriptname -mn'\n#   'scriptname -oq qOption' (qOption can be some arbitrary string.)\n#   'scriptname -qXXX -r'\n#\n#   'scriptname -qr'\n#+      - Unexpected result, takes \"r\" as the argument to option \"q\"\n#   'scriptname -q -r' \n#+      - Unexpected result, same as above\n#   'scriptname -mnop -mnop'  - Unexpected result\n#   (OPTIND is unreliable at stating where an option came from.)\n#\n#  If an option expects an argument (\"flag:\"), then it will grab\n#+ whatever is next on the command-line.\n\nNO_ARGS=0 \nE_OPTERROR=85\n\nif [ $# -eq \"$NO_ARGS\" ]    # Script invoked with no command-line args?\nthen\n  echo \"Usage: `basename $0` options (-mnopqrs)\"\n  exit $E_OPTERROR          # Exit and explain usage.\n                            # Usage: scriptname -options\n                            # Note: dash (-) necessary\nfi  \n\nwhile getopts \":mnopq:rs\" Option\ndo\n  case $Option in\n    m     ) echo \"Scenario #1: option -m-   [OPTIND=${OPTIND}]\";;\n    n &#124; o ) echo \"Scenario #2: option -$Option-   [OPTIND=${OPTIND}]\";;\n    p     ) echo \"Scenario #3: option -p-   [OPTIND=${OPTIND}]\";;\n    q     ) echo \"Scenario #4: option -q-\\\n                  with argument \\\"$OPTARG\\\"   [OPTIND=${OPTIND}]\";;\n    #  Note that option 'q' must have an associated argument,\n    #+ otherwise it falls through to the default.\n    r &#124; s ) echo \"Scenario #5: option -$Option-\";;\n    *     ) echo \"Unimplemented option chosen.\";;   # Default.\n  esac\ndone\n\nshift $(($OPTIND - 1))\n#  Decrements the argument pointer so it points to next argument.\n#  $1 now references the first non-option item supplied on the command-line\n#+ if one exists.\n\nexit $?\n\n#   As Bill Gradwohl states,\n#  \"The getopts mechanism allows one to specify:  scriptname -mnop -mnop\n#+  but there is no reliable way to differentiate what came\n#+ from where by using OPTIND.\"\n#  There are, however, workarounds.\n```", "```sh #!/bin/bash\n#  Note that this example must be invoked with bash, i.e., bash ex38.sh\n#+ not  sh ex38.sh !\n\n. data-file    # Load a data file.\n# Same effect as \"source data-file\", but more portable.\n\n#  The file \"data-file\" must be present in current working directory,\n#+ since it is referred to by its basename.\n\n# Now, let's reference some data from that file.\n\necho \"variable1 (from data-file) = $variable1\"\necho \"variable3 (from data-file) = $variable3\"\n\nlet \"sum = $variable2 + $variable4\"\necho \"Sum of variable2 + variable4 (from data-file) = $sum\"\necho \"message1 (from data-file) is \\\"$message1\\\"\"\n#                                  Escaped quotes\necho \"message2 (from data-file) is \\\"$message2\\\"\"\n\nprint_message This is the message-print function in the data-file.\n\nexit $?\n```", "```sh # This is a data file loaded by a script.\n# Files of this type may contain variables, functions, etc.\n# It loads with a 'source' or '.' command from a shell script.\n\n# Let's initialize some variables.\n\nvariable1=23\nvariable2=474\nvariable3=5\nvariable4=97\n\nmessage1=\"Greetings from *** line $LINENO *** of the data file!\"\nmessage2=\"Enough for now. Goodbye.\"\n\nprint_message ()\n{   # Echoes any message passed to it.\n\n  if [ -z \"$1\" ]\n  then\n    return 1 # Error, if argument missing.\n  fi\n\n  echo\n\n  until [ -z \"$1\" ]\n  do             # Step through arguments passed to function.\n    echo -n \"$1\" # Echo args one at a time, suppressing line feeds.\n    echo -n \" \"  # Insert spaces between words.\n    shift        # Next one.\n  done  \n\n  echo\n\n  return 0\n}\n```", "```sh source $filename $arg1 arg2\n```", "```sh #!/bin/bash\n# self-source.sh: a script sourcing itself \"recursively.\"\n# From \"Stupid Script Tricks,\" Volume II.\n\nMAXPASSCNT=100    # Maximum number of execution passes.\n\necho -n  \"$pass_count  \"\n#  At first execution pass, this just echoes two blank spaces,\n#+ since $pass_count still uninitialized.\n\nlet \"pass_count += 1\"\n#  Assumes the uninitialized variable $pass_count\n#+ can be incremented the first time around.\n#  This works with Bash and pdksh, but\n#+ it relies on non-portable (and possibly dangerous) behavior.\n#  Better would be to initialize $pass_count to 0 before incrementing.\n\nwhile [ \"$pass_count\" -le $MAXPASSCNT ]\ndo\n  . $0   # Script \"sources\" itself, rather than calling itself.\n         # ./$0 (which would be true recursion) doesn't work here. Why?\ndone  \n\n#  What occurs here is not actually recursion,\n#+ since the script effectively \"expands\" itself, i.e.,\n#+ generates a new section of code\n#+ with each pass through the 'while' loop',\n#  with each 'source' in line 20.\n#\n#  Of course, the script interprets each newly 'sourced' \"#!\" line\n#+ as a comment, and not as the start of a new script.\n\necho\n\nexit 0   # The net effect is counting from 1 to 100.\n         # Very impressive.\n\n# Exercise:\n# --------\n# Write a script that uses this trick to actually do something useful.\n```", "```sh #!/bin/bash\n\nexec echo \"Exiting \\\"$0\\\" at line $LINENO.\"   # Exit from script here.\n# $LINENO is an internal Bash variable set to the line number it's on.\n\n# ----------------------------------\n# The following lines never execute.\n\necho \"This echo fails to echo.\"\n\nexit 99                       #  This script will not exit here.\n                              #  Check exit value after script terminates\n                              #+ with an 'echo $?'.\n                              #  It will *not* be 99.\n```", "```sh #!/bin/bash\n# self-exec.sh\n\n# Note: Set permissions on this script to 555 or 755,\n#       then call it with ./self-exec.sh or sh ./self-exec.sh.\n\necho\n\necho \"This line appears ONCE in the script, yet it keeps echoing.\"\necho \"The PID of this instance of the script is still $$.\"\n#     Demonstrates that a subshell is not forked off.\n\necho \"==================== Hit Ctl-C to exit ====================\"\n\nsleep 1\n\nexec $0   #  Spawns another instance of this same script\n          #+ that replaces the previous one.\n\necho \"This line will never echo!\"  # Why not?\n\nexit 99                            # Will not exit here!\n                                   # Exit code will not be 99!\n```", "```sh shopt -s cdspell\n# Allows minor misspelling of directory names with 'cd'\n# Option -s sets, -u unsets.\n\ncd /hpme  # Oops! Mistyped '/home'.\npwd       # /home\n          # The shell corrected the misspelling.\n```", "```sh #!/bin/bash\n\nfunction1 ()\n{\n  # Inside function1 ().\n  caller 0   # Tell me about it.\n}\n\nfunction1    # Line 9 of script.\n\n# 9 main test.sh\n# ^                 Line number that the function was called from.\n#   ^^^^            Invoked from \"main\" part of script.\n#        ^^^^^^^    Name of calling script.\n\ncaller 0     # Has no effect because it's not inside a function.\n```", "```sh bash$ **true**\nbash$ **echo $?**\n0\n\n```", "```sh # Endless loop\nwhile true   # alias for \":\"\ndo\n   operation-1\n   operation-2\n   ...\n   operation-n\n   # Need a way to break out of loop or script will hang.\ndone\n```", "```sh bash$ **false**\nbash$ **echo $?**\n1\n\n```", "```sh # Testing \"false\" \nif false\nthen\n  echo \"false evaluates \\\"true\\\"\"\nelse\n  echo \"false evaluates \\\"false\\\"\"\nfi\n# false evaluates \"false\"\n\n# Looping while \"false\" (null loop)\nwhile false\ndo\n   # The following code will not execute.\n   operation-1\n   operation-2\n   ...\n   operation-n\n   # Nothing happens!\ndone   \n```", "```sh bash$ **type '['**\n[ is a shell builtin\nbash$ **type -a '['**\n[ is a shell builtin\n [ is /usr/bin/[\n\nbash$ **type type**\ntype is a shell builtin\n\n```", "```sh bash$ **help exit**\nexit: exit [n]\n    Exit the shell with a status of N.  If N is omitted, the exit status\n    is that of the last command executed.\n\n```"]