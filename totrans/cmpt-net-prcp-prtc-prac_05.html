<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>A reliable transport protocol#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>A reliable transport protocol#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/hosts/reliability.html">https://4ed.computer-networking.info/syllabus/default/hosts/reliability.html</a></blockquote>

<section id="a-simple-reliable-protocol">
<h2>A simple reliable protocol<a class="headerlink" href="#a-simple-reliable-protocol" title="Link to this heading">#</a></h2>
<p>In this section, we develop a simple reliable protocol running above the network service. To design this protocol, we first assume that the underlying layer provides a perfect service. We will then develop solutions to recover from different types of errors that affect the network service.</p>
<p>The network layer is designed to send and receive packets on behalf of a user. We model these interactions by using the <cite>DATA.req</cite> and <cite>DATA.ind</cite> primitives. However, to simplify the presentation and to avoid confusion between a <cite>DATA.req</cite> primitive issued by the user of the network layer, and a <cite>DATA.req</cite> issued by the transport layer entity itself, we use the following terminology :</p>
<blockquote>
<div><ul class="simple">
<li><p>the interactions between the user and the transport layer entity are represented by using the classical <cite>DATA.req</cite> and the <cite>DATA.ind</cite> primitives</p></li>
<li><p>the interactions between the transport layer entity and the sub-layer are represented by using <cite>send</cite> instead of <cite>DATA.req</cite> and <cite>recvd</cite> instead of <cite>DATA.ind</cite></p></li>
</ul>
</div></blockquote>
<p>When running on top of a perfect network, a transport entity can simply issue a <cite>send(SDU)</cite> upon arrival of a <cite>DATA.req(SDU)</cite> <a class="footnote-reference brackets" href="#fsdu" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Similarly, the receiver issues a <cite>DATA.ind(SDU)</cite> upon receipt of a <cite>recvd(SDU)</cite>. Such a simple protocol is sufficient when a single SDU is sent. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/ba824d054705364b69646b80420c85eb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(SDU)&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Segment(SDU)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(SDU)&quot; ];&#10;}" usemap="#e44596b6402c634781fc156189b78b14744a061d" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-e44596b6402c634781fc156189b78b14744a061d.png"/>
<map id="e44596b6402c634781fc156189b78b14744a061d" name="e44596b6402c634781fc156189b78b14744a061d"/></p>
</div></blockquote>
<p>Unfortunately, this is not always sufficient to ensure a reliable delivery of SDUs. Consider the case where a client sends tens of SDUs to a server. If the server is faster than the client, it will be able to receive and process all the segments sent by the client and deliver their content to its user. However, if the server is slower than the client, problems may arise. The transport entity contains buffers to store SDUs that have been received as a <cite>Data.request</cite> but have not yet been sent. If the application is faster than the network, the buffer may become full. At this point, the operating system suspends the application to let the transport entity empty its transmission queue. The transport entity also uses a buffer to store the received segments that have not yet been processed by the application. If the application is slow to process the data, this buffer may overflow and the transport entity will not able to accept any additional segment. The buffers of the transport entity have a limited size and if they overflow, the arriving segments will be discarded, even if they are correct.</p>
<p>To solve this problem, a reliable protocol must include a feedback mechanism that allows the receiver to inform the sender that it has processed a segment and that another one can be sent. This feedback is required even though there are no transmission errors. To include such a feedback, our reliable protocol must process two types of segments :</p>
<blockquote>
<div><ul class="simple">
<li><p>data segments carrying a SDU</p></li>
<li><p>control segments confirming that the previous segment was correctly processed</p></li>
</ul>
</div></blockquote>
<p>These control segments are usually called <cite>acknowledgments</cite> because they acknowledge the correct reception of data.</p>
<p>These two types of segments can be distinguished by dividing the segments in two parts :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>header</cite> that contains a <cite>segment type</cite> bit set to <cite>0</cite> in data segments and set to <cite>1</cite> in control segments</p></li>
<li><p>the payload that contains the SDU supplied by the application</p></li>
</ul>
</div></blockquote>
<p>Our transport entity can then be modeled as a finite state machine, containing two states for the receiver and two states for the sender. <a class="reference internal" href="#fig-fsm1-transport"><span class="std std-numref">Fig. 47</span></a> provides a graphical representation of this state machine with the sender above and the receiver below.</p>
<blockquote>
<div><div class="figure" id="id13" style="text-align: center">
<span id="fig-fsm1-transport"/><p><img src="../Images/ca317c24a120ea2f84f77bb8205d331e.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e5bcad7738bbd36ecec2c9c6869d4e4fa85fbc91.png"/></p>
<p><span class="caption-number">Fig. 47 </span><span class="caption-text">Finite state machines of the simplest reliable protocol (sender above, receiver below)</span></p>
</div></div></blockquote>
<p>The sender FSM shows that the sender has to wait for an acknowledgment from the receiver before being able to transmit the next SDU.  The figure below illustrates the exchange of a few segments between two hosts.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/15482ac863d12db91aebf9dbd402b97a.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)&quot;], b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ],c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)&quot; ], b&gt;&gt;c [ label = &quot;D(b)&quot;,arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ], c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#60a9f1c91540fca4ffa054e6b58cb88cf03463af" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-60a9f1c91540fca4ffa054e6b58cb88cf03463af.png"/>
<map id="60a9f1c91540fca4ffa054e6b58cb88cf03463af" name="60a9f1c91540fca4ffa054e6b58cb88cf03463af"/></p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Services and protocols</p>
<p>An important aspect to understand when studying computer networks is the difference between a <em>service</em> and a <em>protocol</em>. For this, it is useful to start with real world examples. The traditional Post provides a service where a postman delivers letters to recipients. The Post precisely defines which types of letters (size, weight, etc) can be delivered by using the Standard Mail service. Furthermore, the format of the envelope is specified (position of the sender and recipient addresses, position of the stamp). Someone who wants to send a letter must either place the letter at a Post Office or inside one of the dedicated mailboxes. The letter will then be collected and delivered to its final recipient. Note that for the regular service the Post usually does not guarantee the delivery of each particular letter. Some letters may be lost, and some letters are delivered to the wrong mailbox. If a letter is important, then the sender can use the registered service to ensure that the letter will be delivered to its recipient. Some Post services also provide an acknowledged service or an express mail service that is faster than the regular service.</p>
</div>
<section id="reliable-transfer-above-an-imperfect-link">
<h3>Reliable transfer above an imperfect link<a class="headerlink" href="#reliable-transfer-above-an-imperfect-link" title="Link to this heading">#</a></h3>
<p>The transport layer must deal with several types of errors which can affect the segments that it sends. In practice, we mainly have to deal with two types of errors in the transport layer :</p>
<blockquote>
<div><ul class="simple">
<li><p>Segments can be corrupted by transmission errors</p></li>
<li><p>Segments can be lost or unexpected segments can appear</p></li>
</ul>
</div></blockquote>
<p>To detect errors, a segment is usually divided into two parts :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>header</cite> that contains the fields used by the reliable protocol to ensure reliable delivery. The header contains a checksum or Cyclical Redundancy Check (CRC) <a class="reference internal" href="../bibliography.html#williams1993" id="id2"><span>[Williams1993]</span></a> that is used to detect transmission errors</p></li>
<li><p>a <cite>payload</cite> that contains the user data</p></li>
</ul>
</div></blockquote>
<p>Some headers also include a <cite>length</cite> field, which indicates the total length of the segment or the length of the payload.</p>
<p>The simplest error detection scheme is the checksum. A checksum is basically an arithmetic sum of all the bytes that a segment is composed of. There are different types of checksums. For example, an eight bit checksum can be computed as the arithmetic sum of all the bytes of (both the header and trailer of) the segment. The checksum is computed by the sender before sending the segment and the receiver verifies the checksum upon segment reception. The receiver discards segments received with an invalid checksum. Checksums can be easily implemented in software, but their error detection capabilities are limited. Cyclical Redundancy Checks (CRC) have better error detection capabilities <a class="reference internal" href="../bibliography.html#sgp98" id="id3"><span>[SGP98]</span></a>, but require more CPU when implemented in software.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Checksums, CRCs,…</p>
<p>Most of the protocols in the TCP/IP protocol suite rely on the simple Internet checksum in order to verify that a received packet has not been affected by transmission errors. Despite its popularity and ease of implementation, the Internet checksum is not the only available checksum mechanism. Cyclical Redundancy Checks (<a class="reference external" href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>) are very powerful error detection schemes that are used notably on disks, by many datalink layer protocols and file formats such as <code class="docutils literal notranslate"><span class="pre">zip</span></code> or <code class="docutils literal notranslate"><span class="pre">png</span></code>. They can easily be implemented efficiently in hardware and have better error-detection capabilities than the Internet checksum <a class="reference internal" href="../bibliography.html#sgp98" id="id4"><span>[SGP98]</span></a> . However, CRCs are sometimes considered to be too CPU-intensive for software implementations and other checksum mechanisms are preferred. The TCP/IP community chose the Internet checksum, the OSI community chose the Fletcher checksum <a class="reference internal" href="../bibliography.html#sklower89" id="id5"><span>[Sklower89]</span></a>. Nowadays there are efficient techniques to quickly compute CRCs in software <a class="reference internal" href="../bibliography.html#feldmeier95" id="id6"><span>[Feldmeier95]</span></a>.</p>
</div>
<p>Since the receiver sends an acknowledgment after having received each data segment, the simplest solution to deal with losses is to use a retransmission timer. When the sender sends a segment, it starts a retransmission timer. The duration of this retransmission timer should be larger than the <cite>round-trip-time</cite>, i.e. the delay between the transmission of a data segment and the reception of the corresponding acknowledgment. When the retransmission timer expires, the sender assumes that the data segment has been lost and retransmits it. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/eb3e128faed868520ea345c4171d9007.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b-x c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;, linecolour=red];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#8057bc41346c284d032cdac99ea8cefe6d4cb0d6" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-8057bc41346c284d032cdac99ea8cefe6d4cb0d6.png"/>
<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6" name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"/></p>
</div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p>Unfortunately, retransmission timers alone are not sufficient to recover from losses. Let us consider, as an example, the situation depicted below where an acknowledgment is lost. In this case, the sender retransmits the data segment that has not been acknowledged. However, as illustrated in the figure below, the receiver considers the retransmission as a new segment whose payload must be delivered to its user.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f31aca9d4a56211a006ee59b4bbd6581.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c-x b [label= &quot;C(OK)&quot;, linecolour=red, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b) !!!!!&quot;, linecolour=red ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#34c7c055da8716230ba3f29574fb761575e3d9f5" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-34c7c055da8716230ba3f29574fb761575e3d9f5.png"/>
<map id="34c7c055da8716230ba3f29574fb761575e3d9f5" name="34c7c055da8716230ba3f29574fb761575e3d9f5"/></p>
</div></blockquote>
<p id="index-0">To solve this problem, reliable protocols associate a <cite>sequence number</cite> to each data segment. This <cite>sequence number</cite> is one of the fields found in the header of data segments. We use the notation <cite>D(x,…)</cite> to indicate a data segment whose sequence number field is set to value <cite>x</cite>. The acknowledgments also contain a sequence number indicating the data segments that it acknowledges. We use <cite>OKx</cite> to indicate an acknowledgment that confirms the reception of <cite>D(x,…)</cite>. The sequence number is encoded as a bit string of fixed length. The simplest reliable protocol is the Alternating Bit Protocol (ABP).</p>
</section>
<section id="the-alternating-bit-protocol">
<h3>The Alternating Bit Protocol<a class="headerlink" href="#the-alternating-bit-protocol" title="Link to this heading">#</a></h3>
<p id="index-1">The Alternating Bit Protocol uses a single bit to encode the sequence number. It can be implemented easily. The sender (resp. the receiver) only require a four-state (resp. three-state) Finite State Machine. The sender FSM is represented in <a class="reference internal" href="#fig-abp-sender-fsm"><span class="std std-numref">Fig. 48</span></a> and the receiver FSM in <a class="reference internal" href="#fig-abp-receiver-fsm"><span class="std std-numref">Fig. 49</span></a>.</p>
<blockquote>
<div><div class="figure" id="id14" style="text-align: center">
<span id="fig-abp-sender-fsm"/><p><img src="../Images/8fbe25275e0fee019961c542919ef49b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f9f966f98d52abe87618f3d261ac6aa2b4d8eb8a.png"/></p>
<p><span class="caption-number">Fig. 48 </span><span class="caption-text">Alternating bit protocol: Sender FSM</span></p>
</div></div></blockquote>
<p>The initial state of the sender is <cite>Wait for D(0,…)</cite>. In this state, the sender waits for a <cite>Data.request</cite>. The first data segment that it sends uses sequence number <cite>0</cite>. After having sent this segment, the sender waits for an <cite>OK0</cite> acknowledgment. A data segment is retransmitted upon expiration of the retransmission timer or if an acknowledgment with an incorrect sequence number has been received.</p>
<p>The receiver first waits for <cite>D(0,…)</cite>. If the segment contains a correct <cite>CRC</cite>, it passes the SDU to its user and sends <cite>OK0</cite>. If the segment contains an invalid CRC, it is immediately discarded. Then, the receiver waits for <cite>D(1,…)</cite>. In this state, it may receive a duplicate <cite>D(0,…)</cite> or a data segment with an invalid CRC. In both cases, it returns an <cite>OK0</cite> segment to allow the sender to recover from the possible loss of the previous <cite>OK0</cite> segment.</p>
<blockquote>
<div><div class="figure" id="id15" style="text-align: center">
<span id="fig-abp-receiver-fsm"/><p><img src="../Images/3badb5e30f18cd10794dafd6f023ac28.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-21edc21ac4b15b1453fccde6b2baa11282421518.png"/></p>
<p><span class="caption-number">Fig. 49 </span><span class="caption-text">Alternating bit protocol: Receiver FSM</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Corrupted segments must be discarded</p>
<p>The receiver FSM of the Alternating bit protocol discards all segments that contain an invalid CRC. This is the safest approach since the received segment can be completely different from the one sent by the remote host. A receiver should not attempt at extracting information from a corrupted segment because it cannot know which portion of the segment has been affected by the error.</p>
</div>
<p>The figure below illustrates the operation of the Alternating Bit Protocol.</p>
<p class="mscgen">
<img src="../Images/58f29e8a1f0f64da47ef83b069805c78.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ];&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(c)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,c)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(c)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#2c052a1ec8a41f0cf029c367729c8d20af36fdcb" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-2c052a1ec8a41f0cf029c367729c8d20af36fdcb.png"/>
<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb" name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"/></p>
<p>The Alternating Bit Protocol can recover from the losses of data or control segments. This is illustrated in the two figures below. The first figure shows the loss of one data segment.</p>
<p class="mscgen">
<img src="../Images/f662cc9a0b114455fe7ce91316c8aedb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b-x c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;, linecolour=red];&#10;|||;&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#bac0f438a0b77b3de1b32b1118113f68e2fccc68" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-bac0f438a0b77b3de1b32b1118113f68e2fccc68.png"/>
<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68" name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"/></p>
<p>The second figure illustrates how the hosts handle the loss of one control segment.</p>
<p class="mscgen">
<img src="../Images/3bcb6de20e7b816c3750de577d1012cc.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c-x b [label= &quot;C(OK1)&quot;, linecolour=red, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;Duplicate segment\nignored&quot;, textcolour=red, linecolour=white ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#b3f33d8c62d1ddf01981ca22f5934f5160bb7b73" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b3f33d8c62d1ddf01981ca22f5934f5160bb7b73.png"/>
<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73" name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"/></p>
<p>The Alternating Bit Protocol can recover from transmission errors and segment losses. However, it has one important drawback. Consider two hosts that are directly connected by a 50 Kbits/sec satellite link that has a 250 milliseconds propagation delay. If these hosts send 1000 bits segments, then the maximum throughput that can be achieved by the alternating bit protocol is one segment every <span class="math notranslate nohighlight">\(20+250+250=520\)</span> milliseconds if we ignore the transmission time of the acknowledgment. This is less than 2 Kbits/sec !</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        </section>
<section id="go-back-n-and-selective-repeat">
<h3>Go-back-n and selective repeat<a class="headerlink" href="#go-back-n-and-selective-repeat" title="Link to this heading">#</a></h3>
<p>To overcome the performance limitations of the alternating bit protocol, reliable protocols rely on <cite>pipelining</cite> shown in <a class="reference internal" href="#fig-pipelining"><span class="std std-numref">Fig. 50</span></a>. This technique allows a sender to transmit several consecutive segments without being forced to wait for an acknowledgment after each segment. Each data segment contains a sequence number encoded as an <cite>n</cite> bits field.</p>
<figure class="align-center" id="fig-pipelining">
<a class="reference internal image-reference" href="../_images/pipelining2.png"><img alt="../_images/pipelining2.png" src="../Images/673705ddb7a242862f06d67fd8c2c097.png" style="width: 497.7px; height: 210.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/pipelining2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text">Pipelining improves the performance of reliable protocols</span><a class="headerlink" href="#fig-pipelining" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p><cite>Pipelining</cite> allows the sender to transmit segments at a higher rate. However this higher transmission rate may overload the receiver. In this case, the segments sent by the sender will not be correctly received by their final destination. The reliable protocols that rely on pipelining allow the sender to transmit <cite>W</cite> unacknowledged segments before being forced to wait for an acknowledgment from the receiving entity.</p>
<p>This is implemented by using a <cite>sliding window</cite>. The sliding window is the set of consecutive sequence numbers that the sender can use when transmitting segments without being forced to wait for an acknowledgment. <a class="reference internal" href="#fig-sliding-win"><span class="std std-numref">Fig. 51</span></a> shows a sliding window containing five segments (<cite>6,7,8,9</cite> and <cite>10</cite>). Two of these sequence numbers (<cite>6</cite> and <cite>7</cite>) have been used to send segments and only three sequence numbers (<cite>8</cite>, <cite>9</cite> and <cite>10</cite>) remain in the sliding window. The sliding window is said to be closed once all sequence numbers contained in the sliding window have been used.</p>
<figure class="align-center" id="id16">
<span id="fig-sliding-win"/><a class="reference internal image-reference" href="../_images/slidingwin2.png"><img alt="../_images/slidingwin2.png" src="../Images/cff43484e462b0df38ba215dd67e6922.png" style="width: 498.0px; height: 125.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/slidingwin2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 51 </span><span class="caption-text">The sliding window</span><a class="headerlink" href="#id16" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-sliding-win-ex"><span class="std std-numref">Fig. 52</span></a> illustrates the operation of the sliding window. It uses a sliding window of three segments. The sender can thus transmit three segments before being forced to wait for an acknowledgment. The sliding window moves to the higher sequence numbers upon the reception of each acknowledgment. When the first acknowledgment (<cite>OK0</cite>) is received, it enables the sender to move its sliding window to the right and sequence number <cite>3</cite> becomes available. This sequence number is used later to transmit the segment containing <cite>d</cite>.</p>
<figure class="align-center" id="id17">
<span id="fig-sliding-win-ex"/><a class="reference internal image-reference" href="../_images/gbnwin.png"><img alt="../_images/gbnwin.png" src="../Images/b5fde7825c12c07ce8b77cc1e5f37556.png" style="width: 432.0px; height: 357.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnwin.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 52 </span><span class="caption-text">Sliding window example</span><a class="headerlink" href="#id17" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In practice, as the segment header includes an <cite>n</cite> bits field to encode the sequence number, only the sequence numbers between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{n}-1\)</span> can be used. This implies that, during a long transfer, the same sequence number will be used for different segments and the sliding window will wrap. This is illustrated in <a class="reference internal" href="#fig-sliding-win-modulo"><span class="std std-numref">Fig. 53</span></a> assuming that <cite>2</cite> bits are used to encode the sequence number in the segment header. Note that upon reception of <cite>OK1</cite>, the sender slides its window and can use sequence number <cite>0</cite> again.</p>
<figure class="align-center" id="id18">
<span id="fig-sliding-win-modulo"/><a class="reference internal image-reference" href="../_images/gbnwinex.png"><img alt="../_images/gbnwinex.png" src="../Images/0ef78f3981c477d103876d2f7358bdd3.png" style="width: 433.2px; height: 357.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnwinex.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 53 </span><span class="caption-text">Utilization of the sliding window with modulo arithmetic</span><a class="headerlink" href="#id18" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-2">Unfortunately, segment losses do not disappear because a reliable protocol uses a sliding window. To recover from losses, a sliding window protocol must define :</p>
<blockquote>
<div><ul class="simple">
<li><p>a heuristic to detect losses</p></li>
<li><p>a <cite>retransmission strategy</cite> to retransmit the lost segments</p></li>
</ul>
</div></blockquote>
<p id="index-3">The simplest sliding window protocol uses the <cite>go-back-n</cite> recovery. Intuitively, <cite>go-back-n</cite> operates as follows. A <cite>go-back-n</cite> receiver is as simple as possible. It only accepts the segments that arrive in-sequence. A <cite>go-back-n</cite> receiver discards any out-of-sequence segment that it receives. When <cite>go-back-n</cite> receives a data segment, it always returns an acknowledgment containing the sequence number of the last in-sequence segment that it has received. This acknowledgment is said to be <cite>cumulative</cite>. When a <cite>go-back-n</cite> receiver sends an acknowledgment for sequence number <cite>x</cite>, it implicitly acknowledges the reception of all segments whose sequence number is earlier than <cite>x</cite>. A key advantage of these cumulative acknowledgments is that it is easy to recover from the loss of an acknowledgment. Consider for example a <cite>go-back-n</cite> receiver that received segments <cite>1</cite>, <cite>2</cite> and <cite>3</cite>. It sent <cite>OK1</cite>, <cite>OK2</cite> and <cite>OK3</cite>. Unfortunately, <cite>OK1</cite> and <cite>OK2</cite> were lost. Thanks to the cumulative acknowledgments, when the sender receives <cite>OK3</cite>, it knows that all three segments have been correctly received.</p>
<p><a class="reference internal" href="#fig-fsm-gbn-receiver"><span class="std std-numref">Fig. 54</span></a> shows the FSM of a simple <cite>go-back-n</cite> receiver. This receiver uses two variables : <cite>lastack</cite> and <cite>next</cite>. <cite>next</cite> is the next expected sequence number and <cite>lastack</cite> the sequence number of the last data segment that has been acknowledged. The receiver only accepts the segments that are received in sequence. <cite>maxseq</cite> is the number of different sequence numbers (<span class="math notranslate nohighlight">\(2^n\)</span>).</p>
<blockquote>
<div><div class="figure" id="id19" style="text-align: center">
<span id="fig-fsm-gbn-receiver"/><p><img src="../Images/129311f9bf007c55636d82806ff9a8ec.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f98d257aa4020916a507e4086b4595bc49d52508.png"/></p>
<p><span class="caption-number">Fig. 54 </span><span class="caption-text">Go-back-n: receiver FSM</span></p>
</div></div></blockquote>
<p>A <cite>go-back-n</cite> sender is also very simple as shown in <a class="reference internal" href="#fig-fsm-gbn-sender"><span class="std std-numref">Fig. 55</span></a>. It uses a sending buffer that can store an entire sliding window of segments <a class="footnote-reference brackets" href="#fsizesliding" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. The segments are sent with increasing sequence numbers (modulo <cite>maxseq</cite>). The sender must wait for an acknowledgment once its sending buffer is full. When a <cite>go-back-n</cite> sender receives an acknowledgment, it removes from the sending buffer all the acknowledged segments and uses a retransmission timer to detect segment losses. A simple <cite>go-back-n</cite> sender maintains one retransmission timer per connection. This timer is started when the first segment is sent. When the <cite>go-back-n sender</cite> receives an acknowledgment, it restarts the retransmission timer only if there are still unacknowledged segments in its sending buffer. When the retransmission timer expires, the <cite>go-back-n</cite> sender assumes that all the unacknowledged segments currently stored in its sending buffer have been lost. It thus retransmits all the unacknowledged segments in the buffer and restarts its retransmission timer.</p>
<blockquote>
<div><div class="figure" id="id20" style="text-align: center">
<span id="fig-fsm-gbn-sender"/><p><img src="../Images/86718f7fdab6919b9def71253750e50a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-9fc242d37f5554e34824b6c8ee7220937fbf0ca0.png"/></p>
<p><span class="caption-number">Fig. 55 </span><span class="caption-text">Go-back-n: sender FSM</span></p>
</div></div></blockquote>
<p>The operation of <cite>go-back-n</cite> is illustrated in <a class="reference internal" href="#fig-gbn-example"><span class="std std-numref">Fig. 56</span></a>. In this figure, note that upon reception of the out-of-sequence segment <cite>D(2,c)</cite>, the receiver returns a cumulative acknowledgment <cite>C(OK,0)</cite> that acknowledges all the segments that have been received in sequence. The lost segment is retransmitted upon the expiration of the retransmission timer.</p>
<figure class="align-center" id="id21">
<span id="fig-gbn-example"/><a class="reference internal image-reference" href="../_images/gbnex2.png"><img alt="../_images/gbnex2.png" src="../Images/7c58d5fa667aca0d9275af765599720a.png" style="width: 513.8px; height: 289.79999999999995px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnex2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 56 </span><span class="caption-text">Go-back-n : example</span><a class="headerlink" href="#id21" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The main advantage of <cite>go-back-n</cite> is that it can be easily implemented, and it can also provide good performance when only a few segments are lost. However, when there are many losses, the performance of <cite>go-back-n</cite> quickly drops for two reasons :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>go-back-n</cite> receiver does not accept out-of-sequence segments</p></li>
<li><p>the <cite>go-back-n</cite> sender retransmits all unacknowledged segments once it has detected a loss</p></li>
</ul>
</div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p id="index-4"><cite>Selective repeat</cite> is a better strategy to recover from losses. Intuitively, <cite>selective repeat</cite> allows the receiver to accept out-of-sequence segments. Furthermore, when a <cite>selective repeat</cite> sender detects losses, it only retransmits the segments that have been lost and not the segments that have already been correctly received.</p>
<p>A <cite>selective repeat</cite> receiver maintains a sliding window of <cite>W</cite> segments and stores in a buffer the out-of-sequence segments that it receives. <a class="reference internal" href="#fig-sr-rwin"><span class="std std-numref">Fig. 57</span></a> shows a five-segment receive window on a receiver that has already received segments <cite>7</cite> and <cite>9</cite>.</p>
<figure class="align-center" id="id22">
<span id="fig-sr-rwin"/><a class="reference internal image-reference" href="../_images/selrepeatwin2.png"><img alt="../_images/selrepeatwin2.png" src="../Images/65c1ca27e931f581cf93b7c9874c2977.png" style="width: 521.5px; height: 58.099999999999994px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/selrepeatwin2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">The receiving window with selective repeat</span><a class="headerlink" href="#id22" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>A <cite>selective repeat</cite> receiver discards all segments having an invalid CRC, and maintains the variable <cite>lastack</cite> as the sequence number of the last in-sequence segment that it has received. The receiver always includes the value of <cite>lastack</cite> in the acknowledgments that it sends. Some protocols also allow the <cite>selective repeat</cite> receiver to acknowledge the out-of-sequence segments that it has received. This can be done for example by placing the list of the correctly received, but out-of-sequence segments in the acknowledgments together with the <cite>lastack</cite> value.</p>
<p>When a <cite>selective repeat</cite> receiver receives a data segment, it first verifies whether the segment is inside its receiving window. If yes, the segment is placed in the receive buffer. If not, the received segment is discarded and an acknowledgment containing <cite>lastack</cite> is sent to the sender. The receiver then removes all consecutive segments starting at <cite>lastack</cite> (if any) from the receive buffer. The payloads of these segments are delivered to the user, <cite>lastack</cite> and the receiving window are updated, and an acknowledgment acknowledging the last segment received in sequence is sent.</p>
<p>The <cite>selective repeat</cite> sender maintains a sending buffer that can store up to <cite>W</cite> unacknowledged segments. These segments are sent as long as the sending buffer is not full. Several implementations of a <cite>selective repeat</cite> sender are possible. A simple implementation associates one retransmission timer to each segment. The timer is started when the segment is sent and canceled upon reception of an acknowledgment that covers this segment. When a retransmission timer expires, the corresponding segment is retransmitted and this retransmission timer is restarted. When an acknowledgment is received, all the segments that are covered by this acknowledgment are removed from the sending buffer and the sliding window is updated.</p>
<p><a class="reference internal" href="#fig-sr-example"><span class="std std-numref">Fig. 58</span></a> illustrates the operation of <cite>selective repeat</cite> when segments are lost. In this figure, <cite>C(OK,x)</cite> is used to indicate that all segments, up to and including sequence number <cite>x</cite> have been received correctly.</p>
<figure class="align-center" id="id23">
<span id="fig-sr-example"/><a class="reference internal image-reference" href="../_images/selrepeat.png"><img alt="../_images/selrepeat.png" src="../Images/5146331e8d7c7c36361e7fc92750fb1a.png" style="width: 525.0px; height: 416.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/selrepeat.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 58 </span><span class="caption-text">Selective repeat : example</span><a class="headerlink" href="#id23" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-5">Pure cumulative acknowledgments work well with the <cite>go-back-n</cite> strategy. However, with only cumulative acknowledgments a <cite>selective repeat</cite> sender cannot easily determine which segments have been correctly received after a data segment has been lost. For example, in the figure above, the second <cite>C(OK,0)</cite> does not inform explicitly the sender of the reception of <cite>D(2,c)</cite> and the sender could retransmit this segment although it has already been received. A possible solution to improve the performance of <cite>selective repeat</cite> is to provide additional information about the received segments in the acknowledgments that are returned by the receiver. For example, the receiver could add in the returned acknowledgment the list of the sequence numbers of all segments that have already been received. Such acknowledgments are sometimes called <cite>selective acknowledgments</cite>. We will provide examples of such acknowledgments in the TCP and QUIC protocols later in this book.</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <div class="admonition note">
<p class="admonition-title">Note</p>
<p>Maximum window size with <cite>go-back-n</cite> and <cite>selective repeat</cite></p>
<p>A reliable protocol that uses <cite>n</cite> bits to encode its sequence number can send up to <span class="math notranslate nohighlight">\(2^n\)</span> successive segments. However, to ensure a reliable delivery of the segments, <cite>go-back-n</cite> and <cite>selective repeat</cite> cannot use a sending window of <span class="math notranslate nohighlight">\(2^n\)</span> segments.
Consider first <cite>go-back-n</cite> and assume that a sender sends <span class="math notranslate nohighlight">\(2^n\)</span> segments. These segments are received in-sequence by the destination, but all the returned acknowledgments are lost. The sender will retransmit all segments. These segments will all be accepted by the receiver and delivered a second time to the user. It is easy to see that this problem can be avoided if the maximum size of the sending window is <span class="math notranslate nohighlight">\({2^n}-1\)</span> segments.
A similar problem occurs with <cite>selective repeat</cite>. However, as the receiver accepts out-of-sequence segments, a sending window of <span class="math notranslate nohighlight">\({2^n}-1\)</span> segments is not sufficient to ensure a reliable delivery. It can be easily shown that to avoid this problem, a <cite>selective repeat</cite> sender cannot use a window that is larger than <span class="math notranslate nohighlight">\(\frac{2^n}{2}\)</span> segments.</p>
</div>
<span class="target" id="index-6"/><span class="target" id="index-7"/><p id="index-8">Reliable protocols often need to send data in both directions. To reduce the overhead caused by the acknowledgments, most reliable protocols use <cite>piggybacking</cite>. Thanks to this technique, an entity can place the acknowledgments and the receive window that it advertises for the opposite direction of the data flow inside the header of the data segments that it sends. The main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgment. This is illustrated in the figure below where the acknowledgment number is underlined in the data segments. Piggybacking is only used when data flows in both directions. A receiver will generate a pure acknowledgment when it does not send data in the opposite direction as shown in the bottom of the figure.</p>
<figure class="align-center" id="id24">
<a class="reference internal image-reference" href="../_images/piggyback2.png"><img alt="../_images/piggyback2.png" src="../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png" style="width: 506.09999999999997px; height: 326.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/piggyback2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 59 </span><span class="caption-text">Piggybacking example</span><a class="headerlink" href="#id24" title="Link to this image">#</a></p>
</figcaption>
</figure>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        </section>
</section>
<section id="establishing-a-transport-connection">
<h2>Establishing a transport connection<a class="headerlink" href="#establishing-a-transport-connection" title="Link to this heading">#</a></h2>
<p>Like the connectionless service, the connection-oriented service allows several applications running on a given host to exchange data with other hosts. The port numbers described earlier for the connectionless service are also used by the connection-oriented service to multiplex several applications. Similarly, connection-oriented protocols use checksums/CRCs to detect transmission errors and discard segments containing an invalid checksum/CRC.</p>
<p>An important difference between the connectionless service and the connection-oriented one is that the transport entities in the latter maintain some state during lifetime of the connection. This state is created when a connection is established and is removed when it is released.</p>
<p>The simplest approach to establish a transport connection would be to define two special control segments : <cite>CR</cite> (Connection Request) and <cite>CA</cite> (Connection Acknowledgment). The <cite>CR</cite> segment is sent by the transport entity that wishes to initiate a connection. If the remote entity wishes to accept the connection, it replies by sending a <cite>CA</cite> segment. The <cite>CR</cite> and <cite>CA</cite> segments contain <cite>port numbers</cite> that allow identifying the communicating applications. The transport connection is considered to be established once the <cite>CA</cite> segment has been received. At that point, data segments can be sent in both directions.</p>
<p class="mscgen">
<img src="../Images/384affb0102503143b8af853578161f2.png" alt="msc {&#10;a1 [label=&quot;&quot;, linecolour=white],&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Source&quot;, linecolour=black],&#10;z [label=&quot;Provider&quot;, linecolour=white],&#10;c [label=&quot;Destination&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white],&#10;d1 [label=&quot;&quot;, linecolour=white];&#10;&#10;a1=&gt;b [ label = &quot;CONNECT.req&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;CR&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;c=&gt;d1 [ label = &quot;CONNECT.ind&quot; ];&#10;&#10;d1=&gt;c [ label = &quot;CONNECT.resp&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;CA&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;b=&gt;a1 [ label = &quot;CONNECT.conf&quot; ];&#10;&#10;a1=&gt;b [ linecolour=white, textcolour=blue, label = &quot;Connection\nestablished&quot; ] ,&#10;c=&gt;d1 [ linecolour=white, textcolour=blue, label = &quot;Connection\nestablished&quot; ];&#10;}" usemap="#c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7.png"/>
<map id="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7" name="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"/></p>
<p>Unfortunately, this is not sufficient given the unreliability of the network layer. Since the network layer is imperfect, the <cite>CR</cite> or <cite>CA</cite> segments can be lost, delayed, or suffer from transmission errors. To deal with these problems, the control segments must be protected by a CRC or a checksum to detect transmission errors. Furthermore, since the <cite>CA</cite> segment acknowledges the reception of the <cite>CR</cite> segment, the <cite>CR</cite> segment should be protected using a retransmission timer.</p>
<p>Unfortunately, this scheme is not sufficient to ensure the reliability of the transport service. Consider for example a short-lived transport connection where a single, but important transfer (e.g. money transfer from a bank account) is sent. Such a short-lived connection starts with a <cite>CR</cite> segment acknowledged by a <cite>CA</cite> segment, then the data segment is sent, acknowledged and the connection terminates. Unfortunately, as the network layer service is unreliable, delays combined to retransmissions may lead to the situation depicted in the figure below, where a delayed <cite>CR</cite> and data segments from a former connection are accepted by the receiving entity as valid segments, and the corresponding data is delivered to the user. Duplicating SDUs is not acceptable, and the transport protocol must solve this problem.</p>
<p class="mscgen">
<img src="../Images/450730721625aed82431f20387763529.png" alt="msc {&#10;a1 [label=&quot;&quot;, linecolour=white],&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Source&quot;, linecolour=black],&#10;z [label=&quot;Provider&quot;, linecolour=white],&#10;c [label=&quot;Destination&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white],&#10;d1 [label=&quot;&quot;, linecolour=white];&#10;&#10;a1=&gt;b [ label = &quot;CONNECT.req&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;CR&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;c=&gt;d1 [ label = &quot;CONNECT.ind&quot; ];&#10;&#10;d1=&gt;c [ label = &quot;CONNECT.resp&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;CA&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;b=&gt;a1 [ label = &quot;CONNECT.conf&quot; ];&#10;&#10;a1=&gt;b [ linecolour=white, textcolour=blue, label = &quot;First connection\nestablished&quot; ] ,&#10;c=&gt;d1 [ linecolour=white, textcolour=blue, label = &quot;First connection\nestablished&quot; ];&#10;&#10;a1=&gt;b [ label = &quot;&quot;, linecolour=white];&#10;&#10;a1=&gt;b [ linecolour=white, textcolour=red, label = &quot;First connection\nclosed&quot; ] ,&#10;c=&gt;d1 [ linecolour=white, textcolour=red, label = &quot;First connection\nclosed&quot; ];&#10;&#10;z&gt;&gt;c [ label = &quot;CR&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;c=&gt;d1 [ label = &quot;How to detect duplicates ?&quot; ],&#10;c&gt;&gt;b [ label = &quot;CA&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;a1=&gt;b [ label = &quot;&quot;, linecolour=white];&#10;z&gt;&gt;c [ label = &quot;D&quot;, arcskip=&quot;1&quot;];&#10;}" usemap="#453dea7b2a70bc75af50524c87354c0a129e1d05" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-453dea7b2a70bc75af50524c87354c0a129e1d05.png"/>
<map id="453dea7b2a70bc75af50524c87354c0a129e1d05" name="453dea7b2a70bc75af50524c87354c0a129e1d05"/></p>
<p id="index-9">To avoid these duplicates, transport protocols require the network layer to bound the <cite>Maximum Segment Lifetime (MSL)</cite>. The organization of the network must guarantee that no segment remains in the network for longer than <cite>MSL</cite> seconds. For example, on today’s Internet, <cite>MSL</cite> is expected to be 2 minutes. To avoid duplicate transport connections, transport protocol entities must be able to safely distinguish between a duplicate <cite>CR</cite> segment and a new <cite>CR</cite> segment, without forcing each transport entity to remember all the transport connections that it has established in the past.</p>
<p>A classical solution to avoid remembering the previous transport connections to detect duplicates is to use a clock inside each transport entity. This <cite>transport clock</cite> has the following characteristics :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>transport clock</cite> is implemented as a <cite>k</cite> bits counter and its clock cycle is such that <span class="math notranslate nohighlight">\(2^k \times cycle &gt;&gt; MSL\)</span>. Furthermore, the <cite>transport clock</cite> counter is incremented every clock cycle and after each connection establishment. This clock is illustrated in <a class="reference internal" href="#fig-transport-clock"><span class="std std-numref">Fig. 60</span></a>.</p></li>
<li><p>the <cite>transport clock</cite> must continue to be incremented even if the transport entity stops or reboots</p></li>
</ul>
</div></blockquote>
<figure class="align-center" id="id25">
<span id="fig-transport-clock"/><a class="reference internal image-reference" href="../_images/transport-clock.png"><img alt="../_images/transport-clock.png" src="../Images/036312a7c0aeea69142b1e45c82f9114.png" style="width: 434.0px; height: 143.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-clock.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 60 </span><span class="caption-text">Transport clock</span><a class="headerlink" href="#id25" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>It should be noted that <cite>transport clocks</cite> do not need and usually are not synchronized to the real-time clock. Precisely synchronizing real-time clocks is an interesting problem, but it is outside the scope of this document. See <a class="reference internal" href="../bibliography.html#mills2006" id="id8"><span>[Mills2006]</span></a> for a detailed discussion on synchronizing the real-time clock.</p>
<p>This <cite>transport clock</cite> can be combined with an exchange of three segments, called the <cite>three way handshake</cite>, to detect duplicates. This <cite>three way handshake</cite> occurs as follows :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The initiating transport entity sends a <cite>CR</cite> segment. This segment requests the establishment of a transport connection. It contains a port number (not shown in the figure) and a sequence number (<cite>seq=x</cite> in the figure below) whose value is extracted from the <cite>transport clock</cite>. The transmission of the <cite>CR</cite> segment is protected by a retransmission timer.</p></li>
<li><p>The remote transport entity processes the <cite>CR</cite> segment and creates state for the connection attempt. At this stage, the remote entity does not yet know whether this is a new connection attempt or a duplicate segment. It returns a <cite>CA</cite> segment that contains an acknowledgment number to confirm the reception of the <cite>CR</cite> segment (<cite>ack=x</cite> in the figure below) and a sequence number (<cite>seq=y</cite> in the figure below) whose value is extracted from its transport clock. At this stage, the connection is not yet established.</p></li>
<li><p>The initiating entity receives the <cite>CA</cite> segment. The acknowledgment number of this segment confirms that the remote entity has correctly received the <cite>CR</cite> segment. The transport connection is considered to be established by the initiating entity and the numbering of the data segments starts at sequence number <cite>x</cite>. Before sending data segments, the initiating entity must acknowledge the received <cite>CA</cite> segments by sending another <cite>CA</cite> segment.</p></li>
<li><p>The remote entity considers the transport connection to be established after having received the segment that acknowledges its <cite>CA</cite> segment. The numbering of the data segments sent by the remote entity starts at sequence number <cite>y</cite>.</p></li>
</ol>
</div></blockquote>
<p>The three way handshake is illustrated in <a class="reference internal" href="#fig-three-way-handshake"><span class="std std-numref">Fig. 61</span></a>.</p>
<figure class="align-center" id="id26">
<span id="fig-three-way-handshake"/><a class="reference internal image-reference" href="../_images/transport-twh.png"><img alt="../_images/transport-twh.png" src="../Images/73ba69b884756214c68976e4bd783556.png" style="width: 536.1999999999999px; height: 301.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 61 </span><span class="caption-text">The three-way handshake</span><a class="headerlink" href="#id26" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Thanks to the three-way handshake, transport entities avoid duplicate transport connections. This is illustrated by considering the three scenarios below.</p>
<p>The first scenario (<a class="reference internal" href="#fig-twa-scenario1"><span class="std std-numref">Fig. 62</span></a>) is when the remote entity receives an old <cite>CR</cite> segment. It considers this <cite>CR</cite> segment as a connection establishment attempt and replies by sending a <cite>CA</cite> segment. However, the initiating host cannot match the received <cite>CA</cite> segment with a previous connection attempt. It sends a control segment (<cite>REJECT</cite> in the figure below) to cancel the spurious connection attempt. The remote entity cancels the connection attempt upon reception of this control segment.</p>
<figure class="align-center" id="id27">
<span id="fig-twa-scenario1"/><a class="reference internal image-reference" href="../_images/transport-twh-dup.png"><img alt="../_images/transport-twh-dup.png" src="../Images/81f6e94d2c77bba094868c0725d75ae7.png" style="width: 518.0px; height: 251.99999999999997px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh-dup.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 62 </span><span class="caption-text">Three-way handshake : recovery from a duplicate <cite>CR</cite></span><a class="headerlink" href="#id27" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>A second scenario, shown in <a class="reference internal" href="#fig-twa-scenario2"><span class="std std-numref">Fig. 63</span></a> is when the initiating entity sends a <cite>CR</cite> segment that does not reach the remote entity and receives a duplicate <cite>CA</cite> segment from a previous connection attempt. This duplicate <cite>CA</cite> segment cannot contain a valid acknowledgment for the <cite>CR</cite> segment as the sequence number of the <cite>CR</cite> segment was extracted from the transport clock of the initiating entity. The <cite>CA</cite> segment is thus rejected and the <cite>CR</cite> segment is retransmitted upon expiration of the retransmission timer.</p>
<figure class="align-center" id="id28">
<span id="fig-twa-scenario2"/><a class="reference internal image-reference" href="../_images/transport-twh-dup2.png"><img alt="../_images/transport-twh-dup2.png" src="../Images/4a3c5e9fdcb7671a490f8c5fbebda7f5.png" style="width: 538.3px; height: 319.9px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh-dup2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 63 </span><span class="caption-text">Three-way handshake : recovery from a duplicate <cite>CA</cite></span><a class="headerlink" href="#id28" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The last scenario shown in <a class="reference internal" href="#fig-twa-scenario3"><span class="std std-numref">Fig. 64</span></a> is less likely, but it is important to consider it as well. The remote entity receives an old <cite>CR</cite> segment. It notes the connection attempt and acknowledges it by sending a <cite>CA</cite> segment. The initiating entity does not have a matching connection attempt and replies by sending a <cite>REJECT</cite>. Unfortunately, this segment never reaches the remote entity. Instead, the remote entity receives a retransmission of an older <cite>CA</cite> segment that contains the same sequence number as the first <cite>CR</cite> segment. This <cite>CA</cite> segment cannot be accepted by the remote entity as a confirmation of the transport connection as its acknowledgment number cannot have the same value as the sequence number of the first <cite>CA</cite> segment.</p>
<figure class="align-center" id="id29">
<span id="fig-twa-scenario3"/><a class="reference internal image-reference" href="../_images/transport-twh-dup3.png"><img alt="../_images/transport-twh-dup3.png" src="../Images/9e3c98b89e77408b7654305f9b1a2be3.png" style="width: 514.5px; height: 276.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh-dup3.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 64 </span><span class="caption-text">Three-way handshake : recovery from duplicates <cite>CR</cite> and <cite>CA</cite></span><a class="headerlink" href="#id29" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="transferring-data-on-a-transport-connection">
<h2>Transferring data on a transport connection<a class="headerlink" href="#transferring-data-on-a-transport-connection" title="Link to this heading">#</a></h2>
<p>Now that the transport connection has been established, it can be used to transfer data. To ensure a reliable delivery of the data, the transport protocol will include sliding windows, retransmission timers and <cite>go-back-n</cite> or <cite>selective repeat</cite>. However, we cannot simply reuse these techniques because a reliable transport protocol also needs to cope with three additional types of errors (i) variable delays, (ii) out-f-sequence delivery and (iii) segment duplication.</p>
<p>When two hosts are connected by a link, the transmission delay or the round-trip-time over the link is almost fixed. In a network that can span the globe, the delays and the round-trip-times can vary significantly on a per packet basis. This variability can be caused by two factors. First, packets sent through a network do not necessarily follow the same path to reach their destination. Second, some packets may be queued in the buffers of routers when the load is high and these queuing delays can lead to increased end-to-end delays.</p>
<p>Another problem is that a network does not always deliver packets in sequence. This implies that packets may be reordered by the network. Furthermore, the network may sometimes duplicate packets.</p>
<p>The last issue that needs to be dealt with in the transport layer is the transmission of large SDUs. In our example, we have used short SDUs which fit easily inside segments. Some applications generate SDUs that are much larger than the maximum size of a packet in the network layer. The transport layer needs to include mechanisms to fragment and reassemble these large SDUs.</p>
<p>To deal with all these characteristics of the network layer, we need to adapt the go-back-n and selective repeat techniques that we have introduced earlier.</p>
<p>The ability to detect transmission errors remains important. Each segment contains a CRC/checksum which is computed over the entire segment (header and payload) by the sender and inserted in the header. The receiver recomputes the CRC/checksum for each received segment and discards all segments with an invalid CRC.</p>
<p>Reliable transport protocols also use sequence numbers and acknowledgment numbers. While our example protocols used one sequence number per segment, some reliable transport protocols consider all the data transmitted as a stream of bytes. In these protocols, the sequence number placed in the segment header corresponds to the position of the first byte of the payload in the bytestream. This sequence number allows detecting losses but also enables the receiver to reorder the out-of-sequence segments. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/d415b226c2c0f1663b1289acf10b1351.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(abcde)&quot; ] ,&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;1:abcde&quot;];&#10;c=&gt;d [label=&quot;DATA.ind(abcde)&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(fghijkl)&quot; ] ,&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;6:fghijkl&quot;];&#10;c=&gt;d [label=&quot;DATA.ind(fghijkl)&quot;];&#10;}" usemap="#3c7d33b83d1006864217839e39a4133300ffe3b0" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-3c7d33b83d1006864217839e39a4133300ffe3b0.png"/>
<map id="3c7d33b83d1006864217839e39a4133300ffe3b0" name="3c7d33b83d1006864217839e39a4133300ffe3b0"/></p>
</div></blockquote>
<p>Using sequence numbers to count bytes has also one advantage when the transport layer needs to fragment SDUs in several segments. The figure below shows the fragmentation of a large SDU in two segments. Upon reception of the segments, the receiver will use the sequence numbers to correctly reorder the data.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/e9784923b6b5cd4438e6db36fa5b219d.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(abcdefghijkl)&quot; ] ,&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;1:abcde&quot;];&#10;|||;&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;6:fghijkl&quot;];&#10;c=&gt;d [label=&quot;DATA.ind(abcdefghijkl)&quot;];&#10;}" usemap="#b07721edb508d3fcfd4dc92201cb3bc97f1a85ba" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b07721edb508d3fcfd4dc92201cb3bc97f1a85ba.png"/>
<map id="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba" name="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"/></p>
</div></blockquote>
<p>Compared to our simple protocols, reliable transport protocols encode their sequence numbers using more bits. 32 bits and 64 bits sequence numbers are frequent in the transport layer. This large sequence number space is motivated by two reasons. First, since the sequence number is incremented for each transmitted byte, a single segment may consume one or several thousands of sequence numbers. Second, a reliable transport protocol must be able to detect delayed segments. This can only be done if the number of bytes transmitted during the MSL period is smaller than the sequence number space. Otherwise, there is a risk of accepting duplicate segments.</p>
<p><cite>Go-back-n</cite> and <cite>selective repeat</cite> can be used in the transport layer as in the datalink layer. Since the network layer does not guarantee an in-order delivery of the packets, a transport entity should always store the segments that it receives out-of-sequence. For this reason, most transport protocols will opt for some form of selective repeat mechanism.</p>
<p>In simple protocols, the sliding window has usually a fixed size which depends on the amount of available buffers. A single transport layer entity serves a large and varying number of application processes. Each transport layer entity manages a pool of buffers that needs to be shared between all these processes. Transport entity are usually implemented inside the operating system kernel and shares memory with other parts of the system. Furthermore, a transport layer entity must support several (possibly hundreds or thousands) of transport connections at the same time. This implies that the memory which can be used to support the sending or the receiving buffer of a transport connection may change during the lifetime of the connection <a class="footnote-reference brackets" href="#fautotune" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> . Thus, a transport protocol must allow the sender and the receiver to adjust their window sizes.</p>
<p>To deal with this issue, transport protocols allow the receiver to advertise the current size of its receiving window in all the acknowledgments that it sends. The receiving window advertised by the receiver bounds the size of the sending buffer used by the sender. In practice, the sender maintains two state variables : <cite>swin</cite>, the size of its sending window (that may be adjusted by the system) and <cite>rwin</cite>, the size of the receiving window advertised by the receiver. At any time, the number of unacknowledged segments cannot be larger than <span class="math notranslate nohighlight">\(\min(swin,rwin)\)</span> <a class="footnote-reference brackets" href="#facklost" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> . The utilization of dynamic windows is illustrated in figure <a class="reference internal" href="#fig-transport-dynamic-win"><span class="std std-numref">Fig. 65</span></a>.</p>
<figure class="align-center" id="id30">
<span id="fig-transport-dynamic-win"/><a class="reference internal image-reference" href="../_images/transport-dwin.svg"><img alt="../_images/transport-dwin.svg" src="../Images/b265eb3f8dd59868de804ccf800a887f.png" style="width: 800.0px; height: 600.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-dwin.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 65 </span><span class="caption-text">Dynamic receiving window</span><a class="headerlink" href="#id30" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The receiver may adjust its advertised receive window based on its current memory consumption, but also to limit the bandwidth used by the sender. In practice, the receive buffer can also shrink as the application may not able to process the received data quickly enough. In this case, the receive buffer may be completely full and the advertised receive window may shrink to <cite>0</cite>. When the sender receives an acknowledgment with a receive window set to <cite>0</cite>, it is blocked until it receives an acknowledgment with a positive receive window. Unfortunately, as shown in <a class="reference internal" href="#fig-win-deadlock"><span class="std std-numref">Fig. 66</span></a>, the loss of this acknowledgment could cause a deadlock as the sender waits for an acknowledgment while the receiver is waiting for a data segment.</p>
<figure class="align-center" id="id31">
<span id="fig-win-deadlock"/><a class="reference internal image-reference" href="../_images/transport-win-deadlock.png"><img alt="../_images/transport-win-deadlock.png" src="../Images/66586c6dcc13b89a7b00c779de739ebc.png" style="width: 438.59999999999997px; height: 238.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-win-deadlock.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 66 </span><span class="caption-text">Risk of deadlock with dynamic windows</span><a class="headerlink" href="#id31" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-10">To solve this problem, transport protocols rely on a special timer : the <cite>persistence timer</cite>. This timer is started by the sender whenever it receives an acknowledgment advertising a receive window set to <cite>0</cite>. When the timer expires, the sender retransmits an old segment in order to force the receiver to send a new acknowledgment, and hence send the current receive window size.</p>
<p>To conclude our description of the basic mechanisms found in transport protocols, we still need to discuss the impact of segments arriving in the wrong order. If two consecutive segments are reordered, the receiver relies on their sequence numbers to reorder them in its receive buffer. Unfortunately, as transport protocols reuse the same sequence number for different segments, if a segment is delayed for a prolonged period of time, it might still be accepted by the receiver. This is illustrated in <a class="reference internal" href="#fig-transport-ambiguity"><span class="std std-numref">Fig. 67</span></a> where segment <cite>D(1,b)</cite> is delayed.</p>
<figure class="align-center" id="id32">
<span id="fig-transport-ambiguity"/><a class="reference internal image-reference" href="../_images/transport-ambiguities.png"><img alt="../_images/transport-ambiguities.png" src="../Images/47226dd629dc43186633321c93f4871f.png" style="width: 360.0px; height: 199.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-ambiguities.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 67 </span><span class="caption-text">Ambiguities caused by excessive delays</span><a class="headerlink" href="#id32" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-11">To deal with this problem, transport protocols combine two solutions. First, they use 32 bits or more to encode the sequence number in the segment header. This increases the overhead, but also increases the delay between the transmission of two different segments having the same sequence number. Second, transport protocols require the network layer to enforce a <cite>Maximum Segment Lifetime (MSL)</cite>. The network layer must ensure that no packet remains in the network for more than MSL seconds. In the Internet the MSL is assumed <a class="footnote-reference brackets" href="#fmsl" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> to be 2 minutes <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc793.html"><strong>RFC 793</strong></a>. Note that this limits the maximum bandwidth of a transport protocol. If it uses <cite>n</cite> bits to encode its sequence numbers, then it cannot send more than <span class="math notranslate nohighlight">\(2^n\)</span> segments every MSL seconds.</p>
</section>
<section id="closing-a-transport-connection">
<h2>Closing a transport connection<a class="headerlink" href="#closing-a-transport-connection" title="Link to this heading">#</a></h2>
<p id="index-13">When we discussed the connection-oriented service, we mentioned that there are two types of connection releases : <cite>abrupt release</cite> and <cite>graceful release</cite>.</p>
<p>The first solution to release a transport connection is to define a new control segment (e.g. the <cite>DR</cite> segment for Disconnection Request) and consider the connection to be released once this segment has been sent or received. This is illustrated in <a class="reference internal" href="#fig-abrupt-release"><span class="std std-numref">Fig. 68</span></a>.</p>
<figure class="align-center" id="id33">
<span id="fig-abrupt-release"/><a class="reference internal image-reference" href="../_images/transport-abrupt.png"><img alt="../_images/transport-abrupt.png" src="../Images/2cbf4e00facf50e43973ab7e7a5671dd.png" style="width: 434.4px; height: 226.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-abrupt.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 68 </span><span class="caption-text">Abrupt connection release</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>As the entity that sends the <cite>DR</cite> segment cannot know whether the other entity has already sent all its data on the connection, SDUs can be lost during such an <cite>abrupt connection release</cite>.</p>
<p id="index-14">The second method to release a transport connection is to release independently the two directions of data transfer. Once a user of the transport service has sent all its SDUs, it performs a <cite>DISCONNECT.req</cite> for its direction of data transfer. The transport entity sends a control segment to request the release of the connection <em>after</em> the delivery of all previous SDUs to the remote user. This is usually done by placing in the <cite>DR</cite> the next sequence number and by delivering the <cite>DISCONNECT.ind</cite> only after all previous <cite>DATA.ind</cite>. The remote entity confirms the reception of the <cite>DR</cite> segment and the release of the corresponding direction of data transfer by returning an acknowledgment. This is illustrated in <a class="reference internal" href="#fig-graceful-release"><span class="std std-numref">Fig. 69</span></a>.</p>
<figure class="align-center" id="id34">
<span id="fig-graceful-release"/><a class="reference internal image-reference" href="../_images/transport-graceful.png"><img alt="../_images/transport-graceful.png" src="../Images/2967c3a8822fc72dfc8c278f20b61f48.png" style="width: 480.2px; height: 249.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-graceful.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 69 </span><span class="caption-text">Graceful connection release</span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fsdu" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>SDU is the acronym of Service Data Unit. We use it as a generic term to represent the data that is transported by a protocol.</p>
</aside>
<aside class="footnote brackets" id="fsizesliding" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">2</a><span class="fn-bracket">]</span></span>
<p>The size of the sliding window can be either fixed for a given protocol or negotiated during the connection establishment phase. Some protocols allow to change the maximum window size during the data transfer. We will explain these techniques with real protocols later.</p>
</aside>
<aside class="footnote brackets" id="fautotune" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">3</a><span class="fn-bracket">]</span></span>
<p>For a discussion on how the sending buffer can change, see e.g. <a class="reference internal" href="../bibliography.html#smm1998" id="id12"><span>[SMM1998]</span></a></p>
</aside>
<aside class="footnote brackets" id="facklost" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">4</a><span class="fn-bracket">]</span></span>
<p>Note that if the receive window shrinks, it might happen that the sender has already sent a segment that is not anymore inside its window. This segment will be discarded by the receiver and the sender will retransmit it later.</p>
</aside>
<aside class="footnote brackets" id="fmsl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">5</a><span class="fn-bracket">]</span></span>
<p>In reality, the Internet does not strictly enforce this MSL. However, it is reasonable to expect that most packets on the Internet will not remain in the network during more than 2 minutes. There are a few exceptions to this rule, such as <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1149.html"><strong>RFC 1149</strong></a> whose implementation is described in <a class="reference external" href="http://www.blug.linux.no/rfc1149/">http://www.blug.linux.no/rfc1149/</a> but there are few real links supporting <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1149.html"><strong>RFC 1149</strong></a> in the Internet.</p>
</aside>
</aside>
</section>
&#13;

<h2>A simple reliable protocol<a class="headerlink" href="#a-simple-reliable-protocol" title="Link to this heading">#</a></h2>
<p>In this section, we develop a simple reliable protocol running above the network service. To design this protocol, we first assume that the underlying layer provides a perfect service. We will then develop solutions to recover from different types of errors that affect the network service.</p>
<p>The network layer is designed to send and receive packets on behalf of a user. We model these interactions by using the <cite>DATA.req</cite> and <cite>DATA.ind</cite> primitives. However, to simplify the presentation and to avoid confusion between a <cite>DATA.req</cite> primitive issued by the user of the network layer, and a <cite>DATA.req</cite> issued by the transport layer entity itself, we use the following terminology :</p>
<blockquote>
<div><ul class="simple">
<li><p>the interactions between the user and the transport layer entity are represented by using the classical <cite>DATA.req</cite> and the <cite>DATA.ind</cite> primitives</p></li>
<li><p>the interactions between the transport layer entity and the sub-layer are represented by using <cite>send</cite> instead of <cite>DATA.req</cite> and <cite>recvd</cite> instead of <cite>DATA.ind</cite></p></li>
</ul>
</div></blockquote>
<p>When running on top of a perfect network, a transport entity can simply issue a <cite>send(SDU)</cite> upon arrival of a <cite>DATA.req(SDU)</cite> <a class="footnote-reference brackets" href="#fsdu" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Similarly, the receiver issues a <cite>DATA.ind(SDU)</cite> upon receipt of a <cite>recvd(SDU)</cite>. Such a simple protocol is sufficient when a single SDU is sent. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/ba824d054705364b69646b80420c85eb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(SDU)&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;Segment(SDU)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(SDU)&quot; ];&#10;}" usemap="#e44596b6402c634781fc156189b78b14744a061d" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-e44596b6402c634781fc156189b78b14744a061d.png"/>
<map id="e44596b6402c634781fc156189b78b14744a061d" name="e44596b6402c634781fc156189b78b14744a061d"/></p>
</div></blockquote>
<p>Unfortunately, this is not always sufficient to ensure a reliable delivery of SDUs. Consider the case where a client sends tens of SDUs to a server. If the server is faster than the client, it will be able to receive and process all the segments sent by the client and deliver their content to its user. However, if the server is slower than the client, problems may arise. The transport entity contains buffers to store SDUs that have been received as a <cite>Data.request</cite> but have not yet been sent. If the application is faster than the network, the buffer may become full. At this point, the operating system suspends the application to let the transport entity empty its transmission queue. The transport entity also uses a buffer to store the received segments that have not yet been processed by the application. If the application is slow to process the data, this buffer may overflow and the transport entity will not able to accept any additional segment. The buffers of the transport entity have a limited size and if they overflow, the arriving segments will be discarded, even if they are correct.</p>
<p>To solve this problem, a reliable protocol must include a feedback mechanism that allows the receiver to inform the sender that it has processed a segment and that another one can be sent. This feedback is required even though there are no transmission errors. To include such a feedback, our reliable protocol must process two types of segments :</p>
<blockquote>
<div><ul class="simple">
<li><p>data segments carrying a SDU</p></li>
<li><p>control segments confirming that the previous segment was correctly processed</p></li>
</ul>
</div></blockquote>
<p>These control segments are usually called <cite>acknowledgments</cite> because they acknowledge the correct reception of data.</p>
<p>These two types of segments can be distinguished by dividing the segments in two parts :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>header</cite> that contains a <cite>segment type</cite> bit set to <cite>0</cite> in data segments and set to <cite>1</cite> in control segments</p></li>
<li><p>the payload that contains the SDU supplied by the application</p></li>
</ul>
</div></blockquote>
<p>Our transport entity can then be modeled as a finite state machine, containing two states for the receiver and two states for the sender. <a class="reference internal" href="#fig-fsm1-transport"><span class="std std-numref">Fig. 47</span></a> provides a graphical representation of this state machine with the sender above and the receiver below.</p>
<blockquote>
<div><div class="figure" id="id13" style="text-align: center">
<span id="fig-fsm1-transport"/><p><img src="../Images/ca317c24a120ea2f84f77bb8205d331e.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e5bcad7738bbd36ecec2c9c6869d4e4fa85fbc91.png"/></p>
<p><span class="caption-number">Fig. 47 </span><span class="caption-text">Finite state machines of the simplest reliable protocol (sender above, receiver below)</span></p>
</div></div></blockquote>
<p>The sender FSM shows that the sender has to wait for an acknowledgment from the receiver before being able to transmit the next SDU.  The figure below illustrates the exchange of a few segments between two hosts.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/15482ac863d12db91aebf9dbd402b97a.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)&quot;], b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ],c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)&quot; ], b&gt;&gt;c [ label = &quot;D(b)&quot;,arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ], c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#60a9f1c91540fca4ffa054e6b58cb88cf03463af" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-60a9f1c91540fca4ffa054e6b58cb88cf03463af.png"/>
<map id="60a9f1c91540fca4ffa054e6b58cb88cf03463af" name="60a9f1c91540fca4ffa054e6b58cb88cf03463af"/></p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Services and protocols</p>
<p>An important aspect to understand when studying computer networks is the difference between a <em>service</em> and a <em>protocol</em>. For this, it is useful to start with real world examples. The traditional Post provides a service where a postman delivers letters to recipients. The Post precisely defines which types of letters (size, weight, etc) can be delivered by using the Standard Mail service. Furthermore, the format of the envelope is specified (position of the sender and recipient addresses, position of the stamp). Someone who wants to send a letter must either place the letter at a Post Office or inside one of the dedicated mailboxes. The letter will then be collected and delivered to its final recipient. Note that for the regular service the Post usually does not guarantee the delivery of each particular letter. Some letters may be lost, and some letters are delivered to the wrong mailbox. If a letter is important, then the sender can use the registered service to ensure that the letter will be delivered to its recipient. Some Post services also provide an acknowledged service or an express mail service that is faster than the regular service.</p>
</div>
<section id="reliable-transfer-above-an-imperfect-link">
<h3>Reliable transfer above an imperfect link<a class="headerlink" href="#reliable-transfer-above-an-imperfect-link" title="Link to this heading">#</a></h3>
<p>The transport layer must deal with several types of errors which can affect the segments that it sends. In practice, we mainly have to deal with two types of errors in the transport layer :</p>
<blockquote>
<div><ul class="simple">
<li><p>Segments can be corrupted by transmission errors</p></li>
<li><p>Segments can be lost or unexpected segments can appear</p></li>
</ul>
</div></blockquote>
<p>To detect errors, a segment is usually divided into two parts :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>header</cite> that contains the fields used by the reliable protocol to ensure reliable delivery. The header contains a checksum or Cyclical Redundancy Check (CRC) <a class="reference internal" href="../bibliography.html#williams1993" id="id2"><span>[Williams1993]</span></a> that is used to detect transmission errors</p></li>
<li><p>a <cite>payload</cite> that contains the user data</p></li>
</ul>
</div></blockquote>
<p>Some headers also include a <cite>length</cite> field, which indicates the total length of the segment or the length of the payload.</p>
<p>The simplest error detection scheme is the checksum. A checksum is basically an arithmetic sum of all the bytes that a segment is composed of. There are different types of checksums. For example, an eight bit checksum can be computed as the arithmetic sum of all the bytes of (both the header and trailer of) the segment. The checksum is computed by the sender before sending the segment and the receiver verifies the checksum upon segment reception. The receiver discards segments received with an invalid checksum. Checksums can be easily implemented in software, but their error detection capabilities are limited. Cyclical Redundancy Checks (CRC) have better error detection capabilities <a class="reference internal" href="../bibliography.html#sgp98" id="id3"><span>[SGP98]</span></a>, but require more CPU when implemented in software.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Checksums, CRCs,…</p>
<p>Most of the protocols in the TCP/IP protocol suite rely on the simple Internet checksum in order to verify that a received packet has not been affected by transmission errors. Despite its popularity and ease of implementation, the Internet checksum is not the only available checksum mechanism. Cyclical Redundancy Checks (<a class="reference external" href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>) are very powerful error detection schemes that are used notably on disks, by many datalink layer protocols and file formats such as <code class="docutils literal notranslate"><span class="pre">zip</span></code> or <code class="docutils literal notranslate"><span class="pre">png</span></code>. They can easily be implemented efficiently in hardware and have better error-detection capabilities than the Internet checksum <a class="reference internal" href="../bibliography.html#sgp98" id="id4"><span>[SGP98]</span></a> . However, CRCs are sometimes considered to be too CPU-intensive for software implementations and other checksum mechanisms are preferred. The TCP/IP community chose the Internet checksum, the OSI community chose the Fletcher checksum <a class="reference internal" href="../bibliography.html#sklower89" id="id5"><span>[Sklower89]</span></a>. Nowadays there are efficient techniques to quickly compute CRCs in software <a class="reference internal" href="../bibliography.html#feldmeier95" id="id6"><span>[Feldmeier95]</span></a>.</p>
</div>
<p>Since the receiver sends an acknowledgment after having received each data segment, the simplest solution to deal with losses is to use a retransmission timer. When the sender sends a segment, it starts a retransmission timer. The duration of this retransmission timer should be larger than the <cite>round-trip-time</cite>, i.e. the delay between the transmission of a data segment and the reception of the corresponding acknowledgment. When the retransmission timer expires, the sender assumes that the data segment has been lost and retransmits it. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/eb3e128faed868520ea345c4171d9007.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b-x c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;, linecolour=red];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#8057bc41346c284d032cdac99ea8cefe6d4cb0d6" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-8057bc41346c284d032cdac99ea8cefe6d4cb0d6.png"/>
<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6" name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"/></p>
</div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p>Unfortunately, retransmission timers alone are not sufficient to recover from losses. Let us consider, as an example, the situation depicted below where an acknowledgment is lost. In this case, the sender retransmits the data segment that has not been acknowledged. However, as illustrated in the figure below, the receiver considers the retransmission as a new segment whose payload must be delivered to its user.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f31aca9d4a56211a006ee59b4bbd6581.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c-x b [label= &quot;C(OK)&quot;, linecolour=red, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b) !!!!!&quot;, linecolour=red ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#34c7c055da8716230ba3f29574fb761575e3d9f5" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-34c7c055da8716230ba3f29574fb761575e3d9f5.png"/>
<map id="34c7c055da8716230ba3f29574fb761575e3d9f5" name="34c7c055da8716230ba3f29574fb761575e3d9f5"/></p>
</div></blockquote>
<p id="index-0">To solve this problem, reliable protocols associate a <cite>sequence number</cite> to each data segment. This <cite>sequence number</cite> is one of the fields found in the header of data segments. We use the notation <cite>D(x,…)</cite> to indicate a data segment whose sequence number field is set to value <cite>x</cite>. The acknowledgments also contain a sequence number indicating the data segments that it acknowledges. We use <cite>OKx</cite> to indicate an acknowledgment that confirms the reception of <cite>D(x,…)</cite>. The sequence number is encoded as a bit string of fixed length. The simplest reliable protocol is the Alternating Bit Protocol (ABP).</p>
</section>
<section id="the-alternating-bit-protocol">
<h3>The Alternating Bit Protocol<a class="headerlink" href="#the-alternating-bit-protocol" title="Link to this heading">#</a></h3>
<p id="index-1">The Alternating Bit Protocol uses a single bit to encode the sequence number. It can be implemented easily. The sender (resp. the receiver) only require a four-state (resp. three-state) Finite State Machine. The sender FSM is represented in <a class="reference internal" href="#fig-abp-sender-fsm"><span class="std std-numref">Fig. 48</span></a> and the receiver FSM in <a class="reference internal" href="#fig-abp-receiver-fsm"><span class="std std-numref">Fig. 49</span></a>.</p>
<blockquote>
<div><div class="figure" id="id14" style="text-align: center">
<span id="fig-abp-sender-fsm"/><p><img src="../Images/8fbe25275e0fee019961c542919ef49b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f9f966f98d52abe87618f3d261ac6aa2b4d8eb8a.png"/></p>
<p><span class="caption-number">Fig. 48 </span><span class="caption-text">Alternating bit protocol: Sender FSM</span></p>
</div></div></blockquote>
<p>The initial state of the sender is <cite>Wait for D(0,…)</cite>. In this state, the sender waits for a <cite>Data.request</cite>. The first data segment that it sends uses sequence number <cite>0</cite>. After having sent this segment, the sender waits for an <cite>OK0</cite> acknowledgment. A data segment is retransmitted upon expiration of the retransmission timer or if an acknowledgment with an incorrect sequence number has been received.</p>
<p>The receiver first waits for <cite>D(0,…)</cite>. If the segment contains a correct <cite>CRC</cite>, it passes the SDU to its user and sends <cite>OK0</cite>. If the segment contains an invalid CRC, it is immediately discarded. Then, the receiver waits for <cite>D(1,…)</cite>. In this state, it may receive a duplicate <cite>D(0,…)</cite> or a data segment with an invalid CRC. In both cases, it returns an <cite>OK0</cite> segment to allow the sender to recover from the possible loss of the previous <cite>OK0</cite> segment.</p>
<blockquote>
<div><div class="figure" id="id15" style="text-align: center">
<span id="fig-abp-receiver-fsm"/><p><img src="../Images/3badb5e30f18cd10794dafd6f023ac28.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-21edc21ac4b15b1453fccde6b2baa11282421518.png"/></p>
<p><span class="caption-number">Fig. 49 </span><span class="caption-text">Alternating bit protocol: Receiver FSM</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Corrupted segments must be discarded</p>
<p>The receiver FSM of the Alternating bit protocol discards all segments that contain an invalid CRC. This is the safest approach since the received segment can be completely different from the one sent by the remote host. A receiver should not attempt at extracting information from a corrupted segment because it cannot know which portion of the segment has been affected by the error.</p>
</div>
<p>The figure below illustrates the operation of the Alternating Bit Protocol.</p>
<p class="mscgen">
<img src="../Images/58f29e8a1f0f64da47ef83b069805c78.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ];&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(c)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,c)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(c)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#2c052a1ec8a41f0cf029c367729c8d20af36fdcb" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-2c052a1ec8a41f0cf029c367729c8d20af36fdcb.png"/>
<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb" name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"/></p>
<p>The Alternating Bit Protocol can recover from the losses of data or control segments. This is illustrated in the two figures below. The first figure shows the loss of one data segment.</p>
<p class="mscgen">
<img src="../Images/f662cc9a0b114455fe7ce91316c8aedb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b-x c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;, linecolour=red];&#10;|||;&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#bac0f438a0b77b3de1b32b1118113f68e2fccc68" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-bac0f438a0b77b3de1b32b1118113f68e2fccc68.png"/>
<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68" name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"/></p>
<p>The second figure illustrates how the hosts handle the loss of one control segment.</p>
<p class="mscgen">
<img src="../Images/3bcb6de20e7b816c3750de577d1012cc.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c-x b [label= &quot;C(OK1)&quot;, linecolour=red, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;Duplicate segment\nignored&quot;, textcolour=red, linecolour=white ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#b3f33d8c62d1ddf01981ca22f5934f5160bb7b73" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b3f33d8c62d1ddf01981ca22f5934f5160bb7b73.png"/>
<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73" name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"/></p>
<p>The Alternating Bit Protocol can recover from transmission errors and segment losses. However, it has one important drawback. Consider two hosts that are directly connected by a 50 Kbits/sec satellite link that has a 250 milliseconds propagation delay. If these hosts send 1000 bits segments, then the maximum throughput that can be achieved by the alternating bit protocol is one segment every <span class="math notranslate nohighlight">\(20+250+250=520\)</span> milliseconds if we ignore the transmission time of the acknowledgment. This is less than 2 Kbits/sec !</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        </section>
<section id="go-back-n-and-selective-repeat">
<h3>Go-back-n and selective repeat<a class="headerlink" href="#go-back-n-and-selective-repeat" title="Link to this heading">#</a></h3>
<p>To overcome the performance limitations of the alternating bit protocol, reliable protocols rely on <cite>pipelining</cite> shown in <a class="reference internal" href="#fig-pipelining"><span class="std std-numref">Fig. 50</span></a>. This technique allows a sender to transmit several consecutive segments without being forced to wait for an acknowledgment after each segment. Each data segment contains a sequence number encoded as an <cite>n</cite> bits field.</p>
<figure class="align-center" id="fig-pipelining">
<a class="reference internal image-reference" href="../_images/pipelining2.png"><img alt="../_images/pipelining2.png" src="../Images/673705ddb7a242862f06d67fd8c2c097.png" style="width: 497.7px; height: 210.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/pipelining2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text">Pipelining improves the performance of reliable protocols</span><a class="headerlink" href="#fig-pipelining" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p><cite>Pipelining</cite> allows the sender to transmit segments at a higher rate. However this higher transmission rate may overload the receiver. In this case, the segments sent by the sender will not be correctly received by their final destination. The reliable protocols that rely on pipelining allow the sender to transmit <cite>W</cite> unacknowledged segments before being forced to wait for an acknowledgment from the receiving entity.</p>
<p>This is implemented by using a <cite>sliding window</cite>. The sliding window is the set of consecutive sequence numbers that the sender can use when transmitting segments without being forced to wait for an acknowledgment. <a class="reference internal" href="#fig-sliding-win"><span class="std std-numref">Fig. 51</span></a> shows a sliding window containing five segments (<cite>6,7,8,9</cite> and <cite>10</cite>). Two of these sequence numbers (<cite>6</cite> and <cite>7</cite>) have been used to send segments and only three sequence numbers (<cite>8</cite>, <cite>9</cite> and <cite>10</cite>) remain in the sliding window. The sliding window is said to be closed once all sequence numbers contained in the sliding window have been used.</p>
<figure class="align-center" id="id16">
<span id="fig-sliding-win"/><a class="reference internal image-reference" href="../_images/slidingwin2.png"><img alt="../_images/slidingwin2.png" src="../Images/cff43484e462b0df38ba215dd67e6922.png" style="width: 498.0px; height: 125.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/slidingwin2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 51 </span><span class="caption-text">The sliding window</span><a class="headerlink" href="#id16" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-sliding-win-ex"><span class="std std-numref">Fig. 52</span></a> illustrates the operation of the sliding window. It uses a sliding window of three segments. The sender can thus transmit three segments before being forced to wait for an acknowledgment. The sliding window moves to the higher sequence numbers upon the reception of each acknowledgment. When the first acknowledgment (<cite>OK0</cite>) is received, it enables the sender to move its sliding window to the right and sequence number <cite>3</cite> becomes available. This sequence number is used later to transmit the segment containing <cite>d</cite>.</p>
<figure class="align-center" id="id17">
<span id="fig-sliding-win-ex"/><a class="reference internal image-reference" href="../_images/gbnwin.png"><img alt="../_images/gbnwin.png" src="../Images/b5fde7825c12c07ce8b77cc1e5f37556.png" style="width: 432.0px; height: 357.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnwin.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 52 </span><span class="caption-text">Sliding window example</span><a class="headerlink" href="#id17" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In practice, as the segment header includes an <cite>n</cite> bits field to encode the sequence number, only the sequence numbers between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{n}-1\)</span> can be used. This implies that, during a long transfer, the same sequence number will be used for different segments and the sliding window will wrap. This is illustrated in <a class="reference internal" href="#fig-sliding-win-modulo"><span class="std std-numref">Fig. 53</span></a> assuming that <cite>2</cite> bits are used to encode the sequence number in the segment header. Note that upon reception of <cite>OK1</cite>, the sender slides its window and can use sequence number <cite>0</cite> again.</p>
<figure class="align-center" id="id18">
<span id="fig-sliding-win-modulo"/><a class="reference internal image-reference" href="../_images/gbnwinex.png"><img alt="../_images/gbnwinex.png" src="../Images/0ef78f3981c477d103876d2f7358bdd3.png" style="width: 433.2px; height: 357.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnwinex.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 53 </span><span class="caption-text">Utilization of the sliding window with modulo arithmetic</span><a class="headerlink" href="#id18" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-2">Unfortunately, segment losses do not disappear because a reliable protocol uses a sliding window. To recover from losses, a sliding window protocol must define :</p>
<blockquote>
<div><ul class="simple">
<li><p>a heuristic to detect losses</p></li>
<li><p>a <cite>retransmission strategy</cite> to retransmit the lost segments</p></li>
</ul>
</div></blockquote>
<p id="index-3">The simplest sliding window protocol uses the <cite>go-back-n</cite> recovery. Intuitively, <cite>go-back-n</cite> operates as follows. A <cite>go-back-n</cite> receiver is as simple as possible. It only accepts the segments that arrive in-sequence. A <cite>go-back-n</cite> receiver discards any out-of-sequence segment that it receives. When <cite>go-back-n</cite> receives a data segment, it always returns an acknowledgment containing the sequence number of the last in-sequence segment that it has received. This acknowledgment is said to be <cite>cumulative</cite>. When a <cite>go-back-n</cite> receiver sends an acknowledgment for sequence number <cite>x</cite>, it implicitly acknowledges the reception of all segments whose sequence number is earlier than <cite>x</cite>. A key advantage of these cumulative acknowledgments is that it is easy to recover from the loss of an acknowledgment. Consider for example a <cite>go-back-n</cite> receiver that received segments <cite>1</cite>, <cite>2</cite> and <cite>3</cite>. It sent <cite>OK1</cite>, <cite>OK2</cite> and <cite>OK3</cite>. Unfortunately, <cite>OK1</cite> and <cite>OK2</cite> were lost. Thanks to the cumulative acknowledgments, when the sender receives <cite>OK3</cite>, it knows that all three segments have been correctly received.</p>
<p><a class="reference internal" href="#fig-fsm-gbn-receiver"><span class="std std-numref">Fig. 54</span></a> shows the FSM of a simple <cite>go-back-n</cite> receiver. This receiver uses two variables : <cite>lastack</cite> and <cite>next</cite>. <cite>next</cite> is the next expected sequence number and <cite>lastack</cite> the sequence number of the last data segment that has been acknowledged. The receiver only accepts the segments that are received in sequence. <cite>maxseq</cite> is the number of different sequence numbers (<span class="math notranslate nohighlight">\(2^n\)</span>).</p>
<blockquote>
<div><div class="figure" id="id19" style="text-align: center">
<span id="fig-fsm-gbn-receiver"/><p><img src="../Images/129311f9bf007c55636d82806ff9a8ec.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f98d257aa4020916a507e4086b4595bc49d52508.png"/></p>
<p><span class="caption-number">Fig. 54 </span><span class="caption-text">Go-back-n: receiver FSM</span></p>
</div></div></blockquote>
<p>A <cite>go-back-n</cite> sender is also very simple as shown in <a class="reference internal" href="#fig-fsm-gbn-sender"><span class="std std-numref">Fig. 55</span></a>. It uses a sending buffer that can store an entire sliding window of segments <a class="footnote-reference brackets" href="#fsizesliding" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. The segments are sent with increasing sequence numbers (modulo <cite>maxseq</cite>). The sender must wait for an acknowledgment once its sending buffer is full. When a <cite>go-back-n</cite> sender receives an acknowledgment, it removes from the sending buffer all the acknowledged segments and uses a retransmission timer to detect segment losses. A simple <cite>go-back-n</cite> sender maintains one retransmission timer per connection. This timer is started when the first segment is sent. When the <cite>go-back-n sender</cite> receives an acknowledgment, it restarts the retransmission timer only if there are still unacknowledged segments in its sending buffer. When the retransmission timer expires, the <cite>go-back-n</cite> sender assumes that all the unacknowledged segments currently stored in its sending buffer have been lost. It thus retransmits all the unacknowledged segments in the buffer and restarts its retransmission timer.</p>
<blockquote>
<div><div class="figure" id="id20" style="text-align: center">
<span id="fig-fsm-gbn-sender"/><p><img src="../Images/86718f7fdab6919b9def71253750e50a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-9fc242d37f5554e34824b6c8ee7220937fbf0ca0.png"/></p>
<p><span class="caption-number">Fig. 55 </span><span class="caption-text">Go-back-n: sender FSM</span></p>
</div></div></blockquote>
<p>The operation of <cite>go-back-n</cite> is illustrated in <a class="reference internal" href="#fig-gbn-example"><span class="std std-numref">Fig. 56</span></a>. In this figure, note that upon reception of the out-of-sequence segment <cite>D(2,c)</cite>, the receiver returns a cumulative acknowledgment <cite>C(OK,0)</cite> that acknowledges all the segments that have been received in sequence. The lost segment is retransmitted upon the expiration of the retransmission timer.</p>
<figure class="align-center" id="id21">
<span id="fig-gbn-example"/><a class="reference internal image-reference" href="../_images/gbnex2.png"><img alt="../_images/gbnex2.png" src="../Images/7c58d5fa667aca0d9275af765599720a.png" style="width: 513.8px; height: 289.79999999999995px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnex2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 56 </span><span class="caption-text">Go-back-n : example</span><a class="headerlink" href="#id21" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The main advantage of <cite>go-back-n</cite> is that it can be easily implemented, and it can also provide good performance when only a few segments are lost. However, when there are many losses, the performance of <cite>go-back-n</cite> quickly drops for two reasons :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>go-back-n</cite> receiver does not accept out-of-sequence segments</p></li>
<li><p>the <cite>go-back-n</cite> sender retransmits all unacknowledged segments once it has detected a loss</p></li>
</ul>
</div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p id="index-4"><cite>Selective repeat</cite> is a better strategy to recover from losses. Intuitively, <cite>selective repeat</cite> allows the receiver to accept out-of-sequence segments. Furthermore, when a <cite>selective repeat</cite> sender detects losses, it only retransmits the segments that have been lost and not the segments that have already been correctly received.</p>
<p>A <cite>selective repeat</cite> receiver maintains a sliding window of <cite>W</cite> segments and stores in a buffer the out-of-sequence segments that it receives. <a class="reference internal" href="#fig-sr-rwin"><span class="std std-numref">Fig. 57</span></a> shows a five-segment receive window on a receiver that has already received segments <cite>7</cite> and <cite>9</cite>.</p>
<figure class="align-center" id="id22">
<span id="fig-sr-rwin"/><a class="reference internal image-reference" href="../_images/selrepeatwin2.png"><img alt="../_images/selrepeatwin2.png" src="../Images/65c1ca27e931f581cf93b7c9874c2977.png" style="width: 521.5px; height: 58.099999999999994px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/selrepeatwin2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">The receiving window with selective repeat</span><a class="headerlink" href="#id22" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>A <cite>selective repeat</cite> receiver discards all segments having an invalid CRC, and maintains the variable <cite>lastack</cite> as the sequence number of the last in-sequence segment that it has received. The receiver always includes the value of <cite>lastack</cite> in the acknowledgments that it sends. Some protocols also allow the <cite>selective repeat</cite> receiver to acknowledge the out-of-sequence segments that it has received. This can be done for example by placing the list of the correctly received, but out-of-sequence segments in the acknowledgments together with the <cite>lastack</cite> value.</p>
<p>When a <cite>selective repeat</cite> receiver receives a data segment, it first verifies whether the segment is inside its receiving window. If yes, the segment is placed in the receive buffer. If not, the received segment is discarded and an acknowledgment containing <cite>lastack</cite> is sent to the sender. The receiver then removes all consecutive segments starting at <cite>lastack</cite> (if any) from the receive buffer. The payloads of these segments are delivered to the user, <cite>lastack</cite> and the receiving window are updated, and an acknowledgment acknowledging the last segment received in sequence is sent.</p>
<p>The <cite>selective repeat</cite> sender maintains a sending buffer that can store up to <cite>W</cite> unacknowledged segments. These segments are sent as long as the sending buffer is not full. Several implementations of a <cite>selective repeat</cite> sender are possible. A simple implementation associates one retransmission timer to each segment. The timer is started when the segment is sent and canceled upon reception of an acknowledgment that covers this segment. When a retransmission timer expires, the corresponding segment is retransmitted and this retransmission timer is restarted. When an acknowledgment is received, all the segments that are covered by this acknowledgment are removed from the sending buffer and the sliding window is updated.</p>
<p><a class="reference internal" href="#fig-sr-example"><span class="std std-numref">Fig. 58</span></a> illustrates the operation of <cite>selective repeat</cite> when segments are lost. In this figure, <cite>C(OK,x)</cite> is used to indicate that all segments, up to and including sequence number <cite>x</cite> have been received correctly.</p>
<figure class="align-center" id="id23">
<span id="fig-sr-example"/><a class="reference internal image-reference" href="../_images/selrepeat.png"><img alt="../_images/selrepeat.png" src="../Images/5146331e8d7c7c36361e7fc92750fb1a.png" style="width: 525.0px; height: 416.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/selrepeat.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 58 </span><span class="caption-text">Selective repeat : example</span><a class="headerlink" href="#id23" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-5">Pure cumulative acknowledgments work well with the <cite>go-back-n</cite> strategy. However, with only cumulative acknowledgments a <cite>selective repeat</cite> sender cannot easily determine which segments have been correctly received after a data segment has been lost. For example, in the figure above, the second <cite>C(OK,0)</cite> does not inform explicitly the sender of the reception of <cite>D(2,c)</cite> and the sender could retransmit this segment although it has already been received. A possible solution to improve the performance of <cite>selective repeat</cite> is to provide additional information about the received segments in the acknowledgments that are returned by the receiver. For example, the receiver could add in the returned acknowledgment the list of the sequence numbers of all segments that have already been received. Such acknowledgments are sometimes called <cite>selective acknowledgments</cite>. We will provide examples of such acknowledgments in the TCP and QUIC protocols later in this book.</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <div class="admonition note">
<p class="admonition-title">Note</p>
<p>Maximum window size with <cite>go-back-n</cite> and <cite>selective repeat</cite></p>
<p>A reliable protocol that uses <cite>n</cite> bits to encode its sequence number can send up to <span class="math notranslate nohighlight">\(2^n\)</span> successive segments. However, to ensure a reliable delivery of the segments, <cite>go-back-n</cite> and <cite>selective repeat</cite> cannot use a sending window of <span class="math notranslate nohighlight">\(2^n\)</span> segments.
Consider first <cite>go-back-n</cite> and assume that a sender sends <span class="math notranslate nohighlight">\(2^n\)</span> segments. These segments are received in-sequence by the destination, but all the returned acknowledgments are lost. The sender will retransmit all segments. These segments will all be accepted by the receiver and delivered a second time to the user. It is easy to see that this problem can be avoided if the maximum size of the sending window is <span class="math notranslate nohighlight">\({2^n}-1\)</span> segments.
A similar problem occurs with <cite>selective repeat</cite>. However, as the receiver accepts out-of-sequence segments, a sending window of <span class="math notranslate nohighlight">\({2^n}-1\)</span> segments is not sufficient to ensure a reliable delivery. It can be easily shown that to avoid this problem, a <cite>selective repeat</cite> sender cannot use a window that is larger than <span class="math notranslate nohighlight">\(\frac{2^n}{2}\)</span> segments.</p>
</div>
<span class="target" id="index-6"/><span class="target" id="index-7"/><p id="index-8">Reliable protocols often need to send data in both directions. To reduce the overhead caused by the acknowledgments, most reliable protocols use <cite>piggybacking</cite>. Thanks to this technique, an entity can place the acknowledgments and the receive window that it advertises for the opposite direction of the data flow inside the header of the data segments that it sends. The main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgment. This is illustrated in the figure below where the acknowledgment number is underlined in the data segments. Piggybacking is only used when data flows in both directions. A receiver will generate a pure acknowledgment when it does not send data in the opposite direction as shown in the bottom of the figure.</p>
<figure class="align-center" id="id24">
<a class="reference internal image-reference" href="../_images/piggyback2.png"><img alt="../_images/piggyback2.png" src="../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png" style="width: 506.09999999999997px; height: 326.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/piggyback2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 59 </span><span class="caption-text">Piggybacking example</span><a class="headerlink" href="#id24" title="Link to this image">#</a></p>
</figcaption>
</figure>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        </section>
&#13;

<h3>Reliable transfer above an imperfect link<a class="headerlink" href="#reliable-transfer-above-an-imperfect-link" title="Link to this heading">#</a></h3>
<p>The transport layer must deal with several types of errors which can affect the segments that it sends. In practice, we mainly have to deal with two types of errors in the transport layer :</p>
<blockquote>
<div><ul class="simple">
<li><p>Segments can be corrupted by transmission errors</p></li>
<li><p>Segments can be lost or unexpected segments can appear</p></li>
</ul>
</div></blockquote>
<p>To detect errors, a segment is usually divided into two parts :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>header</cite> that contains the fields used by the reliable protocol to ensure reliable delivery. The header contains a checksum or Cyclical Redundancy Check (CRC) <a class="reference internal" href="../bibliography.html#williams1993" id="id2"><span>[Williams1993]</span></a> that is used to detect transmission errors</p></li>
<li><p>a <cite>payload</cite> that contains the user data</p></li>
</ul>
</div></blockquote>
<p>Some headers also include a <cite>length</cite> field, which indicates the total length of the segment or the length of the payload.</p>
<p>The simplest error detection scheme is the checksum. A checksum is basically an arithmetic sum of all the bytes that a segment is composed of. There are different types of checksums. For example, an eight bit checksum can be computed as the arithmetic sum of all the bytes of (both the header and trailer of) the segment. The checksum is computed by the sender before sending the segment and the receiver verifies the checksum upon segment reception. The receiver discards segments received with an invalid checksum. Checksums can be easily implemented in software, but their error detection capabilities are limited. Cyclical Redundancy Checks (CRC) have better error detection capabilities <a class="reference internal" href="../bibliography.html#sgp98" id="id3"><span>[SGP98]</span></a>, but require more CPU when implemented in software.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Checksums, CRCs,…</p>
<p>Most of the protocols in the TCP/IP protocol suite rely on the simple Internet checksum in order to verify that a received packet has not been affected by transmission errors. Despite its popularity and ease of implementation, the Internet checksum is not the only available checksum mechanism. Cyclical Redundancy Checks (<a class="reference external" href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>) are very powerful error detection schemes that are used notably on disks, by many datalink layer protocols and file formats such as <code class="docutils literal notranslate"><span class="pre">zip</span></code> or <code class="docutils literal notranslate"><span class="pre">png</span></code>. They can easily be implemented efficiently in hardware and have better error-detection capabilities than the Internet checksum <a class="reference internal" href="../bibliography.html#sgp98" id="id4"><span>[SGP98]</span></a> . However, CRCs are sometimes considered to be too CPU-intensive for software implementations and other checksum mechanisms are preferred. The TCP/IP community chose the Internet checksum, the OSI community chose the Fletcher checksum <a class="reference internal" href="../bibliography.html#sklower89" id="id5"><span>[Sklower89]</span></a>. Nowadays there are efficient techniques to quickly compute CRCs in software <a class="reference internal" href="../bibliography.html#feldmeier95" id="id6"><span>[Feldmeier95]</span></a>.</p>
</div>
<p>Since the receiver sends an acknowledgment after having received each data segment, the simplest solution to deal with losses is to use a retransmission timer. When the sender sends a segment, it starts a retransmission timer. The duration of this retransmission timer should be larger than the <cite>round-trip-time</cite>, i.e. the delay between the transmission of a data segment and the reception of the corresponding acknowledgment. When the retransmission timer expires, the sender assumes that the data segment has been lost and retransmits it. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/eb3e128faed868520ea345c4171d9007.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b-x c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;, linecolour=red];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#8057bc41346c284d032cdac99ea8cefe6d4cb0d6" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-8057bc41346c284d032cdac99ea8cefe6d4cb0d6.png"/>
<map id="8057bc41346c284d032cdac99ea8cefe6d4cb0d6" name="8057bc41346c284d032cdac99ea8cefe6d4cb0d6"/></p>
</div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p>Unfortunately, retransmission timers alone are not sufficient to recover from losses. Let us consider, as an example, the situation depicted below where an acknowledgment is lost. In this case, the sender retransmits the data segment that has not been acknowledged. However, as illustrated in the figure below, the receiver considers the retransmission as a new segment whose payload must be delivered to its user.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/f31aca9d4a56211a006ee59b4bbd6581.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c-x b [label= &quot;C(OK)&quot;, linecolour=red, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b) !!!!!&quot;, linecolour=red ];&#10;c&gt;&gt;b [label= &quot;C(OK)&quot;, arcskip=&quot;1&quot;];&#10;|||;&#10;}" usemap="#34c7c055da8716230ba3f29574fb761575e3d9f5" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-34c7c055da8716230ba3f29574fb761575e3d9f5.png"/>
<map id="34c7c055da8716230ba3f29574fb761575e3d9f5" name="34c7c055da8716230ba3f29574fb761575e3d9f5"/></p>
</div></blockquote>
<p id="index-0">To solve this problem, reliable protocols associate a <cite>sequence number</cite> to each data segment. This <cite>sequence number</cite> is one of the fields found in the header of data segments. We use the notation <cite>D(x,…)</cite> to indicate a data segment whose sequence number field is set to value <cite>x</cite>. The acknowledgments also contain a sequence number indicating the data segments that it acknowledges. We use <cite>OKx</cite> to indicate an acknowledgment that confirms the reception of <cite>D(x,…)</cite>. The sequence number is encoded as a bit string of fixed length. The simplest reliable protocol is the Alternating Bit Protocol (ABP).</p>
&#13;

<h3>The Alternating Bit Protocol<a class="headerlink" href="#the-alternating-bit-protocol" title="Link to this heading">#</a></h3>
<p id="index-1">The Alternating Bit Protocol uses a single bit to encode the sequence number. It can be implemented easily. The sender (resp. the receiver) only require a four-state (resp. three-state) Finite State Machine. The sender FSM is represented in <a class="reference internal" href="#fig-abp-sender-fsm"><span class="std std-numref">Fig. 48</span></a> and the receiver FSM in <a class="reference internal" href="#fig-abp-receiver-fsm"><span class="std std-numref">Fig. 49</span></a>.</p>
<blockquote>
<div><div class="figure" id="id14" style="text-align: center">
<span id="fig-abp-sender-fsm"/><p><img src="../Images/8fbe25275e0fee019961c542919ef49b.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f9f966f98d52abe87618f3d261ac6aa2b4d8eb8a.png"/></p>
<p><span class="caption-number">Fig. 48 </span><span class="caption-text">Alternating bit protocol: Sender FSM</span></p>
</div></div></blockquote>
<p>The initial state of the sender is <cite>Wait for D(0,…)</cite>. In this state, the sender waits for a <cite>Data.request</cite>. The first data segment that it sends uses sequence number <cite>0</cite>. After having sent this segment, the sender waits for an <cite>OK0</cite> acknowledgment. A data segment is retransmitted upon expiration of the retransmission timer or if an acknowledgment with an incorrect sequence number has been received.</p>
<p>The receiver first waits for <cite>D(0,…)</cite>. If the segment contains a correct <cite>CRC</cite>, it passes the SDU to its user and sends <cite>OK0</cite>. If the segment contains an invalid CRC, it is immediately discarded. Then, the receiver waits for <cite>D(1,…)</cite>. In this state, it may receive a duplicate <cite>D(0,…)</cite> or a data segment with an invalid CRC. In both cases, it returns an <cite>OK0</cite> segment to allow the sender to recover from the possible loss of the previous <cite>OK0</cite> segment.</p>
<blockquote>
<div><div class="figure" id="id15" style="text-align: center">
<span id="fig-abp-receiver-fsm"/><p><img src="../Images/3badb5e30f18cd10794dafd6f023ac28.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-21edc21ac4b15b1453fccde6b2baa11282421518.png"/></p>
<p><span class="caption-number">Fig. 49 </span><span class="caption-text">Alternating bit protocol: Receiver FSM</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Corrupted segments must be discarded</p>
<p>The receiver FSM of the Alternating bit protocol discards all segments that contain an invalid CRC. This is the safest approach since the received segment can be completely different from the one sent by the remote host. A receiver should not attempt at extracting information from a corrupted segment because it cannot know which portion of the segment has been affected by the error.</p>
</div>
<p>The figure below illustrates the operation of the Alternating Bit Protocol.</p>
<p class="mscgen">
<img src="../Images/58f29e8a1f0f64da47ef83b069805c78.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ];&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(c)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,c)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(c)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#2c052a1ec8a41f0cf029c367729c8d20af36fdcb" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-2c052a1ec8a41f0cf029c367729c8d20af36fdcb.png"/>
<map id="2c052a1ec8a41f0cf029c367729c8d20af36fdcb" name="2c052a1ec8a41f0cf029c367729c8d20af36fdcb"/></p>
<p>The Alternating Bit Protocol can recover from the losses of data or control segments. This is illustrated in the two figures below. The first figure shows the loss of one data segment.</p>
<p class="mscgen">
<img src="../Images/f662cc9a0b114455fe7ce91316c8aedb.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b-x c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;, linecolour=red];&#10;|||;&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#bac0f438a0b77b3de1b32b1118113f68e2fccc68" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-bac0f438a0b77b3de1b32b1118113f68e2fccc68.png"/>
<map id="bac0f438a0b77b3de1b32b1118113f68e2fccc68" name="bac0f438a0b77b3de1b32b1118113f68e2fccc68"/></p>
<p>The second figure illustrates how the hosts handle the loss of one control segment.</p>
<p class="mscgen">
<img src="../Images/3bcb6de20e7b816c3750de577d1012cc.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(a)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(0,a)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(a)&quot; ];&#10;c&gt;&gt;b [label= &quot;C(OK0)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(b)\nstart timer&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;DATA.ind(b)&quot; ];&#10;c-x b [label= &quot;C(OK1)&quot;, linecolour=red, arcskip=&quot;1&quot;];&#10;|||;&#10;a=&gt;b [ linecolour=white, label = &quot;timer expires&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;D(1,b)&quot;, arcskip=&quot;1&quot;];&#10;c=&gt;d [ label = &quot;Duplicate segment\nignored&quot;, textcolour=red, linecolour=white ];&#10;c&gt;&gt;b [label= &quot;C(OK1)&quot;, arcskip=&quot;1&quot;];&#10;b-&gt;a [linecolour=white, label=&quot;cancel timer&quot;];&#10;|||;&#10;}" usemap="#b3f33d8c62d1ddf01981ca22f5934f5160bb7b73" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b3f33d8c62d1ddf01981ca22f5934f5160bb7b73.png"/>
<map id="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73" name="b3f33d8c62d1ddf01981ca22f5934f5160bb7b73"/></p>
<p>The Alternating Bit Protocol can recover from transmission errors and segment losses. However, it has one important drawback. Consider two hosts that are directly connected by a 50 Kbits/sec satellite link that has a 250 milliseconds propagation delay. If these hosts send 1000 bits segments, then the maximum throughput that can be achieved by the alternating bit protocol is one segment every <span class="math notranslate nohighlight">\(20+250+250=520\)</span> milliseconds if we ignore the transmission time of the acknowledgment. This is less than 2 Kbits/sec !</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        &#13;

<h3>Go-back-n and selective repeat<a class="headerlink" href="#go-back-n-and-selective-repeat" title="Link to this heading">#</a></h3>
<p>To overcome the performance limitations of the alternating bit protocol, reliable protocols rely on <cite>pipelining</cite> shown in <a class="reference internal" href="#fig-pipelining"><span class="std std-numref">Fig. 50</span></a>. This technique allows a sender to transmit several consecutive segments without being forced to wait for an acknowledgment after each segment. Each data segment contains a sequence number encoded as an <cite>n</cite> bits field.</p>
<figure class="align-center" id="fig-pipelining">
<a class="reference internal image-reference" href="../_images/pipelining2.png"><img alt="../_images/pipelining2.png" src="../Images/673705ddb7a242862f06d67fd8c2c097.png" style="width: 497.7px; height: 210.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/pipelining2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text">Pipelining improves the performance of reliable protocols</span><a class="headerlink" href="#fig-pipelining" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p><cite>Pipelining</cite> allows the sender to transmit segments at a higher rate. However this higher transmission rate may overload the receiver. In this case, the segments sent by the sender will not be correctly received by their final destination. The reliable protocols that rely on pipelining allow the sender to transmit <cite>W</cite> unacknowledged segments before being forced to wait for an acknowledgment from the receiving entity.</p>
<p>This is implemented by using a <cite>sliding window</cite>. The sliding window is the set of consecutive sequence numbers that the sender can use when transmitting segments without being forced to wait for an acknowledgment. <a class="reference internal" href="#fig-sliding-win"><span class="std std-numref">Fig. 51</span></a> shows a sliding window containing five segments (<cite>6,7,8,9</cite> and <cite>10</cite>). Two of these sequence numbers (<cite>6</cite> and <cite>7</cite>) have been used to send segments and only three sequence numbers (<cite>8</cite>, <cite>9</cite> and <cite>10</cite>) remain in the sliding window. The sliding window is said to be closed once all sequence numbers contained in the sliding window have been used.</p>
<figure class="align-center" id="id16">
<span id="fig-sliding-win"/><a class="reference internal image-reference" href="../_images/slidingwin2.png"><img alt="../_images/slidingwin2.png" src="../Images/cff43484e462b0df38ba215dd67e6922.png" style="width: 498.0px; height: 125.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/slidingwin2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 51 </span><span class="caption-text">The sliding window</span><a class="headerlink" href="#id16" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-sliding-win-ex"><span class="std std-numref">Fig. 52</span></a> illustrates the operation of the sliding window. It uses a sliding window of three segments. The sender can thus transmit three segments before being forced to wait for an acknowledgment. The sliding window moves to the higher sequence numbers upon the reception of each acknowledgment. When the first acknowledgment (<cite>OK0</cite>) is received, it enables the sender to move its sliding window to the right and sequence number <cite>3</cite> becomes available. This sequence number is used later to transmit the segment containing <cite>d</cite>.</p>
<figure class="align-center" id="id17">
<span id="fig-sliding-win-ex"/><a class="reference internal image-reference" href="../_images/gbnwin.png"><img alt="../_images/gbnwin.png" src="../Images/b5fde7825c12c07ce8b77cc1e5f37556.png" style="width: 432.0px; height: 357.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnwin.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 52 </span><span class="caption-text">Sliding window example</span><a class="headerlink" href="#id17" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In practice, as the segment header includes an <cite>n</cite> bits field to encode the sequence number, only the sequence numbers between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{n}-1\)</span> can be used. This implies that, during a long transfer, the same sequence number will be used for different segments and the sliding window will wrap. This is illustrated in <a class="reference internal" href="#fig-sliding-win-modulo"><span class="std std-numref">Fig. 53</span></a> assuming that <cite>2</cite> bits are used to encode the sequence number in the segment header. Note that upon reception of <cite>OK1</cite>, the sender slides its window and can use sequence number <cite>0</cite> again.</p>
<figure class="align-center" id="id18">
<span id="fig-sliding-win-modulo"/><a class="reference internal image-reference" href="../_images/gbnwinex.png"><img alt="../_images/gbnwinex.png" src="../Images/0ef78f3981c477d103876d2f7358bdd3.png" style="width: 433.2px; height: 357.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnwinex.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 53 </span><span class="caption-text">Utilization of the sliding window with modulo arithmetic</span><a class="headerlink" href="#id18" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-2">Unfortunately, segment losses do not disappear because a reliable protocol uses a sliding window. To recover from losses, a sliding window protocol must define :</p>
<blockquote>
<div><ul class="simple">
<li><p>a heuristic to detect losses</p></li>
<li><p>a <cite>retransmission strategy</cite> to retransmit the lost segments</p></li>
</ul>
</div></blockquote>
<p id="index-3">The simplest sliding window protocol uses the <cite>go-back-n</cite> recovery. Intuitively, <cite>go-back-n</cite> operates as follows. A <cite>go-back-n</cite> receiver is as simple as possible. It only accepts the segments that arrive in-sequence. A <cite>go-back-n</cite> receiver discards any out-of-sequence segment that it receives. When <cite>go-back-n</cite> receives a data segment, it always returns an acknowledgment containing the sequence number of the last in-sequence segment that it has received. This acknowledgment is said to be <cite>cumulative</cite>. When a <cite>go-back-n</cite> receiver sends an acknowledgment for sequence number <cite>x</cite>, it implicitly acknowledges the reception of all segments whose sequence number is earlier than <cite>x</cite>. A key advantage of these cumulative acknowledgments is that it is easy to recover from the loss of an acknowledgment. Consider for example a <cite>go-back-n</cite> receiver that received segments <cite>1</cite>, <cite>2</cite> and <cite>3</cite>. It sent <cite>OK1</cite>, <cite>OK2</cite> and <cite>OK3</cite>. Unfortunately, <cite>OK1</cite> and <cite>OK2</cite> were lost. Thanks to the cumulative acknowledgments, when the sender receives <cite>OK3</cite>, it knows that all three segments have been correctly received.</p>
<p><a class="reference internal" href="#fig-fsm-gbn-receiver"><span class="std std-numref">Fig. 54</span></a> shows the FSM of a simple <cite>go-back-n</cite> receiver. This receiver uses two variables : <cite>lastack</cite> and <cite>next</cite>. <cite>next</cite> is the next expected sequence number and <cite>lastack</cite> the sequence number of the last data segment that has been acknowledged. The receiver only accepts the segments that are received in sequence. <cite>maxseq</cite> is the number of different sequence numbers (<span class="math notranslate nohighlight">\(2^n\)</span>).</p>
<blockquote>
<div><div class="figure" id="id19" style="text-align: center">
<span id="fig-fsm-gbn-receiver"/><p><img src="../Images/129311f9bf007c55636d82806ff9a8ec.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f98d257aa4020916a507e4086b4595bc49d52508.png"/></p>
<p><span class="caption-number">Fig. 54 </span><span class="caption-text">Go-back-n: receiver FSM</span></p>
</div></div></blockquote>
<p>A <cite>go-back-n</cite> sender is also very simple as shown in <a class="reference internal" href="#fig-fsm-gbn-sender"><span class="std std-numref">Fig. 55</span></a>. It uses a sending buffer that can store an entire sliding window of segments <a class="footnote-reference brackets" href="#fsizesliding" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. The segments are sent with increasing sequence numbers (modulo <cite>maxseq</cite>). The sender must wait for an acknowledgment once its sending buffer is full. When a <cite>go-back-n</cite> sender receives an acknowledgment, it removes from the sending buffer all the acknowledged segments and uses a retransmission timer to detect segment losses. A simple <cite>go-back-n</cite> sender maintains one retransmission timer per connection. This timer is started when the first segment is sent. When the <cite>go-back-n sender</cite> receives an acknowledgment, it restarts the retransmission timer only if there are still unacknowledged segments in its sending buffer. When the retransmission timer expires, the <cite>go-back-n</cite> sender assumes that all the unacknowledged segments currently stored in its sending buffer have been lost. It thus retransmits all the unacknowledged segments in the buffer and restarts its retransmission timer.</p>
<blockquote>
<div><div class="figure" id="id20" style="text-align: center">
<span id="fig-fsm-gbn-sender"/><p><img src="../Images/86718f7fdab6919b9def71253750e50a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-9fc242d37f5554e34824b6c8ee7220937fbf0ca0.png"/></p>
<p><span class="caption-number">Fig. 55 </span><span class="caption-text">Go-back-n: sender FSM</span></p>
</div></div></blockquote>
<p>The operation of <cite>go-back-n</cite> is illustrated in <a class="reference internal" href="#fig-gbn-example"><span class="std std-numref">Fig. 56</span></a>. In this figure, note that upon reception of the out-of-sequence segment <cite>D(2,c)</cite>, the receiver returns a cumulative acknowledgment <cite>C(OK,0)</cite> that acknowledges all the segments that have been received in sequence. The lost segment is retransmitted upon the expiration of the retransmission timer.</p>
<figure class="align-center" id="id21">
<span id="fig-gbn-example"/><a class="reference internal image-reference" href="../_images/gbnex2.png"><img alt="../_images/gbnex2.png" src="../Images/7c58d5fa667aca0d9275af765599720a.png" style="width: 513.8px; height: 289.79999999999995px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/gbnex2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 56 </span><span class="caption-text">Go-back-n : example</span><a class="headerlink" href="#id21" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The main advantage of <cite>go-back-n</cite> is that it can be easily implemented, and it can also provide good performance when only a few segments are lost. However, when there are many losses, the performance of <cite>go-back-n</cite> quickly drops for two reasons :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>go-back-n</cite> receiver does not accept out-of-sequence segments</p></li>
<li><p>the <cite>go-back-n</cite> sender retransmits all unacknowledged segments once it has detected a loss</p></li>
</ul>
</div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p id="index-4"><cite>Selective repeat</cite> is a better strategy to recover from losses. Intuitively, <cite>selective repeat</cite> allows the receiver to accept out-of-sequence segments. Furthermore, when a <cite>selective repeat</cite> sender detects losses, it only retransmits the segments that have been lost and not the segments that have already been correctly received.</p>
<p>A <cite>selective repeat</cite> receiver maintains a sliding window of <cite>W</cite> segments and stores in a buffer the out-of-sequence segments that it receives. <a class="reference internal" href="#fig-sr-rwin"><span class="std std-numref">Fig. 57</span></a> shows a five-segment receive window on a receiver that has already received segments <cite>7</cite> and <cite>9</cite>.</p>
<figure class="align-center" id="id22">
<span id="fig-sr-rwin"/><a class="reference internal image-reference" href="../_images/selrepeatwin2.png"><img alt="../_images/selrepeatwin2.png" src="../Images/65c1ca27e931f581cf93b7c9874c2977.png" style="width: 521.5px; height: 58.099999999999994px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/selrepeatwin2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 57 </span><span class="caption-text">The receiving window with selective repeat</span><a class="headerlink" href="#id22" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>A <cite>selective repeat</cite> receiver discards all segments having an invalid CRC, and maintains the variable <cite>lastack</cite> as the sequence number of the last in-sequence segment that it has received. The receiver always includes the value of <cite>lastack</cite> in the acknowledgments that it sends. Some protocols also allow the <cite>selective repeat</cite> receiver to acknowledge the out-of-sequence segments that it has received. This can be done for example by placing the list of the correctly received, but out-of-sequence segments in the acknowledgments together with the <cite>lastack</cite> value.</p>
<p>When a <cite>selective repeat</cite> receiver receives a data segment, it first verifies whether the segment is inside its receiving window. If yes, the segment is placed in the receive buffer. If not, the received segment is discarded and an acknowledgment containing <cite>lastack</cite> is sent to the sender. The receiver then removes all consecutive segments starting at <cite>lastack</cite> (if any) from the receive buffer. The payloads of these segments are delivered to the user, <cite>lastack</cite> and the receiving window are updated, and an acknowledgment acknowledging the last segment received in sequence is sent.</p>
<p>The <cite>selective repeat</cite> sender maintains a sending buffer that can store up to <cite>W</cite> unacknowledged segments. These segments are sent as long as the sending buffer is not full. Several implementations of a <cite>selective repeat</cite> sender are possible. A simple implementation associates one retransmission timer to each segment. The timer is started when the segment is sent and canceled upon reception of an acknowledgment that covers this segment. When a retransmission timer expires, the corresponding segment is retransmitted and this retransmission timer is restarted. When an acknowledgment is received, all the segments that are covered by this acknowledgment are removed from the sending buffer and the sliding window is updated.</p>
<p><a class="reference internal" href="#fig-sr-example"><span class="std std-numref">Fig. 58</span></a> illustrates the operation of <cite>selective repeat</cite> when segments are lost. In this figure, <cite>C(OK,x)</cite> is used to indicate that all segments, up to and including sequence number <cite>x</cite> have been received correctly.</p>
<figure class="align-center" id="id23">
<span id="fig-sr-example"/><a class="reference internal image-reference" href="../_images/selrepeat.png"><img alt="../_images/selrepeat.png" src="../Images/5146331e8d7c7c36361e7fc92750fb1a.png" style="width: 525.0px; height: 416.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/selrepeat.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 58 </span><span class="caption-text">Selective repeat : example</span><a class="headerlink" href="#id23" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-5">Pure cumulative acknowledgments work well with the <cite>go-back-n</cite> strategy. However, with only cumulative acknowledgments a <cite>selective repeat</cite> sender cannot easily determine which segments have been correctly received after a data segment has been lost. For example, in the figure above, the second <cite>C(OK,0)</cite> does not inform explicitly the sender of the reception of <cite>D(2,c)</cite> and the sender could retransmit this segment although it has already been received. A possible solution to improve the performance of <cite>selective repeat</cite> is to provide additional information about the received segments in the acknowledgments that are returned by the receiver. For example, the receiver could add in the returned acknowledgment the list of the sequence numbers of all segments that have already been received. Such acknowledgments are sometimes called <cite>selective acknowledgments</cite>. We will provide examples of such acknowledgments in the TCP and QUIC protocols later in this book.</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <div class="admonition note">
<p class="admonition-title">Note</p>
<p>Maximum window size with <cite>go-back-n</cite> and <cite>selective repeat</cite></p>
<p>A reliable protocol that uses <cite>n</cite> bits to encode its sequence number can send up to <span class="math notranslate nohighlight">\(2^n\)</span> successive segments. However, to ensure a reliable delivery of the segments, <cite>go-back-n</cite> and <cite>selective repeat</cite> cannot use a sending window of <span class="math notranslate nohighlight">\(2^n\)</span> segments.
Consider first <cite>go-back-n</cite> and assume that a sender sends <span class="math notranslate nohighlight">\(2^n\)</span> segments. These segments are received in-sequence by the destination, but all the returned acknowledgments are lost. The sender will retransmit all segments. These segments will all be accepted by the receiver and delivered a second time to the user. It is easy to see that this problem can be avoided if the maximum size of the sending window is <span class="math notranslate nohighlight">\({2^n}-1\)</span> segments.
A similar problem occurs with <cite>selective repeat</cite>. However, as the receiver accepts out-of-sequence segments, a sending window of <span class="math notranslate nohighlight">\({2^n}-1\)</span> segments is not sufficient to ensure a reliable delivery. It can be easily shown that to avoid this problem, a <cite>selective repeat</cite> sender cannot use a window that is larger than <span class="math notranslate nohighlight">\(\frac{2^n}{2}\)</span> segments.</p>
</div>
<span class="target" id="index-6"/><span class="target" id="index-7"/><p id="index-8">Reliable protocols often need to send data in both directions. To reduce the overhead caused by the acknowledgments, most reliable protocols use <cite>piggybacking</cite>. Thanks to this technique, an entity can place the acknowledgments and the receive window that it advertises for the opposite direction of the data flow inside the header of the data segments that it sends. The main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgment. This is illustrated in the figure below where the acknowledgment number is underlined in the data segments. Piggybacking is only used when data flows in both directions. A receiver will generate a pure acknowledgment when it does not send data in the opposite direction as shown in the bottom of the figure.</p>
<figure class="align-center" id="id24">
<a class="reference internal image-reference" href="../_images/piggyback2.png"><img alt="../_images/piggyback2.png" src="../Images/53c1a2c1aeb4b7acd10a38ed75d5d3fd.png" style="width: 506.09999999999997px; height: 326.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/piggyback2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 59 </span><span class="caption-text">Piggybacking example</span><a class="headerlink" href="#id24" title="Link to this image">#</a></p>
</figcaption>
</figure>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        
        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        &#13;

<h2>Establishing a transport connection<a class="headerlink" href="#establishing-a-transport-connection" title="Link to this heading">#</a></h2>
<p>Like the connectionless service, the connection-oriented service allows several applications running on a given host to exchange data with other hosts. The port numbers described earlier for the connectionless service are also used by the connection-oriented service to multiplex several applications. Similarly, connection-oriented protocols use checksums/CRCs to detect transmission errors and discard segments containing an invalid checksum/CRC.</p>
<p>An important difference between the connectionless service and the connection-oriented one is that the transport entities in the latter maintain some state during lifetime of the connection. This state is created when a connection is established and is removed when it is released.</p>
<p>The simplest approach to establish a transport connection would be to define two special control segments : <cite>CR</cite> (Connection Request) and <cite>CA</cite> (Connection Acknowledgment). The <cite>CR</cite> segment is sent by the transport entity that wishes to initiate a connection. If the remote entity wishes to accept the connection, it replies by sending a <cite>CA</cite> segment. The <cite>CR</cite> and <cite>CA</cite> segments contain <cite>port numbers</cite> that allow identifying the communicating applications. The transport connection is considered to be established once the <cite>CA</cite> segment has been received. At that point, data segments can be sent in both directions.</p>
<p class="mscgen">
<img src="../Images/384affb0102503143b8af853578161f2.png" alt="msc {&#10;a1 [label=&quot;&quot;, linecolour=white],&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Source&quot;, linecolour=black],&#10;z [label=&quot;Provider&quot;, linecolour=white],&#10;c [label=&quot;Destination&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white],&#10;d1 [label=&quot;&quot;, linecolour=white];&#10;&#10;a1=&gt;b [ label = &quot;CONNECT.req&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;CR&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;c=&gt;d1 [ label = &quot;CONNECT.ind&quot; ];&#10;&#10;d1=&gt;c [ label = &quot;CONNECT.resp&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;CA&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;b=&gt;a1 [ label = &quot;CONNECT.conf&quot; ];&#10;&#10;a1=&gt;b [ linecolour=white, textcolour=blue, label = &quot;Connection\nestablished&quot; ] ,&#10;c=&gt;d1 [ linecolour=white, textcolour=blue, label = &quot;Connection\nestablished&quot; ];&#10;}" usemap="#c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7.png"/>
<map id="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7" name="c8bd190fa10bbc7bbd629dd3a5cd66eaa2806ea7"/></p>
<p>Unfortunately, this is not sufficient given the unreliability of the network layer. Since the network layer is imperfect, the <cite>CR</cite> or <cite>CA</cite> segments can be lost, delayed, or suffer from transmission errors. To deal with these problems, the control segments must be protected by a CRC or a checksum to detect transmission errors. Furthermore, since the <cite>CA</cite> segment acknowledges the reception of the <cite>CR</cite> segment, the <cite>CR</cite> segment should be protected using a retransmission timer.</p>
<p>Unfortunately, this scheme is not sufficient to ensure the reliability of the transport service. Consider for example a short-lived transport connection where a single, but important transfer (e.g. money transfer from a bank account) is sent. Such a short-lived connection starts with a <cite>CR</cite> segment acknowledged by a <cite>CA</cite> segment, then the data segment is sent, acknowledged and the connection terminates. Unfortunately, as the network layer service is unreliable, delays combined to retransmissions may lead to the situation depicted in the figure below, where a delayed <cite>CR</cite> and data segments from a former connection are accepted by the receiving entity as valid segments, and the corresponding data is delivered to the user. Duplicating SDUs is not acceptable, and the transport protocol must solve this problem.</p>
<p class="mscgen">
<img src="../Images/450730721625aed82431f20387763529.png" alt="msc {&#10;a1 [label=&quot;&quot;, linecolour=white],&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Source&quot;, linecolour=black],&#10;z [label=&quot;Provider&quot;, linecolour=white],&#10;c [label=&quot;Destination&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white],&#10;d1 [label=&quot;&quot;, linecolour=white];&#10;&#10;a1=&gt;b [ label = &quot;CONNECT.req&quot; ] ,&#10;b&gt;&gt;c [ label = &quot;CR&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;c=&gt;d1 [ label = &quot;CONNECT.ind&quot; ];&#10;&#10;d1=&gt;c [ label = &quot;CONNECT.resp&quot; ] ,&#10;c&gt;&gt;b [ label = &quot;CA&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;b=&gt;a1 [ label = &quot;CONNECT.conf&quot; ];&#10;&#10;a1=&gt;b [ linecolour=white, textcolour=blue, label = &quot;First connection\nestablished&quot; ] ,&#10;c=&gt;d1 [ linecolour=white, textcolour=blue, label = &quot;First connection\nestablished&quot; ];&#10;&#10;a1=&gt;b [ label = &quot;&quot;, linecolour=white];&#10;&#10;a1=&gt;b [ linecolour=white, textcolour=red, label = &quot;First connection\nclosed&quot; ] ,&#10;c=&gt;d1 [ linecolour=white, textcolour=red, label = &quot;First connection\nclosed&quot; ];&#10;&#10;z&gt;&gt;c [ label = &quot;CR&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;c=&gt;d1 [ label = &quot;How to detect duplicates ?&quot; ],&#10;c&gt;&gt;b [ label = &quot;CA&quot;, arcskip=&quot;1&quot;, textcolour=red];&#10;a1=&gt;b [ label = &quot;&quot;, linecolour=white];&#10;z&gt;&gt;c [ label = &quot;D&quot;, arcskip=&quot;1&quot;];&#10;}" usemap="#453dea7b2a70bc75af50524c87354c0a129e1d05" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-453dea7b2a70bc75af50524c87354c0a129e1d05.png"/>
<map id="453dea7b2a70bc75af50524c87354c0a129e1d05" name="453dea7b2a70bc75af50524c87354c0a129e1d05"/></p>
<p id="index-9">To avoid these duplicates, transport protocols require the network layer to bound the <cite>Maximum Segment Lifetime (MSL)</cite>. The organization of the network must guarantee that no segment remains in the network for longer than <cite>MSL</cite> seconds. For example, on today’s Internet, <cite>MSL</cite> is expected to be 2 minutes. To avoid duplicate transport connections, transport protocol entities must be able to safely distinguish between a duplicate <cite>CR</cite> segment and a new <cite>CR</cite> segment, without forcing each transport entity to remember all the transport connections that it has established in the past.</p>
<p>A classical solution to avoid remembering the previous transport connections to detect duplicates is to use a clock inside each transport entity. This <cite>transport clock</cite> has the following characteristics :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>transport clock</cite> is implemented as a <cite>k</cite> bits counter and its clock cycle is such that <span class="math notranslate nohighlight">\(2^k \times cycle &gt;&gt; MSL\)</span>. Furthermore, the <cite>transport clock</cite> counter is incremented every clock cycle and after each connection establishment. This clock is illustrated in <a class="reference internal" href="#fig-transport-clock"><span class="std std-numref">Fig. 60</span></a>.</p></li>
<li><p>the <cite>transport clock</cite> must continue to be incremented even if the transport entity stops or reboots</p></li>
</ul>
</div></blockquote>
<figure class="align-center" id="id25">
<span id="fig-transport-clock"/><a class="reference internal image-reference" href="../_images/transport-clock.png"><img alt="../_images/transport-clock.png" src="../Images/036312a7c0aeea69142b1e45c82f9114.png" style="width: 434.0px; height: 143.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-clock.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 60 </span><span class="caption-text">Transport clock</span><a class="headerlink" href="#id25" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>It should be noted that <cite>transport clocks</cite> do not need and usually are not synchronized to the real-time clock. Precisely synchronizing real-time clocks is an interesting problem, but it is outside the scope of this document. See <a class="reference internal" href="../bibliography.html#mills2006" id="id8"><span>[Mills2006]</span></a> for a detailed discussion on synchronizing the real-time clock.</p>
<p>This <cite>transport clock</cite> can be combined with an exchange of three segments, called the <cite>three way handshake</cite>, to detect duplicates. This <cite>three way handshake</cite> occurs as follows :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The initiating transport entity sends a <cite>CR</cite> segment. This segment requests the establishment of a transport connection. It contains a port number (not shown in the figure) and a sequence number (<cite>seq=x</cite> in the figure below) whose value is extracted from the <cite>transport clock</cite>. The transmission of the <cite>CR</cite> segment is protected by a retransmission timer.</p></li>
<li><p>The remote transport entity processes the <cite>CR</cite> segment and creates state for the connection attempt. At this stage, the remote entity does not yet know whether this is a new connection attempt or a duplicate segment. It returns a <cite>CA</cite> segment that contains an acknowledgment number to confirm the reception of the <cite>CR</cite> segment (<cite>ack=x</cite> in the figure below) and a sequence number (<cite>seq=y</cite> in the figure below) whose value is extracted from its transport clock. At this stage, the connection is not yet established.</p></li>
<li><p>The initiating entity receives the <cite>CA</cite> segment. The acknowledgment number of this segment confirms that the remote entity has correctly received the <cite>CR</cite> segment. The transport connection is considered to be established by the initiating entity and the numbering of the data segments starts at sequence number <cite>x</cite>. Before sending data segments, the initiating entity must acknowledge the received <cite>CA</cite> segments by sending another <cite>CA</cite> segment.</p></li>
<li><p>The remote entity considers the transport connection to be established after having received the segment that acknowledges its <cite>CA</cite> segment. The numbering of the data segments sent by the remote entity starts at sequence number <cite>y</cite>.</p></li>
</ol>
</div></blockquote>
<p>The three way handshake is illustrated in <a class="reference internal" href="#fig-three-way-handshake"><span class="std std-numref">Fig. 61</span></a>.</p>
<figure class="align-center" id="id26">
<span id="fig-three-way-handshake"/><a class="reference internal image-reference" href="../_images/transport-twh.png"><img alt="../_images/transport-twh.png" src="../Images/73ba69b884756214c68976e4bd783556.png" style="width: 536.1999999999999px; height: 301.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 61 </span><span class="caption-text">The three-way handshake</span><a class="headerlink" href="#id26" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Thanks to the three-way handshake, transport entities avoid duplicate transport connections. This is illustrated by considering the three scenarios below.</p>
<p>The first scenario (<a class="reference internal" href="#fig-twa-scenario1"><span class="std std-numref">Fig. 62</span></a>) is when the remote entity receives an old <cite>CR</cite> segment. It considers this <cite>CR</cite> segment as a connection establishment attempt and replies by sending a <cite>CA</cite> segment. However, the initiating host cannot match the received <cite>CA</cite> segment with a previous connection attempt. It sends a control segment (<cite>REJECT</cite> in the figure below) to cancel the spurious connection attempt. The remote entity cancels the connection attempt upon reception of this control segment.</p>
<figure class="align-center" id="id27">
<span id="fig-twa-scenario1"/><a class="reference internal image-reference" href="../_images/transport-twh-dup.png"><img alt="../_images/transport-twh-dup.png" src="../Images/81f6e94d2c77bba094868c0725d75ae7.png" style="width: 518.0px; height: 251.99999999999997px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh-dup.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 62 </span><span class="caption-text">Three-way handshake : recovery from a duplicate <cite>CR</cite></span><a class="headerlink" href="#id27" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>A second scenario, shown in <a class="reference internal" href="#fig-twa-scenario2"><span class="std std-numref">Fig. 63</span></a> is when the initiating entity sends a <cite>CR</cite> segment that does not reach the remote entity and receives a duplicate <cite>CA</cite> segment from a previous connection attempt. This duplicate <cite>CA</cite> segment cannot contain a valid acknowledgment for the <cite>CR</cite> segment as the sequence number of the <cite>CR</cite> segment was extracted from the transport clock of the initiating entity. The <cite>CA</cite> segment is thus rejected and the <cite>CR</cite> segment is retransmitted upon expiration of the retransmission timer.</p>
<figure class="align-center" id="id28">
<span id="fig-twa-scenario2"/><a class="reference internal image-reference" href="../_images/transport-twh-dup2.png"><img alt="../_images/transport-twh-dup2.png" src="../Images/4a3c5e9fdcb7671a490f8c5fbebda7f5.png" style="width: 538.3px; height: 319.9px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh-dup2.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 63 </span><span class="caption-text">Three-way handshake : recovery from a duplicate <cite>CA</cite></span><a class="headerlink" href="#id28" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The last scenario shown in <a class="reference internal" href="#fig-twa-scenario3"><span class="std std-numref">Fig. 64</span></a> is less likely, but it is important to consider it as well. The remote entity receives an old <cite>CR</cite> segment. It notes the connection attempt and acknowledges it by sending a <cite>CA</cite> segment. The initiating entity does not have a matching connection attempt and replies by sending a <cite>REJECT</cite>. Unfortunately, this segment never reaches the remote entity. Instead, the remote entity receives a retransmission of an older <cite>CA</cite> segment that contains the same sequence number as the first <cite>CR</cite> segment. This <cite>CA</cite> segment cannot be accepted by the remote entity as a confirmation of the transport connection as its acknowledgment number cannot have the same value as the sequence number of the first <cite>CA</cite> segment.</p>
<figure class="align-center" id="id29">
<span id="fig-twa-scenario3"/><a class="reference internal image-reference" href="../_images/transport-twh-dup3.png"><img alt="../_images/transport-twh-dup3.png" src="../Images/9e3c98b89e77408b7654305f9b1a2be3.png" style="width: 514.5px; height: 276.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-twh-dup3.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 64 </span><span class="caption-text">Three-way handshake : recovery from duplicates <cite>CR</cite> and <cite>CA</cite></span><a class="headerlink" href="#id29" title="Link to this image">#</a></p>
</figcaption>
</figure>
&#13;

<h2>Transferring data on a transport connection<a class="headerlink" href="#transferring-data-on-a-transport-connection" title="Link to this heading">#</a></h2>
<p>Now that the transport connection has been established, it can be used to transfer data. To ensure a reliable delivery of the data, the transport protocol will include sliding windows, retransmission timers and <cite>go-back-n</cite> or <cite>selective repeat</cite>. However, we cannot simply reuse these techniques because a reliable transport protocol also needs to cope with three additional types of errors (i) variable delays, (ii) out-f-sequence delivery and (iii) segment duplication.</p>
<p>When two hosts are connected by a link, the transmission delay or the round-trip-time over the link is almost fixed. In a network that can span the globe, the delays and the round-trip-times can vary significantly on a per packet basis. This variability can be caused by two factors. First, packets sent through a network do not necessarily follow the same path to reach their destination. Second, some packets may be queued in the buffers of routers when the load is high and these queuing delays can lead to increased end-to-end delays.</p>
<p>Another problem is that a network does not always deliver packets in sequence. This implies that packets may be reordered by the network. Furthermore, the network may sometimes duplicate packets.</p>
<p>The last issue that needs to be dealt with in the transport layer is the transmission of large SDUs. In our example, we have used short SDUs which fit easily inside segments. Some applications generate SDUs that are much larger than the maximum size of a packet in the network layer. The transport layer needs to include mechanisms to fragment and reassemble these large SDUs.</p>
<p>To deal with all these characteristics of the network layer, we need to adapt the go-back-n and selective repeat techniques that we have introduced earlier.</p>
<p>The ability to detect transmission errors remains important. Each segment contains a CRC/checksum which is computed over the entire segment (header and payload) by the sender and inserted in the header. The receiver recomputes the CRC/checksum for each received segment and discards all segments with an invalid CRC.</p>
<p>Reliable transport protocols also use sequence numbers and acknowledgment numbers. While our example protocols used one sequence number per segment, some reliable transport protocols consider all the data transmitted as a stream of bytes. In these protocols, the sequence number placed in the segment header corresponds to the position of the first byte of the payload in the bytestream. This sequence number allows detecting losses but also enables the receiver to reorder the out-of-sequence segments. This is illustrated in the figure below.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/d415b226c2c0f1663b1289acf10b1351.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(abcde)&quot; ] ,&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;1:abcde&quot;];&#10;c=&gt;d [label=&quot;DATA.ind(abcde)&quot;];&#10;|||;&#10;a=&gt;b [ label = &quot;DATA.req(fghijkl)&quot; ] ,&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;6:fghijkl&quot;];&#10;c=&gt;d [label=&quot;DATA.ind(fghijkl)&quot;];&#10;}" usemap="#3c7d33b83d1006864217839e39a4133300ffe3b0" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-3c7d33b83d1006864217839e39a4133300ffe3b0.png"/>
<map id="3c7d33b83d1006864217839e39a4133300ffe3b0" name="3c7d33b83d1006864217839e39a4133300ffe3b0"/></p>
</div></blockquote>
<p>Using sequence numbers to count bytes has also one advantage when the transport layer needs to fragment SDUs in several segments. The figure below shows the fragmentation of a large SDU in two segments. Upon reception of the segments, the receiver will use the sequence numbers to correctly reorder the data.</p>
<blockquote>
<div><p class="mscgen">
<img src="../Images/e9784923b6b5cd4438e6db36fa5b219d.png" alt="msc {&#10;a [label=&quot;&quot;, linecolour=white],&#10;b [label=&quot;Host A&quot;, linecolour=black],&#10;z [label=&quot;&quot;, linecolour=white],&#10;c [label=&quot;Host B&quot;, linecolour=black],&#10;d [label=&quot;&quot;, linecolour=white];&#10;&#10;a=&gt;b [ label = &quot;DATA.req(abcdefghijkl)&quot; ] ,&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;1:abcde&quot;];&#10;|||;&#10;b&gt;&gt;c [ arcskip=&quot;1&quot;, label=&quot;6:fghijkl&quot;];&#10;c=&gt;d [label=&quot;DATA.ind(abcdefghijkl)&quot;];&#10;}" usemap="#b07721edb508d3fcfd4dc92201cb3bc97f1a85ba" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/mscgen-b07721edb508d3fcfd4dc92201cb3bc97f1a85ba.png"/>
<map id="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba" name="b07721edb508d3fcfd4dc92201cb3bc97f1a85ba"/></p>
</div></blockquote>
<p>Compared to our simple protocols, reliable transport protocols encode their sequence numbers using more bits. 32 bits and 64 bits sequence numbers are frequent in the transport layer. This large sequence number space is motivated by two reasons. First, since the sequence number is incremented for each transmitted byte, a single segment may consume one or several thousands of sequence numbers. Second, a reliable transport protocol must be able to detect delayed segments. This can only be done if the number of bytes transmitted during the MSL period is smaller than the sequence number space. Otherwise, there is a risk of accepting duplicate segments.</p>
<p><cite>Go-back-n</cite> and <cite>selective repeat</cite> can be used in the transport layer as in the datalink layer. Since the network layer does not guarantee an in-order delivery of the packets, a transport entity should always store the segments that it receives out-of-sequence. For this reason, most transport protocols will opt for some form of selective repeat mechanism.</p>
<p>In simple protocols, the sliding window has usually a fixed size which depends on the amount of available buffers. A single transport layer entity serves a large and varying number of application processes. Each transport layer entity manages a pool of buffers that needs to be shared between all these processes. Transport entity are usually implemented inside the operating system kernel and shares memory with other parts of the system. Furthermore, a transport layer entity must support several (possibly hundreds or thousands) of transport connections at the same time. This implies that the memory which can be used to support the sending or the receiving buffer of a transport connection may change during the lifetime of the connection <a class="footnote-reference brackets" href="#fautotune" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> . Thus, a transport protocol must allow the sender and the receiver to adjust their window sizes.</p>
<p>To deal with this issue, transport protocols allow the receiver to advertise the current size of its receiving window in all the acknowledgments that it sends. The receiving window advertised by the receiver bounds the size of the sending buffer used by the sender. In practice, the sender maintains two state variables : <cite>swin</cite>, the size of its sending window (that may be adjusted by the system) and <cite>rwin</cite>, the size of the receiving window advertised by the receiver. At any time, the number of unacknowledged segments cannot be larger than <span class="math notranslate nohighlight">\(\min(swin,rwin)\)</span> <a class="footnote-reference brackets" href="#facklost" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> . The utilization of dynamic windows is illustrated in figure <a class="reference internal" href="#fig-transport-dynamic-win"><span class="std std-numref">Fig. 65</span></a>.</p>
<figure class="align-center" id="id30">
<span id="fig-transport-dynamic-win"/><a class="reference internal image-reference" href="../_images/transport-dwin.svg"><img alt="../_images/transport-dwin.svg" src="../Images/b265eb3f8dd59868de804ccf800a887f.png" style="width: 800.0px; height: 600.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-dwin.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 65 </span><span class="caption-text">Dynamic receiving window</span><a class="headerlink" href="#id30" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The receiver may adjust its advertised receive window based on its current memory consumption, but also to limit the bandwidth used by the sender. In practice, the receive buffer can also shrink as the application may not able to process the received data quickly enough. In this case, the receive buffer may be completely full and the advertised receive window may shrink to <cite>0</cite>. When the sender receives an acknowledgment with a receive window set to <cite>0</cite>, it is blocked until it receives an acknowledgment with a positive receive window. Unfortunately, as shown in <a class="reference internal" href="#fig-win-deadlock"><span class="std std-numref">Fig. 66</span></a>, the loss of this acknowledgment could cause a deadlock as the sender waits for an acknowledgment while the receiver is waiting for a data segment.</p>
<figure class="align-center" id="id31">
<span id="fig-win-deadlock"/><a class="reference internal image-reference" href="../_images/transport-win-deadlock.png"><img alt="../_images/transport-win-deadlock.png" src="../Images/66586c6dcc13b89a7b00c779de739ebc.png" style="width: 438.59999999999997px; height: 238.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-win-deadlock.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 66 </span><span class="caption-text">Risk of deadlock with dynamic windows</span><a class="headerlink" href="#id31" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-10">To solve this problem, transport protocols rely on a special timer : the <cite>persistence timer</cite>. This timer is started by the sender whenever it receives an acknowledgment advertising a receive window set to <cite>0</cite>. When the timer expires, the sender retransmits an old segment in order to force the receiver to send a new acknowledgment, and hence send the current receive window size.</p>
<p>To conclude our description of the basic mechanisms found in transport protocols, we still need to discuss the impact of segments arriving in the wrong order. If two consecutive segments are reordered, the receiver relies on their sequence numbers to reorder them in its receive buffer. Unfortunately, as transport protocols reuse the same sequence number for different segments, if a segment is delayed for a prolonged period of time, it might still be accepted by the receiver. This is illustrated in <a class="reference internal" href="#fig-transport-ambiguity"><span class="std std-numref">Fig. 67</span></a> where segment <cite>D(1,b)</cite> is delayed.</p>
<figure class="align-center" id="id32">
<span id="fig-transport-ambiguity"/><a class="reference internal image-reference" href="../_images/transport-ambiguities.png"><img alt="../_images/transport-ambiguities.png" src="../Images/47226dd629dc43186633321c93f4871f.png" style="width: 360.0px; height: 199.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-ambiguities.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 67 </span><span class="caption-text">Ambiguities caused by excessive delays</span><a class="headerlink" href="#id32" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-11">To deal with this problem, transport protocols combine two solutions. First, they use 32 bits or more to encode the sequence number in the segment header. This increases the overhead, but also increases the delay between the transmission of two different segments having the same sequence number. Second, transport protocols require the network layer to enforce a <cite>Maximum Segment Lifetime (MSL)</cite>. The network layer must ensure that no packet remains in the network for more than MSL seconds. In the Internet the MSL is assumed <a class="footnote-reference brackets" href="#fmsl" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> to be 2 minutes <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc793.html"><strong>RFC 793</strong></a>. Note that this limits the maximum bandwidth of a transport protocol. If it uses <cite>n</cite> bits to encode its sequence numbers, then it cannot send more than <span class="math notranslate nohighlight">\(2^n\)</span> segments every MSL seconds.</p>
&#13;

<h2>Closing a transport connection<a class="headerlink" href="#closing-a-transport-connection" title="Link to this heading">#</a></h2>
<p id="index-13">When we discussed the connection-oriented service, we mentioned that there are two types of connection releases : <cite>abrupt release</cite> and <cite>graceful release</cite>.</p>
<p>The first solution to release a transport connection is to define a new control segment (e.g. the <cite>DR</cite> segment for Disconnection Request) and consider the connection to be released once this segment has been sent or received. This is illustrated in <a class="reference internal" href="#fig-abrupt-release"><span class="std std-numref">Fig. 68</span></a>.</p>
<figure class="align-center" id="id33">
<span id="fig-abrupt-release"/><a class="reference internal image-reference" href="../_images/transport-abrupt.png"><img alt="../_images/transport-abrupt.png" src="../Images/2cbf4e00facf50e43973ab7e7a5671dd.png" style="width: 434.4px; height: 226.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-abrupt.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 68 </span><span class="caption-text">Abrupt connection release</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>As the entity that sends the <cite>DR</cite> segment cannot know whether the other entity has already sent all its data on the connection, SDUs can be lost during such an <cite>abrupt connection release</cite>.</p>
<p id="index-14">The second method to release a transport connection is to release independently the two directions of data transfer. Once a user of the transport service has sent all its SDUs, it performs a <cite>DISCONNECT.req</cite> for its direction of data transfer. The transport entity sends a control segment to request the release of the connection <em>after</em> the delivery of all previous SDUs to the remote user. This is usually done by placing in the <cite>DR</cite> the next sequence number and by delivering the <cite>DISCONNECT.ind</cite> only after all previous <cite>DATA.ind</cite>. The remote entity confirms the reception of the <cite>DR</cite> segment and the release of the corresponding direction of data transfer by returning an acknowledgment. This is illustrated in <a class="reference internal" href="#fig-graceful-release"><span class="std std-numref">Fig. 69</span></a>.</p>
<figure class="align-center" id="id34">
<span id="fig-graceful-release"/><a class="reference internal image-reference" href="../_images/transport-graceful.png"><img alt="../_images/transport-graceful.png" src="../Images/2967c3a8822fc72dfc8c278f20b61f48.png" style="width: 480.2px; height: 249.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/transport-graceful.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 69 </span><span class="caption-text">Graceful connection release</span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fsdu" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>SDU is the acronym of Service Data Unit. We use it as a generic term to represent the data that is transported by a protocol.</p>
</aside>
<aside class="footnote brackets" id="fsizesliding" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">2</a><span class="fn-bracket">]</span></span>
<p>The size of the sliding window can be either fixed for a given protocol or negotiated during the connection establishment phase. Some protocols allow to change the maximum window size during the data transfer. We will explain these techniques with real protocols later.</p>
</aside>
<aside class="footnote brackets" id="fautotune" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">3</a><span class="fn-bracket">]</span></span>
<p>For a discussion on how the sending buffer can change, see e.g. <a class="reference internal" href="../bibliography.html#smm1998" id="id12"><span>[SMM1998]</span></a></p>
</aside>
<aside class="footnote brackets" id="facklost" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">4</a><span class="fn-bracket">]</span></span>
<p>Note that if the receive window shrinks, it might happen that the sender has already sent a segment that is not anymore inside its window. This segment will be discarded by the receiver and the sender will retransmit it later.</p>
</aside>
<aside class="footnote brackets" id="fmsl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">5</a><span class="fn-bracket">]</span></span>
<p>In reality, the Internet does not strictly enforce this MSL. However, it is reasonable to expect that most packets on the Internet will not remain in the network during more than 2 minutes. There are a few exceptions to this rule, such as <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1149.html"><strong>RFC 1149</strong></a> whose implementation is described in <a class="reference external" href="http://www.blug.linux.no/rfc1149/">http://www.blug.linux.no/rfc1149/</a> but there are few real links supporting <span class="target" id="index-16"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1149.html"><strong>RFC 1149</strong></a> in the Internet.</p>
</aside>
</aside>
    
</body>
</html>