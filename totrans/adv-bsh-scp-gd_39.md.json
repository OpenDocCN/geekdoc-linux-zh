["```sh case=value0       # Causes problems.\n    23skidoo=value1   # Also problems.\n    # Variable names starting with a digit are reserved by the shell.\n    # Try _23skidoo=value1\\. Starting variables with an underscore is okay.\n\n    # However . . .   using just an underscore will not work.\n    _=25\n    echo $_           # $_ is a special variable set to last arg of last command.\n    # But . . .       _ is a valid function name!\n\n    xyz((!*=value2    # Causes severe problems.\n    # As of version 3 of Bash, periods are not allowed within variable names.\n    ```", "```sh var-1=23\n    # Use 'var_1' instead.\n\n    function-whatever ()   # Error\n    # Use 'function_whatever ()' instead.\n\n    # As of version 3 of Bash, periods are not allowed within function names.\n    function.whatever ()   # Error\n    # Use 'functionWhatever ()' instead.\n    ```", "```sh do_something ()\n    {\n      echo \"This function does something with \\\"$1\\\".\"\n    }\n\n    do_something=do_something\n\n    do_something do_something\n\n    # All this is legal, but highly confusing.\n    ```", "```sh var1 = 23   # 'var1=23' is correct.\n    # On line above, Bash attempts to execute command \"var1\"\n    # with the arguments \"=\" and \"23\".\n\n    let c = $a - $b   # Instead:   let c=$a-$b   or   let \"c = $a - $b\"\n\n    if [ $a -le 5]    # if [ $a -le 5 ]   is correct.\n    #           ^^      if [ \"$a\" -le 5 ]   is even better.\n                      # [[ $a -le 5 ]] also works.\n    ```", "```sh { ls -l; df; echo \"Done.\" }\n    # bash: syntax error: unexpected end of file\n\n    { ls -l; df; echo \"Done.\"; }\n    #                        ^     ### Final command needs semicolon.\n    ```", "```sh #!/bin/bash\n\n    echo \"uninitialized_var = $uninitialized_var\"\n    # uninitialized_var =\n\n    # However . . .\n    # if $BASH_VERSION â‰¥ 4.2; then\n\n    if [[ ! -v uninitialized_var ]]\n    then\n      uninitialized_var=0   # Initialize it to zero!\n    fi\n\n    ```", "```sh if [ \"$a\" = 273 ]      # Is $a an integer or string?\n    if [ \"$a\" -eq 273 ]    # If $a is an integer.\n\n    # Sometimes you can interchange -eq and = without adverse consequences.\n    # However . . .\n\n    a=273.0   # Not an integer.\n\n    if [ \"$a\" = 273 ]\n    then\n      echo \"Comparison works.\"\n    else  \n      echo \"Comparison does not work.\"\n    fi    # Comparison does not work.\n\n    # Same with   a=\" 273\"  and a=\"0273\".\n\n    # Likewise, problems trying to use \"-eq\" with non-integer values.\n\n    if [ \"$a\" -eq 273.0 ]\n    then\n      echo \"a = $a\"\n    fi  # Aborts with an error message.  \n    # test.sh: [: 273.0: integer expression expected\n    ```", "```sh #!/bin/bash\n    # bad-op.sh: Trying to use a string comparison on integers.\n\n    echo\n    number=1\n\n    #  The following while-loop has two errors:\n    #+ one blatant, and the other subtle.\n\n    while [ \"$number\" < 5 ]    # Wrong! Should be:  while [ \"$number\" -lt 5 ]\n    do\n      echo -n \"$number \"\n      let \"number += 1\"\n    done  \n    #  Attempt to run this bombs with the error message:\n    #+ bad-op.sh: line 10: 5: No such file or directory\n    #  Within single brackets, \"<\" must be escaped,\n    #+ and even then, it's still wrong for comparing integers.\n\n    echo \"---------------------\"\n\n    while [ \"$number\" \\< 5 ]    #  1 2 3 4\n    do                          #\n      echo -n \"$number \"        #  It *seems* to work, but . . .\n      let \"number += 1\"         #+ it actually does an ASCII comparison,\n    done                        #+ rather than a numerical one.\n\n    echo; echo \"---------------------\"\n\n    # This can cause problems. For example:\n\n    lesser=5\n    greater=105\n\n    if [ \"$greater\" \\< \"$lesser\" ]\n    then\n      echo \"$greater is less than $lesser\"\n    fi                          # 105 is less than 5\n    #  In fact, \"105\" actually is less than \"5\"\n    #+ in a string comparison (ASCII sort order).\n\n    echo\n\n    exit 0\n    ```", "```sh let \"a = hello, you\"\n    echo \"$a\"   # 0\n    ```", "```sh command1 2> - &#124; command2\n    # Trying to redirect error output of command1 into a pipe . . .\n    # . . . will not work.\t\n\n    command1 2>& - &#124; command2  # Also futile.\n\n    Thanks, S.C.\n    ```", "```sh #!/bin/bash\n\n    minimum_version=2\n    # Since Chet Ramey is constantly adding features to Bash,\n    # you may set $minimum_version to 2.XX, 3.XX, or whatever is appropriate.\n    E_BAD_VERSION=80\n\n    if [ \"$BASH_VERSION\" \\< \"$minimum_version\" ]\n    then\n      echo \"This script works only with Bash, version $minimum or greater.\"\n      echo \"Upgrade strongly recommended.\"\n      exit $E_BAD_VERSION\n    fi\n\n    ...\n    ```", "```sh var=1 && ((--var)) && echo $var\n    #        ^^^^^^^^^ Here the and-list terminates with exit status 1.\n    #                     $var doesn't echo!\n    echo $?   # 1\n    ```", "```sh #!/bin/bash\n\n    echo \"Here\"\n\n    unix2dos $0    # Script changes itself to DOS format.\n    chmod 755 $0   # Change back to execute permission.\n                   # The 'unix2dos' command removes execute permission.\n\n    ./$0           # Script tries to run itself again.\n                   # But it won't work as a DOS file.\n\n    echo \"There\"\n\n    exit 0\n    ```", "```sh add2 ()\n    {\n      echo \"Whatever ... \"   # Delete this line!\n      let \"retval = $1 + $2\"\n        echo $retval\n        }\n\n        num1=12\n        num2=43\n        echo \"Sum of $num1 and $num2 = $(add2 $num1 $num2)\"\n\n    #   Sum of 12 and 43 = Whatever ... \n    #   55\n\n    #        The \"echoes\" concatenate.\n    ```", "```sh WHATEVER=/home/bozo\n    export WHATEVER\n    exit 0\n    ```", "```sh bash$ echo $WHATEVER\n     `bash$` \n    ```", "```sh #!/bin/bash\n    # Pitfalls of variables in a subshell.\n\n    outer_variable=outer\n    echo\n    echo \"outer_variable = $outer_variable\"\n    echo\n\n    (\n    # Begin subshell\n\n    echo \"outer_variable inside subshell = $outer_variable\"\n    inner_variable=inner  # Set\n    echo \"inner_variable inside subshell = $inner_variable\"\n    outer_variable=inner  # Will value change globally?\n    echo \"outer_variable inside subshell = $outer_variable\"\n\n    # Will 'exporting' make a difference?\n    #    export inner_variable\n    #    export outer_variable\n    # Try it and see.\n\n    # End subshell\n    )\n\n    echo\n    echo \"inner_variable outside subshell = $inner_variable\"  # Unset.\n    echo \"outer_variable outside subshell = $outer_variable\"  # Unchanged.\n    echo\n\n    exit 0\n\n    # What happens if you uncomment lines 19 and 20?\n    # Does it make a difference?\n    ```", "```sh #!/bin/bash\n    #  badread.sh:\n    #  Attempting to use 'echo and 'read'\n    #+ to assign variables non-interactively.\n\n    #   shopt -s lastpipe\n\n    a=aaa\n    b=bbb\n    c=ccc\n\n    echo \"one two three\" &#124; read a b c\n    # Try to reassign a, b, and c.\n\n    echo\n    echo \"a = $a\"  # a = aaa\n    echo \"b = $b\"  # b = bbb\n    echo \"c = $c\"  # c = ccc\n    # Reassignment failed.\n\n    ### However . . .\n    ##  Uncommenting line 6:\n    #   shopt -s lastpipe\n    ##+ fixes the problem!\n    ### This is a new feature in Bash, version 4.2.\n\n    # ------------------------------\n\n    # Try the following alternative.\n\n    var=`echo \"one two three\"`\n    set -- $var\n    a=$1; b=$2; c=$3\n\n    echo \"-------\"\n    echo \"a = $a\"  # a = one\n    echo \"b = $b\"  # b = two\n    echo \"c = $c\"  # c = three \n    # Reassignment succeeded.\n\n    # ------------------------------\n\n    #  Note also that an echo to a 'read' works within a subshell.\n    #  However, the value of the variable changes *only* within the subshell.\n\n    a=aaa          # Starting all over again.\n    b=bbb\n    c=ccc\n\n    echo; echo\n    echo \"one two three\" &#124; ( read a b c;\n    echo \"Inside subshell: \"; echo \"a = $a\"; echo \"b = $b\"; echo \"c = $c\" )\n    # a = one\n    # b = two\n    # c = three\n    echo \"-----------------\"\n    echo \"Outside subshell: \"\n    echo \"a = $a\"  # a = aaa\n    echo \"b = $b\"  # b = bbb\n    echo \"c = $c\"  # c = ccc\n    echo\n\n    exit 0\n    ```", "```sh # Loop piping troubles.\n    #  This example by Anthony Richardson,\n    #+ with addendum by Wilbert Berendsen.\n\n    foundone=false\n    find $HOME -type f -atime +30 -size 100k &#124;\n    while true\n    do\n       read f\n       echo \"$f is over 100KB and has not been accessed in over 30 days\"\n       echo \"Consider moving the file to archives.\"\n       foundone=true\n       # ------------------------------------\n         echo \"Subshell level = $BASH_SUBSHELL\"\n       # Subshell level = 1\n       # Yes, we're inside a subshell.\n       # ------------------------------------\n    done\n\n    #  foundone will always be false here since it is\n    #+ set to true inside a subshell\n    if [ $foundone = false ]\n    then\n       echo \"No files need archiving.\"\n    fi\n\n    # =====================Now, here is the correct way:=================\n\n    foundone=false\n    for f in $(find $HOME -type f -atime +30 -size 100k)  # No pipe here.\n    do\n       echo \"$f is over 100KB and has not been accessed in over 30 days\"\n       echo \"Consider moving the file to archives.\"\n       foundone=true\n    done\n\n    if [ $foundone = false ]\n    then\n       echo \"No files need archiving.\"\n    fi\n\n    # ==================And here is another alternative==================\n\n    #  Places the part of the script that reads the variables\n    #+ within a code block, so they share the same subshell.\n    #  Thank you, W.B.\n\n    find $HOME -type f -atime +30 -size 100k &#124; {\n         foundone=false\n         while read f\n         do\n           echo \"$f is over 100KB and has not been accessed in over 30 days\"\n           echo \"Consider moving the file to archives.\"\n           foundone=true\n         done\n\n         if ! $foundone\n         then\n           echo \"No files need archiving.\"\n         fi\n    }\n    ```", "```sh tail -f /var/log/messages &#124; grep \"$ERROR_MSG\" >> error.log\n    #  The \"error.log\" file will not have anything written to it.\n    #  As Samuli Kaipiainen points out, this results from grep\n    #+ buffering its output.\n    #  The fix is to add the \"--line-buffered\" parameter to grep.\n    ```"]