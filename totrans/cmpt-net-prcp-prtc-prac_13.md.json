["```sh\n# N queues\n# state variable : next_queue\nnext_queue = 0\nwhile True:\n    if isEmpty(buffer):\n        # Wait for next packet in buffer\n        wait()\n    if not(isEmpty(queue[next_queue])):\n        # Send packet at head of next_queue\n        p = remove_packet(queue[next_queue])\n        send(p)\n    next_queue=(next_queue + 1) % N\n# end while \n```", "```sh\n# ALOHA\nN = 1\nwhile N <= max:\n    send(frame)\n    wait(ack_on_return_channel or timeout)\n    if (ack_on_return_channel):\n       break  # transmission was successful\n    else:\n             # timeout\n             wait(random_time)\n             N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# persistent CSMA\nN = 1\nwhile N <= max:\n    wait(channel_becomes_free)\n    send(frame)\n    wait(ack or timeout)\n    if ack:\n       break  # transmission was successful\n    else:\n             # timeout\n             N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# Non persistent CSMA\nN = 1\nwhile N <= max:\n    listen(channel)\n    if free(channel):\n        send(frame)\n        wait(ack or timeout)\n        if received(ack):\n           break  # transmission was successful\n        else:\n                 # timeout\n                 N = N + 1\n    else:\n        wait(random_time)\nelse:\n    # Too many transmission attempts \n```", "```sh\n# CSMA/CD pseudo-code\nN = 1\nwhile N <= max:\n    wait(channel_becomes_free)\n    send(frame)\n    wait_until (end_of_frame) or (collision)\n    if collision detected:\n        stop_transmitting()\n        send(jamming)\n        k = min(10, N)\n        r = random(0, 2**k - 1)\n        wait(r * slotTime)\n        N = N + 1\n    else:\n        wait(inter-frame_delay)\n        break  # transmission was successful\nelse:\n    # Too many transmission attempts \n```", "```sh\n# CSMA/CA simplified pseudo-code\nN=1\nwhile N <= max:\n    wait_until(free(channel))\n    if correct(last_frame):\n        wait(channel_free_during_t >= DIFS)\n    else:\n        wait(channel_free_during_t >= EIFS)\n\n    backoff_time = int(random(0, min(255, 7 * ( 2 ** (N - 1))))) * slotTime\n    wait(channel free during backoff_time)\n    # backoff timer is frozen while channel is sensed to be busy\n    send(frame)\n    wait(ack or timeout)\n    if received(ack)\n        # frame received correctly\n        break\n    else:\n        # retransmission required\n        N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# Additive Increase Multiplicative Decrease\nif congestion:\n    rate = rate * betaC    # multiplicative decrease, betaC<1\nelse\n    rate = rate + alphaN    # additive increase, alphaN > 0 \n```", "```sh\n# Initialisation\ncwin = 1  # congestion window measured in segments\n\n# Ack arrival\nif ack_received:\n    if newack:  # new ack, no congestion\n        # increase cwin by one every rtt\n        cwin = cwin + (1/cwin)\n    else:\n        # no increase\n\nif congestion_detected:\n    cwin = cwin / 2 # only once per rtt \n```", "```sh\n# Initialization\ncwnd = MSS  # congestion window in bytes\nssthresh= swin # in bytes\n\n# Ack arrival\nif tcp.ack > snd.una:  # new ack, no congestion\n    if dupacks == 0:  # not currently recovering from loss\n        if cwnd < ssthresh:\n            # slow-start : quickly increase cwnd\n            # double cwnd every rtt\n            cwnd = cwnd + MSS\n        else:\n            # congestion avoidance : slowly increase cwnd\n            # increase cwnd by one mss every rtt\n            cwnd = cwnd + MSS * (MSS / cwnd)\n    else:  # recovering from loss\n        cwnd = ssthresh  # deflate cwnd RFC5681\n        dupacks = 0\nelse:  # duplicate or old ack\n    if tcp.ack == snd.una:  # duplicate acknowledgment\n        dupacks += 1\n        if dupacks == 1 or dupacks == 2:\n            send_next_unacked_segment  # RFC3042\n        if dupacks == 3:\n            retransmitsegment(snd.una)\n            ssthresh = max(cwnd/2, 2*MSS)\n            cwnd = ssthresh\n        if dupacks > 3:  # RFC5681\n            cwnd = cwnd + MSS  # inflate cwnd\n    else:\n        # ack for old segment, ignored\n        pass\n\nExpiration of the retransmission timer:\n    send(snd.una)  # retransmit first lost segment\n    sshtresh = max(cwnd/2, 2*MSS)\n    cwnd = MSS \n```", "```sh\n# N queues\n# state variable : next_queue\nnext_queue = 0\nwhile True:\n    if isEmpty(buffer):\n        # Wait for next packet in buffer\n        wait()\n    if not(isEmpty(queue[next_queue])):\n        # Send packet at head of next_queue\n        p = remove_packet(queue[next_queue])\n        send(p)\n    next_queue=(next_queue + 1) % N\n# end while \n```", "```sh\n# ALOHA\nN = 1\nwhile N <= max:\n    send(frame)\n    wait(ack_on_return_channel or timeout)\n    if (ack_on_return_channel):\n       break  # transmission was successful\n    else:\n             # timeout\n             wait(random_time)\n             N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# persistent CSMA\nN = 1\nwhile N <= max:\n    wait(channel_becomes_free)\n    send(frame)\n    wait(ack or timeout)\n    if ack:\n       break  # transmission was successful\n    else:\n             # timeout\n             N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# Non persistent CSMA\nN = 1\nwhile N <= max:\n    listen(channel)\n    if free(channel):\n        send(frame)\n        wait(ack or timeout)\n        if received(ack):\n           break  # transmission was successful\n        else:\n                 # timeout\n                 N = N + 1\n    else:\n        wait(random_time)\nelse:\n    # Too many transmission attempts \n```", "```sh\n# CSMA/CD pseudo-code\nN = 1\nwhile N <= max:\n    wait(channel_becomes_free)\n    send(frame)\n    wait_until (end_of_frame) or (collision)\n    if collision detected:\n        stop_transmitting()\n        send(jamming)\n        k = min(10, N)\n        r = random(0, 2**k - 1)\n        wait(r * slotTime)\n        N = N + 1\n    else:\n        wait(inter-frame_delay)\n        break  # transmission was successful\nelse:\n    # Too many transmission attempts \n```", "```sh\n# CSMA/CA simplified pseudo-code\nN=1\nwhile N <= max:\n    wait_until(free(channel))\n    if correct(last_frame):\n        wait(channel_free_during_t >= DIFS)\n    else:\n        wait(channel_free_during_t >= EIFS)\n\n    backoff_time = int(random(0, min(255, 7 * ( 2 ** (N - 1))))) * slotTime\n    wait(channel free during backoff_time)\n    # backoff timer is frozen while channel is sensed to be busy\n    send(frame)\n    wait(ack or timeout)\n    if received(ack)\n        # frame received correctly\n        break\n    else:\n        # retransmission required\n        N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# ALOHA\nN = 1\nwhile N <= max:\n    send(frame)\n    wait(ack_on_return_channel or timeout)\n    if (ack_on_return_channel):\n       break  # transmission was successful\n    else:\n             # timeout\n             wait(random_time)\n             N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# persistent CSMA\nN = 1\nwhile N <= max:\n    wait(channel_becomes_free)\n    send(frame)\n    wait(ack or timeout)\n    if ack:\n       break  # transmission was successful\n    else:\n             # timeout\n             N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# Non persistent CSMA\nN = 1\nwhile N <= max:\n    listen(channel)\n    if free(channel):\n        send(frame)\n        wait(ack or timeout)\n        if received(ack):\n           break  # transmission was successful\n        else:\n                 # timeout\n                 N = N + 1\n    else:\n        wait(random_time)\nelse:\n    # Too many transmission attempts \n```", "```sh\n# CSMA/CD pseudo-code\nN = 1\nwhile N <= max:\n    wait(channel_becomes_free)\n    send(frame)\n    wait_until (end_of_frame) or (collision)\n    if collision detected:\n        stop_transmitting()\n        send(jamming)\n        k = min(10, N)\n        r = random(0, 2**k - 1)\n        wait(r * slotTime)\n        N = N + 1\n    else:\n        wait(inter-frame_delay)\n        break  # transmission was successful\nelse:\n    # Too many transmission attempts \n```", "```sh\n# CSMA/CA simplified pseudo-code\nN=1\nwhile N <= max:\n    wait_until(free(channel))\n    if correct(last_frame):\n        wait(channel_free_during_t >= DIFS)\n    else:\n        wait(channel_free_during_t >= EIFS)\n\n    backoff_time = int(random(0, min(255, 7 * ( 2 ** (N - 1))))) * slotTime\n    wait(channel free during backoff_time)\n    # backoff timer is frozen while channel is sensed to be busy\n    send(frame)\n    wait(ack or timeout)\n    if received(ack)\n        # frame received correctly\n        break\n    else:\n        # retransmission required\n        N = N + 1\nelse:\n    # Too many transmission attempts \n```", "```sh\n# Additive Increase Multiplicative Decrease\nif congestion:\n    rate = rate * betaC    # multiplicative decrease, betaC<1\nelse\n    rate = rate + alphaN    # additive increase, alphaN > 0 \n```", "```sh\n# Initialisation\ncwin = 1  # congestion window measured in segments\n\n# Ack arrival\nif ack_received:\n    if newack:  # new ack, no congestion\n        # increase cwin by one every rtt\n        cwin = cwin + (1/cwin)\n    else:\n        # no increase\n\nif congestion_detected:\n    cwin = cwin / 2 # only once per rtt \n```", "```sh\n# Initialization\ncwnd = MSS  # congestion window in bytes\nssthresh= swin # in bytes\n\n# Ack arrival\nif tcp.ack > snd.una:  # new ack, no congestion\n    if dupacks == 0:  # not currently recovering from loss\n        if cwnd < ssthresh:\n            # slow-start : quickly increase cwnd\n            # double cwnd every rtt\n            cwnd = cwnd + MSS\n        else:\n            # congestion avoidance : slowly increase cwnd\n            # increase cwnd by one mss every rtt\n            cwnd = cwnd + MSS * (MSS / cwnd)\n    else:  # recovering from loss\n        cwnd = ssthresh  # deflate cwnd RFC5681\n        dupacks = 0\nelse:  # duplicate or old ack\n    if tcp.ack == snd.una:  # duplicate acknowledgment\n        dupacks += 1\n        if dupacks == 1 or dupacks == 2:\n            send_next_unacked_segment  # RFC3042\n        if dupacks == 3:\n            retransmitsegment(snd.una)\n            ssthresh = max(cwnd/2, 2*MSS)\n            cwnd = ssthresh\n        if dupacks > 3:  # RFC5681\n            cwnd = cwnd + MSS  # inflate cwnd\n    else:\n        # ack for old segment, ignored\n        pass\n\nExpiration of the retransmission timer:\n    send(snd.una)  # retransmit first lost segment\n    sshtresh = max(cwnd/2, 2*MSS)\n    cwnd = MSS \n```", "```sh\n# Initialisation\ncwin = 1  # congestion window measured in segments\n\n# Ack arrival\nif ack_received:\n    if newack:  # new ack, no congestion\n        # increase cwin by one every rtt\n        cwin = cwin + (1/cwin)\n    else:\n        # no increase\n\nif congestion_detected:\n    cwin = cwin / 2 # only once per rtt \n```", "```sh\n# Initialization\ncwnd = MSS  # congestion window in bytes\nssthresh= swin # in bytes\n\n# Ack arrival\nif tcp.ack > snd.una:  # new ack, no congestion\n    if dupacks == 0:  # not currently recovering from loss\n        if cwnd < ssthresh:\n            # slow-start : quickly increase cwnd\n            # double cwnd every rtt\n            cwnd = cwnd + MSS\n        else:\n            # congestion avoidance : slowly increase cwnd\n            # increase cwnd by one mss every rtt\n            cwnd = cwnd + MSS * (MSS / cwnd)\n    else:  # recovering from loss\n        cwnd = ssthresh  # deflate cwnd RFC5681\n        dupacks = 0\nelse:  # duplicate or old ack\n    if tcp.ack == snd.una:  # duplicate acknowledgment\n        dupacks += 1\n        if dupacks == 1 or dupacks == 2:\n            send_next_unacked_segment  # RFC3042\n        if dupacks == 3:\n            retransmitsegment(snd.una)\n            ssthresh = max(cwnd/2, 2*MSS)\n            cwnd = ssthresh\n        if dupacks > 3:  # RFC5681\n            cwnd = cwnd + MSS  # inflate cwnd\n    else:\n        # ack for old segment, ignored\n        pass\n\nExpiration of the retransmission timer:\n    send(snd.una)  # retransmit first lost segment\n    sshtresh = max(cwnd/2, 2*MSS)\n    cwnd = MSS \n```"]