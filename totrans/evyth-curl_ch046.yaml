- en: Separate install
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单独安装
- en: At times when you build curl and libcurl from source, you do this with the purpose
    of experimenting, testing or perhaps debugging. In these scenarios, you might
    not be ready to replace your system wide libcurl installation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你从源代码构建curl和libcurl时，你这样做是为了实验、测试或者可能是调试。在这些情况下，你可能还没有准备好替换你的系统级libcurl安装。
- en: Many modern systems already have libcurl installed in the system, so when you
    build and install your test version, you need to make sure that your new build
    is used for your purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代系统已经将libcurl安装在了系统中，所以当你构建和安装你的测试版本时，你需要确保你的新构建是为了你的目的而使用的。
- en: We get a lot of reports from people who build and install their own version
    of curl and libcurl, but when they subsequently invoke their new curl build, the
    new tool finds an older libcurl in the system and instead uses that. This tends
    to confuse users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了很多报告，说人们构建并安装了他们自己的curl和libcurl版本，但当他们随后调用他们新的curl构建时，新的工具找到了系统中的较旧的libcurl，并使用它。这往往会让用户感到困惑。
- en: Static linking
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态链接
- en: You can avoid the problem of curl finding an older dynamic libcurl library by
    instead linking with libcurl statically. This however instead triggers a slew
    of other challenges because linking modern libraries with several third party
    dependencies statically is hard work. When you link statically, you need to make
    sure you provide all the dependencies to the linker. This is not a method we recommend.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与libcurl进行静态链接来避免curl找到较旧的动态libcurl库的问题。然而，这却引发了一系列其他挑战，因为将具有多个第三方依赖项的现代库静态链接是很困难的。当你静态链接时，你需要确保你向链接器提供了所有依赖项。这不是我们推荐的方法。
- en: Dynamic linking
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态链接
- en: When you invoke `curl` on a modern system, there is a runtime linker (often
    called `ld.so`) that loads the shared libraries the executable was built to use.
    The shared libraries are searched for and loaded from a set of paths.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在现代系统上调用`curl`时，有一个运行时链接器（通常称为`ld.so`），它会加载可执行文件构建时使用的共享库。共享库会在一组路径中搜索和加载。
- en: The problem is often that the system libcurl library exists in that path, while
    your newly built libcurl does not. Or they both exist in the path but the system
    one is found first.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 问题通常在于系统libcurl库存在于那个路径中，而你的新构建的libcurl不存在。或者它们两个都存在于路径中，但系统的一个被首先找到。
- en: The runtime linker path order is typically defined in `/etc/ld.so.conf` on Linux
    systems. You can change the order and you can add new directories to the list
    of directories to search. Remember to run `ldconfig` after an update.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统上，运行时链接器的路径顺序通常定义在`/etc/ld.so.conf`中。你可以更改顺序，并且可以向搜索目录列表中添加新目录。记得在更新后运行`ldconfig`。
- en: Temporary installs
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时安装
- en: If you build a libcurl and install it somewhere and you just want to use it
    for a single application or maybe just to test something out for a bit, editing
    and changing the dynamic library path might be a bit too intrusive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建了一个libcurl并安装了它，你只想为单个应用程序使用它，或者只是想测试一下，编辑和更改动态库路径可能有点过于侵入性。
- en: A normal unix offers a few other alternative takes that we recommend.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的Unix提供了一些其他我们推荐的替代方案。
- en: '`LD_LIBRARY_PATH`'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`LD_LIBRARY_PATH`'
- en: You can set this environment variable in your shell to make the runtime linker
    look in a particular directory. This affects all executables loaded where this
    variable is set.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的shell中设置这个环境变量，让运行时链接器在特定的目录中查找。这会影响在这个变量设置的所有可执行文件。
- en: It is convenient for quick checks, or even if you want to rotate around and
    have your single `curl` executable use different libcurls in different invokes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于快速检查来说很方便，或者如果你想要在不同的调用中使用不同的libcurl，让你的单个`curl`可执行文件使用不同的libcurl。
- en: 'It can look like this when you have installed your new curl build in `$HOME/install`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将你的新curl构建安装在`$HOME/install`时，它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`rpath`'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`rpath`'
- en: Often, a better way to forcibly load your separate libcurl instead of the system
    one, is to set the `rpath` of the specific `curl` executable you build. That gives
    the runtime linker a specific path to check for this specific executable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，强制加载你自己的单独的libcurl而不是系统的一个更好的方法，是设置你构建的特定`curl`可执行文件的`rpath`。这给运行时链接器提供了一个特定的路径来检查这个特定的可执行文件。
- en: 'This is done at link time, and if you build your own libcurl using application,
    you can make that load your custom libcurl build like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在链接时完成的，如果你使用应用程序构建自己的libcurl，你可以让它加载你的自定义libcurl构建，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With `rpath` set, the executable linked against `$HOME/install/lib/libcurl.so`
    then makes the runtime linker use that specific path and library, while other
    binaries in your system continue to use the system libcurl.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置了`rpath`后，链接到`$HOME/install/lib/libcurl.so`的可执行文件将使运行时链接器使用该特定路径和库，而系统中的其他二进制文件将继续使用系统库curl。
- en: 'When you want to make your custom build of `curl` use its own libcurl and you
    install them into `$HOME/install`, then a configure command line for this looks
    something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想让你的自定义构建的`curl`使用它自己的libcurl，并将它们安装到`$HOME/install`时，这个配置命令行可能看起来像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If your system supports the runpath form of rpath it is often better to use
    that instead because it can be overridden by the `LD_LIBRARY_PATH` environment
    variable. It may also prevent libtool bugs when testing in-tree builds of curl,
    since then libtool can use `LD_LIBRARY_PATH`. Newer linkers may use the runpath
    form of rpath by default when rpath is specified but others need an additional
    linker flag `-Wl,--enable-new-dtags` like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统支持rpath的运行路径形式，通常最好使用它，因为它可以被`LD_LIBRARY_PATH`环境变量覆盖。它还可能在测试curl的树内构建时防止libtool错误，因为那时libtool可以使用`LD_LIBRARY_PATH`。较新的链接器在指定rpath时默认使用rpath的运行路径形式，但其他链接器可能需要一个额外的链接器标志`-Wl,--enable-new-dtags`，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
