["```sh    o &#124; x &#124;\n   ----------\n     &#124; x &#124;\n   ----------\n     &#124; o &#124;\n\n   Your move, human (row, column)?\n```", "```sh Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989\nSmith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612\n...\n```", "```sh #  (Isaac) Newton's Method for speedy extraction\n#+ of square roots.\n\nguess = $argument\n#  $argument is the number to find the square root of.\n#  $guess is each successive calculated \"guess\" -- or trial solution --\n#+ of the square root.\n#  Our first \"guess\" at a square root is the argument itself.\n\noldguess = 0\n# $oldguess is the previous $guess.\n\ntolerance = .000001\n# To how close a tolerance we wish to calculate.\n\nloopcnt = 0\n# Let's keep track of how many times through the loop.\n# Some arguments will require more loop iterations than others.\n\nwhile [ ABS( $guess $oldguess ) -gt $tolerance ]\n#       ^^^^^^^^^^^^^^^^^^^^^^^ Fix up syntax, of course.\n\n#      \"ABS\" is a (floating point) function to find the absolute value\n#+      of the difference between the two terms.\n#             So, as long as difference between current and previous\n#+            trial solution (guess) exceeds the tolerance, keep looping.\n\ndo\n   oldguess = $guess  # Update $oldguess to previous $guess.\n\n#  =======================================================\n   guess = ( $oldguess + ( $argument / $oldguess ) ) / 2.0\n#        = 1/2 ( ($oldguess **2 + $argument) / $oldguess )\n#  equivalent to:\n#        = 1/2 ( $oldguess + $argument / $oldguess )\n#  that is, \"averaging out\" the trial solution and\n#+ the proportion of argument deviation\n#+ (in effect, splitting the error in half).\n#  This converges on an accurate solution\n#+ with surprisingly few loop iterations . . .\n#+ for arguments > $tolerance, of course.\n#  =======================================================\n\n   (( loopcnt++ ))     # Update loop counter.\ndone\n```", "```sh mark --> park --> part --> past --> vast --> vase\n         ^           ^       ^      ^           ^\n```", "```sh    C O D E S\n   A B F G H\n   I K L M N\n   P Q R T U\n   V W X Y Z\n\nEach letter of the alphabet appears once, except \"I\" also represents\n\"J\". The arbitrarily chosen key word, \"CODES\" comes first, then all\nthe rest of the alphabet, in order from left to right, skipping letters\nalready used.\n\nTo encrypt, separate the plaintext message into digrams (2-letter\ngroups). If a group has two identical letters, delete the second, and\nform a new group. If there is a single letter left over at the end,\ninsert a \"null\" character, typically an \"X.\"\n\nTHIS IS A TOP SECRET MESSAGE\n\nTH IS IS AT OP SE CR ET ME SA GE\n\nFor each digram, there are three possibilities.\n-----------------------------------------------\n\n1) Both letters will be on the same row of the key square:\n   For each letter, substitute the one immediately to the right, in that\n   row. If necessary, wrap around left to the beginning of the row.\n\nor\n\n2) Both letters will be in the same column of the key square:\n   For each letter, substitute the one immediately below it, in that\n   row. If necessary, wrap around to the top of the column.\n\nor\n\n3) Both letters will form the corners of a rectangle within the key square:\n   For each letter, substitute the one on the other corner the rectangle\n   which lies on the same row.\n\nThe \"TH\" digram falls under case #3.\nG H\nM N\nT U           (Rectangle with \"T\" and \"H\" at corners)\n\nT --> U\nH --> G\n\nThe \"SE\" digram falls under case #1.\nC O D E S     (Row containing \"S\" and \"E\")\n\nS --> C  (wraps around left to beginning of row)\nE --> S\n\n=========================================================================\n\nTo decrypt encrypted text, reverse the above procedure under cases #1\nand #2 (move in opposite direction for substitution). Under case #3,\njust take the remaining two corners of the rectangle.\n\nHelen Fouche Gaines' classic work, ELEMENTARY CRYPTANALYSIS (1939), gives a\nfairly detailed description of the Playfair Cipher and its solution methods.\n```", "```sh For the simple case of a 2 x 2 determinant:\n\n  &#124;a  b&#124;\n  &#124;b  a&#124;\n\nThe solution is a*a - b*b, where \"a\" and \"b\" represent numbers.\n```"]