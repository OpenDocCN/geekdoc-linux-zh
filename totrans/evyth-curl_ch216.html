<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch216.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="transfers__callbacks__progress__md-_-_-progress-information" class="level1" data-number="215">
<h1 data-number="215">Progress information</h1>
<p>The progress callback is what gets called regularly and repeatedly for each transfer during the entire lifetime of the transfer. The old callback was set with <code>CURLOPT_PROGRESSFUNCTION</code> but the modern and preferred callback is set with <code>CURLOPT_XFERINFOFUNCTION</code>:</p>
<pre><code>curl_easy_setopt(handle, CURLOPT_XFERINFOFUNCTION, xfer_callback);</code></pre>
<p>The <code>xfer_callback</code> function must match this prototype:</p>
<pre><code>int xfer_callback(void *clientp, curl_off_t dltotal, curl_off_t dlnow,
                  curl_off_t ultotal, curl_off_t ulnow);</code></pre>
<p>If this option is set and <code>CURLOPT_NOPROGRESS</code> is set to 0 (zero), this callback function gets called by libcurl with a frequent interval. While data is being transferred it gets called frequently, and during slow periods like when nothing is being transferred it can slow down to about one call per second.</p>
<p>The <strong>clientp</strong> pointer points to the private data set with <code>CURLOPT_XFERINFODATA</code>:</p>
<pre><code>curl_easy_setopt(handle, CURLOPT_XFERINFODATA, custom_pointer);</code></pre>
<p>The callback gets told how much data libcurl is about to transfer and has transferred, in number of bytes:</p>
<ul>
<li><code>dltotal</code> is the total number of bytes libcurl expects to download in this transfer.</li>
<li><code>dlnow</code> is the number of bytes downloaded so far.</li>
<li><code>ultotal</code> is the total number of bytes libcurl expects to upload in this transfer.</li>
<li><code>ulnow</code> is the number of bytes uploaded so far.</li>
</ul>
<p>Unknown/unused argument values passed to the callback are set to zero (like if you only download data, the upload size remains zero). Many times the callback is called one or more times first, before it knows the data sizes, so a program must be made to handle that.</p>
<p>Returning a non-zero value from this callback causes libcurl to abort the transfer and return <code>CURLE_ABORTED_BY_CALLBACK</code>.</p>
<p>If you transfer data with the multi interface, this function is not called during periods of idleness unless you call the appropriate libcurl function that performs transfers.</p>
<p>(The deprecated callback <code>CURLOPT_PROGRESSFUNCTION</code> worked identically but instead of taking arguments of type <code>curl_off_t</code>, it used <code>double</code>.)</p>
<p><span id="transfers__callbacks__header__md"></span></p>
</section>
</body>
</html>
