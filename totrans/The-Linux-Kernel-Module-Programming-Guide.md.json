["```\n  1sudo apt-get install build-essential kmod\n```", "```\n  1sudo pacman -S gcc kmod\n```", "```\n  1lsmod\n```", "```\n  1cat /proc/modules\n```", "```\n  1lsmod | grep fat\n```", "```\n  1sudo apt-get update  \n2apt-cache search linux-headers-`uname -r`\n```", "```\n  1sudo apt-get install linux-headers-`uname -r`\n```", "```\n  1sudo pacman -S linux-headers\n```", "```\n  1sudo dnf install kernel-devel kernel-headers\n```", "```\n  1mkdir -p ~/develop/kernel/hello-1  \n2cd ~/develop/kernel/hello-1\n```", "```\n 1/*   \n2 * hello-1.c - The simplest kernel module.  \n3 */\n\n4#include <linux/module.h> /* Needed by all modules */  \n5#include <linux/printk.h> /* Needed for pr_info() */\n\n6  \n7int init_module(void)  \n8{  \n9    pr_info(\"Hello world 1.\\n\");  \n10\n\n11    /* A nonzero return means init_module failed; module can't be loaded. */\n\n12    return 0;  \n13}  \n14  \n15void cleanup_module(void)  \n16{  \n17    pr_info(\"Goodbye world 1.\\n\");  \n18}\n\n19 \n20MODULE_LICENSE(\"GPL\");\n```", "```\n 1obj-m += hello-1.o   \n2   \n3PWD := $(CURDIR)  \n4   \n5all:  \n6    $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\n7  \n8clean: \n9    $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```", "```\n  1make\n```", "```\n$ sudo -s\n# sudo -V\n\n```", "```\n 1all:  \n2    echo $(PWD)\n```", "```\n$ make -p | grep PWD\nPWD = /home/ubuntu/temp\nOLDPWD = /home/ubuntu\n    echo $(PWD)\n\n```", "```\n$ sudo make -p | grep PWD\n    echo $(PWD)\n\n```", "```\n      1    $ sudo -E make -p | grep PWD   \n    2    PWD = /home/ubuntu/temp\n\n    3    OLDPWD = /home/ubuntu \n    4    echo $(PWD)\n    ```", "```\n     1  ## sudoers file.   \n    2  ##  \n    3  ...\n\n    4  Defaults env_reset \n    5  ## Change env_reset to !env_reset in previous line to keep all environment variables\n    ```", "```\n      1    # disable the env_reset   \n    2    echo \"user:\" > non-env_reset.log; env >> non-env_reset.log\n\n    3    echo \"root:\" >> non-env_reset.log; sudo env >> non-env_reset.log\n\n    4    # enable the env_reset\n\n    5    echo \"user:\" > env_reset.log; env >> env_reset.log \n    6    echo \"root:\" >> env_reset.log; sudo env >> env_reset.log\n    ```", "```\n     1  Defaults env_keep += \"PWD\"\n    ```", "```\n             $ sudo -s\n             # sudo -V\n\n    ```", "```\n  1modinfo hello-1.ko\n```", "```\n  1lsmod | grep hello\n```", "```\n  1sudo insmod hello-1.ko\n```", "```\n  1lsmod | grep hello\n```", "```\n  1sudo rmmod hello_1\n```", "```\n  1sudo dmesg | tail -10\n```", "```\n  1journalctl --since \"1 hour ago\" | grep kernel\n```", "```\n 1/*   \n2 * hello-2.c - Demonstrating the module_init() and module_exit() macros.\n\n3 * This is preferred over using init_module() and cleanup_module().  \n4 */\n\n5#include <linux/init.h> /* Needed for the macros */  \n6#include <linux/module.h> /* Needed by all modules */\n\n7#include <linux/printk.h> /* Needed for pr_info() */  \n8  \n9static int __init hello_2_init(void)\n\n10{  \n11    pr_info(\"Hello, world 2\\n\");  \n12    return 0;  \n13}  \n14  \n15static void __exit hello_2_exit(void)  \n16{\n\n17    pr_info(\"Goodbye, world 2\\n\");  \n18}  \n19  \n20module_init(hello_2_init);  \n21module_exit(hello_2_exit);\n\n22 \n23MODULE_LICENSE(\"GPL\");\n```", "```\n 1obj-m += hello-1.o   \n2obj-m += hello-2.o  \n3   \n4PWD := $(CURDIR)  \n5   \n6all:\n\n7    $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules  \n8\n\n9clean: \n10    $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```", "```\n 1/*   \n2 * hello-3.c - Illustrating the __init, __initdata and __exit macros.  \n3 */\n\n4#include <linux/init.h> /* Needed for the macros */  \n5#include <linux/module.h> /* Needed by all modules */\n\n6#include <linux/printk.h> /* Needed for pr_info() */  \n7  \n8static int hello3_data __initdata = 3;  \n9\n\n10static int __init hello_3_init(void)  \n11{  \n12    pr_info(\"Hello, world %d\\n\", hello3_data);\n\n13    return 0;  \n14}  \n15  \n16static void __exit hello_3_exit(void)  \n17{  \n18    pr_info(\"Goodbye, world 3\\n\");\n\n19}  \n20  \n21module_init(hello_3_init);  \n22module_exit(hello_3_exit);  \n23 \n24MODULE_LICENSE(\"GPL\");\n```", "```\n$ sudo insmod xxxxxx.ko\nloading out-of-tree module taints kernel.\nmodule license 'unspecified' taints kernel.\n\n```", "```\n 1/*   \n2 * hello-4.c - Demonstrates module documentation.  \n3 */\n\n4#include <linux/init.h> /* Needed for the macros */  \n5#include <linux/module.h> /* Needed by all modules */\n\n6#include <linux/printk.h> /* Needed for pr_info() */  \n7  \n8MODULE_LICENSE(\"GPL\");\n\n9MODULE_AUTHOR(\"LKMPG\");  \n10MODULE_DESCRIPTION(\"A sample driver\");  \n11\n\n12static int __init init_hello_4(void)  \n13{  \n14    pr_info(\"Hello, world 4\\n\");  \n15    return 0;  \n16}  \n17\n\n18static void __exit cleanup_hello_4(void)  \n19{  \n20    pr_info(\"Goodbye, world 4\\n\");  \n21}  \n22\n\n23module_init(init_hello_4); \n24module_exit(cleanup_hello_4);\n```", "```\n 1int myint = 3;  \n2module_param(myint, int, 0);\n```", "```\n 1int myintarray[2];   \n2module_param_array(myintarray, int, NULL, 0); /* not interested in count */\n\n3  \n4short myshortarray[4];\n\n5int count; \n6module_param_array(myshortarray, short, &count, 0); /* put count into \"count\" variable */\n```", "```\n 1/*   \n2 * hello-5.c - Demonstrates command line argument passing to a module.\n\n3 */  \n4#include <linux/init.h>  \n5#include <linux/kernel.h> /* for ARRAY_SIZE() */\n\n6#include <linux/module.h>  \n7#include <linux/moduleparam.h>  \n8#include <linux/printk.h>\n\n9#include <linux/stat.h>  \n10  \n11MODULE_LICENSE(\"GPL\");  \n12  \n13static short int myshort = 1;\n\n14static int myint = 420;  \n15static long int mylong = 9999;  \n16static char *mystring = \"blah\";\n\n17static int myintarray[2] = { 420, 420 };  \n18static int arr_argc = 0;  \n19\n\n20/* module_param(foo, int, 0000)  \n21 * The first param is the parameter's name.\n\n22 * The second param is its data type.  \n23 * The final argument is the permissions bits,\n\n24 * for exposing parameters in sysfs (if non-zero) at a later stage.  \n25 */\n\n26module_param(myshort, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n\n27MODULE_PARM_DESC(myshort, \"A short integer\");  \n28module_param(myint, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n29MODULE_PARM_DESC(myint, \"An integer\");  \n30module_param(mylong, long, S_IRUSR);\n\n31MODULE_PARM_DESC(mylong, \"A long integer\");  \n32module_param(mystring, charp, 0000);\n\n33MODULE_PARM_DESC(mystring, \"A character string\");  \n34  \n35/* module_param_array(name, type, num, perm);\n\n36 * The first param is the parameter's (in this case the array's) name.\n\n37 * The second param is the data type of the elements of the array.\n\n38 * The third argument is a pointer to the variable that will store the number\n\n39 * of elements of the array initialized by the user at module loading time.\n\n40 * The fourth argument is the permission bits.  \n41 */  \n42module_param_array(myintarray, int, &arr_argc, 0000);\n\n43MODULE_PARM_DESC(myintarray, \"An array of integers\");  \n44  \n45static int __init hello_5_init(void)\n\n46{  \n47    int i;  \n48  \n49    pr_info(\"Hello, world 5\\n=============\\n\");\n\n50    pr_info(\"myshort is a short integer: %hd\\n\", myshort);\n\n51    pr_info(\"myint is an integer: %d\\n\", myint);  \n52    pr_info(\"mylong is a long integer: %ld\\n\", mylong);\n\n53    pr_info(\"mystring is a string: %s\\n\", mystring);  \n54  \n55    for (i = 0; i < ARRAY_SIZE(myintarray); i++)\n\n56        pr_info(\"myintarray[%d] = %d\\n\", i, myintarray[i]);  \n57\n\n58    pr_info(\"got %d arguments for myintarray.\\n\", arr_argc);  \n59    return 0;  \n60}  \n61\n\n62static void __exit hello_5_exit(void)  \n63{  \n64    pr_info(\"Goodbye, world 5\\n\");  \n65}  \n66\n\n67module_init(hello_5_init); \n68module_exit(hello_5_exit);\n```", "```\n$ sudo insmod hello-5.ko mystring=\"bebop\" myintarray=-1\n$ sudo dmesg -t | tail -7\nmyshort is a short integer: 1\nmyint is an integer: 420\nmylong is a long integer: 9999\nmystring is a string: bebop\nmyintarray[0] = -1\nmyintarray[1] = 420\ngot 1 arguments for myintarray.\n\n$ sudo rmmod hello-5\n$ sudo dmesg -t | tail -1\nGoodbye, world 5\n\n$ sudo insmod hello-5.ko mystring=\"supercalifragilisticexpialidocious\" myintarray=-1,-1\n$ sudo dmesg -t | tail -7\nmyshort is a short integer: 1\nmyint is an integer: 420\nmylong is a long integer: 9999\nmystring is a string: supercalifragilisticexpialidocious\nmyintarray[0] = -1\nmyintarray[1] = -1\ngot 2 arguments for myintarray.\n\n$ sudo rmmod hello_5\n$ sudo dmesg -t | tail -1\nGoodbye, world 5\n\n$ sudo insmod hello-5.ko mylong=hello\ninsmod: ERROR: could not insert module hello-5.ko: Invalid parameters\n\n```", "```\n 1/*   \n2 * start.c - Illustration of multi filed modules  \n3 */\n\n4  \n5#include <linux/kernel.h> /* We are doing kernel work */\n\n6#include <linux/module.h> /* Specifically, a module */  \n7  \n8int init_module(void)  \n9{\n\n10    pr_info(\"Hello, world - this is the kernel speaking\\n\");  \n11    return 0;  \n12}\n\n13 \n14MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * stop.c - Illustration of multi filed modules  \n3 */\n\n4  \n5#include <linux/kernel.h> /* We are doing kernel work */\n\n6#include <linux/module.h> /* Specifically, a module  */  \n7  \n8void cleanup_module(void)  \n9{\n\n10    pr_info(\"Short is the life of a kernel module\\n\");  \n11}  \n12 \n13MODULE_LICENSE(\"GPL\");\n```", "```\n 1obj-m += hello-1.o   \n2obj-m += hello-2.o  \n3obj-m += hello-3.o  \n4obj-m += hello-4.o\n\n5obj-m += hello-5.o  \n6obj-m += startstop.o  \n7startstop-objs := start.o stop.o  \n8\n\n9PWD := $(CURDIR)  \n10  \n11all:  \n12    $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules  \n13\n\n14clean: \n15    $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```", "```\ninsmod: ERROR: could not insert module poet.ko: Invalid module format\n\n```", "```\nkernel: poet: disagrees about version of symbol module_layout\n\n```", "```\n$ modinfo hello-4.ko\ndescription:    A sample driver\nauthor:         LKMPG\nlicense:        GPL\nsrcversion:     B2AA7FBFCC2C39AED665382\ndepends:\nretpoline:      Y\nname:           hello_4\nvermagic:       5.4.0-70-generic SMP mod_unload modversions\n\n```", "```\nVERSION = 5\nPATCHLEVEL = 14\nSUBLEVEL = 0\nEXTRAVERSION = -rc2\n\n```", "```\n  1cp /lib/modules/`uname -r`/build/Makefile linux-`uname -r`\n```", "```\n$ make\n  SYNC    include/config/auto.conf.cmd\n  HOSTCC  scripts/basic/fixdep\n  HOSTCC  scripts/kconfig/conf.o\n  HOSTCC  scripts/kconfig/confdata.o\n  HOSTCC  scripts/kconfig/expr.o\n  LEX     scripts/kconfig/lexer.lex.c\n  YACC    scripts/kconfig/parser.tab.[ch]\n  HOSTCC  scripts/kconfig/preprocess.o\n  HOSTCC  scripts/kconfig/symbol.o\n  HOSTCC  scripts/kconfig/util.o\n  HOSTCC  scripts/kconfig/lexer.lex.o\n  HOSTCC  scripts/kconfig/parser.tab.o\n  HOSTLD  scripts/kconfig/conf\n\n```", "```\n 1#include <stdio.h>   \n2   \n3int main(void)  \n4{  \n5    printf(\"hello\");  \n6    return 0; \n7}\n```", "```\n$ ls -l /dev/sda[1-3]\nbrw-rw----  1 root  disk  8, 1 Apr  9  2025 /dev/sda1\nbrw-rw----  1 root  disk  8, 2 Apr  9  2025 /dev/sda2\nbrw-rw----  1 root  disk  8, 3 Apr  9  2025 /dev/sda3\n\n```", "```\ncrw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0\ncrw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1\ncrw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2\ncrw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3\n\n```", "```\n$ ls -l /dev/sda /dev/sdb\nbrw-rw---- 1 root disk 8,  0 Jan  3 09:02 /dev/sda\nbrw-rw---- 1 root disk 8, 16 Jan  3 09:02 /dev/sdb\n\n```", "```\n 1struct file_operations {   \n2    struct module *owner;  \n3    loff_t (*llseek) (struct file *, loff_t, int);\n\n4    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\n5    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\n6    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\n7    ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\n8    int (*iopoll)(struct kiocb *kiocb, bool spin);  \n9    int (*iterate) (struct file *, struct dir_context *);\n\n10    int (*iterate_shared) (struct file *, struct dir_context *);\n\n11    __poll_t (*poll) (struct file *, struct poll_table_struct *);\n\n12    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\n13    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\n14    int (*mmap) (struct file *, struct vm_area_struct *);\n\n15    unsigned long mmap_supported_flags;  \n16    int (*open) (struct inode *, struct file *);\n\n17    int (*flush) (struct file *, fl_owner_t id);  \n18    int (*release) (struct inode *, struct file *);\n\n19    int (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\n20    int (*fasync) (int, struct file *, int);  \n21    int (*lock) (struct file *, int, struct file_lock *);\n\n22    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\n23    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\n24    int (*check_flags)(int);  \n25    int (*flock) (struct file *, int, struct file_lock *);\n\n26    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\n27    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\n28    int (*setlease)(struct file *, long, struct file_lock **, void **);\n\n29    long (*fallocate)(struct file *file, int mode, loff_t offset,\n\n30        loff_t len);  \n31    void (*show_fdinfo)(struct seq_file *m, struct file *f);\n\n32    ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\n33        loff_t, size_t, unsigned int);  \n34    loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\n35             struct file *file_out, loff_t pos_out,  \n36             loff_t len, unsigned int remap_flags);\n\n37    int (*fadvise)(struct file *, loff_t, loff_t, int); \n38} __randomize_layout;\n```", "```\n 1struct file_operations fops = {   \n2    read: device_read,  \n3    write: device_write,\n\n4    open: device_open,  \n5    release: device_release \n6};\n```", "```\n 1struct file_operations fops = {   \n2    .read = device_read,  \n3    .write = device_write,\n\n4    .open = device_open,  \n5    .release = device_release \n6};\n```", "```\n 1int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);\n```", "```\n 1int register_chrdev_region(dev_t from, unsigned count, const char *name);\n\n2int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);\n```", "```\n 1struct cdev *my_dev = cdev_alloc();  \n2my_cdev->ops = &my_fops;\n```", "```\n 1void cdev_init(struct cdev *cdev, const struct file_operations *fops);\n```", "```\n 1int cdev_add(struct cdev *p, dev_t dev, unsigned count);\n```", "```\n  1cat /proc/devices\n```", "```\n 1/*   \n2 * chardev.c: Creates a read-only char device that says how many times\n\n3 * you have read from the dev file  \n4 */  \n5  \n6#include <linux/atomic.h>  \n7#include <linux/cdev.h>\n\n8#include <linux/delay.h>  \n9#include <linux/device.h>  \n10#include <linux/fs.h>\n\n11#include <linux/init.h>  \n12#include <linux/kernel.h> /* for sprintf() */\n\n13#include <linux/module.h>  \n14#include <linux/printk.h>  \n15#include <linux/types.h>\n\n16#include <linux/uaccess.h> /* for get_user and put_user */  \n17#include <linux/version.h>  \n18\n\n19#include <asm/errno.h>  \n20  \n21/*  Prototypes - this would normally go in a .h file */\n\n22static int device_open(struct inode *, struct file *);\n\n23static int device_release(struct inode *, struct file *);\n\n24static ssize_t device_read(struct file *, char __user *, size_t, loff_t *);\n\n25static ssize_t device_write(struct file *, const char __user *, size_t,  \n26                            loff_t *);\n\n27  \n28#define DEVICE_NAME \"chardev\" /* Dev name as it appears in /proc/devices   */\n\n29#define BUF_LEN 80 /* Max length of the message from the device */  \n30\n\n31/* Global variables are declared as static, so are global within the file. */  \n32\n\n33static int major; /* major number assigned to our device driver */  \n34  \n35enum {  \n36    CDEV_NOT_USED,\n\n37    CDEV_EXCLUSIVE_OPEN,  \n38};  \n39  \n40/* Is device open? Used to prevent multiple access to device */\n\n41static atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);  \n42\n\n43static char msg[BUF_LEN + 1]; /* The msg the device will give when asked */  \n44\n\n45static struct class *cls;  \n46  \n47static struct file_operations chardev_fops = {\n\n48    .read = device_read,  \n49    .write = device_write,  \n50    .open = device_open,\n\n51    .release = device_release,  \n52};  \n53  \n54static int __init chardev_init(void)  \n55{\n\n56    major = register_chrdev(0, DEVICE_NAME, &chardev_fops);  \n57  \n58    if (major < 0) {\n\n59        pr_alert(\"Registering char device failed with %d\\n\", major);\n\n60        return major;  \n61    }  \n62  \n63    pr_info(\"I was assigned major number %d.\\n\", major);  \n64\n\n65#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)  \n66    cls = class_create(DEVICE_NAME);\n\n67#else  \n68    cls = class_create(THIS_MODULE, DEVICE_NAME);  \n69#endif\n\n70    device_create(cls, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);  \n71\n\n72    pr_info(\"Device created on /dev/%s\\n\", DEVICE_NAME);  \n73  \n74    return 0;  \n75}  \n76\n\n77static void __exit chardev_exit(void)  \n78{  \n79    device_destroy(cls, MKDEV(major, 0));\n\n80    class_destroy(cls);  \n81  \n82    /* Unregister the device */  \n83    unregister_chrdev(major, DEVICE_NAME);\n\n84}  \n85  \n86/* Methods */  \n87  \n88/* Called when a process tries to open the device file, like\n\n89 * \"sudo cat /dev/chardev\"  \n90 */  \n91static int device_open(struct inode *inode, struct file *file)  \n92{\n\n93    static int counter = 0;  \n94  \n95    if (atomic_cmpxchg(&already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))\n\n96        return -EBUSY;  \n97  \n98    sprintf(msg, \"I already told you %d times Hello world!\\n\", counter++);\n\n99  \n100    return 0;  \n101}  \n102  \n103/* Called when a process closes the device file. */\n\n104static int device_release(struct inode *inode, struct file *file)  \n105{\n\n106    /* We're now ready for our next caller */  \n107    atomic_set(&already_open, CDEV_NOT_USED);\n\n108  \n109    return 0;  \n110}  \n111  \n112/* Called when a process, which already opened the dev file, attempts to\n\n113 * read from it.  \n114 */  \n115static ssize_t device_read(struct file *filp, /* see include/linux/fs.h   */\n\n116                           char __user *buffer, /* buffer to fill with data */\n\n117                           size_t length, /* length of the buffer     */\n\n118                           loff_t *offset)  \n119{  \n120    /* Number of bytes actually written to the buffer */\n\n121    int bytes_read = 0;  \n122    const char *msg_ptr = msg;  \n123\n\n124    if (!*(msg_ptr + *offset)) { /* we are at the end of message */\n\n125        *offset = 0; /* reset the offset */  \n126        return 0; /* signify end of file */\n\n127    }  \n128  \n129    msg_ptr += *offset;  \n130  \n131    /* Actually put the data into the buffer */\n\n132    while (length && *msg_ptr) {  \n133        /* The buffer is in the user data segment, not the kernel\n\n134         * segment so \"*\" assignment won't work.  We have to use\n\n135         * put_user which copies data from the kernel data segment to\n\n136         * the user data segment.  \n137         */  \n138        put_user(*(msg_ptr++), buffer++);\n\n139        length--;  \n140        bytes_read++;  \n141    }  \n142  \n143    *offset += bytes_read;  \n144\n\n145    /* Most read functions return the number of bytes put into the buffer. */  \n146    return bytes_read;\n\n147}  \n148  \n149/* Called when a process writes to dev file: echo \"hi\" | sudo tee /dev/chardev */\n\n150static ssize_t device_write(struct file *filp, const char __user *buff,\n\n151                            size_t len, loff_t *off)  \n152{\n\n153    pr_alert(\"Sorry, this operation is not supported.\\n\");  \n154    return -EINVAL;  \n155}  \n156\n\n157module_init(chardev_init);  \n158module_exit(chardev_exit);  \n159 \n160MODULE_LICENSE(\"GPL\");\n```", "```\n$ cat /proc/helloworld\nHelloWorld!\n\n```", "```\n 1/*   \n2 * procfs1.c  \n3 */  \n4   \n5#include <linux/kernel.h>  \n6#include <linux/module.h>\n\n7#include <linux/proc_fs.h>  \n8#include <linux/uaccess.h>  \n9#include <linux/version.h>  \n10\n\n11#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)  \n12#define HAVE_PROC_OPS  \n13#endif  \n14\n\n15#define procfs_name \"helloworld\"  \n16  \n17static struct proc_dir_entry *our_proc_file;  \n18\n\n19static ssize_t procfile_read(struct file *file_pointer, char __user *buffer,\n\n20                             size_t buffer_length, loff_t *offset)\n\n21{  \n22    char s[13] = \"HelloWorld!\\n\";  \n23    int len = sizeof(s);\n\n24    ssize_t ret = len;  \n25  \n26    if (*offset >= len || copy_to_user(buffer, s, len)) {\n\n27        pr_info(\"copy_to_user failed\\n\");  \n28        ret = 0;  \n29    } else {\n\n30        pr_info(\"procfile read %s\\n\", file_pointer->f_path.dentry->d_name.name);\n\n31        *offset += len;  \n32    }  \n33  \n34    return ret;  \n35}  \n36  \n37#ifdef HAVE_PROC_OPS\n\n38static const struct proc_ops proc_file_fops = {  \n39    .proc_read = procfile_read,\n\n40};  \n41#else  \n42static const struct file_operations proc_file_fops = {\n\n43    .read = procfile_read,  \n44};  \n45#endif  \n46  \n47static int __init procfs1_init(void)  \n48{\n\n49    our_proc_file = proc_create(procfs_name, 0644, NULL, &proc_file_fops);\n\n50    if (NULL == our_proc_file) {  \n51        pr_alert(\"Error:Could not initialize /proc/%s\\n\", procfs_name);\n\n52        return -ENOMEM;  \n53    }  \n54  \n55    pr_info(\"/proc/%s created\\n\", procfs_name);\n\n56    return 0;  \n57}  \n58  \n59static void __exit procfs1_exit(void)  \n60{  \n61    proc_remove(our_proc_file);\n\n62    pr_info(\"/proc/%s removed\\n\", procfs_name);  \n63}  \n64  \n65module_init(procfs1_init);\n\n66module_exit(procfs1_exit);  \n67 \n68MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * procfs2.c -  create a \"file\" in /proc  \n3 */  \n4   \n5#include <linux/kernel.h> /* We're doing kernel work */\n\n6#include <linux/module.h> /* Specifically, a module */\n\n7#include <linux/proc_fs.h> /* Necessary because we use the proc fs */\n\n8#include <linux/uaccess.h> /* for copy_from_user */  \n9#include <linux/version.h>\n\n10  \n11#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)  \n12#define HAVE_PROC_OPS\n\n13#endif  \n14  \n15#define PROCFS_MAX_SIZE 1024  \n16#define PROCFS_NAME \"buffer1k\"\n\n17  \n18/* This structure hold information about the /proc file */\n\n19static struct proc_dir_entry *our_proc_file;  \n20  \n21/* The buffer used to store character for this module */\n\n22static char procfs_buffer[PROCFS_MAX_SIZE];  \n23  \n24/* The size of the buffer */\n\n25static unsigned long procfs_buffer_size = 0;  \n26  \n27/* This function is called then the /proc file is read */\n\n28static ssize_t procfile_read(struct file *file_pointer, char __user *buffer,\n\n29                             size_t buffer_length, loff_t *offset)\n\n30{  \n31    char s[13] = \"HelloWorld!\\n\";  \n32    int len = sizeof(s);\n\n33    ssize_t ret = len;  \n34  \n35    if (*offset >= len || copy_to_user(buffer, s, len)) {\n\n36        pr_info(\"copy_to_user failed\\n\");  \n37        ret = 0;  \n38    } else {\n\n39        pr_info(\"procfile read %s\\n\", file_pointer->f_path.dentry->d_name.name);  \n40        *offset += len;\n\n41    }  \n42  \n43    return ret;  \n44}  \n45  \n46/* This function is called with the /proc file is written. */\n\n47static ssize_t procfile_write(struct file *file, const char __user *buff,\n\n48                              size_t len, loff_t *off)  \n49{  \n50    procfs_buffer_size = len;\n\n51    if (procfs_buffer_size >= PROCFS_MAX_SIZE)  \n52        procfs_buffer_size = PROCFS_MAX_SIZE - 1;\n\n53  \n54    if (copy_from_user(procfs_buffer, buff, procfs_buffer_size))  \n55        return -EFAULT;  \n56\n\n57    procfs_buffer[procfs_buffer_size] = '\\0';  \n58    *off += procfs_buffer_size;\n\n59    pr_info(\"procfile write %s\\n\", procfs_buffer);  \n60  \n61    return procfs_buffer_size;\n\n62}  \n63  \n64#ifdef HAVE_PROC_OPS  \n65static const struct proc_ops proc_file_fops = {\n\n66    .proc_read = procfile_read,  \n67    .proc_write = procfile_write,  \n68};  \n69#else\n\n70static const struct file_operations proc_file_fops = {  \n71    .read = procfile_read,\n\n72    .write = procfile_write,  \n73};  \n74#endif  \n75  \n76static int __init procfs2_init(void)\n\n77{  \n78    our_proc_file = proc_create(PROCFS_NAME, 0644, NULL, &proc_file_fops);\n\n79    if (NULL == our_proc_file) {  \n80        pr_alert(\"Error:Could not initialize /proc/%s\\n\", PROCFS_NAME);\n\n81        return -ENOMEM;  \n82    }  \n83  \n84    pr_info(\"/proc/%s created\\n\", PROCFS_NAME);\n\n85    return 0;  \n86}  \n87  \n88static void __exit procfs2_exit(void)  \n89{  \n90    proc_remove(our_proc_file);\n\n91    pr_info(\"/proc/%s removed\\n\", PROCFS_NAME);  \n92}  \n93  \n94module_init(procfs2_init);\n\n95module_exit(procfs2_exit);  \n96 \n97MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * procfs3.c  \n3 */  \n4   \n5#include <linux/kernel.h>  \n6#include <linux/module.h>\n\n7#include <linux/proc_fs.h>  \n8#include <linux/sched.h>  \n9#include <linux/uaccess.h>\n\n10#include <linux/version.h>  \n11#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)\n\n12#include <linux/minmax.h>  \n13#endif  \n14  \n15#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)\n\n16#define HAVE_PROC_OPS  \n17#endif  \n18  \n19#define PROCFS_MAX_SIZE 2048UL\n\n20#define PROCFS_ENTRY_FILENAME \"buffer2k\"  \n21  \n22static struct proc_dir_entry *our_proc_file;\n\n23static char procfs_buffer[PROCFS_MAX_SIZE];  \n24static unsigned long procfs_buffer_size = 0;\n\n25  \n26static ssize_t procfs_read(struct file *filp, char __user *buffer,\n\n27                           size_t length, loff_t *offset)  \n28{\n\n29    if (*offset || procfs_buffer_size == 0) {  \n30        pr_debug(\"procfs_read: END\\n\");\n\n31        *offset = 0;  \n32        return 0;  \n33    }  \n34    procfs_buffer_size = min(procfs_buffer_size, length);\n\n35    if (copy_to_user(buffer, procfs_buffer, procfs_buffer_size))\n\n36        return -EFAULT;  \n37    *offset += procfs_buffer_size;  \n38\n\n39    pr_debug(\"procfs_read: read %lu bytes\\n\", procfs_buffer_size);  \n40    return procfs_buffer_size;\n\n41}  \n42static ssize_t procfs_write(struct file *file, const char __user *buffer,\n\n43                            size_t len, loff_t *off)  \n44{  \n45    procfs_buffer_size = min(PROCFS_MAX_SIZE, len);\n\n46    if (copy_from_user(procfs_buffer, buffer, procfs_buffer_size))  \n47        return -EFAULT;\n\n48    *off += procfs_buffer_size;  \n49  \n50    pr_debug(\"procfs_write: write %lu bytes\\n\", procfs_buffer_size);\n\n51    return procfs_buffer_size;  \n52}  \n53static int procfs_open(struct inode *inode, struct file *file)\n\n54{  \n55    return 0;  \n56}  \n57static int procfs_close(struct inode *inode, struct file *file)  \n58{\n\n59    return 0;  \n60}  \n61  \n62#ifdef HAVE_PROC_OPS  \n63static struct proc_ops file_ops_4_our_proc_file = {\n\n64    .proc_read = procfs_read,  \n65    .proc_write = procfs_write,\n\n66    .proc_open = procfs_open,  \n67    .proc_release = procfs_close,  \n68};\n\n69#else  \n70static const struct file_operations file_ops_4_our_proc_file = {\n\n71    .read = procfs_read,  \n72    .write = procfs_write,  \n73    .open = procfs_open,\n\n74    .release = procfs_close,  \n75};  \n76#endif  \n77  \n78static int __init procfs3_init(void)\n\n79{  \n80    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, 0644, NULL,\n\n81                                &file_ops_4_our_proc_file);  \n82    if (our_proc_file == NULL) {\n\n83        pr_debug(\"Error: Could not initialize /proc/%s\\n\",  \n84                 PROCFS_ENTRY_FILENAME);\n\n85        return -ENOMEM;  \n86    }  \n87    proc_set_size(our_proc_file, 80);\n\n88    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);  \n89\n\n90    pr_debug(\"/proc/%s created\\n\", PROCFS_ENTRY_FILENAME);  \n91    return 0;  \n92}  \n93\n\n94static void __exit procfs3_exit(void)  \n95{  \n96    remove_proc_entry(PROCFS_ENTRY_FILENAME, NULL);\n\n97    pr_debug(\"/proc/%s removed\\n\", PROCFS_ENTRY_FILENAME);  \n98}  \n99  \n100module_init(procfs3_init);\n\n101module_exit(procfs3_exit);  \n102 \n103MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * procfs4.c -  create a \"file\" in /proc\n\n3 * This program uses the seq_file library to manage the /proc file.\n\n4 */  \n5  \n6#include <linux/kernel.h> /* We are doing kernel work */\n\n7#include <linux/module.h> /* Specifically, a module */\n\n8#include <linux/proc_fs.h> /* Necessary because we use proc fs */\n\n9#include <linux/seq_file.h> /* for seq_file */  \n10#include <linux/version.h>  \n11\n\n12#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)  \n13#define HAVE_PROC_OPS  \n14#endif  \n15\n\n16#define PROC_NAME \"iter\"  \n17  \n18/* This function is called at the beginning of a sequence.  \n19 * ie, when:\n\n20 *   - the /proc file is read (first time)  \n21 *   - after the function stop (end of sequence)\n\n22 */  \n23static void *my_seq_start(struct seq_file *s, loff_t *pos)  \n24{\n\n25    static unsigned long counter = 0;  \n26  \n27    /* beginning a new sequence? */  \n28    if (*pos == 0) {\n\n29        /* yes => return a non null value to begin the sequence */  \n30        return &counter;\n\n31    }  \n32  \n33    /* no => it is the end of the sequence, return end to stop reading */  \n34    *pos = 0;\n\n35    return NULL;  \n36}  \n37  \n38/* This function is called after the beginning of a sequence.\n\n39 * It is called until the return is NULL (this ends the sequence).  \n40 */\n\n41static void *my_seq_next(struct seq_file *s, void *v, loff_t *pos)  \n42{\n\n43    unsigned long *tmp_v = (unsigned long *)v;  \n44    (*tmp_v)++;  \n45    (*pos)++;  \n46    return NULL;  \n47}  \n48\n\n49/* This function is called at the end of a sequence. */  \n50static void my_seq_stop(struct seq_file *s, void *v)\n\n51{  \n52    /* nothing to do, we use a static value in start() */  \n53}\n\n54  \n55/* This function is called for each \"step\" of a sequence. */\n\n56static int my_seq_show(struct seq_file *s, void *v)  \n57{\n\n58    loff_t *spos = (loff_t *)v;  \n59  \n60    seq_printf(s, \"%Ld\\n\", *spos);\n\n61    return 0;  \n62}  \n63  \n64/* This structure gather \"function\" to manage the sequence */\n\n65static struct seq_operations my_seq_ops = {  \n66    .start = my_seq_start,\n\n67    .next = my_seq_next,  \n68    .stop = my_seq_stop,  \n69    .show = my_seq_show,\n\n70};  \n71  \n72/* This function is called when the /proc file is open. */\n\n73static int my_open(struct inode *inode, struct file *file)  \n74{  \n75    return seq_open(file, &my_seq_ops);\n\n76};  \n77  \n78/* This structure gather \"function\" that manage the /proc file */  \n79#ifdef HAVE_PROC_OPS\n\n80static const struct proc_ops my_file_ops = {  \n81    .proc_open = my_open,\n\n82    .proc_read = seq_read,  \n83    .proc_lseek = seq_lseek,  \n84    .proc_release = seq_release,\n\n85};  \n86#else  \n87static const struct file_operations my_file_ops = {  \n88    .open = my_open,\n\n89    .read = seq_read,  \n90    .llseek = seq_lseek,  \n91    .release = seq_release,  \n92};\n\n93#endif  \n94  \n95static int __init procfs4_init(void)  \n96{  \n97    struct proc_dir_entry *entry;  \n98\n\n99    entry = proc_create(PROC_NAME, 0, NULL, &my_file_ops);  \n100    if (entry == NULL) {\n\n101        pr_debug(\"Error: Could not initialize /proc/%s\\n\", PROC_NAME);\n\n102        return -ENOMEM;  \n103    }  \n104  \n105    return 0;  \n106}  \n107  \n108static void __exit procfs4_exit(void)  \n109{\n\n110    remove_proc_entry(PROC_NAME, NULL);  \n111    pr_debug(\"/proc/%s removed\\n\", PROC_NAME);  \n112}\n\n113  \n114module_init(procfs4_init);  \n115module_exit(procfs4_exit);  \n116 \n117MODULE_LICENSE(\"GPL\");\n```", "```\n  1ls -l /sys\n```", "```\n 1struct attribute {   \n2    char *name;  \n3    struct module *owner;  \n4    umode_t mode;  \n5};  \n6\n\n7int sysfs_create_file(struct kobject * kobj, const struct attribute * attr); \n8void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr);\n```", "```\n 1struct device_attribute {   \n2    struct attribute attr;\n\n3    ssize_t (*show)(struct device *dev, struct device_attribute *attr,  \n4                    char *buf);\n\n5    ssize_t (*store)(struct device *dev, struct device_attribute *attr,\n\n6                    const char *buf, size_t count);  \n7};  \n8\n\n9int device_create_file(struct device *, const struct device_attribute *); \n10void device_remove_file(struct device *, const struct device_attribute *);\n```", "```\n 1/*   \n2 * hello-sysfs.c sysfs example  \n3 */  \n4#include <linux/fs.h>  \n5#include <linux/init.h>\n\n6#include <linux/kobject.h>  \n7#include <linux/module.h>  \n8#include <linux/string.h>  \n9#include <linux/sysfs.h>\n\n10  \n11static struct kobject *mymodule;  \n12  \n13/* the variable you want to be able to change */\n\n14static int myvariable = 0;  \n15  \n16static ssize_t myvariable_show(struct kobject *kobj,\n\n17                               struct kobj_attribute *attr, char *buf)  \n18{\n\n19    return sprintf(buf, \"%d\\n\", myvariable);  \n20}  \n21  \n22static ssize_t myvariable_store(struct kobject *kobj,\n\n23                                struct kobj_attribute *attr, const char *buf,\n\n24                                size_t count)  \n25{  \n26    sscanf(buf, \"%d\", &myvariable);\n\n27    return count;  \n28}  \n29  \n30static struct kobj_attribute myvariable_attribute =\n\n31    __ATTR(myvariable, 0660, myvariable_show, myvariable_store);  \n32\n\n33static int __init mymodule_init(void)  \n34{  \n35    int error = 0;  \n36  \n37    pr_info(\"mymodule: initialized\\n\");\n\n38  \n39    mymodule = kobject_create_and_add(\"mymodule\", kernel_kobj);  \n40    if (!mymodule)\n\n41        return -ENOMEM;  \n42  \n43    error = sysfs_create_file(mymodule, &myvariable_attribute.attr);\n\n44    if (error) {  \n45        kobject_put(mymodule);  \n46        pr_info(\"failed to create the myvariable file \"\n\n47                \"in /sys/kernel/mymodule\\n\");  \n48    }  \n49  \n50    return error;  \n51}  \n52\n\n53static void __exit mymodule_exit(void)  \n54{  \n55    pr_info(\"mymodule: Exit success\\n\");\n\n56    kobject_put(mymodule);  \n57}  \n58  \n59module_init(mymodule_init);  \n60module_exit(mymodule_exit);\n\n61 \n62MODULE_LICENSE(\"GPL\");\n```", "```\n  1make  \n2sudo insmod hello-sysfs.ko\n```", "```\n  1lsmod | grep hello_sysfs\n```", "```\n  1cat /sys/kernel/mymodule/myvariable\n```", "```\n  1echo \"32\" | sudo tee /sys/kernel/mymodule/myvariable\n\n2cat /sys/kernel/mymodule/myvariable\n```", "```\n  1sudo rmmod hello_sysfs\n```", "```\n 1/*   \n2 * ioctl.c  \n3 */  \n4#include <linux/cdev.h>  \n5#include <linux/fs.h>  \n6#include <linux/init.h>\n\n7#include <linux/ioctl.h>  \n8#include <linux/module.h>  \n9#include <linux/slab.h>\n\n10#include <linux/uaccess.h>  \n11#include <linux/version.h>  \n12  \n13struct ioctl_arg {\n\n14    unsigned int val;  \n15};  \n16  \n17/* Documentation/userspace-api/ioctl/ioctl-number.rst */\n\n18#define IOC_MAGIC '\\x66'  \n19  \n20#define IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg)\n\n21#define IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg)  \n22#define IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int)\n\n23#define IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int)  \n24  \n25#define IOCTL_VAL_MAXNR 3\n\n26#define DRIVER_NAME \"ioctltest\"  \n27  \n28static unsigned int test_ioctl_major = 0;\n\n29static unsigned int num_of_dev = 1;  \n30static struct cdev test_ioctl_cdev;\n\n31static int ioctl_num = 0;  \n32  \n33struct test_ioctl_data {  \n34    unsigned char val;\n\n35    rwlock_t lock;  \n36};  \n37  \n38static long test_ioctl_ioctl(struct file *filp, unsigned int cmd,\n\n39                             unsigned long arg)  \n40{  \n41    struct test_ioctl_data *ioctl_data = filp->private_data;\n\n42    int retval = 0;  \n43    unsigned char val;  \n44    struct ioctl_arg data;\n\n45    memset(&data, 0, sizeof(data));  \n46  \n47    switch (cmd) {  \n48    case IOCTL_VALSET:\n\n49        if (copy_from_user(&data, (int __user *)arg, sizeof(data))) {\n\n50            retval = -EFAULT;  \n51            goto done;  \n52        }  \n53\n\n54        pr_alert(\"IOCTL set val:%x .\\n\", data.val);  \n55        write_lock(&ioctl_data->lock);\n\n56        ioctl_data->val = data.val;  \n57        write_unlock(&ioctl_data->lock);\n\n58        break;  \n59  \n60    case IOCTL_VALGET:  \n61        read_lock(&ioctl_data->lock);\n\n62        val = ioctl_data->val;  \n63        read_unlock(&ioctl_data->lock);\n\n64        data.val = val;  \n65  \n66        if (copy_to_user((int __user *)arg, &data, sizeof(data))) {\n\n67            retval = -EFAULT;  \n68            goto done;  \n69        }  \n70  \n71        break;  \n72\n\n73    case IOCTL_VALGET_NUM:  \n74        retval = __put_user(ioctl_num, (int __user *)arg);\n\n75        break;  \n76  \n77    case IOCTL_VALSET_NUM:  \n78        ioctl_num = arg;  \n79        break;  \n80\n\n81    default:  \n82        retval = -ENOTTY;  \n83    }  \n84  \n85done:  \n86    return retval;\n\n87}  \n88  \n89static ssize_t test_ioctl_read(struct file *filp, char __user *buf,\n\n90                               size_t count, loff_t *f_pos)  \n91{\n\n92    struct test_ioctl_data *ioctl_data = filp->private_data;  \n93    unsigned char val;\n\n94    int retval;  \n95    int i = 0;  \n96  \n97    read_lock(&ioctl_data->lock);  \n98    val = ioctl_data->val;\n\n99    read_unlock(&ioctl_data->lock);  \n100  \n101    for (; i < count; i++) {\n\n102        if (copy_to_user(&buf[i], &val, 1)) {  \n103            retval = -EFAULT;\n\n104            goto out;  \n105        }  \n106    }  \n107  \n108    retval = count;  \n109out:  \n110    return retval;\n\n111}  \n112  \n113static int test_ioctl_close(struct inode *inode, struct file *filp)\n\n114{  \n115    pr_alert(\"%s call.\\n\", __func__);  \n116  \n117    if (filp->private_data) {\n\n118        kfree(filp->private_data);  \n119        filp->private_data = NULL;  \n120    }  \n121\n\n122    return 0;  \n123}  \n124  \n125static int test_ioctl_open(struct inode *inode, struct file *filp)  \n126{\n\n127    struct test_ioctl_data *ioctl_data;  \n128  \n129    pr_alert(\"%s call.\\n\", __func__);\n\n130    ioctl_data = kmalloc(sizeof(struct test_ioctl_data), GFP_KERNEL);  \n131\n\n132    if (ioctl_data == NULL)  \n133        return -ENOMEM;  \n134  \n135    rwlock_init(&ioctl_data->lock);\n\n136    ioctl_data->val = 0xFF;  \n137    filp->private_data = ioctl_data;  \n138  \n139    return 0;\n\n140}  \n141  \n142static struct file_operations fops = {  \n143    .owner = THIS_MODULE,\n\n144    .open = test_ioctl_open,  \n145    .release = test_ioctl_close,  \n146    .read = test_ioctl_read,\n\n147    .unlocked_ioctl = test_ioctl_ioctl,  \n148};  \n149  \n150static int __init ioctl_init(void)  \n151{\n\n152    dev_t dev;  \n153    int ret;  \n154  \n155    ret = alloc_chrdev_region(&dev, 0, num_of_dev, DRIVER_NAME);\n\n156  \n157    if (ret)  \n158        return ret;  \n159  \n160    test_ioctl_major = MAJOR(dev);\n\n161    cdev_init(&test_ioctl_cdev, &fops);  \n162    ret = cdev_add(&test_ioctl_cdev, dev, num_of_dev);\n\n163  \n164    if (ret) {  \n165        unregister_chrdev_region(dev, num_of_dev);  \n166        return ret;  \n167    }  \n168\n\n169    pr_alert(\"%s driver(major: %d) installed.\\n\", DRIVER_NAME,  \n170             test_ioctl_major);\n\n171    return 0;  \n172}  \n173  \n174static void __exit ioctl_exit(void)  \n175{  \n176    dev_t dev = MKDEV(test_ioctl_major, 0);\n\n177  \n178    cdev_del(&test_ioctl_cdev);  \n179    unregister_chrdev_region(dev, num_of_dev);\n\n180    pr_alert(\"%s driver removed.\\n\", DRIVER_NAME);  \n181}  \n182  \n183module_init(ioctl_init);\n\n184module_exit(ioctl_exit);  \n185  \n186MODULE_LICENSE(\"GPL\"); \n187MODULE_DESCRIPTION(\"This is test_ioctl module\");\n```", "```\n 1/*   \n2 * chardev2.c - Create an input/output character device  \n3 */  \n4\n\n5#include <linux/atomic.h>  \n6#include <linux/cdev.h>  \n7#include <linux/delay.h>\n\n8#include <linux/device.h>  \n9#include <linux/fs.h>  \n10#include <linux/init.h>\n\n11#include <linux/module.h> /* Specifically, a module */  \n12#include <linux/printk.h>\n\n13#include <linux/types.h>  \n14#include <linux/uaccess.h> /* for get_user and put_user */\n\n15#include <linux/version.h>  \n16  \n17#include <asm/errno.h>  \n18  \n19#include \"chardev.h\"\n\n20#define DEVICE_NAME \"char_dev\"  \n21#define BUF_LEN 80  \n22  \n23enum {  \n24    CDEV_NOT_USED,\n\n25    CDEV_EXCLUSIVE_OPEN,  \n26};  \n27  \n28/* Is the device open right now? Used to prevent concurrent access into\n\n29 * the same device  \n30 */  \n31static atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);  \n32\n\n33/* The message the device will give when asked */  \n34static char message[BUF_LEN + 1];  \n35\n\n36static struct class *cls;  \n37  \n38/* This is called whenever a process attempts to open the device file */\n\n39static int device_open(struct inode *inode, struct file *file)  \n40{  \n41    pr_info(\"device_open(%p)\\n\", file);\n\n42  \n43    return 0;  \n44}  \n45  \n46static int device_release(struct inode *inode, struct file *file)\n\n47{  \n48    pr_info(\"device_release(%p,%p)\\n\", inode, file);  \n49  \n50    return 0;  \n51}  \n52\n\n53/* This function is called whenever a process which has already opened the  \n54 * device file attempts to read from it.\n\n55 */  \n56static ssize_t device_read(struct file *file, /* see include/linux/fs.h   */\n\n57                           char __user *buffer, /* buffer to be filled  */\n\n58                           size_t length, /* length of the buffer     */\n\n59                           loff_t *offset)  \n60{  \n61    /* Number of bytes actually written to the buffer */\n\n62    int bytes_read = 0;  \n63    /* How far did the process reading the message get? Useful if the message\n\n64     * is larger than the size of the buffer we get to fill in device_read.  \n65     */\n\n66    const char *message_ptr = message;  \n67  \n68    if (!*(message_ptr + *offset)) { /* we are at the end of message */\n\n69        *offset = 0; /* reset the offset */  \n70        return 0; /* signify end of file */\n\n71    }  \n72  \n73    message_ptr += *offset;  \n74  \n75    /* Actually put the data into the buffer */\n\n76    while (length && *message_ptr) {  \n77        /* Because the buffer is in the user data segment, not the kernel\n\n78         * data segment, assignment would not work. Instead, we have to\n\n79         * use put_user which copies data from the kernel data segment to  \n80         * the user data segment.\n\n81         */  \n82        put_user(*(message_ptr++), buffer++);  \n83        length--;  \n84        bytes_read++;\n\n85    }  \n86  \n87    pr_info(\"Read %d bytes, %ld left\\n\", bytes_read, length);  \n88  \n89    *offset += bytes_read;\n\n90  \n91    /* Read functions are supposed to return the number of bytes actually\n\n92     * inserted into the buffer.  \n93     */  \n94    return bytes_read;  \n95}\n\n96  \n97/* called when somebody tries to write into our device file. */\n\n98static ssize_t device_write(struct file *file, const char __user *buffer,\n\n99                            size_t length, loff_t *offset)  \n100{  \n101    int i;\n\n102  \n103    pr_info(\"device_write(%p,%p,%ld)\", file, buffer, length);  \n104\n\n105    for (i = 0; i < length && i < BUF_LEN; i++)  \n106        get_user(message[i], buffer + i);\n\n107  \n108    /* Again, return the number of input characters used. */  \n109    return i;\n\n110}  \n111  \n112/* This function is called whenever a process tries to do an ioctl on our\n\n113 * device file. We get two extra parameters (additional to the inode and file\n\n114 * structures, which all device functions get): the number of the ioctl called\n\n115 * and the parameter given to the ioctl function.  \n116 *\n\n117 * If the ioctl is write or read/write (meaning output is returned to the\n\n118 * calling process), the ioctl call returns the output of this function.\n\n119 */  \n120static long  \n121device_ioctl(struct file *file, /* ditto */\n\n122             unsigned int ioctl_num, /* number and param for ioctl */\n\n123             unsigned long ioctl_param)  \n124{  \n125    int i;  \n126    long ret = 0;\n\n127  \n128    /* We don't want to talk to two processes at the same time. */\n\n129    if (atomic_cmpxchg(&already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))\n\n130        return -EBUSY;  \n131  \n132    /* Switch according to the ioctl called */  \n133    switch (ioctl_num) {\n\n134    case IOCTL_SET_MSG: {  \n135        /* Receive a pointer to a message (in user space) and set that to\n\n136         * be the device's message. Get the parameter given to ioctl by\n\n137         * the process.  \n138         */  \n139        char __user *tmp = (char __user *)ioctl_param;\n\n140        char ch;  \n141  \n142        /* Find the length of the message */  \n143        get_user(ch, tmp);\n\n144        for (i = 0; ch && i < BUF_LEN; i++, tmp++)  \n145            get_user(ch, tmp);\n\n146  \n147        device_write(file, (char __user *)ioctl_param, i, NULL);\n\n148        break;  \n149    }  \n150    case IOCTL_GET_MSG: {  \n151        loff_t offset = 0;\n\n152  \n153        /* Give the current message to the calling process - the parameter\n\n154         * we got is a pointer, fill it.  \n155         */\n\n156        i = device_read(file, (char __user *)ioctl_param, 99, &offset);  \n157\n\n158        /* Put a zero at the end of the buffer, so it will be properly  \n159         * terminated.\n\n160         */  \n161        put_user('\\0', (char __user *)ioctl_param + i);  \n162        break;  \n163    }\n\n164    case IOCTL_GET_NTH_BYTE:  \n165        /* This ioctl is both input (ioctl_param) and output (the return\n\n166         * value of this function).  \n167         */  \n168        ret = (long)message[ioctl_param];\n\n169        break;  \n170    }  \n171  \n172    /* We're now ready for our next caller */\n\n173    atomic_set(&already_open, CDEV_NOT_USED);  \n174  \n175    return ret;  \n176}  \n177  \n178/* Module Declarations */\n\n179  \n180/* This structure will hold the functions to be called when a process does\n\n181 * something to the device we created. Since a pointer to this structure\n\n182 * is kept in the devices table, it can't be local to init_module. NULL is\n\n183 * for unimplemented functions.  \n184 */  \n185static struct file_operations fops = {\n\n186    .read = device_read,  \n187    .write = device_write,  \n188    .unlocked_ioctl = device_ioctl,\n\n189    .open = device_open,  \n190    .release = device_release, /* a.k.a. close */\n\n191};  \n192  \n193/* Initialize the module - Register the character device */\n\n194static int __init chardev2_init(void)  \n195{  \n196    /* Register the character device (at least try) */\n\n197    int ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops);  \n198\n\n199    /* Negative values signify an error */  \n200    if (ret_val < 0) {  \n201        pr_alert(\"%s failed with %d\\n\",\n\n202                 \"Sorry, registering the character device \", ret_val);  \n203        return ret_val;\n\n204    }  \n205  \n206#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)  \n207    cls = class_create(DEVICE_FILE_NAME);\n\n208#else  \n209    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME);  \n210#endif\n\n211    device_create(cls, NULL, MKDEV(MAJOR_NUM, 0), NULL, DEVICE_FILE_NAME);  \n212\n\n213    pr_info(\"Device created on /dev/%s\\n\", DEVICE_FILE_NAME);  \n214  \n215    return 0;  \n216}  \n217\n\n218/* Cleanup - unregister the appropriate file from /proc */  \n219static void __exit chardev2_exit(void)\n\n220{  \n221    device_destroy(cls, MKDEV(MAJOR_NUM, 0));  \n222    class_destroy(cls);  \n223\n\n224    /* Unregister the device */  \n225    unregister_chrdev(MAJOR_NUM, DEVICE_NAME);  \n226}  \n227\n\n228module_init(chardev2_init);  \n229module_exit(chardev2_exit);  \n230 \n231MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * chardev.h - the header file with the ioctl definitions.  \n3 *\n\n4 * The declarations here have to be in a header file, because they need\n\n5 * to be known both to the kernel module (in chardev2.c) and the process\n\n6 * calling ioctl() (in userspace_ioctl.c).  \n7 */  \n8  \n9#ifndef CHARDEV_H  \n10#define CHARDEV_H  \n11\n\n12#include <linux/ioctl.h>  \n13  \n14/* The major device number. We can not rely on dynamic registration\n\n15 * any more, because ioctls need to know it.  \n16 */  \n17#define MAJOR_NUM 100  \n18\n\n19/* Set the message of the device driver */  \n20#define IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *)\n\n21/* _IOW means that we are creating an ioctl command number for passing\n\n22 * information from a user process to the kernel module.  \n23 *\n\n24 * The first arguments, MAJOR_NUM, is the major device number we are using.  \n25 *\n\n26 * The second argument is the number of the command (there could be several  \n27 * with different meanings).\n\n28 *  \n29 * The third argument is the type we want to get from the process to the  \n30 * kernel.  \n31 */  \n32\n\n33/* Get the message of the device driver */  \n34#define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *)\n\n35/* This IOCTL is used for output, to get the message of the device driver.\n\n36 * However, we still need the buffer to place the message in to be input,  \n37 * as it is allocated by the process.\n\n38 */  \n39  \n40/* Get the n'th byte of the message */  \n41#define IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int)\n\n42/* The IOCTL is used for both input and output. It receives from the user\n\n43 * a number, n, and returns message[n].  \n44 */  \n45  \n46/* The name of the device file */\n\n47#define DEVICE_FILE_NAME \"char_dev\"  \n48#define DEVICE_PATH \"/dev/char_dev\"  \n49 \n50#endif\n```", "```\n 1/*  userspace_ioctl.c - the process to use ioctl's to control the kernel module\n\n2 *  \n3 *  Until now we could have used cat for input and output.  But now\n\n4 *  we need to do ioctl's, which require writing our own process.   \n5 */  \n6\n\n7/* device specifics, such as ioctl numbers and the   \n8 * major device file. */\n\n9#include \"../chardev.h\"  \n10  \n11#include <stdio.h> /* standard I/O */  \n12#include <fcntl.h> /* open */\n\n13#include <unistd.h> /* close */  \n14#include <stdlib.h> /* exit */  \n15#include <sys/ioctl.h> /* ioctl */\n\n16  \n17/* Functions for the ioctl calls */  \n18  \n19int ioctl_set_msg(int file_desc, char *message)\n\n20{  \n21    int ret_val;  \n22  \n23    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message);  \n24\n\n25    if (ret_val < 0) {  \n26        printf(\"ioctl_set_msg failed:%d\\n\", ret_val);  \n27    }\n\n28  \n29    return ret_val;  \n30}  \n31  \n32int ioctl_get_msg(int file_desc)  \n33{  \n34    int ret_val;\n\n35    char message[100] = { 0 };  \n36  \n37    /* Warning - this is dangerous because we don't tell \n\n38   * the kernel how far it's allowed to write, so it   \n39   * might overflow the buffer. In a real production \n\n40   * program, we would have used two ioctls - one to tell\n\n41   * the kernel the buffer length and another to give   \n42   * it the buffer to fill\n\n43   */  \n44    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message);  \n45\n\n46    if (ret_val < 0) {  \n47        printf(\"ioctl_get_msg failed:%d\\n\", ret_val);\n\n48    }  \n49    printf(\"get_msg message:%s\", message);  \n50  \n51    return ret_val;  \n52}  \n53\n\n54int ioctl_get_nth_byte(int file_desc)  \n55{  \n56    int i, c;  \n57  \n58    printf(\"get_nth_byte message:\");\n\n59  \n60    i = 0;  \n61    do {  \n62        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++);  \n63\n\n64        if (c < 0) {  \n65            printf(\"\\nioctl_get_nth_byte failed at the %d'th byte:\\n\", i);\n\n66            return c;  \n67        }  \n68  \n69        putchar(c);  \n70    } while (c != 0);\n\n71  \n72    return 0;  \n73}  \n74  \n75/* Main - Call the ioctl functions */  \n76int main(void)  \n77{\n\n78    int file_desc, ret_val;  \n79    char *msg = \"Message passed by ioctl\\n\";\n\n80  \n81    file_desc = open(DEVICE_PATH, O_RDWR);  \n82    if (file_desc < 0) {\n\n83        printf(\"Can't open device file: %s, error:%d\\n\", DEVICE_PATH,  \n84               file_desc);\n\n85        exit(EXIT_FAILURE);  \n86    }  \n87  \n88    ret_val = ioctl_set_msg(file_desc, msg);\n\n89    if (ret_val)  \n90        goto error;  \n91    ret_val = ioctl_get_nth_byte(file_desc);\n\n92    if (ret_val)  \n93        goto error;  \n94    ret_val = ioctl_get_msg(file_desc);\n\n95    if (ret_val)  \n96        goto error;  \n97  \n98    close(file_desc);  \n99    return 0;  \n100error:\n\n101    close(file_desc);  \n102    exit(EXIT_FAILURE); \n103}\n```", "```\n$ gcc -v -Q -O2 --help=target | grep protection\nUsing built-in specs.\nCOLLECT_GCC=gcc\nCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper\n...\ngcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)\nCOLLECT_GCC_OPTIONS='-v' '-Q' '-O2' '--help=target' '-mtune=generic' '-march=x86-64'\n /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -v ... -fcf-protection ...\n GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu)\n...\n\n```", "```\n$ sudo grep sys_call_table /proc/kallsyms\nffffffff82000280 R x32_sys_call_table\nffffffff820013a0 R sys_call_table\nffffffff820023e0 R ia32_sys_call_table\n$ sudo insmod syscall-steal.ko sym=0xffffffff820013a0\n\n```", "```\n$ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"\n$ sudo grep sys_call_table /boot/System.map-$(uname -r)\nffffffff82000300 R sys_call_table\n$ sudo grep sys_call_table /proc/kallsyms\nffffffff820013a0 R sys_call_table\n# Reboot\n$ sudo grep sys_call_table /boot/System.map-$(uname -r)\nffffffff82000300 R sys_call_table\n$ sudo grep sys_call_table /proc/kallsyms\nffffffff86400300 R sys_call_table\n\n```", "```\n$ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\"\n$ sudo perl -i -pe 'm/quiet/ and s//quiet nokaslr/' /etc/default/grub\n$ grep quiet /etc/default/grub\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet nokaslr splash\"\n$ sudo update-grub\n\n```", "```\n 1/*   \n2 * syscall-steal.c  \n3 *  \n4 * System call \"stealing\" sample.  \n5 *\n\n6 * Disables page protection at a processor level by changing the 16th bit\n\n7 * in the cr0 register (could be Intel specific).  \n8 */  \n9  \n10#include <linux/delay.h>  \n11#include <linux/kernel.h>\n\n12#include <linux/module.h>  \n13#include <linux/moduleparam.h> /* which will have params */\n\n14#include <linux/unistd.h> /* The list of system calls */  \n15#include <linux/cred.h> /* For current_uid() */\n\n16#include <linux/uidgid.h> /* For __kuid_val() */  \n17#include <linux/version.h>  \n18\n\n19/* For the current (process) structure, we need this to know who the\n\n20 * current user is.  \n21 */  \n22#include <linux/sched.h>  \n23#include <linux/uaccess.h>  \n24\n\n25/* The way we access \"sys_call_table\" varies as kernel internal changes.\n\n26 * - Prior to v5.4 : manual symbol lookup  \n27 * - v5.5 to v5.6  : use kallsyms_lookup_name()\n\n28 * - v5.7+         : Kprobes or specific kernel module parameter  \n29 */  \n30\n\n31/* The in-kernel calls to the ksys_close() syscall were removed in Linux v5.11+.  \n32 */\n\n33#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0))  \n34  \n35#if defined(CONFIG_KPROBES)  \n36#define HAVE_KPROBES 1\n\n37#if defined(CONFIG_X86_64)  \n38/* If you have tried to use the syscall table to intercept syscalls and it \n\n39 * doesn't work, you can try to use Kprobes to intercept syscalls.\n\n40 * Set USE_KPROBES_PRE_HANDLER_BEFORE_SYSCALL to 1 to register a pre-handler  \n41 * before the syscall.\n\n42 */  \n43#define USE_KPROBES_PRE_HANDLER_BEFORE_SYSCALL 0  \n44#endif  \n45#include <linux/kprobes.h>\n\n46#else  \n47#define HAVE_PARAM 1  \n48#include <linux/kallsyms.h> /* For sprint_symbol */\n\n49/* The address of the sys_call_table, which can be obtained with looking up\n\n50 * \"/boot/System.map\" or \"/proc/kallsyms\". When the kernel version is v5.7+,\n\n51 * without CONFIG_KPROBES, you can input the parameter or the module will look\n\n52 * up all the memory.  \n53 */  \n54static unsigned long sym = 0;  \n55module_param(sym, ulong, 0644);\n\n56#endif /* CONFIG_KPROBES */  \n57  \n58#else  \n59  \n60#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 4, 0)\n\n61#define HAVE_KSYS_CLOSE 1  \n62#include <linux/syscalls.h> /* For ksys_close() */  \n63#else\n\n64#include <linux/kallsyms.h> /* For kallsyms_lookup_name */  \n65#endif  \n66  \n67#endif /* Version >= v5.7 */\n\n68  \n69/* UID we want to spy on - will be filled from the command line. */  \n70static uid_t uid = -1;\n\n71module_param(uid, int, 0644);  \n72  \n73#if USE_KPROBES_PRE_HANDLER_BEFORE_SYSCALL\n\n74  \n75/* syscall_sym is the symbol name of the syscall to spy on. The default is\n\n76 * \"__x64_sys_openat\", which can be changed by the module parameter. You can \n\n77 * look up the symbol name of a syscall in /proc/kallsyms.  \n78 */\n\n79static char *syscall_sym = \"__x64_sys_openat\";  \n80module_param(syscall_sym, charp, 0644);  \n81\n\n82static int sys_call_kprobe_pre_handler(struct kprobe *p, struct pt_regs *regs)\n\n83{  \n84    if (__kuid_val(current_uid()) != uid) {  \n85        return 0;  \n86    }  \n87\n\n88    pr_info(\"%s called by %d\\n\", syscall_sym, uid);  \n89    return 0;  \n90}  \n91\n\n92static struct kprobe syscall_kprobe = {  \n93    .symbol_name = \"__x64_sys_openat\",\n\n94    .pre_handler = sys_call_kprobe_pre_handler,  \n95};  \n96  \n97#else  \n98  \n99static unsigned long **sys_call_table_stolen;\n\n100  \n101/* A pointer to the original system call. The reason we keep this, rather\n\n102 * than call the original function (sys_openat), is because somebody else\n\n103 * might have replaced the system call before us. Note that this is not\n\n104 * 100% safe, because if another module replaced sys_openat before us,\n\n105 * then when we are inserted, we will call the function in that module -\n\n106 * and it might be removed before we are.  \n107 *  \n108 * Another reason for this is that we can not get sys_openat.\n\n109 * It is a static variable, so it is not exported.  \n110 */  \n111#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER\n\n112static asmlinkage long (*original_call)(const struct pt_regs *);  \n113#else\n\n114static asmlinkage long (*original_call)(int, const char __user *, int, umode_t);\n\n115#endif  \n116  \n117/* The function we will replace sys_openat (the function called when you\n\n118 * call the open system call) with. To find the exact prototype, with\n\n119 * the number and type of arguments, we find the original function first  \n120 * (it is at fs/open.c).\n\n121 *  \n122 * In theory, this means that we are tied to the current version of the\n\n123 * kernel. In practice, the system calls almost never change (it would\n\n124 * wreck havoc and require programs to be recompiled, since the system\n\n125 * calls are the interface between the kernel and the processes).  \n126 */\n\n127#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER  \n128static asmlinkage long our_sys_openat(const struct pt_regs *regs)\n\n129#else  \n130static asmlinkage long our_sys_openat(int dfd, const char __user *filename,\n\n131                                      int flags, umode_t mode)  \n132#endif  \n133{  \n134    int i = 0;\n\n135    char ch;  \n136  \n137    if (__kuid_val(current_uid()) != uid)  \n138        goto orig_call;  \n139\n\n140    /* Report the file, if relevant */  \n141    pr_info(\"Opened file by %d: \", uid);  \n142    do {\n\n143#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER  \n144        get_user(ch, (char __user *)regs->si + i);\n\n145#else  \n146        get_user(ch, (char __user *)filename + i);  \n147#endif  \n148        i++;\n\n149        pr_info(\"%c\", ch);  \n150    } while (ch != 0);  \n151    pr_info(\"\\n\");  \n152  \n153orig_call:\n\n154    /* Call the original sys_openat - otherwise, we lose the ability to  \n155     * open files.\n\n156     */  \n157#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER  \n158    return original_call(regs);\n\n159#else  \n160    return original_call(dfd, filename, flags, mode);  \n161#endif  \n162}  \n163\n\n164static unsigned long **acquire_sys_call_table(void)  \n165{  \n166#ifdef HAVE_KSYS_CLOSE\n\n167    unsigned long int offset = PAGE_OFFSET;  \n168    unsigned long **sct;\n\n169  \n170    while (offset < ULLONG_MAX) {  \n171        sct = (unsigned long **)offset;  \n172\n\n173        if (sct[__NR_close] == (unsigned long *)ksys_close)  \n174            return sct;  \n175\n\n176        offset += sizeof(void *);  \n177    }  \n178  \n179    return NULL;  \n180#endif  \n181  \n182#ifdef HAVE_PARAM\n\n183    const char sct_name[15] = \"sys_call_table\";  \n184    char symbol[40] = { 0 };  \n185  \n186    if (sym == 0) {\n\n187        pr_alert(\"For Linux v5.7+, Kprobes is the preferable way to get \"  \n188                 \"symbol.\\n\");\n\n189        pr_info(\"If Kprobes is absent, you have to specify the address of \"  \n190                \"sys_call_table symbol\\n\");\n\n191        pr_info(\"by /boot/System.map or /proc/kallsyms, which contains all the \"\n\n192                \"symbol addresses, into sym parameter.\\n\");  \n193        return NULL;  \n194    }\n\n195    sprint_symbol(symbol, sym);  \n196    if (!strncmp(sct_name, symbol, sizeof(sct_name) - 1))\n\n197        return (unsigned long **)sym;  \n198  \n199    return NULL;  \n200#endif  \n201\n\n202#ifdef HAVE_KPROBES  \n203    unsigned long (*kallsyms_lookup_name)(const char *name);\n\n204    struct kprobe kp = {  \n205        .symbol_name = \"kallsyms_lookup_name\",\n\n206    };  \n207  \n208    if (register_kprobe(&kp) < 0)  \n209        return NULL;\n\n210    kallsyms_lookup_name = (unsigned long (*)(const char *name))kp.addr;  \n211    unregister_kprobe(&kp);\n\n212#endif  \n213  \n214    return (unsigned long **)kallsyms_lookup_name(\"sys_call_table\");  \n215}  \n216\n\n217#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)  \n218static inline void __write_cr0(unsigned long cr0)\n\n219{  \n220    asm volatile(\"mov %0,%%cr0\" : \"+r\"(cr0) : : \"memory\");  \n221}  \n222#else  \n223#define __write_cr0 write_cr0\n\n224#endif  \n225  \n226static void enable_write_protection(void)  \n227{  \n228    unsigned long cr0 = read_cr0();\n\n229    set_bit(16, &cr0);  \n230    __write_cr0(cr0);  \n231}  \n232  \n233static void disable_write_protection(void)  \n234{\n\n235    unsigned long cr0 = read_cr0();  \n236    clear_bit(16, &cr0);  \n237    __write_cr0(cr0);  \n238}  \n239#endif\n\n240  \n241static int __init syscall_steal_start(void)  \n242{  \n243#if USE_KPROBES_PRE_HANDLER_BEFORE_SYSCALL\n\n244    int err;  \n245    /* use symbol name from the module parameter */\n\n246    syscall_kprobe.symbol_name = syscall_sym;  \n247    err = register_kprobe(&syscall_kprobe);\n\n248    if (err) {  \n249        pr_err(\"register_kprobe() on %s failed: %d\\n\", syscall_sym, err);\n\n250        pr_err(\"Please check the symbol name from 'syscall_sym' parameter.\\n\");  \n251        return err;\n\n252    }  \n253#else  \n254    if (!(sys_call_table_stolen = acquire_sys_call_table()))  \n255        return -1;\n\n256  \n257    disable_write_protection();  \n258  \n259    /* keep track of the original open function */\n\n260    original_call = (void *)sys_call_table_stolen[__NR_openat];  \n261  \n262    /* use our openat function instead */\n\n263    sys_call_table_stolen[__NR_openat] = (unsigned long *)our_sys_openat;  \n264\n\n265    enable_write_protection();  \n266#endif  \n267  \n268    pr_info(\"Spying on UID:%d\\n\", uid);  \n269    return 0;\n\n270}  \n271  \n272static void __exit syscall_steal_end(void)  \n273{  \n274#if USE_KPROBES_PRE_HANDLER_BEFORE_SYSCALL\n\n275    unregister_kprobe(&syscall_kprobe);  \n276#else  \n277    if (!sys_call_table_stolen)\n\n278        return;  \n279  \n280    /* Return the system call back to normal */\n\n281    if (sys_call_table_stolen[__NR_openat] != (unsigned long *)our_sys_openat) {\n\n282        pr_alert(\"Somebody else also played with the \");  \n283        pr_alert(\"open system call\\n\");\n\n284        pr_alert(\"The system may be left in \");  \n285        pr_alert(\"an unstable state.\\n\");  \n286    }  \n287\n\n288    disable_write_protection();  \n289    sys_call_table_stolen[__NR_openat] = (unsigned long *)original_call;\n\n290    enable_write_protection();  \n291#endif  \n292  \n293    msleep(2000);  \n294}  \n295  \n296module_init(syscall_steal_start);\n\n297module_exit(syscall_steal_end);  \n298 \n299MODULE_LICENSE(\"GPL\");\n```", "```\n  1tail -f\n```", "```\n$ sudo insmod sleep.ko\n$ cat_nonblock /proc/sleep\nLast input:\n$ tail -f /proc/sleep &\nLast input:\nLast input:\nLast input:\nLast input:\nLast input:\nLast input:\nLast input:\ntail: /proc/sleep: file truncated\n[1] 6540\n$ cat_nonblock /proc/sleep\nOpen would block\n$ kill %1\n[1]+  Terminated              tail -f /proc/sleep\n$ cat_nonblock /proc/sleep\nLast input:\n$\n\n```", "```\n 1/*   \n2 * sleep.c - create a /proc file, and if several processes try to open it\n\n3 * at the same time, put all but one to sleep.  \n4 */  \n5  \n6#include <linux/atomic.h>\n\n7#include <linux/fs.h>  \n8#include <linux/kernel.h> /* for sprintf() */\n\n9#include <linux/module.h> /* Specifically, a module */  \n10#include <linux/printk.h>\n\n11#include <linux/proc_fs.h> /* Necessary because we use proc fs */\n\n12#include <linux/types.h>  \n13#include <linux/uaccess.h> /* for get_user and put_user */\n\n14#include <linux/version.h>  \n15#include <linux/wait.h> /* For putting processes to sleep and\n\n16                                   waking them up */ \n17 \n18#include <asm/current.h>\n\n19#include <asm/errno.h>  \n20  \n21#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)  \n22#define HAVE_PROC_OPS\n\n23#endif  \n24  \n25/* Here we keep the last message received, to prove that we can process our\n\n26 * input.  \n27 */  \n28#define MESSAGE_LENGTH 80  \n29static char message[MESSAGE_LENGTH];  \n30\n\n31static struct proc_dir_entry *our_proc_file;  \n32#define PROC_ENTRY_FILENAME \"sleep\"  \n33\n\n34/* Since we use the file operations struct, we can't use the special proc\n\n35 * output provisions - we have to use a standard read function, which is this  \n36 * function.\n\n37 */  \n38static ssize_t module_output(struct file *file, /* see include/linux/fs.h   */\n\n39                             char __user *buf, /* The buffer to put data to\n\n40                                                   (in the user segment)    */\n\n41                             size_t len, /* The length of the buffer */\n\n42                             loff_t *offset)  \n43{  \n44    static int finished = 0;\n\n45    int i;  \n46    char output_msg[MESSAGE_LENGTH + 30];  \n47\n\n48    /* Return 0 to signify end of file - that we have nothing more to say\n\n49     * at this point.  \n50     */  \n51    if (finished) {  \n52        finished = 0;\n\n53        return 0;  \n54    }  \n55  \n56    sprintf(output_msg, \"Last input:%s\\n\", message);\n\n57    for (i = 0; i < len && output_msg[i]; i++)  \n58        put_user(output_msg[i], buf + i);\n\n59  \n60    finished = 1;  \n61    return i; /* Return the number of bytes \"read\" */  \n62}  \n63\n\n64/* This function receives input from the user when the user writes to the  \n65 * /proc file.\n\n66 */  \n67static ssize_t module_input(struct file *file, /* The file itself */\n\n68                            const char __user *buf, /* The buffer with input */\n\n69                            size_t length, /* The buffer's length */\n\n70                            loff_t *offset) /* offset to file - ignore */  \n71{\n\n72    int i;  \n73  \n74    /* Put the input into message, where module_output will later be able\n\n75     * to use it.  \n76     */  \n77    for (i = 0; i < MESSAGE_LENGTH - 1 && i < length; i++)\n\n78        get_user(message[i], buf + i);  \n79    /* we want a standard, zero terminated string */\n\n80    message[i] = '\\0';  \n81  \n82    /* We need to return the number of input characters used */\n\n83    return i;  \n84}  \n85  \n86/* 1 if the file is currently open by somebody */\n\n87static atomic_t already_open = ATOMIC_INIT(0);  \n88  \n89/* Queue of processes who want our file */\n\n90static DECLARE_WAIT_QUEUE_HEAD(waitq);  \n91  \n92/* Called when the /proc file is opened */\n\n93static int module_open(struct inode *inode, struct file *file)  \n94{\n\n95    /* Try to get without blocking  */  \n96    if (!atomic_cmpxchg(&already_open, 0, 1)) {\n\n97        /* Success without blocking, allow the access */  \n98        return 0;  \n99    }\n\n100    /* If the file's flags include O_NONBLOCK, it means the process does not\n\n101     * want to wait for the file. In this case, because the file is already open,\n\n102     * we should fail with -EAGAIN, meaning \"you will have to try again\",\n\n103     * instead of blocking a process which would rather stay awake.\n\n104     */  \n105    if (file->f_flags & O_NONBLOCK)  \n106        return -EAGAIN;  \n107\n\n108    while (atomic_cmpxchg(&already_open, 0, 1)) {  \n109        int i, is_sig = 0;\n\n110  \n111        /* This function puts the current process, including any system\n\n112         * calls, such as us, to sleep.  Execution will be resumed right\n\n113         * after the function call, either because somebody called\n\n114         * wake_up(&waitq) (only module_close does that, when the file\n\n115         * is closed) or when a signal, such as Ctrl-C, is sent  \n116         * to the process\n\n117         */  \n118        wait_event_interruptible(waitq, !atomic_read(&already_open));  \n119\n\n120        /* If we woke up because we got a signal we're not blocking,\n\n121         * return -EINTR (fail the system call).  This allows processes\n\n122         * to be killed or stopped.  \n123         */  \n124        for (i = 0; i < _NSIG_WORDS && !is_sig; i++)\n\n125            is_sig = current->pending.signal.sig[i] & ~current->blocked.sig[i];  \n126\n\n127        if (is_sig) {  \n128            /* Return -EINTR if we got a signal */  \n129            return -EINTR;\n\n130        }  \n131    }  \n132  \n133    return 0; /* Allow the access */  \n134}  \n135  \n136/* Called when the /proc file is closed */\n\n137static int module_close(struct inode *inode, struct file *file)  \n138{\n\n139    /* Set already_open to zero, so one of the processes in the waitq will\n\n140     * be able to set already_open back to one and to open the file. All\n\n141     * the other processes will be called when already_open is back to one,\n\n142     * so they'll go back to sleep.  \n143     */  \n144    atomic_set(&already_open, 0);  \n145\n\n146    /* Wake up all the processes in waitq, so if anybody is waiting for the\n\n147     * file, they can have it.  \n148     */  \n149    wake_up(&waitq);  \n150  \n151    return 0; /* success */  \n152}  \n153\n\n154/* Structures to register as the /proc file, with pointers to all the relevant  \n155 * functions.\n\n156 */  \n157  \n158/* File operations for our /proc file. This is where we place pointers to all\n\n159 * the functions called when somebody tries to do something to our file. NULL\n\n160 * means we don't want to deal with something.  \n161 */  \n162#ifdef HAVE_PROC_OPS\n\n163static const struct proc_ops file_ops_4_our_proc_file = {\n\n164    .proc_read = module_output, /* \"read\" from the file */\n\n165    .proc_write = module_input, /* \"write\" to the file */\n\n166    .proc_open = module_open, /* called when the /proc file is opened */\n\n167    .proc_release = module_close, /* called when it's closed */\n\n168    .proc_lseek = noop_llseek, /* return file->f_pos */  \n169};  \n170#else\n\n171static const struct file_operations file_ops_4_our_proc_file = {\n\n172    .read = module_output,  \n173    .write = module_input,  \n174    .open = module_open,\n\n175    .release = module_close,  \n176    .llseek = noop_llseek,  \n177};  \n178#endif  \n179\n\n180/* Initialize the module - register the /proc file */  \n181static int __init sleep_init(void)  \n182{\n\n183    our_proc_file =  \n184        proc_create(PROC_ENTRY_FILENAME, 0644, NULL, &file_ops_4_our_proc_file);\n\n185    if (our_proc_file == NULL) {  \n186        pr_debug(\"Error: Could not initialize /proc/%s\\n\", PROC_ENTRY_FILENAME);\n\n187        return -ENOMEM;  \n188    }  \n189    proc_set_size(our_proc_file, 80);\n\n190    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);  \n191\n\n192    pr_info(\"/proc/%s created\\n\", PROC_ENTRY_FILENAME);  \n193  \n194    return 0;  \n195}  \n196\n\n197/* Cleanup - unregister our file from /proc.  This could get dangerous if\n\n198 * there are still processes waiting in waitq, because they are inside our\n\n199 * open function, which will get unloaded. I'll explain how to avoid removal\n\n200 * of a kernel module in such a case in chapter 10.  \n201 */  \n202static void __exit sleep_exit(void)  \n203{\n\n204    remove_proc_entry(PROC_ENTRY_FILENAME, NULL);  \n205    pr_debug(\"/proc/%s removed\\n\", PROC_ENTRY_FILENAME);\n\n206}  \n207  \n208module_init(sleep_init);  \n209module_exit(sleep_exit);  \n210 \n211MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 *  cat_nonblock.c - open a file and display its contents, but exit rather than\n\n3 *  wait for input.  \n4 */  \n5#include <errno.h> /* for errno */  \n6#include <fcntl.h> /* for open */\n\n7#include <stdio.h> /* standard I/O */  \n8#include <stdlib.h> /* for exit */\n\n9#include <unistd.h> /* for read */  \n10  \n11#define MAX_BYTES 1024 * 4  \n12  \n13int main(int argc, char *argv[])  \n14{\n\n15    int fd; /* The file descriptor for the file to read */  \n16    size_t bytes; /* The number of bytes read */\n\n17    char buffer[MAX_BYTES]; /* The buffer for the bytes */  \n18  \n19    /* Usage */\n\n20    if (argc != 2) {  \n21        printf(\"Usage: %s <filename>\\n\", argv[0]);\n\n22        puts(\"Reads the content of a file, but doesn't wait for input\");\n\n23        exit(EXIT_FAILURE);  \n24    }  \n25  \n26    /* Open the file for reading in non blocking mode */\n\n27    fd = open(argv[1], O_RDONLY | O_NONBLOCK);  \n28  \n29    /* If open failed */\n\n30    if (fd == -1) {  \n31        puts(errno == EAGAIN ? \"Open would block\" : \"Open failed\");\n\n32        exit(EXIT_FAILURE);  \n33    }  \n34  \n35    /* Read the file and output its contents */  \n36    do {\n\n37        /* Read characters from the file */  \n38        bytes = read(fd, buffer, MAX_BYTES);\n\n39  \n40        /* If there's an error, report it and die */  \n41        if (bytes == -1) {\n\n42            if (errno == EAGAIN)  \n43                puts(\"Normally I'd block, but you told me not to\");\n\n44            else  \n45                puts(\"Another read error\");  \n46            exit(EXIT_FAILURE);\n\n47        }  \n48  \n49        /* Print the characters */  \n50        if (bytes > 0) {\n\n51            for (int i = 0; i < bytes; i++)  \n52                putchar(buffer[i]);  \n53        }  \n54\n\n55        /* While there are no errors and the file isn't over */  \n56    } while (bytes > 0);\n\n57  \n58    close(fd);  \n59    return 0; \n60}\n```", "```\n 1/*   \n2 * completions.c  \n3 */  \n4#include <linux/completion.h>\n\n5#include <linux/err.h> /* for IS_ERR() */  \n6#include <linux/init.h>  \n7#include <linux/kthread.h>\n\n8#include <linux/module.h>  \n9#include <linux/printk.h>  \n10#include <linux/version.h>  \n11\n\n12static struct completion crank_comp;  \n13static struct completion flywheel_comp;  \n14\n\n15static int machine_crank_thread(void *arg)  \n16{  \n17    pr_info(\"Turn the crank\\n\");  \n18\n\n19    complete_all(&crank_comp);  \n20#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)\n\n21    kthread_complete_and_exit(&crank_comp, 0);  \n22#else  \n23    complete_and_exit(&crank_comp, 0);\n\n24#endif  \n25}  \n26  \n27static int machine_flywheel_spinup_thread(void *arg)  \n28{\n\n29    wait_for_completion(&crank_comp);  \n30  \n31    pr_info(\"Flywheel spins up\\n\");  \n32\n\n33    complete_all(&flywheel_comp);  \n34#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)\n\n35    kthread_complete_and_exit(&flywheel_comp, 0);  \n36#else  \n37    complete_and_exit(&flywheel_comp, 0);\n\n38#endif  \n39}  \n40  \n41static int __init completions_init(void)  \n42{  \n43    struct task_struct *crank_thread;\n\n44    struct task_struct *flywheel_thread;  \n45  \n46    pr_info(\"completions example\\n\");\n\n47  \n48    init_completion(&crank_comp);  \n49    init_completion(&flywheel_comp);  \n50\n\n51    crank_thread = kthread_create(machine_crank_thread, NULL, \"KThread Crank\");\n\n52    if (IS_ERR(crank_thread))  \n53        goto ERROR_THREAD_1;  \n54\n\n55    flywheel_thread = kthread_create(machine_flywheel_spinup_thread, NULL,\n\n56                                     \"KThread Flywheel\");  \n57    if (IS_ERR(flywheel_thread))\n\n58        goto ERROR_THREAD_2;  \n59  \n60    wake_up_process(flywheel_thread);\n\n61    wake_up_process(crank_thread);  \n62  \n63    return 0;  \n64  \n65ERROR_THREAD_2:  \n66    kthread_stop(crank_thread);\n\n67ERROR_THREAD_1:  \n68  \n69    return -1;  \n70}  \n71  \n72static void __exit completions_exit(void)  \n73{\n\n74    wait_for_completion(&crank_comp);  \n75    wait_for_completion(&flywheel_comp);  \n76\n\n77    pr_info(\"completions exit\\n\");  \n78}  \n79  \n80module_init(completions_init);\n\n81module_exit(completions_exit);  \n82  \n83MODULE_DESCRIPTION(\"Completions example\"); \n84MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * example_mutex.c  \n3 */  \n4#include <linux/module.h>  \n5#include <linux/mutex.h>\n\n6#include <linux/printk.h>  \n7  \n8static DEFINE_MUTEX(mymutex);  \n9  \n10static int __init example_mutex_init(void)\n\n11{  \n12    int ret;  \n13  \n14    pr_info(\"example_mutex init\\n\");  \n15  \n16    ret = mutex_trylock(&mymutex);\n\n17    if (ret != 0) {  \n18        pr_info(\"mutex is locked\\n\");  \n19  \n20        if (mutex_is_locked(&mymutex) == 0)\n\n21            pr_info(\"The mutex failed to lock!\\n\");  \n22  \n23        mutex_unlock(&mymutex);\n\n24        pr_info(\"mutex is unlocked\\n\");  \n25    } else  \n26        pr_info(\"Failed to lock\\n\");  \n27\n\n28    return 0;  \n29}  \n30  \n31static void __exit example_mutex_exit(void)  \n32{  \n33    pr_info(\"example_mutex exit\\n\");\n\n34}  \n35  \n36module_init(example_mutex_init);  \n37module_exit(example_mutex_exit);  \n38\n\n39MODULE_DESCRIPTION(\"Mutex example\"); \n40MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * example_spinlock.c  \n3 */  \n4#include <linux/init.h>  \n5#include <linux/module.h>\n\n6#include <linux/printk.h>  \n7#include <linux/spinlock.h>  \n8  \n9static DEFINE_SPINLOCK(sl_static);\n\n10static spinlock_t sl_dynamic;  \n11  \n12static void example_spinlock_static(void)  \n13{  \n14    unsigned long flags;\n\n15  \n16    spin_lock_irqsave(&sl_static, flags);  \n17    pr_info(\"Locked static spinlock\\n\");\n\n18  \n19    /* Do something or other safely. Because this uses 100% CPU time, this\n\n20     * code should take no more than a few milliseconds to run.  \n21     */  \n22\n\n23    spin_unlock_irqrestore(&sl_static, flags);  \n24    pr_info(\"Unlocked static spinlock\\n\");  \n25}  \n26\n\n27static void example_spinlock_dynamic(void)  \n28{  \n29    unsigned long flags;  \n30  \n31    spin_lock_init(&sl_dynamic);\n\n32    spin_lock_irqsave(&sl_dynamic, flags);  \n33    pr_info(\"Locked dynamic spinlock\\n\");\n\n34  \n35    /* Do something or other safely. Because this uses 100% CPU time, this\n\n36     * code should take no more than a few milliseconds to run.  \n37     */  \n38\n\n39    spin_unlock_irqrestore(&sl_dynamic, flags);  \n40    pr_info(\"Unlocked dynamic spinlock\\n\");  \n41}\n\n42  \n43static int __init example_spinlock_init(void)  \n44{  \n45    pr_info(\"example spinlock started\\n\");\n\n46  \n47    example_spinlock_static();  \n48    example_spinlock_dynamic();  \n49  \n50    return 0;  \n51}  \n52\n\n53static void __exit example_spinlock_exit(void)  \n54{  \n55    pr_info(\"example spinlock exit\\n\");\n\n56}  \n57  \n58module_init(example_spinlock_init);  \n59module_exit(example_spinlock_exit);  \n60\n\n61MODULE_DESCRIPTION(\"Spinlock example\"); \n62MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * example_rwlock.c  \n3 */  \n4#include <linux/module.h>  \n5#include <linux/printk.h>\n\n6#include <linux/rwlock.h>  \n7  \n8static DEFINE_RWLOCK(myrwlock);  \n9  \n10static void example_read_lock(void)  \n11{\n\n12    unsigned long flags;  \n13  \n14    read_lock_irqsave(&myrwlock, flags);  \n15    pr_info(\"Read Locked\\n\");\n\n16  \n17    /* Read from something */  \n18  \n19    read_unlock_irqrestore(&myrwlock, flags);\n\n20    pr_info(\"Read Unlocked\\n\");  \n21}  \n22  \n23static void example_write_lock(void)\n\n24{  \n25    unsigned long flags;  \n26  \n27    write_lock_irqsave(&myrwlock, flags);\n\n28    pr_info(\"Write Locked\\n\");  \n29  \n30    /* Write to something */  \n31\n\n32    write_unlock_irqrestore(&myrwlock, flags);  \n33    pr_info(\"Write Unlocked\\n\");  \n34}  \n35\n\n36static int __init example_rwlock_init(void)  \n37{  \n38    pr_info(\"example_rwlock started\\n\");  \n39\n\n40    example_read_lock();  \n41    example_write_lock();  \n42  \n43    return 0;  \n44}  \n45\n\n46static void __exit example_rwlock_exit(void)  \n47{  \n48    pr_info(\"example_rwlock exit\\n\");\n\n49}  \n50  \n51module_init(example_rwlock_init);  \n52module_exit(example_rwlock_exit);  \n53\n\n54MODULE_DESCRIPTION(\"Read/Write locks example\"); \n55MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * example_atomic.c  \n3 */  \n4#include <linux/atomic.h>  \n5#include <linux/bitops.h>\n\n6#include <linux/module.h>  \n7#include <linux/printk.h>  \n8  \n9#define BYTE_TO_BINARY_PATTERN \"%c%c%c%c%c%c%c%c\"\n\n10#define BYTE_TO_BINARY(byte)                                                   \\\n\n11    ((byte & 0x80) ? '1' : '0'), ((byte & 0x40) ? '1' : '0'),                  \\\n\n12        ((byte & 0x20) ? '1' : '0'), ((byte & 0x10) ? '1' : '0'),              \\\n\n13        ((byte & 0x08) ? '1' : '0'), ((byte & 0x04) ? '1' : '0'),              \\\n\n14        ((byte & 0x02) ? '1' : '0'), ((byte & 0x01) ? '1' : '0')  \n15\n\n16static void atomic_add_subtract(void)  \n17{  \n18    atomic_t debbie;  \n19    atomic_t chris = ATOMIC_INIT(50);\n\n20  \n21    atomic_set(&debbie, 45);  \n22  \n23    /* subtract one */  \n24    atomic_dec(&debbie);  \n25\n\n26    atomic_add(7, &debbie);  \n27  \n28    /* add one */  \n29    atomic_inc(&debbie);  \n30\n\n31    pr_info(\"chris: %d, debbie: %d\\n\", atomic_read(&chris),  \n32            atomic_read(&debbie));\n\n33}  \n34  \n35static void atomic_bitwise(void)  \n36{  \n37    unsigned long word = 0;  \n38\n\n39    pr_info(\"Bits 0: \" BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));  \n40    set_bit(3, &word);\n\n41    set_bit(5, &word);  \n42    pr_info(\"Bits 1: \" BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));\n\n43    clear_bit(5, &word);  \n44    pr_info(\"Bits 2: \" BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));\n\n45    change_bit(3, &word);  \n46  \n47    pr_info(\"Bits 3: \" BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));\n\n48    if (test_and_set_bit(3, &word))  \n49        pr_info(\"wrong\\n\");\n\n50    pr_info(\"Bits 4: \" BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));  \n51  \n52    word = 255;\n\n53    pr_info(\"Bits 5: \" BYTE_TO_BINARY_PATTERN \"\\n\", BYTE_TO_BINARY(word));  \n54}  \n55\n\n56static int __init example_atomic_init(void)  \n57{  \n58    pr_info(\"example_atomic started\\n\");\n\n59  \n60    atomic_add_subtract();  \n61    atomic_bitwise();  \n62  \n63    return 0;  \n64}  \n65\n\n66static void __exit example_atomic_exit(void)  \n67{  \n68    pr_info(\"example_atomic exit\\n\");\n\n69}  \n70  \n71module_init(example_atomic_init);  \n72module_exit(example_atomic_exit);  \n73\n\n74MODULE_DESCRIPTION(\"Atomic operations example\"); \n75MODULE_LICENSE(\"GPL\");\n```", "```\n 1/*   \n2 * print_string.c - Send output to the tty we're running on, regardless if\n\n3 * it is through X11, telnet, etc.  We do this by printing the string to the\n\n4 * tty associated with the current task.  \n5 */  \n6#include <linux/init.h>  \n7#include <linux/kernel.h>\n\n8#include <linux/module.h>  \n9#include <linux/sched.h> /* For current */\n\n10#include <linux/tty.h> /* For the tty declarations */  \n11  \n12static void print_string(char *str)\n\n13{  \n14    /* The tty for the current task */  \n15    struct tty_struct *my_tty = get_current_tty();\n\n16  \n17    /* If my_tty is NULL, the current task has no tty you can print to (i.e.,\n\n18     * if it is a daemon). If so, there is nothing we can do.  \n19     */\n\n20    if (my_tty) {  \n21        const struct tty_operations *ttyops = my_tty->driver->ops;\n\n22        /* my_tty->driver is a struct which holds the tty's functions,\n\n23         * one of which (write) is used to write strings to the tty.\n\n24         * It can be used to take a string either from the user's or  \n25         * kernel's memory segment.\n\n26         *  \n27         * The function's 1st parameter is the tty to write to, because the\n\n28         * same function would normally be used for all tty's of a certain\n\n29         * type.  \n30         * The 2nd parameter is a pointer to a string.\n\n31         * The 3rd parameter is the length of the string.  \n32         *\n\n33         * As you will see below, sometimes it's necessary to use\n\n34         * preprocessor stuff to create code that works for different\n\n35         * kernel versions. The (naive) approach we've taken here does not\n\n36         * scale well. The right way to deal with this is described in\n\n37         * section 2 of  \n38         * linux/Documentation/SubmittingPatches\n\n39         */  \n40        (ttyops->write)(my_tty, /* The tty itself */\n\n41                        str, /* String */  \n42                        strlen(str)); /* Length */\n\n43  \n44        /* ttys were originally hardware devices, which (usually) strictly\n\n45         * followed the ASCII standard. In ASCII, to move to a new line you\n\n46         * need two characters, a carriage return and a line feed. On Unix,\n\n47         * the ASCII line feed is used for both purposes - so we can not\n\n48         * just use \\n, because it would not have a carriage return and the\n\n49         * next line will start at the column right after the line feed.  \n50         *\n\n51         * This is why text files are different between Unix and MS Windows.\n\n52         * In CP/M and derivatives, like MS-DOS and MS Windows, the ASCII\n\n53         * standard was strictly adhered to, and therefore a newline requires\n\n54         * both a LF and a CR.  \n55         */  \n56        (ttyops->write)(my_tty, \"\\015\\012\", 2);  \n57    }  \n58}  \n59\n\n60static int __init print_string_init(void)  \n61{  \n62    print_string(\"The module has been inserted.  Hello world!\");\n\n63    return 0;  \n64}  \n65  \n66static void __exit print_string_exit(void)  \n67{\n\n68    print_string(\"The module has been removed.  Farewell world!\");  \n69}  \n70\n\n71module_init(print_string_init);  \n72module_exit(print_string_exit);  \n73 \n74MODULE_LICENSE(\"GPL\");\n```", "```\n 1struct timer_list {   \n2    unsigned long expires;  \n3    void (*function)(unsigned long);\n\n4    unsigned long data;  \n5    u32 flags;  \n6    /* ... */  \n7};  \n8\n\n9void setup_timer(struct timer_list *timer, void (*callback)(unsigned long), \n10                 unsigned long data);\n```", "```\n 1void timer_setup(struct timer_list *timer,\n\n2                 void (*callback)(struct timer_list *), unsigned int flags);\n```", "```\n 1struct timer_list {   \n2    unsigned long expires;  \n3    void (*function)(struct timer_list *);\n\n4    u32 flags;  \n5    /* ... */ \n6};\n```", "```\n 1/*   \n2 * kbleds.c - Blink keyboard leds until the module is unloaded.  \n3 */  \n4\n\n5#include <linux/init.h>  \n6#include <linux/kd.h> /* For KDSETLED */  \n7#include <linux/module.h>\n\n8#include <linux/tty.h> /* For tty_struct */  \n9#include <linux/vt.h> /* For MAX_NR_CONSOLES */\n\n10#include <linux/vt_kern.h> /* for fg_console */  \n11#include <linux/console_struct.h> /* For vc_cons */\n\n12  \n13MODULE_DESCRIPTION(\"Example module illustrating the use of Keyboard LEDs.\");\n\n14  \n15static struct timer_list my_timer;  \n16static struct tty_driver *my_driver;\n\n17static unsigned long kbledstatus = 0;  \n18  \n19#define BLINK_DELAY HZ / 5  \n20#define ALL_LEDS_ON 0x07\n\n21#define RESTORE_LEDS 0xFF  \n22  \n23/* Function my_timer_func blinks the keyboard LEDs periodically by invoking\n\n24 * command KDSETLED of ioctl() on the keyboard driver. To learn more on virtual\n\n25 * terminal ioctl operations, please see file:  \n26 *   drivers/tty/vt/vt_ioctl.c, function vt_ioctl().\n\n27 *  \n28 * The argument to KDSETLED is alternatively set to 7 (thus causing the led\n\n29 * mode to be set to LED_SHOW_IOCTL, and all the leds are lit) and to 0xFF\n\n30 * (any value above 7 switches back the led mode to LED_SHOW_FLAGS, thus\n\n31 * the LEDs reflect the actual keyboard status).  To learn more on this,\n\n32 * please see file: drivers/tty/vt/keyboard.c, function setledstate().\n\n33 */  \n34static void my_timer_func(struct timer_list *unused)  \n35{\n\n36    struct tty_struct *t = vc_cons[fg_console].d->port.tty;  \n37  \n38    if (kbledstatus == ALL_LEDS_ON)\n\n39        kbledstatus = RESTORE_LEDS;  \n40    else  \n41        kbledstatus = ALL_LEDS_ON;  \n42\n\n43    (my_driver->ops->ioctl)(t, KDSETLED, kbledstatus);  \n44  \n45    my_timer.expires = jiffies + BLINK_DELAY;\n\n46    add_timer(&my_timer);  \n47}  \n48  \n49static int __init kbleds_init(void)  \n50{  \n51    int i;  \n52\n\n53    pr_info(\"kbleds: loading\\n\");  \n54    pr_info(\"kbleds: fgconsole is %x\\n\", fg_console);\n\n55    for (i = 0; i < MAX_NR_CONSOLES; i++) {  \n56        if (!vc_cons[i].d)  \n57            break;\n\n58        pr_info(\"poet_atkm: console[%i/%i] #%i, tty %p\\n\", i, MAX_NR_CONSOLES,\n\n59                vc_cons[i].d->vc_num, (void *)vc_cons[i].d->port.tty);\n\n60    }  \n61    pr_info(\"kbleds: finished scanning consoles\\n\");\n\n62  \n63    my_driver = vc_cons[fg_console].d->port.tty->driver;\n\n64    pr_info(\"kbleds: tty driver name %s\\n\", my_driver->driver_name);  \n65\n\n66    /* Set up the LED blink timer the first time. */  \n67    timer_setup(&my_timer, my_timer_func, 0);\n\n68    my_timer.expires = jiffies + BLINK_DELAY;  \n69    add_timer(&my_timer);  \n70  \n71    return 0;  \n72}\n\n73  \n74static void __exit kbleds_cleanup(void)  \n75{  \n76    pr_info(\"kbleds: unloading...\\n\");\n\n77    del_timer(&my_timer);  \n78    (my_driver->ops->ioctl)(vc_cons[fg_console].d->port.tty, KDSETLED,\n\n79                            RESTORE_LEDS);  \n80}  \n81  \n82module_init(kbleds_init);\n\n83module_exit(kbleds_cleanup);  \n84 \n85MODULE_LICENSE(\"GPL\");\n```", "```\n  1cat /sys/kernel/debug/gpio\n```", "```\n 1/*   \n2 * led.c - Using GPIO to control the LED on/off  \n3 */  \n4   \n5#include <linux/cdev.h>\n\n6#include <linux/delay.h>  \n7#include <linux/device.h>  \n8#include <linux/fs.h>\n\n9#include <linux/gpio.h>  \n10#include <linux/init.h>  \n11#include <linux/module.h>\n\n12#include <linux/printk.h>  \n13#include <linux/types.h>  \n14#include <linux/uaccess.h>\n\n15#include <linux/version.h>  \n16  \n17#include <asm/errno.h>  \n18  \n19#define DEVICE_NAME \"gpio_led\"\n\n20#define DEVICE_CNT 1  \n21#define BUF_LEN 2  \n22  \n23static char control_signal[BUF_LEN];\n\n24static unsigned long device_buffer_size = 0;  \n25  \n26struct LED_dev {  \n27    dev_t dev_num;\n\n28    int major_num, minor_num;  \n29    struct cdev cdev;  \n30    struct class *cls;\n\n31    struct device *dev;  \n32};  \n33  \n34static struct LED_dev led_device;  \n35  \n36/* Define GPIOs for LEDs.\n\n37 * TODO: According to the requirements, search /sys/kernel/debug/gpio to \n\n38 * find the corresponding GPIO location.  \n39 */  \n40static struct gpio leds[] = { { 4, GPIOF_OUT_INIT_LOW, \"LED 1\" } };\n\n41  \n42/* This is called whenever a process attempts to open the device file */\n\n43static int device_open(struct inode *inode, struct file *file)  \n44{  \n45    return 0;  \n46}  \n47\n\n48static int device_release(struct inode *inode, struct file *file)  \n49{  \n50    return 0;\n\n51}  \n52  \n53static ssize_t device_write(struct file *file, const char __user *buffer,\n\n54                            size_t length, loff_t *offset)  \n55{  \n56    device_buffer_size = min(BUF_LEN, length);\n\n57  \n58    if (copy_from_user(control_signal, buffer, device_buffer_size)) {  \n59        return -EFAULT;  \n60    }  \n61\n\n62    /* Determine the received signal to decide the LED on/off state. */  \n63    switch (control_signal[0]) {\n\n64    case '0':  \n65        gpio_set_value(leds[0].gpio, 0);  \n66        pr_info(\"LED OFF\");\n\n67        break;  \n68    case '1':  \n69        gpio_set_value(leds[0].gpio, 1);  \n70        pr_info(\"LED ON\");\n\n71        break;  \n72    default:  \n73        pr_warn(\"Invalid value!\\n\");  \n74        break;  \n75    }  \n76\n\n77    *offset += device_buffer_size;  \n78  \n79    /* Again, return the number of input characters used. */\n\n80    return device_buffer_size;  \n81}  \n82  \n83static struct file_operations fops = {\n\n84#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)  \n85    .owner = THIS_MODULE,  \n86#endif\n\n87    .write = device_write,  \n88    .open = device_open,  \n89    .release = device_release,  \n90};  \n91\n\n92/* Initialize the module - Register the character device */  \n93static int __init led_init(void)  \n94{\n\n95    int ret = 0;  \n96  \n97    /* Determine whether dynamic allocation of the device number is needed. */\n\n98    if (led_device.major_num) {  \n99        led_device.dev_num = MKDEV(led_device.major_num, led_device.minor_num);\n\n100        ret =  \n101            register_chrdev_region(led_device.dev_num, DEVICE_CNT, DEVICE_NAME);\n\n102    } else {  \n103        ret = alloc_chrdev_region(&led_device.dev_num, 0, DEVICE_CNT,\n\n104                                  DEVICE_NAME);  \n105    }  \n106  \n107    /* Negative values signify an error */\n\n108    if (ret < 0) {  \n109        pr_alert(\"Failed to register character device, error: %d\\n\", ret);\n\n110        return ret;  \n111    }  \n112  \n113    pr_info(\"Major = %d, Minor = %d\\n\", MAJOR(led_device.dev_num),\n\n114            MINOR(led_device.dev_num));  \n115  \n116    /* Prevents module unloading while operations are in use */\n\n117#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)  \n118    led_device.cdev.owner = THIS_MODULE;  \n119#endif  \n120\n\n121    cdev_init(&led_device.cdev, &fops);  \n122    ret = cdev_add(&led_device.cdev, led_device.dev_num, 1);\n\n123    if (ret) {  \n124        pr_err(\"Failed to add the device to the system\\n\");  \n125        goto fail1;  \n126    }\n\n127  \n128#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)  \n129    led_device.cls = class_create(DEVICE_NAME);\n\n130#else  \n131    led_device.cls = class_create(THIS_MODULE, DEVICE_NAME);  \n132#endif\n\n133    if (IS_ERR(led_device.cls)) {  \n134        pr_err(\"Failed to create class for device\\n\");\n\n135        ret = PTR_ERR(led_device.cls);  \n136        goto fail2;  \n137    }  \n138\n\n139    led_device.dev = device_create(led_device.cls, NULL, led_device.dev_num,\n\n140                                   NULL, DEVICE_NAME);  \n141    if (IS_ERR(led_device.dev)) {\n\n142        pr_err(\"Failed to create the device file\\n\");  \n143        ret = PTR_ERR(led_device.dev);\n\n144        goto fail3;  \n145    }  \n146  \n147    pr_info(\"Device created on /dev/%s\\n\", DEVICE_NAME);  \n148\n\n149    ret = gpio_request(leds[0].gpio, leds[0].label);  \n150  \n151    if (ret) {\n\n152        pr_err(\"Unable to request GPIOs for LEDs: %d\\n\", ret);  \n153        goto fail4;\n\n154    }  \n155  \n156    ret = gpio_direction_output(leds[0].gpio, leds[0].flags);  \n157\n\n158    if (ret) {  \n159        pr_err(\"Failed to set GPIO %d direction\\n\", leds[0].gpio);\n\n160        goto fail5;  \n161    }  \n162  \n163    return 0;  \n164  \n165fail5:  \n166    gpio_free(leds[0].gpio);  \n167\n\n168fail4:  \n169    device_destroy(led_device.cls, led_device.dev_num);  \n170  \n171fail3:\n\n172    class_destroy(led_device.cls);  \n173  \n174fail2:  \n175    cdev_del(&led_device.cdev);  \n176  \n177fail1:\n\n178    unregister_chrdev_region(led_device.dev_num, DEVICE_CNT);  \n179  \n180    return ret;\n\n181}  \n182  \n183static void __exit led_exit(void)  \n184{  \n185    gpio_set_value(leds[0].gpio, 0);\n\n186    gpio_free(leds[0].gpio);  \n187  \n188    device_destroy(led_device.cls, led_device.dev_num);\n\n189    class_destroy(led_device.cls);  \n190    cdev_del(&led_device.cdev);\n\n191    unregister_chrdev_region(led_device.dev_num, DEVICE_CNT);  \n192}  \n193  \n194module_init(led_init);\n\n195module_exit(led_exit);  \n196 \n197MODULE_LICENSE(\"GPL\");\n```", "```\n  1make  \n2sudo insmod led.ko\n```", "```\n  1echo \"1\" | sudo tee /dev/gpio_led\n```", "```\n  1echo \"0\" | sudo tee /dev/gpio_led\n```", "```\n  1sudo rmmod led\n```", "```\n 1/*   \n2 *  dht11.c - Using GPIO to read temperature and humidity from DHT11 sensor.\n\n3 */  \n4  \n5#include <linux/cdev.h>  \n6#include <linux/delay.h>  \n7#include <linux/device.h>\n\n8#include <linux/fs.h>  \n9#include <linux/gpio.h>  \n10#include <linux/init.h>  \n11#include <linux/module.h>\n\n12#include <linux/printk.h>  \n13#include <linux/types.h>  \n14#include <linux/uaccess.h>\n\n15#include <linux/version.h>  \n16  \n17#include <asm/errno.h>  \n18  \n19#define GPIO_PIN_4 575\n\n20#define DEVICE_NAME \"dht11\"  \n21#define DEVICE_CNT 1  \n22  \n23static char msg[64];  \n24  \n25struct dht11_dev {\n\n26    dev_t dev_num;  \n27    int major_num, minor_num;  \n28    struct cdev cdev;  \n29    struct class *cls;\n\n30    struct device *dev;  \n31};  \n32  \n33static struct dht11_dev dht11_device;  \n34  \n35/* Define GPIOs for LEDs.\n\n36 * TODO: According to the requirements, search /sys/kernel/debug/gpio to   \n37 * find the corresponding GPIO location.\n\n38 */  \n39static struct gpio dht11[] = { { GPIO_PIN_4, GPIOF_OUT_INIT_HIGH, \"Signal\" } };  \n40\n\n41static int dht11_read_data(void)  \n42{  \n43    int timeout;  \n44    uint8_t sensor_data[5] = { 0 };\n\n45    uint8_t i, j;  \n46  \n47    gpio_set_value(dht11[0].gpio, 0);  \n48    mdelay(20);\n\n49    gpio_set_value(dht11[0].gpio, 1);  \n50    udelay(30);  \n51    gpio_direction_input(dht11[0].gpio);\n\n52    udelay(2);  \n53  \n54    timeout = 300;  \n55    while (gpio_get_value(dht11[0].gpio) && timeout--)\n\n56        udelay(1);  \n57  \n58    if (timeout == -1)  \n59        return -ETIMEDOUT;  \n60  \n61    timeout = 300;\n\n62    while (!gpio_get_value(dht11[0].gpio) && timeout--)  \n63        udelay(1);\n\n64  \n65    if (timeout == -1)  \n66        return -ETIMEDOUT;  \n67  \n68    timeout = 300;\n\n69    while (gpio_get_value(dht11[0].gpio) && timeout--)  \n70        udelay(1);  \n71\n\n72    if (timeout == -1)  \n73        return -ETIMEDOUT;  \n74  \n75    for (j = 0; j < 5; j++) {\n\n76        uint8_t byte = 0;  \n77        for (i = 0; i < 8; i++) {  \n78            timeout = 300;\n\n79            while (gpio_get_value(dht11[0].gpio) && timeout--)  \n80                udelay(1);  \n81\n\n82            if (timeout == -1)  \n83                return -ETIMEDOUT;  \n84  \n85            timeout = 300;\n\n86            while (!gpio_get_value(dht11[0].gpio) && timeout--)  \n87                udelay(1);  \n88\n\n89            if (timeout == -1)  \n90                return -ETIMEDOUT;  \n91  \n92            udelay(50);\n\n93            byte <<= 1;  \n94            if (gpio_get_value(dht11[0].gpio))\n\n95                byte |= 0x01;  \n96        }  \n97        sensor_data[j] = byte;  \n98    }\n\n99  \n100    if (sensor_data[4] != (uint8_t)(sensor_data[0] + sensor_data[1] +\n\n101                                    sensor_data[2] + sensor_data[3]))\n\n102        return -EIO;  \n103  \n104    gpio_direction_output(dht11[0].gpio, 1);\n\n105    sprintf(msg, \"Humidity: %d%%\\nTemperature: %d deg C\\n\", sensor_data[0],  \n106            sensor_data[2]);\n\n107  \n108    return 0;  \n109}  \n110  \n111static int device_open(struct inode *inode, struct file *file)\n\n112{  \n113    int ret, retry;  \n114  \n115    for (retry = 0; retry < 5; ++retry) {\n\n116        ret = dht11_read_data();  \n117        if (ret == 0)  \n118            return 0;\n\n119        msleep(10);  \n120    }  \n121    gpio_direction_output(dht11[0].gpio, 1);  \n122  \n123    return ret;\n\n124}  \n125  \n126static int device_release(struct inode *inode, struct file *file)  \n127{\n\n128    return 0;  \n129}  \n130  \n131static ssize_t device_read(struct file *filp, char __user *buffer,\n\n132                           size_t length, loff_t *offset)  \n133{  \n134    int msg_len = strlen(msg);  \n135\n\n136    if (*offset >= msg_len)  \n137        return 0;  \n138  \n139    size_t remain = msg_len - *offset;\n\n140    size_t bytes_read = min(length, remain);  \n141  \n142    if (copy_to_user(buffer, msg + *offset, bytes_read))\n\n143        return -EFAULT;  \n144  \n145    *offset += bytes_read;  \n146  \n147    return bytes_read;\n\n148}  \n149  \n150static struct file_operations fops = {  \n151    .owner = THIS_MODULE,\n\n152    .open = device_open,  \n153    .release = device_release,  \n154    .read = device_read,  \n155};  \n156\n\n157/* Initialize the module - Register the character device */  \n158static int __init dht11_init(void)  \n159{\n\n160    int ret = 0;  \n161  \n162    /* Determine whether dynamic allocation of the device number is needed. */\n\n163    if (dht11_device.major_num) {  \n164        dht11_device.dev_num =\n\n165            MKDEV(dht11_device.major_num, dht11_device.minor_num);\n\n166        ret = register_chrdev_region(dht11_device.dev_num, DEVICE_CNT,\n\n167                                     DEVICE_NAME);  \n168    } else {\n\n169        ret = alloc_chrdev_region(&dht11_device.dev_num, 0, DEVICE_CNT,\n\n170                                  DEVICE_NAME);  \n171    }  \n172  \n173    /* Negative values signify an error */\n\n174    if (ret < 0) {  \n175        pr_alert(\"Failed to register character device, error: %d\\n\", ret);\n\n176        return ret;  \n177    }  \n178  \n179    pr_info(\"Major = %d, Minor = %d\\n\", MAJOR(dht11_device.dev_num),\n\n180            MINOR(dht11_device.dev_num));  \n181  \n182    /* Prevents module unloading while operations are in use */\n\n183    dht11_device.cdev.owner = THIS_MODULE;  \n184  \n185    cdev_init(&dht11_device.cdev, &fops);\n\n186    ret = cdev_add(&dht11_device.cdev, dht11_device.dev_num, 1);  \n187    if (ret) {\n\n188        pr_err(\"Failed to add the device to the system\\n\");  \n189        goto fail1;  \n190    }  \n191\n\n192#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)  \n193    dht11_device.cls = class_create(DEVICE_NAME);\n\n194#else  \n195    dht11_device.cls = class_create(THIS_MODULE, DEVICE_NAME);  \n196#endif\n\n197    if (IS_ERR(dht11_device.cls)) {  \n198        pr_err(\"Failed to create class for device\\n\");\n\n199        ret = PTR_ERR(dht11_device.cls);  \n200        goto fail2;  \n201    }\n\n202  \n203    dht11_device.dev = device_create(dht11_device.cls, NULL,\n\n204                                     dht11_device.dev_num, NULL, DEVICE_NAME);\n\n205    if (IS_ERR(dht11_device.dev)) {  \n206        pr_err(\"Failed to create the device file\\n\");\n\n207        ret = PTR_ERR(dht11_device.dev);  \n208        goto fail3;\n\n209    }  \n210  \n211    pr_info(\"Device created on /dev/%s\\n\", DEVICE_NAME);  \n212\n\n213    ret = gpio_request(dht11[0].gpio, dht11[0].label);  \n214  \n215    if (ret) {\n\n216        pr_err(\"Unable to request GPIOs for dht11: %d\\n\", ret);  \n217        goto fail4;\n\n218    }  \n219  \n220    ret = gpio_direction_output(dht11[0].gpio, 1);  \n221  \n222    if (ret) {\n\n223        pr_err(\"Failed to set GPIO %d direction\\n\", dht11[0].gpio);\n\n224        goto fail5;  \n225    }  \n226  \n227    return 0;  \n228  \n229fail5:  \n230    gpio_free(dht11[0].gpio);\n\n231  \n232fail4:  \n233    device_destroy(dht11_device.cls, dht11_device.dev_num);  \n234  \n235fail3:\n\n236    class_destroy(dht11_device.cls);  \n237  \n238fail2:  \n239    cdev_del(&dht11_device.cdev);  \n240  \n241fail1:\n\n242    unregister_chrdev_region(dht11_device.dev_num, DEVICE_CNT);  \n243  \n244    return ret;  \n245}  \n246\n\n247static void __exit dht11_exit(void)  \n248{  \n249    gpio_set_value(dht11[0].gpio, 0);\n\n250    gpio_free(dht11[0].gpio);  \n251  \n252    device_destroy(dht11_device.cls, dht11_device.dev_num);\n\n253    class_destroy(dht11_device.cls);  \n254    cdev_del(&dht11_device.cdev);\n\n255    unregister_chrdev_region(dht11_device.dev_num, DEVICE_CNT);  \n256}  \n257  \n258module_init(dht11_init);\n\n259module_exit(dht11_exit);  \n260 \n261MODULE_LICENSE(\"GPL\");\n```", "```\n  1make  \n2sudo insmod dht11.ko\n```", "```\n  1sudo cat /dev/dht11\n```", "```\n$ sudo cat /dev/dht11\nHumidity: 61%\nTemperature: 30°C\n\n```", "```\n  1sudo rmmod dht11\n```", "```\n 1/*   \n2 * example_tasklet.c  \n3 */  \n4#include <linux/delay.h>\n\n5#include <linux/interrupt.h>  \n6#include <linux/module.h>  \n7#include <linux/printk.h>  \n8\n\n9/* Macro DECLARE_TASKLET_OLD exists for compatibility.  \n10 * See https://lwn.net/Articles/830964/  \n11 */\n\n12#ifndef DECLARE_TASKLET_OLD  \n13#define DECLARE_TASKLET_OLD(arg1, arg2) DECLARE_TASKLET(arg1, arg2, 0L)\n\n14#endif  \n15  \n16static void tasklet_fn(unsigned long data)  \n17{  \n18    pr_info(\"Example tasklet starts\\n\");\n\n19    mdelay(5000);  \n20    pr_info(\"Example tasklet ends\\n\");  \n21}  \n22\n\n23static DECLARE_TASKLET_OLD(mytask, tasklet_fn);  \n24  \n25static int __init example_tasklet_init(void)\n\n26{  \n27    pr_info(\"tasklet example init\\n\");  \n28    tasklet_schedule(&mytask);\n\n29    mdelay(200);  \n30    pr_info(\"Example tasklet init continues...\\n\");  \n31    return 0;  \n32}  \n33\n\n34static void __exit example_tasklet_exit(void)  \n35{  \n36    pr_info(\"tasklet example exit\\n\");\n\n37    tasklet_kill(&mytask);  \n38}  \n39  \n40module_init(example_tasklet_init);  \n41module_exit(example_tasklet_exit);\n\n42  \n43MODULE_DESCRIPTION(\"Tasklet example\"); \n44MODULE_LICENSE(\"GPL\");\n```", "```\ntasklet example init\nExample tasklet starts\nExample tasklet init continues...\nExample tasklet ends\n\n```", "```\n 1/*   \n2 * sched.c  \n3 */  \n4#include <linux/init.h>  \n5#include <linux/module.h>\n\n6#include <linux/workqueue.h>  \n7  \n8static struct workqueue_struct *queue = NULL;\n\n9static struct work_struct work;  \n10  \n11static void work_handler(struct work_struct *data)  \n12{\n\n13    pr_info(\"work handler function.\\n\");  \n14}  \n15  \n16static int __init sched_init(void)  \n17{\n\n18    queue = alloc_workqueue(\"HELLOWORLD\", WQ_UNBOUND, 1);  \n19    if (!queue) {\n\n20        pr_err(\"Failed to allocate workqueue\\n\");  \n21        return -ENOMEM;\n\n22    }  \n23    INIT_WORK(&work, work_handler);  \n24    queue_work(queue, &work);\n\n25    return 0;  \n26}  \n27  \n28static void __exit sched_exit(void)  \n29{  \n30    flush_workqueue(queue);\n\n31    destroy_workqueue(queue);  \n32}  \n33  \n34module_init(sched_init);  \n35module_exit(sched_exit);  \n36\n\n37MODULE_LICENSE(\"GPL\"); \n38MODULE_DESCRIPTION(\"Workqueue example\");\n```", "```\n 1/*   \n2 * intrpt.c - Handling GPIO with interrupts  \n3 *\n\n4 * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)\n\n5 * from:  \n6 *   https://github.com/wendlers/rpi-kmod-samples  \n7 *\n\n8 * Press one button to turn on a LED and another to turn it off.  \n9 */  \n10  \n11#include <linux/gpio.h>\n\n12#include <linux/interrupt.h>  \n13#include <linux/kernel.h> /* for ARRAY_SIZE() */\n\n14#include <linux/module.h>  \n15#include <linux/printk.h>  \n16#include <linux/version.h>  \n17\n\n18#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 10, 0)  \n19#define NO_GPIO_REQUEST_ARRAY\n\n20#endif  \n21  \n22static int button_irqs[] = { -1, -1 };  \n23  \n24/* Define GPIOs for LEDs.\n\n25 * TODO: Change the numbers for the GPIO on your board.  \n26 */\n\n27static struct gpio leds[] = { { 4, GPIOF_OUT_INIT_LOW, \"LED 1\" } };  \n28\n\n29/* Define GPIOs for BUTTONS  \n30 * TODO: Change the numbers for the GPIO on your board.\n\n31 */  \n32static struct gpio buttons[] = { { 17, GPIOF_IN, \"LED 1 ON BUTTON\" },\n\n33                                 { 18, GPIOF_IN, \"LED 1 OFF BUTTON\" } };\n\n34  \n35/* interrupt function triggered when a button is pressed. */\n\n36static irqreturn_t button_isr(int irq, void *data)  \n37{  \n38    /* first button */\n\n39    if (irq == button_irqs[0] && !gpio_get_value(leds[0].gpio))\n\n40        gpio_set_value(leds[0].gpio, 1);  \n41    /* second button */\n\n42    else if (irq == button_irqs[1] && gpio_get_value(leds[0].gpio))\n\n43        gpio_set_value(leds[0].gpio, 0);  \n44  \n45    return IRQ_HANDLED;  \n46}  \n47  \n48static int __init intrpt_init(void)\n\n49{  \n50    int ret = 0;  \n51  \n52    pr_info(\"%s\\n\", __func__);  \n53  \n54    /* register LED gpios */\n\n55#ifdef NO_GPIO_REQUEST_ARRAY  \n56    ret = gpio_request(leds[0].gpio, leds[0].label);  \n57#else\n\n58    ret = gpio_request_array(leds, ARRAY_SIZE(leds));  \n59#endif  \n60  \n61    if (ret) {\n\n62        pr_err(\"Unable to request GPIOs for LEDs: %d\\n\", ret);  \n63        return ret;\n\n64    }  \n65  \n66    /* register BUTTON gpios */  \n67#ifdef NO_GPIO_REQUEST_ARRAY\n\n68    ret = gpio_request(buttons[0].gpio, buttons[0].label);  \n69  \n70    if (ret) {\n\n71        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n72        goto fail1;\n\n73    }  \n74  \n75    ret = gpio_request(buttons[1].gpio, buttons[1].label);  \n76  \n77    if (ret) {\n\n78        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n79        goto fail2;\n\n80    }  \n81#else  \n82    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));  \n83  \n84    if (ret) {\n\n85        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n86        goto fail1;  \n87    }\n\n88#endif  \n89  \n90    pr_info(\"Current button1 value: %d\\n\", gpio_get_value(buttons[0].gpio));\n\n91  \n92    ret = gpio_to_irq(buttons[0].gpio);  \n93  \n94    if (ret < 0) {\n\n95        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n96#ifdef NO_GPIO_REQUEST_ARRAY\n\n97        goto fail3;  \n98#else  \n99        goto fail2;  \n100#endif  \n101    }  \n102  \n103    button_irqs[0] = ret;  \n104\n\n105    pr_info(\"Successfully requested BUTTON1 IRQ # %d\\n\", button_irqs[0]);\n\n106  \n107    ret = request_irq(button_irqs[0], button_isr,\n\n108                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\n109                      \"gpiomod#button1\", NULL);  \n110  \n111    if (ret) {\n\n112        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n113#ifdef NO_GPIO_REQUEST_ARRAY  \n114        goto fail3;\n\n115#else  \n116        goto fail2;  \n117#endif  \n118    }  \n119  \n120    ret = gpio_to_irq(buttons[1].gpio);  \n121  \n122    if (ret < 0) {\n\n123        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n124#ifdef NO_GPIO_REQUEST_ARRAY\n\n125        goto fail3;  \n126#else  \n127        goto fail2;  \n128#endif  \n129    }  \n130  \n131    button_irqs[1] = ret;  \n132\n\n133    pr_info(\"Successfully requested BUTTON2 IRQ # %d\\n\", button_irqs[1]);\n\n134  \n135    ret = request_irq(button_irqs[1], button_isr,\n\n136                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\n137                      \"gpiomod#button2\", NULL);  \n138  \n139    if (ret) {\n\n140        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n141#ifdef NO_GPIO_REQUEST_ARRAY\n\n142        goto fail4;  \n143#else  \n144        goto fail3;  \n145#endif  \n146    }  \n147  \n148    return 0;  \n149\n\n150/* cleanup what has been setup so far */  \n151#ifdef NO_GPIO_REQUEST_ARRAY  \n152fail4:\n\n153    free_irq(button_irqs[0], NULL);  \n154  \n155fail3:  \n156    gpio_free(buttons[1].gpio);  \n157  \n158fail2:\n\n159    gpio_free(buttons[0].gpio);  \n160  \n161fail1:  \n162    gpio_free(leds[0].gpio);  \n163#else  \n164fail3:\n\n165    free_irq(button_irqs[0], NULL);  \n166  \n167fail2:  \n168    gpio_free_array(buttons, ARRAY_SIZE(buttons));\n\n169  \n170fail1:  \n171    gpio_free_array(leds, ARRAY_SIZE(leds));  \n172#endif  \n173  \n174    return ret;  \n175}  \n176\n\n177static void __exit intrpt_exit(void)  \n178{  \n179    pr_info(\"%s\\n\", __func__);  \n180  \n181    /* free irqs */\n\n182    free_irq(button_irqs[0], NULL);  \n183    free_irq(button_irqs[1], NULL);  \n184\n\n185    /* turn all LEDs off */  \n186#ifdef NO_GPIO_REQUEST_ARRAY  \n187    gpio_set_value(leds[0].gpio, 0);  \n188#else\n\n189    int i;  \n190    for (i = 0; i < ARRAY_SIZE(leds); i++)  \n191        gpio_set_value(leds[i].gpio, 0);\n\n192#endif  \n193  \n194    /* unregister */  \n195#ifdef NO_GPIO_REQUEST_ARRAY  \n196    gpio_free(leds[0].gpio);\n\n197    gpio_free(buttons[0].gpio);  \n198    gpio_free(buttons[1].gpio);  \n199#else\n\n200    gpio_free_array(leds, ARRAY_SIZE(leds));  \n201    gpio_free_array(buttons, ARRAY_SIZE(buttons));\n\n202#endif  \n203}  \n204  \n205module_init(intrpt_init);  \n206module_exit(intrpt_exit);  \n207\n\n208MODULE_LICENSE(\"GPL\"); \n209MODULE_DESCRIPTION(\"Handle some GPIO interrupts\");\n```", "```\n 1/*   \n2 * bottomhalf.c - Top and bottom half interrupt handling  \n3 *\n\n4 * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)\n\n5 * from:  \n6 *    https://github.com/wendlers/rpi-kmod-samples  \n7 *\n\n8 * Press one button to turn on an LED and another to turn it off  \n9 */  \n10  \n11#include <linux/delay.h>\n\n12#include <linux/gpio.h>  \n13#include <linux/interrupt.h>  \n14#include <linux/module.h>\n\n15#include <linux/printk.h>  \n16#include <linux/init.h>  \n17#include <linux/version.h>\n\n18#include <linux/workqueue.h>  \n19  \n20#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 10, 0)\n\n21#define NO_GPIO_REQUEST_ARRAY  \n22#endif  \n23  \n24static int button_irqs[] = { -1, -1 };  \n25\n\n26/* Define GPIOs for LEDs.  \n27 * TODO: Change the numbers for the GPIO on your board.  \n28 */\n\n29static struct gpio leds[] = { { 4, GPIOF_OUT_INIT_LOW, \"LED 1\" } };  \n30  \n31/* Define GPIOs for BUTTONS\n\n32 * TODO: Change the numbers for the GPIO on your board.  \n33 */  \n34static struct gpio buttons[] = {\n\n35    { 17, GPIOF_IN, \"LED 1 ON BUTTON\" },  \n36    { 18, GPIOF_IN, \"LED 1 OFF BUTTON\" },\n\n37};  \n38  \n39/* Workqueue function containing some non-trivial amount of processing */\n\n40static void bottomhalf_work_fn(struct work_struct *work)  \n41{\n\n42    pr_info(\"Bottom half workqueue starts\\n\");  \n43    /* do something which takes a while */\n\n44    msleep(500);  \n45  \n46    pr_info(\"Bottom half workqueue ends\\n\");\n\n47}  \n48  \n49static DECLARE_WORK(bottomhalf_work, bottomhalf_work_fn);\n\n50  \n51/* interrupt function triggered when a button is pressed */\n\n52static irqreturn_t button_isr(int irq, void *data)  \n53{  \n54    /* Do something quickly right now */\n\n55    if (irq == button_irqs[0] && !gpio_get_value(leds[0].gpio))  \n56        gpio_set_value(leds[0].gpio, 1);\n\n57    else if (irq == button_irqs[1] && gpio_get_value(leds[0].gpio))\n\n58        gpio_set_value(leds[0].gpio, 0);  \n59  \n60    /* Do the rest at leisure via the scheduler */\n\n61    schedule_work(&bottomhalf_work);  \n62    return IRQ_HANDLED;  \n63}  \n64  \n65static int __init bottomhalf_init(void)\n\n66{  \n67    int ret = 0;  \n68  \n69    pr_info(\"%s\\n\", __func__);  \n70  \n71    /* register LED gpios */\n\n72#ifdef NO_GPIO_REQUEST_ARRAY  \n73    ret = gpio_request(leds[0].gpio, leds[0].label);  \n74#else\n\n75    ret = gpio_request_array(leds, ARRAY_SIZE(leds));  \n76#endif  \n77  \n78    if (ret) {\n\n79        pr_err(\"Unable to request GPIOs for LEDs: %d\\n\", ret);  \n80        return ret;\n\n81    }  \n82  \n83    /* register BUTTON gpios */  \n84#ifdef NO_GPIO_REQUEST_ARRAY\n\n85    ret = gpio_request(buttons[0].gpio, buttons[0].label);  \n86  \n87    if (ret) {\n\n88        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n89        goto fail1;\n\n90    }  \n91  \n92    ret = gpio_request(buttons[1].gpio, buttons[1].label);  \n93  \n94    if (ret) {\n\n95        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n96        goto fail2;\n\n97    }  \n98#else  \n99    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));  \n100  \n101    if (ret) {\n\n102        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n103        goto fail1;  \n104    }\n\n105#endif  \n106  \n107    pr_info(\"Current button1 value: %d\\n\", gpio_get_value(buttons[0].gpio));\n\n108  \n109    ret = gpio_to_irq(buttons[0].gpio);  \n110  \n111    if (ret < 0) {\n\n112        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n113#ifdef NO_GPIO_REQUEST_ARRAY\n\n114        goto fail3;  \n115#else  \n116        goto fail2;  \n117#endif  \n118    }  \n119  \n120    button_irqs[0] = ret;  \n121\n\n122    pr_info(\"Successfully requested BUTTON1 IRQ # %d\\n\", button_irqs[0]);\n\n123  \n124    ret = request_irq(button_irqs[0], button_isr,\n\n125                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\n126                      \"gpiomod#button1\", NULL);  \n127  \n128    if (ret) {\n\n129        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n130#ifdef NO_GPIO_REQUEST_ARRAY  \n131        goto fail3;\n\n132#else  \n133        goto fail2;  \n134#endif  \n135    }  \n136  \n137    ret = gpio_to_irq(buttons[1].gpio);  \n138  \n139    if (ret < 0) {\n\n140        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n141#ifdef NO_GPIO_REQUEST_ARRAY\n\n142        goto fail3;  \n143#else  \n144        goto fail2;  \n145#endif  \n146    }  \n147  \n148    button_irqs[1] = ret;  \n149\n\n150    pr_info(\"Successfully requested BUTTON2 IRQ # %d\\n\", button_irqs[1]);\n\n151  \n152    ret = request_irq(button_irqs[1], button_isr,\n\n153                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\n154                      \"gpiomod#button2\", NULL);  \n155  \n156    if (ret) {\n\n157        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n158#ifdef NO_GPIO_REQUEST_ARRAY\n\n159        goto fail4;  \n160#else  \n161        goto fail3;  \n162#endif  \n163    }  \n164  \n165    return 0;  \n166\n\n167/* cleanup what has been setup so far */  \n168#ifdef NO_GPIO_REQUEST_ARRAY  \n169fail4:\n\n170    free_irq(button_irqs[0], NULL);  \n171  \n172fail3:  \n173    gpio_free(buttons[1].gpio);  \n174  \n175fail2:\n\n176    gpio_free(buttons[0].gpio);  \n177  \n178fail1:  \n179    gpio_free(leds[0].gpio);  \n180#else  \n181fail3:\n\n182    free_irq(button_irqs[0], NULL);  \n183  \n184fail2:  \n185    gpio_free_array(buttons, ARRAY_SIZE(buttons));\n\n186  \n187fail1:  \n188    gpio_free_array(leds, ARRAY_SIZE(leds));  \n189#endif  \n190  \n191    return ret;  \n192}\n\n193  \n194static void __exit bottomhalf_exit(void)  \n195{  \n196    pr_info(\"%s\\n\", __func__);  \n197\n\n198    /* free irqs */  \n199    free_irq(button_irqs[0], NULL);  \n200    free_irq(button_irqs[1], NULL);  \n201\n\n202    /* turn all LEDs off */  \n203#ifdef NO_GPIO_REQUEST_ARRAY  \n204    gpio_set_value(leds[0].gpio, 0);  \n205#else\n\n206    int i;  \n207    for (i = 0; i < ARRAY_SIZE(leds); i++)  \n208        gpio_set_value(leds[i].gpio, 0);\n\n209#endif  \n210  \n211    /* unregister */  \n212#ifdef NO_GPIO_REQUEST_ARRAY  \n213    gpio_free(leds[0].gpio);\n\n214    gpio_free(buttons[0].gpio);  \n215    gpio_free(buttons[1].gpio);  \n216#else\n\n217    gpio_free_array(leds, ARRAY_SIZE(leds));  \n218    gpio_free_array(buttons, ARRAY_SIZE(buttons));\n\n219#endif  \n220}  \n221  \n222module_init(bottomhalf_init);  \n223module_exit(bottomhalf_exit);  \n224\n\n225MODULE_LICENSE(\"GPL\"); \n226MODULE_DESCRIPTION(\"Interrupt with top and bottom half\");\n```", "```\n 1/*   \n2 * bh_thread.c - Top and bottom half interrupt handling  \n3 *\n\n4 * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)\n\n5 * from:  \n6 *    https://github.com/wendlers/rpi-kmod-samples  \n7 *\n\n8 * Press one button to turn on a LED and another to turn it off  \n9 */  \n10\n\n11#include <linux/module.h>  \n12#include <linux/kernel.h>  \n13#include <linux/gpio.h>\n\n14#include <linux/delay.h>  \n15#include <linux/interrupt.h>  \n16#include <linux/version.h>  \n17\n\n18#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 10, 0)  \n19#define NO_GPIO_REQUEST_ARRAY\n\n20#endif  \n21  \n22static int button_irqs[] = { -1, -1 };  \n23  \n24/* Define GPIOs for LEDs.\n\n25 * FIXME: Change the numbers for the GPIO on your board.  \n26 */\n\n27static struct gpio leds[] = { { 4, GPIOF_OUT_INIT_LOW, \"LED 1\" } };  \n28  \n29/* Define GPIOs for BUTTONS\n\n30 * FIXME: Change the numbers for the GPIO on your board.  \n31 */  \n32static struct gpio buttons[] = {\n\n33    { 17, GPIOF_IN, \"LED 1 ON BUTTON\" },  \n34    { 18, GPIOF_IN, \"LED 1 OFF BUTTON\" },\n\n35};  \n36  \n37/* This happens immediately, when the IRQ is triggered */\n\n38static irqreturn_t button_top_half(int irq, void *ident)  \n39{  \n40    return IRQ_WAKE_THREAD;  \n41}\n\n42  \n43/* This can happen at leisure, freeing up IRQs for other high priority task */\n\n44static irqreturn_t button_bottom_half(int irq, void *ident)  \n45{  \n46    pr_info(\"Bottom half task starts\\n\");\n\n47    mdelay(500); /* do something which takes a while */  \n48    pr_info(\"Bottom half task ends\\n\");\n\n49    return IRQ_HANDLED;  \n50}  \n51  \n52static int __init bottomhalf_init(void)  \n53{\n\n54    int ret = 0;  \n55  \n56    pr_info(\"%s\\n\", __func__);  \n57  \n58/* register LED gpios */\n\n59#ifdef NO_GPIO_REQUEST_ARRAY  \n60    ret = gpio_request(leds[0].gpio, leds[0].label);\n\n61#else  \n62    ret = gpio_request_array(leds, ARRAY_SIZE(leds));  \n63#endif  \n64\n\n65    if (ret) {  \n66        pr_err(\"Unable to request GPIOs for LEDs: %d\\n\", ret);\n\n67        return ret;  \n68    }  \n69  \n70/* register BUTTON gpios */  \n71#ifdef NO_GPIO_REQUEST_ARRAY\n\n72    ret = gpio_request(buttons[0].gpio, buttons[0].label);  \n73  \n74    if (ret) {\n\n75        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n76        goto fail1;\n\n77    }  \n78  \n79    ret = gpio_request(buttons[1].gpio, buttons[1].label);  \n80  \n81    if (ret) {\n\n82        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n83        goto fail2;\n\n84    }  \n85#else  \n86    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));  \n87  \n88    if (ret) {\n\n89        pr_err(\"Unable to request GPIOs for BUTTONs: %d\\n\", ret);  \n90        goto fail1;  \n91    }\n\n92#endif  \n93  \n94    pr_info(\"Current button1 value: %d\\n\", gpio_get_value(buttons[0].gpio));\n\n95  \n96    ret = gpio_to_irq(buttons[0].gpio);  \n97  \n98    if (ret < 0) {\n\n99        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n100#ifdef NO_GPIO_REQUEST_ARRAY\n\n101        goto fail3;  \n102#else  \n103        goto fail2;  \n104#endif  \n105    }  \n106  \n107    button_irqs[0] = ret;  \n108\n\n109    pr_info(\"Successfully requested BUTTON1 IRQ # %d\\n\", button_irqs[0]);\n\n110  \n111    ret = request_threaded_irq(button_irqs[0], button_top_half,\n\n112                               button_bottom_half,\n\n113                               IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\n114                               \"gpiomod#button1\", &buttons[0]);  \n115\n\n116    if (ret) {  \n117        pr_err(\"Unable to request IRQ: %d\\n\", ret);\n\n118#ifdef NO_GPIO_REQUEST_ARRAY  \n119        goto fail3;  \n120#else  \n121        goto fail2;\n\n122#endif  \n123    }  \n124  \n125    ret = gpio_to_irq(buttons[1].gpio);  \n126  \n127    if (ret < 0) {\n\n128        pr_err(\"Unable to request IRQ: %d\\n\", ret);  \n129#ifdef NO_GPIO_REQUEST_ARRAY\n\n130        goto fail3;  \n131#else  \n132        goto fail2;  \n133#endif  \n134    }  \n135  \n136    button_irqs[1] = ret;  \n137\n\n138    pr_info(\"Successfully requested BUTTON2 IRQ # %d\\n\", button_irqs[1]);\n\n139  \n140    ret = request_threaded_irq(button_irqs[1], button_top_half,\n\n141                               button_bottom_half,\n\n142                               IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\n143                               \"gpiomod#button2\", &buttons[1]);  \n144\n\n145    if (ret) {  \n146        pr_err(\"Unable to request IRQ: %d\\n\", ret);\n\n147#ifdef NO_GPIO_REQUEST_ARRAY  \n148        goto fail4;  \n149#else  \n150        goto fail3;\n\n151#endif  \n152    }  \n153  \n154    return 0;  \n155  \n156/* cleanup what has been setup so far */\n\n157#ifdef NO_GPIO_REQUEST_ARRAY  \n158fail4:  \n159    free_irq(button_irqs[0], &buttons[0]);  \n160  \n161fail3:\n\n162    gpio_free(buttons[1].gpio);  \n163  \n164fail2:  \n165    gpio_free(buttons[0].gpio);  \n166  \n167fail1:\n\n168    gpio_free(leds[0].gpio);  \n169#else  \n170fail3:  \n171    free_irq(button_irqs[0], &buttons[0]);\n\n172  \n173fail2:  \n174    gpio_free_array(buttons, ARRAY_SIZE(buttons));  \n175  \n176fail1:\n\n177    gpio_free_array(leds, ARRAY_SIZE(leds));  \n178#endif  \n179  \n180    return ret;  \n181}  \n182\n\n183static void __exit bottomhalf_exit(void)  \n184{  \n185    pr_info(\"%s\\n\", __func__);  \n186  \n187    /* free irqs */\n\n188    free_irq(button_irqs[0], &buttons[0]);  \n189    free_irq(button_irqs[1], &buttons[1]);  \n190\n\n191/* turn all LEDs off */  \n192#ifdef NO_GPIO_REQUEST_ARRAY  \n193    gpio_set_value(leds[0].gpio, 0);  \n194#else\n\n195    int i;  \n196    for (i = 0; i < ARRAY_SIZE(leds); i++)  \n197        gpio_set_value(leds[i].gpio, 0);\n\n198#endif  \n199  \n200/* unregister */  \n201#ifdef NO_GPIO_REQUEST_ARRAY  \n202    gpio_free(leds[0].gpio);\n\n203    gpio_free(buttons[0].gpio);  \n204    gpio_free(buttons[1].gpio);  \n205#else\n\n206    gpio_free_array(leds, ARRAY_SIZE(leds));  \n207    gpio_free_array(buttons, ARRAY_SIZE(buttons));\n\n208#endif  \n209}  \n210  \n211module_init(bottomhalf_init);  \n212module_exit(bottomhalf_exit);  \n213\n\n214MODULE_LICENSE(\"GPL\"); \n215MODULE_DESCRIPTION(\"Interrupt with top and bottom half\");\n```", "```\n 1int init(struct vinput *);\n```", "```\n 1int send(struct vinput *, char *, int);\n```", "```\n 1int read(struct vinput *, char *, int);\n```", "```\n 1struct class_attribute {   \n2    struct attribute attr;\n\n3    ssize_t (*show)(struct class *class, struct class_attribute *attr,  \n4                    char *buf);\n\n5    ssize_t (*store)(struct class *class, struct class_attribute *attr,\n\n6                    const char *buf, size_t count); \n7};\n```", "```\n  1echo \"vkbd\" | sudo tee /sys/class/vinput/export\n```", "```\n  1echo \"0\" | sudo tee /sys/class/vinput/unexport\n```", "```\n 1/*   \n2 * vinput.h  \n3 */  \n4   \n5#ifndef VINPUT_H  \n6#define VINPUT_H  \n7   \n8#include <linux/input.h>\n\n9#include <linux/spinlock.h>  \n10  \n11#define VINPUT_MAX_LEN 128  \n12#define MAX_VINPUT 32\n\n13#define VINPUT_MINORS MAX_VINPUT  \n14  \n15#define dev_to_vinput(dev) container_of(dev, struct vinput, dev)\n\n16  \n17struct vinput_device;  \n18  \n19struct vinput {  \n20    long id;  \n21    long devno;\n\n22    long last_entry;  \n23    spinlock_t lock;  \n24  \n25    void *priv_data;  \n26  \n27    struct device dev;\n\n28    struct list_head list;  \n29    struct input_dev *input;  \n30    struct vinput_device *type;  \n31};  \n32\n\n33struct vinput_ops {  \n34    int (*init)(struct vinput *);  \n35    int (*kill)(struct vinput *);\n\n36    int (*send)(struct vinput *, char *, int);  \n37    int (*read)(struct vinput *, char *, int);\n\n38};  \n39  \n40struct vinput_device {  \n41    char name[16];  \n42    struct list_head list;\n\n43    struct vinput_ops *ops;  \n44};  \n45  \n46int vinput_register(struct vinput_device *dev);\n\n47void vinput_unregister(struct vinput_device *dev);  \n48 \n49#endif\n```", "```\n 1/*   \n2 * vinput.c  \n3 */  \n4   \n5#include <linux/cdev.h>  \n6#include <linux/input.h>\n\n7#include <linux/module.h>  \n8#include <linux/slab.h>  \n9#include <linux/spinlock.h>\n\n10#include <linux/version.h>  \n11  \n12#include <asm/uaccess.h>  \n13  \n14#include \"vinput.h\"  \n15\n\n16#define DRIVER_NAME \"vinput\"  \n17  \n18#define dev_to_vinput(dev) container_of(dev, struct vinput, dev)\n\n19  \n20static DECLARE_BITMAP(vinput_ids, VINPUT_MINORS);  \n21  \n22static LIST_HEAD(vinput_devices);\n\n23static LIST_HEAD(vinput_vdevices);  \n24  \n25static int vinput_dev;\n\n26static struct spinlock vinput_lock;  \n27static struct class vinput_class;  \n28\n\n29/* Search the name of vinput device in the vinput_devices linked list,  \n30 * which added at vinput_register().\n\n31 */  \n32static struct vinput_device *vinput_get_device_by_type(const char *type)  \n33{\n\n34    int found = 0;  \n35    struct vinput_device *vinput;  \n36    struct list_head *curr;  \n37\n\n38    spin_lock(&vinput_lock);  \n39    list_for_each (curr, &vinput_devices) {\n\n40        vinput = list_entry(curr, struct vinput_device, list);\n\n41        if (vinput && strncmp(type, vinput->name, strlen(vinput->name)) == 0) {\n\n42            found = 1;  \n43            break;  \n44        }  \n45    }  \n46    spin_unlock(&vinput_lock);\n\n47  \n48    if (found)  \n49        return vinput;  \n50    return ERR_PTR(-ENODEV);  \n51}  \n52\n\n53/* Search the id of virtual device in the vinput_vdevices linked list,\n\n54 * which added at vinput_alloc_vdevice().  \n55 */  \n56static struct vinput *vinput_get_vdevice_by_id(long id)\n\n57{  \n58    struct vinput *vinput = NULL;  \n59    struct list_head *curr;  \n60  \n61    spin_lock(&vinput_lock);\n\n62    list_for_each (curr, &vinput_vdevices) {  \n63        vinput = list_entry(curr, struct vinput, list);\n\n64        if (vinput && vinput->id == id)  \n65            break;  \n66    }  \n67    spin_unlock(&vinput_lock);\n\n68  \n69    if (vinput && vinput->id == id)  \n70        return vinput;  \n71    return ERR_PTR(-ENODEV);\n\n72}  \n73  \n74static int vinput_open(struct inode *inode, struct file *file)  \n75{  \n76    int err = 0;\n\n77    struct vinput *vinput = NULL;  \n78  \n79    vinput = vinput_get_vdevice_by_id(iminor(inode));  \n80\n\n81    if (IS_ERR(vinput))  \n82        err = PTR_ERR(vinput);  \n83    else  \n84        file->private_data = vinput;\n\n85  \n86    return err;  \n87}  \n88  \n89static int vinput_release(struct inode *inode, struct file *file)  \n90{\n\n91    return 0;  \n92}  \n93  \n94static ssize_t vinput_read(struct file *file, char __user *buffer, size_t count,\n\n95                           loff_t *offset)  \n96{  \n97    int len;  \n98    char buff[VINPUT_MAX_LEN + 1];\n\n99    struct vinput *vinput = file->private_data;  \n100  \n101    len = vinput->type->ops->read(vinput, buff, count);\n\n102  \n103    if (*offset > len)  \n104        count = 0;  \n105    else if (count + *offset > VINPUT_MAX_LEN)\n\n106        count = len - *offset;  \n107  \n108    if (raw_copy_to_user(buffer, buff + *offset, count))\n\n109        return -EFAULT;  \n110  \n111    *offset += count;  \n112  \n113    return count;  \n114}  \n115\n\n116static ssize_t vinput_write(struct file *file, const char __user *buffer,\n\n117                            size_t count, loff_t *offset)  \n118{\n\n119    char buff[VINPUT_MAX_LEN + 1];  \n120    struct vinput *vinput = file->private_data;  \n121\n\n122    memset(buff, 0, sizeof(char) * (VINPUT_MAX_LEN + 1));  \n123  \n124    if (count > VINPUT_MAX_LEN) {\n\n125        dev_warn(&vinput->dev, \"Too long. %d bytes allowed\\n\", VINPUT_MAX_LEN);\n\n126        return -EINVAL;  \n127    }  \n128  \n129    if (raw_copy_from_user(buff, buffer, count))\n\n130        return -EFAULT;  \n131  \n132    return vinput->type->ops->send(vinput, buff, count);  \n133}  \n134\n\n135static const struct file_operations vinput_fops = {  \n136    .owner = THIS_MODULE,\n\n137    .open = vinput_open,  \n138    .release = vinput_release,  \n139    .read = vinput_read,\n\n140    .write = vinput_write,  \n141};  \n142  \n143static void vinput_unregister_vdevice(struct vinput *vinput)\n\n144{  \n145    input_unregister_device(vinput->input);  \n146    if (vinput->type->ops->kill)\n\n147        vinput->type->ops->kill(vinput);  \n148}  \n149  \n150static void vinput_destroy_vdevice(struct vinput *vinput)\n\n151{  \n152    /* Remove from the list first */  \n153    spin_lock(&vinput_lock);  \n154    list_del(&vinput->list);\n\n155    clear_bit(vinput->id, vinput_ids);  \n156    spin_unlock(&vinput_lock);  \n157\n\n158    kfree(vinput);  \n159}  \n160  \n161static void vinput_release_dev(struct device *dev)\n\n162{  \n163    struct vinput *vinput = dev_to_vinput(dev);  \n164    int id = vinput->id;  \n165\n\n166    vinput_destroy_vdevice(vinput);  \n167  \n168    pr_debug(\"released vinput%d.\\n\", id);\n\n169}  \n170  \n171static struct vinput *vinput_alloc_vdevice(void)  \n172{  \n173    int err;\n\n174    struct vinput *vinput = kzalloc(sizeof(struct vinput), GFP_KERNEL);  \n175\n\n176    if (!vinput) {  \n177        pr_err(\"vinput: Cannot allocate vinput input device\\n\");\n\n178        return ERR_PTR(-ENOMEM);  \n179    }  \n180  \n181    spin_lock_init(&vinput->lock);  \n182\n\n183    spin_lock(&vinput_lock);  \n184    vinput->id = find_first_zero_bit(vinput_ids, VINPUT_MINORS);\n\n185    if (vinput->id >= VINPUT_MINORS) {  \n186        err = -ENOBUFS;  \n187        goto fail_id;  \n188    }\n\n189    set_bit(vinput->id, vinput_ids);  \n190    list_add(&vinput->list, &vinput_vdevices);\n\n191    spin_unlock(&vinput_lock);  \n192  \n193    /* allocate the input device */\n\n194    vinput->input = input_allocate_device();  \n195    if (vinput->input == NULL) {\n\n196        pr_err(\"vinput: Cannot allocate vinput input device\\n\");  \n197        err = -ENOMEM;\n\n198        goto fail_input_dev;  \n199    }  \n200  \n201    /* initialize device */  \n202    vinput->dev.class = &vinput_class;\n\n203    vinput->dev.release = vinput_release_dev;  \n204    vinput->dev.devt = MKDEV(vinput_dev, vinput->id);\n\n205    dev_set_name(&vinput->dev, DRIVER_NAME \"%lu\", vinput->id);  \n206  \n207    return vinput;  \n208\n\n209fail_input_dev:  \n210    spin_lock(&vinput_lock);  \n211    list_del(&vinput->list);  \n212fail_id:\n\n213    spin_unlock(&vinput_lock);  \n214    kfree(vinput);  \n215  \n216    return ERR_PTR(err);  \n217}  \n218\n\n219static int vinput_register_vdevice(struct vinput *vinput)  \n220{  \n221    int err = 0;  \n222\n\n223    /* register the input device */  \n224    vinput->input->name = vinput->type->name;\n\n225    vinput->input->phys = \"vinput\";  \n226    vinput->input->dev.parent = &vinput->dev;  \n227\n\n228    vinput->input->id.bustype = BUS_VIRTUAL;  \n229    vinput->input->id.product = 0x0000;\n\n230    vinput->input->id.vendor = 0x0000;  \n231    vinput->input->id.version = 0x0000;\n\n232  \n233    err = vinput->type->ops->init(vinput);  \n234  \n235    if (err == 0)\n\n236        dev_info(&vinput->dev, \"Registered virtual input %s %ld\\n\",\n\n237                 vinput->type->name, vinput->id);  \n238  \n239    return err;  \n240}  \n241\n\n242#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)  \n243static ssize_t export_store(const struct class *class,\n\n244                            const struct class_attribute *attr,  \n245#else\n\n246static ssize_t export_store(struct class *class, struct class_attribute *attr,  \n247#endif\n\n248                            const char *buf, size_t len)  \n249{  \n250    int err;  \n251    struct vinput *vinput;\n\n252    struct vinput_device *device;  \n253  \n254    device = vinput_get_device_by_type(buf);\n\n255    if (IS_ERR(device)) {  \n256        pr_info(\"vinput: This virtual device isn't registered\\n\");\n\n257        err = PTR_ERR(device);  \n258        goto fail;  \n259    }  \n260  \n261    vinput = vinput_alloc_vdevice();\n\n262    if (IS_ERR(vinput)) {  \n263        err = PTR_ERR(vinput);  \n264        goto fail;  \n265    }  \n266\n\n267    vinput->type = device;  \n268    err = device_register(&vinput->dev);  \n269    if (err < 0)\n\n270        goto fail_register;  \n271  \n272    err = vinput_register_vdevice(vinput);  \n273    if (err < 0)\n\n274        goto fail_register_vinput;  \n275  \n276    return len;  \n277  \n278fail_register_vinput:\n\n279    input_free_device(vinput->input);  \n280    device_unregister(&vinput->dev);\n\n281    /* avoid calling vinput_destroy_vdevice() twice */  \n282    return err;  \n283fail_register:\n\n284    input_free_device(vinput->input);  \n285    vinput_destroy_vdevice(vinput);  \n286fail:\n\n287    return err;  \n288}  \n289/* This macro generates class_attr_export structure and export_store() */\n\n290static CLASS_ATTR_WO(export);  \n291  \n292#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)\n\n293static ssize_t unexport_store(const struct class *class,\n\n294                              const struct class_attribute *attr,  \n295#else\n\n296static ssize_t unexport_store(struct class *class, struct class_attribute *attr,  \n297#endif\n\n298                              const char *buf, size_t len)  \n299{  \n300    int err;  \n301    unsigned long id;\n\n302    struct vinput *vinput;  \n303  \n304    err = kstrtol(buf, 10, &id);  \n305    if (err) {\n\n306        err = -EINVAL;  \n307        goto failed;  \n308    }  \n309  \n310    vinput = vinput_get_vdevice_by_id(id);\n\n311    if (IS_ERR(vinput)) {  \n312        pr_err(\"vinput: No such vinput device %ld\\n\", id);\n\n313        err = PTR_ERR(vinput);  \n314        goto failed;  \n315    }  \n316  \n317    vinput_unregister_vdevice(vinput);\n\n318    device_unregister(&vinput->dev);  \n319  \n320    return len;  \n321failed:  \n322    return err;  \n323}\n\n324/* This macro generates class_attr_unexport structure and unexport_store() */\n\n325static CLASS_ATTR_WO(unexport);  \n326  \n327static struct attribute *vinput_class_attrs[] = {\n\n328    &class_attr_export.attr,  \n329    &class_attr_unexport.attr,  \n330    NULL,\n\n331};  \n332  \n333/* This macro generates vinput_class_groups structure */\n\n334ATTRIBUTE_GROUPS(vinput_class);  \n335  \n336static struct class vinput_class = {  \n337    .name = \"vinput\",\n\n338/* .owner was removed in Linux v6.4 via upstream commit 6e30a66433af (\"driver core: class: remove\n\n339 * struct module owner out of struct class\")  \n340 */  \n341#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)\n\n342    .owner = THIS_MODULE,  \n343#endif  \n344    .class_groups = vinput_class_groups,  \n345};  \n346\n\n347int vinput_register(struct vinput_device *dev)  \n348{  \n349    spin_lock(&vinput_lock);\n\n350    list_add(&dev->list, &vinput_devices);  \n351    spin_unlock(&vinput_lock);  \n352\n\n353    pr_info(\"vinput: registered new virtual input device '%s'\\n\", dev->name);  \n354  \n355    return 0;\n\n356}  \n357EXPORT_SYMBOL(vinput_register);  \n358  \n359void vinput_unregister(struct vinput_device *dev)  \n360{\n\n361    struct list_head *curr, *next;  \n362  \n363    /* Remove from the list first */\n\n364    spin_lock(&vinput_lock);  \n365    list_del(&dev->list);  \n366    spin_unlock(&vinput_lock);  \n367\n\n368    /* unregister all devices of this type */  \n369    list_for_each_safe (curr, next, &vinput_vdevices) {\n\n370        struct vinput *vinput = list_entry(curr, struct vinput, list);\n\n371        if (vinput && vinput->type == dev) {  \n372            vinput_unregister_vdevice(vinput);\n\n373            device_unregister(&vinput->dev);  \n374        }  \n375    }  \n376\n\n377    pr_info(\"vinput: unregistered virtual input device '%s'\\n\", dev->name);\n\n378}  \n379EXPORT_SYMBOL(vinput_unregister);  \n380  \n381static int __init vinput_init(void)\n\n382{  \n383    int err = 0;  \n384  \n385    pr_info(\"vinput: Loading virtual input driver\\n\");  \n386\n\n387    vinput_dev = register_chrdev(0, DRIVER_NAME, &vinput_fops);  \n388    if (vinput_dev < 0) {\n\n389        pr_err(\"vinput: Unable to allocate char dev region\\n\");  \n390        err = vinput_dev;\n\n391        goto failed_alloc;  \n392    }  \n393  \n394    spin_lock_init(&vinput_lock);\n\n395  \n396    err = class_register(&vinput_class);  \n397    if (err < 0) {\n\n398        pr_err(\"vinput: Unable to register vinput class\\n\");  \n399        goto failed_class;\n\n400    }  \n401  \n402    return 0;  \n403failed_class:  \n404    unregister_chrdev(vinput_dev, DRIVER_NAME);\n\n405failed_alloc:  \n406    return err;  \n407}  \n408  \n409static void __exit vinput_end(void)  \n410{\n\n411    pr_info(\"vinput: Unloading virtual input driver\\n\");  \n412  \n413    unregister_chrdev(vinput_dev, DRIVER_NAME);\n\n414    class_unregister(&vinput_class);  \n415}  \n416  \n417module_init(vinput_init);  \n418module_exit(vinput_end);  \n419\n\n420MODULE_LICENSE(\"GPL\"); \n421MODULE_DESCRIPTION(\"Emulate input events\");\n```", "```\n  1echo \"+34\" | sudo tee /dev/vinput0\n```", "```\n  1echo \"-34\" | sudo tee /dev/vinput0\n```", "```\n 1/*   \n2 * vkbd.c  \n3 */  \n4   \n5#include <linux/init.h>  \n6#include <linux/input.h>  \n7#include <linux/module.h>\n\n8#include <linux/spinlock.h>  \n9  \n10#include \"vinput.h\"  \n11  \n12#define VINPUT_KBD \"vkbd\"\n\n13#define VINPUT_RELEASE 0  \n14#define VINPUT_PRESS 1  \n15  \n16static unsigned short vkeymap[KEY_MAX];  \n17\n\n18static int vinput_vkbd_init(struct vinput *vinput)  \n19{  \n20    int i;  \n21  \n22    /* Set up the input bitfield */\n\n23    vinput->input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\n\n24    vinput->input->keycodesize = sizeof(unsigned short);\n\n25    vinput->input->keycodemax = KEY_MAX;  \n26    vinput->input->keycode = vkeymap;  \n27\n\n28    for (i = 0; i < KEY_MAX; i++)  \n29        set_bit(vkeymap[i], vinput->input->keybit);\n\n30  \n31    /* vinput will help us allocate new input device structure via\n\n32     * input_allocate_device(). So, we can register it straightforwardly.\n\n33     */  \n34    return input_register_device(vinput->input);  \n35}  \n36\n\n37static int vinput_vkbd_read(struct vinput *vinput, char *buff, int len)  \n38{  \n39    spin_lock(&vinput->lock);\n\n40    len = snprintf(buff, len, \"%+ld\\n\", vinput->last_entry);  \n41    spin_unlock(&vinput->lock);  \n42\n\n43    return len;  \n44}  \n45  \n46static int vinput_vkbd_send(struct vinput *vinput, char *buff, int len)\n\n47{  \n48    int ret;  \n49    long key = 0;  \n50    short type = VINPUT_PRESS;  \n51\n\n52    /* Determine which event was received (press or release)  \n53     * and store the state.\n\n54     */  \n55    if (buff[0] == '+')  \n56        ret = kstrtol(buff + 1, 10, &key);\n\n57    else  \n58        ret = kstrtol(buff, 10, &key);  \n59    if (ret)\n\n60        dev_err(&vinput->dev, \"error during kstrtol: -%d\\n\", ret);\n\n61    spin_lock(&vinput->lock);  \n62    vinput->last_entry = key;\n\n63    spin_unlock(&vinput->lock);  \n64  \n65    if (key < 0) {  \n66        type = VINPUT_RELEASE;\n\n67        key = -key;  \n68    }  \n69  \n70    dev_info(&vinput->dev, \"Event %s code %ld\\n\",\n\n71             (type == VINPUT_RELEASE) ? \"VINPUT_RELEASE\" : \"VINPUT_PRESS\", key);  \n72\n\n73    /* Report the state received to input subsystem. */  \n74    input_report_key(vinput->input, key, type);\n\n75    /* Tell input subsystem that it finished the report. */  \n76    input_sync(vinput->input);  \n77\n\n78    return len;  \n79}  \n80  \n81static struct vinput_ops vkbd_ops = {  \n82    .init = vinput_vkbd_init,\n\n83    .send = vinput_vkbd_send,  \n84    .read = vinput_vkbd_read,  \n85};  \n86\n\n87static struct vinput_device vkbd_dev = {  \n88    .name = VINPUT_KBD,  \n89    .ops = &vkbd_ops,\n\n90};  \n91  \n92static int __init vkbd_init(void)  \n93{  \n94    int i;  \n95  \n96    for (i = 0; i < KEY_MAX; i++)\n\n97        vkeymap[i] = i;  \n98    return vinput_register(&vkbd_dev);  \n99}  \n100  \n101static void __exit vkbd_end(void)\n\n102{  \n103    vinput_unregister(&vkbd_dev);  \n104}  \n105  \n106module_init(vkbd_init);  \n107module_exit(vkbd_end);  \n108\n\n109MODULE_LICENSE(\"GPL\"); \n110MODULE_DESCRIPTION(\"Emulate keyboard input events through /dev/vinput\");\n```", "```\n 1/*   \n2 * devicemodel.c  \n3 */  \n4#include <linux/kernel.h>  \n5#include <linux/module.h>\n\n6#include <linux/platform_device.h>  \n7#include <linux/version.h>  \n8\n\n9struct devicemodel_data {  \n10    char *greeting;  \n11    int number;  \n12};  \n13\n\n14static int devicemodel_probe(struct platform_device *dev)  \n15{  \n16    struct devicemodel_data *pd =\n\n17        (struct devicemodel_data *)(dev->dev.platform_data);  \n18  \n19    pr_info(\"devicemodel probe\\n\");\n\n20    pr_info(\"devicemodel greeting: %s; %d\\n\", pd->greeting, pd->number);  \n21\n\n22    /* Your device initialization code */  \n23  \n24    return 0;  \n25}  \n26  \n27#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)\n\n28static void devicemodel_remove(struct platform_device *dev)  \n29{\n\n30    pr_info(\"devicemodel example removed\\n\");  \n31    /* Your device removal code */\n\n32}  \n33#else  \n34static int devicemodel_remove(struct platform_device *dev)  \n35{\n\n36    pr_info(\"devicemodel example removed\\n\");  \n37    /* Your device removal code */\n\n38    return 0;  \n39}  \n40#endif  \n41  \n42static int devicemodel_suspend(struct device *dev)  \n43{\n\n44    pr_info(\"devicemodel example suspend\\n\");  \n45  \n46    /* Your device suspend code */  \n47\n\n48    return 0;  \n49}  \n50  \n51static int devicemodel_resume(struct device *dev)  \n52{\n\n53    pr_info(\"devicemodel example resume\\n\");  \n54  \n55    /* Your device resume code */  \n56\n\n57    return 0;  \n58}  \n59  \n60static const struct dev_pm_ops devicemodel_pm_ops = {\n\n61    .suspend = devicemodel_suspend,  \n62    .resume = devicemodel_resume,\n\n63    .poweroff = devicemodel_suspend,  \n64    .freeze = devicemodel_suspend,\n\n65    .thaw = devicemodel_resume,  \n66    .restore = devicemodel_resume,  \n67};  \n68\n\n69static struct platform_driver devicemodel_driver = {  \n70    .driver =  \n71        {\n\n72            .name = \"devicemodel_example\",  \n73            .pm = &devicemodel_pm_ops,\n\n74        },  \n75    .probe = devicemodel_probe,  \n76    .remove = devicemodel_remove,  \n77};  \n78\n\n79static int __init devicemodel_init(void)  \n80{  \n81    int ret;  \n82  \n83    pr_info(\"devicemodel init\\n\");\n\n84  \n85    ret = platform_driver_register(&devicemodel_driver);  \n86  \n87    if (ret) {\n\n88        pr_err(\"Unable to register driver\\n\");  \n89        return ret;\n\n90    }  \n91  \n92    return 0;  \n93}  \n94  \n95static void __exit devicemodel_exit(void)  \n96{\n\n97    pr_info(\"devicemodel exit\\n\");  \n98    platform_driver_unregister(&devicemodel_driver);\n\n99}  \n100  \n101module_init(devicemodel_init);  \n102module_exit(devicemodel_exit);  \n103\n\n104MODULE_LICENSE(\"GPL\"); \n105MODULE_DESCRIPTION(\"Linux Device Model example\");\n```", "```\n 1/* devicetree.c - Demonstrates device tree interaction with kernel modules */   \n2\n\n3#include <linux/init.h>  \n4#include <linux/kernel.h>  \n5#include <linux/module.h>  \n6#include <linux/of.h>\n\n7#include <linux/of_device.h>  \n8#include <linux/platform_device.h>  \n9#include <linux/version.h>  \n10\n\n11#define DRIVER_NAME \"lkmpg_devicetree\"  \n12  \n13/* Structure to hold device-specific data */\n\n14struct dt_device_data {  \n15    const char *label;  \n16    u32 reg_value;  \n17    u32 custom_value;\n\n18    bool has_clock;  \n19};  \n20  \n21/* Probe function - called when device tree node matches */\n\n22static int dt_probe(struct platform_device *pdev)  \n23{  \n24    struct device *dev = &pdev->dev;\n\n25    struct device_node *np = dev->of_node;  \n26    struct dt_device_data *data;  \n27    const char *string_prop;\n\n28    u32 value;  \n29    int ret;  \n30  \n31    pr_info(\"%s: Device tree probe called for %s\\n\", DRIVER_NAME,\n\n32            np->full_name);  \n33  \n34    /* Allocate memory for device data */\n\n35    data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);  \n36    if (!data)  \n37        return -ENOMEM;\n\n38  \n39    /* Read a string property */  \n40    ret = of_property_read_string(np, \"label\", &string_prop);\n\n41    if (ret == 0) {  \n42        data->label = string_prop;\n\n43        pr_info(\"%s: Found label property: %s\\n\", DRIVER_NAME, data->label);  \n44    } else {\n\n45        data->label = \"unnamed\";  \n46        pr_info(\"%s: No label property found, using default\\n\", DRIVER_NAME);\n\n47    }  \n48  \n49    /* Read a u32 property */  \n50    ret = of_property_read_u32(np, \"reg\", &value);\n\n51    if (ret == 0) {  \n52        data->reg_value = value;\n\n53        pr_info(\"%s: Found reg property: 0x%x\\n\", DRIVER_NAME, data->reg_value);  \n54    }  \n55\n\n56    /* Read a custom u32 property */  \n57    ret = of_property_read_u32(np, \"lkmpg,custom-value\", &value);\n\n58    if (ret == 0) {  \n59        data->custom_value = value;\n\n60        pr_info(\"%s: Found custom-value property: %u\\n\", DRIVER_NAME,\n\n61                data->custom_value);  \n62    } else {  \n63        data->custom_value = 42; /* Default value */\n\n64        pr_info(\"%s: No custom-value found, using default: %u\\n\", DRIVER_NAME,\n\n65                data->custom_value);  \n66    }  \n67  \n68    /* Check for presence of a property */\n\n69    data->has_clock = of_property_read_bool(np, \"lkmpg,has-clock\");\n\n70    pr_info(\"%s: has-clock property: %s\\n\", DRIVER_NAME,\n\n71            data->has_clock ? \"present\" : \"absent\");  \n72  \n73    /* Store device data for later use */\n\n74    platform_set_drvdata(pdev, data);  \n75  \n76    pr_info(\"%s: Device probe successful\\n\", DRIVER_NAME);\n\n77    return 0;  \n78}  \n79  \n80/* Remove function - called when device is removed */\n\n81#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)  \n82static void dt_remove(struct platform_device *pdev)\n\n83{  \n84    struct dt_device_data *data = platform_get_drvdata(pdev);  \n85\n\n86    pr_info(\"%s: Removing device %s\\n\", DRIVER_NAME, data->label);\n\n87    /* Cleanup is handled automatically by devm_* functions */\n\n88}  \n89#else  \n90static int dt_remove(struct platform_device *pdev)  \n91{\n\n92    struct dt_device_data *data = platform_get_drvdata(pdev);  \n93\n\n94    pr_info(\"%s: Removing device %s\\n\", DRIVER_NAME, data->label);\n\n95    /* Cleanup is handled automatically by devm_* functions */  \n96    return 0;  \n97}  \n98#endif  \n99\n\n100/* Device tree match table - defines compatible strings this driver supports */\n\n101static const struct of_device_id dt_match_table[] = {  \n102    {  \n103        .compatible = \"lkmpg,example-device\",\n\n104    },  \n105    {  \n106        .compatible = \"lkmpg,another-device\",  \n107    },  \n108    {} /* Sentinel */\n\n109};  \n110MODULE_DEVICE_TABLE(of, dt_match_table);  \n111  \n112/* Platform driver structure */\n\n113static struct platform_driver dt_driver = {  \n114    .probe = dt_probe,  \n115    .remove = dt_remove,\n\n116    .driver = {  \n117        .name = DRIVER_NAME,  \n118        .of_match_table = dt_match_table,\n\n119    },  \n120};  \n121  \n122/* Module initialization */  \n123static int __init dt_init(void)  \n124{  \n125    int ret;  \n126\n\n127    pr_info(\"%s: Initializing device tree example module\\n\", DRIVER_NAME);  \n128\n\n129    /* Register the platform driver */  \n130    ret = platform_driver_register(&dt_driver);\n\n131    if (ret) {  \n132        pr_err(\"%s: Failed to register platform driver\\n\", DRIVER_NAME);\n\n133        return ret;  \n134    }  \n135  \n136    pr_info(\"%s: Module loaded successfully\\n\", DRIVER_NAME);\n\n137    return 0;  \n138}  \n139  \n140/* Module cleanup */  \n141static void __exit dt_exit(void)  \n142{\n\n143    pr_info(\"%s: Cleaning up device tree example module\\n\", DRIVER_NAME);\n\n144    platform_driver_unregister(&dt_driver);  \n145}  \n146  \n147module_init(dt_init);  \n148module_exit(dt_exit);  \n149\n\n150MODULE_LICENSE(\"GPL\"); \n151MODULE_DESCRIPTION(\"Device tree interaction example for LKMPG\");\n```", "```\n 1/* Example device tree fragment */   \n2lkmpg_device@0 {  \n3    compatible = \"lkmpg,example-device\";\n\n4    reg = <0x40000000 0x1000>;  \n5    label = \"LKMPG Test Device\";  \n6    lkmpg,custom-value = <100>;\n\n7    lkmpg,has-clock; \n8};\n```", "```\n  1# List all platform devices   \n2ls /sys/bus/platform/devices/  \n3\n\n4# Check device tree nodes \n5ls /proc/device-tree/\n```", "```\n 1bvl = bvec_alloc(gfp_mask, nr_iovecs, &idx);   \n2if (unlikely(!bvl)) {\n\n3    mempool_free(bio, bio_pool);  \n4    bio = NULL;  \n5    goto out; \n6}\n```", "```\n 1CONFIG_JUMP_LABEL=y   \n2CONFIG_HAVE_ARCH_JUMP_LABEL=y \n3CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y\n```", "```\n 1DEFINE_STATIC_KEY_FALSE(fkey);\n```", "```\n 1pr_info(\"fastpath 1\\n\");   \n2if (static_branch_unlikely(&fkey))\n\n3    pr_alert(\"do unlikely thing\\n\"); \n4pr_info(\"fastpath 2\\n\");\n```", "```\n 1/*   \n2 * static_key.c  \n3 */  \n4   \n5#include <linux/atomic.h>  \n6#include <linux/device.h>  \n7#include <linux/fs.h>\n\n8#include <linux/kernel.h> /* for sprintf() */  \n9#include <linux/module.h>  \n10#include <linux/printk.h>\n\n11#include <linux/types.h>  \n12#include <linux/uaccess.h> /* for get_user and put_user */\n\n13#include <linux/jump_label.h> /* for static key macros */  \n14#include <linux/version.h>  \n15\n\n16#include <asm/errno.h>  \n17  \n18static int device_open(struct inode *inode, struct file *file);\n\n19static int device_release(struct inode *inode, struct file *file);\n\n20static ssize_t device_read(struct file *file, char __user *buf, size_t count,\n\n21                           loff_t *ppos);  \n22static ssize_t device_write(struct file *file, const char __user *buf,\n\n23                            size_t count, loff_t *ppos);  \n24  \n25#define DEVICE_NAME \"key_state\"\n\n26#define BUF_LEN 10  \n27  \n28static int major;  \n29  \n30enum {  \n31    CDEV_NOT_USED,  \n32    CDEV_EXCLUSIVE_OPEN,  \n33};  \n34\n\n35static atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);  \n36  \n37static char msg[BUF_LEN + 1];\n\n38  \n39static struct class *cls;  \n40  \n41static DEFINE_STATIC_KEY_FALSE(fkey);  \n42\n\n43static struct file_operations chardev_fops = {  \n44    .owner = THIS_MODULE,\n\n45    .open = device_open,  \n46    .release = device_release,  \n47    .read = device_read,\n\n48    .write = device_write,  \n49};  \n50  \n51static int __init chardev_init(void)  \n52{\n\n53    major = register_chrdev(0, DEVICE_NAME, &chardev_fops);  \n54    if (major < 0) {\n\n55        pr_alert(\"Registering char device failed with %d\\n\", major);\n\n56        return major;  \n57    }  \n58  \n59    pr_info(\"I was assigned major number %d\\n\", major);  \n60\n\n61#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)  \n62    cls = class_create(DEVICE_NAME);\n\n63#else  \n64    cls = class_create(THIS_MODULE, DEVICE_NAME);  \n65#endif  \n66\n\n67    device_create(cls, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);  \n68\n\n69    pr_info(\"Device created on /dev/%s\\n\", DEVICE_NAME);  \n70  \n71    return 0;  \n72}  \n73\n\n74static void __exit chardev_exit(void)  \n75{  \n76    device_destroy(cls, MKDEV(major, 0));\n\n77    class_destroy(cls);  \n78  \n79    /* Unregister the device */  \n80    unregister_chrdev(major, DEVICE_NAME);\n\n81}  \n82  \n83/* Methods */  \n84  \n85/**  \n86 * Called when a process tried to open the device file, like\n\n87 * cat /dev/key_state  \n88 */  \n89static int device_open(struct inode *inode, struct file *file)\n\n90{  \n91    if (atomic_cmpxchg(&already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))\n\n92        return -EBUSY;  \n93  \n94    sprintf(msg, static_key_enabled(&fkey) ? \"enabled\\n\" : \"disabled\\n\");\n\n95  \n96    pr_info(\"fastpath 1\\n\");  \n97    if (static_branch_unlikely(&fkey))\n\n98        pr_alert(\"do unlikely thing\\n\");  \n99    pr_info(\"fastpath 2\\n\");  \n100\n\n101    return 0;  \n102}  \n103  \n104/**  \n105 * Called when a process closes the device file\n\n106 */  \n107static int device_release(struct inode *inode, struct file *file)  \n108{\n\n109    /* We are now ready for our next caller. */  \n110    atomic_set(&already_open, CDEV_NOT_USED);  \n111\n\n112    return 0;  \n113}  \n114  \n115/**  \n116 * Called when a process, which already opened the dev file, attempts to\n\n117 * read from it.  \n118 */  \n119static ssize_t device_read(struct file *filp, /* see include/linux/fs.h */\n\n120                           char __user *buffer, /* buffer to fill with data */\n\n121                           size_t length, /* length of the buffer */\n\n122                           loff_t *offset)  \n123{  \n124    /* Number of the bytes actually written to the buffer */\n\n125    int bytes_read = 0;  \n126    const char *msg_ptr = msg;  \n127\n\n128    if (!*(msg_ptr + *offset)) { /* We are at the end of the message */\n\n129        *offset = 0; /* reset the offset */  \n130        return 0; /* signify end of file */  \n131    }  \n132\n\n133    msg_ptr += *offset;  \n134  \n135    /* Actually put the data into the buffer */  \n136    while (length && *msg_ptr) {\n\n137        /**  \n138         * The buffer is in the user data segment, not the kernel\n\n139         * segment so \"*\" assignment won't work. We have to use\n\n140         * put_user which copies data from the kernel data segment to\n\n141         * the user data segment.  \n142         */  \n143        put_user(*(msg_ptr++), buffer++);\n\n144        length--;  \n145        bytes_read++;  \n146    }  \n147  \n148    *offset += bytes_read;  \n149\n\n150    /* Most read functions return the number of bytes put into the buffer. */  \n151    return bytes_read;\n\n152}  \n153  \n154/* Called when a process writes to dev file; echo \"enable\" > /dev/key_state */\n\n155static ssize_t device_write(struct file *filp, const char __user *buffer,\n\n156                            size_t length, loff_t *offset)  \n157{  \n158    char command[10];  \n159\n\n160    if (length > 10) {  \n161        pr_err(\"command exceeded 10 char\\n\");  \n162        return -EINVAL;\n\n163    }  \n164  \n165    if (copy_from_user(command, buffer, length))  \n166        return -EFAULT;  \n167\n\n168    if (strncmp(command, \"enable\", strlen(\"enable\")) == 0)  \n169        static_branch_enable(&fkey);\n\n170    else if (strncmp(command, \"disable\", strlen(\"disable\")) == 0)\n\n171        static_branch_disable(&fkey);  \n172    else {  \n173        pr_err(\"Invalid command: %s\\n\", command);\n\n174        return -EINVAL;  \n175    }  \n176  \n177    /* Again, return the number of input characters used. */\n\n178    return length;  \n179}  \n180  \n181module_init(chardev_init);  \n182module_exit(chardev_exit);\n\n183 \n184MODULE_LICENSE(\"GPL\");\n```", "```\n  1cat /dev/key_state\n```", "```\n  1echo enable > /dev/key_state\n```"]