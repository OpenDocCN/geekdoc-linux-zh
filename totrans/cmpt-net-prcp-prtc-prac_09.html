<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Building a network#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Building a network#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/networks/network.html">https://4ed.computer-networking.info/syllabus/default/networks/network.html</a></blockquote>

<p>In the previous parts, we have explained how hosts operate while considering the network as a black box. In this part, we open the black box and describe how networks operate. The key layer for the operation of a network is the network layer illustrated in <a class="reference internal" href="../hosts/introduction.html#fig-network-layer"><span class="std std-numref">Fig. 5</span></a>. The main objective of the network layer is to allow hosts, connected to different networks, to exchange information through intermediate systems called <a class="reference internal" href="../glossary.html#term-router"><span class="xref std std-term">router</span></a>. The unit of information in the network layer is called a <a class="reference internal" href="../glossary.html#term-packet"><span class="xref std std-term">packet</span></a>.</p>
<p>Before explaining the operation of the network layer, it is useful to remember the characteristics of the service provided by the <cite>datalink</cite> layer. There are many variants of the datalink layer. Some provide a reliable service while others do not provide any guarantee of delivery. The reliable datalink layer services are popular in environments such as wireless networks where transmission errors are frequent. On the other hand, unreliable services are usually used when the physical layer provides an almost reliable service (i.e. only a negligible fraction of the frames are affected by transmission errors). Such <cite>almost reliable</cite> services are frequently used in wired and optical networks. In this chapter, we will assume that the datalink layer service provides an <cite>almost reliable</cite> service since this is both the most general one and also the most widely deployed one.</p>
<blockquote>
<div><div class="figure" id="id13" style="text-align: center">
<span id="fig-datalink-layer"/><p><img src="../Images/dc19c34d49b1c14ad1e1c5f6a6f78cc3.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e48b2a2d32de4a82e568f70dfc56177e37ec4851.png"/></p>
<p><span class="caption-number">Fig. 126 </span><span class="caption-text">The point-to-point datalink layer</span></p>
</div></div></blockquote>
<p>There are two main types of datalink layers. The simplest datalink layer is when there are only two communicating systems that are directly connected through the physical layer. Such a datalink layer is used when there is a point-to-point link between the two communicating systems. These two systems can be hosts or routers. PPP (Point-to-Point Protocol), defined in <span class="target" id="index-0"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1661.html"><strong>RFC 1661</strong></a>, is an example of such a point-to-point datalink layer. Datalink layer entities exchange <cite>frames</cite>. A datalink <a class="reference internal" href="../glossary.html#term-frame"><span class="xref std std-term">frame</span></a> sent by a datalink layer entity on the left is transmitted through the physical layer, so that it can reach the datalink layer entity on the right. Point-to-point datalink layers can either provide an unreliable service (frames can be corrupted or lost) or a reliable service (in this case, the datalink layer includes retransmission mechanisms).</p>
<p>The second type of datalink layer is the one used in Local Area Networks (LAN). Conceptually, a LAN is a set of communicating devices such that any two devices can directly exchange frames through the datalink layer. Both hosts and routers can be connected to a LAN. Some LANs only connect a few devices, but there are LANs that can connect hundreds or even thousands of devices. In this chapter, we focus on the utilization of point-to-point datalink layers. We describe later the organization and the operation of Local Area Networks and their impact on the network layer.</p>
<p>Even if we only consider the point-to-point datalink layers, there is an important characteristic of these layers that we cannot ignore. No datalink layer is able to send frames of unlimited size. Each datalink layer is characterized by a maximum frame size. There are more than dozen different datalink layers and unfortunately most of them use a different maximum frame size. This heterogeneity in the maximum frame sizes will cause problems when we will need to exchange data between hosts attached to different types of datalink layers.</p>
<p>As a first step, let us assume that we only need to exchange a small amount of data. In this case, there is no issue with the maximum length of the frames. However, there are other more interesting problems that we need to tackle. To understand these problems, let us consider the network represented in the figure <a class="reference internal" href="#fig-net-3hosts-5routers"><span class="std std-numref">Fig. 127</span></a>.</p>
<blockquote>
<div><div class="figure" id="id14" style="text-align: center">
<span id="fig-net-3hosts-5routers"/><p><img src="../Images/216416ec64aeca9b1fa48c3009b429db.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-fb72a346e373cc1c48e60df0d1893df3bff9f91a.png"/></p>
<p><span class="caption-number">Fig. 127 </span><span class="caption-text">A simple network containing three hosts and five routers</span></p>
</div></div></blockquote>
<p>This network contains two types of devices. The hosts, represented with circles and the routers, represented as boxes. A host is a device which is able to send and receive data for its own usage in contrast with routers that most of the time simply forward data towards their final destination. Routers have multiple links to neighboring routers or hosts. Hosts are usually attached via a single link to the network. Nowadays, with the growth of wireless networks, more and more hosts are equipped with several physical interfaces. These hosts are often called <cite>multihomed</cite>. Still, using several interfaces at the same time often leads to practical issues that are beyond the scope of this document. For this reason, we focus on <cite>single-homed</cite> hosts, i.e. hosts attached to a single network, in this e-book.</p>
<p>To understand the key principles behind the operation of a network, let us analyze all the operations that need to be performed to allow host <cite>A</cite> in the above network to send one byte to host <cite>B</cite>. Thanks to the datalink layer used above the <cite>A-R1</cite> link, host <cite>A</cite> can easily send a byte to router <cite>R1</cite> inside a frame. However, upon reception of this frame, router <cite>R1</cite> needs to understand that this byte is destined to host <cite>B</cite> and not to itself. This is the objective of the network layer.</p>
<p id="index-1">The network layer enables the transmission of information between hosts that are not directly connected through intermediate routers. This transmission is carried out by putting the information to be transmitted inside a data structure which is called a <cite>packet</cite>. As a frame that contains useful data and control information, a packet also contains both data supplied by the user and control information. An important issue in the network layer is the ability to identify a node (host or router) inside the network. This identification is performed by associating an address to each node. An <a class="reference internal" href="../glossary.html#term-address"><span class="xref std std-term">address</span></a> is usually represented as a sequence of bits. Most networks use fixed-length addresses. At this stage, let us simply assume that each of the nodes in the above network has an address which corresponds to the binary representation of its name on the figure.</p>
<p>To send one byte of information to host <cite>B</cite>, host <cite>A</cite> needs to place this information inside a <cite>packet</cite>. In addition to the data being transmitted, the packet also contains either the addresses of the source and the destination nodes or information that indicates the path that needs to be followed to reach the destination.</p>
<p>There are two possible organizations for the network layer :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>datagram</cite></p></li>
<li><p><cite>virtual circuits</cite></p></li>
</ul>
</div></blockquote>
<section id="the-datagram-organization">
<h2>The datagram organization<a class="headerlink" href="#the-datagram-organization" title="Link to this heading">#</a></h2>
<p>The first and most popular organization of the network layer is the datagram organization. This organization is inspired by the organization of the postal service. Each host is identified by a <cite>network layer address</cite>. To send information to a remote host, a host creates a packet that contains:</p>
<blockquote>
<div><ul class="simple">
<li><p>the network layer address of the destination host</p></li>
<li><p>its own network layer address</p></li>
<li><p>the information to be sent</p></li>
</ul>
</div></blockquote>
<p>To understand the datagram organization, let us consider <a class="reference internal" href="#fig-simple-internetwork"><span class="std std-numref">Fig. 128</span></a>. A network layer address, represented by a letter, has been assigned to each host and router. To send some information to host <cite>J</cite>, host <cite>A</cite> creates a packet containing its own address, the destination address and the information to be exchanged.</p>
<blockquote>
<div><div class="figure" id="id15" style="text-align: center">
<span id="fig-simple-internetwork"/><p><img src="../Images/b17c456b68f70d26fa9339dd30edb066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-193c99e6385daa99c4ea90e4ee589dd5ec7bf3c8.png"/></p>
<p><span class="caption-number">Fig. 128 </span><span class="caption-text">A simple internetwork</span></p>
</div></div></blockquote>
<p id="index-2">With the datagram organization, routers use <cite>hop-by-hop forwarding</cite>. This means that when a router receives a packet that is not destined to itself, it looks up the destination address of the packet in its <cite>forwarding table</cite>. A <cite>forwarding table</cite> is a data structure that maps each destination address (or set of destination addresses) to the outgoing interface over which a packet destined to this address must be forwarded to reach its final destination. The router consults its forwarding table to forward each packet that it handles.</p>
<p>The figure illustrates some possible forwarding tables in this network. By inspecting the forwarding tables of the different routers, one can find the path followed by packets sent from a source to a particular destination. In the example above, host <cite>A</cite> sends its packet to router <cite>R1</cite>. <cite>R1</cite> consults its forwarding table and forwards the packet towards <cite>R2</cite>. Based on its own table, <cite>R2</cite> decides to forward the packet to <cite>R5</cite> that can deliver it to its destination. Thus, the path from <cite>A</cite> to <cite>J</cite> is <cite>A -&gt; R1 -&gt; R2 -&gt; R5 -&gt; J</cite>.</p>
<p>The computation of the forwarding tables of all the routers inside a network is a key element for the correct operation of the network. This computation can be carried out by using either distributed or centralized algorithms. These algorithms provide different performance, may lead to different types of paths, but their composition must lead to valid paths.</p>
<p>In a network, a path can be defined as the list of all intermediate routers for a given source destination pair. For a given source/destination pair, the path can be derived by first consulting the forwarding table of the router attached to the source to determine the next router on the path towards the chosen destination. Then, the forwarding table of this router is queried for the same destination… The queries continue until the destination is reached. In a network that has valid forwarding tables, all the paths between all source/destination pairs contain a finite number of intermediate routers. However, if forwarding tables have not been correctly computed, two types of invalid paths can occur.</p>
<p id="index-3">A path may lead to a <cite>black hole</cite>. In a network, a black hole is a router that receives packets for at least one given source/destination pair but does not have an entry inside its forwarding table for this destination. Since it does not know how to reach the destination, the router cannot forward the received packets and must discard them. Any centralized or distributed algorithm that computes forwarding tables must ensure that there are not black holes inside the network.</p>
<p id="index-4">A second type of problem may exist in networks using the datagram organization. Consider a path that contains a cycle. For example, router <cite>R1</cite> sends all packets towards destination <cite>D</cite> via router <cite>R2</cite>. Router <cite>R2</cite> forwards these packets to router <cite>R3</cite> and finally router <cite>R3</cite>’s forwarding table uses router <cite>R1</cite> as its nexthop to reach destination <cite>D</cite>. In this case, if a packet destined to <cite>D</cite> is received by router <cite>R1</cite>, it will loop on the <cite>R1 -&gt; R2 -&gt; R3 -&gt; R1</cite> cycle and will never reach its final destination. As in the black hole case, the destination is not reachable from all sources in the network. In practice the loop problem is more annoying than the black hole problem because when a packet is caught in a forwarding loop, it unnecessarily consumes bandwidth. In the black hole case, the problematic packet is quickly discarded. We will see later that network layer protocols include techniques to minimize the impact of such forwarding loops.</p>
<p>Any solution which is used to compute the forwarding tables of a network must ensure that all destinations are reachable from any source. This implies that it must guarantee the absence of black holes and forwarding loops.</p>
<p id="index-5">The <cite>forwarding tables</cite> and the precise format of the packets that are exchanged inside the network are part of the <cite>data plane</cite> of the network. This <cite>data plane</cite> contains all the protocols and algorithms that are used by hosts and routers to create and process the packets that contain user data. On high-end routers, the data plane is often implemented in hardware for performance reasons.</p>
<p id="index-6">Besides the <cite>data plane</cite>, a network is also characterized by its <cite>control plane</cite>. The control plane includes all the protocols and algorithms (often distributed) that compute the forwarding tables that are installed on all routers inside the network. While there is only one possible <cite>data plane</cite> for a given networking technology, different networks using the same technology may use different control planes.</p>
<p>The simplest <cite>control plane</cite> for a network is to manually compute the forwarding tables of all routers inside the network. This simple control plane is sufficient when the network is (very) small, usually up to a few routers.</p>
<p>In most networks, manual forwarding tables are not a solution for two reasons. First, most networks are too large to enable a manual computation of the forwarding tables. Second, with manually computed forwarding tables, it is very difficult to deal with link and router failures. Networks need to operate 24h a day, 365 days per year. Many events can affect the routers and links that compose a network. Link failures are regular events in deployed networks. Links can fail for various reasons, including electromagnetic interference, fiber cuts, hardware or software problems on the terminating routers,… Some links also need to be either added to or removed from the network because their utilization is too low or their cost is too high.</p>
<p>Similarly, routers also fail. There are two types of failures that affect routers. A router may stop forwarding packets due to hardware or software problems (e.g., due to a crash of its operating system). A router may also need to be halted from time to time (e.g., to upgrade its operating system or to install new interface cards). These planned and unplanned events affect the set of links and routers that can be used to forward packets in the network. Still, most network users expect that their network will continue to correctly forward packets despite all these events. With manually computed forwarding tables, it is usually impossible to pre-compute the forwarding tables while taking into account all possible failure scenarios.</p>
<p>An alternative to manually computed forwarding tables is to use a network management platform that tracks the network status and can push new forwarding tables on the routers when it detects any modification to the network topology. This solution gives some flexibility to the network managers in computing the paths inside their network. However, this solution only works if the network management platform is always capable of reaching all routers even when the network topology changes. This may require a dedicated network that allows the management platform to push information on the forwarding tables. Openflow is a modern example of such solutions <a class="reference internal" href="../bibliography.html#mab2008" id="id1"><span>[MAB2008]</span></a>. In a nutshell, Openflow is a protocol that enables a network controller to install specific entries in the forwarding tables of remote routers and much more.</p>
<p>Another interesting point that is worth being discussed is when the forwarding tables are computed. A widely used solution is to compute the entries of the forwarding tables for all destinations on all routers. This ensures that each router has a valid route towards each destination. These entries can be updated when an event occurs and the network topology changes. A drawback of this approach is that the forwarding tables can become large in large networks since each router must always maintain one entry for each destination inside its forwarding table.</p>
<p>Some networks use the arrival of packets as the trigger to compute the corresponding entries in the forwarding tables. Several technologies have been built upon this principle. When a packet arrives, the router consults its forwarding table to find a path towards the destination. If the destination is present in the forwarding table, the packet is forwarded. Otherwise, the router needs to find a way to forward the packet and update its forwarding table.</p>
<section id="computing-forwarding-tables">
<h3>Computing forwarding tables<a class="headerlink" href="#computing-forwarding-tables" title="Link to this heading">#</a></h3>
<p>Networks deployed several techniques to update the forwarding tables upon the arrival of a packet. In this section, we briefly present the principles that underlie three of these techniques.</p>
<p>The first technique assumes that the underlying network topology is a tree. A tree is the simplest network to be considered when forwarding packets. The main advantage of using a tree is that there is only one path between any pair of nodes inside the network. Since a tree does not contain any cycle, it is impossible to have forwarding loops in a tree-shaped network.</p>
<p id="index-7">In a tree-shaped network, it is relatively simple for each node to automatically compute its forwarding table by inspecting the packets that it receives. For this, each node uses the source and destination addresses present inside each packet. Thanks to the source address, a node can learn the location of the different sources inside the network. Each source has a unique address. When a node receives a packet over a given interface, it learns that the source (address) of this packet is reachable via this interface. The node maintains a data structure that maps each known source address to an incoming interface. This data structure is often called the <cite>port-address table</cite> since it indicates the interface (or port) to reach a given address.</p>
<p>Learning the location of the sources is not sufficient, nodes also need to forward packets towards their destination. When a node receives a packet whose destination address is already present inside its port-address table, it simply forwards the packet on the interface listed in the port-address table. In this case, the packet will follow the port-address table entries in the downstream nodes and will reach the destination. If the destination address is not included in the port-address table, the node simply forwards the packet on all its interfaces, except the interface from which the packet was received. Forwarding a packet over all interfaces is usually called <cite>broadcasting</cite> in the terminology of computer networks. Sending the packet over all interfaces except one is a costly operation since the packet is sent over links that do not reach the destination. Given the tree-shape of the network, the packet will explore all downstream branches of the tree and will finally reach its destination. In practice, the <cite>broadcasting</cite> operation does not occur too often and its performance impact remains limited.</p>
<p>To understand the operation of the port-address table, let us consider the example network shown in <a class="reference internal" href="#fig-simple-tree-network"><span class="std std-numref">Fig. 129</span></a>. This network contains three hosts: <cite>A</cite>, <cite>B</cite> and <cite>C</cite> and five routers, <cite>R1</cite> to <cite>R5</cite>. When the network boots, all the forwarding tables of the nodes are empty.</p>
<blockquote>
<div><div class="figure" id="id16" style="text-align: center">
<span id="fig-simple-tree-network"/><p><img src="../Images/d7769586ddea01abce95ea2ac91eaad6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2bd54f92e493fb190c605f89e5a3a0962dc026f0.png"/></p>
<p><span class="caption-number">Fig. 129 </span><span class="caption-text">A simple tree-shaped network</span></p>
</div></div></blockquote>
<p>Host <cite>A</cite> sends a packet towards <cite>B</cite>. When receiving this packet, <cite>R1</cite> learns that <cite>A</cite> is reachable via its <cite>West</cite> interface. Since it does not have an entry for destination <cite>B</cite> in its port-address table, it forwards the packet to both <cite>R2</cite> and <cite>R3</cite>. When <cite>R2</cite> receives the packet, it updates its own forwarding table and forward the packet to <cite>C</cite>. Since <cite>C</cite> is not the intended recipient, it simply discards the received packet. Router <cite>R3</cite> also receives the packet. It learns that <cite>A</cite> is reachable via its <cite>North-West</cite> interface and broadcasts the packet to <cite>R4</cite> and <cite>R5</cite>. <cite>R5</cite> also updates its forwarding table and finally forwards it to destination <cite>B</cite>. Let us now consider what happens when <cite>B</cite> sends a reply to <cite>A</cite>. <cite>R5</cite>  first learns that <cite>B</cite> is attached to its <cite>North-East</cite> port. It then consults its port-address table and finds that <cite>A</cite> is reachable via its <cite>North-West</cite> interface. The packet is then forwarded hop-by-hop to <cite>A</cite> without any broadcasting. Later on, if <cite>C</cite> sends a packet to <cite>B</cite>, this packet will reach <cite>R1</cite> that contains a valid forwarding entry in its forwarding table.</p>
<p>By inspecting the source and destination addresses of packets, network nodes can automatically derive their forwarding tables. As we will discuss later, this technique is used in <a class="reference internal" href="../glossary.html#term-Ethernet"><span class="xref std std-term">Ethernet</span></a> networks. Despite being widely used, it has two important drawbacks. First, packets sent to unknown destinations must be broadcasted in the network even if the destination is not attached to the network. Consider the transmission of ten packets destined to <cite>Z</cite> in the network above. When a node receives a packet towards this destination, it can only broadcast that packet. Since <cite>Z</cite> is not attached to the network, no node will ever receive a packet whose source is <cite>Z</cite> to update its forwarding table. The second and more important problem is that few networks have a tree-shaped topology. It is interesting to analyze what happens when a port-address table is used in a network that contains a cycle. Consider the simple network shown in <a class="reference internal" href="#fig-simple-redundant-network"><span class="std std-numref">Fig. 130</span></a> with a single host.</p>
<blockquote>
<div><div class="figure" id="id17" style="text-align: center">
<span id="fig-simple-redundant-network"/><p><img src="../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-ac5be638528d298bb186b89d3eb42f1daa95f094.png"/></p>
<p><span class="caption-number">Fig. 130 </span><span class="caption-text">A simple and redundant network</span></p>
</div></div></blockquote>
<p>Assume that the network has started and all port-address and forwarding tables are empty. Host <cite>A</cite> sends a packet towards <cite>B</cite>. Upon reception of this packet, <cite>R1</cite> updates its port-address table. Since <cite>B</cite> is not present in the port-address table, the packet is broadcasted. Both <cite>R2</cite> and <cite>R3</cite> receive a copy of the packet sent by <cite>A</cite>. They both update their port-address table. Unfortunately, they also both broadcast the received packet. <cite>B</cite> receives a first copy of the packet, but <cite>R3</cite> and <cite>R2</cite> receive it again. <cite>R3</cite> will then broadcast this copy of the packet to <cite>B</cite> and <cite>R1</cite> while <cite>R2</cite> will broadcast its copy to <cite>R1</cite>. Although <cite>B</cite> has already received two copies of the packet, it is still inside the network and continues to loop. Due to the presence of the cycle, a single packet towards an unknown destination generates many copies of this packet that loop and will eventually saturate the network. Network operators who are using port-address tables to automatically compute the forwarding tables also use distributed algorithms to ensure that the network topology is always a tree.</p>
<p id="index-8">Another technique called <cite>source routing</cite> can be used to automatically compute forwarding tables. It has been used in interconnecting Token Ring networks and in some wireless networks. Intuitively, <cite>source routing</cite> enables a destination to automatically discover the paths from a given source towards itself. This technique requires nodes to encode information inside some packets. For simplicity, let us assume that the <cite>data plane</cite> supports two types of packets :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>data packets</cite></p></li>
<li><p>the <cite>control packets</cite></p></li>
</ul>
</div></blockquote>
<p><cite>Data packets</cite> are used to exchange data while <cite>control packets</cite> are used to discover the paths between hosts. With <cite>source routing</cite>, routers can be kept as simple as possible and all the complexity is placed on the hosts. This is in contrast with the previous technique where the nodes had to maintain a port-address and a forwarding table while the hosts simply sent and received packets. Each node is configured with one unique address and there is one identifier per outgoing link. For simplicity and to avoid cluttering the figures with those identifiers, we assume that each node uses as link identifiers north, west, south,… In practice, a node would associate one integer to each outgoing link. This is illustrated in <a class="reference internal" href="#fig-simple-2hosts-4routers"><span class="std std-numref">Fig. 131</span></a>.</p>
<blockquote>
<div><div class="figure" id="id18" style="text-align: center">
<span id="fig-simple-2hosts-4routers"/><p><img src="../Images/4bdec978a60e773b93a0a4c896847066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-254369ee4a0a0b60014d8a2fdbe9a6cb9d9e252e.png"/></p>
<p><span class="caption-number">Fig. 131 </span><span class="caption-text">A simple network with two hosts and four routers</span></p>
</div></div></blockquote>
<p>In the network above, router <cite>R2</cite> is attached to two outgoing links. <cite>R2</cite> is connected to both <cite>R1</cite> and <cite>R3</cite>. <cite>R2</cite> can easily determine that it is connected to these two nodes by exchanging packets with them or observing the packets that it receives over each interface. Assume for example that when a node (either host or router) starts, it sends a special control packet over each of its interfaces to advertise its own address to its neighbors. When a node receives such a packet, it automatically replies with its own address. This exchange can also be used to verify whether a neighbor, either router or host, is still alive. With <cite>source routing</cite>, the data plane packets include a list of identifiers. This list is called a <cite>source route</cite>. It indicates the path to be followed by the packet as a sequence of link identifiers. When a node receives such a <cite>data plane</cite> packet, it first checks whether the packet’s destination is a direct neighbor. In this case, the packet is forwarded to this neighbor. Otherwise, the node extracts the next address from the list and forwards it to the neighbor. This allows the source to specify the explicit path to be followed for each packet. For example, in the figure above there are two possible paths between <cite>A</cite> and <cite>B</cite>. To use the path via <cite>R2</cite>, <cite>A</cite> would send a packet that contains <cite>R1,R2,R3</cite> as source route. To avoid going via <cite>R2</cite>, <cite>A</cite> would place <cite>R1,R3</cite> as the source route in its transmitted packet. If <cite>A</cite> knows the complete network topology and all link identifiers, it can easily compute the source route towards each destination. It can even use different paths, e.g. for redundancy, to reach a given destination. However, in a real network hosts do not usually have a map of the entire network topology.</p>
<p id="index-9">In networks that rely on source routing, hosts use control packets to automatically discover the best path(s). In addition to the source and destination addresses, <cite>control packets</cite> contain a list that records the intermediate nodes. This list is often called the <cite>record route</cite> because it allows recording the route followed by a given packet. When a node receives such a <cite>control packet</cite>, it first checks whether its address is included in the record route. If yes, the packet has already been forwarded by this node and it is silently discarded. Otherwise, it adds its own address to the <cite>record route</cite> and forwards the packet to all its interfaces, except the interface over which the packet has been received. Thanks to this, the <cite>control packet</cite> can explore all paths between a source and a given destination.</p>
<p>For example, consider again the network topology above. <cite>A</cite> sends a control packet towards <cite>B</cite>. The initial <cite>record route</cite> is empty. When <cite>R1</cite> receives the packet, it adds its own address to the <cite>record route</cite> and forwards a copy to <cite>R2</cite> and another to <cite>R3</cite>. <cite>R2</cite> receives the packet, adds itself to the <cite>record route</cite> and forwards it to <cite>R3</cite>. <cite>R3</cite> receives two copies of the packet. The first contains the <cite>[R1,R2]</cite> <cite>record route</cite> and the second <cite>[R1]</cite>. In the end, <cite>B</cite> will receive two control packets containing  <cite>[R1,R2,R3,R4]</cite> and <cite>[R1,R3,R4]</cite> as <cite>record routes</cite>. <cite>B</cite> can keep these two paths or select the best one and discard the second. A popular heuristic is to select the <cite>record route</cite> of the first received packet as being the best one since this likely corresponds to the shortest delay path.</p>
<p>With the received <cite>record route</cite>, <cite>B</cite> can send a <cite>data packet</cite> to <cite>A</cite>. For this, it simply reverses the chosen <cite>record route</cite>. However, we still need to communicate the chosen path to <cite>A</cite>. This can be done by putting the <cite>record route</cite> inside a control packet which is sent back to <cite>A</cite> over the reverse path. An alternative is to simply send a <cite>data packet</cite> back to <cite>A</cite>. This packet will travel back to <cite>A</cite>. To allow <cite>A</cite> to inspect the entire path followed by the <cite>data packet</cite>, its <cite>source route</cite> must contain all intermediate routers when it is received by <cite>A</cite>. This can be achieved by encoding the <cite>source route</cite> using a data structure that contains an index and the ordered list of node addresses. The index always points to the next address in the <cite>source route</cite>. It is initialized at <cite>0</cite> when a packet is created and incremented by each intermediate node.</p>
<p>The third technique to compute forwarding tables is to rely on a control plane using a distributed algorithm. Routers exchange control messages to discover the network topology and build their forwarding table based on them. We dedicate a more detailed description of such distributed algorithms later in this section.</p>
</section>
<section id="flat-or-hierarchical-addresses">
<h3>Flat or hierarchical addresses<a class="headerlink" href="#flat-or-hierarchical-addresses" title="Link to this heading">#</a></h3>
<p>The last, but important, point to discuss about the <cite>data plane</cite> of the networks that rely on the datagram mode is their addressing scheme. In the examples above, we have used letters to represent the addresses of the hosts and network nodes. In practice, all addresses are encoded as a bit string. Most network technologies use a fixed size bit string to represent source and destination address. These addresses can be organized in two different ways.</p>
<p>The first organization, which is the one that we have implicitly assumed until now, is the <cite>flat addressing</cite> scheme. Under this scheme, each host and network node has a unique address. The unicity of the addresses is important for the operation of the network. If two hosts have the same address, it can become difficult for the network to forward packets towards this destination. <cite>Flat addresses</cite> are typically used in situations where network nodes and hosts need to be able to communicate immediately with unique addresses. These <cite>flat addresses</cite> are often embedded inside the network interface cards. The network card manufacturer creates one unique address for each interface and this address is stored in the read-only memory of the interface. An advantage of this addressing scheme is that it easily supports unstructured and mobile networks. When a host moves, it can attach to another network and remain confident that its address is unique and enables it to communicate inside the new network.</p>
<p>With <cite>flat addressing</cite> the lookup operation in the forwarding table can be implemented as an exact match. The <cite>forwarding table</cite> contains the (sorted) list of all known destination addresses. When a packet arrives, a network node only needs to check whether this address is included in the forwarding table or not. In software, this is an <cite>O(log(n))</cite> operation if the list is sorted. In hardware, Content Addressable Memories can efficiently perform this lookup operation, but their size is usually limited.</p>
<p>A drawback of the <cite>flat addressing scheme</cite> is that the forwarding tables linearly grow with the number of devices in the network. This addressing scheme is notably used by Ethernet networks described in chapter <a class="reference internal" href="lan.html#chapter-ethernet"><span class="std std-ref">Ethernet</span></a>. With this addressing scheme, each forwarding table must contain an entry that points to every address reachable inside the network. Since large networks can contain tens of millions of hosts or more, this is a major problem on routers that need to be able to quickly forward packets. As an illustration, it is interesting to consider the case of an interface running at 10 Gbps. Such interfaces are found on high-end servers and in various routers today. Assuming a packet size of 1000 bits, a conservative number, such interface must forward ten million packets every second. This implies that a router that receives packets over such a link must forward one 1000 bits packet every 100 nanoseconds. This is the same order of magnitude as the memory access times of old DRAMs. This delay decreases when packets are smaller or as links become faster. High-end routers today support 400 Gbps or 800 Gbps line cards.</p>
<p>A widely used alternative to the <cite>flat addressing scheme</cite> is the <cite>hierarchical addressing scheme</cite>. This addressing scheme builds upon the fact that networks usually contain much more hosts than routers. In this case, a first solution to reduce the size of the forwarding tables is to create a hierarchy of addresses. This is the solution chosen by the post office since postal addresses contain a country, sometimes a state or province, a city, a street and finally a street number. When an envelope is forwarded by a post office in a remote country, it only looks at the destination country, while a post office in the same province will look at the city information. Only the post office responsible for a given city will look at the street name and only the postman will use the street number. <cite>Hierarchical addresses</cite> provide a similar solution for network addresses. For example, the address of an Internet host attached to a campus network could contain in the high-order bits an identification of the Internet Service Provider (ISP) that serves the campus network. Then, a subsequent block of bits identifies the campus network which is one of the customers of the ISP. Finally, the low order bits of the address identify the host in the campus network. Both IPv4 and IPv6 use hierarchical addresses.</p>
<p>This hierarchical allocation of addresses can be applied in any type of network. In practice, the allocation of the addresses must follow the network topology. Usually, this is achieved by dividing the addressing space in consecutive blocks and then allocating these blocks to different parts of the network. In a small network, the simplest solution is to allocate one block of addresses to each network node and assign the host addresses from the attached node.</p>
<blockquote>
<div><div class="figure" id="id19" style="text-align: center">
<span id="fig-net-2hosts-4routers"/><p><img src="../Images/4bdec978a60e773b93a0a4c896847066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-254369ee4a0a0b60014d8a2fdbe9a6cb9d9e252e.png"/></p>
<p><span class="caption-number">Fig. 132 </span><span class="caption-text">A simple network with two hosts and four routers</span></p>
</div></div></blockquote>
<p>In figure <a class="reference internal" href="#fig-net-2hosts-4routers"><span class="std std-numref">Fig. 132</span></a>, assume that the network uses 16 bits addresses and that the prefix <cite>01001010</cite> has been assigned to the entire network. Since the network contains four routers, the network operator could assign one block of sixty-four addresses to each router. <cite>R1</cite> would use address <cite>0100101000000000</cite> while <cite>A</cite> could use address <cite>0100101000000001</cite>. <cite>R2</cite> could be assigned all addresses from <cite>0100101001000000</cite>  to <cite>0100101001111111</cite>. <cite>R4</cite> could then use <cite>0100101011000000</cite> and assign <cite>0100101011000001</cite> to <cite>B</cite>. Other allocation schemes are possible. For example, <cite>R3</cite> could be allocated a larger block of addresses than <cite>R2</cite> and <cite>R4</cite> could use a sub-block from <cite>R3</cite> ‘s address block.</p>
<p>The main advantage of hierarchical addresses is that it is possible to significantly reduce the size of the forwarding tables. In many networks, the number of routers can be several orders of magnitude smaller than the number of hosts. A campus network may contain a dozen routers and thousands of hosts. The largest Internet Services Providers typically contain no more than a few tens of thousands of routers but still serve tens or hundreds of millions of hosts.</p>
<p>Despite their popularity, <cite>hierarchical addresses</cite> have some drawbacks. Their first drawback is that a lookup in the forwarding table is more complex than when using <cite>flat addresses</cite>. For example, on the Internet, network nodes have to perform a longest-match to forward each packet. This is partially compensated by the reduction in the size of the forwarding tables, but the additional complexity of the lookup operation has been a difficulty to implement hardware support for packet forwarding. A second drawback of the utilization of hierarchical addresses is that when a host connects for the first time to a network, it must contact one router to determine its own address. This requires some packet exchanges between the host and some routers. Furthermore, if a host moves and is attached to another routers, its network address will change. This can be an issue with some mobile hosts.</p>
</section>
<section id="dealing-with-heterogeneous-datalink-layers">
<h3>Dealing with heterogeneous datalink layers<a class="headerlink" href="#dealing-with-heterogeneous-datalink-layers" title="Link to this heading">#</a></h3>
<p>Sometimes, the network layer needs to deal with heterogeneous datalink layers. For example, two hosts connected to different datalink layers exchange packets via routers that are using other types of datalink layers. Thanks to the network layer, this exchange of packets is possible provided that each packet can be placed inside a datalink layer frame before being transmitted. If all datalink layers support the same frame size, this is simple. When a node receives a frame, it decapsulates the packet that it contains, checks the header and forwards it, encapsulated inside another frame, to the outgoing interface. Unfortunately, the encapsulation operation is not always possible. Each datalink layer is characterized by the maximum frame size that it supports. Datalink layers typically support frames containing up to a few hundreds or a few thousands of bytes. The maximum frame size that a given datalink layer supports depends on its underlying technology. Unfortunately, most datalink layers support a different maximum frame size. This implies that when a host sends a large packet inside a frame to its nexthop router, there is a risk that this packet will have to traverse a link that is not capable of forwarding the packet inside a single frame. In principle, there are three possibilities to solve this problem. To discuss them, we consider a simple scenario with two hosts connected to a router as shown in the figure below.</p>
<blockquote>
<div><div class="figure" id="id20" style="text-align: center"><p><img src="../Images/b50bd82cdce23b386cd09872d74ee6e1.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-115ecc2aa8934e7f084e4f2798ef098265d83c68.png"/></p>
<p><span class="caption-number">Fig. 133 </span><span class="caption-text">A simple heterogeneous network</span></p>
</div></div></blockquote>
<p>Consider in the network above that host <cite>A</cite> wants to send a 900 bytes packet (870 bytes of payload and 30 bytes of header) to host <cite>B</cite> via router <cite>R1</cite>. Host <cite>A</cite> encapsulates this packet inside a single frame. The frame is received by router <cite>R1</cite> which extracts the packet. Router <cite>R1</cite> has three possible options to process this packet.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The packet is too large and router <cite>R1</cite> cannot forward it to router <cite>R2</cite>. It rejects the packet and sends a control packet back to the source (host <cite>A</cite>) to indicate that it cannot forward packets longer than 500 bytes (minus the packet header). The source could react to this control packet by retransmitting the information in smaller packets.</p></li>
<li><p>The network layer is able to fragment a packet. In our example, the router could fragment the packet in two parts. The first part contains the beginning of the payload and the second the end. There are two possible ways to perform this fragmentation.</p></li>
<li><p>Router <cite>R1</cite> fragments the packet into two fragments before transmitting them to router <cite>R2</cite>. Router <cite>R2</cite> reassembles the two packet fragments in a larger packet before transmitting them on the link towards host <cite>B</cite>.</p></li>
<li><p>Each of the packet fragments is a valid packet that contains a header with the source (host <cite>A</cite>) and destination (host <cite>B</cite>) addresses. When router <cite>R2</cite> receives a packet fragment, it treats this packet as a regular packet and forwards it to its final destination (host <cite>B</cite>). Host <cite>B</cite> reassembles the received fragments.</p></li>
</ol>
</div></blockquote>
<p>These three solutions have advantages and drawbacks. With the first solution, routers remain simple and do not need to perform any fragmentation operation. This is important when routers are implemented mainly in hardware. However, hosts must be complex since they need to store the packets that they produce if they need to pass through a link that does not support large packets. This increases the buffering required on the hosts.</p>
<p>Furthermore, a single large packet may potentially need to be retransmitted several times. Consider for example a network similar to the one shown above but with four routers. Assume that the link <cite>R1-&gt;R2</cite> supports 1000 bytes packets, link <cite>R2-&gt;R3</cite> 800 bytes packets and link <cite>R3-&gt;R4</cite> 600 bytes packets. A host attached to <cite>R1</cite> that sends large packet will have to first try 1000 bytes, then 800 bytes and finally 600 bytes. Fortunately, this scenario does not occur very often in practice and this is the reason why this solution is used in real networks.</p>
<p>Fragmenting packets on a per-link basis, as presented for the second solution, can minimize the transmission overhead since a packet is only fragmented on the links where fragmentation is required. Large packets can continue to be used downstream of a link that only accepts small packets. However, this reduction of the overhead comes with two drawbacks. First, fragmenting packets, potentially on all links, increases the processing time and the buffer requirements on the routers. Second, this solution leads to a longer end-to-end delay since the downstream router has to reassemble all the packet fragments before forwarding the packet.</p>
<p>The last solution is a compromise between the two others. Routers need to perform fragmentation but they do not need to reassemble packet fragments. Only the hosts need to have buffers to reassemble the received fragments. This solution has a lower end-to-end delay and requires fewer processing time and memory on the routers.</p>
<p>The first solution to the fragmentation problem presented above suggests the utilization of control packets to inform the source about the reception of a too long packet. This is only one of the functions that are performed by the control protocol in the network layer. Other functions include :</p>
<blockquote>
<div><ul class="simple">
<li><p>sending a control packet back to the source if a packet is received by a router that does not have a valid entry in its forwarding table</p></li>
<li><p>sending a control packet back to the source if a router detects that a packet is looping inside the network</p></li>
<li><p>verifying that packets can reach a given destination</p></li>
</ul>
</div></blockquote>
<p>We will discuss these functions in more details when we will describe the protocols that are used in the network layer of the TCP/IP protocol suite.</p>
</section>
</section>
<section id="virtual-circuit-organization">
<h2>Virtual circuit organization<a class="headerlink" href="#virtual-circuit-organization" title="Link to this heading">#</a></h2>
<p>The second organization of the network layer, called <cite>virtual circuits</cite>, has been inspired by the organization of telephone networks. Telephone networks have been designed to carry phone calls that usually last a few minutes. Each phone is identified by a telephone number and is attached to a telephone switch. To initiate a phone call, a telephone first needs to send the destination’s phone number to its local switch. The switch cooperates with the other switches in the network to create a bi-directional channel between the two telephones through the network. This channel will be used by the two telephones during the lifetime of the call and will be released at the end of the call. Until the 1960s, most of these channels were created manually, by telephone operators, upon request of the caller. Today’s telephone networks use automated switches and allow several channels to be carried over the same physical link, but the principles roughly remain the same.</p>
<p id="index-10">In a network using virtual circuits, all hosts are also identified with a network layer address. However, packet forwarding is not performed by looking at the destination address of each packet. With the <cite>virtual circuit</cite> organization, each data packet contains one label <a class="footnote-reference brackets" href="#flabels" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. A label is an integer which is part of the packet header. Routers implement <cite>label switching</cite> to forward <cite>labelled data packet</cite>. Upon reception of a packet, a router consults its <cite>label forwarding table</cite> to find the outgoing interface for this packet. In contrast with the datagram mode, this lookup is very simple. The <cite>label forwarding table</cite> is an array stored in memory and the label of the incoming packet is the index to access this array. This implies that the lookup operation has an <cite>O(1)</cite> complexity in contrast with other packet forwarding techniques. To ensure that on each node the packet label is an index in the <cite>label forwarding table</cite>, each router that forwards a packet replaces the label of the forwarded packet with the label found in the <cite>label forwarding table</cite>.  Each entry of the <cite>label forwarding table</cite> contains two pieces of information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the outgoing interface for the packet</p></li>
<li><p>the label for the outgoing packet</p></li>
</ul>
</div></blockquote>
<p>For example, consider the <cite>label forwarding table</cite> of a network node below.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>South</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>none</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>West</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>East</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</div>
<p>If this node receives a packet with <cite>label=2</cite>, it forwards the packet on its <cite>West</cite> interface and sets the <cite>label</cite> of the outgoing packet to <cite>2</cite>. If the received packet’s <cite>label</cite> is set to <cite>3</cite>, then the packet is forwarded over the <cite>East</cite> interface and the <cite>label</cite> of the outgoing packet is set to <cite>2</cite>. If a packet is received with a label field set to <cite>1</cite>, the packet is discarded since the corresponding <cite>label forwarding table</cite> entry is invalid.</p>
<p><cite>Label switching</cite> enables a full control over the path followed by packets inside the network. Consider the network below and assume that we want to use two virtual circuits : <cite>R1-&gt;R3-&gt;R4-&gt;R2-&gt;R5</cite> and <cite>R2-&gt;R1-&gt;R3-&gt;R4-&gt;R5</cite>.</p>
<blockquote>
<div><div class="figure" id="id21" style="text-align: center"><p><img src="../Images/c5fa5b3b06d080fc6776a20d0bcd17c6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-a8b394cac1086224030e6f2e7bc39e71dd067d5f.png"/></p>
<p><span class="caption-number">Fig. 134 </span><span class="caption-text">An example of network where label switching can be applied to tune its paths</span></p>
</div></div></blockquote>
<p>To create these virtual circuits, we need to configure the <cite>label forwarding tables</cite> of all routers. For simplicity, assume that a label forwarding table only contains two entries. Assume that <cite>R5</cite> wants to receive the packets from the virtual circuit created by <cite>R1</cite> (resp. <cite>R2</cite>) with <cite>label=1</cite> (<cite>label=0</cite>). <cite>R4</cite> could use the following <cite>label forwarding table</cite>:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R4’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-&gt;R2</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R5</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</div>
<p>Since a packet received with <cite>label=1</cite> must be forwarded to <cite>R5</cite> with <cite>label=1</cite>, <cite>R2</cite>’s <cite>label forwarding table</cite> could contain :</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R2’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>none</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R5</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div>
<p>Two virtual circuits pass through <cite>R3</cite>. They both need to be forwarded to <cite>R4</cite>, but <cite>R4</cite> expects <cite>label=1</cite> for packets belonging to the virtual circuit originated by <cite>R2</cite> and <cite>label=0</cite> for packets belonging to the other virtual circuit. <cite>R3</cite> could choose to leave the labels unchanged.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R3’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-&gt;R4</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R4</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div>
<p>With the above <cite>label forwarding table</cite>, <cite>R1</cite> needs to originate the packets that belong to the <cite>R1-&gt;R3-&gt;R4-&gt;R2-&gt;R5</cite> circuit with <cite>label=0</cite>. The packets received from <cite>R2</cite> and belonging to the <cite>R2-&gt;R1-&gt;R3-&gt;R4-&gt;R5</cite> circuit would then use <cite>label=1</cite> on the <cite>R1-R3</cite> link. <cite>R1</cite> ‘s label forwarding table could be built as follows :</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R1’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-&gt;R3</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R3</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div>
<p>The figure below shows the path followed by the packets on the <cite>R1-&gt;R3-&gt;R4-&gt;R2-&gt;R5</cite> path in red with on each arrow the label used in the packets.</p>
<blockquote>
<div><div class="figure" id="id22" style="text-align: center"><p><img src="../Images/aac335913fe6b920a1747148900960d0.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2afa2a575d1b8c3f5168dab2fa0a10a06fbbf081.png"/></p>
<p><span class="caption-number">Fig. 135 </span><span class="caption-text">The path followed by packets for a specific circuit</span></p>
</div></div></blockquote>
<p>MultiProtocol Label Switching (MPLS) is the example of a deployed networking technology that relies on label switching. MPLS is more complex than the above description because it has been designed to be easily integrated with datagram technologies. However, the principles remain. <cite>Asynchronous Transfer Mode</cite> (ATM) and Frame Relay are other examples of technologies that rely on <cite>label switching</cite>.</p>
<p>Nowadays, most deployed networks rely on distributed algorithms, called routing protocols, to compute the forwarding tables that are installed on the routers. These distributed algorithms are part of the <cite>control plane</cite>. They are usually implemented in software and are executed on the main CPU of the routers. There are two main families of routing protocols : distance vector routing and link state routing. Both are capable of discovering autonomously the network and react dynamically to topology changes.</p>
<span class="target" id="index-11"/><p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="flabels" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>We will see later a more detailed description of Multiprotocol Label Switching, a networking technology that is capable of using one or more labels.</p>
</aside>
</aside>
</section>
&#13;

<h2>The datagram organization<a class="headerlink" href="#the-datagram-organization" title="Link to this heading">#</a></h2>
<p>The first and most popular organization of the network layer is the datagram organization. This organization is inspired by the organization of the postal service. Each host is identified by a <cite>network layer address</cite>. To send information to a remote host, a host creates a packet that contains:</p>
<blockquote>
<div><ul class="simple">
<li><p>the network layer address of the destination host</p></li>
<li><p>its own network layer address</p></li>
<li><p>the information to be sent</p></li>
</ul>
</div></blockquote>
<p>To understand the datagram organization, let us consider <a class="reference internal" href="#fig-simple-internetwork"><span class="std std-numref">Fig. 128</span></a>. A network layer address, represented by a letter, has been assigned to each host and router. To send some information to host <cite>J</cite>, host <cite>A</cite> creates a packet containing its own address, the destination address and the information to be exchanged.</p>
<blockquote>
<div><div class="figure" id="id15" style="text-align: center">
<span id="fig-simple-internetwork"/><p><img src="../Images/b17c456b68f70d26fa9339dd30edb066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-193c99e6385daa99c4ea90e4ee589dd5ec7bf3c8.png"/></p>
<p><span class="caption-number">Fig. 128 </span><span class="caption-text">A simple internetwork</span></p>
</div></div></blockquote>
<p id="index-2">With the datagram organization, routers use <cite>hop-by-hop forwarding</cite>. This means that when a router receives a packet that is not destined to itself, it looks up the destination address of the packet in its <cite>forwarding table</cite>. A <cite>forwarding table</cite> is a data structure that maps each destination address (or set of destination addresses) to the outgoing interface over which a packet destined to this address must be forwarded to reach its final destination. The router consults its forwarding table to forward each packet that it handles.</p>
<p>The figure illustrates some possible forwarding tables in this network. By inspecting the forwarding tables of the different routers, one can find the path followed by packets sent from a source to a particular destination. In the example above, host <cite>A</cite> sends its packet to router <cite>R1</cite>. <cite>R1</cite> consults its forwarding table and forwards the packet towards <cite>R2</cite>. Based on its own table, <cite>R2</cite> decides to forward the packet to <cite>R5</cite> that can deliver it to its destination. Thus, the path from <cite>A</cite> to <cite>J</cite> is <cite>A -&gt; R1 -&gt; R2 -&gt; R5 -&gt; J</cite>.</p>
<p>The computation of the forwarding tables of all the routers inside a network is a key element for the correct operation of the network. This computation can be carried out by using either distributed or centralized algorithms. These algorithms provide different performance, may lead to different types of paths, but their composition must lead to valid paths.</p>
<p>In a network, a path can be defined as the list of all intermediate routers for a given source destination pair. For a given source/destination pair, the path can be derived by first consulting the forwarding table of the router attached to the source to determine the next router on the path towards the chosen destination. Then, the forwarding table of this router is queried for the same destination… The queries continue until the destination is reached. In a network that has valid forwarding tables, all the paths between all source/destination pairs contain a finite number of intermediate routers. However, if forwarding tables have not been correctly computed, two types of invalid paths can occur.</p>
<p id="index-3">A path may lead to a <cite>black hole</cite>. In a network, a black hole is a router that receives packets for at least one given source/destination pair but does not have an entry inside its forwarding table for this destination. Since it does not know how to reach the destination, the router cannot forward the received packets and must discard them. Any centralized or distributed algorithm that computes forwarding tables must ensure that there are not black holes inside the network.</p>
<p id="index-4">A second type of problem may exist in networks using the datagram organization. Consider a path that contains a cycle. For example, router <cite>R1</cite> sends all packets towards destination <cite>D</cite> via router <cite>R2</cite>. Router <cite>R2</cite> forwards these packets to router <cite>R3</cite> and finally router <cite>R3</cite>’s forwarding table uses router <cite>R1</cite> as its nexthop to reach destination <cite>D</cite>. In this case, if a packet destined to <cite>D</cite> is received by router <cite>R1</cite>, it will loop on the <cite>R1 -&gt; R2 -&gt; R3 -&gt; R1</cite> cycle and will never reach its final destination. As in the black hole case, the destination is not reachable from all sources in the network. In practice the loop problem is more annoying than the black hole problem because when a packet is caught in a forwarding loop, it unnecessarily consumes bandwidth. In the black hole case, the problematic packet is quickly discarded. We will see later that network layer protocols include techniques to minimize the impact of such forwarding loops.</p>
<p>Any solution which is used to compute the forwarding tables of a network must ensure that all destinations are reachable from any source. This implies that it must guarantee the absence of black holes and forwarding loops.</p>
<p id="index-5">The <cite>forwarding tables</cite> and the precise format of the packets that are exchanged inside the network are part of the <cite>data plane</cite> of the network. This <cite>data plane</cite> contains all the protocols and algorithms that are used by hosts and routers to create and process the packets that contain user data. On high-end routers, the data plane is often implemented in hardware for performance reasons.</p>
<p id="index-6">Besides the <cite>data plane</cite>, a network is also characterized by its <cite>control plane</cite>. The control plane includes all the protocols and algorithms (often distributed) that compute the forwarding tables that are installed on all routers inside the network. While there is only one possible <cite>data plane</cite> for a given networking technology, different networks using the same technology may use different control planes.</p>
<p>The simplest <cite>control plane</cite> for a network is to manually compute the forwarding tables of all routers inside the network. This simple control plane is sufficient when the network is (very) small, usually up to a few routers.</p>
<p>In most networks, manual forwarding tables are not a solution for two reasons. First, most networks are too large to enable a manual computation of the forwarding tables. Second, with manually computed forwarding tables, it is very difficult to deal with link and router failures. Networks need to operate 24h a day, 365 days per year. Many events can affect the routers and links that compose a network. Link failures are regular events in deployed networks. Links can fail for various reasons, including electromagnetic interference, fiber cuts, hardware or software problems on the terminating routers,… Some links also need to be either added to or removed from the network because their utilization is too low or their cost is too high.</p>
<p>Similarly, routers also fail. There are two types of failures that affect routers. A router may stop forwarding packets due to hardware or software problems (e.g., due to a crash of its operating system). A router may also need to be halted from time to time (e.g., to upgrade its operating system or to install new interface cards). These planned and unplanned events affect the set of links and routers that can be used to forward packets in the network. Still, most network users expect that their network will continue to correctly forward packets despite all these events. With manually computed forwarding tables, it is usually impossible to pre-compute the forwarding tables while taking into account all possible failure scenarios.</p>
<p>An alternative to manually computed forwarding tables is to use a network management platform that tracks the network status and can push new forwarding tables on the routers when it detects any modification to the network topology. This solution gives some flexibility to the network managers in computing the paths inside their network. However, this solution only works if the network management platform is always capable of reaching all routers even when the network topology changes. This may require a dedicated network that allows the management platform to push information on the forwarding tables. Openflow is a modern example of such solutions <a class="reference internal" href="../bibliography.html#mab2008" id="id1"><span>[MAB2008]</span></a>. In a nutshell, Openflow is a protocol that enables a network controller to install specific entries in the forwarding tables of remote routers and much more.</p>
<p>Another interesting point that is worth being discussed is when the forwarding tables are computed. A widely used solution is to compute the entries of the forwarding tables for all destinations on all routers. This ensures that each router has a valid route towards each destination. These entries can be updated when an event occurs and the network topology changes. A drawback of this approach is that the forwarding tables can become large in large networks since each router must always maintain one entry for each destination inside its forwarding table.</p>
<p>Some networks use the arrival of packets as the trigger to compute the corresponding entries in the forwarding tables. Several technologies have been built upon this principle. When a packet arrives, the router consults its forwarding table to find a path towards the destination. If the destination is present in the forwarding table, the packet is forwarded. Otherwise, the router needs to find a way to forward the packet and update its forwarding table.</p>
<section id="computing-forwarding-tables">
<h3>Computing forwarding tables<a class="headerlink" href="#computing-forwarding-tables" title="Link to this heading">#</a></h3>
<p>Networks deployed several techniques to update the forwarding tables upon the arrival of a packet. In this section, we briefly present the principles that underlie three of these techniques.</p>
<p>The first technique assumes that the underlying network topology is a tree. A tree is the simplest network to be considered when forwarding packets. The main advantage of using a tree is that there is only one path between any pair of nodes inside the network. Since a tree does not contain any cycle, it is impossible to have forwarding loops in a tree-shaped network.</p>
<p id="index-7">In a tree-shaped network, it is relatively simple for each node to automatically compute its forwarding table by inspecting the packets that it receives. For this, each node uses the source and destination addresses present inside each packet. Thanks to the source address, a node can learn the location of the different sources inside the network. Each source has a unique address. When a node receives a packet over a given interface, it learns that the source (address) of this packet is reachable via this interface. The node maintains a data structure that maps each known source address to an incoming interface. This data structure is often called the <cite>port-address table</cite> since it indicates the interface (or port) to reach a given address.</p>
<p>Learning the location of the sources is not sufficient, nodes also need to forward packets towards their destination. When a node receives a packet whose destination address is already present inside its port-address table, it simply forwards the packet on the interface listed in the port-address table. In this case, the packet will follow the port-address table entries in the downstream nodes and will reach the destination. If the destination address is not included in the port-address table, the node simply forwards the packet on all its interfaces, except the interface from which the packet was received. Forwarding a packet over all interfaces is usually called <cite>broadcasting</cite> in the terminology of computer networks. Sending the packet over all interfaces except one is a costly operation since the packet is sent over links that do not reach the destination. Given the tree-shape of the network, the packet will explore all downstream branches of the tree and will finally reach its destination. In practice, the <cite>broadcasting</cite> operation does not occur too often and its performance impact remains limited.</p>
<p>To understand the operation of the port-address table, let us consider the example network shown in <a class="reference internal" href="#fig-simple-tree-network"><span class="std std-numref">Fig. 129</span></a>. This network contains three hosts: <cite>A</cite>, <cite>B</cite> and <cite>C</cite> and five routers, <cite>R1</cite> to <cite>R5</cite>. When the network boots, all the forwarding tables of the nodes are empty.</p>
<blockquote>
<div><div class="figure" id="id16" style="text-align: center">
<span id="fig-simple-tree-network"/><p><img src="../Images/d7769586ddea01abce95ea2ac91eaad6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2bd54f92e493fb190c605f89e5a3a0962dc026f0.png"/></p>
<p><span class="caption-number">Fig. 129 </span><span class="caption-text">A simple tree-shaped network</span></p>
</div></div></blockquote>
<p>Host <cite>A</cite> sends a packet towards <cite>B</cite>. When receiving this packet, <cite>R1</cite> learns that <cite>A</cite> is reachable via its <cite>West</cite> interface. Since it does not have an entry for destination <cite>B</cite> in its port-address table, it forwards the packet to both <cite>R2</cite> and <cite>R3</cite>. When <cite>R2</cite> receives the packet, it updates its own forwarding table and forward the packet to <cite>C</cite>. Since <cite>C</cite> is not the intended recipient, it simply discards the received packet. Router <cite>R3</cite> also receives the packet. It learns that <cite>A</cite> is reachable via its <cite>North-West</cite> interface and broadcasts the packet to <cite>R4</cite> and <cite>R5</cite>. <cite>R5</cite> also updates its forwarding table and finally forwards it to destination <cite>B</cite>. Let us now consider what happens when <cite>B</cite> sends a reply to <cite>A</cite>. <cite>R5</cite>  first learns that <cite>B</cite> is attached to its <cite>North-East</cite> port. It then consults its port-address table and finds that <cite>A</cite> is reachable via its <cite>North-West</cite> interface. The packet is then forwarded hop-by-hop to <cite>A</cite> without any broadcasting. Later on, if <cite>C</cite> sends a packet to <cite>B</cite>, this packet will reach <cite>R1</cite> that contains a valid forwarding entry in its forwarding table.</p>
<p>By inspecting the source and destination addresses of packets, network nodes can automatically derive their forwarding tables. As we will discuss later, this technique is used in <a class="reference internal" href="../glossary.html#term-Ethernet"><span class="xref std std-term">Ethernet</span></a> networks. Despite being widely used, it has two important drawbacks. First, packets sent to unknown destinations must be broadcasted in the network even if the destination is not attached to the network. Consider the transmission of ten packets destined to <cite>Z</cite> in the network above. When a node receives a packet towards this destination, it can only broadcast that packet. Since <cite>Z</cite> is not attached to the network, no node will ever receive a packet whose source is <cite>Z</cite> to update its forwarding table. The second and more important problem is that few networks have a tree-shaped topology. It is interesting to analyze what happens when a port-address table is used in a network that contains a cycle. Consider the simple network shown in <a class="reference internal" href="#fig-simple-redundant-network"><span class="std std-numref">Fig. 130</span></a> with a single host.</p>
<blockquote>
<div><div class="figure" id="id17" style="text-align: center">
<span id="fig-simple-redundant-network"/><p><img src="../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-ac5be638528d298bb186b89d3eb42f1daa95f094.png"/></p>
<p><span class="caption-number">Fig. 130 </span><span class="caption-text">A simple and redundant network</span></p>
</div></div></blockquote>
<p>Assume that the network has started and all port-address and forwarding tables are empty. Host <cite>A</cite> sends a packet towards <cite>B</cite>. Upon reception of this packet, <cite>R1</cite> updates its port-address table. Since <cite>B</cite> is not present in the port-address table, the packet is broadcasted. Both <cite>R2</cite> and <cite>R3</cite> receive a copy of the packet sent by <cite>A</cite>. They both update their port-address table. Unfortunately, they also both broadcast the received packet. <cite>B</cite> receives a first copy of the packet, but <cite>R3</cite> and <cite>R2</cite> receive it again. <cite>R3</cite> will then broadcast this copy of the packet to <cite>B</cite> and <cite>R1</cite> while <cite>R2</cite> will broadcast its copy to <cite>R1</cite>. Although <cite>B</cite> has already received two copies of the packet, it is still inside the network and continues to loop. Due to the presence of the cycle, a single packet towards an unknown destination generates many copies of this packet that loop and will eventually saturate the network. Network operators who are using port-address tables to automatically compute the forwarding tables also use distributed algorithms to ensure that the network topology is always a tree.</p>
<p id="index-8">Another technique called <cite>source routing</cite> can be used to automatically compute forwarding tables. It has been used in interconnecting Token Ring networks and in some wireless networks. Intuitively, <cite>source routing</cite> enables a destination to automatically discover the paths from a given source towards itself. This technique requires nodes to encode information inside some packets. For simplicity, let us assume that the <cite>data plane</cite> supports two types of packets :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>data packets</cite></p></li>
<li><p>the <cite>control packets</cite></p></li>
</ul>
</div></blockquote>
<p><cite>Data packets</cite> are used to exchange data while <cite>control packets</cite> are used to discover the paths between hosts. With <cite>source routing</cite>, routers can be kept as simple as possible and all the complexity is placed on the hosts. This is in contrast with the previous technique where the nodes had to maintain a port-address and a forwarding table while the hosts simply sent and received packets. Each node is configured with one unique address and there is one identifier per outgoing link. For simplicity and to avoid cluttering the figures with those identifiers, we assume that each node uses as link identifiers north, west, south,… In practice, a node would associate one integer to each outgoing link. This is illustrated in <a class="reference internal" href="#fig-simple-2hosts-4routers"><span class="std std-numref">Fig. 131</span></a>.</p>
<blockquote>
<div><div class="figure" id="id18" style="text-align: center">
<span id="fig-simple-2hosts-4routers"/><p><img src="../Images/4bdec978a60e773b93a0a4c896847066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-254369ee4a0a0b60014d8a2fdbe9a6cb9d9e252e.png"/></p>
<p><span class="caption-number">Fig. 131 </span><span class="caption-text">A simple network with two hosts and four routers</span></p>
</div></div></blockquote>
<p>In the network above, router <cite>R2</cite> is attached to two outgoing links. <cite>R2</cite> is connected to both <cite>R1</cite> and <cite>R3</cite>. <cite>R2</cite> can easily determine that it is connected to these two nodes by exchanging packets with them or observing the packets that it receives over each interface. Assume for example that when a node (either host or router) starts, it sends a special control packet over each of its interfaces to advertise its own address to its neighbors. When a node receives such a packet, it automatically replies with its own address. This exchange can also be used to verify whether a neighbor, either router or host, is still alive. With <cite>source routing</cite>, the data plane packets include a list of identifiers. This list is called a <cite>source route</cite>. It indicates the path to be followed by the packet as a sequence of link identifiers. When a node receives such a <cite>data plane</cite> packet, it first checks whether the packet’s destination is a direct neighbor. In this case, the packet is forwarded to this neighbor. Otherwise, the node extracts the next address from the list and forwards it to the neighbor. This allows the source to specify the explicit path to be followed for each packet. For example, in the figure above there are two possible paths between <cite>A</cite> and <cite>B</cite>. To use the path via <cite>R2</cite>, <cite>A</cite> would send a packet that contains <cite>R1,R2,R3</cite> as source route. To avoid going via <cite>R2</cite>, <cite>A</cite> would place <cite>R1,R3</cite> as the source route in its transmitted packet. If <cite>A</cite> knows the complete network topology and all link identifiers, it can easily compute the source route towards each destination. It can even use different paths, e.g. for redundancy, to reach a given destination. However, in a real network hosts do not usually have a map of the entire network topology.</p>
<p id="index-9">In networks that rely on source routing, hosts use control packets to automatically discover the best path(s). In addition to the source and destination addresses, <cite>control packets</cite> contain a list that records the intermediate nodes. This list is often called the <cite>record route</cite> because it allows recording the route followed by a given packet. When a node receives such a <cite>control packet</cite>, it first checks whether its address is included in the record route. If yes, the packet has already been forwarded by this node and it is silently discarded. Otherwise, it adds its own address to the <cite>record route</cite> and forwards the packet to all its interfaces, except the interface over which the packet has been received. Thanks to this, the <cite>control packet</cite> can explore all paths between a source and a given destination.</p>
<p>For example, consider again the network topology above. <cite>A</cite> sends a control packet towards <cite>B</cite>. The initial <cite>record route</cite> is empty. When <cite>R1</cite> receives the packet, it adds its own address to the <cite>record route</cite> and forwards a copy to <cite>R2</cite> and another to <cite>R3</cite>. <cite>R2</cite> receives the packet, adds itself to the <cite>record route</cite> and forwards it to <cite>R3</cite>. <cite>R3</cite> receives two copies of the packet. The first contains the <cite>[R1,R2]</cite> <cite>record route</cite> and the second <cite>[R1]</cite>. In the end, <cite>B</cite> will receive two control packets containing  <cite>[R1,R2,R3,R4]</cite> and <cite>[R1,R3,R4]</cite> as <cite>record routes</cite>. <cite>B</cite> can keep these two paths or select the best one and discard the second. A popular heuristic is to select the <cite>record route</cite> of the first received packet as being the best one since this likely corresponds to the shortest delay path.</p>
<p>With the received <cite>record route</cite>, <cite>B</cite> can send a <cite>data packet</cite> to <cite>A</cite>. For this, it simply reverses the chosen <cite>record route</cite>. However, we still need to communicate the chosen path to <cite>A</cite>. This can be done by putting the <cite>record route</cite> inside a control packet which is sent back to <cite>A</cite> over the reverse path. An alternative is to simply send a <cite>data packet</cite> back to <cite>A</cite>. This packet will travel back to <cite>A</cite>. To allow <cite>A</cite> to inspect the entire path followed by the <cite>data packet</cite>, its <cite>source route</cite> must contain all intermediate routers when it is received by <cite>A</cite>. This can be achieved by encoding the <cite>source route</cite> using a data structure that contains an index and the ordered list of node addresses. The index always points to the next address in the <cite>source route</cite>. It is initialized at <cite>0</cite> when a packet is created and incremented by each intermediate node.</p>
<p>The third technique to compute forwarding tables is to rely on a control plane using a distributed algorithm. Routers exchange control messages to discover the network topology and build their forwarding table based on them. We dedicate a more detailed description of such distributed algorithms later in this section.</p>
</section>
<section id="flat-or-hierarchical-addresses">
<h3>Flat or hierarchical addresses<a class="headerlink" href="#flat-or-hierarchical-addresses" title="Link to this heading">#</a></h3>
<p>The last, but important, point to discuss about the <cite>data plane</cite> of the networks that rely on the datagram mode is their addressing scheme. In the examples above, we have used letters to represent the addresses of the hosts and network nodes. In practice, all addresses are encoded as a bit string. Most network technologies use a fixed size bit string to represent source and destination address. These addresses can be organized in two different ways.</p>
<p>The first organization, which is the one that we have implicitly assumed until now, is the <cite>flat addressing</cite> scheme. Under this scheme, each host and network node has a unique address. The unicity of the addresses is important for the operation of the network. If two hosts have the same address, it can become difficult for the network to forward packets towards this destination. <cite>Flat addresses</cite> are typically used in situations where network nodes and hosts need to be able to communicate immediately with unique addresses. These <cite>flat addresses</cite> are often embedded inside the network interface cards. The network card manufacturer creates one unique address for each interface and this address is stored in the read-only memory of the interface. An advantage of this addressing scheme is that it easily supports unstructured and mobile networks. When a host moves, it can attach to another network and remain confident that its address is unique and enables it to communicate inside the new network.</p>
<p>With <cite>flat addressing</cite> the lookup operation in the forwarding table can be implemented as an exact match. The <cite>forwarding table</cite> contains the (sorted) list of all known destination addresses. When a packet arrives, a network node only needs to check whether this address is included in the forwarding table or not. In software, this is an <cite>O(log(n))</cite> operation if the list is sorted. In hardware, Content Addressable Memories can efficiently perform this lookup operation, but their size is usually limited.</p>
<p>A drawback of the <cite>flat addressing scheme</cite> is that the forwarding tables linearly grow with the number of devices in the network. This addressing scheme is notably used by Ethernet networks described in chapter <a class="reference internal" href="lan.html#chapter-ethernet"><span class="std std-ref">Ethernet</span></a>. With this addressing scheme, each forwarding table must contain an entry that points to every address reachable inside the network. Since large networks can contain tens of millions of hosts or more, this is a major problem on routers that need to be able to quickly forward packets. As an illustration, it is interesting to consider the case of an interface running at 10 Gbps. Such interfaces are found on high-end servers and in various routers today. Assuming a packet size of 1000 bits, a conservative number, such interface must forward ten million packets every second. This implies that a router that receives packets over such a link must forward one 1000 bits packet every 100 nanoseconds. This is the same order of magnitude as the memory access times of old DRAMs. This delay decreases when packets are smaller or as links become faster. High-end routers today support 400 Gbps or 800 Gbps line cards.</p>
<p>A widely used alternative to the <cite>flat addressing scheme</cite> is the <cite>hierarchical addressing scheme</cite>. This addressing scheme builds upon the fact that networks usually contain much more hosts than routers. In this case, a first solution to reduce the size of the forwarding tables is to create a hierarchy of addresses. This is the solution chosen by the post office since postal addresses contain a country, sometimes a state or province, a city, a street and finally a street number. When an envelope is forwarded by a post office in a remote country, it only looks at the destination country, while a post office in the same province will look at the city information. Only the post office responsible for a given city will look at the street name and only the postman will use the street number. <cite>Hierarchical addresses</cite> provide a similar solution for network addresses. For example, the address of an Internet host attached to a campus network could contain in the high-order bits an identification of the Internet Service Provider (ISP) that serves the campus network. Then, a subsequent block of bits identifies the campus network which is one of the customers of the ISP. Finally, the low order bits of the address identify the host in the campus network. Both IPv4 and IPv6 use hierarchical addresses.</p>
<p>This hierarchical allocation of addresses can be applied in any type of network. In practice, the allocation of the addresses must follow the network topology. Usually, this is achieved by dividing the addressing space in consecutive blocks and then allocating these blocks to different parts of the network. In a small network, the simplest solution is to allocate one block of addresses to each network node and assign the host addresses from the attached node.</p>
<blockquote>
<div><div class="figure" id="id19" style="text-align: center">
<span id="fig-net-2hosts-4routers"/><p><img src="../Images/4bdec978a60e773b93a0a4c896847066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-254369ee4a0a0b60014d8a2fdbe9a6cb9d9e252e.png"/></p>
<p><span class="caption-number">Fig. 132 </span><span class="caption-text">A simple network with two hosts and four routers</span></p>
</div></div></blockquote>
<p>In figure <a class="reference internal" href="#fig-net-2hosts-4routers"><span class="std std-numref">Fig. 132</span></a>, assume that the network uses 16 bits addresses and that the prefix <cite>01001010</cite> has been assigned to the entire network. Since the network contains four routers, the network operator could assign one block of sixty-four addresses to each router. <cite>R1</cite> would use address <cite>0100101000000000</cite> while <cite>A</cite> could use address <cite>0100101000000001</cite>. <cite>R2</cite> could be assigned all addresses from <cite>0100101001000000</cite>  to <cite>0100101001111111</cite>. <cite>R4</cite> could then use <cite>0100101011000000</cite> and assign <cite>0100101011000001</cite> to <cite>B</cite>. Other allocation schemes are possible. For example, <cite>R3</cite> could be allocated a larger block of addresses than <cite>R2</cite> and <cite>R4</cite> could use a sub-block from <cite>R3</cite> ‘s address block.</p>
<p>The main advantage of hierarchical addresses is that it is possible to significantly reduce the size of the forwarding tables. In many networks, the number of routers can be several orders of magnitude smaller than the number of hosts. A campus network may contain a dozen routers and thousands of hosts. The largest Internet Services Providers typically contain no more than a few tens of thousands of routers but still serve tens or hundreds of millions of hosts.</p>
<p>Despite their popularity, <cite>hierarchical addresses</cite> have some drawbacks. Their first drawback is that a lookup in the forwarding table is more complex than when using <cite>flat addresses</cite>. For example, on the Internet, network nodes have to perform a longest-match to forward each packet. This is partially compensated by the reduction in the size of the forwarding tables, but the additional complexity of the lookup operation has been a difficulty to implement hardware support for packet forwarding. A second drawback of the utilization of hierarchical addresses is that when a host connects for the first time to a network, it must contact one router to determine its own address. This requires some packet exchanges between the host and some routers. Furthermore, if a host moves and is attached to another routers, its network address will change. This can be an issue with some mobile hosts.</p>
</section>
<section id="dealing-with-heterogeneous-datalink-layers">
<h3>Dealing with heterogeneous datalink layers<a class="headerlink" href="#dealing-with-heterogeneous-datalink-layers" title="Link to this heading">#</a></h3>
<p>Sometimes, the network layer needs to deal with heterogeneous datalink layers. For example, two hosts connected to different datalink layers exchange packets via routers that are using other types of datalink layers. Thanks to the network layer, this exchange of packets is possible provided that each packet can be placed inside a datalink layer frame before being transmitted. If all datalink layers support the same frame size, this is simple. When a node receives a frame, it decapsulates the packet that it contains, checks the header and forwards it, encapsulated inside another frame, to the outgoing interface. Unfortunately, the encapsulation operation is not always possible. Each datalink layer is characterized by the maximum frame size that it supports. Datalink layers typically support frames containing up to a few hundreds or a few thousands of bytes. The maximum frame size that a given datalink layer supports depends on its underlying technology. Unfortunately, most datalink layers support a different maximum frame size. This implies that when a host sends a large packet inside a frame to its nexthop router, there is a risk that this packet will have to traverse a link that is not capable of forwarding the packet inside a single frame. In principle, there are three possibilities to solve this problem. To discuss them, we consider a simple scenario with two hosts connected to a router as shown in the figure below.</p>
<blockquote>
<div><div class="figure" id="id20" style="text-align: center"><p><img src="../Images/b50bd82cdce23b386cd09872d74ee6e1.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-115ecc2aa8934e7f084e4f2798ef098265d83c68.png"/></p>
<p><span class="caption-number">Fig. 133 </span><span class="caption-text">A simple heterogeneous network</span></p>
</div></div></blockquote>
<p>Consider in the network above that host <cite>A</cite> wants to send a 900 bytes packet (870 bytes of payload and 30 bytes of header) to host <cite>B</cite> via router <cite>R1</cite>. Host <cite>A</cite> encapsulates this packet inside a single frame. The frame is received by router <cite>R1</cite> which extracts the packet. Router <cite>R1</cite> has three possible options to process this packet.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The packet is too large and router <cite>R1</cite> cannot forward it to router <cite>R2</cite>. It rejects the packet and sends a control packet back to the source (host <cite>A</cite>) to indicate that it cannot forward packets longer than 500 bytes (minus the packet header). The source could react to this control packet by retransmitting the information in smaller packets.</p></li>
<li><p>The network layer is able to fragment a packet. In our example, the router could fragment the packet in two parts. The first part contains the beginning of the payload and the second the end. There are two possible ways to perform this fragmentation.</p></li>
<li><p>Router <cite>R1</cite> fragments the packet into two fragments before transmitting them to router <cite>R2</cite>. Router <cite>R2</cite> reassembles the two packet fragments in a larger packet before transmitting them on the link towards host <cite>B</cite>.</p></li>
<li><p>Each of the packet fragments is a valid packet that contains a header with the source (host <cite>A</cite>) and destination (host <cite>B</cite>) addresses. When router <cite>R2</cite> receives a packet fragment, it treats this packet as a regular packet and forwards it to its final destination (host <cite>B</cite>). Host <cite>B</cite> reassembles the received fragments.</p></li>
</ol>
</div></blockquote>
<p>These three solutions have advantages and drawbacks. With the first solution, routers remain simple and do not need to perform any fragmentation operation. This is important when routers are implemented mainly in hardware. However, hosts must be complex since they need to store the packets that they produce if they need to pass through a link that does not support large packets. This increases the buffering required on the hosts.</p>
<p>Furthermore, a single large packet may potentially need to be retransmitted several times. Consider for example a network similar to the one shown above but with four routers. Assume that the link <cite>R1-&gt;R2</cite> supports 1000 bytes packets, link <cite>R2-&gt;R3</cite> 800 bytes packets and link <cite>R3-&gt;R4</cite> 600 bytes packets. A host attached to <cite>R1</cite> that sends large packet will have to first try 1000 bytes, then 800 bytes and finally 600 bytes. Fortunately, this scenario does not occur very often in practice and this is the reason why this solution is used in real networks.</p>
<p>Fragmenting packets on a per-link basis, as presented for the second solution, can minimize the transmission overhead since a packet is only fragmented on the links where fragmentation is required. Large packets can continue to be used downstream of a link that only accepts small packets. However, this reduction of the overhead comes with two drawbacks. First, fragmenting packets, potentially on all links, increases the processing time and the buffer requirements on the routers. Second, this solution leads to a longer end-to-end delay since the downstream router has to reassemble all the packet fragments before forwarding the packet.</p>
<p>The last solution is a compromise between the two others. Routers need to perform fragmentation but they do not need to reassemble packet fragments. Only the hosts need to have buffers to reassemble the received fragments. This solution has a lower end-to-end delay and requires fewer processing time and memory on the routers.</p>
<p>The first solution to the fragmentation problem presented above suggests the utilization of control packets to inform the source about the reception of a too long packet. This is only one of the functions that are performed by the control protocol in the network layer. Other functions include :</p>
<blockquote>
<div><ul class="simple">
<li><p>sending a control packet back to the source if a packet is received by a router that does not have a valid entry in its forwarding table</p></li>
<li><p>sending a control packet back to the source if a router detects that a packet is looping inside the network</p></li>
<li><p>verifying that packets can reach a given destination</p></li>
</ul>
</div></blockquote>
<p>We will discuss these functions in more details when we will describe the protocols that are used in the network layer of the TCP/IP protocol suite.</p>
</section>
&#13;

<h3>Computing forwarding tables<a class="headerlink" href="#computing-forwarding-tables" title="Link to this heading">#</a></h3>
<p>Networks deployed several techniques to update the forwarding tables upon the arrival of a packet. In this section, we briefly present the principles that underlie three of these techniques.</p>
<p>The first technique assumes that the underlying network topology is a tree. A tree is the simplest network to be considered when forwarding packets. The main advantage of using a tree is that there is only one path between any pair of nodes inside the network. Since a tree does not contain any cycle, it is impossible to have forwarding loops in a tree-shaped network.</p>
<p id="index-7">In a tree-shaped network, it is relatively simple for each node to automatically compute its forwarding table by inspecting the packets that it receives. For this, each node uses the source and destination addresses present inside each packet. Thanks to the source address, a node can learn the location of the different sources inside the network. Each source has a unique address. When a node receives a packet over a given interface, it learns that the source (address) of this packet is reachable via this interface. The node maintains a data structure that maps each known source address to an incoming interface. This data structure is often called the <cite>port-address table</cite> since it indicates the interface (or port) to reach a given address.</p>
<p>Learning the location of the sources is not sufficient, nodes also need to forward packets towards their destination. When a node receives a packet whose destination address is already present inside its port-address table, it simply forwards the packet on the interface listed in the port-address table. In this case, the packet will follow the port-address table entries in the downstream nodes and will reach the destination. If the destination address is not included in the port-address table, the node simply forwards the packet on all its interfaces, except the interface from which the packet was received. Forwarding a packet over all interfaces is usually called <cite>broadcasting</cite> in the terminology of computer networks. Sending the packet over all interfaces except one is a costly operation since the packet is sent over links that do not reach the destination. Given the tree-shape of the network, the packet will explore all downstream branches of the tree and will finally reach its destination. In practice, the <cite>broadcasting</cite> operation does not occur too often and its performance impact remains limited.</p>
<p>To understand the operation of the port-address table, let us consider the example network shown in <a class="reference internal" href="#fig-simple-tree-network"><span class="std std-numref">Fig. 129</span></a>. This network contains three hosts: <cite>A</cite>, <cite>B</cite> and <cite>C</cite> and five routers, <cite>R1</cite> to <cite>R5</cite>. When the network boots, all the forwarding tables of the nodes are empty.</p>
<blockquote>
<div><div class="figure" id="id16" style="text-align: center">
<span id="fig-simple-tree-network"/><p><img src="../Images/d7769586ddea01abce95ea2ac91eaad6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2bd54f92e493fb190c605f89e5a3a0962dc026f0.png"/></p>
<p><span class="caption-number">Fig. 129 </span><span class="caption-text">A simple tree-shaped network</span></p>
</div></div></blockquote>
<p>Host <cite>A</cite> sends a packet towards <cite>B</cite>. When receiving this packet, <cite>R1</cite> learns that <cite>A</cite> is reachable via its <cite>West</cite> interface. Since it does not have an entry for destination <cite>B</cite> in its port-address table, it forwards the packet to both <cite>R2</cite> and <cite>R3</cite>. When <cite>R2</cite> receives the packet, it updates its own forwarding table and forward the packet to <cite>C</cite>. Since <cite>C</cite> is not the intended recipient, it simply discards the received packet. Router <cite>R3</cite> also receives the packet. It learns that <cite>A</cite> is reachable via its <cite>North-West</cite> interface and broadcasts the packet to <cite>R4</cite> and <cite>R5</cite>. <cite>R5</cite> also updates its forwarding table and finally forwards it to destination <cite>B</cite>. Let us now consider what happens when <cite>B</cite> sends a reply to <cite>A</cite>. <cite>R5</cite>  first learns that <cite>B</cite> is attached to its <cite>North-East</cite> port. It then consults its port-address table and finds that <cite>A</cite> is reachable via its <cite>North-West</cite> interface. The packet is then forwarded hop-by-hop to <cite>A</cite> without any broadcasting. Later on, if <cite>C</cite> sends a packet to <cite>B</cite>, this packet will reach <cite>R1</cite> that contains a valid forwarding entry in its forwarding table.</p>
<p>By inspecting the source and destination addresses of packets, network nodes can automatically derive their forwarding tables. As we will discuss later, this technique is used in <a class="reference internal" href="../glossary.html#term-Ethernet"><span class="xref std std-term">Ethernet</span></a> networks. Despite being widely used, it has two important drawbacks. First, packets sent to unknown destinations must be broadcasted in the network even if the destination is not attached to the network. Consider the transmission of ten packets destined to <cite>Z</cite> in the network above. When a node receives a packet towards this destination, it can only broadcast that packet. Since <cite>Z</cite> is not attached to the network, no node will ever receive a packet whose source is <cite>Z</cite> to update its forwarding table. The second and more important problem is that few networks have a tree-shaped topology. It is interesting to analyze what happens when a port-address table is used in a network that contains a cycle. Consider the simple network shown in <a class="reference internal" href="#fig-simple-redundant-network"><span class="std std-numref">Fig. 130</span></a> with a single host.</p>
<blockquote>
<div><div class="figure" id="id17" style="text-align: center">
<span id="fig-simple-redundant-network"/><p><img src="../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-ac5be638528d298bb186b89d3eb42f1daa95f094.png"/></p>
<p><span class="caption-number">Fig. 130 </span><span class="caption-text">A simple and redundant network</span></p>
</div></div></blockquote>
<p>Assume that the network has started and all port-address and forwarding tables are empty. Host <cite>A</cite> sends a packet towards <cite>B</cite>. Upon reception of this packet, <cite>R1</cite> updates its port-address table. Since <cite>B</cite> is not present in the port-address table, the packet is broadcasted. Both <cite>R2</cite> and <cite>R3</cite> receive a copy of the packet sent by <cite>A</cite>. They both update their port-address table. Unfortunately, they also both broadcast the received packet. <cite>B</cite> receives a first copy of the packet, but <cite>R3</cite> and <cite>R2</cite> receive it again. <cite>R3</cite> will then broadcast this copy of the packet to <cite>B</cite> and <cite>R1</cite> while <cite>R2</cite> will broadcast its copy to <cite>R1</cite>. Although <cite>B</cite> has already received two copies of the packet, it is still inside the network and continues to loop. Due to the presence of the cycle, a single packet towards an unknown destination generates many copies of this packet that loop and will eventually saturate the network. Network operators who are using port-address tables to automatically compute the forwarding tables also use distributed algorithms to ensure that the network topology is always a tree.</p>
<p id="index-8">Another technique called <cite>source routing</cite> can be used to automatically compute forwarding tables. It has been used in interconnecting Token Ring networks and in some wireless networks. Intuitively, <cite>source routing</cite> enables a destination to automatically discover the paths from a given source towards itself. This technique requires nodes to encode information inside some packets. For simplicity, let us assume that the <cite>data plane</cite> supports two types of packets :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>data packets</cite></p></li>
<li><p>the <cite>control packets</cite></p></li>
</ul>
</div></blockquote>
<p><cite>Data packets</cite> are used to exchange data while <cite>control packets</cite> are used to discover the paths between hosts. With <cite>source routing</cite>, routers can be kept as simple as possible and all the complexity is placed on the hosts. This is in contrast with the previous technique where the nodes had to maintain a port-address and a forwarding table while the hosts simply sent and received packets. Each node is configured with one unique address and there is one identifier per outgoing link. For simplicity and to avoid cluttering the figures with those identifiers, we assume that each node uses as link identifiers north, west, south,… In practice, a node would associate one integer to each outgoing link. This is illustrated in <a class="reference internal" href="#fig-simple-2hosts-4routers"><span class="std std-numref">Fig. 131</span></a>.</p>
<blockquote>
<div><div class="figure" id="id18" style="text-align: center">
<span id="fig-simple-2hosts-4routers"/><p><img src="../Images/4bdec978a60e773b93a0a4c896847066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-254369ee4a0a0b60014d8a2fdbe9a6cb9d9e252e.png"/></p>
<p><span class="caption-number">Fig. 131 </span><span class="caption-text">A simple network with two hosts and four routers</span></p>
</div></div></blockquote>
<p>In the network above, router <cite>R2</cite> is attached to two outgoing links. <cite>R2</cite> is connected to both <cite>R1</cite> and <cite>R3</cite>. <cite>R2</cite> can easily determine that it is connected to these two nodes by exchanging packets with them or observing the packets that it receives over each interface. Assume for example that when a node (either host or router) starts, it sends a special control packet over each of its interfaces to advertise its own address to its neighbors. When a node receives such a packet, it automatically replies with its own address. This exchange can also be used to verify whether a neighbor, either router or host, is still alive. With <cite>source routing</cite>, the data plane packets include a list of identifiers. This list is called a <cite>source route</cite>. It indicates the path to be followed by the packet as a sequence of link identifiers. When a node receives such a <cite>data plane</cite> packet, it first checks whether the packet’s destination is a direct neighbor. In this case, the packet is forwarded to this neighbor. Otherwise, the node extracts the next address from the list and forwards it to the neighbor. This allows the source to specify the explicit path to be followed for each packet. For example, in the figure above there are two possible paths between <cite>A</cite> and <cite>B</cite>. To use the path via <cite>R2</cite>, <cite>A</cite> would send a packet that contains <cite>R1,R2,R3</cite> as source route. To avoid going via <cite>R2</cite>, <cite>A</cite> would place <cite>R1,R3</cite> as the source route in its transmitted packet. If <cite>A</cite> knows the complete network topology and all link identifiers, it can easily compute the source route towards each destination. It can even use different paths, e.g. for redundancy, to reach a given destination. However, in a real network hosts do not usually have a map of the entire network topology.</p>
<p id="index-9">In networks that rely on source routing, hosts use control packets to automatically discover the best path(s). In addition to the source and destination addresses, <cite>control packets</cite> contain a list that records the intermediate nodes. This list is often called the <cite>record route</cite> because it allows recording the route followed by a given packet. When a node receives such a <cite>control packet</cite>, it first checks whether its address is included in the record route. If yes, the packet has already been forwarded by this node and it is silently discarded. Otherwise, it adds its own address to the <cite>record route</cite> and forwards the packet to all its interfaces, except the interface over which the packet has been received. Thanks to this, the <cite>control packet</cite> can explore all paths between a source and a given destination.</p>
<p>For example, consider again the network topology above. <cite>A</cite> sends a control packet towards <cite>B</cite>. The initial <cite>record route</cite> is empty. When <cite>R1</cite> receives the packet, it adds its own address to the <cite>record route</cite> and forwards a copy to <cite>R2</cite> and another to <cite>R3</cite>. <cite>R2</cite> receives the packet, adds itself to the <cite>record route</cite> and forwards it to <cite>R3</cite>. <cite>R3</cite> receives two copies of the packet. The first contains the <cite>[R1,R2]</cite> <cite>record route</cite> and the second <cite>[R1]</cite>. In the end, <cite>B</cite> will receive two control packets containing  <cite>[R1,R2,R3,R4]</cite> and <cite>[R1,R3,R4]</cite> as <cite>record routes</cite>. <cite>B</cite> can keep these two paths or select the best one and discard the second. A popular heuristic is to select the <cite>record route</cite> of the first received packet as being the best one since this likely corresponds to the shortest delay path.</p>
<p>With the received <cite>record route</cite>, <cite>B</cite> can send a <cite>data packet</cite> to <cite>A</cite>. For this, it simply reverses the chosen <cite>record route</cite>. However, we still need to communicate the chosen path to <cite>A</cite>. This can be done by putting the <cite>record route</cite> inside a control packet which is sent back to <cite>A</cite> over the reverse path. An alternative is to simply send a <cite>data packet</cite> back to <cite>A</cite>. This packet will travel back to <cite>A</cite>. To allow <cite>A</cite> to inspect the entire path followed by the <cite>data packet</cite>, its <cite>source route</cite> must contain all intermediate routers when it is received by <cite>A</cite>. This can be achieved by encoding the <cite>source route</cite> using a data structure that contains an index and the ordered list of node addresses. The index always points to the next address in the <cite>source route</cite>. It is initialized at <cite>0</cite> when a packet is created and incremented by each intermediate node.</p>
<p>The third technique to compute forwarding tables is to rely on a control plane using a distributed algorithm. Routers exchange control messages to discover the network topology and build their forwarding table based on them. We dedicate a more detailed description of such distributed algorithms later in this section.</p>
&#13;

<h3>Flat or hierarchical addresses<a class="headerlink" href="#flat-or-hierarchical-addresses" title="Link to this heading">#</a></h3>
<p>The last, but important, point to discuss about the <cite>data plane</cite> of the networks that rely on the datagram mode is their addressing scheme. In the examples above, we have used letters to represent the addresses of the hosts and network nodes. In practice, all addresses are encoded as a bit string. Most network technologies use a fixed size bit string to represent source and destination address. These addresses can be organized in two different ways.</p>
<p>The first organization, which is the one that we have implicitly assumed until now, is the <cite>flat addressing</cite> scheme. Under this scheme, each host and network node has a unique address. The unicity of the addresses is important for the operation of the network. If two hosts have the same address, it can become difficult for the network to forward packets towards this destination. <cite>Flat addresses</cite> are typically used in situations where network nodes and hosts need to be able to communicate immediately with unique addresses. These <cite>flat addresses</cite> are often embedded inside the network interface cards. The network card manufacturer creates one unique address for each interface and this address is stored in the read-only memory of the interface. An advantage of this addressing scheme is that it easily supports unstructured and mobile networks. When a host moves, it can attach to another network and remain confident that its address is unique and enables it to communicate inside the new network.</p>
<p>With <cite>flat addressing</cite> the lookup operation in the forwarding table can be implemented as an exact match. The <cite>forwarding table</cite> contains the (sorted) list of all known destination addresses. When a packet arrives, a network node only needs to check whether this address is included in the forwarding table or not. In software, this is an <cite>O(log(n))</cite> operation if the list is sorted. In hardware, Content Addressable Memories can efficiently perform this lookup operation, but their size is usually limited.</p>
<p>A drawback of the <cite>flat addressing scheme</cite> is that the forwarding tables linearly grow with the number of devices in the network. This addressing scheme is notably used by Ethernet networks described in chapter <a class="reference internal" href="lan.html#chapter-ethernet"><span class="std std-ref">Ethernet</span></a>. With this addressing scheme, each forwarding table must contain an entry that points to every address reachable inside the network. Since large networks can contain tens of millions of hosts or more, this is a major problem on routers that need to be able to quickly forward packets. As an illustration, it is interesting to consider the case of an interface running at 10 Gbps. Such interfaces are found on high-end servers and in various routers today. Assuming a packet size of 1000 bits, a conservative number, such interface must forward ten million packets every second. This implies that a router that receives packets over such a link must forward one 1000 bits packet every 100 nanoseconds. This is the same order of magnitude as the memory access times of old DRAMs. This delay decreases when packets are smaller or as links become faster. High-end routers today support 400 Gbps or 800 Gbps line cards.</p>
<p>A widely used alternative to the <cite>flat addressing scheme</cite> is the <cite>hierarchical addressing scheme</cite>. This addressing scheme builds upon the fact that networks usually contain much more hosts than routers. In this case, a first solution to reduce the size of the forwarding tables is to create a hierarchy of addresses. This is the solution chosen by the post office since postal addresses contain a country, sometimes a state or province, a city, a street and finally a street number. When an envelope is forwarded by a post office in a remote country, it only looks at the destination country, while a post office in the same province will look at the city information. Only the post office responsible for a given city will look at the street name and only the postman will use the street number. <cite>Hierarchical addresses</cite> provide a similar solution for network addresses. For example, the address of an Internet host attached to a campus network could contain in the high-order bits an identification of the Internet Service Provider (ISP) that serves the campus network. Then, a subsequent block of bits identifies the campus network which is one of the customers of the ISP. Finally, the low order bits of the address identify the host in the campus network. Both IPv4 and IPv6 use hierarchical addresses.</p>
<p>This hierarchical allocation of addresses can be applied in any type of network. In practice, the allocation of the addresses must follow the network topology. Usually, this is achieved by dividing the addressing space in consecutive blocks and then allocating these blocks to different parts of the network. In a small network, the simplest solution is to allocate one block of addresses to each network node and assign the host addresses from the attached node.</p>
<blockquote>
<div><div class="figure" id="id19" style="text-align: center">
<span id="fig-net-2hosts-4routers"/><p><img src="../Images/4bdec978a60e773b93a0a4c896847066.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-254369ee4a0a0b60014d8a2fdbe9a6cb9d9e252e.png"/></p>
<p><span class="caption-number">Fig. 132 </span><span class="caption-text">A simple network with two hosts and four routers</span></p>
</div></div></blockquote>
<p>In figure <a class="reference internal" href="#fig-net-2hosts-4routers"><span class="std std-numref">Fig. 132</span></a>, assume that the network uses 16 bits addresses and that the prefix <cite>01001010</cite> has been assigned to the entire network. Since the network contains four routers, the network operator could assign one block of sixty-four addresses to each router. <cite>R1</cite> would use address <cite>0100101000000000</cite> while <cite>A</cite> could use address <cite>0100101000000001</cite>. <cite>R2</cite> could be assigned all addresses from <cite>0100101001000000</cite>  to <cite>0100101001111111</cite>. <cite>R4</cite> could then use <cite>0100101011000000</cite> and assign <cite>0100101011000001</cite> to <cite>B</cite>. Other allocation schemes are possible. For example, <cite>R3</cite> could be allocated a larger block of addresses than <cite>R2</cite> and <cite>R4</cite> could use a sub-block from <cite>R3</cite> ‘s address block.</p>
<p>The main advantage of hierarchical addresses is that it is possible to significantly reduce the size of the forwarding tables. In many networks, the number of routers can be several orders of magnitude smaller than the number of hosts. A campus network may contain a dozen routers and thousands of hosts. The largest Internet Services Providers typically contain no more than a few tens of thousands of routers but still serve tens or hundreds of millions of hosts.</p>
<p>Despite their popularity, <cite>hierarchical addresses</cite> have some drawbacks. Their first drawback is that a lookup in the forwarding table is more complex than when using <cite>flat addresses</cite>. For example, on the Internet, network nodes have to perform a longest-match to forward each packet. This is partially compensated by the reduction in the size of the forwarding tables, but the additional complexity of the lookup operation has been a difficulty to implement hardware support for packet forwarding. A second drawback of the utilization of hierarchical addresses is that when a host connects for the first time to a network, it must contact one router to determine its own address. This requires some packet exchanges between the host and some routers. Furthermore, if a host moves and is attached to another routers, its network address will change. This can be an issue with some mobile hosts.</p>
&#13;

<h3>Dealing with heterogeneous datalink layers<a class="headerlink" href="#dealing-with-heterogeneous-datalink-layers" title="Link to this heading">#</a></h3>
<p>Sometimes, the network layer needs to deal with heterogeneous datalink layers. For example, two hosts connected to different datalink layers exchange packets via routers that are using other types of datalink layers. Thanks to the network layer, this exchange of packets is possible provided that each packet can be placed inside a datalink layer frame before being transmitted. If all datalink layers support the same frame size, this is simple. When a node receives a frame, it decapsulates the packet that it contains, checks the header and forwards it, encapsulated inside another frame, to the outgoing interface. Unfortunately, the encapsulation operation is not always possible. Each datalink layer is characterized by the maximum frame size that it supports. Datalink layers typically support frames containing up to a few hundreds or a few thousands of bytes. The maximum frame size that a given datalink layer supports depends on its underlying technology. Unfortunately, most datalink layers support a different maximum frame size. This implies that when a host sends a large packet inside a frame to its nexthop router, there is a risk that this packet will have to traverse a link that is not capable of forwarding the packet inside a single frame. In principle, there are three possibilities to solve this problem. To discuss them, we consider a simple scenario with two hosts connected to a router as shown in the figure below.</p>
<blockquote>
<div><div class="figure" id="id20" style="text-align: center"><p><img src="../Images/b50bd82cdce23b386cd09872d74ee6e1.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-115ecc2aa8934e7f084e4f2798ef098265d83c68.png"/></p>
<p><span class="caption-number">Fig. 133 </span><span class="caption-text">A simple heterogeneous network</span></p>
</div></div></blockquote>
<p>Consider in the network above that host <cite>A</cite> wants to send a 900 bytes packet (870 bytes of payload and 30 bytes of header) to host <cite>B</cite> via router <cite>R1</cite>. Host <cite>A</cite> encapsulates this packet inside a single frame. The frame is received by router <cite>R1</cite> which extracts the packet. Router <cite>R1</cite> has three possible options to process this packet.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The packet is too large and router <cite>R1</cite> cannot forward it to router <cite>R2</cite>. It rejects the packet and sends a control packet back to the source (host <cite>A</cite>) to indicate that it cannot forward packets longer than 500 bytes (minus the packet header). The source could react to this control packet by retransmitting the information in smaller packets.</p></li>
<li><p>The network layer is able to fragment a packet. In our example, the router could fragment the packet in two parts. The first part contains the beginning of the payload and the second the end. There are two possible ways to perform this fragmentation.</p></li>
<li><p>Router <cite>R1</cite> fragments the packet into two fragments before transmitting them to router <cite>R2</cite>. Router <cite>R2</cite> reassembles the two packet fragments in a larger packet before transmitting them on the link towards host <cite>B</cite>.</p></li>
<li><p>Each of the packet fragments is a valid packet that contains a header with the source (host <cite>A</cite>) and destination (host <cite>B</cite>) addresses. When router <cite>R2</cite> receives a packet fragment, it treats this packet as a regular packet and forwards it to its final destination (host <cite>B</cite>). Host <cite>B</cite> reassembles the received fragments.</p></li>
</ol>
</div></blockquote>
<p>These three solutions have advantages and drawbacks. With the first solution, routers remain simple and do not need to perform any fragmentation operation. This is important when routers are implemented mainly in hardware. However, hosts must be complex since they need to store the packets that they produce if they need to pass through a link that does not support large packets. This increases the buffering required on the hosts.</p>
<p>Furthermore, a single large packet may potentially need to be retransmitted several times. Consider for example a network similar to the one shown above but with four routers. Assume that the link <cite>R1-&gt;R2</cite> supports 1000 bytes packets, link <cite>R2-&gt;R3</cite> 800 bytes packets and link <cite>R3-&gt;R4</cite> 600 bytes packets. A host attached to <cite>R1</cite> that sends large packet will have to first try 1000 bytes, then 800 bytes and finally 600 bytes. Fortunately, this scenario does not occur very often in practice and this is the reason why this solution is used in real networks.</p>
<p>Fragmenting packets on a per-link basis, as presented for the second solution, can minimize the transmission overhead since a packet is only fragmented on the links where fragmentation is required. Large packets can continue to be used downstream of a link that only accepts small packets. However, this reduction of the overhead comes with two drawbacks. First, fragmenting packets, potentially on all links, increases the processing time and the buffer requirements on the routers. Second, this solution leads to a longer end-to-end delay since the downstream router has to reassemble all the packet fragments before forwarding the packet.</p>
<p>The last solution is a compromise between the two others. Routers need to perform fragmentation but they do not need to reassemble packet fragments. Only the hosts need to have buffers to reassemble the received fragments. This solution has a lower end-to-end delay and requires fewer processing time and memory on the routers.</p>
<p>The first solution to the fragmentation problem presented above suggests the utilization of control packets to inform the source about the reception of a too long packet. This is only one of the functions that are performed by the control protocol in the network layer. Other functions include :</p>
<blockquote>
<div><ul class="simple">
<li><p>sending a control packet back to the source if a packet is received by a router that does not have a valid entry in its forwarding table</p></li>
<li><p>sending a control packet back to the source if a router detects that a packet is looping inside the network</p></li>
<li><p>verifying that packets can reach a given destination</p></li>
</ul>
</div></blockquote>
<p>We will discuss these functions in more details when we will describe the protocols that are used in the network layer of the TCP/IP protocol suite.</p>
&#13;

<h2>Virtual circuit organization<a class="headerlink" href="#virtual-circuit-organization" title="Link to this heading">#</a></h2>
<p>The second organization of the network layer, called <cite>virtual circuits</cite>, has been inspired by the organization of telephone networks. Telephone networks have been designed to carry phone calls that usually last a few minutes. Each phone is identified by a telephone number and is attached to a telephone switch. To initiate a phone call, a telephone first needs to send the destination’s phone number to its local switch. The switch cooperates with the other switches in the network to create a bi-directional channel between the two telephones through the network. This channel will be used by the two telephones during the lifetime of the call and will be released at the end of the call. Until the 1960s, most of these channels were created manually, by telephone operators, upon request of the caller. Today’s telephone networks use automated switches and allow several channels to be carried over the same physical link, but the principles roughly remain the same.</p>
<p id="index-10">In a network using virtual circuits, all hosts are also identified with a network layer address. However, packet forwarding is not performed by looking at the destination address of each packet. With the <cite>virtual circuit</cite> organization, each data packet contains one label <a class="footnote-reference brackets" href="#flabels" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. A label is an integer which is part of the packet header. Routers implement <cite>label switching</cite> to forward <cite>labelled data packet</cite>. Upon reception of a packet, a router consults its <cite>label forwarding table</cite> to find the outgoing interface for this packet. In contrast with the datagram mode, this lookup is very simple. The <cite>label forwarding table</cite> is an array stored in memory and the label of the incoming packet is the index to access this array. This implies that the lookup operation has an <cite>O(1)</cite> complexity in contrast with other packet forwarding techniques. To ensure that on each node the packet label is an index in the <cite>label forwarding table</cite>, each router that forwards a packet replaces the label of the forwarded packet with the label found in the <cite>label forwarding table</cite>.  Each entry of the <cite>label forwarding table</cite> contains two pieces of information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the outgoing interface for the packet</p></li>
<li><p>the label for the outgoing packet</p></li>
</ul>
</div></blockquote>
<p>For example, consider the <cite>label forwarding table</cite> of a network node below.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>South</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>none</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>West</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>East</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</div>
<p>If this node receives a packet with <cite>label=2</cite>, it forwards the packet on its <cite>West</cite> interface and sets the <cite>label</cite> of the outgoing packet to <cite>2</cite>. If the received packet’s <cite>label</cite> is set to <cite>3</cite>, then the packet is forwarded over the <cite>East</cite> interface and the <cite>label</cite> of the outgoing packet is set to <cite>2</cite>. If a packet is received with a label field set to <cite>1</cite>, the packet is discarded since the corresponding <cite>label forwarding table</cite> entry is invalid.</p>
<p><cite>Label switching</cite> enables a full control over the path followed by packets inside the network. Consider the network below and assume that we want to use two virtual circuits : <cite>R1-&gt;R3-&gt;R4-&gt;R2-&gt;R5</cite> and <cite>R2-&gt;R1-&gt;R3-&gt;R4-&gt;R5</cite>.</p>
<blockquote>
<div><div class="figure" id="id21" style="text-align: center"><p><img src="../Images/c5fa5b3b06d080fc6776a20d0bcd17c6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-a8b394cac1086224030e6f2e7bc39e71dd067d5f.png"/></p>
<p><span class="caption-number">Fig. 134 </span><span class="caption-text">An example of network where label switching can be applied to tune its paths</span></p>
</div></div></blockquote>
<p>To create these virtual circuits, we need to configure the <cite>label forwarding tables</cite> of all routers. For simplicity, assume that a label forwarding table only contains two entries. Assume that <cite>R5</cite> wants to receive the packets from the virtual circuit created by <cite>R1</cite> (resp. <cite>R2</cite>) with <cite>label=1</cite> (<cite>label=0</cite>). <cite>R4</cite> could use the following <cite>label forwarding table</cite>:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R4’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-&gt;R2</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R5</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</div>
<p>Since a packet received with <cite>label=1</cite> must be forwarded to <cite>R5</cite> with <cite>label=1</cite>, <cite>R2</cite>’s <cite>label forwarding table</cite> could contain :</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R2’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>none</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R5</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div>
<p>Two virtual circuits pass through <cite>R3</cite>. They both need to be forwarded to <cite>R4</cite>, but <cite>R4</cite> expects <cite>label=1</cite> for packets belonging to the virtual circuit originated by <cite>R2</cite> and <cite>label=0</cite> for packets belonging to the other virtual circuit. <cite>R3</cite> could choose to leave the labels unchanged.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R3’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-&gt;R4</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R4</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div>
<p>With the above <cite>label forwarding table</cite>, <cite>R1</cite> needs to originate the packets that belong to the <cite>R1-&gt;R3-&gt;R4-&gt;R2-&gt;R5</cite> circuit with <cite>label=0</cite>. The packets received from <cite>R2</cite> and belonging to the <cite>R2-&gt;R1-&gt;R3-&gt;R4-&gt;R5</cite> circuit would then use <cite>label=1</cite> on the <cite>R1-R3</cite> link. <cite>R1</cite> ‘s label forwarding table could be built as follows :</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td colspan="3"><p>R1’s label forwarding table</p></td>
</tr>
<tr class="row-even"><td><p>index</p></td>
<td><p>outgoing interface</p></td>
<td><p>label</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>-&gt;R3</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>-&gt;R3</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
</div>
<p>The figure below shows the path followed by the packets on the <cite>R1-&gt;R3-&gt;R4-&gt;R2-&gt;R5</cite> path in red with on each arrow the label used in the packets.</p>
<blockquote>
<div><div class="figure" id="id22" style="text-align: center"><p><img src="../Images/aac335913fe6b920a1747148900960d0.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2afa2a575d1b8c3f5168dab2fa0a10a06fbbf081.png"/></p>
<p><span class="caption-number">Fig. 135 </span><span class="caption-text">The path followed by packets for a specific circuit</span></p>
</div></div></blockquote>
<p>MultiProtocol Label Switching (MPLS) is the example of a deployed networking technology that relies on label switching. MPLS is more complex than the above description because it has been designed to be easily integrated with datagram technologies. However, the principles remain. <cite>Asynchronous Transfer Mode</cite> (ATM) and Frame Relay are other examples of technologies that rely on <cite>label switching</cite>.</p>
<p>Nowadays, most deployed networks rely on distributed algorithms, called routing protocols, to compute the forwarding tables that are installed on the routers. These distributed algorithms are part of the <cite>control plane</cite>. They are usually implemented in software and are executed on the main CPU of the routers. There are two main families of routing protocols : distance vector routing and link state routing. Both are capable of discovering autonomously the network and react dynamically to topology changes.</p>
<span class="target" id="index-11"/><p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="flabels" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>We will see later a more detailed description of Multiprotocol Label Switching, a networking technology that is capable of using one or more labels.</p>
</aside>
</aside>
&#13;

<h1>The control plane<a class="headerlink" href="#the-control-plane" title="Link to this heading">#</a></h1>
<p>One of the objectives of the <cite>control plane</cite> in the network layer is to maintain the routing tables that are used on all routers. As indicated earlier, a routing table is a data structure that contains, for each destination address (or block of addresses) known by the router, the outgoing interface over which the router must forward a packet destined to this address. The routing table may also contain additional information such as the address of the next router on the path towards the destination or an estimation of the cost of this path.</p>
<p>In this section, we discuss the main techniques that can be used to maintain the forwarding tables in a network.</p>
<section id="distance-vector-routing">
<span id="index-12"/><h2>Distance vector routing<a class="headerlink" href="#distance-vector-routing" title="Link to this heading">#</a></h2>
<p>Distance vector routing is a simple distributed routing protocol. Distance vector routing allows routers to automatically discover the destinations reachable inside the network as well as the shortest path to reach each of these destinations. The shortest path is computed based on <cite>metrics</cite> or <cite>costs</cite> that are associated to each link. We use <cite>l.cost</cite> to represent the metric that has been configured for link <cite>l</cite> on a router.</p>
<p>Each router maintains a routing table. The routing table <cite>R</cite> can be modeled as a data structure that stores, for each known destination address <cite>d</cite>, the following attributes :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>R[d].link</cite> is the outgoing link that the router uses to forward packets towards destination <cite>d</cite></p></li>
<li><p><cite>R[d].cost</cite> is the sum of the metrics of the links that compose the shortest path to reach destination <cite>d</cite></p></li>
<li><p><cite>R[d].time</cite> is the timestamp of the last distance vector containing destination <cite>d</cite></p></li>
</ul>
</div></blockquote>
<p>A router that uses distance vector routing regularly sends its distance vector over all its interfaces. This distance vector is a summary of the router’s routing table that indicates the distance towards each known destination. This distance vector can be computed from the routing table by using the pseudo-code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">Every</span> <span class="n">N</span> <span class="n">seconds</span><span class="p">:</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]:</span>
        <span class="c1"># add destination d to vector</span>
        <span class="n">v</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">interfaces</span>
        <span class="c1"># send vector v on this interface</span>
        <span class="n">send</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>When a router boots, it does not know any destination in the network and its routing table only contains its local address(es). It thus sends to all its neighbors a distance vector that contains only its address at a distance of <cite>0</cite>. When a router receives a distance vector on link <cite>l</cite>, it processes it as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># V : received Vector</span>
<span class="c1"># l : link over which vector is received</span>
<span class="k">def</span><span class="w"> </span><span class="nf">received</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="c1"># received vector from link l</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">V</span><span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]):</span>
            <span class="c1"># new route</span>
            <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">cost</span>
            <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">now</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># existing route, is the new better ?</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">V</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">==</span> <span class="n">l</span><span class="p">):</span>
                <span class="c1"># Better route or change to current route</span>
                <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">cost</span>
                <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">now</span>
</pre></div>
</div>
<p>The router iterates over all addresses included in the distance vector. If the distance vector contains a destination address that the router does not know, it inserts it inside its routing table via link <cite>l</cite> and at a distance which is the sum between the distance indicated in the distance vector and the cost associated to link <cite>l</cite>. If the destination was already known by the router, it only updates the corresponding entry in its routing table if either :</p>
<blockquote>
<div><ul class="simple">
<li><p>the cost of the new route is smaller than the cost of the already known route <cite>((V[d].cost + l.cost) &lt; R[d].cost)</cite></p></li>
<li><p>the new route was learned over the same link as the current best route towards this destination <cite>(R[d].link == l)</cite></p></li>
</ul>
</div></blockquote>
<p>The first condition ensures that the router discovers the shortest path towards each destination. The second condition is used to take into account the changes of routes that may occur after a link failure or a change of the metric associated to a link.</p>
<p>To understand the operation of a distance vector protocol, let us consider the network of five routers shown in <a class="reference internal" href="#fig-dv-5routers"><span class="std std-numref">Fig. 136</span></a>.</p>
<blockquote>
<div><div class="figure" id="id23" style="text-align: center">
<span id="fig-dv-5routers"/><p><img src="../Images/2fa610c73105286d66d016e10c05cd70.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-a9a9cb808fe5a14a98c1dbe92665e86362239b99.png"/></p>
<p><span class="caption-number">Fig. 136 </span><span class="caption-text">Operation of distance vector routing in a simple network</span></p>
</div></div></blockquote>
<p>Assume that router <cite>A</cite> is the first to send its distance vector <cite>[A=0]</cite>.</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>B</cite> and <cite>D</cite> process the received distance vector and update their routing table with a route towards <cite>A</cite>.</p></li>
<li><p><cite>D</cite> sends its distance vector <cite>[D=0,A=1]</cite> to <cite>A</cite> and <cite>E</cite>. <cite>E</cite> can now reach <cite>A</cite> and <cite>D</cite>.</p></li>
<li><p><cite>C</cite> sends its distance vector <cite>[C=0]</cite> to <cite>B</cite> and <cite>E</cite></p></li>
<li><p><cite>E</cite> sends its distance vector <cite>[E=0,D=1,A=2,C=1]</cite> to <cite>D</cite>, <cite>B</cite> and <cite>C</cite>. <cite>B</cite> can now reach <cite>A</cite>, <cite>C</cite>, <cite>D</cite> and <cite>E</cite></p></li>
<li><p><cite>B</cite> sends its distance vector <cite>[B=0,A=1,C=1,D=2,E=1]</cite> to <cite>A</cite>, <cite>C</cite> and <cite>E</cite>. <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>E</cite> can now reach all five routers of this network.</p></li>
<li><p><cite>A</cite> sends its distance vector <cite>[A=0,B=1,C=2,D=1,E=2]</cite> to <cite>B</cite> and <cite>D</cite>.</p></li>
</ul>
</div></blockquote>
<p>At this point, all routers can reach all other routers in the network thanks to the routing tables shown in figure <a class="reference internal" href="#fig-dv-5routers-tables"><span class="std std-numref">Fig. 137</span></a>.</p>
<blockquote>
<div><div class="figure" id="id24" style="text-align: center">
<span id="fig-dv-5routers-tables"/><p><img src="../Images/7c1f3aa75ce05eb9400c684329583c9a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c1486faca4bfc4a9163014023f2da72e81e44823.png"/></p>
<p><span class="caption-number">Fig. 137 </span><span class="caption-text">Routing tables computed by distance vector in a simple network</span></p>
</div></div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p>To deal with link and router failures, routers use the timestamp stored in their routing table. As all routers send their distance vector every <cite>N</cite> seconds, the timestamp of each route should be regularly refreshed. Thus no route should have a timestamp older than <cite>N</cite> seconds, unless the route is not reachable anymore. In practice, to cope with the possible loss of a distance vector due to transmission errors, routers check the timestamp of the routes stored in their routing table every <cite>N</cite> seconds and remove the routes that are older than <span class="math notranslate nohighlight">\(3 \times N\)</span> seconds.</p>
<p>When a router notices that a route towards a destination has expired, it must first associate an <span class="math notranslate nohighlight">\(\infty\)</span> cost to this route and send its distance vector to its neighbors to inform them. The route can then be removed from the routing table after some time (e.g. <span class="math notranslate nohighlight">\(3 \times N\)</span> seconds), to ensure that the neighboring routers have received the bad news, even if some distance vectors do not reach them due to transmission errors.</p>
<p>Consider the example above and assume that the link between routers <cite>A</cite> and <cite>B</cite> fails. Before the failure, <cite>A</cite> used <cite>B</cite> to reach destinations <cite>B</cite>, <cite>C</cite> and <cite>E</cite> while <cite>B</cite> only used the <cite>A-B</cite> link to reach <cite>A</cite>. The two routers detect the failure by the timeouts in the affected entries in their routing tables. Both routers <cite>A</cite> and <cite>B</cite> send their distance vector.</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>A</cite> sends its distance vector <span class="math notranslate nohighlight">\([A=0,B=\infty,C=\infty,D=1,E=\infty]\)</span>. <cite>D</cite> knows that it cannot reach <cite>B</cite> anymore via <cite>A</cite></p></li>
<li><p><cite>D</cite> sends its distance vector <span class="math notranslate nohighlight">\([D=0,B=\infty,A=1,C=2,E=1]\)</span> to <cite>A</cite> and <cite>E</cite>. <cite>A</cite> recovers routes towards <cite>C</cite> and <cite>E</cite> via <cite>D</cite>.</p></li>
<li><p><cite>B</cite> sends its distance vector <span class="math notranslate nohighlight">\([B=0,A=\infty,C=1,D=2,E=1]\)</span> to <cite>E</cite> and <cite>C</cite>. <cite>C</cite> learns that there is no route anymore to reach <cite>A</cite> via <cite>B</cite>.</p></li>
<li><p><cite>E</cite> sends its distance vector <span class="math notranslate nohighlight">\([E=0,A=2,C=1,D=1,B=1]\)</span> to <cite>D</cite>, <cite>B</cite> and <cite>C</cite>. <cite>D</cite> learns a route towards <cite>B</cite>. <cite>C</cite> and <cite>B</cite> learn a route towards <cite>A</cite>.</p></li>
</ul>
</div></blockquote>
<p>At this point, all routers have a routing table allowing them to reach all other routers, except router <cite>A</cite>, which cannot yet reach router <cite>B</cite>. <cite>A</cite> recovers the route towards <cite>B</cite> once router <cite>D</cite> sends its updated distance vector <span class="math notranslate nohighlight">\([A=1,B=2,C=2,D=0,E=1]\)</span>. This last step is illustrated in figure <a class="reference internal" href="#fig-dv-5routers-failure"><span class="std std-numref">Fig. 138</span></a>, which shows the routing tables on all routers.</p>
<blockquote>
<div><div class="figure" id="id25" style="text-align: center">
<span id="fig-dv-5routers-failure"/><p><img src="../Images/f6f46399afab72ccf3c3eb51d5f05021.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c25840e94b71c98694ba6dd9f79377a61ee9860c.png"/></p>
<p><span class="caption-number">Fig. 138 </span><span class="caption-text">Routing tables computed by distance vector after a failure</span></p>
</div></div></blockquote>
<p id="index-13">Consider now that the link between <cite>D</cite> and <cite>E</cite> fails. The network is now partitioned into two disjoint parts: (<cite>A</cite> , <cite>D</cite>)  and (<cite>B</cite>, <cite>E</cite>, <cite>C</cite>). The routes towards <cite>B</cite>, <cite>C</cite> and <cite>E</cite> expire first on router <cite>D</cite>. At this time, router <cite>D</cite> updates its routing table.</p>
<p>If <cite>D</cite> sends <span class="math notranslate nohighlight">\([D=0, A=1, B=\infty, C=\infty, E=\infty]\)</span>, <cite>A</cite> learns that <cite>B</cite>, <cite>C</cite> and <cite>E</cite> are unreachable and updates its routing table.</p>
<p>Unfortunately, if the distance vector sent to <cite>A</cite> is lost or if <cite>A</cite> sends its own distance vector ( <span class="math notranslate nohighlight">\([A=0,D=1,B=3,C=3,E=2]\)</span> ) at the same time as <cite>D</cite> sends its distance vector, <cite>D</cite> updates its routing table to use the shorter routes advertised by <cite>A</cite> towards <cite>B</cite>, <cite>C</cite> and <cite>E</cite>. After some time <cite>D</cite> sends a new distance vector : <span class="math notranslate nohighlight">\([D=0,A=1,E=3,C=4,B=4]\)</span>. <cite>A</cite> updates its routing table and after some time sends its own distance vector <span class="math notranslate nohighlight">\([A=0,D=1,B=5,C=5,E=4]\)</span>, etc. This problem is known as the <cite>count to infinity problem</cite> in the networking literature.</p>
<p>Routers <cite>A</cite> and <cite>D</cite> exchange distance vectors with increasing costs until these costs reach <span class="math notranslate nohighlight">\(\infty\)</span>. This problem may occur in other scenarios than the one depicted in the above figure. In fact, distance vector routing may suffer from count to infinity problems as soon as there is a cycle in the network. Unfortunately, cycles are widely used in networks since they provide the required redundancy to deal with link and router failures. To mitigate the impact of counting to infinity, some distance vector protocols consider that <span class="math notranslate nohighlight">\(16=\infty\)</span>. Unfortunately, this limits the metrics that network operators can use and the diameter of the networks using distance vectors.</p>
<p id="index-14">This count to infinity problem occurs because router <cite>A</cite> advertises to router <cite>D</cite> a route that it has learned via router <cite>D</cite>. A possible solution to avoid this problem could be to change how a router creates its distance vector. Instead of computing one distance vector and sending it to all its neighbors, a router could create a distance vector that is specific to each neighbor and only contains the routes that have not been learned via this neighbor. This could be implemented by the following pseudocode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># split horizon</span>
<span class="n">Every</span> <span class="n">N</span> <span class="n">seconds</span><span class="p">:</span>
    <span class="c1"># one vector for each interface</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">!=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>
        <span class="n">send</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="c1"># end for d in R[]</span>
    <span class="c1"># end for l in interfaces</span>
</pre></div>
</div>
<p>This technique is called <cite>split-horizon</cite>. With this technique, the count to infinity problem would not have happened in the above scenario, as router <cite>A</cite> would have advertised <span class="math notranslate nohighlight">\([A=0]\)</span> after the failure, since it learned all its other routes via router <cite>D</cite>. Another variant called <cite>split-horizon with poison reverse</cite> is also possible.  Routers using this variant advertise a cost of <span class="math notranslate nohighlight">\(\infty\)</span> for the destinations that they reach via the router to which they send the distance vector. This can be implemented by using the pseudo-code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># split horizon with poison reverse</span>
<span class="n">Every</span> <span class="n">N</span> <span class="n">seconds</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>
        <span class="c1"># one vector for each interface</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">!=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">infinity</span><span class="p">)</span>
        <span class="n">send</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="c1"># end for d in R[]</span>
    <span class="c1"># end for l in interfaces</span>
</pre></div>
</div>
<p>Unfortunately, split-horizon is not sufficient to avoid all count to infinity problems with distance vector routing. Consider the failure of link <cite>A-B</cite> in the four routers network shown in figure <a class="reference internal" href="#fig-dv-4routers-count"><span class="std std-numref">Fig. 139</span></a>.</p>
<blockquote>
<div><div class="figure" id="id26" style="text-align: center">
<span id="fig-dv-4routers-count"/><p><img src="../Images/52e88a9b6b9535c5fb1a69d33e6abe9d.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c31d45d09804a51745715c3cbb1daca3086b49b4.png"/></p>
<p><span class="caption-number">Fig. 139 </span><span class="caption-text">Count to infinity problem</span></p>
</div></div></blockquote>
<p>After having detected the failure, router <cite>B</cite> sends its distance vectors:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\([A=\infty,B=0,C=\infty,E=1]\)</span> to router <cite>C</cite></p></li>
<li><p><span class="math notranslate nohighlight">\([A=\infty,B=0,C=1,E=\infty]\)</span> to router <cite>E</cite></p></li>
</ul>
</div></blockquote>
<p>If, unfortunately, the distance vector sent to router <cite>C</cite> is lost due to a transmission error or because router <cite>C</cite> is overloaded, a new count to infinity problem can occur. If router <cite>C</cite> sends its distance vector <span class="math notranslate nohighlight">\([A=2,B=1,C=0,E=\infty]\)</span> to router <cite>E</cite>, this router installs a route of distance <cite>3</cite> to reach <cite>A</cite> via <cite>C</cite>. Router <cite>E</cite> sends its distance vectors <span class="math notranslate nohighlight">\([A=3,B=\infty,C=1,E=1]\)</span> to router <cite>B</cite> and <span class="math notranslate nohighlight">\([A=\infty,B=1,C=\infty,E=0]\)</span> to router <cite>C</cite>. This distance vector allows <cite>B</cite> to recover a route of distance <cite>4</cite> to reach <cite>A</cite>.</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <div class="admonition note">
<p class="admonition-title">Note</p>
<p>Forwarding tables versus routing tables</p>
<p>Routers usually maintain at least two data structures that contain information about the reachable destinations. The first data structure is the <cite>routing table</cite>. The <cite>routing table</cite> is a data structure that associates a destination to an outgoing interface or a nexthop router and a set of additional attributes. Different routing protocols can associate different attributes for each destination. Distance vector routing protocols will store the cost to reach the destination along the shortest path. Other routing protocols may store information about the number of hops of the best path, its lifetime or the number of sub paths. A <cite>routing table</cite> may store different paths towards a given destination and flag one of them as the best one.</p>
<p>The <cite>routing table</cite> is a software data structure which is updated by (one or more) routing protocols. The <cite>routing table</cite> is usually not directly used when forwarding packets. Packet forwarding relies on a more compact data structure which is the <cite>forwarding table</cite>. On high-end routers, the <cite>forwarding table</cite> is implemented directly in hardware while lower performance routers will use a software implementation. A <cite>forwarding table</cite> contains a subset of the information found in the <cite>routing table</cite>. It only contains the nexthops towards each destination that are used to forward packets and no attributes. A <cite>forwarding table</cite> will typically associate each destination to one or more outgoing interface or nexthop router.</p>
</div>
</section>
<section id="link-state-routing">
<span id="linkstate"/><span id="index-15"/><h2>Link state routing<a class="headerlink" href="#link-state-routing" title="Link to this heading">#</a></h2>
<p>Link state routing is the second family of routing protocols. While distance vector routers use a distributed algorithm to compute their routing tables, link-state routers exchange messages to allow each router to learn the entire network topology. Based on this learned topology, each router is then able to compute its routing table by using a shortest path computation such as Dijkstra’s algorithm <a class="reference internal" href="../bibliography.html#dijkstra1959" id="id3"><span>[Dijkstra1959]</span></a>. A detailed description of this shortest path algorithm may be found in <a class="reference internal" href="../bibliography.html#wikipedia-dijkstra" id="id4"><span>[Wikipedia:Dijkstra]</span></a>.</p>
<p>For link-state routing, a network is modeled as a <cite>directed weighted graph</cite>. Each router is a node, and the links between routers are the edges in the graph. A positive weight is associated to each directed edge and routers use the shortest path to reach each destination. In practice, different types of weights can be associated to each directed edge :</p>
<blockquote>
<div><ul class="simple">
<li><p>unit weight. If all links have a unit weight, shortest path routing prefers the paths with the least number of intermediate routers.</p></li>
<li><p>weight proportional to the propagation delay on the link. If all link weights are configured this way, shortest path routing uses the paths with the smallest propagation delay.</p></li>
<li><p><span class="math notranslate nohighlight">\(weight=\frac{C}{bandwidth}\)</span> where <cite>C</cite> is a constant larger than the highest link bandwidth in the network. If all link weights are configured this way, shortest path routing prefers higher bandwidth paths over lower bandwidth paths.</p></li>
</ul>
</div></blockquote>
<p>Usually, the same weight is associated to the two directed edges that correspond to a physical link (i.e. <span class="math notranslate nohighlight">\(R1 \rightarrow R2\)</span> and <span class="math notranslate nohighlight">\(R2 \rightarrow R1\)</span>). However, nothing in the link state protocols requires this. For example, if the weight is set in function of the link bandwidth, then an asymmetric ADSL link could have a different weight for the upstream and downstream directions. Other variants are possible. Some networks use optimization algorithms to find the best set of weights to minimize congestion inside the network for a given traffic demand <a class="reference internal" href="../bibliography.html#frt2002" id="id5"><span>[FRT2002]</span></a>.</p>
<p id="index-16">When a link-state router boots, it first needs to discover to which routers it is directly connected. For this, each router sends a HELLO message every <cite>N</cite> seconds on all its interfaces. This message contains the router’s address. Each router has a unique address. As its neighboring routers also send HELLO messages, the router automatically discovers to which neighbors it is connected. These HELLO messages are only sent to neighbors that are directly connected to a router, and a router never forwards the HELLO messages that it receives. HELLO messages are also used to detect link and router failures. A link is considered to have failed if no HELLO message has been received from a neighboring router for a period of <span class="math notranslate nohighlight">\(k \times N\)</span> seconds. This is illustrated in figure <a class="reference internal" href="#fig-ls-hello"><span class="std std-numref">Fig. 140</span></a>.</p>
<blockquote>
<div><div class="figure" id="id27" style="text-align: center">
<span id="fig-ls-hello"/><p><img src="../Images/ed161dec8dab31664eee88d66a4d8f93.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-4b15d434ff883b08599d326112d9327bf5bc7a55.png"/></p>
<p><span class="caption-number">Fig. 140 </span><span class="caption-text">The exchange of HELLO messages</span></p>
</div></div></blockquote>
<p>Once a router has discovered its neighbors, it must reliably distribute all its outgoing edges to all routers in the network to allow them to compute their local view of the network topology. For this, each router builds a <cite>link-state packet</cite> (LSP) containing the following information:</p>
<blockquote>
<div><ul class="simple">
<li><p>LSP.Router: identification (address) of the sender of the LSP</p></li>
<li><p>LSP.age: age or remaining lifetime of the LSP</p></li>
<li><p>LSP.seq: sequence number of the LSP</p></li>
<li><p>LSP.Links[]: links advertised in the LSP. Each directed link is represented with the following information:</p>
<ul>
<li><p>LSP.Links[i].Id: identification of the neighbor</p></li>
<li><p>LSP.Links[i].cost: cost of the link</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>These LSPs must be reliably distributed inside the network without using the router’s routing table since these tables can only be computed once the LSPs have been received. The <cite>Flooding</cite> algorithm is used to efficiently distribute the LSPs of all routers. Each router that implements <cite>flooding</cite> maintains a <cite>Link sSate DataBase</cite> (LSDB) containing the most recent LSP sent by each router. When a router receives a LSP, it first verifies whether this LSP is already stored inside its LSDB. If so, the router has already distributed the LSP earlier and it does not need to forward it. Otherwise, the router forwards the LSP on all its links except the link over which the LSP was received. Flooding can be implemented by using the following pseudo-code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># links is the set of all links on the router</span>
<span class="c1"># Router R's LSP arrival on link l</span>
<span class="k">if</span> <span class="n">newer</span><span class="p">(</span><span class="n">LSP</span><span class="p">,</span> <span class="n">LSDB</span><span class="p">(</span><span class="n">LSP</span><span class="o">.</span><span class="n">Router</span><span class="p">))</span> <span class="p">:</span>
    <span class="n">LSDB</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">LSP</span><span class="p">)</span>  <span class="c1"># implicitly removes older LSP from same router</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">l</span><span class="p">:</span>
           <span class="n">send</span><span class="p">(</span><span class="n">LSP</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="c1"># else, LSP has already been flooded</span>
</pre></div>
</div>
<p>In this pseudo-code, <cite>LSDB(r)</cite> returns the most recent <cite>LSP</cite> originating from router <cite>r</cite> that is stored in the <cite>LSDB</cite>. <cite>newer(lsp1, lsp2)</cite> returns true if <cite>lsp1</cite> is more recent than <cite>lsp2</cite>. See the note below for a discussion on how <cite>newer</cite> can be implemented.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Which is the most recent LSP ?</p>
<p>A router that implements flooding must be able to detect whether a received LSP is newer than the stored LSP. This requires a comparison between the sequence number of the received LSP and the sequence number of the LSP stored in the link state database. The ARPANET routing protocol <a class="reference internal" href="../bibliography.html#mrr1979" id="id6"><span>[MRR1979]</span></a> used a 6 bits sequence number and implemented the comparison as follows <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc789.html"><strong>RFC 789</strong></a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span><span class="w"> </span><span class="nf">newer</span><span class="p">(</span> <span class="n">lsp1</span><span class="p">,</span> <span class="n">lsp2</span> <span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span> <span class="p">((</span><span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span> <span class="o">-</span> <span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">))</span> <span class="ow">or</span>
           <span class="p">(</span> <span class="p">(</span><span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span> <span class="o">-</span> <span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>This comparison takes into account the modulo <span class="math notranslate nohighlight">\(2^{6}\)</span> arithmetic used to increment the sequence numbers. Intuitively, the comparison divides the circle of all sequence numbers into two halves. Usually, the sequence number of the received LSP is equal to the sequence number of the stored LSP incremented by one, but sometimes the sequence numbers of two successive LSPs may differ, e.g. if one router has been disconnected for some time. The comparison above worked well until October 27, 1980. On this day, the ARPANET crashed completely. The crash was complex and involved several routers. At one point, LSP <cite>40</cite> and LSP <cite>44</cite> from one of the routers were stored in the LSDB of some routers in the ARPANET. As LSP <cite>44</cite> was the newest, it should have replaced LSP <cite>40</cite> on all routers. Unfortunately, one of the ARPANET routers suffered from a memory problem and sequence number <cite>40</cite> (<cite>101000</cite> in binary) was replaced by <cite>8</cite> (<cite>001000</cite> in binary) in the buggy router and flooded. Three LSPs were present in the network and <cite>44</cite> was newer than <cite>40</cite> which is newer than <cite>8</cite>, but unfortunately <cite>8</cite> was considered to be newer than <cite>44</cite>… All routers started to exchange these three link state packets forever and the only solution to recover from this problem was to shutdown the entire network <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc789.html"><strong>RFC 789</strong></a>.</p>
<p>Current link state routing protocols usually use 32 bits sequence numbers and include a special mechanism in the unlikely case that a sequence number reaches the maximum value (with a 32 bits sequence number space, it takes 136 years to cycle the sequence numbers if a link state packet is generated every second).</p>
<p>To deal with the memory corruption problem, link state packets contain a checksum or CRC. This checksum is computed by the router that generates the LSP. Each router must verify the checksum when it receives or floods an LSP. Furthermore, each router must periodically verify the checksums of the LSPs stored in its LSDB. This enables them to cope with memory errors that could corrupt the LSDB as the one that occurred in the ARPANET.</p>
</div>
<p>Flooding is illustrated in figure <a class="reference internal" href="#fig-ls-flooding"><span class="std std-numref">Fig. 141</span></a>. By exchanging HELLO messages, each router learns its direct neighbors. For example, router <cite>E</cite> learns that it is directly connected to routers <cite>D</cite>, <cite>B</cite> and <cite>C</cite>. Its first LSP has sequence number <cite>0</cite> and contains the directed links <cite>E-&gt;D</cite>, <cite>E-&gt;B</cite> and <cite>E-&gt;C</cite>. Router <cite>E</cite> sends its LSP on all its links and routers <cite>D</cite>, <cite>B</cite> and <cite>C</cite> insert the LSP in their LSDB and forward it over their other links.</p>
<blockquote>
<div><div class="figure" id="id28" style="text-align: center">
<span id="fig-ls-flooding"/><p><img src="../Images/e127285ac098a043b65dee85776a39ab.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2a2c4eb4d41a705939621b272fd7e83d56f7dfcd.png"/></p>
<p><span class="caption-number">Fig. 141 </span><span class="caption-text">Flooding: example</span></p>
</div></div></blockquote>
<p>Flooding allows LSPs to be distributed to all routers inside the network without relying on routing tables. In the example above, the LSP sent by router <cite>E</cite> is likely to be sent twice on some links in the network. For example, routers <cite>B</cite> and <cite>C</cite> receive <cite>E</cite>’s LSP at almost the same time and forward it over the <cite>B-C</cite> link. To avoid sending the same LSP twice on each link, a possible solution is to slightly change the pseudo-code above so that a router waits for some random time before forwarding a LSP on each link. The drawback of this solution is that the delay to flood an LSP to all routers in the network increases. In practice, routers immediately flood the LSPs that contain new information (e.g. addition or removal of a link) and delay the flooding of refresh LSPs (i.e. LSPs that contain exactly the same information as the previous LSP originating from this router) <a class="reference internal" href="../bibliography.html#ffeb2005" id="id7"><span>[FFEB2005]</span></a>.</p>
<p>To ensure that all routers receive all LSPs, even when there are transmissions errors, link state routing protocols use <cite>reliable flooding</cite>. With <cite>reliable flooding</cite>, routers use acknowledgments and if necessary retransmissions to ensure that all link state packets are successfully transferred to each neighboring router. Thanks to reliable flooding, all routers store in their LSDB the most recent LSP sent by each router in the network. By combining the received LSPs with its own LSP, each router can build a graph that represents the entire network topology as shown in figure <a class="reference internal" href="#fig-ls-lsdb"><span class="std std-numref">Fig. 142</span></a>.</p>
<blockquote>
<div><div class="figure" id="id29" style="text-align: center">
<span id="fig-ls-lsdb"/><p><img src="../Images/43bd64f4088699d0e20f5a2a28cc52d3.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-999e8ca5abef6594dc9dd4f83812773cd5f10d58.png"/></p>
<p><span class="caption-number">Fig. 142 </span><span class="caption-text">Link state databases received by all routers</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Static or dynamic link metrics ?</p>
<p>As link state packets are flooded regularly, routers are able to measure the quality (e.g. delay or load) of their links and adjust the metric of each link according to its current quality. Such dynamic adjustments were included in the ARPANET routing protocol <a class="reference internal" href="../bibliography.html#mrr1979" id="id8"><span>[MRR1979]</span></a> . However, experience showed that it was difficult to tune the dynamic adjustments and ensure that no forwarding loops occur in the network <a class="reference internal" href="../bibliography.html#kz1989" id="id9"><span>[KZ1989]</span></a>. Today’s link state routing protocols use metrics that are manually configured on the routers and are only changed by the network operators or network management tools <a class="reference internal" href="../bibliography.html#frt2002" id="id10"><span>[FRT2002]</span></a>.</p>
</div>
<p id="index-19">When a link fails, the two routers attached to the link detect the failure by the absence of HELLO messages received during the last <span class="math notranslate nohighlight">\(k \times N\)</span> seconds. Once a router has detected the failure of one of its local links, it generates and floods a new LSP that no longer contains the failed link. This new LSP replaces the previous LSP in the network. In practice, the two routers attached to a link do not detect this failure exactly at the same time. During this period, some links may be announced in only one direction. This is illustrated in figure <a class="reference internal" href="#fig-ls-2way"><span class="std std-numref">Fig. 143</span></a>. Router <cite>E</cite> has detected the failure of link <cite>E-B</cite> and flooded a new LSP, but router <cite>B</cite> has not yet detected this failure.</p>
<blockquote>
<div><div class="figure" id="id30" style="text-align: center">
<span id="fig-ls-2way"/><p><img src="../Images/54c82dddc42e7ee74ac40c1a259a382f.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-d7b98da0477cdd87715294fdcd0a0dcdb9c82b9b.png"/></p>
<p><span class="caption-number">Fig. 143 </span><span class="caption-text">The two-way connectivity check</span></p>
</div></div></blockquote>
<p>When a link is reported in the LSP of only one of the attached routers, routers consider the link as having failed and they remove it from the directed graph that they compute from their LSDB. This is called the <cite>two-way connectivity check</cite>. This check allows link failures to be quickly flooded as a single LSP is sufficient to announce such bad news. However, when a link comes up, it can only be used once the two attached routers have sent their LSPs. The <cite>two-way connectivity check</cite> also allows for dealing with router failures. When a router fails, all its links fail by definition. These failures are reported in the LSPs sent by the neighbors of the failed router. The failed router does not, of course, send a new LSP to announce its failure. However, in the graph that represents the network, this failed router appears as a node that only has outgoing edges. Thanks to the <cite>two-way connectivity check</cite>, this failed router cannot be considered as a transit router to reach any destination since no outgoing edge is attached to it.</p>
<p>When a router has failed, its LSP must be removed from the LSDB of all routers <a class="footnote-reference brackets" href="#foverload" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. This can be done by using the <cite>age</cite> field that is included in each LSP. The <cite>age</cite> field is used to bound the maximum lifetime of a link state packet in the network. When a router generates a LSP, it sets its lifetime (usually measured in seconds) in the <cite>age</cite> field. All routers regularly decrement the <cite>age</cite> of the LSPs in their LSDB and a LSP is discarded once its <cite>age</cite> reaches <cite>0</cite>. Thanks to the <cite>age</cite> field, the LSP from a failed router does not remain in the LSDBs forever.</p>
<p>To compute its forwarding table, each router computes the spanning tree rooted at itself by using Dijkstra’s shortest path algorithm <a class="reference internal" href="../bibliography.html#dijkstra1959" id="id12"><span>[Dijkstra1959]</span></a>. The forwarding table can be derived automatically from the spanning as shown in figure <a class="reference internal" href="#fig-ls-forwarding-tables"><span class="std std-numref">Fig. 144</span></a>.</p>
<blockquote>
<div><div class="figure" id="id31" style="text-align: center">
<span id="fig-ls-forwarding-tables"/><p><img src="../Images/40a9896cfb388877cc0637008a57262c.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-01481a5658df5221a568a124f36d8cc30348bb22.png"/></p>
<p><span class="caption-number">Fig. 144 </span><span class="caption-text">Computation of the forwarding table, the paths used by packets sent by R3 are shown in red</span></p>
</div></div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="foverload" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">2</a><span class="fn-bracket">]</span></span>
<p>It should be noted that link state routing assumes that all routers in the network have enough memory to store the entire LSDB. The routers that do not have enough memory to store the entire LSDB cannot participate in link state routing. Some link state routing protocols allow routers to report that they do not have enough memory and must be removed from the graph by the other routers in the network, but this is outside the scope of this e-book.</p>
</aside>
</aside>
</section>
&#13;

<span id="index-12"/><h2>Distance vector routing<a class="headerlink" href="#distance-vector-routing" title="Link to this heading">#</a></h2>
<p>Distance vector routing is a simple distributed routing protocol. Distance vector routing allows routers to automatically discover the destinations reachable inside the network as well as the shortest path to reach each of these destinations. The shortest path is computed based on <cite>metrics</cite> or <cite>costs</cite> that are associated to each link. We use <cite>l.cost</cite> to represent the metric that has been configured for link <cite>l</cite> on a router.</p>
<p>Each router maintains a routing table. The routing table <cite>R</cite> can be modeled as a data structure that stores, for each known destination address <cite>d</cite>, the following attributes :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>R[d].link</cite> is the outgoing link that the router uses to forward packets towards destination <cite>d</cite></p></li>
<li><p><cite>R[d].cost</cite> is the sum of the metrics of the links that compose the shortest path to reach destination <cite>d</cite></p></li>
<li><p><cite>R[d].time</cite> is the timestamp of the last distance vector containing destination <cite>d</cite></p></li>
</ul>
</div></blockquote>
<p>A router that uses distance vector routing regularly sends its distance vector over all its interfaces. This distance vector is a summary of the router’s routing table that indicates the distance towards each known destination. This distance vector can be computed from the routing table by using the pseudo-code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">Every</span> <span class="n">N</span> <span class="n">seconds</span><span class="p">:</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]:</span>
        <span class="c1"># add destination d to vector</span>
        <span class="n">v</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">interfaces</span>
        <span class="c1"># send vector v on this interface</span>
        <span class="n">send</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>When a router boots, it does not know any destination in the network and its routing table only contains its local address(es). It thus sends to all its neighbors a distance vector that contains only its address at a distance of <cite>0</cite>. When a router receives a distance vector on link <cite>l</cite>, it processes it as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># V : received Vector</span>
<span class="c1"># l : link over which vector is received</span>
<span class="k">def</span><span class="w"> </span><span class="nf">received</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="c1"># received vector from link l</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">V</span><span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]):</span>
            <span class="c1"># new route</span>
            <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">cost</span>
            <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">now</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># existing route, is the new better ?</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">V</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">==</span> <span class="n">l</span><span class="p">):</span>
                <span class="c1"># Better route or change to current route</span>
                <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">cost</span>
                <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">now</span>
</pre></div>
</div>
<p>The router iterates over all addresses included in the distance vector. If the distance vector contains a destination address that the router does not know, it inserts it inside its routing table via link <cite>l</cite> and at a distance which is the sum between the distance indicated in the distance vector and the cost associated to link <cite>l</cite>. If the destination was already known by the router, it only updates the corresponding entry in its routing table if either :</p>
<blockquote>
<div><ul class="simple">
<li><p>the cost of the new route is smaller than the cost of the already known route <cite>((V[d].cost + l.cost) &lt; R[d].cost)</cite></p></li>
<li><p>the new route was learned over the same link as the current best route towards this destination <cite>(R[d].link == l)</cite></p></li>
</ul>
</div></blockquote>
<p>The first condition ensures that the router discovers the shortest path towards each destination. The second condition is used to take into account the changes of routes that may occur after a link failure or a change of the metric associated to a link.</p>
<p>To understand the operation of a distance vector protocol, let us consider the network of five routers shown in <a class="reference internal" href="#fig-dv-5routers"><span class="std std-numref">Fig. 136</span></a>.</p>
<blockquote>
<div><div class="figure" id="id23" style="text-align: center">
<span id="fig-dv-5routers"/><p><img src="../Images/2fa610c73105286d66d016e10c05cd70.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-a9a9cb808fe5a14a98c1dbe92665e86362239b99.png"/></p>
<p><span class="caption-number">Fig. 136 </span><span class="caption-text">Operation of distance vector routing in a simple network</span></p>
</div></div></blockquote>
<p>Assume that router <cite>A</cite> is the first to send its distance vector <cite>[A=0]</cite>.</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>B</cite> and <cite>D</cite> process the received distance vector and update their routing table with a route towards <cite>A</cite>.</p></li>
<li><p><cite>D</cite> sends its distance vector <cite>[D=0,A=1]</cite> to <cite>A</cite> and <cite>E</cite>. <cite>E</cite> can now reach <cite>A</cite> and <cite>D</cite>.</p></li>
<li><p><cite>C</cite> sends its distance vector <cite>[C=0]</cite> to <cite>B</cite> and <cite>E</cite></p></li>
<li><p><cite>E</cite> sends its distance vector <cite>[E=0,D=1,A=2,C=1]</cite> to <cite>D</cite>, <cite>B</cite> and <cite>C</cite>. <cite>B</cite> can now reach <cite>A</cite>, <cite>C</cite>, <cite>D</cite> and <cite>E</cite></p></li>
<li><p><cite>B</cite> sends its distance vector <cite>[B=0,A=1,C=1,D=2,E=1]</cite> to <cite>A</cite>, <cite>C</cite> and <cite>E</cite>. <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>E</cite> can now reach all five routers of this network.</p></li>
<li><p><cite>A</cite> sends its distance vector <cite>[A=0,B=1,C=2,D=1,E=2]</cite> to <cite>B</cite> and <cite>D</cite>.</p></li>
</ul>
</div></blockquote>
<p>At this point, all routers can reach all other routers in the network thanks to the routing tables shown in figure <a class="reference internal" href="#fig-dv-5routers-tables"><span class="std std-numref">Fig. 137</span></a>.</p>
<blockquote>
<div><div class="figure" id="id24" style="text-align: center">
<span id="fig-dv-5routers-tables"/><p><img src="../Images/7c1f3aa75ce05eb9400c684329583c9a.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c1486faca4bfc4a9163014023f2da72e81e44823.png"/></p>
<p><span class="caption-number">Fig. 137 </span><span class="caption-text">Routing tables computed by distance vector in a simple network</span></p>
</div></div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p>To deal with link and router failures, routers use the timestamp stored in their routing table. As all routers send their distance vector every <cite>N</cite> seconds, the timestamp of each route should be regularly refreshed. Thus no route should have a timestamp older than <cite>N</cite> seconds, unless the route is not reachable anymore. In practice, to cope with the possible loss of a distance vector due to transmission errors, routers check the timestamp of the routes stored in their routing table every <cite>N</cite> seconds and remove the routes that are older than <span class="math notranslate nohighlight">\(3 \times N\)</span> seconds.</p>
<p>When a router notices that a route towards a destination has expired, it must first associate an <span class="math notranslate nohighlight">\(\infty\)</span> cost to this route and send its distance vector to its neighbors to inform them. The route can then be removed from the routing table after some time (e.g. <span class="math notranslate nohighlight">\(3 \times N\)</span> seconds), to ensure that the neighboring routers have received the bad news, even if some distance vectors do not reach them due to transmission errors.</p>
<p>Consider the example above and assume that the link between routers <cite>A</cite> and <cite>B</cite> fails. Before the failure, <cite>A</cite> used <cite>B</cite> to reach destinations <cite>B</cite>, <cite>C</cite> and <cite>E</cite> while <cite>B</cite> only used the <cite>A-B</cite> link to reach <cite>A</cite>. The two routers detect the failure by the timeouts in the affected entries in their routing tables. Both routers <cite>A</cite> and <cite>B</cite> send their distance vector.</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>A</cite> sends its distance vector <span class="math notranslate nohighlight">\([A=0,B=\infty,C=\infty,D=1,E=\infty]\)</span>. <cite>D</cite> knows that it cannot reach <cite>B</cite> anymore via <cite>A</cite></p></li>
<li><p><cite>D</cite> sends its distance vector <span class="math notranslate nohighlight">\([D=0,B=\infty,A=1,C=2,E=1]\)</span> to <cite>A</cite> and <cite>E</cite>. <cite>A</cite> recovers routes towards <cite>C</cite> and <cite>E</cite> via <cite>D</cite>.</p></li>
<li><p><cite>B</cite> sends its distance vector <span class="math notranslate nohighlight">\([B=0,A=\infty,C=1,D=2,E=1]\)</span> to <cite>E</cite> and <cite>C</cite>. <cite>C</cite> learns that there is no route anymore to reach <cite>A</cite> via <cite>B</cite>.</p></li>
<li><p><cite>E</cite> sends its distance vector <span class="math notranslate nohighlight">\([E=0,A=2,C=1,D=1,B=1]\)</span> to <cite>D</cite>, <cite>B</cite> and <cite>C</cite>. <cite>D</cite> learns a route towards <cite>B</cite>. <cite>C</cite> and <cite>B</cite> learn a route towards <cite>A</cite>.</p></li>
</ul>
</div></blockquote>
<p>At this point, all routers have a routing table allowing them to reach all other routers, except router <cite>A</cite>, which cannot yet reach router <cite>B</cite>. <cite>A</cite> recovers the route towards <cite>B</cite> once router <cite>D</cite> sends its updated distance vector <span class="math notranslate nohighlight">\([A=1,B=2,C=2,D=0,E=1]\)</span>. This last step is illustrated in figure <a class="reference internal" href="#fig-dv-5routers-failure"><span class="std std-numref">Fig. 138</span></a>, which shows the routing tables on all routers.</p>
<blockquote>
<div><div class="figure" id="id25" style="text-align: center">
<span id="fig-dv-5routers-failure"/><p><img src="../Images/f6f46399afab72ccf3c3eb51d5f05021.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c25840e94b71c98694ba6dd9f79377a61ee9860c.png"/></p>
<p><span class="caption-number">Fig. 138 </span><span class="caption-text">Routing tables computed by distance vector after a failure</span></p>
</div></div></blockquote>
<p id="index-13">Consider now that the link between <cite>D</cite> and <cite>E</cite> fails. The network is now partitioned into two disjoint parts: (<cite>A</cite> , <cite>D</cite>)  and (<cite>B</cite>, <cite>E</cite>, <cite>C</cite>). The routes towards <cite>B</cite>, <cite>C</cite> and <cite>E</cite> expire first on router <cite>D</cite>. At this time, router <cite>D</cite> updates its routing table.</p>
<p>If <cite>D</cite> sends <span class="math notranslate nohighlight">\([D=0, A=1, B=\infty, C=\infty, E=\infty]\)</span>, <cite>A</cite> learns that <cite>B</cite>, <cite>C</cite> and <cite>E</cite> are unreachable and updates its routing table.</p>
<p>Unfortunately, if the distance vector sent to <cite>A</cite> is lost or if <cite>A</cite> sends its own distance vector ( <span class="math notranslate nohighlight">\([A=0,D=1,B=3,C=3,E=2]\)</span> ) at the same time as <cite>D</cite> sends its distance vector, <cite>D</cite> updates its routing table to use the shorter routes advertised by <cite>A</cite> towards <cite>B</cite>, <cite>C</cite> and <cite>E</cite>. After some time <cite>D</cite> sends a new distance vector : <span class="math notranslate nohighlight">\([D=0,A=1,E=3,C=4,B=4]\)</span>. <cite>A</cite> updates its routing table and after some time sends its own distance vector <span class="math notranslate nohighlight">\([A=0,D=1,B=5,C=5,E=4]\)</span>, etc. This problem is known as the <cite>count to infinity problem</cite> in the networking literature.</p>
<p>Routers <cite>A</cite> and <cite>D</cite> exchange distance vectors with increasing costs until these costs reach <span class="math notranslate nohighlight">\(\infty\)</span>. This problem may occur in other scenarios than the one depicted in the above figure. In fact, distance vector routing may suffer from count to infinity problems as soon as there is a cycle in the network. Unfortunately, cycles are widely used in networks since they provide the required redundancy to deal with link and router failures. To mitigate the impact of counting to infinity, some distance vector protocols consider that <span class="math notranslate nohighlight">\(16=\infty\)</span>. Unfortunately, this limits the metrics that network operators can use and the diameter of the networks using distance vectors.</p>
<p id="index-14">This count to infinity problem occurs because router <cite>A</cite> advertises to router <cite>D</cite> a route that it has learned via router <cite>D</cite>. A possible solution to avoid this problem could be to change how a router creates its distance vector. Instead of computing one distance vector and sending it to all its neighbors, a router could create a distance vector that is specific to each neighbor and only contains the routes that have not been learned via this neighbor. This could be implemented by the following pseudocode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># split horizon</span>
<span class="n">Every</span> <span class="n">N</span> <span class="n">seconds</span><span class="p">:</span>
    <span class="c1"># one vector for each interface</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">!=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>
        <span class="n">send</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="c1"># end for d in R[]</span>
    <span class="c1"># end for l in interfaces</span>
</pre></div>
</div>
<p>This technique is called <cite>split-horizon</cite>. With this technique, the count to infinity problem would not have happened in the above scenario, as router <cite>A</cite> would have advertised <span class="math notranslate nohighlight">\([A=0]\)</span> after the failure, since it learned all its other routes via router <cite>D</cite>. Another variant called <cite>split-horizon with poison reverse</cite> is also possible.  Routers using this variant advertise a cost of <span class="math notranslate nohighlight">\(\infty\)</span> for the destinations that they reach via the router to which they send the distance vector. This can be implemented by using the pseudo-code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># split horizon with poison reverse</span>
<span class="n">Every</span> <span class="n">N</span> <span class="n">seconds</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>
        <span class="c1"># one vector for each interface</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">R</span><span class="p">[]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">link</span> <span class="o">!=</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">Pair</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">infinity</span><span class="p">)</span>
        <span class="n">send</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="c1"># end for d in R[]</span>
    <span class="c1"># end for l in interfaces</span>
</pre></div>
</div>
<p>Unfortunately, split-horizon is not sufficient to avoid all count to infinity problems with distance vector routing. Consider the failure of link <cite>A-B</cite> in the four routers network shown in figure <a class="reference internal" href="#fig-dv-4routers-count"><span class="std std-numref">Fig. 139</span></a>.</p>
<blockquote>
<div><div class="figure" id="id26" style="text-align: center">
<span id="fig-dv-4routers-count"/><p><img src="../Images/52e88a9b6b9535c5fb1a69d33e6abe9d.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-c31d45d09804a51745715c3cbb1daca3086b49b4.png"/></p>
<p><span class="caption-number">Fig. 139 </span><span class="caption-text">Count to infinity problem</span></p>
</div></div></blockquote>
<p>After having detected the failure, router <cite>B</cite> sends its distance vectors:</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\([A=\infty,B=0,C=\infty,E=1]\)</span> to router <cite>C</cite></p></li>
<li><p><span class="math notranslate nohighlight">\([A=\infty,B=0,C=1,E=\infty]\)</span> to router <cite>E</cite></p></li>
</ul>
</div></blockquote>
<p>If, unfortunately, the distance vector sent to router <cite>C</cite> is lost due to a transmission error or because router <cite>C</cite> is overloaded, a new count to infinity problem can occur. If router <cite>C</cite> sends its distance vector <span class="math notranslate nohighlight">\([A=2,B=1,C=0,E=\infty]\)</span> to router <cite>E</cite>, this router installs a route of distance <cite>3</cite> to reach <cite>A</cite> via <cite>C</cite>. Router <cite>E</cite> sends its distance vectors <span class="math notranslate nohighlight">\([A=3,B=\infty,C=1,E=1]\)</span> to router <cite>B</cite> and <span class="math notranslate nohighlight">\([A=\infty,B=1,C=\infty,E=0]\)</span> to router <cite>C</cite>. This distance vector allows <cite>B</cite> to recover a route of distance <cite>4</cite> to reach <cite>A</cite>.</p>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <div class="admonition note">
<p class="admonition-title">Note</p>
<p>Forwarding tables versus routing tables</p>
<p>Routers usually maintain at least two data structures that contain information about the reachable destinations. The first data structure is the <cite>routing table</cite>. The <cite>routing table</cite> is a data structure that associates a destination to an outgoing interface or a nexthop router and a set of additional attributes. Different routing protocols can associate different attributes for each destination. Distance vector routing protocols will store the cost to reach the destination along the shortest path. Other routing protocols may store information about the number of hops of the best path, its lifetime or the number of sub paths. A <cite>routing table</cite> may store different paths towards a given destination and flag one of them as the best one.</p>
<p>The <cite>routing table</cite> is a software data structure which is updated by (one or more) routing protocols. The <cite>routing table</cite> is usually not directly used when forwarding packets. Packet forwarding relies on a more compact data structure which is the <cite>forwarding table</cite>. On high-end routers, the <cite>forwarding table</cite> is implemented directly in hardware while lower performance routers will use a software implementation. A <cite>forwarding table</cite> contains a subset of the information found in the <cite>routing table</cite>. It only contains the nexthops towards each destination that are used to forward packets and no attributes. A <cite>forwarding table</cite> will typically associate each destination to one or more outgoing interface or nexthop router.</p>
</div>
&#13;

<span id="linkstate"/><span id="index-15"/><h2>Link state routing<a class="headerlink" href="#link-state-routing" title="Link to this heading">#</a></h2>
<p>Link state routing is the second family of routing protocols. While distance vector routers use a distributed algorithm to compute their routing tables, link-state routers exchange messages to allow each router to learn the entire network topology. Based on this learned topology, each router is then able to compute its routing table by using a shortest path computation such as Dijkstra’s algorithm <a class="reference internal" href="../bibliography.html#dijkstra1959" id="id3"><span>[Dijkstra1959]</span></a>. A detailed description of this shortest path algorithm may be found in <a class="reference internal" href="../bibliography.html#wikipedia-dijkstra" id="id4"><span>[Wikipedia:Dijkstra]</span></a>.</p>
<p>For link-state routing, a network is modeled as a <cite>directed weighted graph</cite>. Each router is a node, and the links between routers are the edges in the graph. A positive weight is associated to each directed edge and routers use the shortest path to reach each destination. In practice, different types of weights can be associated to each directed edge :</p>
<blockquote>
<div><ul class="simple">
<li><p>unit weight. If all links have a unit weight, shortest path routing prefers the paths with the least number of intermediate routers.</p></li>
<li><p>weight proportional to the propagation delay on the link. If all link weights are configured this way, shortest path routing uses the paths with the smallest propagation delay.</p></li>
<li><p><span class="math notranslate nohighlight">\(weight=\frac{C}{bandwidth}\)</span> where <cite>C</cite> is a constant larger than the highest link bandwidth in the network. If all link weights are configured this way, shortest path routing prefers higher bandwidth paths over lower bandwidth paths.</p></li>
</ul>
</div></blockquote>
<p>Usually, the same weight is associated to the two directed edges that correspond to a physical link (i.e. <span class="math notranslate nohighlight">\(R1 \rightarrow R2\)</span> and <span class="math notranslate nohighlight">\(R2 \rightarrow R1\)</span>). However, nothing in the link state protocols requires this. For example, if the weight is set in function of the link bandwidth, then an asymmetric ADSL link could have a different weight for the upstream and downstream directions. Other variants are possible. Some networks use optimization algorithms to find the best set of weights to minimize congestion inside the network for a given traffic demand <a class="reference internal" href="../bibliography.html#frt2002" id="id5"><span>[FRT2002]</span></a>.</p>
<p id="index-16">When a link-state router boots, it first needs to discover to which routers it is directly connected. For this, each router sends a HELLO message every <cite>N</cite> seconds on all its interfaces. This message contains the router’s address. Each router has a unique address. As its neighboring routers also send HELLO messages, the router automatically discovers to which neighbors it is connected. These HELLO messages are only sent to neighbors that are directly connected to a router, and a router never forwards the HELLO messages that it receives. HELLO messages are also used to detect link and router failures. A link is considered to have failed if no HELLO message has been received from a neighboring router for a period of <span class="math notranslate nohighlight">\(k \times N\)</span> seconds. This is illustrated in figure <a class="reference internal" href="#fig-ls-hello"><span class="std std-numref">Fig. 140</span></a>.</p>
<blockquote>
<div><div class="figure" id="id27" style="text-align: center">
<span id="fig-ls-hello"/><p><img src="../Images/ed161dec8dab31664eee88d66a4d8f93.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-4b15d434ff883b08599d326112d9327bf5bc7a55.png"/></p>
<p><span class="caption-number">Fig. 140 </span><span class="caption-text">The exchange of HELLO messages</span></p>
</div></div></blockquote>
<p>Once a router has discovered its neighbors, it must reliably distribute all its outgoing edges to all routers in the network to allow them to compute their local view of the network topology. For this, each router builds a <cite>link-state packet</cite> (LSP) containing the following information:</p>
<blockquote>
<div><ul class="simple">
<li><p>LSP.Router: identification (address) of the sender of the LSP</p></li>
<li><p>LSP.age: age or remaining lifetime of the LSP</p></li>
<li><p>LSP.seq: sequence number of the LSP</p></li>
<li><p>LSP.Links[]: links advertised in the LSP. Each directed link is represented with the following information:</p>
<ul>
<li><p>LSP.Links[i].Id: identification of the neighbor</p></li>
<li><p>LSP.Links[i].cost: cost of the link</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>These LSPs must be reliably distributed inside the network without using the router’s routing table since these tables can only be computed once the LSPs have been received. The <cite>Flooding</cite> algorithm is used to efficiently distribute the LSPs of all routers. Each router that implements <cite>flooding</cite> maintains a <cite>Link sSate DataBase</cite> (LSDB) containing the most recent LSP sent by each router. When a router receives a LSP, it first verifies whether this LSP is already stored inside its LSDB. If so, the router has already distributed the LSP earlier and it does not need to forward it. Otherwise, the router forwards the LSP on all its links except the link over which the LSP was received. Flooding can be implemented by using the following pseudo-code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># links is the set of all links on the router</span>
<span class="c1"># Router R's LSP arrival on link l</span>
<span class="k">if</span> <span class="n">newer</span><span class="p">(</span><span class="n">LSP</span><span class="p">,</span> <span class="n">LSDB</span><span class="p">(</span><span class="n">LSP</span><span class="o">.</span><span class="n">Router</span><span class="p">))</span> <span class="p">:</span>
    <span class="n">LSDB</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">LSP</span><span class="p">)</span>  <span class="c1"># implicitly removes older LSP from same router</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">l</span><span class="p">:</span>
           <span class="n">send</span><span class="p">(</span><span class="n">LSP</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="c1"># else, LSP has already been flooded</span>
</pre></div>
</div>
<p>In this pseudo-code, <cite>LSDB(r)</cite> returns the most recent <cite>LSP</cite> originating from router <cite>r</cite> that is stored in the <cite>LSDB</cite>. <cite>newer(lsp1, lsp2)</cite> returns true if <cite>lsp1</cite> is more recent than <cite>lsp2</cite>. See the note below for a discussion on how <cite>newer</cite> can be implemented.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Which is the most recent LSP ?</p>
<p>A router that implements flooding must be able to detect whether a received LSP is newer than the stored LSP. This requires a comparison between the sequence number of the received LSP and the sequence number of the LSP stored in the link state database. The ARPANET routing protocol <a class="reference internal" href="../bibliography.html#mrr1979" id="id6"><span>[MRR1979]</span></a> used a 6 bits sequence number and implemented the comparison as follows <span class="target" id="index-17"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc789.html"><strong>RFC 789</strong></a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span><span class="w"> </span><span class="nf">newer</span><span class="p">(</span> <span class="n">lsp1</span><span class="p">,</span> <span class="n">lsp2</span> <span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span> <span class="p">((</span><span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span> <span class="o">-</span> <span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">))</span> <span class="ow">or</span>
           <span class="p">(</span> <span class="p">(</span><span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">lsp2</span><span class="o">.</span><span class="n">seq</span> <span class="o">-</span> <span class="n">lsp1</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>This comparison takes into account the modulo <span class="math notranslate nohighlight">\(2^{6}\)</span> arithmetic used to increment the sequence numbers. Intuitively, the comparison divides the circle of all sequence numbers into two halves. Usually, the sequence number of the received LSP is equal to the sequence number of the stored LSP incremented by one, but sometimes the sequence numbers of two successive LSPs may differ, e.g. if one router has been disconnected for some time. The comparison above worked well until October 27, 1980. On this day, the ARPANET crashed completely. The crash was complex and involved several routers. At one point, LSP <cite>40</cite> and LSP <cite>44</cite> from one of the routers were stored in the LSDB of some routers in the ARPANET. As LSP <cite>44</cite> was the newest, it should have replaced LSP <cite>40</cite> on all routers. Unfortunately, one of the ARPANET routers suffered from a memory problem and sequence number <cite>40</cite> (<cite>101000</cite> in binary) was replaced by <cite>8</cite> (<cite>001000</cite> in binary) in the buggy router and flooded. Three LSPs were present in the network and <cite>44</cite> was newer than <cite>40</cite> which is newer than <cite>8</cite>, but unfortunately <cite>8</cite> was considered to be newer than <cite>44</cite>… All routers started to exchange these three link state packets forever and the only solution to recover from this problem was to shutdown the entire network <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc789.html"><strong>RFC 789</strong></a>.</p>
<p>Current link state routing protocols usually use 32 bits sequence numbers and include a special mechanism in the unlikely case that a sequence number reaches the maximum value (with a 32 bits sequence number space, it takes 136 years to cycle the sequence numbers if a link state packet is generated every second).</p>
<p>To deal with the memory corruption problem, link state packets contain a checksum or CRC. This checksum is computed by the router that generates the LSP. Each router must verify the checksum when it receives or floods an LSP. Furthermore, each router must periodically verify the checksums of the LSPs stored in its LSDB. This enables them to cope with memory errors that could corrupt the LSDB as the one that occurred in the ARPANET.</p>
</div>
<p>Flooding is illustrated in figure <a class="reference internal" href="#fig-ls-flooding"><span class="std std-numref">Fig. 141</span></a>. By exchanging HELLO messages, each router learns its direct neighbors. For example, router <cite>E</cite> learns that it is directly connected to routers <cite>D</cite>, <cite>B</cite> and <cite>C</cite>. Its first LSP has sequence number <cite>0</cite> and contains the directed links <cite>E-&gt;D</cite>, <cite>E-&gt;B</cite> and <cite>E-&gt;C</cite>. Router <cite>E</cite> sends its LSP on all its links and routers <cite>D</cite>, <cite>B</cite> and <cite>C</cite> insert the LSP in their LSDB and forward it over their other links.</p>
<blockquote>
<div><div class="figure" id="id28" style="text-align: center">
<span id="fig-ls-flooding"/><p><img src="../Images/e127285ac098a043b65dee85776a39ab.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2a2c4eb4d41a705939621b272fd7e83d56f7dfcd.png"/></p>
<p><span class="caption-number">Fig. 141 </span><span class="caption-text">Flooding: example</span></p>
</div></div></blockquote>
<p>Flooding allows LSPs to be distributed to all routers inside the network without relying on routing tables. In the example above, the LSP sent by router <cite>E</cite> is likely to be sent twice on some links in the network. For example, routers <cite>B</cite> and <cite>C</cite> receive <cite>E</cite>’s LSP at almost the same time and forward it over the <cite>B-C</cite> link. To avoid sending the same LSP twice on each link, a possible solution is to slightly change the pseudo-code above so that a router waits for some random time before forwarding a LSP on each link. The drawback of this solution is that the delay to flood an LSP to all routers in the network increases. In practice, routers immediately flood the LSPs that contain new information (e.g. addition or removal of a link) and delay the flooding of refresh LSPs (i.e. LSPs that contain exactly the same information as the previous LSP originating from this router) <a class="reference internal" href="../bibliography.html#ffeb2005" id="id7"><span>[FFEB2005]</span></a>.</p>
<p>To ensure that all routers receive all LSPs, even when there are transmissions errors, link state routing protocols use <cite>reliable flooding</cite>. With <cite>reliable flooding</cite>, routers use acknowledgments and if necessary retransmissions to ensure that all link state packets are successfully transferred to each neighboring router. Thanks to reliable flooding, all routers store in their LSDB the most recent LSP sent by each router in the network. By combining the received LSPs with its own LSP, each router can build a graph that represents the entire network topology as shown in figure <a class="reference internal" href="#fig-ls-lsdb"><span class="std std-numref">Fig. 142</span></a>.</p>
<blockquote>
<div><div class="figure" id="id29" style="text-align: center">
<span id="fig-ls-lsdb"/><p><img src="../Images/43bd64f4088699d0e20f5a2a28cc52d3.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-999e8ca5abef6594dc9dd4f83812773cd5f10d58.png"/></p>
<p><span class="caption-number">Fig. 142 </span><span class="caption-text">Link state databases received by all routers</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Static or dynamic link metrics ?</p>
<p>As link state packets are flooded regularly, routers are able to measure the quality (e.g. delay or load) of their links and adjust the metric of each link according to its current quality. Such dynamic adjustments were included in the ARPANET routing protocol <a class="reference internal" href="../bibliography.html#mrr1979" id="id8"><span>[MRR1979]</span></a> . However, experience showed that it was difficult to tune the dynamic adjustments and ensure that no forwarding loops occur in the network <a class="reference internal" href="../bibliography.html#kz1989" id="id9"><span>[KZ1989]</span></a>. Today’s link state routing protocols use metrics that are manually configured on the routers and are only changed by the network operators or network management tools <a class="reference internal" href="../bibliography.html#frt2002" id="id10"><span>[FRT2002]</span></a>.</p>
</div>
<p id="index-19">When a link fails, the two routers attached to the link detect the failure by the absence of HELLO messages received during the last <span class="math notranslate nohighlight">\(k \times N\)</span> seconds. Once a router has detected the failure of one of its local links, it generates and floods a new LSP that no longer contains the failed link. This new LSP replaces the previous LSP in the network. In practice, the two routers attached to a link do not detect this failure exactly at the same time. During this period, some links may be announced in only one direction. This is illustrated in figure <a class="reference internal" href="#fig-ls-2way"><span class="std std-numref">Fig. 143</span></a>. Router <cite>E</cite> has detected the failure of link <cite>E-B</cite> and flooded a new LSP, but router <cite>B</cite> has not yet detected this failure.</p>
<blockquote>
<div><div class="figure" id="id30" style="text-align: center">
<span id="fig-ls-2way"/><p><img src="../Images/54c82dddc42e7ee74ac40c1a259a382f.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-d7b98da0477cdd87715294fdcd0a0dcdb9c82b9b.png"/></p>
<p><span class="caption-number">Fig. 143 </span><span class="caption-text">The two-way connectivity check</span></p>
</div></div></blockquote>
<p>When a link is reported in the LSP of only one of the attached routers, routers consider the link as having failed and they remove it from the directed graph that they compute from their LSDB. This is called the <cite>two-way connectivity check</cite>. This check allows link failures to be quickly flooded as a single LSP is sufficient to announce such bad news. However, when a link comes up, it can only be used once the two attached routers have sent their LSPs. The <cite>two-way connectivity check</cite> also allows for dealing with router failures. When a router fails, all its links fail by definition. These failures are reported in the LSPs sent by the neighbors of the failed router. The failed router does not, of course, send a new LSP to announce its failure. However, in the graph that represents the network, this failed router appears as a node that only has outgoing edges. Thanks to the <cite>two-way connectivity check</cite>, this failed router cannot be considered as a transit router to reach any destination since no outgoing edge is attached to it.</p>
<p>When a router has failed, its LSP must be removed from the LSDB of all routers <a class="footnote-reference brackets" href="#foverload" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. This can be done by using the <cite>age</cite> field that is included in each LSP. The <cite>age</cite> field is used to bound the maximum lifetime of a link state packet in the network. When a router generates a LSP, it sets its lifetime (usually measured in seconds) in the <cite>age</cite> field. All routers regularly decrement the <cite>age</cite> of the LSPs in their LSDB and a LSP is discarded once its <cite>age</cite> reaches <cite>0</cite>. Thanks to the <cite>age</cite> field, the LSP from a failed router does not remain in the LSDBs forever.</p>
<p>To compute its forwarding table, each router computes the spanning tree rooted at itself by using Dijkstra’s shortest path algorithm <a class="reference internal" href="../bibliography.html#dijkstra1959" id="id12"><span>[Dijkstra1959]</span></a>. The forwarding table can be derived automatically from the spanning as shown in figure <a class="reference internal" href="#fig-ls-forwarding-tables"><span class="std std-numref">Fig. 144</span></a>.</p>
<blockquote>
<div><div class="figure" id="id31" style="text-align: center">
<span id="fig-ls-forwarding-tables"/><p><img src="../Images/40a9896cfb388877cc0637008a57262c.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-01481a5658df5221a568a124f36d8cc30348bb22.png"/></p>
<p><span class="caption-number">Fig. 144 </span><span class="caption-text">Computation of the forwarding table, the paths used by packets sent by R3 are shown in red</span></p>
</div></div></blockquote>

        
        
            
            
                
        
        
            <pre style="overflow: hidden; width: 100%; height: 520px">Please log in to see this exercise</pre>
        
        
            
        
        
        <p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="foverload" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">2</a><span class="fn-bracket">]</span></span>
<p>It should be noted that link state routing assumes that all routers in the network have enough memory to store the entire LSDB. The routers that do not have enough memory to store the entire LSDB cannot participate in link state routing. Some link state routing protocols allow routers to report that they do not have enough memory and must be removed from the graph by the other routers in the network, but this is outside the scope of this e-book.</p>
</aside>
</aside>
    
</body>
</html>