<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Internet protocols#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Internet protocols#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html">https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html</a></blockquote>

<p>The main objective of the network layer is to allow hosts, connected to different networks, to exchange information through intermediate systems called <a class="reference internal" href="../glossary.html#term-router"><span class="xref std std-term">router</span></a>. The unit of information in the network layer is called a <a class="reference internal" href="../glossary.html#term-packet"><span class="xref std std-term">packet</span></a>.</p>
<blockquote>
<div><div class="figure" id="id28" style="text-align: center"><p><img src="../Images/666a41088f52b54a3b4670a0295154bb.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f8f635030f0c778052c1902b185d784237078aa7.png"/></p>
<p><span class="caption-number">Fig. 106 </span><span class="caption-text">The network layer in the reference model</span></p>
</div></div></blockquote>
<p>Before explaining the network layer in detail, it is useful to begin by analyzing the service provided by the <cite>datalink</cite> layer. There are many variants of the datalink layer. Some provide a connection-oriented service while others provide a connectionless service. In this section, we focus on connectionless datalink layer services as they are the most widely used. Using a connection-oriented datalink layer causes some problems that are beyond the scope of this chapter. See <span class="target" id="index-0"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3819.html"><strong>RFC 3819</strong></a> for a discussion on this topic.</p>
<blockquote>
<div><div class="figure" id="id29" style="text-align: center"><p><img src="../Images/e94f023d5f58d59588d996bb0d388d15.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-da03a2741f16be5d7f176c28f405ac3da82b5e3e.png"/></p>
<p><span class="caption-number">Fig. 107 </span><span class="caption-text">The point-to-point datalink layer</span></p>
</div></div></blockquote>
<p>There are three main types of datalink layers. The simplest datalink layer is when there are only two communicating systems that are directly connected through the physical layer. Such a datalink layer is used when there is a point-to-point link between the two communicating systems. The two systems can be hosts or routers. <abbr title="Point-to-Point Protocol">PPP</abbr>, defined in <span class="target" id="index-1"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1661.html"><strong>RFC 1661</strong></a>, is an example of such a point-to-point datalink layer. Datalink layers exchange <cite>frames</cite> and a datalink <a class="reference internal" href="../glossary.html#term-frame"><span class="xref std std-term">frame</span></a> sent by a datalink layer entity on the left is transmitted through the physical layer, so that it can reach the datalink layer entity on the right. Point-to-point datalink layers can either provide an unreliable service (frames can be corrupted or lost) or a reliable service (in this case, the datalink layer includes retransmission mechanisms similar to the ones used in the transport layer). The unreliable service is frequently used above physical layers (e.g. optical fiber, twisted pairs) having a low bit error ratio while reliability mechanisms are often used in wireless networks to recover locally from transmission errors.</p>
<p>The second type of datalink layer is the one used in Local Area Networks (LAN). Conceptually, a LAN is a set of communicating devices such that any two devices can directly exchange frames through the datalink layer. Both hosts and routers can be connected to a LAN. Some LANs only connect a few devices, but there are LANs that can connect hundreds or even thousands of devices.</p>
<figure class="align-center" id="id30">
<a class="reference internal image-reference" href="../_images/simple-lan.png"><img alt="../_images/simple-lan.png" src="../Images/a7152d7ccb5142638996cde819a282cb.png" style="width: 400.0px; height: 297.6px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/simple-lan.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 108 </span><span class="caption-text">A local area network</span><a class="headerlink" href="#id30" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In the second part, we describe the organization and the operation of Local Area Networks. An important difference between the point-to-point datalink layers and the datalink layers used in LANs is that in a LAN, each communicating device is identified by a unique <cite>datalink layer address</cite>. This address is usually embedded in the hardware of the device and different types of LANs use different types of datalink layer addresses. Most LANs use 48-bits long addresses that are usually called <cite>MAC</cite> addresses. A communicating device attached to a LAN can send a datalink frame to any other communicating device that is attached to the same LAN. Most LANs also support special broadcast and multicast datalink layer addresses. A frame sent to the broadcast address of the LAN is delivered to all communicating devices that are attached to the LAN. The multicast addresses are used to identify groups of communicating devices. When a frame is sent towards a multicast datalink layer address, it is delivered by the LAN to all communicating devices that belong to the corresponding group.</p>
<p id="index-2">The third type of datalink layers are used in Non-Broadcast Multi-Access (NBMA) networks. These networks are used to interconnect devices like a LAN. All devices attached to an NBMA network are identified by a unique datalink layer address. However, and this is the main difference between an NBMA network and a traditional LAN, the NBMA service only supports unicast. The datalink layer service provided by an NBMA network supports neither broadcast nor multicast.</p>
<p>Unfortunately no datalink layer is able to send frames of unlimited size. Each datalink layer is characterized by a maximum frame size. There are more than a dozen different datalink layers and unfortunately most of them use a different maximum frame size. The network layer must cope with the heterogeneity of the datalink layer.</p>
<p>Two different network layer protocols coexist on the Internet: IP version 4 and
IP version 6. As explained earlier, these two protocols allow a host
to send packets to any other host. Both protocols support variable-length
packets. The most important difference between IPv4 and IPv6 is the
size of the IP addresses. IPv4 uses addresses that are encoded as
a 32 bits long (4 bytes) bit string. IPv6 addresses are much longer.
An IPv6 address is encoded as a 128 bits long (16 bytes) bit string.</p>
<p>In this section, we describe how hosts use these two protocols to send
and receive packets. We do not discuss how IP addresses are allocated and
how IP packets can be efficiently forwarded through the Internet. These
parts of IPv4 and IPv6 are discussed in the second part of the book.</p>
<section id="ip-version-4">
<h2>IP version 4<a class="headerlink" href="#ip-version-4" title="Link to this heading">#</a></h2>
<p>IP version 4 is the data plane protocol of the network layer in the TCP/IP protocol suite. The design of IP version 4 was based on the following assumptions :</p>
<blockquote>
<div><ul class="simple">
<li><p>IP should provide an unreliable connectionless service (TCP provides reliability when required by the application)</p></li>
<li><p>IP operates with the datagram transmission mode</p></li>
<li><p>IP addresses have a fixed size of 32 bits</p></li>
<li><p>IP must be usable above different types of datalink layers</p></li>
<li><p>IP hosts exchange variable length packets</p></li>
</ul>
</div></blockquote>
<p>IPv4 addresses are encoded as a 32 bits field. IPv4 addresses are often represented in <cite>dotted-decimal</cite> format as a sequence of four integers separated by a <cite>dot</cite>. The first integer is the decimal representation of the most significant byte of the 32 bits IPv4 address, … For example,</p>
<blockquote>
<div><ul class="simple">
<li><p>1.2.3.4 corresponds to 00000001000000100000001100000100</p></li>
<li><p>127.0.0.1 corresponds to 01111111000000000000000000000001</p></li>
<li><p>255.255.255.255 corresponds to 11111111111111111111111111111111</p></li>
</ul>
</div></blockquote>
<p id="index-3">An IPv4 address is used to identify an interface on a router or a host. A router has thus as many IPv4 addresses as the number of interfaces that it has in the datalink layer. Most hosts have a single datalink layer interface and thus have a single IPv4 address. However, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface). These hosts are said to be <cite>multihomed</cite>. A multihomed host with two interfaces has thus two IPv4 addresses.</p>
<p>Many Internet hosts are attached to <a class="reference internal" href="../glossary.html#term-Local-Area-Networks"><span class="xref std std-term">Local Area Networks</span></a> (LANs)
such as Wi-Fi or
Ethernet networks. We will describe the operation of these networks in more
details in the second part of the book, but at this stage, the important
point to know about these LANs is that they provide a connectionless datalink
layer service. On a LAN, each device is identified by a unique 48 bits long
address that is called a <a class="reference internal" href="../glossary.html#term-MAC-address"><span class="xref std std-term">MAC address</span></a> (MAC stands for
<a class="reference internal" href="../glossary.html#term-Medium-Access-Control"><span class="xref std std-term">Medium Access Control</span></a> that will be explained in details in the
second part). To ensure the unicity of the MAC addresses, these addresses are
usually hardwired directly on the network interface cards. Each vendor
of network cards ensures that all the interfaces that it sells have a unique
MAC address. The devices attached a LAN can exchanged frames easily.
A <a class="reference internal" href="../glossary.html#term-frame"><span class="xref std std-term">frame</span></a> is a sequence of bytes that starts with a
fixed-length header followed by a payload and for some types of LANs a
trailer. The frame header contains the MAC address of the source of the
frame and the MAC address of the destination of the frame. The frame payload
carries the information exchanged and the trailer can contain a CRC to detect
transmission errors or other types of control information.</p>
<figure class="align-center" id="id31">
<span id="fig-frame-ip"/><img alt="../_images/frame-ip.svg" src="../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/frame-ip.svg"/>
<figcaption>
<p><span class="caption-number">Fig. 109 </span><span class="caption-text">A datalink layer frame containing an IPv4 packet</span><a class="headerlink" href="#id31" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>When several hosts are attached to the same LAN, they can quickly exchange
IP packets by placing these packets inside datalink layer frames. If host
A knows the MAC address of host B, it can send an IP packet as the
payload of a frame whose source MAC address is its own MAC address and
destination MAC address is B’s MAC address. We will detail later how
a host can automatically learn the MAC address of another host.</p>
<p>When a host is attached to a LAN, it can directly send packets to the
other hosts attached to the same LAN. To reach remote hosts, it must
first send its packets to a router, also attached to the LAN. The router
will be able to forward the packet to other routers such that it
reaches its final destination.</p>
<p>When a host attached to a LAN sends an IP packet, it needs to know
whether the destination is attached to the same LAN or not. If the
destination is attached to the same LAN, the host can simply place the
packet inside a frame and us the datalink layer to deliver it directly
to its final destination. Otherwise, the host must the datalink layer
to send the packet inside a frame to the LAN router that will take
care of the packet. IPv4 and IPv6 solve this problem by grouping IP
addresses in subnets. An <a class="reference internal" href="../glossary.html#term-IP-subnet"><span class="xref std std-term">IP subnet</span></a> is the set of all IP addresses
that have the same prefix. It is represented as an IP address followed
by <cite>n</cite>, the number of bits in the common prefix.</p>
<p>An IPv4 address is composed of two parts : a <cite>subnetwork identifier</cite> and  a <cite>host identifier</cite>. The <cite>subnetwork identifier</cite> is composed of the high order bits of the address and the host identifier is encoded in the low order bits of the address. This is illustrated below with a 22 bits subnetwork identifier shown in blue and a 12 bits host identifier in red.</p>
<div class="figure" id="id32" style="text-align: center"><p><img src="../Images/03c5aa7a0fcd0914d2426d59732c3312.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e26dfe934490c67c87b2cd22e9d30684eda459d5.png"/></p>
<p><span class="caption-number">Fig. 110 </span><span class="caption-text">The subnetwork (blue) and host identifiers (red) inside an IPv4 address</span></p>
</div><p>A subnet identifier or IPv4 prefix is usually <a class="footnote-reference brackets" href="#fnetmask" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> represented as <cite>A.B.C.D/p</cite> where <cite>A.B.C.D</cite> is the network address obtained by concatenating the subnet identifier with a host identifier containing only <cite>0</cite> and <cite>p</cite> is the length of the subnet identifier in bits. The table below provides examples of IP subnets.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Subnet</p></th>
<th class="head"><p>Number of
addresses</p></th>
<th class="head"><p>Smallest
address</p></th>
<th class="head"><p>Highest
address</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10.0.0.0/8</p></td>
<td><p>16,777,216</p></td>
<td><p>10.0.0.0</p></td>
<td><p>10.255.255.255</p></td>
</tr>
<tr class="row-odd"><td><p>192.168.0.0/16</p></td>
<td><p>65,536</p></td>
<td><p>192.168.0.0</p></td>
<td><p>192.168.255.255</p></td>
</tr>
<tr class="row-even"><td><p>198.18.0.0/15</p></td>
<td><p>131,072</p></td>
<td><p>198.18.0.0</p></td>
<td><p>198.19.255.255</p></td>
</tr>
<tr class="row-odd"><td><p>192.0.2.0/24</p></td>
<td><p>256</p></td>
<td><p>192.0.2.0</p></td>
<td><p>192.0.2.255</p></td>
</tr>
<tr class="row-even"><td><p>10.0.0.0/30</p></td>
<td><p>4</p></td>
<td><p>10.0.0.0</p></td>
<td><p>10.0.0.3</p></td>
</tr>
<tr class="row-odd"><td><p>10.0.0.0/31</p></td>
<td><p>2</p></td>
<td><p>10.0.0.0</p></td>
<td><p>10.0.0.1</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Class A, B, or C addresses</p>
<blockquote>
<div><p>Today’s IPv4 implementations use <cite>variable-length subnets</cite> defined in <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1519.html"><strong>RFC 1519</strong></a>. With <cite>variable-length</cite> subnets, the subnet identifier can be any size, from <cite>1</cite> to <cite>31</cite> bits. <cite>Variable-length</cite> subnets allow the network operators to use a subnet that better matches the number of hosts that are placed inside the subnet. Before the publication of <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1519.html"><strong>RFC 1519</strong></a>, IPv4 address blocks were divided in classes of addresses. <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a> defined three classes of IPv4 addresses depending on their high order bits:</p>
<blockquote>
<div><ul class="simple">
<li><p>Class A addresses are the addresses whose high order bit is set to zero. The high order byte of this address was the network identifier and the 24 low order bits the host identifier. They correspond to today’s <code class="docutils literal notranslate"><span class="pre">\8</span></code> subnets.</p></li>
<li><p>Class B addresses are the addresses whose two high order bits are set to one followed by zero. The next fourteen bits are the network identifier and the low order sixteen bits the host identifier. They correspond to today’s <code class="docutils literal notranslate"><span class="pre">/16</span></code> subnets.</p></li>
<li><p>Class C addresses are the addresses whose three high order bits are set to one followed by one and then zero. The next fourteen bits are the network identifier and the low order twenty four bits the host identifier. They correspond to today’s <code class="docutils literal notranslate"><span class="pre">/24</span></code> subnets.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p>Initially, address blocks were allocated based on the address class required. Large companies, network providers and some universities asked for a Class A addresses and obtained it. Many universities requested a Class B address. However, this allocation was inefficient as Class A address blocks are much larger than the needs of most enterprises while Class C are too small. <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1519.html"><strong>RFC 1519</strong></a> suppressed this inefficient allocation. Nowadays, the IPv4 addressing space is almost fully utilized, except some reserved blocks. The <a class="reference external" href="https://ipv4.potaroo.net/">IPv4 Address Report</a> provides a detailed report on the evolution of the allocated IPv4 addressing space.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Special IPv4 addresses</p>
<blockquote>
<div><p>Most unicast IPv4 addresses can appear as source and destination addresses in packets on the global Internet. However, it is worth noting that some blocks of IPv4 addresses have a special usage, as described in <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5735.html"><strong>RFC 5735</strong></a>. These include :</p>
</div></blockquote>
<ul class="simple">
<li><p><cite>0.0.0.0/8</cite>, which is reserved for self-identification. A common address in this block is <cite>0.0.0.0</cite>, which is sometimes used when a host boots and does not yet know its IPv4 address.</p></li>
<li><p><cite>127.0.0.0/8</cite>, which is reserved for loopback addresses. Each host implementing IPv4 must have a loopback interface (that is not attached to a datalink layer). By convention, IPv4 address <cite>127.0.0.1</cite> is assigned to this interface. This allows processes running on a host to use TCP/IP to contact other processes running on the same host. This can be very useful for testing purposes.</p></li>
<li><p><cite>10.0.0.0/8</cite>, <cite>172.16.0.0/12</cite> and <cite>192.168.0.0/16</cite> are reserved for private networks that are not directly attached to the Internet. These addresses are often called private addresses or <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1918.html"><strong>RFC 1918</strong></a> addresses.</p></li>
<li><p><cite>169.254.0.0/16</cite> is used for link-local addresses <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3927.html"><strong>RFC 3927</strong></a>. Some hosts use an address in this block when they are connected to a network that does not allocate addresses as expected.</p></li>
</ul>
</div>
<section id="ipv4-packets">
<h3>IPv4 packets<a class="headerlink" href="#ipv4-packets" title="Link to this heading">#</a></h3>
<p>The IPv4 packet format was defined in <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>. It is shown in <a class="reference internal" href="#fig-ipv4-header-detail"><span class="std std-numref">Fig. 111</span></a>. Apart from a few clarifications and some backward compatible changes, the IPv4 packet format did not change significantly since the publication of <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>. All IPv4 packets use the 20 bytes header shown in figure <a class="reference internal" href="#fig-ipv4-header-detail"><span class="std std-numref">Fig. 111</span></a>. Some IPv4 packets contain an optional header extension that is described later.</p>
<figure class="align-center" id="id33">
<span id="fig-ipv4-header-detail"/><a class="reference internal image-reference" href="../_images/ipv4.svg"><img alt="../_images/ipv4.svg" src="../Images/8871e184de5c481e4e3b12210a03c90b.png" style="width: 571.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv4.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 111 </span><span class="caption-text">The IP version 4 header</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The main fields of the IPv4 header are :</p>
<blockquote>
<div><ul class="simple">
<li><p>a 4 bits <cite>version</cite> that indicates the version of IP used to build the header. Using a version field in the header allows the network layer protocol to evolve.</p></li>
<li><p>a 4 bits <cite>IP Header Length (IHL)</cite> that indicates the length of the IP header in 32 bits words. This field allows IPv4 to use options if required, but as it is encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.</p></li>
<li><p>an 8 bits <cite>DS</cite> field that is used for Quality of Service and whose usage is described later.</p></li>
<li><p>an 8 bits <cite>Protocol</cite> field that indicates the transport layer protocol that must process the packet’s payload at the destination. Common values for this field <a class="footnote-reference brackets" href="#fprotocolnumber" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> are <cite>6</cite> for TCP and <cite>17</cite> for UDP</p></li>
<li><p>a 16 bits <cite>length</cite> field that indicates the total length of the entire IPv4 packet (header and payload) in bytes. This implies that an IPv4 packet cannot be longer than 65535 bytes.</p></li>
<li><p>a 32 bits <cite>source address</cite> field that contains the IPv4 address of the source host</p></li>
<li><p>a 32 bits <cite>destination address</cite> field that contains the IPv4 address of the destination host</p></li>
<li><p>a 16 bits <cite>checksum</cite> that protects only the IPv4 header against transmission errors</p></li>
</ul>
</div></blockquote>
<p id="index-13">The other fields of the IPv4 header are used for specific purposes. The first is the 8 bits <cite>Time To Live (TTL)</cite> field. This field is used by IPv4 to avoid the risk of having an IPv4 packet caught in an infinite loop due to a transient or permanent error in routing tables <a class="footnote-reference brackets" href="#fttl" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. We will discuss in part two why such problems can happen. The <cite>TTL</cite> field of the IPv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. Hosts send their IPv4 packets with a positive <cite>TTL</cite> (usually <cite>64</cite> or more <a class="footnote-reference brackets" href="#finitialttl" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>). When a router receives an IPv4 packet, it first decrements the <cite>TTL</cite> by one. If the <cite>TTL</cite> becomes <cite>0</cite>, the packet is discarded and a message is sent back to the packet’s source (see section <a class="reference internal" href="#icmp">ICMP</a>). Otherwise, the router performs a lookup in its forwarding table to forward the packet.</p>
<p id="index-14">A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is used above many very different datalink layers. Each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterized by a maximum frame size. From IP’s point of view, a datalink layer interface is characterized by its <cite>Maximum Transmission Unit (MTU)</cite>. The MTU of an interface is the largest IPv4 packet (including header) that it can send. The table below provides some common MTU sizes <a class="footnote-reference brackets" href="#f6lowpan" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Datalink layer</p></td>
<td><p>MTU</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet</p></td>
<td><p>1500 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>WiFi</p></td>
<td><p>2272 bytes</p></td>
</tr>
<tr class="row-even"><td><p>ATM (AAL5)</p></td>
<td><p>9180 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>802.15.4</p></td>
<td><p>102 or 81 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Token Ring</p></td>
<td><p>4464 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>FDDI</p></td>
<td><p>4352 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink layer technologies that are used today are able to send a 64 KBytes IPv4 packet inside a frame. Consider a client attached to a Token Ring network
that wishes to send packets to a server connected to an Ethernet network. The client could send a 4 KBytes packet that would need to be fragmented inside the network to reach the server.</p>
<p id="index-15">To solve these problems, IPv4 includes a packet fragmentation and reassembly mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if the packet is too long to be sent via the datalink layer. In IPv4, fragmentation is completely performed in the IP layer and a large IPv4 is fragmented into two or more IPv4 packets (called fragments). The IPv4 fragments of a large packet are normal IPv4 packets that are forwarded towards the destination of the large packet by intermediate routers.</p>
<p>The IPv4 fragmentation mechanism relies on four fields of the IPv4 header : <cite>Length</cite>, <cite>Identification</cite>, the <cite>flags</cite> and the <cite>Fragment Offset</cite>. The IPv4 header contains two flags : <cite>More fragments</cite> and <cite>Don’t Fragment (DF)</cite>. When the <cite>DF</cite> flag is set, this indicates that the packet cannot be fragmented.</p>
<p id="index-16">The basic operation of the IPv4 fragmentation is as follows. A large packet is fragmented into two or more fragments. The size of all fragments, except the last one, is equal to the Maximum Transmission Unit of the link used to forward the packet. Each IPv4 packet contains a 16 bits <cite>Identification</cite> field. When a packet is fragmented, the <cite>Identification</cite> of the large packet is copied in all fragments to allow the destination to reassemble the received fragments together. In each fragment, the <cite>Fragment Offset</cite> indicates, in units of 8 bytes, the position of the payload of the fragment in the payload of the original packet. The <cite>Length</cite> field in each fragment indicates the length of the payload of the fragment as in a normal IPv4 packet. Finally, the <cite>More fragments</cite> flag is set only in the last fragment of a large packet.</p>
<p>The following pseudo-code details the IPv4 fragmentation algorithm, assuming that the packet does not contain IP options.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1">#mtu : maximum size of the packet (including header) of outgoing link</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">len</span> <span class="o">&lt;</span>  <span class="n">mtu</span> <span class="p">:</span>
 <span class="n">send</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># packet is too large</span>
<span class="n">maxpayload</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="nb">int</span><span class="p">((</span><span class="n">mtu</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># must be n times 8 bytes</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="o">==</span><span class="s1">'DF'</span> <span class="p">:</span>
 <span class="n">discard</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># packet must be fragmented</span>
<span class="n">payload</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="n">IP</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span>
<span class="n">pos</span><span class="o">=</span><span class="mi">0</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
 <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpayload</span> <span class="p">:</span>
    <span class="n">toSend</span><span class="o">=</span><span class="n">IP</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
              <span class="n">ttl</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">frag</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">frag</span><span class="o">+</span><span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
              <span class="nb">len</span><span class="o">=</span><span class="n">mtu</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxpayload</span><span class="p">]</span>
    <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="o">+</span><span class="n">maxpayload</span>
    <span class="n">payload</span><span class="o">=</span><span class="n">payload</span><span class="p">[</span><span class="n">maxpayload</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
 <span class="k">else</span>
    <span class="n">toSend</span><span class="o">=</span><span class="n">IP</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
              <span class="n">ttl</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">frag</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">frag</span><span class="o">+</span><span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
              <span class="n">flags</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
              <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">proto</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span>
 <span class="n">forward</span><span class="p">(</span><span class="n">toSend</span><span class="p">)</span>
</pre></div>
</div>
<p>The fragments of an IPv4 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. Furthermore, some fragments may be lost and never reach the destination.</p>
<p>The reassembly algorithm used by the destination host is roughly as follows. First, the destination can verify whether a received IPv4 packet is a fragment or not by checking the value of the <cite>More fragments</cite> flag and the <cite>Fragment Offset</cite>. If the <cite>Fragment Offset</cite> is set to <cite>0</cite> and the <cite>More fragments</cite> flag is reset, the received packet has not been fragmented. Otherwise, the packet has been fragmented and must be reassembled. The reassembly algorithm relies on the <cite>Identification</cite> field of the received fragments to associate a fragment with the corresponding packet being reassembled. Furthermore, the <cite>Fragment Offset</cite> field indicates the position of the fragment payload in the original non fragmented packet. Finally, the packet with the <cite>More fragments</cite> flag reset allows the destination to determine the total length of the original no fragmented packet.</p>
<p>Note that the reassembly algorithm must deal with the unreliability of the IP network. This implies that a fragment may be duplicated or a fragment may never reach the destination. The destination can easily detect fragment duplication thanks to the <cite>Fragment Offset</cite>. To deal with fragment losses, the reassembly algorithm must bound the time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. This can be implemented by starting a timer when the first fragment of a packet is received. If the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost.</p>
<p id="index-17">The original IP specification, in <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>, defined several types of options that can be added to the IP header. Each option is encoded using a <cite>type length value</cite> format. They are not widely used today. Additional details may be found in <span class="target" id="index-19"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>.</p>
</section>
</section>
<section id="icmp-version-4">
<span id="icmp"/><span id="index-20"/><h2>ICMP version 4<a class="headerlink" href="#icmp-version-4" title="Link to this heading">#</a></h2>
<p>It is sometimes necessary for intermediate routers or the destination host to inform the sender of the packet of a problem that occurred while processing a packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control Message Protocol (ICMP). ICMP is defined in <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc792.html"><strong>RFC 792</strong></a>. ICMP messages are carried as the payload of IP packets (the protocol value reserved for ICMP is <cite>1</cite>). <a class="reference internal" href="#fig-icmpv4-header"><span class="std std-numref">Fig. 112</span></a> illustrates the IPv4 header. An ICMP message is composed of an 8 byte header and a variable length payload that usually contains the first bytes of the packet that triggered the transmission of the ICMP message.</p>
<figure class="align-center" id="id34">
<span id="fig-icmpv4-header"/><a class="reference internal image-reference" href="../_images/icmpv4.png"><img alt="../_images/icmpv4.png" src="../Images/c6f49e0d69bec409a194b8b0090a586c.png" style="width: 500.0px; height: 121.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/icmpv4.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 112 </span><span class="caption-text">ICMP version 4 <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc792.html"><strong>RFC 792</strong></a></span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In the ICMP header, the <cite>Type</cite> and <cite>Code</cite> fields indicate the type of problem that was detected by the sender of the ICMP message. The <cite>Checksum</cite> protects the entire ICMP message against transmission errors and the <cite>Data</cite> field contains additional information for some ICMP messages.</p>
<p>The main types of ICMP messages are :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Destination unreachable</cite> : a <cite>Destination unreachable</cite> ICMP message is sent when a packet cannot be delivered to its destination due to routing problems. Different types of non reachability are distinguished :</p>
<ul>
<li><p><cite>Network unreachable</cite> : this ICMP message is sent by a router that does not have a route for the subnet containing the destination address of the packet</p></li>
<li><p><cite>Host unreachable</cite> : this ICMP message is sent by a router that is attached to the subnet that contains the destination address of the packet, but this destination address cannot be reached at this time</p></li>
<li><p><cite>Protocol unreachable</cite> : this ICMP message is sent by a destination host that has received a packet, but does not support the transport protocol indicated in the packet’s <cite>Protocol</cite> field</p></li>
<li><p><cite>Port unreachable</cite> : this ICMP message is sent by a destination host that has received a packet destined to a port number, but no server process is bound to this port</p></li>
</ul>
</li>
<li><p><cite>Fragmentation needed</cite> : this ICMP message is sent by a router that receives a packet with the <cite>Don’t Fragment</cite> flag set that is larger than the MTU of the outgoing interface</p></li>
</ul>
</div></blockquote>
<p id="index-23"><em class="manpage">ping(8)</em> is often used by network operators to verify that a given IP address is reachable. Each host is supposed <a class="footnote-reference brackets" href="#fpingproblems" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> to reply with an ICMP <cite>Echo reply</cite> message when its receives an  ICMP <cite>Echo request</cite> message. A sample usage of <em class="manpage">ping(8)</em> is shown below.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>ping 130.104.1.1
PING 130.104.1.1 (130.104.1.1): 56 data bytes
64 bytes from 130.104.1.1: icmp_seq=0 ttl=243 time=19.961 ms
64 bytes from 130.104.1.1: icmp_seq=1 ttl=243 time=22.072 ms
64 bytes from 130.104.1.1: icmp_seq=2 ttl=243 time=23.064 ms
64 bytes from 130.104.1.1: icmp_seq=3 ttl=243 time=20.026 ms
64 bytes from 130.104.1.1: icmp_seq=4 ttl=243 time=25.099 ms
--- 130.104.1.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.961/22.044/25.099/1.938 ms
</pre></div>
</div>
<p id="index-24">Another very useful debugging tool is <em class="manpage">traceroute(8)</em>. The traceroute man page describes this tool as <cite>“print the route packets take to network host”</cite>. traceroute uses the <cite>TTL exceeded</cite> ICMP messages to discover the intermediate routers on the path towards a destination. The principle behind traceroute is very simple. When a router receives an IP packet whose <cite>TTL</cite> is set to <cite>1</cite> it decrements the <cite>TTL</cite> and is forced to return to the sending host a <cite>TTL exceeded</cite> ICMP message containing the header and the first bytes of the discarded IP packet. To discover all routers on a network path, a simple solution is to first send a packet whose <cite>TTL</cite> is set to <cite>1</cite>, then a packet whose <cite>TTL</cite> is set to <cite>2</cite>, etc. A sample traceroute output is shown below.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>traceroute www.ietf.org
traceroute to www.ietf.org (64.170.98.32), 64 hops max, 40 byte packets
 1  CsHalles3.sri.ucl.ac.be (192.168.251.230)  5.376 ms  1.217 ms  1.137 ms
 2  CtHalles.sri.ucl.ac.be (192.168.251.229)  1.444 ms  1.669 ms  1.301 ms
 3  CtPythagore.sri.ucl.ac.be (130.104.254.230)  1.950 ms  4.688 ms  1.319 ms
 4  fe.m20.access.lln.belnet.net (193.191.11.9)  1.578 ms  1.272 ms  1.259 ms
 5  10ge.cr2.brueve.belnet.net (193.191.16.22)  5.461 ms  4.241 ms  4.162 ms
 6  212.3.237.13 (212.3.237.13)  5.347 ms  4.544 ms  4.285 ms
 7  ae-11-11.car1.Brussels1.Level3.net (4.69.136.249)  5.195 ms  4.304 ms  4.329 ms
 8  ae-6-6.ebr1.London1.Level3.net (4.69.136.246)  8.892 ms  8.980 ms  8.830 ms
 9  ae-100-100.ebr2.London1.Level3.net (4.69.141.166)  8.925 ms  8.950 ms  9.006 ms
 10  ae-41-41.ebr1.NewYork1.Level3.net (4.69.137.66)  79.590 ms
     ae-43-43.ebr1.NewYork1.Level3.net (4.69.137.74)  78.140 ms
     ae-42-42.ebr1.NewYork1.Level3.net (4.69.137.70)  77.663 ms
 11  ae-2-2.ebr1.Newark1.Level3.net (4.69.132.98)  78.290 ms  83.765 ms  90.006 ms
 12  ae-14-51.car4.Newark1.Level3.net (4.68.99.8)  78.309 ms  78.257 ms  79.709 ms
 13  ex1-tg2-0.eqnwnj.sbcglobal.net (151.164.89.249)  78.460 ms  78.452 ms  78.292 ms
 14  151.164.95.190 (151.164.95.190)  157.198 ms  160.767 ms  159.898 ms
 15  ded-p10-0.pltn13.sbcglobal.net (151.164.191.243)  161.872 ms  156.996 ms  159.425 ms
 16  AMS-1152322.cust-rtr.swbell.net (75.61.192.10)  158.735 ms  158.485 ms  158.588 ms
 17  mail.ietf.org (64.170.98.32)  158.427 ms  158.502 ms  158.567 ms
</pre></div>
</div>
<p>The above <em class="manpage">traceroute(8)</em> output shows a 17 hops path between a host at UCLouvain and one of the main IETF servers. For each hop, traceroute provides the IPv4 address of the router that sent the ICMP message and the measured round-trip-time between the source and this router. traceroute sends three probes with each <cite>TTL</cite> value. In some cases, such as at the tenth hop above, the ICMP messages may be received from different addresses. This is usually because different packets from the same source have followed different paths <a class="footnote-reference brackets" href="#ftraceroutemore" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> in the network.</p>
<p id="index-25">Another important utilization of ICMP messages is to discover the maximum MTU that can be used to reach a destination without fragmentation. As explained earlier, when an IPv4 router receives a packet that is larger than the MTU of the outgoing link, it must fragment the packet. Unfortunately, fragmentation is a complex operation and routers cannot perform it at line rate <a class="reference internal" href="../bibliography.html#km1995" id="id11"><span>[KM1995]</span></a>. Furthermore, when a TCP segment is transported in an IP packet that is fragmented in the network, the loss of a single fragment forces TCP to retransmit the entire segment (and thus all the fragments). If TCP was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. In addition, IP reassembly causes several challenges at high speed as discussed in <span class="target" id="index-26"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a>. Using IP fragmentation to allow UDP applications to exchange large messages raises several security issues <a class="reference internal" href="../bibliography.html#kps2003" id="id12"><span>[KPS2003]</span></a>.</p>
<p>ICMP, combined with the <cite>Don’t fragment (DF)</cite> IPv4 flag, is used by TCP implementations to discover the largest MTU size that is allowed to reach a destination host without causing network fragmentation. This is the <cite>Path MTU discovery</cite> mechanism defined in <span class="target" id="index-27"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1191.html"><strong>RFC 1191</strong></a>. A TCP implementation that includes <cite>Path MTU discovery</cite> (most do) requests the IPv4 layer to send all segments inside IPv4 packets having the <cite>DF</cite> flag set. This prohibits intermediate routers from fragmenting these packets. If a router needs to forward a packet which cannot be fragmented over a link with a smaller MTU, it returns a <cite>Fragmentation needed</cite> ICMP message to the source, indicating the MTU of its outgoing link. This ICMP message contains in the MTU of the router’s outgoing link in its <cite>Data</cite> field. Upon reception of this ICMP message, the source TCP implementation adjusts its Maximum Segment Size (MSS) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.</p>
<section id="operation-of-ipv4-hosts">
<h3>Operation of IPv4 hosts<a class="headerlink" href="#operation-of-ipv4-hosts" title="Link to this heading">#</a></h3>
<p>At this point of the description of IPv4, it is useful to have a detailed look at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest case is when a host needs to send a segment in an IPv4 packet. The host performs two operations. First, it must decide on which interface the packet will be sent. Second it must create the corresponding IP packet(s).</p>
<p>To simplify the discussion in this section, we ignore the utilization of IPv4 options. This is not a severe limitation as today IPv4 packets rarely contain options. Details about the processing of the IPv4 options may be found in the relevant RFCs, such as <span class="target" id="index-28"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>.</p>
<p>An IPv4 host having <span class="math notranslate nohighlight">\(n\)</span> datalink layer interfaces manages <span class="math notranslate nohighlight">\(n+1\)</span> IPv4 addresses :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>127.0.0.1/32</cite> IPv4 address assigned by convention to its loopback address</p></li>
<li><p>one <cite>A.B.C.D/p</cite> IPv4 address assigned to each of its <span class="math notranslate nohighlight">\(n\)</span> datalink layer interfaces</p></li>
</ul>
</div></blockquote>
<p>Such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identifier assigned to its interfaces. Furthermore, the host usually uses one of its interfaces as the <cite>default</cite> interface when sending packets that are not addressed to a directly connected destination. This is represented by the <cite>default</cite> route : <cite>0.0.0.0/0</cite> that is associated to one interface.</p>
<p>When a transport protocol running on the host requests the transmission of a segment, it usually provides the IPv4 destination address to the IPv4 layer in addition to the segment <a class="footnote-reference brackets" href="#fiddf" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. The IPv4 implementation first performs a longest prefix match with the destination address in its routing table. The lookup returns the identification of the interface that must be used to send the packet. The host can then create the IPv4 packet containing the segment. The source IPv4 address of the packet is the IPv4 address of the host on the interface returned by the longest prefix match. The <cite>Protocol</cite> field of the packet is set to the identification of the local transport protocol which created the segment. The <cite>TTL</cite> field of the packet is set to the default <cite>TTL</cite> used by the host. The host must now choose the packet’s <cite>Identification</cite>. This <cite>Identification</cite> is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. Ideally, a sending host should never send a packet twice with the same <cite>Identification</cite> to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. Unfortunately, with a 16 bits <cite>Identification</cite> field and an expected MSL of 2 minutes, this implies that the maximum bandwidth to a given destination is limited to roughly 286 Mbps. With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps <span class="target" id="index-29"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a> if fragmentation must be possible <a class="footnote-reference brackets" href="#fiddf" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. This is very low and is another reason why hosts are highly encouraged to avoid fragmentation. If; despite all of this, the MTU of the outgoing interface is smaller than the packet’s length, the packet is fragmented. Finally, the packet’s checksum is computed before transmission.</p>
<p>When a host receives an IPv4 packet destined to itself, there are several operations that it must perform. First, it must check the packet’s checksum. If the checksum is incorrect, the packet is discarded. Then, it must check whether the packet has been fragmented. If yes, the packet is passed to the reassembly algorithm described earlier. Otherwise, the packet must be passed to the upper layer. This is done by looking at the <cite>Protocol</cite> field (<cite>6</cite> for TCP, <cite>17</cite> for UDP). If the host does not implement the transport layer protocol corresponding to the received <cite>Protocol</cite> field, it sends a <cite>Protocol unreachable</cite> ICMP message to the sending host. If the received packet contains an ICMP message (<cite>Protocol</cite> field set to <cite>1</cite>), the processing is more complex. An <cite>Echo-request</cite> ICMP message triggers the transmission of an <cite>ICMP Echo-reply</cite> message. The other types of ICMP messages indicate an error that was caused by a previously transmitted packet. These ICMP messages are usually forwarded to the transport protocol that sent the erroneous packet. This can be done by inspecting the contents of the ICMP message that includes the header and the first 64 bits of the erroneous packet. If the IP packet did not contain options, which is the case for most IPv4 packets, the transport protocol can find in the first 32 bits of the transport header the source and destination ports to determine the affected transport flow. This is important for Path MTU discovery for example.</p>
</section>
</section>
<section id="ip-version-6">
<h2>IP version 6<a class="headerlink" href="#ip-version-6" title="Link to this heading">#</a></h2>
<p>In the late 1980s and early 1990s the growth of the Internet was causing several operational problems on routers. Many of these routers had a single CPU and up to 1 MByte of RAM to store their operating system, packet buffers and routing tables. Given the rate of allocation of IPv4 prefixes to companies and universities willing to join the Internet, the routing tables where growing very quickly and some feared that all IPv4 prefixes would quickly be allocated. In 1987, a study cited in <span class="target" id="index-30"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1752.html"><strong>RFC 1752</strong></a>, estimated that there would be 100,000 networks in the near future. In August 1990, estimates indicated that the class B space would be exhausted by March 1994.</p>
<p>Two types of solution were developed to solve this problem. The first short term solution was the introduction of Classless Inter Domain Routing (<a class="reference internal" href="../glossary.html#term-CIDR"><span class="xref std std-term">CIDR</span></a>). A second short term solution was the Network Address Translation (<a class="reference internal" href="../glossary.html#term-NAT"><span class="xref std std-term">NAT</span></a>) mechanism, defined in <span class="target" id="index-31"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1631.html"><strong>RFC 1631</strong></a>. NAT allowed multiple hosts to share a single public IPv4 address.</p>
<p>However, in parallel with these short-term solutions, which have allowed the IPv4 Internet to continue to be usable until now, the Internet Engineering Task Force started working on developing a replacement for IPv4. This work started with an open call for proposals, outlined in <span class="target" id="index-32"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1550.html"><strong>RFC 1550</strong></a>. Several groups responded to this call with proposals for a next generation Internet Protocol (IPng) :</p>
<blockquote>
<div><ul class="simple">
<li><p>TUBA proposed in <span class="target" id="index-33"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1347.html"><strong>RFC 1347</strong></a> and <span class="target" id="index-34"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1561.html"><strong>RFC 1561</strong></a></p></li>
<li><p>PIP proposed in <span class="target" id="index-35"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1621.html"><strong>RFC 1621</strong></a></p></li>
<li><p>SIPP proposed in <span class="target" id="index-36"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a></p></li>
</ul>
</div></blockquote>
<p>The IETF decided to pursue the development of IPng based on the SIPP proposal. As IP version <cite>5</cite> was already used by the experimental ST-2 protocol defined in <span class="target" id="index-37"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1819.html"><strong>RFC 1819</strong></a>, the successor of IP version 4 is IP version 6. The initial IP version 6 defined in <span class="target" id="index-38"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1752.html"><strong>RFC 1752</strong></a> was designed based on the following assumptions :</p>
<blockquote>
<div><ul class="simple">
<li><p>IPv6 addresses are encoded as a 128 bits field</p></li>
<li><p>The IPv6 header has a simple format that can easily be parsed by hardware devices</p></li>
<li><p>A host should be able to configure its IPv6 address automatically</p></li>
<li><p>Security must be part of IPv6</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The IPng address size</p>
<p>When the work on IPng started, it was clear that 32 bits was too small to encode an IPng address and all proposals used longer addresses. However, there were many discussions about the most suitable address length. A first approach, proposed by SIPP in <span class="target" id="index-39"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a>, was to use 64 bit addresses. A 64 bits address space was 4 billion times larger than the IPv4 address space and, furthermore, from an implementation perspective, 64 bit CPUs were being considered and 64 bit addresses would naturally fit inside their registers. Another approach was to use an existing address format. This was the TUBA proposal (<span class="target" id="index-40"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1347.html"><strong>RFC 1347</strong></a>) that reuses the ISO CLNP 20 bytes addresses. The 20 bytes addresses provided room for growth, but using ISO CLNP was not favored by the IETF partially due to political reasons, despite the fact that mature CLNP implementations were already available. 128 bits appeared to be a reasonable compromise at that time.</p>
</div>
<section id="ipv6-addressing-architecture">
<h3>IPv6 addressing architecture<a class="headerlink" href="#ipv6-addressing-architecture" title="Link to this heading">#</a></h3>
<p>The experience of IPv4 revealed that the scalability of a network layer protocol heavily depends on its addressing architecture. The designers of IPv6 spent a lot of effort defining its addressing architecture <span class="target" id="index-41"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3513.html"><strong>RFC 3513</strong></a>. All IPv6 addresses are 128 bits wide. This implies that there are <span class="math notranslate nohighlight">\(340,282,366,920,938,463,463,374,607,431,768,211,456 (3.4 \times 10^{38})\)</span> different IPv6 addresses. As the surface of the Earth is about 510,072,000 <span class="math notranslate nohighlight">\(km^2\)</span>, this implies that there are about <span class="math notranslate nohighlight">\(6.67 \times 10^{23}\)</span> IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only 8 addresses per square kilometer, this is a significant improvement on paper.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Textual representation of IPv6 addresses</p>
<blockquote>
<div><blockquote>
<div><p>It is sometimes necessary to write IPv6 addresses in text format, e.g. when manually configuring addresses or for documentation purposes. The preferred format for writing IPv6 addresses is <code class="docutils literal notranslate"><span class="pre">x:x:x:x:x:x:x:x</span></code>, where the <code class="docutils literal notranslate"><span class="pre">x</span></code> ‘s are hexadecimal digits representing the eight 16-bit parts of the address. Here are a few examples of IPv6 addresses :</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abcd:ef01:2345:6789:abcd:ef01:2345:6789</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:8:800:200c:417a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fe80:0:0:0:219:e3ff:fed7:1204</span></code></p></li>
</ul>
</div></blockquote>
<p>IPv6 addresses often contain a long sequence of bits set to <code class="docutils literal notranslate"><span class="pre">0</span></code>. In this case, a compact notation has been defined. With this notation, <cite>::</cite> is used to indicate one or more groups of 16 bits blocks containing only bits set to <cite>0</cite>. For example,</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:8:800:200c:417a</span></code>  is represented as  <code class="docutils literal notranslate"><span class="pre">2001:db8::8:800:200c:417a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ff01:0:0:0:0:0:0:101</span></code>   is represented as <code class="docutils literal notranslate"><span class="pre">ff01::101</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:1</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">::1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:0</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">::</span></code></p></li>
</ul>
</div></blockquote>
<p>An IPv6 prefix can be represented as <cite>address/length</cite>, where <cite>length</cite> is the length of the prefix in bits. For example, the three notations below correspond to the same IPv6 prefix :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8:0000:cd30:0000:0000:0000:0000</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8::cd30:0:0:0:0</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8:0:cd30::</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
</ul>
</div></blockquote>
</div>
<p>IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address is used to identify one datalink-layer interface on a host. If a host has several datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then it needs several IPv6 addresses. In general, an IPv6 unicast address is structured as shown in <a class="reference internal" href="#fig-ipv6-addr-structure"><span class="std std-numref">Fig. 113</span></a>.</p>
<blockquote>
<div><div class="figure" id="id35" style="text-align: center">
<span id="fig-ipv6-addr-structure"/><p><img src="../Images/334d256816526fa56f8d5037c79a8b94.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-4558f8509d6fa81db82cb12abf3e94faa59800ee.png"/></p>
<p><span class="caption-number">Fig. 113 </span><span class="caption-text">Structure of IPv6 unicast addresses</span></p>
</div></div></blockquote>
<p id="index-42">The IETF has reserved some IPv6 addresses for a special usage. The two most important ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:1</span></code> (<code class="docutils literal notranslate"><span class="pre">::1</span></code> in compact form) is the IPv6 loopback address. This is the address of a logical interface that is always up and running on IPv6 enabled hosts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:0</span></code> (<code class="docutils literal notranslate"><span class="pre">::</span></code> in compact form) is the unspecified IPv6 address. This is the IPv6 address that a host can use as source address when trying to acquire an official address.</p></li>
</ul>
</div></blockquote>
<p id="index-43">The last type of unicast IPv6 addresses are the <cite>Link Local Unicast</cite> addresses shown in <a class="reference internal" href="#fig-ipv6-link-local"><span class="std std-numref">Fig. 114</span></a>. These addresses are part of the <cite>fe80::/10</cite> address block and are defined in <span class="target" id="index-44"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a>. Each host can compute its own link local address by concatenating the <cite>fe80::/64</cite> prefix with the 64 bits identifier of its interface. Link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. They are used notably for address discovery and auto-configuration purposes. Their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. Link local addresses have also been defined for IPv4 <span class="target" id="index-45"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3927.html"><strong>RFC 3927</strong></a>. However, the IPv4 link local addresses are only used when a host cannot obtain a regular IPv4 address, e.g. on an isolated LAN.</p>
<blockquote>
<div><div class="figure" id="id36" style="text-align: center">
<span id="fig-ipv6-link-local"/><p><img src="../Images/85809a63cecf02a8a699a08cbd775118.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-597315a4b07b3d8b4bb499f065eef093cf5435d0.png"/></p>
<p><span class="caption-number">Fig. 114 </span><span class="caption-text">IPv6 link local address structure</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All IPv6 hosts have several addresses</p>
<p>An important consequence of the IPv6 unicast addressing architecture and the utilization of link-local addresses is that each IPv6 host has several IPv6 addresses. This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.</p>
</div>
<p>The addresses described above are unicast addresses. These addresses are used to identify (interfaces on) hosts and routers. They can appear as source and destination addresses in the IPv6 packets. When a host sends a packet towards a unicast address, this packet is delivered by the network to its final destination. There are situations, such as when delivering video or television signal to a large number of receivers, where it is useful to have a network that can efficiently deliver the same packet to a large number of receivers. This is the <cite>multicast</cite> service. A multicast service can be provided in a LAN. In this case, a multicast address identifies a set of receivers and each frame sent towards this address is delivered to all receivers in the group. Multicast can also be used in a network containing routers and hosts. In this case, a multicast address identifies also a group of receivers and the network delivers efficiently each multicast packet to all members of the group. Consider for example the network shown in <a class="reference internal" href="#fig-ipv6-simple-network"><span class="std std-numref">Fig. 115</span></a>.</p>
<blockquote>
<div><div class="figure" id="id37" style="text-align: center">
<span id="fig-ipv6-simple-network"/><p><img src="../Images/bae1061d88df9cf3ecd419cee229cdb6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-59beeb7114cd16125dc7dad2d36d93cbd2ab9a96.png"/></p>
<p><span class="caption-number">Fig. 115 </span><span class="caption-text">A simple network with hosts and routers</span></p>
</div></div></blockquote>
<p>Assume that <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code> are part of a multicast group. If <code class="docutils literal notranslate"><span class="pre">A</span></code> sends a multicast packet towards this group, then <code class="docutils literal notranslate"><span class="pre">R1</span></code> will replicate the packet to forward it to <code class="docutils literal notranslate"><span class="pre">R2</span></code> and <code class="docutils literal notranslate"><span class="pre">R3</span></code>. <code class="docutils literal notranslate"><span class="pre">R2</span></code> would forward the packet towards <code class="docutils literal notranslate"><span class="pre">B</span></code>. <code class="docutils literal notranslate"><span class="pre">R3</span></code> would forward the packet towards <code class="docutils literal notranslate"><span class="pre">R4</span></code> that would deliver it to <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<p>Finally, <span class="target" id="index-46"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a> defines the structure of the IPv6 multicast addresses <a class="footnote-reference brackets" href="#fmultiiana" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>. This structure is depicted in <a class="reference internal" href="#fig-ipv6-multicast-addr"><span class="std std-numref">Fig. 116</span></a>.</p>
<blockquote>
<div><div class="figure" id="id38" style="text-align: center">
<span id="fig-ipv6-multicast-addr"/><p><img src="../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2250bbf546a7d3d505096c89409858262a471a9e.png"/></p>
<p><span class="caption-number">Fig. 116 </span><span class="caption-text">IPv6 multicast address structure</span></p>
</div></div></blockquote>
<p>The low order 112 bits of an IPv6 multicast address are the group’s identifier. The high order bits are used as a marker to distinguish multicast addresses from unicast addresses. Notably, the 4-bit <cite>Flags</cite> field indicates whether the address is temporary or permanent. Finally, the <cite>Scope</cite> field indicates the boundaries of the forwarding of packets destined to a particular address. A link-local scope indicates that a router should not forward a packet destined to such a multicast address. An organization local-scope indicates that a packet sent to such a multicast destination address should not leave the organization. Finally the global scope is intended for multicast groups spanning the global Internet.</p>
<p>Among these addresses, some are well known. For example, all hosts automatically belong to the <code class="docutils literal notranslate"><span class="pre">ff02::1</span></code> multicast group while all routers automatically belong to the <code class="docutils literal notranslate"><span class="pre">ff02::2</span></code> multicast group. A detailed discussion of IPv6 multicast is outside the scope of this chapter.</p>
</section>
<section id="ipv6-packet">
<span id="ipv6packet"/><h3>IPv6 packet<a class="headerlink" href="#ipv6-packet" title="Link to this heading">#</a></h3>
<p>The IPv6 packet format was heavily inspired by the packet format proposed for the SIPP protocol in <span class="target" id="index-47"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a>. The standard IPv6 header defined in <span class="target" id="index-48"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> occupies 40 bytes and contains 8 different fields, as shown in <a class="reference internal" href="#fig-ipv6-header-detail"><span class="std std-numref">Fig. 117</span></a>.</p>
<figure class="align-center" id="id39">
<span id="fig-ipv6-header-detail"/><a class="reference internal image-reference" href="../_images/ipv6.svg"><img alt="../_images/ipv6.svg" src="../Images/edbbdd527f59f4dd548e19b2b90f6405.png" style="width: 685.1999999999999px; height: 441.59999999999997px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 117 </span><span class="caption-text">The IP version 6 header (<span class="target" id="index-49"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a>)</span><a class="headerlink" href="#id39" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Apart from the source and destination addresses, the IPv6 header contains the following fields :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Version</cite> : a 4 bits field set to <cite>6</cite> and intended to allow IP to evolve in the future if needed</p></li>
<li><p><cite>Traffic class</cite> : this 8 bits field indicates the type of service expected by this packet and contains the <code class="docutils literal notranslate"><span class="pre">CE</span></code> and <code class="docutils literal notranslate"><span class="pre">ECT</span></code> flags that are used by <cite>Explicit Congestion Notification</cite></p></li>
<li><p><cite>Flow Label</cite> : this field was initially intended to be used to tag packets belonging to the same <cite>flow</cite>. A recent document, <span class="target" id="index-50"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6437.html"><strong>RFC 6437</strong></a> describes some possible usages of this field, but it is too early to tell whether it will be really used.</p></li>
<li><p><cite>Payload Length</cite> : this is the size of the packet payload in bytes. As the length is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of payload.</p></li>
<li><p><cite>Next Header</cite> : this 8-bit field indicates the type <a class="footnote-reference brackets" href="#fianaprotocol" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> of header that follows the IPv6 header. It can be a transport layer header (e.g. <cite>6</cite> for TCP or <cite>17</cite> for UDP) or an IPv6 option.</p></li>
<li><p><cite>Hop Limit</cite> : this 8-bit field indicates the number of routers that can forward the packet. It is decremented by one by each router and prevents packets from looping forever inside the network.</p></li>
</ul>
</div></blockquote>
<p>It is interesting to note that there is no checksum inside the IPv6 header. This is mainly because all datalink layers and transport protocols include a checksum or a CRC to protect their frames/segments against transmission errors. Adding a checksum in the IPv6 header would have forced each router to recompute the checksum of all packets, with limited benefit in detecting errors. In practice, an IP checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. However, this benefit was found to be too small given the reliability of current memories and the cost of computing the checksum on each router <a class="footnote-reference brackets" href="#fipv4checksum" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<p>When a host receives an IPv6 packet, it needs to determine which transport protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is the first role of the <cite>Next header</cite> field. The <a class="reference external" href="https://www.iana.org">IANA</a> which manages the allocation of Internet resources and protocol parameters, maintains an official list of transport protocols <a class="footnote-reference brackets" href="#fianaprotocol" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>. The following protocol numbers are reserved :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TCP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UDP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">17</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCTP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">132</span></code></p></li>
</ul>
</div></blockquote>
<p>For example, an IPv6 packet that contains an TCP segment would appear as shown in <a class="reference internal" href="#fig-ipv6-tcp"><span class="std std-numref">Fig. 118</span></a>.</p>
<figure class="align-default" id="id40">
<span id="fig-ipv6-tcp"/><a class="reference internal image-reference" href="../_images/ipv6-tcp.svg"><img alt="../_images/ipv6-tcp.svg" src="../Images/6b433eadd436f66e88bc838b2d95ab25.png" style="width: 685.1999999999999px; height: 691.1999999999999px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-tcp.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 118 </span><span class="caption-text">An IPv6 packet containing an TCP segment</span><a class="headerlink" href="#id40" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="ipv6options">However, the <cite>Next header</cite> has broader usages than simply indicating the transport protocol which is responsible for the packet payload. An IPv6 packet can contain a chain of headers and the last one indicates the transport protocol that is responsible for the packet payload. Supporting a chain of headers is a clever design from an extensibility viewpoint. As we will see, this chain of headers has several usages.</p>
<p><span class="target" id="index-51"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> defines several types of IPv6 extension headers that could be added to an IPv6 packet :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Hop-by-Hop Options</cite> header. This option is processed by routers and hosts.</p></li>
<li><p><cite>Destination Options</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Routing</cite> header. This option is processed by some nodes.</p></li>
<li><p><cite>Fragment</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Authentication</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Encapsulating Security Payload</cite>. This option is processed only by hosts.</p></li>
</ul>
</div></blockquote>
<p>The last two headers are used to add security above IPv6 and implement IPSec. They are described in <span class="target" id="index-52"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2402.html"><strong>RFC 2402</strong></a> and <span class="target" id="index-53"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2406.html"><strong>RFC 2406</strong></a> and are outside the scope of this document.</p>
<p>The <cite>Hop-by-Hop Options</cite> header was designed to make IPv6 easily extensible. In theory, this option could be used to define new fields that were not foreseen when IPv6 was designed. It is intended to be processed by both routers and hosts.  Deploying an extension to a network protocol can be difficult in practice since some nodes already support the extensions while others still use the old version and do not understand the extension. To deal with this issue, the IPv6 designers opted for a Type-Length-Value encoding of these IPv6 options. The <cite>Hop-by-Hop Options</cite> header is encoded as show in <a class="reference internal" href="#fig-ipv6-hbhoption"><span class="std std-numref">Fig. 119</span></a>.</p>
<figure class="align-default" id="id41">
<span id="fig-ipv6-hbhoption"/><a class="reference internal image-reference" href="../_images/ipv6-hbh.svg"><img alt="../_images/ipv6-hbh.svg" src="../Images/342b609792a5cdad56255af20171a375.png" style="width: 694.8px; height: 172.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-hbh.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 119 </span><span class="caption-text">The IPv6 <cite>Hop-by-Hop Options</cite> header</span><a class="headerlink" href="#id41" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this optional header, the <cite>Next Header</cite> field is used to support the chain of headers. It indicates the type of the next header in the chain. IPv6 headers have different lengths. The <cite>Hdr Ext Len</cite> field indicates the total length of the option header in bytes. The <cite>Opt. Type</cite> field indicates the type of option. These types are encoded such that their high order bits specify how the header needs to be handled by nodes that do not recognize it. The following values are defined for the two high order bits :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">00</span></code> : if a node does not recognize this header, it  can be safely skipped and the processing continues with the subsequent header</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">01</span></code> : if a node does not recognize this header, the packet must be discarded</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10</span></code> (resp. <code class="docutils literal notranslate"><span class="pre">11</span></code>) : if a node does not recognize this header, it must return a control packet (ICMP, see later) back to the source (resp. except if the destination was a multicast address)</p></li>
</ul>
</div></blockquote>
<p>This encoding allows the designers of protocol extensions to specify whether the option must be supported by all nodes on a path or not. Still, deploying such an extension can be difficult in practice.</p>
<p id="index-54">Two <cite>hop-by-hop</cite> options have been defined. <span class="target" id="index-55"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2675.html"><strong>RFC 2675</strong></a> specifies the jumbogram that enables IPv6 to support packets containing a payload larger than 65535 bytes. These jumbo packets have their <cite>payload length</cite> set to <cite>0</cite> and the jumbogram option contains the packet length as a 32 bits field. Such packets can only be sent from a source to a destination if all the routers on the path support this option. However, as of this writing it does not seem that the jumbogram option has been implemented. The router alert option defined in <span class="target" id="index-56"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2711.html"><strong>RFC 2711</strong></a> is the second example of a <cite>hop-by-hop</cite> option. The packets that contain this option should be processed in a special way by intermediate routers. This option is used for IP packets that carry Resource Reservation Protocol (RSVP) messages, but this is outside the scope of this book.</p>
<p>The <cite>Destinations Option</cite> header uses the same format as the <cite>Hop-by-Hop Options</cite> header. It has some usages, e.g. to support mobile nodes <span class="target" id="index-57"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6275.html"><strong>RFC 6275</strong></a>, but these are outside the scope of this document.</p>
<p id="index-58">The <cite>Fragment Options</cite> header is more important. An important problem in the network layer is the ability to handle heterogeneous datalink layers. Most datalink layer technologies can only transmit and receive frames that are shorter than a given maximum frame size. Unfortunately, all datalink layer technologies use different maximum frames sizes.</p>
<p id="index-59">Each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterized by a maximum frame size. From IP’s point of view, a datalink layer interface is characterized by its <cite>Maximum Transmission Unit (MTU)</cite>. The MTU of an interface is the largest packet (including header) that it can send. The table below provides some common MTU sizes.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Datalink layer</p></td>
<td><p>MTU</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet</p></td>
<td><p>1500 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>WiFi</p></td>
<td><p>2272 bytes</p></td>
</tr>
<tr class="row-even"><td><p>ATM (AAL5)</p></td>
<td><p>9180 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>802.15.4</p></td>
<td><p>102 or 81 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Token Ring</p></td>
<td><p>4464 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>FDDI</p></td>
<td><p>4352 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although IPv6 can send 64 KBytes long packets, few datalink layer technologies that are used today are able to send a 64 KBytes packet inside a frame. Furthermore, as illustrated in <a class="reference internal" href="#fig-ipv6-need-fragmentation"><span class="std std-numref">Fig. 120</span></a>, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.</p>
<blockquote>
<div><div class="figure" id="id42" style="text-align: center">
<span id="fig-ipv6-need-fragmentation"/><p><img src="../Images/1baf064048236d27ceffa188e5e44d59.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-afc7ac3182d066f891384914a3f8683b3655b333.png"/></p>
<p><span class="caption-number">Fig. 120 </span><span class="caption-text">The need for fragmentation and reassembly</span></p>
</div></div></blockquote>
<p id="index-60">To solve these problems, IPv6 includes a packet fragmentation and reassembly mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate routers. However, experience with IPv4 has shown that fragmenting packets in routers was costly <a class="reference internal" href="../bibliography.html#km1995" id="id20"><span>[KM1995]</span></a>.  For this reason, the developers of IPv6 have decided that routers would not fragment packets anymore. In IPv6, fragmentation is only performed by the source host. If a source has to send a packet which is larger than the MTU of the outgoing interface, the packet needs to be fragmented before being transmitted. In IPv6, each packet fragment is an IPv6 packet that includes the <cite>Fragmentation</cite> header shown in <a class="reference internal" href="#fig-ipv6-fragment-header"><span class="std std-numref">Fig. 121</span></a>. This header is included by the source in each packet fragment. The receiver uses them to reassemble the received fragments.</p>
<figure class="align-default" id="id43">
<span id="fig-ipv6-fragment-header"/><a class="reference internal image-reference" href="../_images/ipv6-fragment.svg"><img alt="../_images/ipv6-fragment.svg" src="../Images/bf5635c8afb9faf01ffd82e5c9a79010.png" style="width: 685.1999999999999px; height: 96.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-fragment.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 121 </span><span class="caption-text">IPv6 fragmentation header</span><a class="headerlink" href="#id43" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>If a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an ICMPv6 message to inform the sender of the problem. The sender can then either fragment the packet or perform Path MTU discovery. In IPv6, packet fragmentation is performed only by the source by using IPv6 options.</p>
<p>In IPv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. This 64 bits header is composed of six fields :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>Next Header</cite> field that indicates the type of the header that follows the fragmentation header</p></li>
<li><p>two <cite>Reserved</cite> fields set to <cite>0</cite>.</p></li>
<li><p>the <cite>Fragment Offset</cite> is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following this header, relative to the start of the original packet.</p></li>
<li><p>the <cite>More</cite> flag, which is set to <cite>0</cite> in the last fragment of a packet and to <cite>1</cite> in all other fragments.</p></li>
<li><p>the 32-bit <cite>Identification</cite> field indicates to which original packet a fragment belongs. When a host sends fragmented packets, it should ensure that it does not reuse the same <cite>identification</cite> field for packets sent to the same destination during a period of <cite>MSL</cite> seconds. This is easier with the 32 bits <cite>identification</cite> used in the IPv6 fragmentation header, than with the 16 bits <cite>identification</cite> field of the IPv4 header.</p></li>
</ul>
</div></blockquote>
<p>Some IPv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the first fragment. Others send the fragments in reverse order, starting from the last fragment. The latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to reassemble all fragments of the packet upon reception of the last fragment. When a host receives the first fragment of an IPv6 packet, it cannot know a priori the length of the entire IPv6 packet.</p>
<p><a class="reference internal" href="#fig-ipv6-fragmentation-example"><span class="std std-numref">Fig. 122</span></a> provides an example of a fragmented IPv6 packet containing a UDP segment. The <cite>Next Header</cite> type reserved for the IPv6 fragmentation option is 44.</p>
<figure class="align-center" id="id44">
<span id="fig-ipv6-fragmentation-example"/><a class="reference internal image-reference" href="../_images/ipv6-frag-example.png"><img alt="../_images/ipv6-frag-example.png" src="../Images/4d1256f56efdd49bd1e8367b8821cdac.png" style="width: 451.49999999999994px; height: 288.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-frag-example.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 122 </span><span class="caption-text">IPv6 fragmentation example</span><a class="headerlink" href="#id44" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The following pseudo-code details the IPv6 fragmentation, assuming that the packet does not contain options.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># mtu : maximum size of the packet (including header) of outgoing link</span>
<span class="c1"># In Scapy-like notation (see https://github.com/secdev/scapy)</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mtu</span><span class="p">:</span>
    <span class="n">send</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># packet is too large</span>
    <span class="c1"># 40 refers to the size of the IPv6 header</span>
    <span class="n">maxpayload</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="nb">int</span><span class="p">((</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># must be n times 8 bytes</span>
    <span class="c1"># packet must be fragmented</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">IPv6</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">globalCounter</span>
    <span class="n">globalCounter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpayload</span><span class="p">:</span>
            <span class="n">toSend</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">plen</span><span class="o">=</span><span class="n">mtu</span><span class="p">,</span>
                          <span class="n">hlim</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">hlim</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span><span class="o">/</span><span class="n">IPv6ExtHdrFrament</span><span class="p">(</span>
                              <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">nh</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">nh</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxpayload</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">maxpayload</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="n">maxpayload</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The last fragment</span>
            <span class="n">toSend</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">plen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span>
                          <span class="n">hlim</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">hlim</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span><span class="o">/</span><span class="n">IPv6ExtHdrFrament</span><span class="p">(</span>
                              <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">nh</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">nh</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">forward</span><span class="p">(</span><span class="n">toSend</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above pseudocode, we maintain a single 32 bits counter that is incremented for each packet that needs to be fragmented. Other implementations to compute the packet identification are possible. <span class="target" id="index-61"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> only requires that two fragmented packets that are sent within the MSL between the same pair of hosts have different identifications.</p>
<p>The fragments of an IPv6 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. Furthermore, some fragments may be lost and never reach the destination.</p>
<p>The reassembly algorithm used by the destination host is roughly as follows. First, the destination can verify whether a received IPv6 packet is a fragment or not by checking whether it contains a fragment header. If so, all fragments with the some identification must be reassembled together. The reassembly algorithm relies on the <cite>Identification</cite> field of the received fragments to associate a fragment with the corresponding packet being reassembled. Furthermore, the <cite>Fragment Offset</cite> field indicates the position of the fragment payload in the original non-fragmented packet. Finally, the packet with the <cite>M</cite> flag reset allows the destination to determine the total length of the original non-fragmented packet.</p>
<p>Note that the reassembly algorithm must deal with the unreliability of the IP network. This implies that a fragment may be duplicated or a fragment may never reach the destination. The destination can easily detect fragment duplication thanks to the <cite>Fragment Offset</cite>. To deal with fragment losses, the reassembly algorithm must bind the time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. This can be implemented by starting a timer when the first fragment of a packet is received. If the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Header compression on low bandwidth links</p>
<p>Given the size of the IPv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for Voice over IP applications. In such environments, several techniques can be used to reduce the overhead. A first solution is to use data compression in the datalink layer to compress all the information exchanged <a class="reference internal" href="../bibliography.html#thomborson1992" id="id21"><span>[Thomborson1992]</span></a>. These techniques are similar to the data compression algorithms used in tools such as <em class="manpage">compress(1)</em> or <em class="manpage">gzip(1)</em> <span class="target" id="index-62"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1951.html"><strong>RFC 1951</strong></a>. They compress streams of bits without taking advantage of the fact that these streams contain IP packets with a known structure. A second solution is to compress the IP and TCP header. These header compression techniques, such as the one defined in <span class="target" id="index-63"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5795.html"><strong>RFC 5795</strong></a> take advantage of the redundancy found in successive packets from the same flow to significantly reduce the size of the protocol headers. Another solution is to define a compressed encoding of the IPv6 header that matches the capabilities of the underlying datalink layer <span class="target" id="index-64"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a>.</p>
</div>
<p>The last type of <cite>IPv6 header extension</cite> is the <cite>Routing</cite> header. The <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">0</span></code> routing header defined in <span class="target" id="index-65"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> is an example of an IPv6 option that must be processed by some routers. This option is encoded as shown in <a class="reference internal" href="#fig-ipv6-rh0"><span class="std std-numref">Fig. 123</span></a>.</p>
<figure class="align-center" id="id45">
<span id="fig-ipv6-rh0"/><a class="reference internal image-reference" href="../_images/ipv6-routing-0.svg"><img alt="../_images/ipv6-routing-0.svg" src="../Images/276a7739af129da2cd8c3b5ec430d381.png" style="width: 579.0px; height: 592.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-routing-0.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 123 </span><span class="caption-text">The Type 0 routing header (<span class="target" id="index-66"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a>)</span><a class="headerlink" href="#id45" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. Unfortunately, further work with this routing header, including an entertaining demonstration with <a class="reference external" href="https://www.secdev.org/projects/scapy/">scapy</a> <a class="reference internal" href="../bibliography.html#be2007" id="id22"><span>[BE2007]</span></a> , revealed severe security problems with this routing header. For this reason, loose source routing with the type 0 routing header has been removed from the IPv6 specification <span class="target" id="index-67"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5095.html"><strong>RFC 5095</strong></a>.</p>
</section>
<section id="icmp-version-6">
<span id="icmpv6"/><h3>ICMP version 6<a class="headerlink" href="#icmp-version-6" title="Link to this heading">#</a></h3>
<p>It is sometimes necessary for intermediate routers or the destination host to inform the sender of the packet of a problem that occurred while processing a packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control Message Protocol (ICMP). ICMPv6 is defined in <span class="target" id="index-68"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a>. It is used both to report problems that occurred while processing an IPv6 packet, but also to distribute addresses.</p>
<p>ICMPv6 messages are carried inside IPv6 packets (the <cite>Next Header</cite> field for ICMPv6 is <code class="docutils literal notranslate"><span class="pre">58</span></code>). Each ICMP message contains a 32 bits header with an 8 bits <cite>type</cite> field, a <cite>code</cite> field and a 16 bits checksum computed over the entire ICMPv6 message. The message body contains a copy of the IPv6 packet in error. The ICMPv6 header is shown in <a class="reference internal" href="#fig-icmpv6-header"><span class="std std-numref">Fig. 124</span></a>.</p>
<figure class="align-center" id="id46">
<span id="fig-icmpv6-header"/><a class="reference internal image-reference" href="../_images/icmpv6.svg"><img alt="../_images/icmpv6.svg" src="../Images/8440c110b309073d9f6a09bf2e22fccb.png" style="width: 715.1999999999999px; height: 153.6px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/icmpv6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 124 </span><span class="caption-text">ICMP version 6 packet format</span><a class="headerlink" href="#id46" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>ICMPv6 specifies two classes of messages : error messages that indicate a problem in handling a packet and informational messages. Four types of error messages are defined in <span class="target" id="index-69"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a> :</p>
<blockquote>
<div><ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code><span class="classifier"><cite>Destination Unreachable</cite>. Such an ICMPv6 message is sent when the destination address of a packet is unreachable. The <cite>code</cite> field of the ICMP header contains additional information about the type of unreachability. The following codes are specified in <span class="target" id="index-70"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a></span></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> : No route to destination. This indicates that the router that sent the ICMPv6 message did not have a route towards the packet’s destination</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : Communication with destination administratively prohibited. This indicates that a firewall has refused to forward the packet towards its final destination.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : Beyond scope of source address. This message can be sent if the source is using link-local addresses to reach a global unicast address outside its subnet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : Address unreachable. This message indicates that the packet reached the subnet of the destination, but the host that owns this destination address cannot be reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> : Port unreachable. This message indicates that the IPv6 packet was received by the destination, but there was no application listening to the specified port.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : Packet Too Big. The router that was to send the ICMPv6 message received an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message contains the MTU of this link in bytes. This allows the sending host to implement Path MTU discovery <span class="target" id="index-71"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1981.html"><strong>RFC 1981</strong></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : Time Exceeded. This error message can be sent either by a router or by a host. A router would set <cite>code</cite> to <cite>0</cite> to report the reception of a packet whose <cite>Hop Limit</cite> reached <cite>0</cite>. A host would set <cite>code</cite> to <cite>1</cite> to report that it was unable to reassemble received IPv6 fragments.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> : Parameter Problem. This ICMPv6 message is used to report either the reception of an IPv6 packet with an erroneous header field (code <cite>0</cite>) or an unknown <cite>Next Header</cite> or IP option (codes <cite>1</cite> and <cite>2</cite>). In this case, the message body contains the erroneous IPv6 packet and the first 32 bits of the message body contain a pointer to the error.</p></li>
</ul>
</div></blockquote>
<p>The <cite>Destination Unreachable</cite> ICMP error message is returned when a packet cannot be forwarded to its final destination. The first four ICMPv6 error messages (type <code class="docutils literal notranslate"><span class="pre">1</span></code>, codes <code class="docutils literal notranslate"><span class="pre">0-3</span></code>)  are generated by routers while hosts may return code <code class="docutils literal notranslate"><span class="pre">4</span></code> when there is no application bound to the corresponding port number.</p>
<p>The <cite>Packet Too Big</cite> ICMP messages enable the source host to discover the MTU size that it can safely use to reach a given destination. To understand its operation, consider the (academic) scenario shown in <a class="reference internal" href="#fig-ipv6-mtu-discovery"><span class="std std-numref">Fig. 125</span></a>. In this figure, the labels on each link represent the maximum packet size supported by this link.</p>
<blockquote>
<div><div class="figure" id="id47" style="text-align: center">
<span id="fig-ipv6-mtu-discovery"/><p><img src="../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-01f32f8a7fcf88c7a58965b21306ce4ba00c84bf.png"/></p>
<p><span class="caption-number">Fig. 125 </span><span class="caption-text">Example for IPv6 MTU discovery</span></p>
</div></div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> sends a 1500 bytes packet, <code class="docutils literal notranslate"><span class="pre">R1</span></code> will return an ICMPv6 error message indicating a maximum packet length of 1400 bytes. <code class="docutils literal notranslate"><span class="pre">A</span></code> would then fragment the packet before retransmitting it. The small fragment would go through, but the large fragment will be refused by <code class="docutils literal notranslate"><span class="pre">R2</span></code> that would return an ICMPv6 error message. <code class="docutils literal notranslate"><span class="pre">A</span></code> can fragment again the packet and send it to the final destination as two fragments.</p>
<p>In practice, an IPv6 implementation does not store the transmitted packets to be able to retransmit them if needed. However, since TCP (and SCTP) buffer the segments that they transmit, a similar approach can be used in transport protocols to detect the largest MTU on a path towards a given destination. This technique is called PathMTU Discovery <span class="target" id="index-72"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1981.html"><strong>RFC 1981</strong></a>.</p>
<p id="index-73">When a TCP segment is transported in an IP packet that is fragmented in the network, the loss of a single fragment forces TCP to retransmit the entire segment (and thus all the fragments). If TCP was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. In addition, IP reassembly causes several challenges at high speed as discussed in <span class="target" id="index-74"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a>. Using IP fragmentation to allow UDP applications to exchange large messages raises several security issues <a class="reference internal" href="../bibliography.html#kps2003" id="id23"><span>[KPS2003]</span></a>.</p>
<p>ICMPv6 is used by TCP implementations to discover the largest MTU size that is allowed to reach a destination host without causing network fragmentation. A TCP implementation parses the <cite>Packets Too Big</cite> ICMP messages that it receives. These ICMP messages contain the MTU of the router’s outgoing link in their <cite>Data</cite> field. Upon reception of such an ICMP message, the source TCP implementation adjusts its Maximum Segment Size (MSS) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.</p>
<p id="index-75">Two types of informational ICMPv6 messages are defined in <span class="target" id="index-76"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a> : <cite>echo request</cite> and <cite>echo reply</cite>, which are used to test the reachability of a destination by using <em class="manpage">ping6(8)</em>. Each host is supposed to reply with an ICMP <cite>Echo reply</cite> message when it receives an  ICMP <cite>Echo request</cite> message. A sample usage of <em class="manpage">ping6(8)</em> is shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">#</span>ping6<span class="w"> </span>www.ietf.org
<span class="go">PING6(56=40+8+8 bytes) 2001:6a8:3080:2:3403:bbf4:edae:afc3 --&gt; 2001:1890:123a::1:1e</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=0 hlim=49 time=156.905 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=1 hlim=49 time=155.618 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=2 hlim=49 time=155.808 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=3 hlim=49 time=155.325 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=4 hlim=49 time=155.493 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=5 hlim=49 time=155.801 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=6 hlim=49 time=155.660 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=7 hlim=49 time=155.869 ms</span>
<span class="go">^C</span>
<span class="go">--- www.ietf.org ping6 statistics ---</span>
<span class="go">8 packets transmitted, 8 packets received, 0.0% packet loss</span>
<span class="go">round-trip min/avg/max/std-dev = 155.325/155.810/156.905/0.447 ms</span>
</pre></div>
</div>
<p id="index-77">Another very useful debugging tool is <em class="manpage">traceroute6(8)</em>. The traceroute man page describes this tool as <cite>“print the route packets take to network host”</cite>. traceroute uses the <cite>Time exceeded</cite> ICMP messages to discover the intermediate routers on the path towards a destination. The principle behind traceroute is very simple. When a router receives an IP packet whose <cite>Hop Limit</cite> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> it is forced to return to the sending host a <cite>Time exceeded</cite> ICMP message containing the header and the first bytes of the discarded packet. To discover all routers on a network path, a simple solution is to first send a packet whose <cite>Hop Limit</cite> is set to <cite>1</cite>, then a packet whose <cite>Hop Limit</cite> is set to <cite>2</cite>, etc. A sample traceroute6 output is shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">#</span>traceroute6<span class="w"> </span>www.ietf.org
<span class="go">traceroute6 to www.ietf.org (2001:1890:1112:1::20) from 2001:6a8:3080:2:217:f2ff:fed6:65c0, 30 hops max, 12 byte packets</span>
<span class="go"> 1  2001:6a8:3080:2::1  13.821 ms  0.301 ms  0.324 ms</span>
<span class="go"> 2  2001:6a8:3000:8000::1  0.651 ms  0.51 ms  0.495 ms</span>
<span class="go"> 3  10ge.cr2.bruvil.belnet.net  3.402 ms  3.34 ms  3.33 ms</span>
<span class="go"> 4  10ge.cr2.brueve.belnet.net  3.668 ms 10ge.cr2.brueve.belnet.net  3.988 ms 10ge.cr2.brueve.belnet.net  3.699 ms</span>
<span class="go"> 5  belnet.rt1.ams.nl.geant2.net  10.598 ms  7.214 ms  10.082 ms</span>
<span class="go"> 6  so-7-0-0.rt2.cop.dk.geant2.net  20.19 ms  20.002 ms  20.064 ms</span>
<span class="go"> 7  kbn-ipv6-b1.ipv6.telia.net  21.078 ms  20.868 ms  20.864 ms</span>
<span class="go"> 8  s-ipv6-b1-link.ipv6.telia.net  31.312 ms  31.113 ms  31.411 ms</span>
<span class="go"> 9  s-ipv6-b1-link.ipv6.telia.net  61.986 ms  61.988 ms  61.994 ms</span>
<span class="go"> 10  2001:1890:61:8909::1  121.716 ms  121.779 ms  121.177 ms</span>
<span class="go"> 11  2001:1890:61:9117::2  203.709 ms  203.305 ms  203.07 ms</span>
<span class="go"> 12  mail.ietf.org  204.172 ms  203.755 ms  203.748 ms</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rate limitation of ICMP messages</p>
<p>High-end hardware based routers use special purpose chips on their interfaces to forward IPv6 packets at line rate. These chips are optimized to process <cite>correct</cite> IP packets. They are not able to create ICMP messages at line rate. When such a chip receives an IP packet that triggers an ICMP message, it interrupts the main CPU of the router and the software running on this CPU processes the packet. This CPU is much slower than the hardware acceleration found on the interfaces <a class="reference internal" href="../bibliography.html#gill2004" id="id24"><span>[Gill2004]</span></a>. It would be overloaded if it had to process IP packets at line rate and generate one ICMP message for each received packet. To protect this CPU, high-end routers limit the rate at which the hardware can interrupt the main CPU and thus the rate at which ICMP messages can be generated. This implies that not all erroneous IP packets cause the transmission of an ICMP message. The risk of overloading the main CPU of the router is also the reason why using hop-by-hop IPv6 options, including the router alert option is discouraged <a href="#id49"><span class="problematic" id="id25">[#falert]_</span></a>.</p>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fnetmask" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Another way of representing IP subnets is to use netmasks. A netmask is a 32 bits field whose <cite>p</cite> high order bits are set to <cite>1</cite> and the low order bits are set to <cite>0</cite>. The number of high order bits set <cite>1</cite> indicates the length of the subnet identifier. Netmasks are usually represented in the same dotted decimal format as IPv4 addresses. For example <cite>10.0.0.0/8</cite> would be represented as <cite>10.0.0.0 255.0.0.0</cite> while <cite>192.168.1.0/24</cite> would be represented as <cite>192.168.1.0 255.255.255.0</cite>. In some cases, the netmask can be represented in hexadecimal.</p>
</aside>
<aside class="footnote brackets" id="fprotocolnumber" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://www.iana.org/assignments/protocol-numbers/">http://www.iana.org/assignments/protocol-numbers/</a> for the list of all assigned <cite>Protocol</cite> numbers</p>
</aside>
<aside class="footnote brackets" id="fttl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>The initial IP specification in <span class="target" id="index-78"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a> suggested that routers would decrement the <cite>TTL</cite> at least once every second. This would ensure that a packet would never remain for more than <cite>TTL</cite> seconds in the network. However, in practice most router implementations simply chose to decrement the <cite>TTL</cite> by one.</p>
</aside>
<aside class="footnote brackets" id="finitialttl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>The initial TTL value used to send IP packets vary from one implementation to another. Most current IP implementations use an initial TTL of 64 or more. See <a class="reference external" href="http://members.cox.net/~ndav1/self_published/TTL_values.html">http://members.cox.net/~ndav1/self_published/TTL_values.html</a> for additional information.</p>
</aside>
<aside class="footnote brackets" id="f6lowpan" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Supporting IP over the 802.15.4 datalink layer technology requires special mechanisms. See <span class="target" id="index-79"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a> for a discussion of the special problems posed by 802.15.4</p>
</aside>
<aside class="footnote brackets" id="fpingproblems" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span>
<p>Until a few years ago, all hosts replied to <cite>Echo request</cite> ICMP messages. However, due to the security problems that have affected TCP/IP implementations, many of these implementations can now be configured to disable answering <cite>Echo request</cite> ICMP messages.</p>
</aside>
<aside class="footnote brackets" id="ftraceroutemore" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">7</a><span class="fn-bracket">]</span></span>
<p>A detailed analysis of traceroute output is outside the scope of this document. Additional information may be found in <a class="reference internal" href="../bibliography.html#aco-2006" id="id26"><span>[ACO+2006]</span></a> and <a class="reference internal" href="../bibliography.html#dt2007" id="id27"><span>[DT2007]</span></a></p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fmultiiana" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">8</a><span class="fn-bracket">]</span></span>
<p>The full list of allocated IPv6 multicast addresses is available at <a class="reference external" href="http://www.iana.org/assignments/ipv6-multicast-addresses">http://www.iana.org/assignments/ipv6-multicast-addresses</a></p>
</aside>
<aside class="footnote brackets" id="fianaprotocol" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id19">2</a>)</span>
<p>The <a class="reference external" href="https://www.iana.org">IANA</a> maintains the list of all allocated Next Header types at <a class="reference external" href="http://www.iana.org/assignments/protocol-numbers/">http://www.iana.org/assignments/protocol-numbers/</a></p>
</aside>
<aside class="footnote brackets" id="fipv4checksum" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">10</a><span class="fn-bracket">]</span></span>
<p>When IPv4 was designed, the situation was different. The IPv4 header includes a checksum that only covers the network header. This checksum is computed by the source and updated by all intermediate routers that decrement the TTL, which is the IPv4 equivalent of the <cite>HopLimit</cite> used by IPv6.</p>
</aside>
<aside class="footnote brackets" id="fdfflag" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<p>A transport protocol implementation can also specify whether the packet must be sent with the <cite>DF</cite> set or set. A TCP implementation using <cite>Path MTU Discovery</cite> would always request the transmission of IPv4 packets with the <cite>DF</cite> flag set.</p>
</aside>
<aside class="footnote brackets" id="fiddf" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id14">2</a>)</span>
<p>It should be noted that only the packets that can be fragmented (i.e. whose <cite>DF</cite> flag is reset) must have different <cite>Identification</cite> fields. The <cite>Identification</cite> field is not used in the packets having the <cite>DF</cite> flag set.</p>
</aside>
</aside>
</section>
</section>
&#13;

<h2>IP version 4<a class="headerlink" href="#ip-version-4" title="Link to this heading">#</a></h2>
<p>IP version 4 is the data plane protocol of the network layer in the TCP/IP protocol suite. The design of IP version 4 was based on the following assumptions :</p>
<blockquote>
<div><ul class="simple">
<li><p>IP should provide an unreliable connectionless service (TCP provides reliability when required by the application)</p></li>
<li><p>IP operates with the datagram transmission mode</p></li>
<li><p>IP addresses have a fixed size of 32 bits</p></li>
<li><p>IP must be usable above different types of datalink layers</p></li>
<li><p>IP hosts exchange variable length packets</p></li>
</ul>
</div></blockquote>
<p>IPv4 addresses are encoded as a 32 bits field. IPv4 addresses are often represented in <cite>dotted-decimal</cite> format as a sequence of four integers separated by a <cite>dot</cite>. The first integer is the decimal representation of the most significant byte of the 32 bits IPv4 address, … For example,</p>
<blockquote>
<div><ul class="simple">
<li><p>1.2.3.4 corresponds to 00000001000000100000001100000100</p></li>
<li><p>127.0.0.1 corresponds to 01111111000000000000000000000001</p></li>
<li><p>255.255.255.255 corresponds to 11111111111111111111111111111111</p></li>
</ul>
</div></blockquote>
<p id="index-3">An IPv4 address is used to identify an interface on a router or a host. A router has thus as many IPv4 addresses as the number of interfaces that it has in the datalink layer. Most hosts have a single datalink layer interface and thus have a single IPv4 address. However, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface). These hosts are said to be <cite>multihomed</cite>. A multihomed host with two interfaces has thus two IPv4 addresses.</p>
<p>Many Internet hosts are attached to <a class="reference internal" href="../glossary.html#term-Local-Area-Networks"><span class="xref std std-term">Local Area Networks</span></a> (LANs)
such as Wi-Fi or
Ethernet networks. We will describe the operation of these networks in more
details in the second part of the book, but at this stage, the important
point to know about these LANs is that they provide a connectionless datalink
layer service. On a LAN, each device is identified by a unique 48 bits long
address that is called a <a class="reference internal" href="../glossary.html#term-MAC-address"><span class="xref std std-term">MAC address</span></a> (MAC stands for
<a class="reference internal" href="../glossary.html#term-Medium-Access-Control"><span class="xref std std-term">Medium Access Control</span></a> that will be explained in details in the
second part). To ensure the unicity of the MAC addresses, these addresses are
usually hardwired directly on the network interface cards. Each vendor
of network cards ensures that all the interfaces that it sells have a unique
MAC address. The devices attached a LAN can exchanged frames easily.
A <a class="reference internal" href="../glossary.html#term-frame"><span class="xref std std-term">frame</span></a> is a sequence of bytes that starts with a
fixed-length header followed by a payload and for some types of LANs a
trailer. The frame header contains the MAC address of the source of the
frame and the MAC address of the destination of the frame. The frame payload
carries the information exchanged and the trailer can contain a CRC to detect
transmission errors or other types of control information.</p>
<figure class="align-center" id="id31">
<span id="fig-frame-ip"/><img alt="../_images/frame-ip.svg" src="../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/frame-ip.svg"/>
<figcaption>
<p><span class="caption-number">Fig. 109 </span><span class="caption-text">A datalink layer frame containing an IPv4 packet</span><a class="headerlink" href="#id31" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>When several hosts are attached to the same LAN, they can quickly exchange
IP packets by placing these packets inside datalink layer frames. If host
A knows the MAC address of host B, it can send an IP packet as the
payload of a frame whose source MAC address is its own MAC address and
destination MAC address is B’s MAC address. We will detail later how
a host can automatically learn the MAC address of another host.</p>
<p>When a host is attached to a LAN, it can directly send packets to the
other hosts attached to the same LAN. To reach remote hosts, it must
first send its packets to a router, also attached to the LAN. The router
will be able to forward the packet to other routers such that it
reaches its final destination.</p>
<p>When a host attached to a LAN sends an IP packet, it needs to know
whether the destination is attached to the same LAN or not. If the
destination is attached to the same LAN, the host can simply place the
packet inside a frame and us the datalink layer to deliver it directly
to its final destination. Otherwise, the host must the datalink layer
to send the packet inside a frame to the LAN router that will take
care of the packet. IPv4 and IPv6 solve this problem by grouping IP
addresses in subnets. An <a class="reference internal" href="../glossary.html#term-IP-subnet"><span class="xref std std-term">IP subnet</span></a> is the set of all IP addresses
that have the same prefix. It is represented as an IP address followed
by <cite>n</cite>, the number of bits in the common prefix.</p>
<p>An IPv4 address is composed of two parts : a <cite>subnetwork identifier</cite> and  a <cite>host identifier</cite>. The <cite>subnetwork identifier</cite> is composed of the high order bits of the address and the host identifier is encoded in the low order bits of the address. This is illustrated below with a 22 bits subnetwork identifier shown in blue and a 12 bits host identifier in red.</p>
<div class="figure" id="id32" style="text-align: center"><p><img src="../Images/03c5aa7a0fcd0914d2426d59732c3312.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e26dfe934490c67c87b2cd22e9d30684eda459d5.png"/></p>
<p><span class="caption-number">Fig. 110 </span><span class="caption-text">The subnetwork (blue) and host identifiers (red) inside an IPv4 address</span></p>
</div><p>A subnet identifier or IPv4 prefix is usually <a class="footnote-reference brackets" href="#fnetmask" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> represented as <cite>A.B.C.D/p</cite> where <cite>A.B.C.D</cite> is the network address obtained by concatenating the subnet identifier with a host identifier containing only <cite>0</cite> and <cite>p</cite> is the length of the subnet identifier in bits. The table below provides examples of IP subnets.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Subnet</p></th>
<th class="head"><p>Number of
addresses</p></th>
<th class="head"><p>Smallest
address</p></th>
<th class="head"><p>Highest
address</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10.0.0.0/8</p></td>
<td><p>16,777,216</p></td>
<td><p>10.0.0.0</p></td>
<td><p>10.255.255.255</p></td>
</tr>
<tr class="row-odd"><td><p>192.168.0.0/16</p></td>
<td><p>65,536</p></td>
<td><p>192.168.0.0</p></td>
<td><p>192.168.255.255</p></td>
</tr>
<tr class="row-even"><td><p>198.18.0.0/15</p></td>
<td><p>131,072</p></td>
<td><p>198.18.0.0</p></td>
<td><p>198.19.255.255</p></td>
</tr>
<tr class="row-odd"><td><p>192.0.2.0/24</p></td>
<td><p>256</p></td>
<td><p>192.0.2.0</p></td>
<td><p>192.0.2.255</p></td>
</tr>
<tr class="row-even"><td><p>10.0.0.0/30</p></td>
<td><p>4</p></td>
<td><p>10.0.0.0</p></td>
<td><p>10.0.0.3</p></td>
</tr>
<tr class="row-odd"><td><p>10.0.0.0/31</p></td>
<td><p>2</p></td>
<td><p>10.0.0.0</p></td>
<td><p>10.0.0.1</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Class A, B, or C addresses</p>
<blockquote>
<div><p>Today’s IPv4 implementations use <cite>variable-length subnets</cite> defined in <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1519.html"><strong>RFC 1519</strong></a>. With <cite>variable-length</cite> subnets, the subnet identifier can be any size, from <cite>1</cite> to <cite>31</cite> bits. <cite>Variable-length</cite> subnets allow the network operators to use a subnet that better matches the number of hosts that are placed inside the subnet. Before the publication of <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1519.html"><strong>RFC 1519</strong></a>, IPv4 address blocks were divided in classes of addresses. <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a> defined three classes of IPv4 addresses depending on their high order bits:</p>
<blockquote>
<div><ul class="simple">
<li><p>Class A addresses are the addresses whose high order bit is set to zero. The high order byte of this address was the network identifier and the 24 low order bits the host identifier. They correspond to today’s <code class="docutils literal notranslate"><span class="pre">\8</span></code> subnets.</p></li>
<li><p>Class B addresses are the addresses whose two high order bits are set to one followed by zero. The next fourteen bits are the network identifier and the low order sixteen bits the host identifier. They correspond to today’s <code class="docutils literal notranslate"><span class="pre">/16</span></code> subnets.</p></li>
<li><p>Class C addresses are the addresses whose three high order bits are set to one followed by one and then zero. The next fourteen bits are the network identifier and the low order twenty four bits the host identifier. They correspond to today’s <code class="docutils literal notranslate"><span class="pre">/24</span></code> subnets.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p>Initially, address blocks were allocated based on the address class required. Large companies, network providers and some universities asked for a Class A addresses and obtained it. Many universities requested a Class B address. However, this allocation was inefficient as Class A address blocks are much larger than the needs of most enterprises while Class C are too small. <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1519.html"><strong>RFC 1519</strong></a> suppressed this inefficient allocation. Nowadays, the IPv4 addressing space is almost fully utilized, except some reserved blocks. The <a class="reference external" href="https://ipv4.potaroo.net/">IPv4 Address Report</a> provides a detailed report on the evolution of the allocated IPv4 addressing space.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Special IPv4 addresses</p>
<blockquote>
<div><p>Most unicast IPv4 addresses can appear as source and destination addresses in packets on the global Internet. However, it is worth noting that some blocks of IPv4 addresses have a special usage, as described in <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5735.html"><strong>RFC 5735</strong></a>. These include :</p>
</div></blockquote>
<ul class="simple">
<li><p><cite>0.0.0.0/8</cite>, which is reserved for self-identification. A common address in this block is <cite>0.0.0.0</cite>, which is sometimes used when a host boots and does not yet know its IPv4 address.</p></li>
<li><p><cite>127.0.0.0/8</cite>, which is reserved for loopback addresses. Each host implementing IPv4 must have a loopback interface (that is not attached to a datalink layer). By convention, IPv4 address <cite>127.0.0.1</cite> is assigned to this interface. This allows processes running on a host to use TCP/IP to contact other processes running on the same host. This can be very useful for testing purposes.</p></li>
<li><p><cite>10.0.0.0/8</cite>, <cite>172.16.0.0/12</cite> and <cite>192.168.0.0/16</cite> are reserved for private networks that are not directly attached to the Internet. These addresses are often called private addresses or <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1918.html"><strong>RFC 1918</strong></a> addresses.</p></li>
<li><p><cite>169.254.0.0/16</cite> is used for link-local addresses <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3927.html"><strong>RFC 3927</strong></a>. Some hosts use an address in this block when they are connected to a network that does not allocate addresses as expected.</p></li>
</ul>
</div>
<section id="ipv4-packets">
<h3>IPv4 packets<a class="headerlink" href="#ipv4-packets" title="Link to this heading">#</a></h3>
<p>The IPv4 packet format was defined in <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>. It is shown in <a class="reference internal" href="#fig-ipv4-header-detail"><span class="std std-numref">Fig. 111</span></a>. Apart from a few clarifications and some backward compatible changes, the IPv4 packet format did not change significantly since the publication of <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>. All IPv4 packets use the 20 bytes header shown in figure <a class="reference internal" href="#fig-ipv4-header-detail"><span class="std std-numref">Fig. 111</span></a>. Some IPv4 packets contain an optional header extension that is described later.</p>
<figure class="align-center" id="id33">
<span id="fig-ipv4-header-detail"/><a class="reference internal image-reference" href="../_images/ipv4.svg"><img alt="../_images/ipv4.svg" src="../Images/8871e184de5c481e4e3b12210a03c90b.png" style="width: 571.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv4.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 111 </span><span class="caption-text">The IP version 4 header</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The main fields of the IPv4 header are :</p>
<blockquote>
<div><ul class="simple">
<li><p>a 4 bits <cite>version</cite> that indicates the version of IP used to build the header. Using a version field in the header allows the network layer protocol to evolve.</p></li>
<li><p>a 4 bits <cite>IP Header Length (IHL)</cite> that indicates the length of the IP header in 32 bits words. This field allows IPv4 to use options if required, but as it is encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.</p></li>
<li><p>an 8 bits <cite>DS</cite> field that is used for Quality of Service and whose usage is described later.</p></li>
<li><p>an 8 bits <cite>Protocol</cite> field that indicates the transport layer protocol that must process the packet’s payload at the destination. Common values for this field <a class="footnote-reference brackets" href="#fprotocolnumber" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> are <cite>6</cite> for TCP and <cite>17</cite> for UDP</p></li>
<li><p>a 16 bits <cite>length</cite> field that indicates the total length of the entire IPv4 packet (header and payload) in bytes. This implies that an IPv4 packet cannot be longer than 65535 bytes.</p></li>
<li><p>a 32 bits <cite>source address</cite> field that contains the IPv4 address of the source host</p></li>
<li><p>a 32 bits <cite>destination address</cite> field that contains the IPv4 address of the destination host</p></li>
<li><p>a 16 bits <cite>checksum</cite> that protects only the IPv4 header against transmission errors</p></li>
</ul>
</div></blockquote>
<p id="index-13">The other fields of the IPv4 header are used for specific purposes. The first is the 8 bits <cite>Time To Live (TTL)</cite> field. This field is used by IPv4 to avoid the risk of having an IPv4 packet caught in an infinite loop due to a transient or permanent error in routing tables <a class="footnote-reference brackets" href="#fttl" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. We will discuss in part two why such problems can happen. The <cite>TTL</cite> field of the IPv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. Hosts send their IPv4 packets with a positive <cite>TTL</cite> (usually <cite>64</cite> or more <a class="footnote-reference brackets" href="#finitialttl" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>). When a router receives an IPv4 packet, it first decrements the <cite>TTL</cite> by one. If the <cite>TTL</cite> becomes <cite>0</cite>, the packet is discarded and a message is sent back to the packet’s source (see section <a class="reference internal" href="#icmp">ICMP</a>). Otherwise, the router performs a lookup in its forwarding table to forward the packet.</p>
<p id="index-14">A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is used above many very different datalink layers. Each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterized by a maximum frame size. From IP’s point of view, a datalink layer interface is characterized by its <cite>Maximum Transmission Unit (MTU)</cite>. The MTU of an interface is the largest IPv4 packet (including header) that it can send. The table below provides some common MTU sizes <a class="footnote-reference brackets" href="#f6lowpan" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Datalink layer</p></td>
<td><p>MTU</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet</p></td>
<td><p>1500 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>WiFi</p></td>
<td><p>2272 bytes</p></td>
</tr>
<tr class="row-even"><td><p>ATM (AAL5)</p></td>
<td><p>9180 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>802.15.4</p></td>
<td><p>102 or 81 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Token Ring</p></td>
<td><p>4464 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>FDDI</p></td>
<td><p>4352 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink layer technologies that are used today are able to send a 64 KBytes IPv4 packet inside a frame. Consider a client attached to a Token Ring network
that wishes to send packets to a server connected to an Ethernet network. The client could send a 4 KBytes packet that would need to be fragmented inside the network to reach the server.</p>
<p id="index-15">To solve these problems, IPv4 includes a packet fragmentation and reassembly mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if the packet is too long to be sent via the datalink layer. In IPv4, fragmentation is completely performed in the IP layer and a large IPv4 is fragmented into two or more IPv4 packets (called fragments). The IPv4 fragments of a large packet are normal IPv4 packets that are forwarded towards the destination of the large packet by intermediate routers.</p>
<p>The IPv4 fragmentation mechanism relies on four fields of the IPv4 header : <cite>Length</cite>, <cite>Identification</cite>, the <cite>flags</cite> and the <cite>Fragment Offset</cite>. The IPv4 header contains two flags : <cite>More fragments</cite> and <cite>Don’t Fragment (DF)</cite>. When the <cite>DF</cite> flag is set, this indicates that the packet cannot be fragmented.</p>
<p id="index-16">The basic operation of the IPv4 fragmentation is as follows. A large packet is fragmented into two or more fragments. The size of all fragments, except the last one, is equal to the Maximum Transmission Unit of the link used to forward the packet. Each IPv4 packet contains a 16 bits <cite>Identification</cite> field. When a packet is fragmented, the <cite>Identification</cite> of the large packet is copied in all fragments to allow the destination to reassemble the received fragments together. In each fragment, the <cite>Fragment Offset</cite> indicates, in units of 8 bytes, the position of the payload of the fragment in the payload of the original packet. The <cite>Length</cite> field in each fragment indicates the length of the payload of the fragment as in a normal IPv4 packet. Finally, the <cite>More fragments</cite> flag is set only in the last fragment of a large packet.</p>
<p>The following pseudo-code details the IPv4 fragmentation algorithm, assuming that the packet does not contain IP options.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1">#mtu : maximum size of the packet (including header) of outgoing link</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">len</span> <span class="o">&lt;</span>  <span class="n">mtu</span> <span class="p">:</span>
 <span class="n">send</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># packet is too large</span>
<span class="n">maxpayload</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="nb">int</span><span class="p">((</span><span class="n">mtu</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># must be n times 8 bytes</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="o">==</span><span class="s1">'DF'</span> <span class="p">:</span>
 <span class="n">discard</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># packet must be fragmented</span>
<span class="n">payload</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="n">IP</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span>
<span class="n">pos</span><span class="o">=</span><span class="mi">0</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
 <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpayload</span> <span class="p">:</span>
    <span class="n">toSend</span><span class="o">=</span><span class="n">IP</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
              <span class="n">ttl</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">frag</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">frag</span><span class="o">+</span><span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
              <span class="nb">len</span><span class="o">=</span><span class="n">mtu</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxpayload</span><span class="p">]</span>
    <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="o">+</span><span class="n">maxpayload</span>
    <span class="n">payload</span><span class="o">=</span><span class="n">payload</span><span class="p">[</span><span class="n">maxpayload</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
 <span class="k">else</span>
    <span class="n">toSend</span><span class="o">=</span><span class="n">IP</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
              <span class="n">ttl</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">frag</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">frag</span><span class="o">+</span><span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
              <span class="n">flags</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
              <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">proto</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span>
 <span class="n">forward</span><span class="p">(</span><span class="n">toSend</span><span class="p">)</span>
</pre></div>
</div>
<p>The fragments of an IPv4 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. Furthermore, some fragments may be lost and never reach the destination.</p>
<p>The reassembly algorithm used by the destination host is roughly as follows. First, the destination can verify whether a received IPv4 packet is a fragment or not by checking the value of the <cite>More fragments</cite> flag and the <cite>Fragment Offset</cite>. If the <cite>Fragment Offset</cite> is set to <cite>0</cite> and the <cite>More fragments</cite> flag is reset, the received packet has not been fragmented. Otherwise, the packet has been fragmented and must be reassembled. The reassembly algorithm relies on the <cite>Identification</cite> field of the received fragments to associate a fragment with the corresponding packet being reassembled. Furthermore, the <cite>Fragment Offset</cite> field indicates the position of the fragment payload in the original non fragmented packet. Finally, the packet with the <cite>More fragments</cite> flag reset allows the destination to determine the total length of the original no fragmented packet.</p>
<p>Note that the reassembly algorithm must deal with the unreliability of the IP network. This implies that a fragment may be duplicated or a fragment may never reach the destination. The destination can easily detect fragment duplication thanks to the <cite>Fragment Offset</cite>. To deal with fragment losses, the reassembly algorithm must bound the time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. This can be implemented by starting a timer when the first fragment of a packet is received. If the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost.</p>
<p id="index-17">The original IP specification, in <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>, defined several types of options that can be added to the IP header. Each option is encoded using a <cite>type length value</cite> format. They are not widely used today. Additional details may be found in <span class="target" id="index-19"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>.</p>
</section>
&#13;

<h3>IPv4 packets<a class="headerlink" href="#ipv4-packets" title="Link to this heading">#</a></h3>
<p>The IPv4 packet format was defined in <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>. It is shown in <a class="reference internal" href="#fig-ipv4-header-detail"><span class="std std-numref">Fig. 111</span></a>. Apart from a few clarifications and some backward compatible changes, the IPv4 packet format did not change significantly since the publication of <span class="target" id="index-12"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>. All IPv4 packets use the 20 bytes header shown in figure <a class="reference internal" href="#fig-ipv4-header-detail"><span class="std std-numref">Fig. 111</span></a>. Some IPv4 packets contain an optional header extension that is described later.</p>
<figure class="align-center" id="id33">
<span id="fig-ipv4-header-detail"/><a class="reference internal image-reference" href="../_images/ipv4.svg"><img alt="../_images/ipv4.svg" src="../Images/8871e184de5c481e4e3b12210a03c90b.png" style="width: 571.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv4.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 111 </span><span class="caption-text">The IP version 4 header</span><a class="headerlink" href="#id33" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The main fields of the IPv4 header are :</p>
<blockquote>
<div><ul class="simple">
<li><p>a 4 bits <cite>version</cite> that indicates the version of IP used to build the header. Using a version field in the header allows the network layer protocol to evolve.</p></li>
<li><p>a 4 bits <cite>IP Header Length (IHL)</cite> that indicates the length of the IP header in 32 bits words. This field allows IPv4 to use options if required, but as it is encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.</p></li>
<li><p>an 8 bits <cite>DS</cite> field that is used for Quality of Service and whose usage is described later.</p></li>
<li><p>an 8 bits <cite>Protocol</cite> field that indicates the transport layer protocol that must process the packet’s payload at the destination. Common values for this field <a class="footnote-reference brackets" href="#fprotocolnumber" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> are <cite>6</cite> for TCP and <cite>17</cite> for UDP</p></li>
<li><p>a 16 bits <cite>length</cite> field that indicates the total length of the entire IPv4 packet (header and payload) in bytes. This implies that an IPv4 packet cannot be longer than 65535 bytes.</p></li>
<li><p>a 32 bits <cite>source address</cite> field that contains the IPv4 address of the source host</p></li>
<li><p>a 32 bits <cite>destination address</cite> field that contains the IPv4 address of the destination host</p></li>
<li><p>a 16 bits <cite>checksum</cite> that protects only the IPv4 header against transmission errors</p></li>
</ul>
</div></blockquote>
<p id="index-13">The other fields of the IPv4 header are used for specific purposes. The first is the 8 bits <cite>Time To Live (TTL)</cite> field. This field is used by IPv4 to avoid the risk of having an IPv4 packet caught in an infinite loop due to a transient or permanent error in routing tables <a class="footnote-reference brackets" href="#fttl" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. We will discuss in part two why such problems can happen. The <cite>TTL</cite> field of the IPv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. Hosts send their IPv4 packets with a positive <cite>TTL</cite> (usually <cite>64</cite> or more <a class="footnote-reference brackets" href="#finitialttl" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>). When a router receives an IPv4 packet, it first decrements the <cite>TTL</cite> by one. If the <cite>TTL</cite> becomes <cite>0</cite>, the packet is discarded and a message is sent back to the packet’s source (see section <a class="reference internal" href="#icmp">ICMP</a>). Otherwise, the router performs a lookup in its forwarding table to forward the packet.</p>
<p id="index-14">A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is used above many very different datalink layers. Each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterized by a maximum frame size. From IP’s point of view, a datalink layer interface is characterized by its <cite>Maximum Transmission Unit (MTU)</cite>. The MTU of an interface is the largest IPv4 packet (including header) that it can send. The table below provides some common MTU sizes <a class="footnote-reference brackets" href="#f6lowpan" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Datalink layer</p></td>
<td><p>MTU</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet</p></td>
<td><p>1500 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>WiFi</p></td>
<td><p>2272 bytes</p></td>
</tr>
<tr class="row-even"><td><p>ATM (AAL5)</p></td>
<td><p>9180 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>802.15.4</p></td>
<td><p>102 or 81 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Token Ring</p></td>
<td><p>4464 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>FDDI</p></td>
<td><p>4352 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink layer technologies that are used today are able to send a 64 KBytes IPv4 packet inside a frame. Consider a client attached to a Token Ring network
that wishes to send packets to a server connected to an Ethernet network. The client could send a 4 KBytes packet that would need to be fragmented inside the network to reach the server.</p>
<p id="index-15">To solve these problems, IPv4 includes a packet fragmentation and reassembly mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if the packet is too long to be sent via the datalink layer. In IPv4, fragmentation is completely performed in the IP layer and a large IPv4 is fragmented into two or more IPv4 packets (called fragments). The IPv4 fragments of a large packet are normal IPv4 packets that are forwarded towards the destination of the large packet by intermediate routers.</p>
<p>The IPv4 fragmentation mechanism relies on four fields of the IPv4 header : <cite>Length</cite>, <cite>Identification</cite>, the <cite>flags</cite> and the <cite>Fragment Offset</cite>. The IPv4 header contains two flags : <cite>More fragments</cite> and <cite>Don’t Fragment (DF)</cite>. When the <cite>DF</cite> flag is set, this indicates that the packet cannot be fragmented.</p>
<p id="index-16">The basic operation of the IPv4 fragmentation is as follows. A large packet is fragmented into two or more fragments. The size of all fragments, except the last one, is equal to the Maximum Transmission Unit of the link used to forward the packet. Each IPv4 packet contains a 16 bits <cite>Identification</cite> field. When a packet is fragmented, the <cite>Identification</cite> of the large packet is copied in all fragments to allow the destination to reassemble the received fragments together. In each fragment, the <cite>Fragment Offset</cite> indicates, in units of 8 bytes, the position of the payload of the fragment in the payload of the original packet. The <cite>Length</cite> field in each fragment indicates the length of the payload of the fragment as in a normal IPv4 packet. Finally, the <cite>More fragments</cite> flag is set only in the last fragment of a large packet.</p>
<p>The following pseudo-code details the IPv4 fragmentation algorithm, assuming that the packet does not contain IP options.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1">#mtu : maximum size of the packet (including header) of outgoing link</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">len</span> <span class="o">&lt;</span>  <span class="n">mtu</span> <span class="p">:</span>
 <span class="n">send</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># packet is too large</span>
<span class="n">maxpayload</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="nb">int</span><span class="p">((</span><span class="n">mtu</span><span class="o">-</span><span class="mi">20</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># must be n times 8 bytes</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="o">==</span><span class="s1">'DF'</span> <span class="p">:</span>
 <span class="n">discard</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># packet must be fragmented</span>
<span class="n">payload</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="n">IP</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span>
<span class="n">pos</span><span class="o">=</span><span class="mi">0</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
 <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpayload</span> <span class="p">:</span>
    <span class="n">toSend</span><span class="o">=</span><span class="n">IP</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
              <span class="n">ttl</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">frag</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">frag</span><span class="o">+</span><span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
              <span class="nb">len</span><span class="o">=</span><span class="n">mtu</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxpayload</span><span class="p">]</span>
    <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="o">+</span><span class="n">maxpayload</span>
    <span class="n">payload</span><span class="o">=</span><span class="n">payload</span><span class="p">[</span><span class="n">maxpayload</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
 <span class="k">else</span>
    <span class="n">toSend</span><span class="o">=</span><span class="n">IP</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
              <span class="n">ttl</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">ttl</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
              <span class="n">frag</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">frag</span><span class="o">+</span><span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span>
              <span class="n">flags</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
              <span class="nb">len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">proto</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span>
 <span class="n">forward</span><span class="p">(</span><span class="n">toSend</span><span class="p">)</span>
</pre></div>
</div>
<p>The fragments of an IPv4 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. Furthermore, some fragments may be lost and never reach the destination.</p>
<p>The reassembly algorithm used by the destination host is roughly as follows. First, the destination can verify whether a received IPv4 packet is a fragment or not by checking the value of the <cite>More fragments</cite> flag and the <cite>Fragment Offset</cite>. If the <cite>Fragment Offset</cite> is set to <cite>0</cite> and the <cite>More fragments</cite> flag is reset, the received packet has not been fragmented. Otherwise, the packet has been fragmented and must be reassembled. The reassembly algorithm relies on the <cite>Identification</cite> field of the received fragments to associate a fragment with the corresponding packet being reassembled. Furthermore, the <cite>Fragment Offset</cite> field indicates the position of the fragment payload in the original non fragmented packet. Finally, the packet with the <cite>More fragments</cite> flag reset allows the destination to determine the total length of the original no fragmented packet.</p>
<p>Note that the reassembly algorithm must deal with the unreliability of the IP network. This implies that a fragment may be duplicated or a fragment may never reach the destination. The destination can easily detect fragment duplication thanks to the <cite>Fragment Offset</cite>. To deal with fragment losses, the reassembly algorithm must bound the time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. This can be implemented by starting a timer when the first fragment of a packet is received. If the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost.</p>
<p id="index-17">The original IP specification, in <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>, defined several types of options that can be added to the IP header. Each option is encoded using a <cite>type length value</cite> format. They are not widely used today. Additional details may be found in <span class="target" id="index-19"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>.</p>
&#13;

<span id="icmp"/><span id="index-20"/><h2>ICMP version 4<a class="headerlink" href="#icmp-version-4" title="Link to this heading">#</a></h2>
<p>It is sometimes necessary for intermediate routers or the destination host to inform the sender of the packet of a problem that occurred while processing a packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control Message Protocol (ICMP). ICMP is defined in <span class="target" id="index-21"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc792.html"><strong>RFC 792</strong></a>. ICMP messages are carried as the payload of IP packets (the protocol value reserved for ICMP is <cite>1</cite>). <a class="reference internal" href="#fig-icmpv4-header"><span class="std std-numref">Fig. 112</span></a> illustrates the IPv4 header. An ICMP message is composed of an 8 byte header and a variable length payload that usually contains the first bytes of the packet that triggered the transmission of the ICMP message.</p>
<figure class="align-center" id="id34">
<span id="fig-icmpv4-header"/><a class="reference internal image-reference" href="../_images/icmpv4.png"><img alt="../_images/icmpv4.png" src="../Images/c6f49e0d69bec409a194b8b0090a586c.png" style="width: 500.0px; height: 121.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/icmpv4.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 112 </span><span class="caption-text">ICMP version 4 <span class="target" id="index-22"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc792.html"><strong>RFC 792</strong></a></span><a class="headerlink" href="#id34" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In the ICMP header, the <cite>Type</cite> and <cite>Code</cite> fields indicate the type of problem that was detected by the sender of the ICMP message. The <cite>Checksum</cite> protects the entire ICMP message against transmission errors and the <cite>Data</cite> field contains additional information for some ICMP messages.</p>
<p>The main types of ICMP messages are :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Destination unreachable</cite> : a <cite>Destination unreachable</cite> ICMP message is sent when a packet cannot be delivered to its destination due to routing problems. Different types of non reachability are distinguished :</p>
<ul>
<li><p><cite>Network unreachable</cite> : this ICMP message is sent by a router that does not have a route for the subnet containing the destination address of the packet</p></li>
<li><p><cite>Host unreachable</cite> : this ICMP message is sent by a router that is attached to the subnet that contains the destination address of the packet, but this destination address cannot be reached at this time</p></li>
<li><p><cite>Protocol unreachable</cite> : this ICMP message is sent by a destination host that has received a packet, but does not support the transport protocol indicated in the packet’s <cite>Protocol</cite> field</p></li>
<li><p><cite>Port unreachable</cite> : this ICMP message is sent by a destination host that has received a packet destined to a port number, but no server process is bound to this port</p></li>
</ul>
</li>
<li><p><cite>Fragmentation needed</cite> : this ICMP message is sent by a router that receives a packet with the <cite>Don’t Fragment</cite> flag set that is larger than the MTU of the outgoing interface</p></li>
</ul>
</div></blockquote>
<p id="index-23"><em class="manpage">ping(8)</em> is often used by network operators to verify that a given IP address is reachable. Each host is supposed <a class="footnote-reference brackets" href="#fpingproblems" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> to reply with an ICMP <cite>Echo reply</cite> message when its receives an  ICMP <cite>Echo request</cite> message. A sample usage of <em class="manpage">ping(8)</em> is shown below.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>ping 130.104.1.1
PING 130.104.1.1 (130.104.1.1): 56 data bytes
64 bytes from 130.104.1.1: icmp_seq=0 ttl=243 time=19.961 ms
64 bytes from 130.104.1.1: icmp_seq=1 ttl=243 time=22.072 ms
64 bytes from 130.104.1.1: icmp_seq=2 ttl=243 time=23.064 ms
64 bytes from 130.104.1.1: icmp_seq=3 ttl=243 time=20.026 ms
64 bytes from 130.104.1.1: icmp_seq=4 ttl=243 time=25.099 ms
--- 130.104.1.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.961/22.044/25.099/1.938 ms
</pre></div>
</div>
<p id="index-24">Another very useful debugging tool is <em class="manpage">traceroute(8)</em>. The traceroute man page describes this tool as <cite>“print the route packets take to network host”</cite>. traceroute uses the <cite>TTL exceeded</cite> ICMP messages to discover the intermediate routers on the path towards a destination. The principle behind traceroute is very simple. When a router receives an IP packet whose <cite>TTL</cite> is set to <cite>1</cite> it decrements the <cite>TTL</cite> and is forced to return to the sending host a <cite>TTL exceeded</cite> ICMP message containing the header and the first bytes of the discarded IP packet. To discover all routers on a network path, a simple solution is to first send a packet whose <cite>TTL</cite> is set to <cite>1</cite>, then a packet whose <cite>TTL</cite> is set to <cite>2</cite>, etc. A sample traceroute output is shown below.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>traceroute www.ietf.org
traceroute to www.ietf.org (64.170.98.32), 64 hops max, 40 byte packets
 1  CsHalles3.sri.ucl.ac.be (192.168.251.230)  5.376 ms  1.217 ms  1.137 ms
 2  CtHalles.sri.ucl.ac.be (192.168.251.229)  1.444 ms  1.669 ms  1.301 ms
 3  CtPythagore.sri.ucl.ac.be (130.104.254.230)  1.950 ms  4.688 ms  1.319 ms
 4  fe.m20.access.lln.belnet.net (193.191.11.9)  1.578 ms  1.272 ms  1.259 ms
 5  10ge.cr2.brueve.belnet.net (193.191.16.22)  5.461 ms  4.241 ms  4.162 ms
 6  212.3.237.13 (212.3.237.13)  5.347 ms  4.544 ms  4.285 ms
 7  ae-11-11.car1.Brussels1.Level3.net (4.69.136.249)  5.195 ms  4.304 ms  4.329 ms
 8  ae-6-6.ebr1.London1.Level3.net (4.69.136.246)  8.892 ms  8.980 ms  8.830 ms
 9  ae-100-100.ebr2.London1.Level3.net (4.69.141.166)  8.925 ms  8.950 ms  9.006 ms
 10  ae-41-41.ebr1.NewYork1.Level3.net (4.69.137.66)  79.590 ms
     ae-43-43.ebr1.NewYork1.Level3.net (4.69.137.74)  78.140 ms
     ae-42-42.ebr1.NewYork1.Level3.net (4.69.137.70)  77.663 ms
 11  ae-2-2.ebr1.Newark1.Level3.net (4.69.132.98)  78.290 ms  83.765 ms  90.006 ms
 12  ae-14-51.car4.Newark1.Level3.net (4.68.99.8)  78.309 ms  78.257 ms  79.709 ms
 13  ex1-tg2-0.eqnwnj.sbcglobal.net (151.164.89.249)  78.460 ms  78.452 ms  78.292 ms
 14  151.164.95.190 (151.164.95.190)  157.198 ms  160.767 ms  159.898 ms
 15  ded-p10-0.pltn13.sbcglobal.net (151.164.191.243)  161.872 ms  156.996 ms  159.425 ms
 16  AMS-1152322.cust-rtr.swbell.net (75.61.192.10)  158.735 ms  158.485 ms  158.588 ms
 17  mail.ietf.org (64.170.98.32)  158.427 ms  158.502 ms  158.567 ms
</pre></div>
</div>
<p>The above <em class="manpage">traceroute(8)</em> output shows a 17 hops path between a host at UCLouvain and one of the main IETF servers. For each hop, traceroute provides the IPv4 address of the router that sent the ICMP message and the measured round-trip-time between the source and this router. traceroute sends three probes with each <cite>TTL</cite> value. In some cases, such as at the tenth hop above, the ICMP messages may be received from different addresses. This is usually because different packets from the same source have followed different paths <a class="footnote-reference brackets" href="#ftraceroutemore" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> in the network.</p>
<p id="index-25">Another important utilization of ICMP messages is to discover the maximum MTU that can be used to reach a destination without fragmentation. As explained earlier, when an IPv4 router receives a packet that is larger than the MTU of the outgoing link, it must fragment the packet. Unfortunately, fragmentation is a complex operation and routers cannot perform it at line rate <a class="reference internal" href="../bibliography.html#km1995" id="id11"><span>[KM1995]</span></a>. Furthermore, when a TCP segment is transported in an IP packet that is fragmented in the network, the loss of a single fragment forces TCP to retransmit the entire segment (and thus all the fragments). If TCP was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. In addition, IP reassembly causes several challenges at high speed as discussed in <span class="target" id="index-26"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a>. Using IP fragmentation to allow UDP applications to exchange large messages raises several security issues <a class="reference internal" href="../bibliography.html#kps2003" id="id12"><span>[KPS2003]</span></a>.</p>
<p>ICMP, combined with the <cite>Don’t fragment (DF)</cite> IPv4 flag, is used by TCP implementations to discover the largest MTU size that is allowed to reach a destination host without causing network fragmentation. This is the <cite>Path MTU discovery</cite> mechanism defined in <span class="target" id="index-27"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1191.html"><strong>RFC 1191</strong></a>. A TCP implementation that includes <cite>Path MTU discovery</cite> (most do) requests the IPv4 layer to send all segments inside IPv4 packets having the <cite>DF</cite> flag set. This prohibits intermediate routers from fragmenting these packets. If a router needs to forward a packet which cannot be fragmented over a link with a smaller MTU, it returns a <cite>Fragmentation needed</cite> ICMP message to the source, indicating the MTU of its outgoing link. This ICMP message contains in the MTU of the router’s outgoing link in its <cite>Data</cite> field. Upon reception of this ICMP message, the source TCP implementation adjusts its Maximum Segment Size (MSS) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.</p>
<section id="operation-of-ipv4-hosts">
<h3>Operation of IPv4 hosts<a class="headerlink" href="#operation-of-ipv4-hosts" title="Link to this heading">#</a></h3>
<p>At this point of the description of IPv4, it is useful to have a detailed look at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest case is when a host needs to send a segment in an IPv4 packet. The host performs two operations. First, it must decide on which interface the packet will be sent. Second it must create the corresponding IP packet(s).</p>
<p>To simplify the discussion in this section, we ignore the utilization of IPv4 options. This is not a severe limitation as today IPv4 packets rarely contain options. Details about the processing of the IPv4 options may be found in the relevant RFCs, such as <span class="target" id="index-28"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>.</p>
<p>An IPv4 host having <span class="math notranslate nohighlight">\(n\)</span> datalink layer interfaces manages <span class="math notranslate nohighlight">\(n+1\)</span> IPv4 addresses :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>127.0.0.1/32</cite> IPv4 address assigned by convention to its loopback address</p></li>
<li><p>one <cite>A.B.C.D/p</cite> IPv4 address assigned to each of its <span class="math notranslate nohighlight">\(n\)</span> datalink layer interfaces</p></li>
</ul>
</div></blockquote>
<p>Such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identifier assigned to its interfaces. Furthermore, the host usually uses one of its interfaces as the <cite>default</cite> interface when sending packets that are not addressed to a directly connected destination. This is represented by the <cite>default</cite> route : <cite>0.0.0.0/0</cite> that is associated to one interface.</p>
<p>When a transport protocol running on the host requests the transmission of a segment, it usually provides the IPv4 destination address to the IPv4 layer in addition to the segment <a class="footnote-reference brackets" href="#fiddf" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. The IPv4 implementation first performs a longest prefix match with the destination address in its routing table. The lookup returns the identification of the interface that must be used to send the packet. The host can then create the IPv4 packet containing the segment. The source IPv4 address of the packet is the IPv4 address of the host on the interface returned by the longest prefix match. The <cite>Protocol</cite> field of the packet is set to the identification of the local transport protocol which created the segment. The <cite>TTL</cite> field of the packet is set to the default <cite>TTL</cite> used by the host. The host must now choose the packet’s <cite>Identification</cite>. This <cite>Identification</cite> is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. Ideally, a sending host should never send a packet twice with the same <cite>Identification</cite> to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. Unfortunately, with a 16 bits <cite>Identification</cite> field and an expected MSL of 2 minutes, this implies that the maximum bandwidth to a given destination is limited to roughly 286 Mbps. With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps <span class="target" id="index-29"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a> if fragmentation must be possible <a class="footnote-reference brackets" href="#fiddf" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. This is very low and is another reason why hosts are highly encouraged to avoid fragmentation. If; despite all of this, the MTU of the outgoing interface is smaller than the packet’s length, the packet is fragmented. Finally, the packet’s checksum is computed before transmission.</p>
<p>When a host receives an IPv4 packet destined to itself, there are several operations that it must perform. First, it must check the packet’s checksum. If the checksum is incorrect, the packet is discarded. Then, it must check whether the packet has been fragmented. If yes, the packet is passed to the reassembly algorithm described earlier. Otherwise, the packet must be passed to the upper layer. This is done by looking at the <cite>Protocol</cite> field (<cite>6</cite> for TCP, <cite>17</cite> for UDP). If the host does not implement the transport layer protocol corresponding to the received <cite>Protocol</cite> field, it sends a <cite>Protocol unreachable</cite> ICMP message to the sending host. If the received packet contains an ICMP message (<cite>Protocol</cite> field set to <cite>1</cite>), the processing is more complex. An <cite>Echo-request</cite> ICMP message triggers the transmission of an <cite>ICMP Echo-reply</cite> message. The other types of ICMP messages indicate an error that was caused by a previously transmitted packet. These ICMP messages are usually forwarded to the transport protocol that sent the erroneous packet. This can be done by inspecting the contents of the ICMP message that includes the header and the first 64 bits of the erroneous packet. If the IP packet did not contain options, which is the case for most IPv4 packets, the transport protocol can find in the first 32 bits of the transport header the source and destination ports to determine the affected transport flow. This is important for Path MTU discovery for example.</p>
</section>
&#13;

<h3>Operation of IPv4 hosts<a class="headerlink" href="#operation-of-ipv4-hosts" title="Link to this heading">#</a></h3>
<p>At this point of the description of IPv4, it is useful to have a detailed look at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest case is when a host needs to send a segment in an IPv4 packet. The host performs two operations. First, it must decide on which interface the packet will be sent. Second it must create the corresponding IP packet(s).</p>
<p>To simplify the discussion in this section, we ignore the utilization of IPv4 options. This is not a severe limitation as today IPv4 packets rarely contain options. Details about the processing of the IPv4 options may be found in the relevant RFCs, such as <span class="target" id="index-28"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a>.</p>
<p>An IPv4 host having <span class="math notranslate nohighlight">\(n\)</span> datalink layer interfaces manages <span class="math notranslate nohighlight">\(n+1\)</span> IPv4 addresses :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>127.0.0.1/32</cite> IPv4 address assigned by convention to its loopback address</p></li>
<li><p>one <cite>A.B.C.D/p</cite> IPv4 address assigned to each of its <span class="math notranslate nohighlight">\(n\)</span> datalink layer interfaces</p></li>
</ul>
</div></blockquote>
<p>Such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identifier assigned to its interfaces. Furthermore, the host usually uses one of its interfaces as the <cite>default</cite> interface when sending packets that are not addressed to a directly connected destination. This is represented by the <cite>default</cite> route : <cite>0.0.0.0/0</cite> that is associated to one interface.</p>
<p>When a transport protocol running on the host requests the transmission of a segment, it usually provides the IPv4 destination address to the IPv4 layer in addition to the segment <a class="footnote-reference brackets" href="#fiddf" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. The IPv4 implementation first performs a longest prefix match with the destination address in its routing table. The lookup returns the identification of the interface that must be used to send the packet. The host can then create the IPv4 packet containing the segment. The source IPv4 address of the packet is the IPv4 address of the host on the interface returned by the longest prefix match. The <cite>Protocol</cite> field of the packet is set to the identification of the local transport protocol which created the segment. The <cite>TTL</cite> field of the packet is set to the default <cite>TTL</cite> used by the host. The host must now choose the packet’s <cite>Identification</cite>. This <cite>Identification</cite> is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. Ideally, a sending host should never send a packet twice with the same <cite>Identification</cite> to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. Unfortunately, with a 16 bits <cite>Identification</cite> field and an expected MSL of 2 minutes, this implies that the maximum bandwidth to a given destination is limited to roughly 286 Mbps. With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps <span class="target" id="index-29"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a> if fragmentation must be possible <a class="footnote-reference brackets" href="#fiddf" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>. This is very low and is another reason why hosts are highly encouraged to avoid fragmentation. If; despite all of this, the MTU of the outgoing interface is smaller than the packet’s length, the packet is fragmented. Finally, the packet’s checksum is computed before transmission.</p>
<p>When a host receives an IPv4 packet destined to itself, there are several operations that it must perform. First, it must check the packet’s checksum. If the checksum is incorrect, the packet is discarded. Then, it must check whether the packet has been fragmented. If yes, the packet is passed to the reassembly algorithm described earlier. Otherwise, the packet must be passed to the upper layer. This is done by looking at the <cite>Protocol</cite> field (<cite>6</cite> for TCP, <cite>17</cite> for UDP). If the host does not implement the transport layer protocol corresponding to the received <cite>Protocol</cite> field, it sends a <cite>Protocol unreachable</cite> ICMP message to the sending host. If the received packet contains an ICMP message (<cite>Protocol</cite> field set to <cite>1</cite>), the processing is more complex. An <cite>Echo-request</cite> ICMP message triggers the transmission of an <cite>ICMP Echo-reply</cite> message. The other types of ICMP messages indicate an error that was caused by a previously transmitted packet. These ICMP messages are usually forwarded to the transport protocol that sent the erroneous packet. This can be done by inspecting the contents of the ICMP message that includes the header and the first 64 bits of the erroneous packet. If the IP packet did not contain options, which is the case for most IPv4 packets, the transport protocol can find in the first 32 bits of the transport header the source and destination ports to determine the affected transport flow. This is important for Path MTU discovery for example.</p>
&#13;

<h2>IP version 6<a class="headerlink" href="#ip-version-6" title="Link to this heading">#</a></h2>
<p>In the late 1980s and early 1990s the growth of the Internet was causing several operational problems on routers. Many of these routers had a single CPU and up to 1 MByte of RAM to store their operating system, packet buffers and routing tables. Given the rate of allocation of IPv4 prefixes to companies and universities willing to join the Internet, the routing tables where growing very quickly and some feared that all IPv4 prefixes would quickly be allocated. In 1987, a study cited in <span class="target" id="index-30"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1752.html"><strong>RFC 1752</strong></a>, estimated that there would be 100,000 networks in the near future. In August 1990, estimates indicated that the class B space would be exhausted by March 1994.</p>
<p>Two types of solution were developed to solve this problem. The first short term solution was the introduction of Classless Inter Domain Routing (<a class="reference internal" href="../glossary.html#term-CIDR"><span class="xref std std-term">CIDR</span></a>). A second short term solution was the Network Address Translation (<a class="reference internal" href="../glossary.html#term-NAT"><span class="xref std std-term">NAT</span></a>) mechanism, defined in <span class="target" id="index-31"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1631.html"><strong>RFC 1631</strong></a>. NAT allowed multiple hosts to share a single public IPv4 address.</p>
<p>However, in parallel with these short-term solutions, which have allowed the IPv4 Internet to continue to be usable until now, the Internet Engineering Task Force started working on developing a replacement for IPv4. This work started with an open call for proposals, outlined in <span class="target" id="index-32"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1550.html"><strong>RFC 1550</strong></a>. Several groups responded to this call with proposals for a next generation Internet Protocol (IPng) :</p>
<blockquote>
<div><ul class="simple">
<li><p>TUBA proposed in <span class="target" id="index-33"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1347.html"><strong>RFC 1347</strong></a> and <span class="target" id="index-34"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1561.html"><strong>RFC 1561</strong></a></p></li>
<li><p>PIP proposed in <span class="target" id="index-35"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1621.html"><strong>RFC 1621</strong></a></p></li>
<li><p>SIPP proposed in <span class="target" id="index-36"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a></p></li>
</ul>
</div></blockquote>
<p>The IETF decided to pursue the development of IPng based on the SIPP proposal. As IP version <cite>5</cite> was already used by the experimental ST-2 protocol defined in <span class="target" id="index-37"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1819.html"><strong>RFC 1819</strong></a>, the successor of IP version 4 is IP version 6. The initial IP version 6 defined in <span class="target" id="index-38"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1752.html"><strong>RFC 1752</strong></a> was designed based on the following assumptions :</p>
<blockquote>
<div><ul class="simple">
<li><p>IPv6 addresses are encoded as a 128 bits field</p></li>
<li><p>The IPv6 header has a simple format that can easily be parsed by hardware devices</p></li>
<li><p>A host should be able to configure its IPv6 address automatically</p></li>
<li><p>Security must be part of IPv6</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The IPng address size</p>
<p>When the work on IPng started, it was clear that 32 bits was too small to encode an IPng address and all proposals used longer addresses. However, there were many discussions about the most suitable address length. A first approach, proposed by SIPP in <span class="target" id="index-39"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a>, was to use 64 bit addresses. A 64 bits address space was 4 billion times larger than the IPv4 address space and, furthermore, from an implementation perspective, 64 bit CPUs were being considered and 64 bit addresses would naturally fit inside their registers. Another approach was to use an existing address format. This was the TUBA proposal (<span class="target" id="index-40"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1347.html"><strong>RFC 1347</strong></a>) that reuses the ISO CLNP 20 bytes addresses. The 20 bytes addresses provided room for growth, but using ISO CLNP was not favored by the IETF partially due to political reasons, despite the fact that mature CLNP implementations were already available. 128 bits appeared to be a reasonable compromise at that time.</p>
</div>
<section id="ipv6-addressing-architecture">
<h3>IPv6 addressing architecture<a class="headerlink" href="#ipv6-addressing-architecture" title="Link to this heading">#</a></h3>
<p>The experience of IPv4 revealed that the scalability of a network layer protocol heavily depends on its addressing architecture. The designers of IPv6 spent a lot of effort defining its addressing architecture <span class="target" id="index-41"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3513.html"><strong>RFC 3513</strong></a>. All IPv6 addresses are 128 bits wide. This implies that there are <span class="math notranslate nohighlight">\(340,282,366,920,938,463,463,374,607,431,768,211,456 (3.4 \times 10^{38})\)</span> different IPv6 addresses. As the surface of the Earth is about 510,072,000 <span class="math notranslate nohighlight">\(km^2\)</span>, this implies that there are about <span class="math notranslate nohighlight">\(6.67 \times 10^{23}\)</span> IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only 8 addresses per square kilometer, this is a significant improvement on paper.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Textual representation of IPv6 addresses</p>
<blockquote>
<div><blockquote>
<div><p>It is sometimes necessary to write IPv6 addresses in text format, e.g. when manually configuring addresses or for documentation purposes. The preferred format for writing IPv6 addresses is <code class="docutils literal notranslate"><span class="pre">x:x:x:x:x:x:x:x</span></code>, where the <code class="docutils literal notranslate"><span class="pre">x</span></code> ‘s are hexadecimal digits representing the eight 16-bit parts of the address. Here are a few examples of IPv6 addresses :</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abcd:ef01:2345:6789:abcd:ef01:2345:6789</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:8:800:200c:417a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fe80:0:0:0:219:e3ff:fed7:1204</span></code></p></li>
</ul>
</div></blockquote>
<p>IPv6 addresses often contain a long sequence of bits set to <code class="docutils literal notranslate"><span class="pre">0</span></code>. In this case, a compact notation has been defined. With this notation, <cite>::</cite> is used to indicate one or more groups of 16 bits blocks containing only bits set to <cite>0</cite>. For example,</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:8:800:200c:417a</span></code>  is represented as  <code class="docutils literal notranslate"><span class="pre">2001:db8::8:800:200c:417a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ff01:0:0:0:0:0:0:101</span></code>   is represented as <code class="docutils literal notranslate"><span class="pre">ff01::101</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:1</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">::1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:0</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">::</span></code></p></li>
</ul>
</div></blockquote>
<p>An IPv6 prefix can be represented as <cite>address/length</cite>, where <cite>length</cite> is the length of the prefix in bits. For example, the three notations below correspond to the same IPv6 prefix :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8:0000:cd30:0000:0000:0000:0000</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8::cd30:0:0:0:0</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8:0:cd30::</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
</ul>
</div></blockquote>
</div>
<p>IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address is used to identify one datalink-layer interface on a host. If a host has several datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then it needs several IPv6 addresses. In general, an IPv6 unicast address is structured as shown in <a class="reference internal" href="#fig-ipv6-addr-structure"><span class="std std-numref">Fig. 113</span></a>.</p>
<blockquote>
<div><div class="figure" id="id35" style="text-align: center">
<span id="fig-ipv6-addr-structure"/><p><img src="../Images/334d256816526fa56f8d5037c79a8b94.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-4558f8509d6fa81db82cb12abf3e94faa59800ee.png"/></p>
<p><span class="caption-number">Fig. 113 </span><span class="caption-text">Structure of IPv6 unicast addresses</span></p>
</div></div></blockquote>
<p id="index-42">The IETF has reserved some IPv6 addresses for a special usage. The two most important ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:1</span></code> (<code class="docutils literal notranslate"><span class="pre">::1</span></code> in compact form) is the IPv6 loopback address. This is the address of a logical interface that is always up and running on IPv6 enabled hosts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:0</span></code> (<code class="docutils literal notranslate"><span class="pre">::</span></code> in compact form) is the unspecified IPv6 address. This is the IPv6 address that a host can use as source address when trying to acquire an official address.</p></li>
</ul>
</div></blockquote>
<p id="index-43">The last type of unicast IPv6 addresses are the <cite>Link Local Unicast</cite> addresses shown in <a class="reference internal" href="#fig-ipv6-link-local"><span class="std std-numref">Fig. 114</span></a>. These addresses are part of the <cite>fe80::/10</cite> address block and are defined in <span class="target" id="index-44"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a>. Each host can compute its own link local address by concatenating the <cite>fe80::/64</cite> prefix with the 64 bits identifier of its interface. Link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. They are used notably for address discovery and auto-configuration purposes. Their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. Link local addresses have also been defined for IPv4 <span class="target" id="index-45"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3927.html"><strong>RFC 3927</strong></a>. However, the IPv4 link local addresses are only used when a host cannot obtain a regular IPv4 address, e.g. on an isolated LAN.</p>
<blockquote>
<div><div class="figure" id="id36" style="text-align: center">
<span id="fig-ipv6-link-local"/><p><img src="../Images/85809a63cecf02a8a699a08cbd775118.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-597315a4b07b3d8b4bb499f065eef093cf5435d0.png"/></p>
<p><span class="caption-number">Fig. 114 </span><span class="caption-text">IPv6 link local address structure</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All IPv6 hosts have several addresses</p>
<p>An important consequence of the IPv6 unicast addressing architecture and the utilization of link-local addresses is that each IPv6 host has several IPv6 addresses. This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.</p>
</div>
<p>The addresses described above are unicast addresses. These addresses are used to identify (interfaces on) hosts and routers. They can appear as source and destination addresses in the IPv6 packets. When a host sends a packet towards a unicast address, this packet is delivered by the network to its final destination. There are situations, such as when delivering video or television signal to a large number of receivers, where it is useful to have a network that can efficiently deliver the same packet to a large number of receivers. This is the <cite>multicast</cite> service. A multicast service can be provided in a LAN. In this case, a multicast address identifies a set of receivers and each frame sent towards this address is delivered to all receivers in the group. Multicast can also be used in a network containing routers and hosts. In this case, a multicast address identifies also a group of receivers and the network delivers efficiently each multicast packet to all members of the group. Consider for example the network shown in <a class="reference internal" href="#fig-ipv6-simple-network"><span class="std std-numref">Fig. 115</span></a>.</p>
<blockquote>
<div><div class="figure" id="id37" style="text-align: center">
<span id="fig-ipv6-simple-network"/><p><img src="../Images/bae1061d88df9cf3ecd419cee229cdb6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-59beeb7114cd16125dc7dad2d36d93cbd2ab9a96.png"/></p>
<p><span class="caption-number">Fig. 115 </span><span class="caption-text">A simple network with hosts and routers</span></p>
</div></div></blockquote>
<p>Assume that <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code> are part of a multicast group. If <code class="docutils literal notranslate"><span class="pre">A</span></code> sends a multicast packet towards this group, then <code class="docutils literal notranslate"><span class="pre">R1</span></code> will replicate the packet to forward it to <code class="docutils literal notranslate"><span class="pre">R2</span></code> and <code class="docutils literal notranslate"><span class="pre">R3</span></code>. <code class="docutils literal notranslate"><span class="pre">R2</span></code> would forward the packet towards <code class="docutils literal notranslate"><span class="pre">B</span></code>. <code class="docutils literal notranslate"><span class="pre">R3</span></code> would forward the packet towards <code class="docutils literal notranslate"><span class="pre">R4</span></code> that would deliver it to <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<p>Finally, <span class="target" id="index-46"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a> defines the structure of the IPv6 multicast addresses <a class="footnote-reference brackets" href="#fmultiiana" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>. This structure is depicted in <a class="reference internal" href="#fig-ipv6-multicast-addr"><span class="std std-numref">Fig. 116</span></a>.</p>
<blockquote>
<div><div class="figure" id="id38" style="text-align: center">
<span id="fig-ipv6-multicast-addr"/><p><img src="../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2250bbf546a7d3d505096c89409858262a471a9e.png"/></p>
<p><span class="caption-number">Fig. 116 </span><span class="caption-text">IPv6 multicast address structure</span></p>
</div></div></blockquote>
<p>The low order 112 bits of an IPv6 multicast address are the group’s identifier. The high order bits are used as a marker to distinguish multicast addresses from unicast addresses. Notably, the 4-bit <cite>Flags</cite> field indicates whether the address is temporary or permanent. Finally, the <cite>Scope</cite> field indicates the boundaries of the forwarding of packets destined to a particular address. A link-local scope indicates that a router should not forward a packet destined to such a multicast address. An organization local-scope indicates that a packet sent to such a multicast destination address should not leave the organization. Finally the global scope is intended for multicast groups spanning the global Internet.</p>
<p>Among these addresses, some are well known. For example, all hosts automatically belong to the <code class="docutils literal notranslate"><span class="pre">ff02::1</span></code> multicast group while all routers automatically belong to the <code class="docutils literal notranslate"><span class="pre">ff02::2</span></code> multicast group. A detailed discussion of IPv6 multicast is outside the scope of this chapter.</p>
</section>
<section id="ipv6-packet">
<span id="ipv6packet"/><h3>IPv6 packet<a class="headerlink" href="#ipv6-packet" title="Link to this heading">#</a></h3>
<p>The IPv6 packet format was heavily inspired by the packet format proposed for the SIPP protocol in <span class="target" id="index-47"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a>. The standard IPv6 header defined in <span class="target" id="index-48"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> occupies 40 bytes and contains 8 different fields, as shown in <a class="reference internal" href="#fig-ipv6-header-detail"><span class="std std-numref">Fig. 117</span></a>.</p>
<figure class="align-center" id="id39">
<span id="fig-ipv6-header-detail"/><a class="reference internal image-reference" href="../_images/ipv6.svg"><img alt="../_images/ipv6.svg" src="../Images/edbbdd527f59f4dd548e19b2b90f6405.png" style="width: 685.1999999999999px; height: 441.59999999999997px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 117 </span><span class="caption-text">The IP version 6 header (<span class="target" id="index-49"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a>)</span><a class="headerlink" href="#id39" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Apart from the source and destination addresses, the IPv6 header contains the following fields :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Version</cite> : a 4 bits field set to <cite>6</cite> and intended to allow IP to evolve in the future if needed</p></li>
<li><p><cite>Traffic class</cite> : this 8 bits field indicates the type of service expected by this packet and contains the <code class="docutils literal notranslate"><span class="pre">CE</span></code> and <code class="docutils literal notranslate"><span class="pre">ECT</span></code> flags that are used by <cite>Explicit Congestion Notification</cite></p></li>
<li><p><cite>Flow Label</cite> : this field was initially intended to be used to tag packets belonging to the same <cite>flow</cite>. A recent document, <span class="target" id="index-50"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6437.html"><strong>RFC 6437</strong></a> describes some possible usages of this field, but it is too early to tell whether it will be really used.</p></li>
<li><p><cite>Payload Length</cite> : this is the size of the packet payload in bytes. As the length is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of payload.</p></li>
<li><p><cite>Next Header</cite> : this 8-bit field indicates the type <a class="footnote-reference brackets" href="#fianaprotocol" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> of header that follows the IPv6 header. It can be a transport layer header (e.g. <cite>6</cite> for TCP or <cite>17</cite> for UDP) or an IPv6 option.</p></li>
<li><p><cite>Hop Limit</cite> : this 8-bit field indicates the number of routers that can forward the packet. It is decremented by one by each router and prevents packets from looping forever inside the network.</p></li>
</ul>
</div></blockquote>
<p>It is interesting to note that there is no checksum inside the IPv6 header. This is mainly because all datalink layers and transport protocols include a checksum or a CRC to protect their frames/segments against transmission errors. Adding a checksum in the IPv6 header would have forced each router to recompute the checksum of all packets, with limited benefit in detecting errors. In practice, an IP checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. However, this benefit was found to be too small given the reliability of current memories and the cost of computing the checksum on each router <a class="footnote-reference brackets" href="#fipv4checksum" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<p>When a host receives an IPv6 packet, it needs to determine which transport protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is the first role of the <cite>Next header</cite> field. The <a class="reference external" href="https://www.iana.org">IANA</a> which manages the allocation of Internet resources and protocol parameters, maintains an official list of transport protocols <a class="footnote-reference brackets" href="#fianaprotocol" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>. The following protocol numbers are reserved :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TCP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UDP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">17</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCTP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">132</span></code></p></li>
</ul>
</div></blockquote>
<p>For example, an IPv6 packet that contains an TCP segment would appear as shown in <a class="reference internal" href="#fig-ipv6-tcp"><span class="std std-numref">Fig. 118</span></a>.</p>
<figure class="align-default" id="id40">
<span id="fig-ipv6-tcp"/><a class="reference internal image-reference" href="../_images/ipv6-tcp.svg"><img alt="../_images/ipv6-tcp.svg" src="../Images/6b433eadd436f66e88bc838b2d95ab25.png" style="width: 685.1999999999999px; height: 691.1999999999999px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-tcp.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 118 </span><span class="caption-text">An IPv6 packet containing an TCP segment</span><a class="headerlink" href="#id40" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="ipv6options">However, the <cite>Next header</cite> has broader usages than simply indicating the transport protocol which is responsible for the packet payload. An IPv6 packet can contain a chain of headers and the last one indicates the transport protocol that is responsible for the packet payload. Supporting a chain of headers is a clever design from an extensibility viewpoint. As we will see, this chain of headers has several usages.</p>
<p><span class="target" id="index-51"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> defines several types of IPv6 extension headers that could be added to an IPv6 packet :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Hop-by-Hop Options</cite> header. This option is processed by routers and hosts.</p></li>
<li><p><cite>Destination Options</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Routing</cite> header. This option is processed by some nodes.</p></li>
<li><p><cite>Fragment</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Authentication</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Encapsulating Security Payload</cite>. This option is processed only by hosts.</p></li>
</ul>
</div></blockquote>
<p>The last two headers are used to add security above IPv6 and implement IPSec. They are described in <span class="target" id="index-52"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2402.html"><strong>RFC 2402</strong></a> and <span class="target" id="index-53"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2406.html"><strong>RFC 2406</strong></a> and are outside the scope of this document.</p>
<p>The <cite>Hop-by-Hop Options</cite> header was designed to make IPv6 easily extensible. In theory, this option could be used to define new fields that were not foreseen when IPv6 was designed. It is intended to be processed by both routers and hosts.  Deploying an extension to a network protocol can be difficult in practice since some nodes already support the extensions while others still use the old version and do not understand the extension. To deal with this issue, the IPv6 designers opted for a Type-Length-Value encoding of these IPv6 options. The <cite>Hop-by-Hop Options</cite> header is encoded as show in <a class="reference internal" href="#fig-ipv6-hbhoption"><span class="std std-numref">Fig. 119</span></a>.</p>
<figure class="align-default" id="id41">
<span id="fig-ipv6-hbhoption"/><a class="reference internal image-reference" href="../_images/ipv6-hbh.svg"><img alt="../_images/ipv6-hbh.svg" src="../Images/342b609792a5cdad56255af20171a375.png" style="width: 694.8px; height: 172.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-hbh.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 119 </span><span class="caption-text">The IPv6 <cite>Hop-by-Hop Options</cite> header</span><a class="headerlink" href="#id41" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this optional header, the <cite>Next Header</cite> field is used to support the chain of headers. It indicates the type of the next header in the chain. IPv6 headers have different lengths. The <cite>Hdr Ext Len</cite> field indicates the total length of the option header in bytes. The <cite>Opt. Type</cite> field indicates the type of option. These types are encoded such that their high order bits specify how the header needs to be handled by nodes that do not recognize it. The following values are defined for the two high order bits :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">00</span></code> : if a node does not recognize this header, it  can be safely skipped and the processing continues with the subsequent header</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">01</span></code> : if a node does not recognize this header, the packet must be discarded</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10</span></code> (resp. <code class="docutils literal notranslate"><span class="pre">11</span></code>) : if a node does not recognize this header, it must return a control packet (ICMP, see later) back to the source (resp. except if the destination was a multicast address)</p></li>
</ul>
</div></blockquote>
<p>This encoding allows the designers of protocol extensions to specify whether the option must be supported by all nodes on a path or not. Still, deploying such an extension can be difficult in practice.</p>
<p id="index-54">Two <cite>hop-by-hop</cite> options have been defined. <span class="target" id="index-55"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2675.html"><strong>RFC 2675</strong></a> specifies the jumbogram that enables IPv6 to support packets containing a payload larger than 65535 bytes. These jumbo packets have their <cite>payload length</cite> set to <cite>0</cite> and the jumbogram option contains the packet length as a 32 bits field. Such packets can only be sent from a source to a destination if all the routers on the path support this option. However, as of this writing it does not seem that the jumbogram option has been implemented. The router alert option defined in <span class="target" id="index-56"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2711.html"><strong>RFC 2711</strong></a> is the second example of a <cite>hop-by-hop</cite> option. The packets that contain this option should be processed in a special way by intermediate routers. This option is used for IP packets that carry Resource Reservation Protocol (RSVP) messages, but this is outside the scope of this book.</p>
<p>The <cite>Destinations Option</cite> header uses the same format as the <cite>Hop-by-Hop Options</cite> header. It has some usages, e.g. to support mobile nodes <span class="target" id="index-57"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6275.html"><strong>RFC 6275</strong></a>, but these are outside the scope of this document.</p>
<p id="index-58">The <cite>Fragment Options</cite> header is more important. An important problem in the network layer is the ability to handle heterogeneous datalink layers. Most datalink layer technologies can only transmit and receive frames that are shorter than a given maximum frame size. Unfortunately, all datalink layer technologies use different maximum frames sizes.</p>
<p id="index-59">Each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterized by a maximum frame size. From IP’s point of view, a datalink layer interface is characterized by its <cite>Maximum Transmission Unit (MTU)</cite>. The MTU of an interface is the largest packet (including header) that it can send. The table below provides some common MTU sizes.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Datalink layer</p></td>
<td><p>MTU</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet</p></td>
<td><p>1500 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>WiFi</p></td>
<td><p>2272 bytes</p></td>
</tr>
<tr class="row-even"><td><p>ATM (AAL5)</p></td>
<td><p>9180 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>802.15.4</p></td>
<td><p>102 or 81 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Token Ring</p></td>
<td><p>4464 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>FDDI</p></td>
<td><p>4352 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although IPv6 can send 64 KBytes long packets, few datalink layer technologies that are used today are able to send a 64 KBytes packet inside a frame. Furthermore, as illustrated in <a class="reference internal" href="#fig-ipv6-need-fragmentation"><span class="std std-numref">Fig. 120</span></a>, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.</p>
<blockquote>
<div><div class="figure" id="id42" style="text-align: center">
<span id="fig-ipv6-need-fragmentation"/><p><img src="../Images/1baf064048236d27ceffa188e5e44d59.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-afc7ac3182d066f891384914a3f8683b3655b333.png"/></p>
<p><span class="caption-number">Fig. 120 </span><span class="caption-text">The need for fragmentation and reassembly</span></p>
</div></div></blockquote>
<p id="index-60">To solve these problems, IPv6 includes a packet fragmentation and reassembly mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate routers. However, experience with IPv4 has shown that fragmenting packets in routers was costly <a class="reference internal" href="../bibliography.html#km1995" id="id20"><span>[KM1995]</span></a>.  For this reason, the developers of IPv6 have decided that routers would not fragment packets anymore. In IPv6, fragmentation is only performed by the source host. If a source has to send a packet which is larger than the MTU of the outgoing interface, the packet needs to be fragmented before being transmitted. In IPv6, each packet fragment is an IPv6 packet that includes the <cite>Fragmentation</cite> header shown in <a class="reference internal" href="#fig-ipv6-fragment-header"><span class="std std-numref">Fig. 121</span></a>. This header is included by the source in each packet fragment. The receiver uses them to reassemble the received fragments.</p>
<figure class="align-default" id="id43">
<span id="fig-ipv6-fragment-header"/><a class="reference internal image-reference" href="../_images/ipv6-fragment.svg"><img alt="../_images/ipv6-fragment.svg" src="../Images/bf5635c8afb9faf01ffd82e5c9a79010.png" style="width: 685.1999999999999px; height: 96.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-fragment.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 121 </span><span class="caption-text">IPv6 fragmentation header</span><a class="headerlink" href="#id43" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>If a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an ICMPv6 message to inform the sender of the problem. The sender can then either fragment the packet or perform Path MTU discovery. In IPv6, packet fragmentation is performed only by the source by using IPv6 options.</p>
<p>In IPv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. This 64 bits header is composed of six fields :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>Next Header</cite> field that indicates the type of the header that follows the fragmentation header</p></li>
<li><p>two <cite>Reserved</cite> fields set to <cite>0</cite>.</p></li>
<li><p>the <cite>Fragment Offset</cite> is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following this header, relative to the start of the original packet.</p></li>
<li><p>the <cite>More</cite> flag, which is set to <cite>0</cite> in the last fragment of a packet and to <cite>1</cite> in all other fragments.</p></li>
<li><p>the 32-bit <cite>Identification</cite> field indicates to which original packet a fragment belongs. When a host sends fragmented packets, it should ensure that it does not reuse the same <cite>identification</cite> field for packets sent to the same destination during a period of <cite>MSL</cite> seconds. This is easier with the 32 bits <cite>identification</cite> used in the IPv6 fragmentation header, than with the 16 bits <cite>identification</cite> field of the IPv4 header.</p></li>
</ul>
</div></blockquote>
<p>Some IPv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the first fragment. Others send the fragments in reverse order, starting from the last fragment. The latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to reassemble all fragments of the packet upon reception of the last fragment. When a host receives the first fragment of an IPv6 packet, it cannot know a priori the length of the entire IPv6 packet.</p>
<p><a class="reference internal" href="#fig-ipv6-fragmentation-example"><span class="std std-numref">Fig. 122</span></a> provides an example of a fragmented IPv6 packet containing a UDP segment. The <cite>Next Header</cite> type reserved for the IPv6 fragmentation option is 44.</p>
<figure class="align-center" id="id44">
<span id="fig-ipv6-fragmentation-example"/><a class="reference internal image-reference" href="../_images/ipv6-frag-example.png"><img alt="../_images/ipv6-frag-example.png" src="../Images/4d1256f56efdd49bd1e8367b8821cdac.png" style="width: 451.49999999999994px; height: 288.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-frag-example.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 122 </span><span class="caption-text">IPv6 fragmentation example</span><a class="headerlink" href="#id44" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The following pseudo-code details the IPv6 fragmentation, assuming that the packet does not contain options.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># mtu : maximum size of the packet (including header) of outgoing link</span>
<span class="c1"># In Scapy-like notation (see https://github.com/secdev/scapy)</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mtu</span><span class="p">:</span>
    <span class="n">send</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># packet is too large</span>
    <span class="c1"># 40 refers to the size of the IPv6 header</span>
    <span class="n">maxpayload</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="nb">int</span><span class="p">((</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># must be n times 8 bytes</span>
    <span class="c1"># packet must be fragmented</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">IPv6</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">globalCounter</span>
    <span class="n">globalCounter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpayload</span><span class="p">:</span>
            <span class="n">toSend</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">plen</span><span class="o">=</span><span class="n">mtu</span><span class="p">,</span>
                          <span class="n">hlim</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">hlim</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span><span class="o">/</span><span class="n">IPv6ExtHdrFrament</span><span class="p">(</span>
                              <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">nh</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">nh</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxpayload</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">maxpayload</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="n">maxpayload</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The last fragment</span>
            <span class="n">toSend</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">plen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span>
                          <span class="n">hlim</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">hlim</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span><span class="o">/</span><span class="n">IPv6ExtHdrFrament</span><span class="p">(</span>
                              <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">nh</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">nh</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">forward</span><span class="p">(</span><span class="n">toSend</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above pseudocode, we maintain a single 32 bits counter that is incremented for each packet that needs to be fragmented. Other implementations to compute the packet identification are possible. <span class="target" id="index-61"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> only requires that two fragmented packets that are sent within the MSL between the same pair of hosts have different identifications.</p>
<p>The fragments of an IPv6 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. Furthermore, some fragments may be lost and never reach the destination.</p>
<p>The reassembly algorithm used by the destination host is roughly as follows. First, the destination can verify whether a received IPv6 packet is a fragment or not by checking whether it contains a fragment header. If so, all fragments with the some identification must be reassembled together. The reassembly algorithm relies on the <cite>Identification</cite> field of the received fragments to associate a fragment with the corresponding packet being reassembled. Furthermore, the <cite>Fragment Offset</cite> field indicates the position of the fragment payload in the original non-fragmented packet. Finally, the packet with the <cite>M</cite> flag reset allows the destination to determine the total length of the original non-fragmented packet.</p>
<p>Note that the reassembly algorithm must deal with the unreliability of the IP network. This implies that a fragment may be duplicated or a fragment may never reach the destination. The destination can easily detect fragment duplication thanks to the <cite>Fragment Offset</cite>. To deal with fragment losses, the reassembly algorithm must bind the time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. This can be implemented by starting a timer when the first fragment of a packet is received. If the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Header compression on low bandwidth links</p>
<p>Given the size of the IPv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for Voice over IP applications. In such environments, several techniques can be used to reduce the overhead. A first solution is to use data compression in the datalink layer to compress all the information exchanged <a class="reference internal" href="../bibliography.html#thomborson1992" id="id21"><span>[Thomborson1992]</span></a>. These techniques are similar to the data compression algorithms used in tools such as <em class="manpage">compress(1)</em> or <em class="manpage">gzip(1)</em> <span class="target" id="index-62"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1951.html"><strong>RFC 1951</strong></a>. They compress streams of bits without taking advantage of the fact that these streams contain IP packets with a known structure. A second solution is to compress the IP and TCP header. These header compression techniques, such as the one defined in <span class="target" id="index-63"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5795.html"><strong>RFC 5795</strong></a> take advantage of the redundancy found in successive packets from the same flow to significantly reduce the size of the protocol headers. Another solution is to define a compressed encoding of the IPv6 header that matches the capabilities of the underlying datalink layer <span class="target" id="index-64"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a>.</p>
</div>
<p>The last type of <cite>IPv6 header extension</cite> is the <cite>Routing</cite> header. The <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">0</span></code> routing header defined in <span class="target" id="index-65"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> is an example of an IPv6 option that must be processed by some routers. This option is encoded as shown in <a class="reference internal" href="#fig-ipv6-rh0"><span class="std std-numref">Fig. 123</span></a>.</p>
<figure class="align-center" id="id45">
<span id="fig-ipv6-rh0"/><a class="reference internal image-reference" href="../_images/ipv6-routing-0.svg"><img alt="../_images/ipv6-routing-0.svg" src="../Images/276a7739af129da2cd8c3b5ec430d381.png" style="width: 579.0px; height: 592.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-routing-0.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 123 </span><span class="caption-text">The Type 0 routing header (<span class="target" id="index-66"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a>)</span><a class="headerlink" href="#id45" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. Unfortunately, further work with this routing header, including an entertaining demonstration with <a class="reference external" href="https://www.secdev.org/projects/scapy/">scapy</a> <a class="reference internal" href="../bibliography.html#be2007" id="id22"><span>[BE2007]</span></a> , revealed severe security problems with this routing header. For this reason, loose source routing with the type 0 routing header has been removed from the IPv6 specification <span class="target" id="index-67"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5095.html"><strong>RFC 5095</strong></a>.</p>
</section>
<section id="icmp-version-6">
<span id="icmpv6"/><h3>ICMP version 6<a class="headerlink" href="#icmp-version-6" title="Link to this heading">#</a></h3>
<p>It is sometimes necessary for intermediate routers or the destination host to inform the sender of the packet of a problem that occurred while processing a packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control Message Protocol (ICMP). ICMPv6 is defined in <span class="target" id="index-68"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a>. It is used both to report problems that occurred while processing an IPv6 packet, but also to distribute addresses.</p>
<p>ICMPv6 messages are carried inside IPv6 packets (the <cite>Next Header</cite> field for ICMPv6 is <code class="docutils literal notranslate"><span class="pre">58</span></code>). Each ICMP message contains a 32 bits header with an 8 bits <cite>type</cite> field, a <cite>code</cite> field and a 16 bits checksum computed over the entire ICMPv6 message. The message body contains a copy of the IPv6 packet in error. The ICMPv6 header is shown in <a class="reference internal" href="#fig-icmpv6-header"><span class="std std-numref">Fig. 124</span></a>.</p>
<figure class="align-center" id="id46">
<span id="fig-icmpv6-header"/><a class="reference internal image-reference" href="../_images/icmpv6.svg"><img alt="../_images/icmpv6.svg" src="../Images/8440c110b309073d9f6a09bf2e22fccb.png" style="width: 715.1999999999999px; height: 153.6px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/icmpv6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 124 </span><span class="caption-text">ICMP version 6 packet format</span><a class="headerlink" href="#id46" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>ICMPv6 specifies two classes of messages : error messages that indicate a problem in handling a packet and informational messages. Four types of error messages are defined in <span class="target" id="index-69"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a> :</p>
<blockquote>
<div><ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code><span class="classifier"><cite>Destination Unreachable</cite>. Such an ICMPv6 message is sent when the destination address of a packet is unreachable. The <cite>code</cite> field of the ICMP header contains additional information about the type of unreachability. The following codes are specified in <span class="target" id="index-70"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a></span></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> : No route to destination. This indicates that the router that sent the ICMPv6 message did not have a route towards the packet’s destination</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : Communication with destination administratively prohibited. This indicates that a firewall has refused to forward the packet towards its final destination.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : Beyond scope of source address. This message can be sent if the source is using link-local addresses to reach a global unicast address outside its subnet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : Address unreachable. This message indicates that the packet reached the subnet of the destination, but the host that owns this destination address cannot be reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> : Port unreachable. This message indicates that the IPv6 packet was received by the destination, but there was no application listening to the specified port.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : Packet Too Big. The router that was to send the ICMPv6 message received an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message contains the MTU of this link in bytes. This allows the sending host to implement Path MTU discovery <span class="target" id="index-71"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1981.html"><strong>RFC 1981</strong></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : Time Exceeded. This error message can be sent either by a router or by a host. A router would set <cite>code</cite> to <cite>0</cite> to report the reception of a packet whose <cite>Hop Limit</cite> reached <cite>0</cite>. A host would set <cite>code</cite> to <cite>1</cite> to report that it was unable to reassemble received IPv6 fragments.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> : Parameter Problem. This ICMPv6 message is used to report either the reception of an IPv6 packet with an erroneous header field (code <cite>0</cite>) or an unknown <cite>Next Header</cite> or IP option (codes <cite>1</cite> and <cite>2</cite>). In this case, the message body contains the erroneous IPv6 packet and the first 32 bits of the message body contain a pointer to the error.</p></li>
</ul>
</div></blockquote>
<p>The <cite>Destination Unreachable</cite> ICMP error message is returned when a packet cannot be forwarded to its final destination. The first four ICMPv6 error messages (type <code class="docutils literal notranslate"><span class="pre">1</span></code>, codes <code class="docutils literal notranslate"><span class="pre">0-3</span></code>)  are generated by routers while hosts may return code <code class="docutils literal notranslate"><span class="pre">4</span></code> when there is no application bound to the corresponding port number.</p>
<p>The <cite>Packet Too Big</cite> ICMP messages enable the source host to discover the MTU size that it can safely use to reach a given destination. To understand its operation, consider the (academic) scenario shown in <a class="reference internal" href="#fig-ipv6-mtu-discovery"><span class="std std-numref">Fig. 125</span></a>. In this figure, the labels on each link represent the maximum packet size supported by this link.</p>
<blockquote>
<div><div class="figure" id="id47" style="text-align: center">
<span id="fig-ipv6-mtu-discovery"/><p><img src="../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-01f32f8a7fcf88c7a58965b21306ce4ba00c84bf.png"/></p>
<p><span class="caption-number">Fig. 125 </span><span class="caption-text">Example for IPv6 MTU discovery</span></p>
</div></div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> sends a 1500 bytes packet, <code class="docutils literal notranslate"><span class="pre">R1</span></code> will return an ICMPv6 error message indicating a maximum packet length of 1400 bytes. <code class="docutils literal notranslate"><span class="pre">A</span></code> would then fragment the packet before retransmitting it. The small fragment would go through, but the large fragment will be refused by <code class="docutils literal notranslate"><span class="pre">R2</span></code> that would return an ICMPv6 error message. <code class="docutils literal notranslate"><span class="pre">A</span></code> can fragment again the packet and send it to the final destination as two fragments.</p>
<p>In practice, an IPv6 implementation does not store the transmitted packets to be able to retransmit them if needed. However, since TCP (and SCTP) buffer the segments that they transmit, a similar approach can be used in transport protocols to detect the largest MTU on a path towards a given destination. This technique is called PathMTU Discovery <span class="target" id="index-72"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1981.html"><strong>RFC 1981</strong></a>.</p>
<p id="index-73">When a TCP segment is transported in an IP packet that is fragmented in the network, the loss of a single fragment forces TCP to retransmit the entire segment (and thus all the fragments). If TCP was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. In addition, IP reassembly causes several challenges at high speed as discussed in <span class="target" id="index-74"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a>. Using IP fragmentation to allow UDP applications to exchange large messages raises several security issues <a class="reference internal" href="../bibliography.html#kps2003" id="id23"><span>[KPS2003]</span></a>.</p>
<p>ICMPv6 is used by TCP implementations to discover the largest MTU size that is allowed to reach a destination host without causing network fragmentation. A TCP implementation parses the <cite>Packets Too Big</cite> ICMP messages that it receives. These ICMP messages contain the MTU of the router’s outgoing link in their <cite>Data</cite> field. Upon reception of such an ICMP message, the source TCP implementation adjusts its Maximum Segment Size (MSS) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.</p>
<p id="index-75">Two types of informational ICMPv6 messages are defined in <span class="target" id="index-76"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a> : <cite>echo request</cite> and <cite>echo reply</cite>, which are used to test the reachability of a destination by using <em class="manpage">ping6(8)</em>. Each host is supposed to reply with an ICMP <cite>Echo reply</cite> message when it receives an  ICMP <cite>Echo request</cite> message. A sample usage of <em class="manpage">ping6(8)</em> is shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">#</span>ping6<span class="w"> </span>www.ietf.org
<span class="go">PING6(56=40+8+8 bytes) 2001:6a8:3080:2:3403:bbf4:edae:afc3 --&gt; 2001:1890:123a::1:1e</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=0 hlim=49 time=156.905 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=1 hlim=49 time=155.618 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=2 hlim=49 time=155.808 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=3 hlim=49 time=155.325 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=4 hlim=49 time=155.493 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=5 hlim=49 time=155.801 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=6 hlim=49 time=155.660 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=7 hlim=49 time=155.869 ms</span>
<span class="go">^C</span>
<span class="go">--- www.ietf.org ping6 statistics ---</span>
<span class="go">8 packets transmitted, 8 packets received, 0.0% packet loss</span>
<span class="go">round-trip min/avg/max/std-dev = 155.325/155.810/156.905/0.447 ms</span>
</pre></div>
</div>
<p id="index-77">Another very useful debugging tool is <em class="manpage">traceroute6(8)</em>. The traceroute man page describes this tool as <cite>“print the route packets take to network host”</cite>. traceroute uses the <cite>Time exceeded</cite> ICMP messages to discover the intermediate routers on the path towards a destination. The principle behind traceroute is very simple. When a router receives an IP packet whose <cite>Hop Limit</cite> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> it is forced to return to the sending host a <cite>Time exceeded</cite> ICMP message containing the header and the first bytes of the discarded packet. To discover all routers on a network path, a simple solution is to first send a packet whose <cite>Hop Limit</cite> is set to <cite>1</cite>, then a packet whose <cite>Hop Limit</cite> is set to <cite>2</cite>, etc. A sample traceroute6 output is shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">#</span>traceroute6<span class="w"> </span>www.ietf.org
<span class="go">traceroute6 to www.ietf.org (2001:1890:1112:1::20) from 2001:6a8:3080:2:217:f2ff:fed6:65c0, 30 hops max, 12 byte packets</span>
<span class="go"> 1  2001:6a8:3080:2::1  13.821 ms  0.301 ms  0.324 ms</span>
<span class="go"> 2  2001:6a8:3000:8000::1  0.651 ms  0.51 ms  0.495 ms</span>
<span class="go"> 3  10ge.cr2.bruvil.belnet.net  3.402 ms  3.34 ms  3.33 ms</span>
<span class="go"> 4  10ge.cr2.brueve.belnet.net  3.668 ms 10ge.cr2.brueve.belnet.net  3.988 ms 10ge.cr2.brueve.belnet.net  3.699 ms</span>
<span class="go"> 5  belnet.rt1.ams.nl.geant2.net  10.598 ms  7.214 ms  10.082 ms</span>
<span class="go"> 6  so-7-0-0.rt2.cop.dk.geant2.net  20.19 ms  20.002 ms  20.064 ms</span>
<span class="go"> 7  kbn-ipv6-b1.ipv6.telia.net  21.078 ms  20.868 ms  20.864 ms</span>
<span class="go"> 8  s-ipv6-b1-link.ipv6.telia.net  31.312 ms  31.113 ms  31.411 ms</span>
<span class="go"> 9  s-ipv6-b1-link.ipv6.telia.net  61.986 ms  61.988 ms  61.994 ms</span>
<span class="go"> 10  2001:1890:61:8909::1  121.716 ms  121.779 ms  121.177 ms</span>
<span class="go"> 11  2001:1890:61:9117::2  203.709 ms  203.305 ms  203.07 ms</span>
<span class="go"> 12  mail.ietf.org  204.172 ms  203.755 ms  203.748 ms</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rate limitation of ICMP messages</p>
<p>High-end hardware based routers use special purpose chips on their interfaces to forward IPv6 packets at line rate. These chips are optimized to process <cite>correct</cite> IP packets. They are not able to create ICMP messages at line rate. When such a chip receives an IP packet that triggers an ICMP message, it interrupts the main CPU of the router and the software running on this CPU processes the packet. This CPU is much slower than the hardware acceleration found on the interfaces <a class="reference internal" href="../bibliography.html#gill2004" id="id24"><span>[Gill2004]</span></a>. It would be overloaded if it had to process IP packets at line rate and generate one ICMP message for each received packet. To protect this CPU, high-end routers limit the rate at which the hardware can interrupt the main CPU and thus the rate at which ICMP messages can be generated. This implies that not all erroneous IP packets cause the transmission of an ICMP message. The risk of overloading the main CPU of the router is also the reason why using hop-by-hop IPv6 options, including the router alert option is discouraged <a href="#id49"><span class="problematic" id="id25">[#falert]_</span></a>.</p>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fnetmask" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Another way of representing IP subnets is to use netmasks. A netmask is a 32 bits field whose <cite>p</cite> high order bits are set to <cite>1</cite> and the low order bits are set to <cite>0</cite>. The number of high order bits set <cite>1</cite> indicates the length of the subnet identifier. Netmasks are usually represented in the same dotted decimal format as IPv4 addresses. For example <cite>10.0.0.0/8</cite> would be represented as <cite>10.0.0.0 255.0.0.0</cite> while <cite>192.168.1.0/24</cite> would be represented as <cite>192.168.1.0 255.255.255.0</cite>. In some cases, the netmask can be represented in hexadecimal.</p>
</aside>
<aside class="footnote brackets" id="fprotocolnumber" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://www.iana.org/assignments/protocol-numbers/">http://www.iana.org/assignments/protocol-numbers/</a> for the list of all assigned <cite>Protocol</cite> numbers</p>
</aside>
<aside class="footnote brackets" id="fttl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>The initial IP specification in <span class="target" id="index-78"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a> suggested that routers would decrement the <cite>TTL</cite> at least once every second. This would ensure that a packet would never remain for more than <cite>TTL</cite> seconds in the network. However, in practice most router implementations simply chose to decrement the <cite>TTL</cite> by one.</p>
</aside>
<aside class="footnote brackets" id="finitialttl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>The initial TTL value used to send IP packets vary from one implementation to another. Most current IP implementations use an initial TTL of 64 or more. See <a class="reference external" href="http://members.cox.net/~ndav1/self_published/TTL_values.html">http://members.cox.net/~ndav1/self_published/TTL_values.html</a> for additional information.</p>
</aside>
<aside class="footnote brackets" id="f6lowpan" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Supporting IP over the 802.15.4 datalink layer technology requires special mechanisms. See <span class="target" id="index-79"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a> for a discussion of the special problems posed by 802.15.4</p>
</aside>
<aside class="footnote brackets" id="fpingproblems" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span>
<p>Until a few years ago, all hosts replied to <cite>Echo request</cite> ICMP messages. However, due to the security problems that have affected TCP/IP implementations, many of these implementations can now be configured to disable answering <cite>Echo request</cite> ICMP messages.</p>
</aside>
<aside class="footnote brackets" id="ftraceroutemore" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">7</a><span class="fn-bracket">]</span></span>
<p>A detailed analysis of traceroute output is outside the scope of this document. Additional information may be found in <a class="reference internal" href="../bibliography.html#aco-2006" id="id26"><span>[ACO+2006]</span></a> and <a class="reference internal" href="../bibliography.html#dt2007" id="id27"><span>[DT2007]</span></a></p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fmultiiana" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">8</a><span class="fn-bracket">]</span></span>
<p>The full list of allocated IPv6 multicast addresses is available at <a class="reference external" href="http://www.iana.org/assignments/ipv6-multicast-addresses">http://www.iana.org/assignments/ipv6-multicast-addresses</a></p>
</aside>
<aside class="footnote brackets" id="fianaprotocol" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id19">2</a>)</span>
<p>The <a class="reference external" href="https://www.iana.org">IANA</a> maintains the list of all allocated Next Header types at <a class="reference external" href="http://www.iana.org/assignments/protocol-numbers/">http://www.iana.org/assignments/protocol-numbers/</a></p>
</aside>
<aside class="footnote brackets" id="fipv4checksum" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">10</a><span class="fn-bracket">]</span></span>
<p>When IPv4 was designed, the situation was different. The IPv4 header includes a checksum that only covers the network header. This checksum is computed by the source and updated by all intermediate routers that decrement the TTL, which is the IPv4 equivalent of the <cite>HopLimit</cite> used by IPv6.</p>
</aside>
<aside class="footnote brackets" id="fdfflag" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<p>A transport protocol implementation can also specify whether the packet must be sent with the <cite>DF</cite> set or set. A TCP implementation using <cite>Path MTU Discovery</cite> would always request the transmission of IPv4 packets with the <cite>DF</cite> flag set.</p>
</aside>
<aside class="footnote brackets" id="fiddf" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id14">2</a>)</span>
<p>It should be noted that only the packets that can be fragmented (i.e. whose <cite>DF</cite> flag is reset) must have different <cite>Identification</cite> fields. The <cite>Identification</cite> field is not used in the packets having the <cite>DF</cite> flag set.</p>
</aside>
</aside>
</section>
&#13;

<h3>IPv6 addressing architecture<a class="headerlink" href="#ipv6-addressing-architecture" title="Link to this heading">#</a></h3>
<p>The experience of IPv4 revealed that the scalability of a network layer protocol heavily depends on its addressing architecture. The designers of IPv6 spent a lot of effort defining its addressing architecture <span class="target" id="index-41"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3513.html"><strong>RFC 3513</strong></a>. All IPv6 addresses are 128 bits wide. This implies that there are <span class="math notranslate nohighlight">\(340,282,366,920,938,463,463,374,607,431,768,211,456 (3.4 \times 10^{38})\)</span> different IPv6 addresses. As the surface of the Earth is about 510,072,000 <span class="math notranslate nohighlight">\(km^2\)</span>, this implies that there are about <span class="math notranslate nohighlight">\(6.67 \times 10^{23}\)</span> IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only 8 addresses per square kilometer, this is a significant improvement on paper.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Textual representation of IPv6 addresses</p>
<blockquote>
<div><blockquote>
<div><p>It is sometimes necessary to write IPv6 addresses in text format, e.g. when manually configuring addresses or for documentation purposes. The preferred format for writing IPv6 addresses is <code class="docutils literal notranslate"><span class="pre">x:x:x:x:x:x:x:x</span></code>, where the <code class="docutils literal notranslate"><span class="pre">x</span></code> ‘s are hexadecimal digits representing the eight 16-bit parts of the address. Here are a few examples of IPv6 addresses :</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abcd:ef01:2345:6789:abcd:ef01:2345:6789</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:8:800:200c:417a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fe80:0:0:0:219:e3ff:fed7:1204</span></code></p></li>
</ul>
</div></blockquote>
<p>IPv6 addresses often contain a long sequence of bits set to <code class="docutils literal notranslate"><span class="pre">0</span></code>. In this case, a compact notation has been defined. With this notation, <cite>::</cite> is used to indicate one or more groups of 16 bits blocks containing only bits set to <cite>0</cite>. For example,</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2001:db8:0:0:8:800:200c:417a</span></code>  is represented as  <code class="docutils literal notranslate"><span class="pre">2001:db8::8:800:200c:417a</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ff01:0:0:0:0:0:0:101</span></code>   is represented as <code class="docutils literal notranslate"><span class="pre">ff01::101</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:1</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">::1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:0</span></code> is represented as <code class="docutils literal notranslate"><span class="pre">::</span></code></p></li>
</ul>
</div></blockquote>
<p>An IPv6 prefix can be represented as <cite>address/length</cite>, where <cite>length</cite> is the length of the prefix in bits. For example, the three notations below correspond to the same IPv6 prefix :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8:0000:cd30:0000:0000:0000:0000</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8::cd30:0:0:0:0</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2001:0db8:0:cd30::</span></code> / <code class="docutils literal notranslate"><span class="pre">60</span></code></p></li>
</ul>
</div></blockquote>
</div>
<p>IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address is used to identify one datalink-layer interface on a host. If a host has several datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then it needs several IPv6 addresses. In general, an IPv6 unicast address is structured as shown in <a class="reference internal" href="#fig-ipv6-addr-structure"><span class="std std-numref">Fig. 113</span></a>.</p>
<blockquote>
<div><div class="figure" id="id35" style="text-align: center">
<span id="fig-ipv6-addr-structure"/><p><img src="../Images/334d256816526fa56f8d5037c79a8b94.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-4558f8509d6fa81db82cb12abf3e94faa59800ee.png"/></p>
<p><span class="caption-number">Fig. 113 </span><span class="caption-text">Structure of IPv6 unicast addresses</span></p>
</div></div></blockquote>
<p id="index-42">The IETF has reserved some IPv6 addresses for a special usage. The two most important ones are :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:1</span></code> (<code class="docutils literal notranslate"><span class="pre">::1</span></code> in compact form) is the IPv6 loopback address. This is the address of a logical interface that is always up and running on IPv6 enabled hosts.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0:0:0:0:0:0:0:0</span></code> (<code class="docutils literal notranslate"><span class="pre">::</span></code> in compact form) is the unspecified IPv6 address. This is the IPv6 address that a host can use as source address when trying to acquire an official address.</p></li>
</ul>
</div></blockquote>
<p id="index-43">The last type of unicast IPv6 addresses are the <cite>Link Local Unicast</cite> addresses shown in <a class="reference internal" href="#fig-ipv6-link-local"><span class="std std-numref">Fig. 114</span></a>. These addresses are part of the <cite>fe80::/10</cite> address block and are defined in <span class="target" id="index-44"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a>. Each host can compute its own link local address by concatenating the <cite>fe80::/64</cite> prefix with the 64 bits identifier of its interface. Link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. They are used notably for address discovery and auto-configuration purposes. Their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. Link local addresses have also been defined for IPv4 <span class="target" id="index-45"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3927.html"><strong>RFC 3927</strong></a>. However, the IPv4 link local addresses are only used when a host cannot obtain a regular IPv4 address, e.g. on an isolated LAN.</p>
<blockquote>
<div><div class="figure" id="id36" style="text-align: center">
<span id="fig-ipv6-link-local"/><p><img src="../Images/85809a63cecf02a8a699a08cbd775118.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-597315a4b07b3d8b4bb499f065eef093cf5435d0.png"/></p>
<p><span class="caption-number">Fig. 114 </span><span class="caption-text">IPv6 link local address structure</span></p>
</div></div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All IPv6 hosts have several addresses</p>
<p>An important consequence of the IPv6 unicast addressing architecture and the utilization of link-local addresses is that each IPv6 host has several IPv6 addresses. This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.</p>
</div>
<p>The addresses described above are unicast addresses. These addresses are used to identify (interfaces on) hosts and routers. They can appear as source and destination addresses in the IPv6 packets. When a host sends a packet towards a unicast address, this packet is delivered by the network to its final destination. There are situations, such as when delivering video or television signal to a large number of receivers, where it is useful to have a network that can efficiently deliver the same packet to a large number of receivers. This is the <cite>multicast</cite> service. A multicast service can be provided in a LAN. In this case, a multicast address identifies a set of receivers and each frame sent towards this address is delivered to all receivers in the group. Multicast can also be used in a network containing routers and hosts. In this case, a multicast address identifies also a group of receivers and the network delivers efficiently each multicast packet to all members of the group. Consider for example the network shown in <a class="reference internal" href="#fig-ipv6-simple-network"><span class="std std-numref">Fig. 115</span></a>.</p>
<blockquote>
<div><div class="figure" id="id37" style="text-align: center">
<span id="fig-ipv6-simple-network"/><p><img src="../Images/bae1061d88df9cf3ecd419cee229cdb6.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-59beeb7114cd16125dc7dad2d36d93cbd2ab9a96.png"/></p>
<p><span class="caption-number">Fig. 115 </span><span class="caption-text">A simple network with hosts and routers</span></p>
</div></div></blockquote>
<p>Assume that <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code> are part of a multicast group. If <code class="docutils literal notranslate"><span class="pre">A</span></code> sends a multicast packet towards this group, then <code class="docutils literal notranslate"><span class="pre">R1</span></code> will replicate the packet to forward it to <code class="docutils literal notranslate"><span class="pre">R2</span></code> and <code class="docutils literal notranslate"><span class="pre">R3</span></code>. <code class="docutils literal notranslate"><span class="pre">R2</span></code> would forward the packet towards <code class="docutils literal notranslate"><span class="pre">B</span></code>. <code class="docutils literal notranslate"><span class="pre">R3</span></code> would forward the packet towards <code class="docutils literal notranslate"><span class="pre">R4</span></code> that would deliver it to <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
<p>Finally, <span class="target" id="index-46"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4291.html"><strong>RFC 4291</strong></a> defines the structure of the IPv6 multicast addresses <a class="footnote-reference brackets" href="#fmultiiana" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>. This structure is depicted in <a class="reference internal" href="#fig-ipv6-multicast-addr"><span class="std std-numref">Fig. 116</span></a>.</p>
<blockquote>
<div><div class="figure" id="id38" style="text-align: center">
<span id="fig-ipv6-multicast-addr"/><p><img src="../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-2250bbf546a7d3d505096c89409858262a471a9e.png"/></p>
<p><span class="caption-number">Fig. 116 </span><span class="caption-text">IPv6 multicast address structure</span></p>
</div></div></blockquote>
<p>The low order 112 bits of an IPv6 multicast address are the group’s identifier. The high order bits are used as a marker to distinguish multicast addresses from unicast addresses. Notably, the 4-bit <cite>Flags</cite> field indicates whether the address is temporary or permanent. Finally, the <cite>Scope</cite> field indicates the boundaries of the forwarding of packets destined to a particular address. A link-local scope indicates that a router should not forward a packet destined to such a multicast address. An organization local-scope indicates that a packet sent to such a multicast destination address should not leave the organization. Finally the global scope is intended for multicast groups spanning the global Internet.</p>
<p>Among these addresses, some are well known. For example, all hosts automatically belong to the <code class="docutils literal notranslate"><span class="pre">ff02::1</span></code> multicast group while all routers automatically belong to the <code class="docutils literal notranslate"><span class="pre">ff02::2</span></code> multicast group. A detailed discussion of IPv6 multicast is outside the scope of this chapter.</p>
&#13;

<span id="ipv6packet"/><h3>IPv6 packet<a class="headerlink" href="#ipv6-packet" title="Link to this heading">#</a></h3>
<p>The IPv6 packet format was heavily inspired by the packet format proposed for the SIPP protocol in <span class="target" id="index-47"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1710.html"><strong>RFC 1710</strong></a>. The standard IPv6 header defined in <span class="target" id="index-48"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> occupies 40 bytes and contains 8 different fields, as shown in <a class="reference internal" href="#fig-ipv6-header-detail"><span class="std std-numref">Fig. 117</span></a>.</p>
<figure class="align-center" id="id39">
<span id="fig-ipv6-header-detail"/><a class="reference internal image-reference" href="../_images/ipv6.svg"><img alt="../_images/ipv6.svg" src="../Images/edbbdd527f59f4dd548e19b2b90f6405.png" style="width: 685.1999999999999px; height: 441.59999999999997px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 117 </span><span class="caption-text">The IP version 6 header (<span class="target" id="index-49"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a>)</span><a class="headerlink" href="#id39" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Apart from the source and destination addresses, the IPv6 header contains the following fields :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Version</cite> : a 4 bits field set to <cite>6</cite> and intended to allow IP to evolve in the future if needed</p></li>
<li><p><cite>Traffic class</cite> : this 8 bits field indicates the type of service expected by this packet and contains the <code class="docutils literal notranslate"><span class="pre">CE</span></code> and <code class="docutils literal notranslate"><span class="pre">ECT</span></code> flags that are used by <cite>Explicit Congestion Notification</cite></p></li>
<li><p><cite>Flow Label</cite> : this field was initially intended to be used to tag packets belonging to the same <cite>flow</cite>. A recent document, <span class="target" id="index-50"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6437.html"><strong>RFC 6437</strong></a> describes some possible usages of this field, but it is too early to tell whether it will be really used.</p></li>
<li><p><cite>Payload Length</cite> : this is the size of the packet payload in bytes. As the length is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of payload.</p></li>
<li><p><cite>Next Header</cite> : this 8-bit field indicates the type <a class="footnote-reference brackets" href="#fianaprotocol" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> of header that follows the IPv6 header. It can be a transport layer header (e.g. <cite>6</cite> for TCP or <cite>17</cite> for UDP) or an IPv6 option.</p></li>
<li><p><cite>Hop Limit</cite> : this 8-bit field indicates the number of routers that can forward the packet. It is decremented by one by each router and prevents packets from looping forever inside the network.</p></li>
</ul>
</div></blockquote>
<p>It is interesting to note that there is no checksum inside the IPv6 header. This is mainly because all datalink layers and transport protocols include a checksum or a CRC to protect their frames/segments against transmission errors. Adding a checksum in the IPv6 header would have forced each router to recompute the checksum of all packets, with limited benefit in detecting errors. In practice, an IP checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. However, this benefit was found to be too small given the reliability of current memories and the cost of computing the checksum on each router <a class="footnote-reference brackets" href="#fipv4checksum" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<p>When a host receives an IPv6 packet, it needs to determine which transport protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is the first role of the <cite>Next header</cite> field. The <a class="reference external" href="https://www.iana.org">IANA</a> which manages the allocation of Internet resources and protocol parameters, maintains an official list of transport protocols <a class="footnote-reference brackets" href="#fianaprotocol" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>. The following protocol numbers are reserved :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">TCP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UDP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">17</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCTP</span></code> uses <cite>Next Header</cite> number <code class="docutils literal notranslate"><span class="pre">132</span></code></p></li>
</ul>
</div></blockquote>
<p>For example, an IPv6 packet that contains an TCP segment would appear as shown in <a class="reference internal" href="#fig-ipv6-tcp"><span class="std std-numref">Fig. 118</span></a>.</p>
<figure class="align-default" id="id40">
<span id="fig-ipv6-tcp"/><a class="reference internal image-reference" href="../_images/ipv6-tcp.svg"><img alt="../_images/ipv6-tcp.svg" src="../Images/6b433eadd436f66e88bc838b2d95ab25.png" style="width: 685.1999999999999px; height: 691.1999999999999px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-tcp.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 118 </span><span class="caption-text">An IPv6 packet containing an TCP segment</span><a class="headerlink" href="#id40" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="ipv6options">However, the <cite>Next header</cite> has broader usages than simply indicating the transport protocol which is responsible for the packet payload. An IPv6 packet can contain a chain of headers and the last one indicates the transport protocol that is responsible for the packet payload. Supporting a chain of headers is a clever design from an extensibility viewpoint. As we will see, this chain of headers has several usages.</p>
<p><span class="target" id="index-51"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> defines several types of IPv6 extension headers that could be added to an IPv6 packet :</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>Hop-by-Hop Options</cite> header. This option is processed by routers and hosts.</p></li>
<li><p><cite>Destination Options</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Routing</cite> header. This option is processed by some nodes.</p></li>
<li><p><cite>Fragment</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Authentication</cite> header. This option is processed only by hosts.</p></li>
<li><p><cite>Encapsulating Security Payload</cite>. This option is processed only by hosts.</p></li>
</ul>
</div></blockquote>
<p>The last two headers are used to add security above IPv6 and implement IPSec. They are described in <span class="target" id="index-52"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2402.html"><strong>RFC 2402</strong></a> and <span class="target" id="index-53"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2406.html"><strong>RFC 2406</strong></a> and are outside the scope of this document.</p>
<p>The <cite>Hop-by-Hop Options</cite> header was designed to make IPv6 easily extensible. In theory, this option could be used to define new fields that were not foreseen when IPv6 was designed. It is intended to be processed by both routers and hosts.  Deploying an extension to a network protocol can be difficult in practice since some nodes already support the extensions while others still use the old version and do not understand the extension. To deal with this issue, the IPv6 designers opted for a Type-Length-Value encoding of these IPv6 options. The <cite>Hop-by-Hop Options</cite> header is encoded as show in <a class="reference internal" href="#fig-ipv6-hbhoption"><span class="std std-numref">Fig. 119</span></a>.</p>
<figure class="align-default" id="id41">
<span id="fig-ipv6-hbhoption"/><a class="reference internal image-reference" href="../_images/ipv6-hbh.svg"><img alt="../_images/ipv6-hbh.svg" src="../Images/342b609792a5cdad56255af20171a375.png" style="width: 694.8px; height: 172.79999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-hbh.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 119 </span><span class="caption-text">The IPv6 <cite>Hop-by-Hop Options</cite> header</span><a class="headerlink" href="#id41" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this optional header, the <cite>Next Header</cite> field is used to support the chain of headers. It indicates the type of the next header in the chain. IPv6 headers have different lengths. The <cite>Hdr Ext Len</cite> field indicates the total length of the option header in bytes. The <cite>Opt. Type</cite> field indicates the type of option. These types are encoded such that their high order bits specify how the header needs to be handled by nodes that do not recognize it. The following values are defined for the two high order bits :</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">00</span></code> : if a node does not recognize this header, it  can be safely skipped and the processing continues with the subsequent header</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">01</span></code> : if a node does not recognize this header, the packet must be discarded</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">10</span></code> (resp. <code class="docutils literal notranslate"><span class="pre">11</span></code>) : if a node does not recognize this header, it must return a control packet (ICMP, see later) back to the source (resp. except if the destination was a multicast address)</p></li>
</ul>
</div></blockquote>
<p>This encoding allows the designers of protocol extensions to specify whether the option must be supported by all nodes on a path or not. Still, deploying such an extension can be difficult in practice.</p>
<p id="index-54">Two <cite>hop-by-hop</cite> options have been defined. <span class="target" id="index-55"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2675.html"><strong>RFC 2675</strong></a> specifies the jumbogram that enables IPv6 to support packets containing a payload larger than 65535 bytes. These jumbo packets have their <cite>payload length</cite> set to <cite>0</cite> and the jumbogram option contains the packet length as a 32 bits field. Such packets can only be sent from a source to a destination if all the routers on the path support this option. However, as of this writing it does not seem that the jumbogram option has been implemented. The router alert option defined in <span class="target" id="index-56"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2711.html"><strong>RFC 2711</strong></a> is the second example of a <cite>hop-by-hop</cite> option. The packets that contain this option should be processed in a special way by intermediate routers. This option is used for IP packets that carry Resource Reservation Protocol (RSVP) messages, but this is outside the scope of this book.</p>
<p>The <cite>Destinations Option</cite> header uses the same format as the <cite>Hop-by-Hop Options</cite> header. It has some usages, e.g. to support mobile nodes <span class="target" id="index-57"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6275.html"><strong>RFC 6275</strong></a>, but these are outside the scope of this document.</p>
<p id="index-58">The <cite>Fragment Options</cite> header is more important. An important problem in the network layer is the ability to handle heterogeneous datalink layers. Most datalink layer technologies can only transmit and receive frames that are shorter than a given maximum frame size. Unfortunately, all datalink layer technologies use different maximum frames sizes.</p>
<p id="index-59">Each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterized by a maximum frame size. From IP’s point of view, a datalink layer interface is characterized by its <cite>Maximum Transmission Unit (MTU)</cite>. The MTU of an interface is the largest packet (including header) that it can send. The table below provides some common MTU sizes.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Datalink layer</p></td>
<td><p>MTU</p></td>
</tr>
<tr class="row-even"><td><p>Ethernet</p></td>
<td><p>1500 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>WiFi</p></td>
<td><p>2272 bytes</p></td>
</tr>
<tr class="row-even"><td><p>ATM (AAL5)</p></td>
<td><p>9180 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>802.15.4</p></td>
<td><p>102 or 81 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Token Ring</p></td>
<td><p>4464 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>FDDI</p></td>
<td><p>4352 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<p>Although IPv6 can send 64 KBytes long packets, few datalink layer technologies that are used today are able to send a 64 KBytes packet inside a frame. Furthermore, as illustrated in <a class="reference internal" href="#fig-ipv6-need-fragmentation"><span class="std std-numref">Fig. 120</span></a>, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.</p>
<blockquote>
<div><div class="figure" id="id42" style="text-align: center">
<span id="fig-ipv6-need-fragmentation"/><p><img src="../Images/1baf064048236d27ceffa188e5e44d59.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-afc7ac3182d066f891384914a3f8683b3655b333.png"/></p>
<p><span class="caption-number">Fig. 120 </span><span class="caption-text">The need for fragmentation and reassembly</span></p>
</div></div></blockquote>
<p id="index-60">To solve these problems, IPv6 includes a packet fragmentation and reassembly mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate routers. However, experience with IPv4 has shown that fragmenting packets in routers was costly <a class="reference internal" href="../bibliography.html#km1995" id="id20"><span>[KM1995]</span></a>.  For this reason, the developers of IPv6 have decided that routers would not fragment packets anymore. In IPv6, fragmentation is only performed by the source host. If a source has to send a packet which is larger than the MTU of the outgoing interface, the packet needs to be fragmented before being transmitted. In IPv6, each packet fragment is an IPv6 packet that includes the <cite>Fragmentation</cite> header shown in <a class="reference internal" href="#fig-ipv6-fragment-header"><span class="std std-numref">Fig. 121</span></a>. This header is included by the source in each packet fragment. The receiver uses them to reassemble the received fragments.</p>
<figure class="align-default" id="id43">
<span id="fig-ipv6-fragment-header"/><a class="reference internal image-reference" href="../_images/ipv6-fragment.svg"><img alt="../_images/ipv6-fragment.svg" src="../Images/bf5635c8afb9faf01ffd82e5c9a79010.png" style="width: 685.1999999999999px; height: 96.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-fragment.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 121 </span><span class="caption-text">IPv6 fragmentation header</span><a class="headerlink" href="#id43" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>If a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an ICMPv6 message to inform the sender of the problem. The sender can then either fragment the packet or perform Path MTU discovery. In IPv6, packet fragmentation is performed only by the source by using IPv6 options.</p>
<p>In IPv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. This 64 bits header is composed of six fields :</p>
<blockquote>
<div><ul class="simple">
<li><p>a <cite>Next Header</cite> field that indicates the type of the header that follows the fragmentation header</p></li>
<li><p>two <cite>Reserved</cite> fields set to <cite>0</cite>.</p></li>
<li><p>the <cite>Fragment Offset</cite> is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following this header, relative to the start of the original packet.</p></li>
<li><p>the <cite>More</cite> flag, which is set to <cite>0</cite> in the last fragment of a packet and to <cite>1</cite> in all other fragments.</p></li>
<li><p>the 32-bit <cite>Identification</cite> field indicates to which original packet a fragment belongs. When a host sends fragmented packets, it should ensure that it does not reuse the same <cite>identification</cite> field for packets sent to the same destination during a period of <cite>MSL</cite> seconds. This is easier with the 32 bits <cite>identification</cite> used in the IPv6 fragmentation header, than with the 16 bits <cite>identification</cite> field of the IPv4 header.</p></li>
</ul>
</div></blockquote>
<p>Some IPv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the first fragment. Others send the fragments in reverse order, starting from the last fragment. The latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to reassemble all fragments of the packet upon reception of the last fragment. When a host receives the first fragment of an IPv6 packet, it cannot know a priori the length of the entire IPv6 packet.</p>
<p><a class="reference internal" href="#fig-ipv6-fragmentation-example"><span class="std std-numref">Fig. 122</span></a> provides an example of a fragmented IPv6 packet containing a UDP segment. The <cite>Next Header</cite> type reserved for the IPv6 fragmentation option is 44.</p>
<figure class="align-center" id="id44">
<span id="fig-ipv6-fragmentation-example"/><a class="reference internal image-reference" href="../_images/ipv6-frag-example.png"><img alt="../_images/ipv6-frag-example.png" src="../Images/4d1256f56efdd49bd1e8367b8821cdac.png" style="width: 451.49999999999994px; height: 288.4px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-frag-example.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 122 </span><span class="caption-text">IPv6 fragmentation example</span><a class="headerlink" href="#id44" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The following pseudo-code details the IPv6 fragmentation, assuming that the packet does not contain options.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># mtu : maximum size of the packet (including header) of outgoing link</span>
<span class="c1"># In Scapy-like notation (see https://github.com/secdev/scapy)</span>
<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mtu</span><span class="p">:</span>
    <span class="n">send</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># packet is too large</span>
    <span class="c1"># 40 refers to the size of the IPv6 header</span>
    <span class="n">maxpayload</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="nb">int</span><span class="p">((</span><span class="n">mtu</span> <span class="o">-</span> <span class="mi">40</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># must be n times 8 bytes</span>
    <span class="c1"># packet must be fragmented</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">IPv6</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">globalCounter</span>
    <span class="n">globalCounter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpayload</span><span class="p">:</span>
            <span class="n">toSend</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">plen</span><span class="o">=</span><span class="n">mtu</span><span class="p">,</span>
                          <span class="n">hlim</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">hlim</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span><span class="o">/</span><span class="n">IPv6ExtHdrFrament</span><span class="p">(</span>
                              <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">nh</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">nh</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxpayload</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">maxpayload</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="n">maxpayload</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The last fragment</span>
            <span class="n">toSend</span> <span class="o">=</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">plen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span>
                          <span class="n">hlim</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">hlim</span><span class="p">,</span> <span class="n">nh</span><span class="o">=</span><span class="mi">44</span><span class="p">)</span><span class="o">/</span><span class="n">IPv6ExtHdrFrament</span><span class="p">(</span>
                              <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">),</span> <span class="n">m</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">nh</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">nh</span><span class="p">)</span><span class="o">/</span><span class="n">payload</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">forward</span><span class="p">(</span><span class="n">toSend</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above pseudocode, we maintain a single 32 bits counter that is incremented for each packet that needs to be fragmented. Other implementations to compute the packet identification are possible. <span class="target" id="index-61"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> only requires that two fragmented packets that are sent within the MSL between the same pair of hosts have different identifications.</p>
<p>The fragments of an IPv6 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. Furthermore, some fragments may be lost and never reach the destination.</p>
<p>The reassembly algorithm used by the destination host is roughly as follows. First, the destination can verify whether a received IPv6 packet is a fragment or not by checking whether it contains a fragment header. If so, all fragments with the some identification must be reassembled together. The reassembly algorithm relies on the <cite>Identification</cite> field of the received fragments to associate a fragment with the corresponding packet being reassembled. Furthermore, the <cite>Fragment Offset</cite> field indicates the position of the fragment payload in the original non-fragmented packet. Finally, the packet with the <cite>M</cite> flag reset allows the destination to determine the total length of the original non-fragmented packet.</p>
<p>Note that the reassembly algorithm must deal with the unreliability of the IP network. This implies that a fragment may be duplicated or a fragment may never reach the destination. The destination can easily detect fragment duplication thanks to the <cite>Fragment Offset</cite>. To deal with fragment losses, the reassembly algorithm must bind the time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. This can be implemented by starting a timer when the first fragment of a packet is received. If the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Header compression on low bandwidth links</p>
<p>Given the size of the IPv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for Voice over IP applications. In such environments, several techniques can be used to reduce the overhead. A first solution is to use data compression in the datalink layer to compress all the information exchanged <a class="reference internal" href="../bibliography.html#thomborson1992" id="id21"><span>[Thomborson1992]</span></a>. These techniques are similar to the data compression algorithms used in tools such as <em class="manpage">compress(1)</em> or <em class="manpage">gzip(1)</em> <span class="target" id="index-62"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1951.html"><strong>RFC 1951</strong></a>. They compress streams of bits without taking advantage of the fact that these streams contain IP packets with a known structure. A second solution is to compress the IP and TCP header. These header compression techniques, such as the one defined in <span class="target" id="index-63"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5795.html"><strong>RFC 5795</strong></a> take advantage of the redundancy found in successive packets from the same flow to significantly reduce the size of the protocol headers. Another solution is to define a compressed encoding of the IPv6 header that matches the capabilities of the underlying datalink layer <span class="target" id="index-64"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a>.</p>
</div>
<p>The last type of <cite>IPv6 header extension</cite> is the <cite>Routing</cite> header. The <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">0</span></code> routing header defined in <span class="target" id="index-65"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a> is an example of an IPv6 option that must be processed by some routers. This option is encoded as shown in <a class="reference internal" href="#fig-ipv6-rh0"><span class="std std-numref">Fig. 123</span></a>.</p>
<figure class="align-center" id="id45">
<span id="fig-ipv6-rh0"/><a class="reference internal image-reference" href="../_images/ipv6-routing-0.svg"><img alt="../_images/ipv6-routing-0.svg" src="../Images/276a7739af129da2cd8c3b5ec430d381.png" style="width: 579.0px; height: 592.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ipv6-routing-0.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 123 </span><span class="caption-text">The Type 0 routing header (<span class="target" id="index-66"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2460.html"><strong>RFC 2460</strong></a>)</span><a class="headerlink" href="#id45" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. Unfortunately, further work with this routing header, including an entertaining demonstration with <a class="reference external" href="https://www.secdev.org/projects/scapy/">scapy</a> <a class="reference internal" href="../bibliography.html#be2007" id="id22"><span>[BE2007]</span></a> , revealed severe security problems with this routing header. For this reason, loose source routing with the type 0 routing header has been removed from the IPv6 specification <span class="target" id="index-67"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5095.html"><strong>RFC 5095</strong></a>.</p>
&#13;

<span id="icmpv6"/><h3>ICMP version 6<a class="headerlink" href="#icmp-version-6" title="Link to this heading">#</a></h3>
<p>It is sometimes necessary for intermediate routers or the destination host to inform the sender of the packet of a problem that occurred while processing a packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control Message Protocol (ICMP). ICMPv6 is defined in <span class="target" id="index-68"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a>. It is used both to report problems that occurred while processing an IPv6 packet, but also to distribute addresses.</p>
<p>ICMPv6 messages are carried inside IPv6 packets (the <cite>Next Header</cite> field for ICMPv6 is <code class="docutils literal notranslate"><span class="pre">58</span></code>). Each ICMP message contains a 32 bits header with an 8 bits <cite>type</cite> field, a <cite>code</cite> field and a 16 bits checksum computed over the entire ICMPv6 message. The message body contains a copy of the IPv6 packet in error. The ICMPv6 header is shown in <a class="reference internal" href="#fig-icmpv6-header"><span class="std std-numref">Fig. 124</span></a>.</p>
<figure class="align-center" id="id46">
<span id="fig-icmpv6-header"/><a class="reference internal image-reference" href="../_images/icmpv6.svg"><img alt="../_images/icmpv6.svg" src="../Images/8440c110b309073d9f6a09bf2e22fccb.png" style="width: 715.1999999999999px; height: 153.6px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/icmpv6.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 124 </span><span class="caption-text">ICMP version 6 packet format</span><a class="headerlink" href="#id46" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>ICMPv6 specifies two classes of messages : error messages that indicate a problem in handling a packet and informational messages. Four types of error messages are defined in <span class="target" id="index-69"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a> :</p>
<blockquote>
<div><ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code><span class="classifier"><cite>Destination Unreachable</cite>. Such an ICMPv6 message is sent when the destination address of a packet is unreachable. The <cite>code</cite> field of the ICMP header contains additional information about the type of unreachability. The following codes are specified in <span class="target" id="index-70"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a></span></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> : No route to destination. This indicates that the router that sent the ICMPv6 message did not have a route towards the packet’s destination</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : Communication with destination administratively prohibited. This indicates that a firewall has refused to forward the packet towards its final destination.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : Beyond scope of source address. This message can be sent if the source is using link-local addresses to reach a global unicast address outside its subnet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : Address unreachable. This message indicates that the packet reached the subnet of the destination, but the host that owns this destination address cannot be reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> : Port unreachable. This message indicates that the IPv6 packet was received by the destination, but there was no application listening to the specified port.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : Packet Too Big. The router that was to send the ICMPv6 message received an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message contains the MTU of this link in bytes. This allows the sending host to implement Path MTU discovery <span class="target" id="index-71"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1981.html"><strong>RFC 1981</strong></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : Time Exceeded. This error message can be sent either by a router or by a host. A router would set <cite>code</cite> to <cite>0</cite> to report the reception of a packet whose <cite>Hop Limit</cite> reached <cite>0</cite>. A host would set <cite>code</cite> to <cite>1</cite> to report that it was unable to reassemble received IPv6 fragments.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code> : Parameter Problem. This ICMPv6 message is used to report either the reception of an IPv6 packet with an erroneous header field (code <cite>0</cite>) or an unknown <cite>Next Header</cite> or IP option (codes <cite>1</cite> and <cite>2</cite>). In this case, the message body contains the erroneous IPv6 packet and the first 32 bits of the message body contain a pointer to the error.</p></li>
</ul>
</div></blockquote>
<p>The <cite>Destination Unreachable</cite> ICMP error message is returned when a packet cannot be forwarded to its final destination. The first four ICMPv6 error messages (type <code class="docutils literal notranslate"><span class="pre">1</span></code>, codes <code class="docutils literal notranslate"><span class="pre">0-3</span></code>)  are generated by routers while hosts may return code <code class="docutils literal notranslate"><span class="pre">4</span></code> when there is no application bound to the corresponding port number.</p>
<p>The <cite>Packet Too Big</cite> ICMP messages enable the source host to discover the MTU size that it can safely use to reach a given destination. To understand its operation, consider the (academic) scenario shown in <a class="reference internal" href="#fig-ipv6-mtu-discovery"><span class="std std-numref">Fig. 125</span></a>. In this figure, the labels on each link represent the maximum packet size supported by this link.</p>
<blockquote>
<div><div class="figure" id="id47" style="text-align: center">
<span id="fig-ipv6-mtu-discovery"/><p><img src="../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-01f32f8a7fcf88c7a58965b21306ce4ba00c84bf.png"/></p>
<p><span class="caption-number">Fig. 125 </span><span class="caption-text">Example for IPv6 MTU discovery</span></p>
</div></div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> sends a 1500 bytes packet, <code class="docutils literal notranslate"><span class="pre">R1</span></code> will return an ICMPv6 error message indicating a maximum packet length of 1400 bytes. <code class="docutils literal notranslate"><span class="pre">A</span></code> would then fragment the packet before retransmitting it. The small fragment would go through, but the large fragment will be refused by <code class="docutils literal notranslate"><span class="pre">R2</span></code> that would return an ICMPv6 error message. <code class="docutils literal notranslate"><span class="pre">A</span></code> can fragment again the packet and send it to the final destination as two fragments.</p>
<p>In practice, an IPv6 implementation does not store the transmitted packets to be able to retransmit them if needed. However, since TCP (and SCTP) buffer the segments that they transmit, a similar approach can be used in transport protocols to detect the largest MTU on a path towards a given destination. This technique is called PathMTU Discovery <span class="target" id="index-72"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1981.html"><strong>RFC 1981</strong></a>.</p>
<p id="index-73">When a TCP segment is transported in an IP packet that is fragmented in the network, the loss of a single fragment forces TCP to retransmit the entire segment (and thus all the fragments). If TCP was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. In addition, IP reassembly causes several challenges at high speed as discussed in <span class="target" id="index-74"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4963.html"><strong>RFC 4963</strong></a>. Using IP fragmentation to allow UDP applications to exchange large messages raises several security issues <a class="reference internal" href="../bibliography.html#kps2003" id="id23"><span>[KPS2003]</span></a>.</p>
<p>ICMPv6 is used by TCP implementations to discover the largest MTU size that is allowed to reach a destination host without causing network fragmentation. A TCP implementation parses the <cite>Packets Too Big</cite> ICMP messages that it receives. These ICMP messages contain the MTU of the router’s outgoing link in their <cite>Data</cite> field. Upon reception of such an ICMP message, the source TCP implementation adjusts its Maximum Segment Size (MSS) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.</p>
<p id="index-75">Two types of informational ICMPv6 messages are defined in <span class="target" id="index-76"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4443.html"><strong>RFC 4443</strong></a> : <cite>echo request</cite> and <cite>echo reply</cite>, which are used to test the reachability of a destination by using <em class="manpage">ping6(8)</em>. Each host is supposed to reply with an ICMP <cite>Echo reply</cite> message when it receives an  ICMP <cite>Echo request</cite> message. A sample usage of <em class="manpage">ping6(8)</em> is shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">#</span>ping6<span class="w"> </span>www.ietf.org
<span class="go">PING6(56=40+8+8 bytes) 2001:6a8:3080:2:3403:bbf4:edae:afc3 --&gt; 2001:1890:123a::1:1e</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=0 hlim=49 time=156.905 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=1 hlim=49 time=155.618 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=2 hlim=49 time=155.808 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=3 hlim=49 time=155.325 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=4 hlim=49 time=155.493 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=5 hlim=49 time=155.801 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=6 hlim=49 time=155.660 ms</span>
<span class="go">16 bytes from 2001:1890:123a::1:1e, icmp_seq=7 hlim=49 time=155.869 ms</span>
<span class="go">^C</span>
<span class="go">--- www.ietf.org ping6 statistics ---</span>
<span class="go">8 packets transmitted, 8 packets received, 0.0% packet loss</span>
<span class="go">round-trip min/avg/max/std-dev = 155.325/155.810/156.905/0.447 ms</span>
</pre></div>
</div>
<p id="index-77">Another very useful debugging tool is <em class="manpage">traceroute6(8)</em>. The traceroute man page describes this tool as <cite>“print the route packets take to network host”</cite>. traceroute uses the <cite>Time exceeded</cite> ICMP messages to discover the intermediate routers on the path towards a destination. The principle behind traceroute is very simple. When a router receives an IP packet whose <cite>Hop Limit</cite> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code> it is forced to return to the sending host a <cite>Time exceeded</cite> ICMP message containing the header and the first bytes of the discarded packet. To discover all routers on a network path, a simple solution is to first send a packet whose <cite>Hop Limit</cite> is set to <cite>1</cite>, then a packet whose <cite>Hop Limit</cite> is set to <cite>2</cite>, etc. A sample traceroute6 output is shown below.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span/><span class="gp">#</span>traceroute6<span class="w"> </span>www.ietf.org
<span class="go">traceroute6 to www.ietf.org (2001:1890:1112:1::20) from 2001:6a8:3080:2:217:f2ff:fed6:65c0, 30 hops max, 12 byte packets</span>
<span class="go"> 1  2001:6a8:3080:2::1  13.821 ms  0.301 ms  0.324 ms</span>
<span class="go"> 2  2001:6a8:3000:8000::1  0.651 ms  0.51 ms  0.495 ms</span>
<span class="go"> 3  10ge.cr2.bruvil.belnet.net  3.402 ms  3.34 ms  3.33 ms</span>
<span class="go"> 4  10ge.cr2.brueve.belnet.net  3.668 ms 10ge.cr2.brueve.belnet.net  3.988 ms 10ge.cr2.brueve.belnet.net  3.699 ms</span>
<span class="go"> 5  belnet.rt1.ams.nl.geant2.net  10.598 ms  7.214 ms  10.082 ms</span>
<span class="go"> 6  so-7-0-0.rt2.cop.dk.geant2.net  20.19 ms  20.002 ms  20.064 ms</span>
<span class="go"> 7  kbn-ipv6-b1.ipv6.telia.net  21.078 ms  20.868 ms  20.864 ms</span>
<span class="go"> 8  s-ipv6-b1-link.ipv6.telia.net  31.312 ms  31.113 ms  31.411 ms</span>
<span class="go"> 9  s-ipv6-b1-link.ipv6.telia.net  61.986 ms  61.988 ms  61.994 ms</span>
<span class="go"> 10  2001:1890:61:8909::1  121.716 ms  121.779 ms  121.177 ms</span>
<span class="go"> 11  2001:1890:61:9117::2  203.709 ms  203.305 ms  203.07 ms</span>
<span class="go"> 12  mail.ietf.org  204.172 ms  203.755 ms  203.748 ms</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rate limitation of ICMP messages</p>
<p>High-end hardware based routers use special purpose chips on their interfaces to forward IPv6 packets at line rate. These chips are optimized to process <cite>correct</cite> IP packets. They are not able to create ICMP messages at line rate. When such a chip receives an IP packet that triggers an ICMP message, it interrupts the main CPU of the router and the software running on this CPU processes the packet. This CPU is much slower than the hardware acceleration found on the interfaces <a class="reference internal" href="../bibliography.html#gill2004" id="id24"><span>[Gill2004]</span></a>. It would be overloaded if it had to process IP packets at line rate and generate one ICMP message for each received packet. To protect this CPU, high-end routers limit the rate at which the hardware can interrupt the main CPU and thus the rate at which ICMP messages can be generated. This implies that not all erroneous IP packets cause the transmission of an ICMP message. The risk of overloading the main CPU of the router is also the reason why using hop-by-hop IPv6 options, including the router alert option is discouraged <a href="#id49"><span class="problematic" id="id25">[#falert]_</span></a>.</p>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fnetmask" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Another way of representing IP subnets is to use netmasks. A netmask is a 32 bits field whose <cite>p</cite> high order bits are set to <cite>1</cite> and the low order bits are set to <cite>0</cite>. The number of high order bits set <cite>1</cite> indicates the length of the subnet identifier. Netmasks are usually represented in the same dotted decimal format as IPv4 addresses. For example <cite>10.0.0.0/8</cite> would be represented as <cite>10.0.0.0 255.0.0.0</cite> while <cite>192.168.1.0/24</cite> would be represented as <cite>192.168.1.0 255.255.255.0</cite>. In some cases, the netmask can be represented in hexadecimal.</p>
</aside>
<aside class="footnote brackets" id="fprotocolnumber" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference external" href="http://www.iana.org/assignments/protocol-numbers/">http://www.iana.org/assignments/protocol-numbers/</a> for the list of all assigned <cite>Protocol</cite> numbers</p>
</aside>
<aside class="footnote brackets" id="fttl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>The initial IP specification in <span class="target" id="index-78"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc791.html"><strong>RFC 791</strong></a> suggested that routers would decrement the <cite>TTL</cite> at least once every second. This would ensure that a packet would never remain for more than <cite>TTL</cite> seconds in the network. However, in practice most router implementations simply chose to decrement the <cite>TTL</cite> by one.</p>
</aside>
<aside class="footnote brackets" id="finitialttl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>The initial TTL value used to send IP packets vary from one implementation to another. Most current IP implementations use an initial TTL of 64 or more. See <a class="reference external" href="http://members.cox.net/~ndav1/self_published/TTL_values.html">http://members.cox.net/~ndav1/self_published/TTL_values.html</a> for additional information.</p>
</aside>
<aside class="footnote brackets" id="f6lowpan" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Supporting IP over the 802.15.4 datalink layer technology requires special mechanisms. See <span class="target" id="index-79"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4944.html"><strong>RFC 4944</strong></a> for a discussion of the special problems posed by 802.15.4</p>
</aside>
<aside class="footnote brackets" id="fpingproblems" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span>
<p>Until a few years ago, all hosts replied to <cite>Echo request</cite> ICMP messages. However, due to the security problems that have affected TCP/IP implementations, many of these implementations can now be configured to disable answering <cite>Echo request</cite> ICMP messages.</p>
</aside>
<aside class="footnote brackets" id="ftraceroutemore" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">7</a><span class="fn-bracket">]</span></span>
<p>A detailed analysis of traceroute output is outside the scope of this document. Additional information may be found in <a class="reference internal" href="../bibliography.html#aco-2006" id="id26"><span>[ACO+2006]</span></a> and <a class="reference internal" href="../bibliography.html#dt2007" id="id27"><span>[DT2007]</span></a></p>
</aside>
</aside>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fmultiiana" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">8</a><span class="fn-bracket">]</span></span>
<p>The full list of allocated IPv6 multicast addresses is available at <a class="reference external" href="http://www.iana.org/assignments/ipv6-multicast-addresses">http://www.iana.org/assignments/ipv6-multicast-addresses</a></p>
</aside>
<aside class="footnote brackets" id="fianaprotocol" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id16">1</a>,<a role="doc-backlink" href="#id19">2</a>)</span>
<p>The <a class="reference external" href="https://www.iana.org">IANA</a> maintains the list of all allocated Next Header types at <a class="reference external" href="http://www.iana.org/assignments/protocol-numbers/">http://www.iana.org/assignments/protocol-numbers/</a></p>
</aside>
<aside class="footnote brackets" id="fipv4checksum" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">10</a><span class="fn-bracket">]</span></span>
<p>When IPv4 was designed, the situation was different. The IPv4 header includes a checksum that only covers the network header. This checksum is computed by the source and updated by all intermediate routers that decrement the TTL, which is the IPv4 equivalent of the <cite>HopLimit</cite> used by IPv6.</p>
</aside>
<aside class="footnote brackets" id="fdfflag" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></span>
<p>A transport protocol implementation can also specify whether the packet must be sent with the <cite>DF</cite> set or set. A TCP implementation using <cite>Path MTU Discovery</cite> would always request the transmission of IPv4 packets with the <cite>DF</cite> flag set.</p>
</aside>
<aside class="footnote brackets" id="fiddf" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id14">2</a>)</span>
<p>It should be noted that only the packets that can be fragmented (i.e. whose <cite>DF</cite> flag is reset) must have different <cite>Identification</cite> fields. The <cite>Identification</cite> field is not used in the packets having the <cite>DF</cite> flag set.</p>
</aside>
</aside>
    
</body>
</html>