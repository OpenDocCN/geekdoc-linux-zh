<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch089.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="usingcurl__downloads__compression__md-_-_-compression" class="level1" data-number="88">
<h1 data-number="88">Compression</h1>
<p>curl allows you to ask HTTP and HTTPS servers to provide compressed versions of the data and then perform automatic decompression of it on arrival. In situations where bandwidth is more limited than CPU this helps you receive more data in a shorter amount of time.</p>
<p>HTTP compression can be done using two different mechanisms, one which might be considered “The Right Way” and the other that is the way that everyone actually uses and is the widespread and popular way to do it. The common way to compress HTTP content is using the <strong>Content-Encoding</strong> header. You ask curl to use this with the <code>--compressed</code> option:</p>
<pre><code>curl --compressed http://example.com/</code></pre>
<p>With this option enabled (and if the server supports it) it delivers the data in a compressed way and curl decompresses it before saving it or sending it to stdout. This usually means that as a user you do not really see or experience the compression other than possibly noticing a faster transfer.</p>
<p>The <code>--compressed</code> option asks for Content-Encoding compression using one of the supported compression algorithms. There is also the rare <strong>Transfer-Encoding</strong> method, which is the request header that was created for this automated method but was never really widely adopted. You can tell curl to ask for Transfer-Encoded compression with <code>--tr-encoding</code>:</p>
<pre><code>curl --tr-encoding http://example.com/</code></pre>
<p>In theory, there is nothing that prevents you from using both in the same command line, although in practice, you may experience that some servers get a little confused when asked to compress in two different ways. It is generally safer to just pick one.</p>
<p>For SCP and SFTP transfers, there is <code>--compressed-ssh</code>. It compresses all traffic in either direction.</p>
<section id="usingcurl__downloads__compression__md-_-_-http-headers" class="level2" data-number="88.1">
<h2 data-number="88.1">HTTP headers</h2>
<p>HTTP/1.x headers cannot be compressed. HTTP/2 and HTTP/3 headers on the other hands are always compressed and cannot be sent uncompressed. However, as a convenience to users, curl always shows the headers uncompressed in a style similar to how they look for HTTP/1.x to make the output and look consistent.</p>
</section>
<section id="usingcurl__downloads__compression__md-_-_-uploads" class="level2" data-number="88.2">
<h2 data-number="88.2">Uploads</h2>
<p>For HTTP there is no standard way to do compression. The above mentioned HTTP compression methods only work for downloads.</p>
<p><span id="usingcurl__downloads__redirects__md"></span></p>
</section>
</section>
</body>
</html>
