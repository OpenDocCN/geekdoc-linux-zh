<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch081.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="usingcurl__verbose__trace__md-_-_-trace-options" class="level1" data-number="80">
<h1 data-number="80">Trace options</h1>
<p>There are times when <code>-v</code> is not enough. In particular, when you want to store the complete stream including the actual transferred data.</p>
<p>For situations when curl does encrypted file transfers with protocols such as HTTPS, FTPS or SFTP, other network monitoring tools (like Wireshark or tcpdump) are not able to do this job as easily for you.</p>
<p>For this, curl offers two other options that you use instead of <code>-v</code>.</p>
<p><code>--trace [filename]</code> saves a full trace in the given filename. You can also use ‘-’ (a single minus) instead of a filename to get it passed to stdout. You would use it like this:</p>
<pre><code>$ curl --trace dump http://example.com</code></pre>
<p>When completed, there is a ‘dump’ file that can turn out pretty sizable. In this case, the 15 first lines of the dump file looks like:</p>
<pre><code>== Info: Rebuilt URL to: http://example.com/
== Info:   Trying 93.184.216.34...
== Info: Connected to example.com (93.184.216.34) port 80 (#0)
=&gt; Send header, 75 bytes (0x4b)
0000: 47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a GET / HTTP/1.1..
0010: 48 6f 73 74 3a 20 65 78 61 6d 70 6c 65 2e 63 6f Host: example.co
0020: 6d 0d 0a 55 73 65 72 2d 41 67 65 6e 74 3a 20 63 m..User-Agent: c
0030: 75 72 6c 2f 37 2e 34 35 2e 30 0d 0a 41 63 63 65 url/7.45.0..Acce
0040: 70 74 3a 20 2a 2f 2a 0d 0a 0d 0a                pt: */*....
&lt;= Recv header, 17 bytes (0x11)
0000: 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d HTTP/1.1 200 OK.
0010: 0a                                              .
&lt;= Recv header, 22 bytes (0x16)
0000: 41 63 63 65 70 74 2d 52 61 6e 67 65 73 3a 20 62 Accept-Ranges: b
0010: 79 74 65 73 0d 0a                               ytes..</code></pre>
<p>Every single sent and received byte gets displayed individually in hexadecimal numbers. Received headers are output line by line.</p>
<p>If you think the hexadecimals are not helping, you can try <code>--trace-ascii [filename]</code> instead, also this accepting ‘-’ for stdout and that makes the 15 first lines of tracing look like:</p>
<pre><code>== Info: Rebuilt URL to: http://example.com/
== Info:   Trying 93.184.216.34...
== Info: Connected to example.com (93.184.216.34) port 80 (#0)
=&gt; Send header, 75 bytes (0x4b)
0000: GET / HTTP/1.1
0010: Host: example.com
0023: User-Agent: curl/7.45.0
003c: Accept: */*
0049:
&lt;= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
&lt;= Recv header, 22 bytes (0x16)
0000: Accept-Ranges: bytes
&lt;= Recv header, 31 bytes (0x1f)
0000: Cache-Control: max-age=604800</code></pre>
<section id="usingcurl__verbose__trace__md-_-_-time-stamps" class="level2" data-number="80.1">
<h2 data-number="80.1">Time stamps</h2>
<p>The <code>--trace-time</code> option prefixes all verbose/trace outputs with a high resolution timer for when the line is printed. It works with the regular <code>-v / --verbose</code> option as well as with <code>--trace</code> and <code>--trace-ascii</code>.</p>
<p>An example could look like this:</p>
<pre><code>$ curl -v --trace-time http://example.com
23:38:56.837164 * Rebuilt URL to: http://example.com/
23:38:56.841456 *   Trying 93.184.216.34...
23:38:56.935155 * Connected to example.com (93.184.216.34) port 80 (#0)
23:38:56.935296 &gt; GET / HTTP/1.1
23:38:56.935296 &gt; Host: example.com
23:38:56.935296 &gt; User-Agent: curl/7.45.0
23:38:56.935296 &gt; Accept: */*
23:38:56.935296 &gt;
23:38:57.029570 &lt; HTTP/1.1 200 OK
23:38:57.029699 &lt; Accept-Ranges: bytes
23:38:57.029803 &lt; Cache-Control: max-age=604800
23:38:57.029903 &lt; Content-Type: text/html
---- snip ----</code></pre>
<p>The lines are all the local time as hours:minutes:seconds and then number of microseconds in that second.</p>
</section>
<section id="usingcurl__verbose__trace__md-_-_-identify-transfers-and-connections" class="level2" data-number="80.2">
<h2 data-number="80.2">Identify transfers and connections</h2>
<p>As the trace information flow showing on screen or to a file using these options is a continuous stream even though your command line might make curl use a large number of separate connections and different transfers, there are times when you want to see to which specific transfers or connections the various information below to. To better understand the trace output.</p>
<p>You can then add <code>--trace-ids</code> to the line and you see how curl adds two numbers to all tracing: the connection number and the transfer number. They are two separate identifiers because connections can be reused and multiple transfers can use the same connection.</p>
</section>
<section id="usingcurl__verbose__trace__md-_-_-more-data" class="level2" data-number="80.3">
<h2 data-number="80.3">More data</h2>
<p>If the amount of tracing data is not enough. Like when you suspect and want to debug a problem in a more fundamental lower protocol level, curl provides the <code>--trace-config</code> option for you.</p>
<p>With this option you tell curl to also include logging about components that it otherwise does not include by default, such as details about TLS, HTTP/2 or HTTP/3 protocol bits. It also has convenience options for adding the connection and transfer identifiers and time stamps.</p>
<p>The <code>--trace-config</code> option accepts an argument where you specify a comma-separated list with the areas you want it to trace. For example, include identifiers and show me HTTP/2 details:</p>
<pre><code>curl --trace-config ids,http/2 https://example.com</code></pre>
<p>The exact set of options varies, but here are some ones to try:</p>
<table>
<thead>
<tr class="header">
<th>area</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ids</code></td>
<td>the same identifiers as <code>--trace-ids</code> provides</td>
</tr>
<tr class="even">
<td><code>time</code></td>
<td>the same time output as <code>--trace-time</code> provides</td>
</tr>
<tr class="odd">
<td><code>all</code></td>
<td>show everything possible</td>
</tr>
<tr class="even">
<td><code>tls</code></td>
<td>TLS protocol exchange details</td>
</tr>
<tr class="odd">
<td><code>http/2</code></td>
<td>HTTP/2 frame information</td>
</tr>
<tr class="even">
<td><code>http/3</code></td>
<td>HTTP/3 frame information</td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td>additional ones in future versions</td>
</tr>
</tbody>
</table>
<p>Doing a quick run with <code>all</code> is often a good way to get to see which specific areas that are shown, as then you can do follow-up runs with more specific areas set.</p>
<p><span id="usingcurl__verbose__writeout__md"></span></p>
</section>
</section>
</body>
</html>
