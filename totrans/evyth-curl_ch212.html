<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch212.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="transfers__drive__multi-socket__md-_-_-drive-with-multi-_socket" class="level1" data-number="211">
<h1 data-number="211">Drive with multi_socket</h1>
<p>multi_socket is the extra spicy version of the regular multi interface and is designed for event-driven applications. Make sure you read the <a href="ch210.xhtml#transfers__drive__multi__md">Drive with multi interface</a> section first.</p>
<p>multi_socket supports multiple parallel transfers—all done in the same single thread—and have been used to run several tens of thousands of transfers in a single application. It is usually the API that makes the most sense if you do a large number (&gt;100 or so) of parallel transfers.</p>
<p>Event-driven in this case means that your application uses a system level library or setup that subscribes to a number of sockets and it lets your application know when one of those sockets are readable or writable and it tells you exactly which one.</p>
<p>This setup allows clients to scale up the number of simultaneous transfers much higher than with other systems, and still maintain good performance. The regular APIs otherwise waste far too much time scanning through lists of all the sockets.</p>
<section id="transfers__drive__multi-socket__md-_-_-pick-one" class="level2" data-number="211.1">
<h2 data-number="211.1">Pick one</h2>
<p>There are numerous event based systems to select from out there, and libcurl is completely agnostic to which one you use. libevent, libev and libuv are three popular ones but you can also go directly to your operating system’s native solutions such as epoll, kqueue, /dev/poll, pollset or Event Completion.</p>
</section>
<section id="transfers__drive__multi-socket__md-_-_-many-easy-handles" class="level2" data-number="211.2">
<h2 data-number="211.2">Many easy handles</h2>
<p>Just like with the regular multi interface, you add easy handles to a multi handle with <code>curl_multi_add_handle()</code>. One easy handle for each transfer you want to perform.</p>
<p>You can add them at any time while the transfers are running and you can also similarly remove easy handles at any time using the <code>curl_multi_remove_handle</code> call. Typically though, you remove a handle only after its transfer is completed.</p>
</section>
<section id="transfers__drive__multi-socket__md-_-_-multi_socket-callbacks" class="level2" data-number="211.3">
<h2 data-number="211.3">multi_socket callbacks</h2>
<p>As explained above, this event-based mechanism relies on the application to know which sockets that are used by libcurl and what activities libcurl waits for on those sockets: if it waits for the socket to become readable, writable or both.</p>
<p>The application also needs to tell libcurl when the timeout time has expired, as it is control of driving everything libcurl cannot do it itself. libcurl informs the application updated timeout values as soon as it needs to.</p>
<section id="transfers__drive__multi-socket__md-_-_-socket_callback" class="level3" data-number="211.3.1">
<h3 data-number="211.3.1">socket_callback</h3>
<p>libcurl informs the application about socket activity to wait for with a callback called <a href="https://curl.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html">CURLMOPT_SOCKETFUNCTION</a>. Your application needs to implement such a function:</p>
<pre><code>int socket_callback(CURL *easy,      /* easy handle */
                    curl_socket_t s, /* socket */
                    int what,        /* what to wait for */
                    void *userp,     /* private callback pointer */
                    void *socketp)   /* private socket pointer */
{
   /* told about the socket &#39;s&#39; */
}

/* set the callback in the multi handle */
curl_multi_setopt(multi_handle, CURLMOPT_SOCKETFUNCTION, socket_callback);</code></pre>
<p>Using this, libcurl sets and removes sockets your application should monitor. Your application tells the underlying event-based system to wait for the sockets. This callback is called multiple times if there are multiple sockets to wait for, and it is called again when the status changes and perhaps you should switch from waiting for a writable socket to instead wait for it to become readable.</p>
<p>When one of the sockets that the application is monitoring on libcurl’s behalf registers that it becomes readable or writable, as requested, you tell libcurl about it by calling <code>curl_multi_socket_action()</code> and passing in the affected socket and an associated bitmask specifying which socket activity that was registered:</p>
<pre><code>int running_handles;
ret = curl_multi_socket_action(multi_handle,
                               sockfd, /* the socket with activity */
                               ev_bitmask, /* the specific activity */
                               &amp;running_handles);</code></pre>
</section>
<section id="transfers__drive__multi-socket__md-_-_-timer_callback" class="level3" data-number="211.3.2">
<h3 data-number="211.3.2">timer_callback</h3>
<p>The application is in control and waits for socket activity. But even without socket activity there are things libcurl needs to do. Timeout things, calling the progress callback, starting over a retry or failing a transfer that takes too long, etc. To make that work, the application must also make sure to handle a single-shot timeout that libcurl sets.</p>
<p>libcurl sets the timeout with the timer_callback <a href="https://curl.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html">CURLMOPT_TIMERFUNCTION</a>:</p>
<pre><code>int timer_callback(multi_handle,   /* multi handle */
                   timeout_ms,     /* milliseconds to wait */
                   userp)          /* private callback pointer */
{
  /* the new time-out value to wait for is in &#39;timeout_ms&#39; */
}

/* set the callback in the multi handle */
curl_multi_setopt(multi_handle, CURLMOPT_TIMERFUNCTION, timer_callback);</code></pre>
<p>There is only one timeout for the application to handle for the entire multi handle, no matter how many individual easy handles that have been added or transfers that are in progress. The timer callback gets updated with the current nearest-in-time period to wait. If libcurl gets called before the timeout expiry time because of socket activity, it may update the timeout value again before it expires.</p>
<p>When the event system of your choice eventually tells you that the timer has expired, you need to tell libcurl about it:</p>
<pre><code>curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0, &amp;running);</code></pre>
<p>…in many cases, this makes libcurl call the timer_callback again and set a new timeout for the next expiry period.</p>
</section>
<section id="transfers__drive__multi-socket__md-_-_-how-to-start-everything" class="level3" data-number="211.3.3">
<h3 data-number="211.3.3">How to start everything</h3>
<p>When you have added one or more easy handles to the multi handle and set the socket and timer callbacks in the multi handle, you are ready to start the transfer.</p>
<p>To kick it all off, you tell libcurl it timed out (because all easy handles start out with a short timeout) which make libcurl call the callbacks to set things up and from then on you can just let your event system drive:</p>
<pre><code>/* all easy handles and callbacks are setup */

curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0, &amp;running);

/* now the callbacks should have been called and we have sockets to wait
   for and possibly a timeout, too. Make the event system do its magic */

event_base_dispatch(event_base); /* libevent2 has this API */

/* at this point we have exited the event loop */</code></pre>
</section>
<section id="transfers__drive__multi-socket__md-_-_-when-is-it-done" class="level3" data-number="211.3.4">
<h3 data-number="211.3.4">When is it done?</h3>
<p>The ‘running_handles’ counter returned by <code>curl_multi_socket_action</code> holds the number of current transfers not completed. When that number reaches zero, we know there are no transfers going on.</p>
<p>Each time the ‘running_handles’ counter changes, <code>curl_multi_info_read()</code> returns info about the specific transfers that completed.</p>
<p><span id="transfers__callbacks__README__md"></span></p>
</section>
</section>
</section>
</body>
</html>
