["```go\ntype game struct {\n\tboard           *board\n\tfirstPlayer     iPlayer\n\tsecondPlayer    iPlayer\n\tfirstPlayerTurn bool\n\tgameStatus      GameStatus\n\tmoves           []move\n}\n\nfunc (this *game) play() error {}\n\nfunc (g *game) setGameStatus(win bool, whiteWon bool, stalemate bool) {}\n\nfunc (g *game) printResult() {}\n```", "```go\ntype GameStatus uint8\n\nconst (\n    GameInProgress GameStatus = iota\n    GameDraw\n    Stalemate\n    FirstPlayerWin\n    SecondPlayerWin\n)\n```", "```go\ntype board struct {\n\tsquare    [][]cell\n\tdimension int\n}\n\nfunc (this *board) printBoard() {}\n\nfunc (this *board) makeMove(move move) error {}\n```", "```go\ntype cell struct {\n\tlocation location\n\tpiece    piece\n}\n```", "```go\ntype move struct {\n    currLocation location\n    newLocation  location\n    piece        piece\n    resign       bool\n    drawOffer    bool\n}\n```", "```go\ntype iPlayer interface {\n    isWhite() bool\n    getNextMove(board) move\n    agreeDraw(board) bool\n    getID() int\n}\n```", "```go\ntype humanPlayer struct {\n    white bool\n    id    int\n}\n\nfunc (this humanPlayer) getID() int {}\n\nfunc (this humanPlayer) isWhite() bool {}\n\nfunc (this humanPlayer) getNextMove(board board) move {}\n\nfunc (this humanPlayer) agreeDraw(board board) bool {}\n```", "```go\ntype computerPlayer struct {\n\twhite bool\n\tid    int\n}\n\nfunc (this computerPlayer) isWhite() bool {}\n\nfunc (this computerPlayer) getID() int {}\n\nfunc (this computerPlayer) getNextMove(board board) move {}\n\nfunc (this computerPlayer) agreeDraw(board board) bool {}\n```", "```go\ntype piece interface {\n\tcanMove(board, location, location) error\n\tgetPieceType() PieceType\n\tisKilled() bool\n\tisWhite() bool\n}\n```", "```go\ntype PieceType uint8\n\nconst (\n\tKing PieceType = iota\n\tQueen\n\tRook\n\tBishop\n\tKnight\n\tPawn\n)\n```", "```go\ntype king struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *king) canMove(board board, currLocation, newLocation location) error {}\n\nfunc (this *king) getPieceType() PieceType {}\n\nfunc (this *king) isKilled() bool {}\n\nfunc (this *king) isWhite() bool {}\n```", "```go\ntype queen struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *queen) canMove(board board, currLocation, newLocation location) error {}\n\nfunc (this *queen) getPieceType() PieceType {}\n\nfunc (this *queen) isKilled() bool {}\n\nfunc (this *queen) isWhite() bool {}\n```", "```go\ntype rook struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *rook) canMove(board board, currLocation, newLocation location) error {}\n\nfunc (this *rook) getPieceType() PieceType {}\n\nfunc (this *rook) isKilled() bool {}\n\nfunc (this *rook) isWhite() bool {}\n```", "```go\ntype bishop struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *bishop) canMove(board board, currLocation, newLocation location) error {}\n\nfunc (this *bishop) getPieceType() PieceType {}\n\nfunc (this *bishop) isKilled() bool {}\n\nfunc (this *bishop) isWhite() bool {}\n```", "```go\ntype knight struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *knight) canMove(board board, currLocation, newLocation location) error {}\n\nfunc (this *knight) getPieceType() PieceType {}\n\nfunc (this *knight) isKilled() bool {}\n\nfunc (this *knight) isWhite() bool {}\n```", "```go\ntype pawn struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *pawn) canMove(board board, currLocation, newLocation location) error {}\n\nfunc (this *pawn) getPieceType() PieceType {}\n\nfunc (this *pawn) isKilled() bool {}\n\nfunc (this *pawn) isWhite() bool {}\n```", "```go\ntype location struct {\n\ti int\n\tj int\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype game struct {\n\tboard           *board\n\tfirstPlayer     iPlayer\n\tsecondPlayer    iPlayer\n\tfirstPlayerTurn bool\n\tgameStatus      GameStatus\n\tmoves           []move\n}\n\nfunc initGame(b *board, p1, p2 iPlayer) *game {\n\tgame := &game{\n\t\tboard:           b,\n\t\tfirstPlayer:     p1,\n\t\tsecondPlayer:    p2,\n\t\tfirstPlayerTurn: true,\n\t\tgameStatus:      GameInProgress,\n\t}\n\treturn game\n}\n\nfunc (this *game) play() error {\n\tvar move move\n\tvar err error\n\tfor {\n\t\tif this.firstPlayerTurn {\n\t\t\tmove = this.firstPlayer.getNextMove(*this.board)\n\t\t\tif move.resign {\n\t\t\t\tthis.setGameStatus(true, true, false)\n\t\t\t}\n\t\t\tif move.drawOffer {\n\t\t\t\tif this.secondPlayer.agreeDraw(*this.board) {\n\t\t\t\t\tthis.setGameStatus(false, true, false)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\terr := this.board.makeMove(move)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tmove = this.firstPlayer.getNextMove(*this.board)\n\t\t\tif move.resign {\n\t\t\t\tthis.setGameStatus(true, true, false)\n\t\t\t}\n\t\t\tif move.drawOffer {\n\t\t\t\tif this.secondPlayer.agreeDraw(*this.board) {\n\t\t\t\t\tthis.setGameStatus(false, true, false)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = this.board.makeMove(move)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tthis.moves = append(this.moves, move)\n\t\twin, draw, stalemate := this.checkGameStatus()\n\t\tthis.setGameStatus(win, draw, stalemate)\n\t\tif this.gameStatus != GameInProgress {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (this *game) checkGameStatus() (win bool, whiteWon bool, stalemate bool) {\n\n\treturn true, true, true\n\n}\n\nfunc (g *game) setGameStatus(win bool, whiteWon bool, stalemate bool) {\n\tif win {\n\t\tif whiteWon {\n\t\t\tif g.firstPlayer.isWhite() {\n\t\t\t\tg.gameStatus = FirstPlayerWin\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tg.gameStatus = SecondPlayerWin\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tif stalemate {\n\t\tg.gameStatus = Stalemate\n\t}\n\tg.gameStatus = GameDraw\n\treturn\n}\n\nfunc (g *game) printResult() {\n\tswitch g.gameStatus {\n\tcase GameInProgress:\n\t\tfmt.Println(\"Game in Progress\")\n\tcase GameDraw:\n\t\tfmt.Println(\"Game Drawn\")\n\tcase Stalemate:\n\t\tfmt.Println(\"Stalemate\")\n\tcase FirstPlayerWin:\n\t\tfmt.Println(\"First Player Win\")\n\tcase SecondPlayerWin:\n\t\tfmt.Println(\"Second Player Win\")\n\tdefault:\n\t\tfmt.Println(\"Invalid Game Status\")\n\t}\n\tg.board.printBoard()\n}\n```", "```go\npackage main\n\ntype GameStatus uint8\n\nconst (\n\tGameInProgress GameStatus = iota\n\tGameDraw\n\tStalemate\n\tFirstPlayerWin\n\tSecondPlayerWin\n)\n```", "```go\npackage main\n\ntype board struct {\n\tsquare    [][]cell\n\tdimension int\n}\n\nfunc (this *board) printBoard() {\n\n}\n\nfunc (this *board) makeMove(move move) error {\n\terr := move.piece.canMove(*this, move.currLocation, move.newLocation)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t//Mark the piece at new location as as the current piece\n\tthis.square[move.newLocation.i][move.newLocation.j].piece = move.piece\n\n\t//Mark the piece at current location as nil\n\tthis.square[move.currLocation.i][move.currLocation.j].piece = nil\n\treturn nil\n}\n```", "```go\npackage main\n\ntype cell struct {\n\tlocation location\n\tpiece    piece\n}\n```", "```go\npackage main\n\ntype move struct {\n\tcurrLocation location\n\tnewLocation  location\n\tpiece        piece\n\tresign       bool\n\tdrawOffer    bool\n}\n```", "```go\npackage main\n\ntype iPlayer interface {\n\tisWhite() bool\n\tgetNextMove(board) move\n\tagreeDraw(board) bool\n\tgetID() int\n}\n```", "```go\npackage main\n\ntype humanPlayer struct {\n\twhite bool\n\tid    int\n}\n\nfunc (this humanPlayer) getID() int {\n\treturn this.id\n}\n\nfunc (this humanPlayer) isWhite() bool {\n\treturn this.white\n}\n\nfunc (this humanPlayer) getNextMove(board board) move {\n\tcurrLocation := location{\n\t\ti: 1,\n\t\tj: 0,\n\t}\n\n\tnewLocation := location{\n\t\ti: 2,\n\t\tj: 0,\n\t}\n\treturn move{\n\t\tcurrLocation: currLocation,\n\t\tpiece:        board.square[1][0].piece,\n\t\tnewLocation:  newLocation,\n\t}\n}\n\nfunc (this humanPlayer) agreeDraw(board board) bool {\n\treturn false\n}\n```", "```go\npackage main\n\ntype computerPlayer struct {\n\twhite bool\n\tid    int\n}\n\nfunc (this computerPlayer) isWhite() bool {\n\treturn this.white\n}\nfunc (this computerPlayer) getID() int {\n\treturn this.id\n}\n\nfunc (this computerPlayer) getNextMove(board board) move {\n\tcurrLocation := location{\n\t\ti: 1,\n\t\tj: 0,\n\t}\n\n\tnewLocation := location{\n\t\ti: 2,\n\t\tj: 0,\n\t}\n\treturn move{\n\t\tcurrLocation: currLocation,\n\t\tpiece:        board.square[1][0].piece,\n\t\tnewLocation:  newLocation,\n\t}\n}\n\nfunc (this computerPlayer) agreeDraw(board board) bool {\n\treturn false\n}\n```", "```go\npackage main\n\ntype piece interface {\n\tcanMove(board, location, location) error\n\tgetPieceType() PieceType\n\tisKilled() bool\n\tisWhite() bool\n}\n```", "```go\npackage main\n\ntype PieceType uint8\n\nconst (\n\tKing PieceType = iota\n\tQueen\n\tRook\n\tBishop\n\tKnight\n\tPawn\n)\n```", "```go\npackage main\n\ntype king struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *king) canMove(board board, currLocation, newLocation location) error {\n\treturn nil\n}\n\nfunc (this *king) getPieceType() PieceType {\n\treturn King\n}\n\nfunc (this *king) isKilled() bool {\n\treturn this.killed\n}\n\nfunc (this *king) isWhite() bool {\n\treturn this.white\n}\n```", "```go\npackage main\n\ntype queen struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *queen) canMove(board board, currLocation, newLocation location) error {\n\treturn nil\n}\n\nfunc (this *queen) getPieceType() PieceType {\n\treturn Queen\n}\n\nfunc (this *queen) isKilled() bool {\n\treturn this.killed\n}\n\nfunc (this *queen) isWhite() bool {\n\treturn this.white\n}\n```", "```go\npackage main\n\ntype rook struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *rook) canMove(board board, currLocation, newLocation location) error {\n\treturn nil\n}\n\nfunc (this *rook) getPieceType() PieceType {\n\treturn Pawn\n}\n\nfunc (this *rook) isKilled() bool {\n\treturn this.killed\n}\n\nfunc (this *rook) isWhite() bool {\n\treturn this.white\n}\n```", "```go\npackage main\n\ntype bishop struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *bishop) canMove(board board, currLocation, newLocation location) error {\n\treturn nil\n}\n\nfunc (this *bishop) getPieceType() PieceType {\n\treturn Pawn\n}\n\nfunc (this *bishop) isKilled() bool {\n\treturn this.killed\n}\n\nfunc (this *bishop) isWhite() bool {\n\treturn this.white\n}\n```", "```go\npackage main\n\ntype knight struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *knight) canMove(board board, currLocation, newLocation location) error {\n\treturn nil\n}\n\nfunc (this *knight) getPieceType() PieceType {\n\treturn Knight\n}\n\nfunc (this *knight) isKilled() bool {\n\treturn this.killed\n}\n\nfunc (this *knight) isWhite() bool {\n\treturn this.white\n}\n```", "```go\npackage main\n\ntype pawn struct {\n\twhite  bool\n\tkilled bool\n}\n\nfunc (this *pawn) canMove(board board, currLocation, newLocation location) error {\n\treturn nil\n}\n\nfunc (this *pawn) getPieceType() PieceType {\n\treturn Pawn\n}\n\nfunc (this *pawn) isKilled() bool {\n\treturn this.killed\n}\n\nfunc (this *pawn) isWhite() bool {\n\treturn this.white\n}\n```", "```go\npackage main\n\ntype location struct {\n\ti int\n\tj int\n}\n```", "```go\npackage main\n\nfunc main() {\n\n\twhiteKing, whiteQueen, whiteRooks, whiteBishops, whiteKnights, whitePawns := makePieces(true)\n\tblackKing, blackQueen, blackRooks, blackBishops, blackKnights, blackPawns := makePieces(true)\n\n\tcells := make([][]cell, 8)\n\n\tfor i := 0; i < 8; i++ {\n\t\tcells[i] = make([]cell, 8)\n\t}\n\n\t//Fill White Pieces in the first row\n\tcells[0][0] = cell{location: location{i: 0, j: 0}, piece: whiteRooks[0]}\n\tcells[0][1] = cell{location: location{i: 0, j: 1}, piece: whiteKnights[0]}\n\tcells[0][2] = cell{location: location{i: 0, j: 2}, piece: whiteBishops[0]}\n\tcells[0][3] = cell{location: location{i: 0, j: 3}, piece: whiteKing}\n\tcells[0][4] = cell{location: location{i: 0, j: 4}, piece: whiteQueen}\n\tcells[0][5] = cell{location: location{i: 0, j: 5}, piece: whiteBishops[1]}\n\tcells[0][6] = cell{location: location{i: 0, j: 6}, piece: whiteKnights[1]}\n\tcells[0][7] = cell{location: location{i: 0, j: 7}, piece: whiteRooks[1]}\n\t//Fill White Pawns in the second row\n\tfor i := 0; i < 8; i++ {\n\t\tcells[1][i] = cell{location: location{i: 0, j: 7}, piece: whitePawns[i]}\n\t}\n\n\t//Fill Black Pieces in the first row\n\tcells[7][0] = cell{location: location{i: 7, j: 0}, piece: blackRooks[0]}\n\tcells[7][1] = cell{location: location{i: 7, j: 1}, piece: blackKnights[0]}\n\tcells[7][2] = cell{location: location{i: 7, j: 2}, piece: blackBishops[0]}\n\tcells[7][3] = cell{location: location{i: 7, j: 3}, piece: blackKing}\n\tcells[7][4] = cell{location: location{i: 7, j: 4}, piece: blackQueen}\n\tcells[7][5] = cell{location: location{i: 7, j: 5}, piece: blackBishops[1]}\n\tcells[7][6] = cell{location: location{i: 7, j: 6}, piece: blackKnights[1]}\n\tcells[7][7] = cell{location: location{i: 7, j: 7}, piece: blackRooks[1]}\n\t//Fill Black Pawns in the second row\n\tfor i := 0; i < 8; i++ {\n\t\tcells[6][i] = cell{location: location{i: 0, j: 7}, piece: blackPawns[i]}\n\t}\n\n\tboard := &board{\n\t\tsquare:    cells,\n\t\tdimension: 8,\n\t}\n\n\tplayer1 := humanPlayer{\n\t\twhite: true,\n\t\tid:    1,\n\t}\n\n\tplayer2 := computerPlayer{\n\t\twhite: false,\n\t\tid:    1,\n\t}\n\n\tgame := initGame(board, player1, player2)\n\tgame.play()\n\tgame.printResult()\n}\n\nfunc makePieces(isWhite bool) (*king, *queen, [2]*rook, [2]*bishop, [2]*knight, [8]*pawn) {\n\n\tking := &king{\n\t\twhite: isWhite,\n\t}\n\n\tqueen := &queen{\n\t\twhite: isWhite,\n\t}\n\n\trooks := [2]*rook{}\n\tfor i := 0; i < 2; i++ {\n\t\tr := &rook{\n\t\t\twhite: true,\n\t\t}\n\t\trooks[i] = r\n\t}\n\n\tbishops := [2]*bishop{}\n\tfor i := 0; i < 2; i++ {\n\t\tb := &bishop{\n\t\t\twhite: true,\n\t\t}\n\t\tbishops[i] = b\n\t}\n\n\tknights := [2]*knight{}\n\tfor i := 0; i < 2; i++ {\n\t\tk := &knight{\n\t\t\twhite: true,\n\t\t}\n\t\tknights[i] = k\n\t}\n\n\tpawns := [8]*pawn{}\n\tfor i := 0; i < 8; i++ {\n\t\tp := &pawn{\n\t\t\twhite: isWhite,\n\t\t}\n\t\tpawns[i] = p\n\t}\n\n\treturn king, queen, rooks, bishops, knights, pawns\n}\n```"]