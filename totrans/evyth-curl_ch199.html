<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch199.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="libcurl__performance__md-_-_-performance" class="level1" data-number="198">
<h1 data-number="198">Performance</h1>
<p>This section collects general advice on what you can do as an application author to get the maximum performance out of libcurl.</p>
<p>libcurl is designed and intended to run as fast as possible by default. You are expected to get top performance already without doing anything extra in particular. There are however some common things to look at or perhaps mistakes to avoid.</p>
<section id="libcurl__performance__md-_-_-reuse-handles" class="level2" data-number="198.1">
<h2 data-number="198.1">reuse handles</h2>
<p>This is a general mantra whenever libcurl is discussed. If you use the easy interface, the <em>primary</em> key to high performance is to reuse the handles when doing subsequent transfers. That lets libcurl reuse connections, reuse TLS sessions, use its DNS cache as much as possible and more.</p>
</section>
<section id="libcurl__performance__md-_-_-buffer-sizes" class="level2" data-number="198.2">
<h2 data-number="198.2">buffer sizes</h2>
<p>If you download data, set the <code>CURLOPT_BUFFERSIZE</code> to a suitable size. It is on the smaller size from start and especially on high speed transfers, you might be able to get more out of libcurl by increase its size. We encourage you to try out a few sizes in a benchmark with your use case.</p>
<p>Similarly, if you upload data you might want to adjust the <code>CURLOPT_UPLOAD_BUFFERSIZE</code> for the same reasons.</p>
</section>
<section id="libcurl__performance__md-_-_-pool-size" class="level2" data-number="198.3">
<h2 data-number="198.3">pool size</h2>
<p>The number of live connections kept in the connection pool that you set with <code>CURLOPT_MAXCONNECTS</code> can be interesting to tweak. Depending of course how your application uses connections, but if it for example iterates over N hostnames in a short period of time, it could make sense for you to make sure that libcurl can keep all those connections alive.</p>
</section>
<section id="libcurl__performance__md-_-_-make-callbacks-as-fast-as-possible" class="level2" data-number="198.4">
<h2 data-number="198.4">make callbacks as fast as possible</h2>
<p>In high speed data downloads, the write callback is called many times. If this function is not written to execute the fastest possible way, there is a risk that this function alone makes <em>all</em> transfers slower than they otherwise could be.</p>
<p>The same of course goes for the read callback for uploads.</p>
<p>Avoid doing complicated logic or use locks/mutexes in your libcurl callbacks.</p>
</section>
<section id="libcurl__performance__md-_-_-share-data" class="level2" data-number="198.5">
<h2 data-number="198.5">share data</h2>
<p>If you use multiple easy handles, you can still share data and caches between them in order to increase performance. Take a closer look at <a href="ch257.xhtml#helpers__sharing__md">the share API</a>.</p>
</section>
<section id="libcurl__performance__md-_-_-threads" class="level2" data-number="198.6">
<h2 data-number="198.6">threads</h2>
<p>If your transfer thread ends up consuming 100% CPU, then you might benefit from distributing the load onto multiple threads to increase bandwidth.</p>
<p>Normally then, you want to make each thread do transfers as independently as possible to avoid them interfering with each other’s performance or risk getting into thread-safe problems due to shared handles. Try to make the same hostnames get transferred on the same thread so that connection reuse can be optimized.</p>
</section>
<section id="libcurl__performance__md-_-_-curl_multi_socket_action" class="level2" data-number="198.7">
<h2 data-number="198.7"><code>curl_multi_socket_action</code></h2>
<p>If your application performs many parallel transfers, like more than a hundred concurrent ones or so, then you <em>must</em> consider switching to the <code>curl_multi_socket_action()</code> and the event based API instead of the “regular” multi API. That allows and pushes you to use an event based approach which lets your application avoid both <code>poll()</code> and <code>select()</code>, which is key to high performance combined with a high degree of parallelism.</p>
<p><span id="libcurl__cplusplus__md"></span></p>
</section>
</section>
</body>
</html>
