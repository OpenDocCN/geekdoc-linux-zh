["```sh COMMAND <<InputComesFromHERE\n...\n...\n...\nInputComesFromHERE\n```", "```sh command #1\ncommand #2\n...\n```", "```sh interactive-program <<LimitString\ncommand #1\ncommand #2\n...\nLimitString\n```", "```sh #!/bin/bash\n\nwall <<zzz23EndOfMessagezzz23\nE-mail your noontime orders for pizza to the system administrator.\n    (Add an extra dollar for anchovy or mushroom topping.)\n# Additional message text goes here.\n# Note: 'wall' prints comment lines.\nzzz23EndOfMessagezzz23\n\n# Could have been done more efficiently by\n#         wall <message-file\n#  However, embedding the message template in a script\n#+ is a quick-and-dirty one-off solution.\n\nexit\n```", "```sh #!/bin/bash\n\n# Noninteractive use of 'vi' to edit a file.\n# Emulates 'sed'.\n\nE_BADARGS=85\n\nif [ -z \"$1\" ]\nthen\n  echo \"Usage: `basename $0` filename\"\n  exit $E_BADARGS\nfi\n\nTARGETFILE=$1\n\n# Insert 2 lines in file, then save.\n#--------Begin here document-----------#\nvi $TARGETFILE <<x23LimitStringx23\ni\nThis is line 1 of the example file.\nThis is line 2 of the example file.\n^[\nZZ\nx23LimitStringx23\n#----------End here document-----------#\n\n#  Note that ^[ above is a literal escape\n#+ typed by Control-V <Esc>.\n\n#  Bram Moolenaar points out that this may not work with 'vim'\n#+ because of possible problems with terminal interaction.\n\nexit\n```", "```sh #!/bin/bash\n#  Replace all instances of \"Smith\" with \"Jones\"\n#+ in files with a \".txt\" filename suffix. \n\nORIGINAL=Smith\nREPLACEMENT=Jones\n\nfor word in $(fgrep -l $ORIGINAL *.txt)\ndo\n  # -------------------------------------\n  ex $word <<EOF\n  :%s/$ORIGINAL/$REPLACEMENT/g\n  :wq\nEOF\n  # :%s is the \"ex\" substitution command.\n  # :wq is write-and-quit.\n  # -------------------------------------\ndone\n```", "```sh #!/bin/bash\n\n#  'echo' is fine for printing single line messages,\n#+  but somewhat problematic for for message blocks.\n#   A 'cat' here document overcomes this limitation.\n\ncat <<End-of-message\n-------------------------------------\nThis is line 1 of the message.\nThis is line 2 of the message.\nThis is line 3 of the message.\nThis is line 4 of the message.\nThis is the last line of the message.\n-------------------------------------\nEnd-of-message\n\n#  Replacing line 7, above, with\n#+   cat > $Newfile <<End-of-message\n#+       ^^^^^^^^^^\n#+ writes the output to the file $Newfile, rather than to stdout.\n\nexit 0\n\n#--------------------------------------------\n# Code below disabled, due to \"exit 0\" above.\n\n# S.C. points out that the following also works.\necho \"-------------------------------------\nThis is line 1 of the message.\nThis is line 2 of the message.\nThis is line 3 of the message.\nThis is line 4 of the message.\nThis is the last line of the message.\n-------------------------------------\"\n# However, text may not include double quotes unless they are escaped.\n```", "```sh #!/bin/bash\n# Same as previous example, but...\n\n#  The - option to a here document <<-\n#+ suppresses leading tabs in the body of the document,\n#+ but *not* spaces.\n\ncat <<-ENDOFMESSAGE\n\tThis is line 1 of the message.\n\tThis is line 2 of the message.\n\tThis is line 3 of the message.\n\tThis is line 4 of the message.\n\tThis is the last line of the message.\nENDOFMESSAGE\n# The output of the script will be flush left.\n# Leading tab in each line will not show.\n\n# Above 5 lines of \"message\" prefaced by a tab, not spaces.\n# Spaces not affected by   <<-  .\n\n# Note that this option has no effect on *embedded* tabs.\n\nexit 0\n```", "```sh #!/bin/bash\n# Another 'cat' here document, using parameter substitution.\n\n# Try it with no command-line parameters,   ./scriptname\n# Try it with one command-line parameter,   ./scriptname Mortimer\n# Try it with one two-word quoted command-line parameter,\n#                           ./scriptname \"Mortimer Jones\"\n\nCMDLINEPARAM=1     #  Expect at least command-line parameter.\n\nif [ $# -ge $CMDLINEPARAM ]\nthen\n  NAME=$1          #  If more than one command-line param,\n                   #+ then just take the first.\nelse\n  NAME=\"John Doe\"  #  Default, if no command-line parameter.\nfi  \n\nRESPONDENT=\"the author of this fine script\"  \n\ncat <<Endofmessage\n\nHello, there, $NAME.\nGreetings to you, $NAME, from $RESPONDENT.\n\n# This comment shows up in the output (why?).\n\nEndofmessage\n\n# Note that the blank lines show up in the output.\n# So does the comment.\n\nexit\n```", "```sh #!/bin/bash\n# upload.sh\n\n#  Upload file pair (Filename.lsm, Filename.tar.gz)\n#+ to incoming directory at Sunsite/UNC (ibiblio.org).\n#  Filename.tar.gz is the tarball itself.\n#  Filename.lsm is the descriptor file.\n#  Sunsite requires \"lsm\" file, otherwise will bounce contributions.\n\nE_ARGERROR=85\n\nif [ -z \"$1\" ]\nthen\n  echo \"Usage: `basename $0` Filename-to-upload\"\n  exit $E_ARGERROR\nfi  \n\nFilename=`basename $1`           # Strips pathname out of file name.\n\nServer=\"ibiblio.org\"\nDirectory=\"/incoming/Linux\"\n#  These need not be hard-coded into script,\n#+ but may instead be changed to command-line argument.\n\nPassword=\"your.e-mail.address\"   # Change above to suit.\n\nftp -n $Server <<End-Of-Session\n# -n option disables auto-logon\n\nuser anonymous \"$Password\"       #  If this doesn't work, then try:\n                                 #  quote user anonymous \"$Password\"\nbinary\nbell                             # Ring 'bell' after each file transfer.\ncd $Directory\nput \"$Filename.lsm\"\nput \"$Filename.tar.gz\"\nbye\nEnd-Of-Session\n\nexit 0\n```", "```sh #!/bin/bash\n#  A 'cat' here-document, but with parameter substitution disabled.\n\nNAME=\"John Doe\"\nRESPONDENT=\"the author of this fine script\"  \n\ncat <<'Endofmessage'\n\nHello, there, $NAME.\nGreetings to you, $NAME, from $RESPONDENT.\n\nEndofmessage\n\n#   No parameter substitution when the \"limit string\" is quoted or escaped.\n#   Either of the following at the head of the here document would have\n#+  the same effect.\n#   cat <<\"Endofmessage\"\n#   cat <<\\Endofmessage\n\n#   And, likewise:\n\ncat <<\"SpecialCharTest\"\n\nDirectory listing would follow\nif limit string were not quoted.\n`ls -l`\n\nArithmetic expansion would take place\nif limit string were not quoted.\n$((5 + 3))\n\nA a single backslash would echo\nif limit string were not quoted.\n\\\\\n\nSpecialCharTest\n\nexit\n```", "```sh #!/bin/bash\n# generate-script.sh\n# Based on an idea by Albert Reiner.\n\nOUTFILE=generated.sh         # Name of the file to generate.\n\n# -----------------------------------------------------------\n# 'Here document containing the body of the generated script.\n(\ncat <<'EOF'\n#!/bin/bash\n\necho \"This is a generated shell script.\"\n#  Note that since we are inside a subshell,\n#+ we can't access variables in the \"outside\" script.\n\necho \"Generated file will be named: $OUTFILE\"\n#  Above line will not work as normally expected\n#+ because parameter expansion has been disabled.\n#  Instead, the result is literal output.\n\na=7\nb=3\n\nlet \"c = $a * $b\"\necho \"c = $c\"\n\nexit 0\nEOF\n) > $OUTFILE\n# -----------------------------------------------------------\n\n#  Quoting the 'limit string' prevents variable expansion\n#+ within the body of the above 'here document.'\n#  This permits outputting literal strings in the output file.\n\nif [ -f \"$OUTFILE\" ]\nthen\n  chmod 755 $OUTFILE\n  # Make the generated file executable.\nelse\n  echo \"Problem in creating file: \\\"$OUTFILE\\\"\"\nfi\n\n#  This method also works for generating\n#+ C programs, Perl programs, Python programs, Makefiles,\n#+ and the like.\n\nexit 0\n```", "```sh variable=$(cat <<SETVAR\nThis variable\nruns over multiple lines.\nSETVAR\n)\n\necho \"$variable\"\n```", "```sh #!/bin/bash\n# here-function.sh\n\nGetPersonalData ()\n{\n  read firstname\n  read lastname\n  read address\n  read city \n  read state \n  read zipcode\n} # This certainly appears to be an interactive function, but . . .\n\n# Supply input to the above function.\nGetPersonalData <<RECORD001\nBozo\nBozeman\n2726 Nondescript Dr.\nBozeman\nMT\n21226\nRECORD001\n\necho\necho \"$firstname $lastname\"\necho \"$address\"\necho \"$city, $state $zipcode\"\necho\n\nexit 0\n```", "```sh #!/bin/bash\n\n: <<TESTVARIABLES\n${HOSTNAME?}${USER?}${MAIL?}  # Print error message if one of the variables not set.\nTESTVARIABLES\n\nexit $?\n```", "```sh #!/bin/bash\n# commentblock.sh\n\n: <<COMMENTBLOCK\necho \"This line will not echo.\"\nThis is a comment line missing the \"#\" prefix.\nThis is another comment line missing the \"#\" prefix.\n\n&*@!!++=\nThe above line will cause no error message,\nbecause the Bash interpreter will ignore it.\nCOMMENTBLOCK\n\necho \"Exit value of above \\\"COMMENTBLOCK\\\" is $?.\"   # 0\n# No error shown.\necho\n\n#  The above technique also comes in useful for commenting out\n#+ a block of working code for debugging purposes.\n#  This saves having to put a \"#\" at the beginning of each line,\n#+ then having to go back and delete each \"#\" later.\n#  Note that the use of of colon, above, is optional.\n\necho \"Just before commented-out code block.\"\n#  The lines of code between the double-dashed lines will not execute.\n#  ===================================================================\n: <<DEBUGXXX\nfor file in *\ndo\n cat \"$file\"\ndone\nDEBUGXXX\n#  ===================================================================\necho \"Just after commented-out code block.\"\n\nexit 0\n\n######################################################################\n#  Note, however, that if a bracketed variable is contained within\n#+ the commented-out code block,\n#+ then this could cause problems.\n#  for example:\n\n#/!/bin/bash\n\n  : <<COMMENTBLOCK\n  echo \"This line will not echo.\"\n  &*@!!++=\n  ${foo_bar_bazz?}\n  $(rm -rf /tmp/foobar/)\n  $(touch my_build_directory/cups/Makefile)\nCOMMENTBLOCK\n\n$ sh commented-bad.sh\ncommented-bad.sh: line 3: foo_bar_bazz: parameter null or not set\n\n# The remedy for this is to strong-quote the 'COMMENTBLOCK' in line 49, above.\n\n  : <<'COMMENTBLOCK'\n\n# Thank you, Kurt Pfeifle, for pointing this out.\n```", "```sh #!/bin/bash\n# self-document.sh: self-documenting script\n# Modification of \"colm.sh\".\n\nDOC_REQUEST=70\n\nif [ \"$1\" = \"-h\"  -o \"$1\" = \"--help\" ]     # Request help.\nthen\n  echo; echo \"Usage: $0 [directory-name]\"; echo\n  sed --silent -e '/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p' \"$0\" &#124;\n  sed -e '/DOCUMENTATIONXX$/d'; exit $DOC_REQUEST; fi\n\n: <<DOCUMENTATIONXX\nList the statistics of a specified directory in tabular format.\n---------------------------------------------------------------\nThe command-line parameter gives the directory to be listed.\nIf no directory specified or directory specified cannot be read,\nthen list the current working directory.\n\nDOCUMENTATIONXX\n\nif [ -z \"$1\" -o ! -r \"$1\" ]\nthen\n  directory=.\nelse\n  directory=\"$1\"\nfi  \n\necho \"Listing of \"$directory\":\"; echo\n(printf \"PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\\n\" \\\n; ls -l \"$directory\" &#124; sed 1d) &#124; column -t\n\nexit 0\n```", "```sh DOC_REQUEST=70\n\nif [ \"$1\" = \"-h\"  -o \"$1\" = \"--help\" ]     # Request help.\nthen                                       # Use a \"cat script\" . . .\n  cat <<DOCUMENTATIONXX\nList the statistics of a specified directory in tabular format.\n---------------------------------------------------------------\nThe command-line parameter gives the directory to be listed.\nIf no directory specified or directory specified cannot be read,\nthen list the current working directory.\n\nDOCUMENTATIONXX\nexit $DOC_REQUEST\nfi\n```", "```sh bash$ **bash -c 'lsof -a -p $$ -d0' << EOF**\n> **EOF**\nlsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)\n\n```", "```sh #!/bin/bash\n\necho \"----------------------------------------------------------------------\"\n\ncat <<LimitString\necho \"This is line 1 of the message inside the here document.\"\necho \"This is line 2 of the message inside the here document.\"\necho \"This is the final line of the message inside the here document.\"\n     LimitString\n#^^^^Indented limit string. Error! This script will not behave as expected.\n\necho \"----------------------------------------------------------------------\"\n\n#  These comments are outside the 'here document',\n#+ and should not echo.\n\necho \"Outside the here document.\"\n\nexit 0\n\necho \"This line had better not echo.\"  # Follows an 'exit' command.\n```", "```sh # This works.\ncat <<!\nHello!\n! Three more exclamations !!!\n!\n\n# But . . .\ncat <<!\nHello!\nSingle exclamation point follows!\n!\n!\n# Crashes with an error message.\n\n# However, the following will work.\ncat <<EOF\nHello!\nSingle exclamation point follows!\n!\nEOF\n# It's safer to use a multi-character limit string.\n```"]