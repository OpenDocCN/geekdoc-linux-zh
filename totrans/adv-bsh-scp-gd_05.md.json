["```sh # This line is a comment.\n```", "```sh echo \"A comment will follow.\" # Comment here.\n#                            ^ Note whitespace before #\n```", "```sh      # A tab precedes this comment.\n```", "```sh initial=( `cat \"$startfile\" &#124; sed -e '/#/d' &#124; tr -d '\\n' &#124;\\\n# Delete lines containing '#' comment character.\n           sed -e 's/\\./\\. /g' -e 's/_/_ /g'` )\n# Excerpted from life.sh script\n```", "```sh echo \"The # here does not begin a comment.\"\necho 'The # here does not begin a comment.'\necho The \\# here does not begin a comment.\necho The # here begins a comment.\n\necho ${PATH#*:}       # Parameter substitution, not a comment.\necho $(( 2#101011 ))  # Base conversion, not a comment.\n\n# Thanks, S.C.\n```", "```sh echo hello; echo there\n\nif [ -x \"$filename\" ]; then    #  Note the space after the semicolon.\n#+                   ^^\n  echo \"File $filename exists.\"; cp $filename $filename.bak\nelse   #                       ^^\n  echo \"File $filename not found.\"; touch $filename\nfi; echo \"File test complete.\"\n```", "```sh case \"$variable\" in\n  abc)  echo \"\\$variable = abc\" ;;\n  xyz)  echo \"\\$variable = xyz\" ;;\nesac\n```", "```sh bash$ **touch .hidden-file**\nbash$ **ls -l**\t      \ntotal 10\n -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook\n -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak\n -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook\n\nbash$ **ls -al**\t      \ntotal 14\n drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./\n drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../\n -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook\n -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak\n -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook\n -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file\n\n```", "```sh bash$ **pwd**\n/home/bozo/projects\n\nbash$ **cd .**\nbash$ **pwd**\n/home/bozo/projects\n\nbash$ **cd ..**\nbash$ **pwd**\n/home/bozo/\n\n```", "```sh bash$ **cp /home/bozo/current_work/junk/* .**\n\n```", "```sh let \"t2 = ((a = 9, 15 / 3))\"\n# Set \"a = 9\" and \"t2 = 15 / 3\"\n```", "```sh for file in /{,usr/}bin/*calc\n#             ^    Find all executable files ending in \"calc\"\n#+                 in /bin and /usr/bin directories.\ndo\n        if [ -x \"$file\" ]\n        then\n          echo $file\n        fi\ndone\n\n# /bin/ipcalc\n# /usr/bin/kcalc\n# /usr/bin/oidcalc\n# /usr/bin/oocalc\n\n# Thank you, Rory Winston, for pointing this out.\n```", "```sh :\necho $?   # 0\n```", "```sh while :\ndo\n   operation-1\n   operation-2\n   ...\n   operation-n\ndone\n\n# Same as:\n#    while true\n#    do\n#      ...\n#    done\n```", "```sh if condition\nthen :   # Do nothing and branch ahead\nelse     # Or else ...\n   take-some-action\nfi\n```", "```sh : ${username=`whoami`}\n# ${username=`whoami`}   Gives an error without the leading :\n#                        unless \"username\" is a command or builtin...\n\n: ${1?\"Usage: $0 ARGUMENT\"}     # From \"usage-message.sh example script.\n```", "```sh : ${HOSTNAME?} ${USER?} ${MAIL?}\n#  Prints error message\n#+ if one or more of essential environmental variables not set.\n```", "```sh : > data.xxx   # File \"data.xxx\" now empty.\t      \n\n# Same effect as   cat /dev/null >data.xxx\n# However, this does not fork a new process, since \":\" is a builtin.\n```", "```sh : This is a comment that generates an error, ( if [ $x -eq 3] ).\n```", "```sh bash$ **echo $PATH**\n/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games\n```", "```sh :()\n{\n  echo \"The name of this function is \"$FUNCNAME\" \"\n  # Why use a colon as a function name?\n  # It's a way of obfuscating your code.\n}\n\n:\n\n# The name of this function is :\n```", "```sh not_empty ()\n{\n  :\n} # Contains a : (null command), and so is not empty.\n```", "```sh bash$ **echo ***\nabs-book.sgml add-drive.sh agram.sh alias.sh\n\n```", "```sh (( var0 = var1<98?9:21 ))\n#                ^ ^\n\n# if [ \"$var1\" -lt 98 ]\n# then\n#   var0=9\n# else\n#   var0=21\n# fi\n```", "```sh var1=5\nvar2=23skidoo\n\necho $var1     # 5\necho $var2     # 23skidoo\n```", "```sh (a=hello; echo $a)\n```", "```sh a=123\n( a=321; )\t      \n\necho \"a = $a\"   # a = 123\n# \"a\" within parentheses acts like a local variable.\n```", "```sh Array=(element1 element2 element3)\n```", "```sh echo \\\"{These,words,are,quoted}\\\"   # \" prefix and suffix\n# \"These\" \"words\" \"are\" \"quoted\"\n\ncat {file1,file2,file3} > combined_file\n# Concatenates the files file1, file2, and file3 into combined_file.\n\ncp file22.{txt,backup}\n# Copies \"file22.txt\" to \"file22.backup\"\n```", "```sh echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z\n# Echoes characters between a and z.\n\necho {0..3} # 0 1 2 3\n# Echoes characters between 0 and 3.\n\nbase64_charset=( {A..Z} {a..z} {0..9} + / = )\n# Initializing an array, using extended brace expansion.\n# From vladz's \"base64.sh\" example script.\n```", "```sh bash$ **{ local a;\n\t      a=123; }**\nbash: local: can only be used in a\nfunction\n\n```", "```sh a=123\n{ a=321; }\necho \"a = $a\"   # a = 321   (value inside code block)\n\n# Thanks, S.C.\n```", "```sh #!/bin/bash\n# Reading lines in /etc/fstab.\n\nFile=/etc/fstab\n\n{\nread line1\nread line2\n} < $File\n\necho \"First line in $File is:\"\necho \"$line1\"\necho\necho \"Second line in $File is:\"\necho \"$line2\"\n\nexit 0\n\n# Now, how do you parse the separate fields of each line?\n# Hint: use awk, or . . .\n# . . . Hans-Joerg Diers suggests using the \"set\" Bash builtin.\n```", "```sh #!/bin/bash\n# rpm-check.sh\n\n#  Queries an rpm file for description, listing,\n#+ and whether it can be installed.\n#  Saves output to a file.\n# \n#  This script illustrates using a code block.\n\nSUCCESS=0\nE_NOARGS=65\n\nif [ -z \"$1\" ]\nthen\n  echo \"Usage: `basename $0` rpm-file\"\n  exit $E_NOARGS\nfi  \n\n{ # Begin code block.\n  echo\n  echo \"Archive Description:\"\n  rpm -qpi $1       # Query description.\n  echo\n  echo \"Archive Listing:\"\n  rpm -qpl $1       # Query listing.\n  echo\n  rpm -i --test $1  # Query whether rpm file can be installed.\n  if [ \"$?\" -eq $SUCCESS ]\n  then\n    echo \"$1 can be installed.\"\n  else\n    echo \"$1 cannot be installed.\"\n  fi  \n  echo              # End code block.\n} > \"$1.test\"       # Redirects output of everything in block to file.\n\necho \"Results of rpm test in file $1.test\"\n\n# See rpm man page for explanation of options.\n\nexit 0\n```", "```sh ls . &#124; xargs -i -t cp ./{} $1\n#            ^^         ^^\n\n# From \"ex42.sh\" (copydir.sh) example.\n```", "```sh Array[1]=slot_1\necho ${Array[1]}\n```", "```sh a=3\nb=7\n\necho $[$a+$b]   # 10\necho $[$a*$b]   # 21\n```", "```sh bash$ **type bogus_command &>/dev/null**\n `bash$` `**echo $?**`\n`1` \n```", "```sh command_test () { type \"$1\" &>/dev/null; }\n#                                      ^\n\ncmd=rmdir            # Legitimate command.\ncommand_test $cmd; echo $?   # 0\n\ncmd=bogus_command    # Illegitimate command\ncommand_test $cmd; echo $?   # 1\n```", "```sh veg1=carrots\nveg2=tomatoes\n\nif [[ \"$veg1\" < \"$veg2\" ]]\nthen\n  echo \"Although $veg1 precede $veg2 in the dictionary,\"\n  echo -n \"this does not necessarily imply anything \"\n  echo \"about my culinary preferences.\"\nelse\n  echo \"What kind of dictionary are you using, anyhow?\"\nfi\n```", "```sh echo ls -l &#124; sh\n#  Passes the output of \"echo ls -l\" to the shell,\n#+ with the same result as a simple \"ls -l\".\n\ncat *.lst &#124; sort &#124; uniq\n# Merges and sorts all \".lst\" files, then deletes duplicate lines.\n```", "```sh #!/bin/bash\n# uppercase.sh : Changes input to uppercase.\n\ntr 'a-z' 'A-Z'\n#  Letter ranges must be quoted\n#+ to prevent filename generation from single-letter filenames.\n\nexit 0\n```", "```sh bash$ **ls -l &#124; ./uppercase.sh**\n-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT\n -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT\n -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE\n\n```", "```sh cat file1 file2 &#124; ls -l &#124; sort\n# The output from \"cat file1 file2\" disappears.\n```", "```sh variable=\"initial_value\"\necho \"new_value\" &#124; read variable\necho \"variable = $variable\"     # variable = initial_value\n```", "```sh bash$ **sleep 10 &**\n[1] 850\n[1]+  Done                    sleep 10\n\n```", "```sh #!/bin/bash\n# background-loop.sh\n\nfor i in 1 2 3 4 5 6 7 8 9 10            # First loop.\ndo\n  echo -n \"$i \"\ndone & # Run this loop in background.\n       # Will sometimes execute after second loop.\n\necho   # This 'echo' sometimes will not display.\n\nfor i in 11 12 13 14 15 16 17 18 19 20   # Second loop.\ndo\n  echo -n \"$i \"\ndone  \n\necho   # This 'echo' sometimes will not display.\n\n# ======================================================\n\n# The expected output from the script:\n# 1 2 3 4 5 6 7 8 9 10 \n# 11 12 13 14 15 16 17 18 19 20 \n\n# Sometimes, though, you get:\n# 11 12 13 14 15 16 17 18 19 20 \n# 1 2 3 4 5 6 7 8 9 10 bozo $\n# (The second 'echo' doesn't execute. Why?)\n\n# Occasionally also:\n# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n# (The first 'echo' doesn't execute. Why?)\n\n# Very rarely something like:\n# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 \n# The foreground loop preempts the background one.\n\nexit 0\n\n#  Nasimuddin Ansari suggests adding    sleep 1\n#+ after the   echo -n \"$i\"   in lines 6 and 14,\n#+ for some real fun.\n```", "```sh if [ $file1 -ot $file2 ]\nthen #      ^\n  echo \"File $file1 is older than $file2.\"\nfi\n\nif [ \"$a\" -eq \"$b\" ]\nthen #    ^\n  echo \"$a is equal to $b.\"\nfi\n\nif [ \"$c\" -eq 24 -a \"$d\" -eq 47 ]\nthen #    ^              ^\n  echo \"$c equals 24 and $d equals 47.\"\nfi\n\nparam2=${param1:-$DEFAULTVAL}\n#               ^\n```", "```sh bash$ **ls -l**\n-rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname\n\nbash$ **rm -- -badname**\n\nbash$ **ls -l**\ntotal 0\n```", "```sh bash$ **cat -**\n**abc**\nabc\n\n...\n\n**Ctl-D**\n```", "```sh (cd /source/directory && tar cf - . ) &#124; (cd /dest/directory && tar xpvf -)\n# Move entire file tree from one directory to another\n# [courtesy Alan Cox <a.cox@swansea.ac.uk>, with a minor change]\n\n# 1) cd /source/directory\n#    Source directory, where the files to be moved are.\n# 2) &&\n#   \"And-list\": if the 'cd' operation successful,\n#    then execute the next command.\n# 3) tar cf - .\n#    The 'c' option 'tar' archiving command creates a new archive,\n#    the 'f' (file) option, followed by '-' designates the target file\n#    as stdout, and do it in current directory tree ('.').\n# 4) &#124;\n#    Piped to ...\n# 5) ( ... )\n#    a subshell\n# 6) cd /dest/directory\n#    Change to the destination directory.\n# 7) &&\n#   \"And-list\", as above\n# 8) tar xpvf -\n#    Unarchive ('x'), preserve ownership and file permissions ('p'),\n#    and send verbose messages to stdout ('v'),\n#    reading data from stdin ('f' followed by '-').\n#\n#    Note that 'x' is a command, and 'p', 'v', 'f' are options.\n#\n# Whew!\n\n# More elegant than, but equivalent to:\n#   cd source/directory\n#   tar cf - . &#124; (cd ../dest/directory; tar xpvf -)\n#\n#     Also having same effect:\n# cp -a /source/directory/* /dest/directory\n#     Or:\n# cp -a /source/directory/* /source/directory/.[^.]* /dest/directory\n#     If there are hidden files in /source/directory.\n```", "```sh bunzip2 -c linux-2.6.16.tar.bz2 &#124; tar xvf -\n#  --uncompress tar file--      &#124; --then pass it to \"tar\"--\n#  If \"tar\" has not been patched to handle \"bunzip2\",\n#+ this needs to be done in two discrete steps, using a pipe.\n#  The purpose of the exercise is to unarchive \"bzipped\" kernel source.\n```", "```sh bash$ **echo \"whatever\" &#124; cat -**\nwhatever \n```", "```sh bash$ **file**\nUsage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...\n\n```", "```sh bash$ **file -**\n**abc**\nstandard input:              ASCII text\n\nbash$ **file -**\n**#!/bin/bash**\nstandard input:              Bourne-Again shell script text executable\n\n```", "```sh #!/bin/bash\n\n#  Backs up all files in current directory modified within last 24 hours\n#+ in a \"tarball\" (tarred and gzipped file).\n\nBACKUPFILE=backup-$(date +%m-%d-%Y)\n#                 Embeds date in backup filename.\n#                 Thanks, Joshua Tschida, for the idea.\narchive=${1:-$BACKUPFILE}\n#  If no backup-archive filename specified on command-line,\n#+ it will default to \"backup-MM-DD-YYYY.tar.gz.\"\n\ntar cvf - `find . -mtime -1 -type f -print` > $archive.tar\ngzip $archive.tar\necho \"Directory $PWD backed up in archive file \\\"$archive.tar.gz\\\".\"\n\n#  Stephane Chazelas points out that the above code will fail\n#+ if there are too many files found\n#+ or if any filenames contain blank characters.\n\n# He suggests the following alternatives:\n# -------------------------------------------------------------------\n#   find . -mtime -1 -type f -print0 &#124; xargs -0 tar rvf \"$archive.tar\"\n#      using the GNU version of \"find\".\n\n#   find . -mtime -1 -type f -exec tar rvf \"$archive.tar\" '{}' \\;\n#         portable to other UNIX flavors, but much slower.\n# -------------------------------------------------------------------\n\nexit 0\n```", "```sh var=\"-n\"\necho $var\t\t\n# Has the effect of \"echo -n\", and outputs nothing.\n```", "```sh a=28\necho $a   # 28\n```", "```sh let \"z = 5 % 3\"\necho $z  # 2\n```", "```sh bash$ **echo ~bozo**\n/home/bozo\n\nbash$ **echo ~**\n/home/bozo\n\nbash$ **echo ~/**\n/home/bozo/\n\nbash$ **echo ~:**\n/home/bozo:\n\nbash$ **echo ~nonexistent-user**\n~nonexistent-user\n\n```", "```sh #!/bin/bash\n    # Embedding Ctl-H in a string.\n\n    a=\"^H^H\"                  # Two Ctl-H's -- backspaces\n                              # ctl-V ctl-H, using vi/vim\n    echo \"abcdef\"             # abcdef\n    echo\n    echo -n \"abcdef$a \"       # abcd f\n    #  Space at end  ^              ^  Backspaces twice.\n    echo\n    echo -n \"abcdef$a\"        # abcdef\n    #  No space at end               ^ Doesn't backspace (why?).\n                              # Results may not be quite as expected.\n    echo; echo\n\n    # Constantin Hagemeier suggests trying:\n    # a=$'\\010\\010'\n    # a=$'\\b\\b'\n    # a=$'\\x08\\x08'\n    # But, this does not change the results.\n\n    ########################################\n\n    # Now, try this.\n\n    rubout=\"^H^H^H^H^H\"       # 5 x Ctl-H.\n\n    echo -n \"12345678\"\n    sleep 2\n    echo -n \"$rubout\"\n    sleep 2\n    ```", "```sh #!/bin/bash\n    # Thank you, Lee Maschmeyer, for this example.\n\n    read -n 1 -s -p \\\n    $'Control-M leaves cursor at beginning of this line. Press Enter. \\x0d'\n               # Of course, '0d' is the hex equivalent of Control-M.\n    echo >&2   #  The '-s' makes anything typed silent,\n               #+ so it is necessary to go to new line explicitly.\n\n    read -n 1 -s -p $'Control-J leaves cursor on next line. \\x0a'\n               #  '0a' is the hex equivalent of Control-J, linefeed.\n    echo >&2\n\n    ###\n\n    read -n 1 -s -p $'And Control-K\\x0bgoes straight down.'\n    echo >&2   #  Control-K is vertical tab.\n\n    # A better example of the effect of a vertical tab is:\n\n    var=$'\\x0aThis is the bottom line\\x0bThis is the top line\\x0a'\n    echo \"$var\"\n    #  This works the same way as the above example. However:\n    echo \"$var\" &#124; col\n    #  This causes the right end of the line to be higher than the left end.\n    #  It also explains why we started and ended with a line feed --\n    #+ to avoid a garbled screen.\n\n    # As Lee Maschmeyer explains:\n    # --------------------------\n    #  In the [first vertical tab example] . . . the vertical tab\n    #+ makes the printing go straight down without a carriage return.\n    #  This is true only on devices, such as the Linux console,\n    #+ that can't go \"backward.\"\n    #  The real purpose of VT is to go straight UP, not down.\n    #  It can be used to print superscripts on a printer.\n    #  The col utility can be used to emulate the proper behavior of VT.\n\n    exit 0\n    ```", "```sh echo -e '\\x0a'\n    echo <Ctl-V><Ctl-J>\n    ```", "```sh ls &#124; { read firstline; read secondline; }\n#  Error. The code block in braces runs as a subshell,\n#+ so the output of \"ls\" cannot be passed to variables within the block.\necho \"First line is $firstline; second line is $secondline\"  # Won't work.\n\n# Thanks, S.C.\n```"]