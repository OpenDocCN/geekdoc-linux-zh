- en: Pastebin System Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pastebin 系统设计
- en: 原文：[https://techbyexample.com/pastebin-system-design/](https://techbyexample.com/pastebin-system-design/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://techbyexample.com/pastebin-system-design/](https://techbyexample.com/pastebin-system-design/)
- en: Table of Contents
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: '[Overview](#Overview "Overview")'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[概览](#Overview "概览")'
- en: '[Functional Requirements](#Functional_Requirements "Functional Requirements")'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[功能性需求](#Functional_Requirements "功能性需求")'
- en: '[Non Functional Requirements](#Non_Functional_Requirements "Non Functional
    Requirements")'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[非功能性需求](#Non_Functional_Requirements "非功能性需求")'
- en: '[Capacity Estimate](#Capacity_Estimate "Capacity Estimate")'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[容量估算](#Capacity_Estimate "容量估算")'
- en: '[Traffic Estimation](#Traffic_Estimation "Traffic Estimation")'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[流量估算](#Traffic_Estimation "流量估算")'
- en: '[Data Estimation](#Data_Estimation "Data Estimation")'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据估算](#Data_Estimation "数据估算")'
- en: '[Text Upload](#Text_Upload "Text Upload")'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文本上传](#Text_Upload "文本上传")'
- en: '[Image Upload](#Image_Upload "Image Upload")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图片上传](#Image_Upload "图片上传")'
- en: '[Database Schema](#Database_Schema "Database Schema")'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库架构](#Database_Schema "数据库架构")'
- en: '[Text Storage](#Text_Storage "Text Storage")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文本存储](#Text_Storage "文本存储")'
- en: '[Image Storage](#Image_Storage "Image Storage")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图片存储](#Image_Storage "图片存储")'
- en: '[User Table](#User_Table "User Table")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用户表](#User_Table "用户表")'
- en: '[Paste Table](#Paste_Table "Paste Table")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Paste 表](#Paste_Table "Paste 表")'
- en: '[How Unique URLs will be generated](#How_Unique_URLs_will_be_generated "How
    Unique URLs will be generated")'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何生成唯一的 URL](#How_Unique_URLs_will_be_generated "如何生成唯一的 URL")'
- en: '[High-Level Design](#High-Level_Design "High-Level Design")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[高级设计](#High-Level_Design "高级设计")'
- en: '[Paste Bin Service](#Paste_Bin_Service "Paste Bin Service")'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Paste Bin 服务](#Paste_Bin_Service "Paste Bin 服务")'
- en: '[For Upload](#For_Upload "For Upload")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[上传](#For_Upload "上传")'
- en: '[For download](#For_download "For download")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[下载](#For_download "下载")'
- en: '[Key Generation Service](#Key_Generation_Service "Key Generation Service")'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[密钥生成服务](#Key_Generation_Service "密钥生成服务")'
- en: '[Database Schema](#Database_Schema-2 "Database Schema")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库架构](#Database_Schema-2 "数据库架构")'
- en: '[Which Database to Use](#Which_Database_to_Use "Which Database to Use")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用哪个数据库](#Which_Database_to_Use "使用哪个数据库")'
- en: '[How to resolve concurrency issues](#How_to_resolve_concurrency_issues "How
    to resolve concurrency issues")'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何解决并发问题](#How_to_resolve_concurrency_issues "如何解决并发问题")'
- en: '[How to recover key_prefix](#How_to_recover_key_prefix "How to recover key_prefix")'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何恢复 key_prefix](#How_to_recover_key_prefix "如何恢复 key_prefix")'
- en: '[What happens if the key ranges are getting exhausted](#What_happens_if_the_key_ranges_are_getting_exhausted
    "What happens if the key ranges are getting exhausted")'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如果密钥范围耗尽会发生什么](#What_happens_if_the_key_ranges_are_getting_exhausted "如果密钥范围耗尽会发生什么")'
- en: '[What if the PasteBin never expires](#What_if_the_PasteBin_never_expires "What
    if the PasteBin never expires")'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如果 PasteBin 永不过期会怎样](#What_if_the_PasteBin_never_expires "如果 PasteBin 永不过期会怎样")'
- en: '[Is not KGS service a single point of failure?](#Is_not_KGS_service_a_single_point_of_failure
    "Is not KGS service a single point of failure?")'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[KGS 服务不是单点故障吗？](#Is_not_KGS_service_a_single_point_of_failure "KGS 服务不是单点故障吗？")'
- en: '[Other common components](#Other_common_components "Other common components")'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[其他常见组件](#Other_common_components "其他常见组件")'
- en: '[Non-Functional Requirements](#Non-Functional_Requirements "Non-Functional
    Requirements")'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[非功能性需求](#Non-Functional_Requirements "非功能性需求")'
- en: '[Scalability](#Scalability "Scalability")'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可扩展性](#Scalability "可扩展性")'
- en: '[Low latency](#Low_latency "Low latency")'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[低延迟](#Low_latency "低延迟")'
- en: '[Availability](#Availability "Availability")'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可用性](#Availability "可用性")'
- en: '[Alerting and Monitoring](#Alerting_and_Monitoring "Alerting and Monitoring")'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[告警与监控](#Alerting_and_Monitoring "告警与监控")'
- en: '[Moving closer to user location](#Moving_closer_to_user_location "Moving closer
    to user location")'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[向用户位置靠近](#Moving_closer_to_user_location "向用户位置靠近")'
- en: '[Avoiding Single Point of Failures](#Avoiding_Single_Point_of_Failures "Avoiding
    Single Point of Failures")'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免单点故障](#Avoiding_Single_Point_of_Failures "避免单点故障")'
- en: '[Conclusion](#Conclusion "Conclusion")'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结论](#Conclusion "结论")'
- en: '**Overview**'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**概览**'
- en: First, let’s look at the definition of **Pastebin**.  Pastebin service allows
    you to share text and images over a link which can be shared with multiple users.
    So basically **Pastebin** is a service that allows you to share data temporarily
    over a link.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下**Pastebin**的定义。Pastebin 服务允许你通过链接共享文本和图片，这些链接可以与多个用户共享。所以，基本上**Pastebin**是一种允许你通过链接暂时共享数据的服务。
- en: Requirement analysis is a critical part of any system design question. It is
    divided into two parts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需求分析是任何系统设计问题中的关键部分。它分为两个部分。
- en: '**Functional Requirements** – Defines the Business Requirements'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能需求** – 定义业务需求'
- en: '**Non-Functional Requirements** – Defines the quality attributes of a system
    such as performance, scalability, security, etc.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能需求** – 定义系统的质量属性，如性能、可扩展性、安全性等。'
- en: Let’s see some of the functional and non-functional requirements of the **Pastebin**
    service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 **Pastebin** 服务的一些功能性和非功能性需求。
- en: '**Functional Requirements**'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**功能需求**'
- en: Users should be able to paste the text or upload an image and then share that
    text or image using a unique URL which will be generated by the Pastebin service
    with others
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够粘贴文本或上传图像，并通过粘贴本服务生成的唯一 URL 与其他人共享该文本或图像
- en: Users should be able to set expiry for an URL. If not specified by default the
    expiry would be 1 week
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够为 URL 设置过期时间。如果没有指定，默认过期时间为 1 周
- en: Users can be either logged in or anonymous
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以是登录状态或匿名状态
- en: The user should be able to log in and view the pastebins that have been generated
    by him
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够登录并查看自己生成的粘贴本
- en: Other users can access the paste text content or image whenever they access
    the paste URL.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他用户可以在访问粘贴 URL 时访问粘贴的文本内容或图像。
- en: '**Non Functional Requirements**'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**非功能需求**'
- en: The system should be highly durable. The unique URL once generated should persist.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该具有高持久性。一旦生成的唯一 URL 应该能够持续存在。
- en: The system should be strongly consistent. What it means is that once a paste
    is generated then the system should be able to return that paste in the next immediate
    call.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该具备强一致性。这意味着一旦生成粘贴本，系统应该能够在下一个即时请求中返回该粘贴本。
- en: The system should be highly available
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该具有高可用性
- en: The system should be fault-tolerant
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该具备容错能力
- en: There should be no single point of failure
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该没有单点故障
- en: '**Capacity Estimate**'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**容量估算**'
- en: We will do a capacity estimate for three things
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对三项内容进行容量估算
- en: Network Estimation
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络估算
- en: Data Estimation
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据估算
- en: Traffic Estimation
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量估算
- en: '**Traffic Estimation**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流量估算**'
- en: Assume the number of active users per day 200K
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设每日活跃用户数为 200K
- en: Number of pastebins created – 200K
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建的粘贴本数量 – 200K
- en: Each of the pastebins created is read 10 times. Total read – 200K*10 = 2000K
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个创建的粘贴本被读取 10 次。总读取量 = 200K*10 = 2000K
- en: So our system is more read-heavy than write**–**heavySo total writes per sec
    = 200K/24*60*60 ~ 3 requests/sec.Considering peak traffic = 200 request/sec.Total
    read per sec = 2000K/24*60*60 – 30 requests/secConsidering peak traffic = 2000
    request/sec
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的系统比写操作更偏向读取操作 —— 所以每秒写入请求总数 = 200K/24*60*60 ~ 3 请求/秒。考虑到峰值流量 = 200 请求/秒。每秒读取请求总数
    = 2000K/24*60*60 – 30 请求/秒。考虑到峰值流量 = 2000 请求/秒
- en: '**Data Estimation**'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据估算**'
- en: While creating Pastebin a user can specify either text or an image. Assume the
    max text size that is allowed to the user is 5MB and the maximum image size is
    10 MB.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建 Pastebin 时，用户可以指定文本或图像。假设用户允许的最大文本大小为 5MB，最大图像大小为 10MB。
- en: Also, assume that the ratio of  text upload vs image upload is 9:1
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，假设文本上传与图像上传的比例为 9:1
- en: '**Text Upload**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文本上传**'
- en: Number of text upload = 180K
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本上传数量 = 180K
- en: Max size of text upload – 5MB
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大文本上传大小 – 5MB
- en: Average size of text upload – 10KB
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均文本上传大小 – 10KB
- en: Total Size per day = 10KB * 180K = 1.8 GB per day
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每日总大小 = 10KB * 180K = 每日 1.8 GB
- en: Assume no paste is getting expired, then the total size required for 3 years
    will be = 1.8*3*365 ~= 2TB
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设没有粘贴会过期，那么3年所需的总大小为 = 1.8*3*365 ~= 2TB
- en: '**Image Upload**'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图像上传**'
- en: Number of image upload = 20K
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像上传数量 = 20K
- en: Max size of text upload – 10MB
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大文本上传大小 – 10MB
- en: Average size of image upload – 100KB
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均图像上传大小 – 100KB
- en: Total Size per day = 100KB * 20K = 2 GB per day
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每日总大小 = 100KB * 20K = 每日 2 GB
- en: Assume no paste is getting expired, then the total size required for 3 years
    will be = 2*3*365 ~= 2.2TB
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设没有粘贴会过期，那么3年所需的总大小为 = 2*3*365 ~= 2.2TB
- en: Total Size Needed = 2TB + 2.2TB  =~ 4.2 TB for 3 years
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所需总大小 = 2TB + 2.2TB  ~= 4.2 TB（三年内）
- en: '**Database Schema**'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数据库架构**'
- en: We need to store each paste created by the user along with the corresponding
    text or image. As we already mentioned that text can go up to the size of 5MB
    and image can go up to the size of 10 MB.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要存储用户创建的每个粘贴本以及相应的文本或图像。如前所述，文本大小可以达到 5MB，图像大小可以达到 10MB。
- en: We cannot store images in the database otherwise it will be a bad design as
    there will be much database IO involved. Also storing text could also be not stored
    in the database if it is larger in size. So below strategy can be adopted for
    text and image storage
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将图像存储在数据库中，否则会是一个糟糕的设计，因为这样会涉及大量的数据库 IO。同时，如果文本的大小较大，存储文本也不应放入数据库。因此，以下策略可以用于文本和图像的存储。
- en: '**Text Storage**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文本存储**'
- en: If the text is less than 10 KB then it can be stored as part of the database.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文本小于 10 KB，则可以将其作为数据库的一部分存储。
- en: If not then the text will be stored in blob storage. We can use Amazon S3 here.
    The link of the S3 will be stored in the database
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，则文本将存储在 Blob 存储中。我们可以在这里使用 Amazon S3。S3 的链接将存储在数据库中
- en: '**Image Storage**'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图像存储**'
- en: The image will always be stored in S3
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像将始终存储在 S3 中
- en: We don’t have any ACID requirements so we can use No SQL databases to store
    the paste that will be created. We can use Cassandra Database in this case.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有任何 ACID 要求，因此可以使用 No SQL 数据库来存储将要创建的粘贴。在这种情况下，我们可以使用 Cassandra 数据库。
- en: We will have the below tables
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有以下表
- en: User Table
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户表
- en: Paste Table
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粘贴表
- en: '**User Table**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户表**'
- en: It will have below fields
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它将包含以下字段
- en: '**user_id**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user_id**'
- en: '**user_name**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user_name**'
- en: '**password_encrypted**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**password_encrypted**'
- en: '**created**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**created**'
- en: '**updated**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**updated**'
- en: '**Paste Table**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**粘贴表**'
- en: It will have below fields
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它将包含以下字段
- en: '**paste_id** – It will be a UUID'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**paste_id** – 它将是一个 UUID'
- en: '**paste_type** – It will either text or image'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**paste_type** – 它可以是文本或图像'
- en: '**text** – If the paste_type is text and text size is less than 10kb then it
    will be populated'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**text** – 如果 paste_type 是文本并且文本大小小于 10KB，则将填充该字段'
- en: '**s3_url** – Populated in two conditions. If the paste_type is text and text
    size is greater than 10kb. When the paste_type is an image'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s3_url** – 在两种情况下填充。如果 paste_type 是文本且文本大小大于 10KB，或者 paste_type 是图像时。'
- en: '**user_id**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user_id**'
- en: '**created**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**created**'
- en: '**updated**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**updated**'
- en: '**How Unique URLs will be generated**'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**如何生成唯一的 URL**'
- en: Since the paste is meant to be created and also share with other users it will
    be good if we have a short URL generated so that it is easy to share. So now we
    will look at how we can generate the short URL for the paste. For that, we will
    have another service called Key Generation Service that will be used to generate
    a short key which then will be used in the created paste URL
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于粘贴是为了创建并与其他用户共享，如果我们能够生成一个短链接以方便分享会更好。因此，我们现在将查看如何为粘贴生成短链接。为此，我们将有另一个服务，称为密钥生成服务，用于生成一个短密钥，该密钥将用于创建的粘贴
    URL。
- en: '**High-Level Design**'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**高层次设计**'
- en: On a high level let’s discuss what will be the higher flow and what all services
    would exist.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 高层次地，我们先讨论一下更高层次的流程以及将会存在的所有服务。
- en: There will be an **API gateway** on which every request from all the users will
    land.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将会有一个 **API 网关**，所有用户的请求都会通过这个网关。
- en: There will be a **Pastebin** service. This service holds the responsibility
    of generating all the paste URLs.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将会有一个 **Pastebin** 服务。该服务负责生成所有粘贴 URL。
- en: There will be a **Key Generation Service**  that holds the responsibility of
    generation of short keys
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将会有一个 **Key Generation Service** 服务，负责生成短密钥
- en: The **Pastebin** service will call the key generation service whenever it needs
    new keys.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pastebin** 服务将在需要新的密钥时调用密钥生成服务。'
- en: When the **Pastebin** service has exhausted all the key ranges it will publish
    a Kafka/SNS message specifying that the key ranges have been exhausted.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 **Pastebin** 服务用尽所有密钥范围时，它将发布一个 Kafka/SNS 消息，说明密钥范围已被用尽。
- en: This message will be picked by a **Key Recovery** service which will be a worker.
    It will mark the key range as free so that it can be picked again.  This worker
    will also delete the paste created for all the keys in the range from the database.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该消息将由 **Key Recovery** 服务接收，该服务是一个工作进程。它将标记密钥范围为可用，这样可以再次选择该范围。该工作进程还将从数据库中删除所有密钥范围内创建的粘贴。
- en: We will cache the latest paste created as they are more likely to be shared
    and accessed after they are created
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将缓存最新创建的粘贴，因为它们更有可能在创建后被共享和访问
- en: Below is the high-level diagram of the service
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该服务的高层次图示
- en: '![](../Images/670bd24c89724e87a31eb2ff94ec892d.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/670bd24c89724e87a31eb2ff94ec892d.png)'
- en: Let’s see some of the details of the **Paste Bin** service and the **Key Generation**
    Service
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 **Paste Bin** 服务和 **Key Generation** 服务的一些细节
- en: '**Paste Bin Service**'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Paste Bin 服务**'
- en: This service will be the interface to all the APIs that exist in our system.
    The PasteBin service will expose an API to create the paste as well as it will
    also expose an API to read that paste.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务将成为我们系统中所有API的接口。PasteBin服务将暴露一个创建粘贴的API，并且还会暴露一个读取粘贴的API。
- en: '**Create Paste** – It will interact with the Key Generation Service to get
    the short keys. These keys will be used for generating the URL. It will then make
    an entry into the database for that paste. It will also make an entry into the
    cache.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建粘贴** – 它将与密钥生成服务交互，获取短密钥。这些密钥将用于生成URL。然后，它将为该粘贴在数据库中创建一个条目，并且还会在缓存中创建一个条目。'
- en: '**Read Paste** – It will first see if the paste already exists in the cache.
    If yes then it will return that paste. If not it will fetch the paste from the
    database.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取粘贴** – 它将首先检查粘贴是否已存在于缓存中。如果存在，它将返回该粘贴；如果不存在，它将从数据库中获取粘贴。'
- en: Making Create and Read Paste more efficient When text is in KBs or when paste
    contains an image then creating as well as reading paste via PaateBin service
    is a challenge. Here we can do one optimization. We can directly upload the large
    text or image to the Blob Storage which could be Amazon S3 or HDFS. How do we
    do that
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 提高创建和读取粘贴的效率：当文本是KB级别或粘贴中包含图片时，通过PasteBin服务创建和读取粘贴会面临挑战。在这种情况下，我们可以进行一种优化：直接将大文本或图片上传到Blob存储（如Amazon
    S3或HDFS）。我们是如何做到的呢？
- en: '**For Upload**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**上传**'
- en: Let’s User A wants to create a Paste that contains an image. The client will
    send a request to the server to send the presigned URL to which the client can
    upload the image
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设用户A想要创建一个包含图片的粘贴。客户端将向服务器发送请求，请求一个预签名URL，以便客户端上传图片。
- en: The server will respond with a pre-signed URL whose validity can be of few hours.
    You can read this article to get an idea of the pre-signed URL [https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html)
    . Basically, it is an URL that is already signed with a token and hence it can
    be used to directly upload to that URL without requiring any further authentication.
    This is also called direct upload. The server will also return the image_id here
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将响应一个预签名URL，其有效期可能是几小时。你可以阅读这篇文章了解预签名URL的相关信息：[https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html)。基本上，这个URL已经用令牌签名，因此可以直接用于上传，无需进一步的身份验证。这也叫做直接上传。服务器还将返回`image_id`。
- en: The client will upload the image to that URL. It will directly be stored in
    S3
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端将把图片上传到该URL。它将直接存储到S3中。
- en: Now the client will call the Create Paste API. While calling the Create Paste
    API, it will pass in the image_id in the request body as well. The server will
    then have the image_id. Since it has image_id, it will know that the image corresponding
    to the Paste has already been uploaded to the Blob Storage which is S3 here. It
    will save the path as a field while saving the paste in DB
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在客户端将调用创建粘贴API。在调用创建粘贴API时，它也会在请求体中传递`image_id`。服务器将接收到该`image_id`。由于它有`image_id`，它将知道与粘贴对应的图片已经上传到Blob存储，这里指的是S3。它会在将粘贴保存到数据库时，将路径作为字段保存。
- en: With the above approach, we prevent bytes of image or text via the PasteBin
    service which is an optimization in terms of cost and performance
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述方法，我们避免了通过PasteBin服务传输大量的图片或文本字节，从而在成本和性能上进行了一种优化。
- en: '**For download**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**下载**'
- en: User A has created a paste that will be shared with User B. So user B will be
    reading the paste
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户A已创建一个粘贴，并将与用户B共享。所以用户B将阅读该粘贴。
- en: While reading, the reverse happens. The PasteBin service fetches the paste from
    cache or DB.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取时，过程正好相反。PasteBin服务从缓存或数据库中获取粘贴内容。
- en: Once it fetches the paste, it will see if it contains a large text or image.
    If yes then it will fetch the S3 location from the DB.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦它获取到粘贴内容，它将检查是否包含大文本或图片。如果是，它将从数据库中获取S3位置。
- en: Then it will generate a Presigned URL again for that S3 location. The client
    is returned both the paste information as well the S3 URL
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它会为该S3位置生成一个预签名URL。客户端将同时返回粘贴信息和S3 URL。
- en: Using this Presigned S3 URL, the client can directly download the corresponding
    big paste or image file.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个预签名S3 URL，客户端可以直接下载相应的大粘贴或图片文件。
- en: '**Key Generation Service**'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**密钥生成服务**'
- en: There will be a KGS service that holds the responsibility of generating the
    keys. First, let’s see what should be the length of each key. Possible options
    of length are 6,7,8\. Only base64 URL-safe characters could be used to generate
    the key. Therefore
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有一个KGS服务，负责生成键。首先，让我们看看每个键的长度应该是多少。可能的长度选项为6、7、8。只能使用Base64 URL安全字符来生成键。因此，
- en: For 6- We have 64^6= 68.7 billion options
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于6—我们有64^6 = 68.7亿个选项
- en: For 7 – We have 64^7 = ~3500 Billion options
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于7—我们有64^7 = 约3500亿个选项
- en: For 8 – We have 64^8= trillion options
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于8—我们有64^8 = 万亿个选项
- en: We can now assume that 68.7 billion entries will be enough so we can have 6
    characters for the key.  Now the question is how these are going to be maintained
    in the Database. If we are storing 68 billion entries in the database then it
    might be too many entries and a waste of resources.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以假设687亿条记录足够，所以我们可以为键分配6个字符。现在的问题是这些键如何在数据库中进行维护。如果我们在数据库中存储687亿条记录，可能会有太多条记录，且浪费资源。
- en: One option is to store ranges of keys in the databases. We can have a range
    of 64 where we only store the first five characters which will act as a prefix
    for all 64 keys which can be generated from this prefix.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将键范围存储在数据库中。我们可以有一个64的范围，在该范围内仅存储前五个字符，这些字符将作为前缀，用于从该前缀生成的所有64个键。
- en: Let’s say we have the below prefix
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下前缀
- en: adcA2
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: adcA2
- en: Then below 64 keys can be generated from this
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以从此生成下列64个键
- en: '**adcA2[a-z]** – 26 keys'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**adcA2[a-z]** – 26个键'
- en: '**adcA2[A-Z]** – 26 keys'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**adcA2[A-Z]** – 26个键'
- en: '**adcA2[0-9]** – 10 keys'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**adcA2[0-9]** – 10个键'
- en: '**adcA2[-_]** – 2 keys'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**adcA2[-_]** – 2个键'
- en: We can store these ranges in DB. So for 6 characters, we will have overall 64^5
    entries in the database. The keys will be returned by the Key Service to the Tiny
    URL services in ranges and batches only. The Tiny URL service will then use this
    prefix to generate 64 keys and serve 64 different create tiny URL requests. This
    is optimization as the **PasteBin** service only needs to call the Key Generation
    Service only when it has exhausted all its 64 keys. So there will be one call
    from **PasteBin** service to the Key Generation Service for generating 64 short
    URLsLet’s now see the points for the KGS service
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些范围存储在数据库中。因此，对于6个字符，我们将总共在数据库中存储64^5条记录。键将通过键服务按范围和批次返回给Tiny URL服务。Tiny
    URL服务然后使用此前缀生成64个键，并处理64个不同的创建短网址请求。这是优化，因为**PasteBin**服务只有在用尽所有64个键时才需要调用键生成服务。所以**PasteBin**服务将向键生成服务发出一次调用来生成64个短网址。接下来我们来看KGS服务的要点
- en: Database Schema
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库架构
- en: Which database to use
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哪个数据库
- en: How to resolve concurrency issues
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解决并发问题
- en: How to recover key_prefix
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何恢复 key_prefix
- en: What happens if the key ranges are getting exhausted
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键范围耗尽会发生什么情况
- en: What if the paste never expires
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果粘贴内容永不过期怎么办
- en: Is not KGS service a single point of failure?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KGS服务不是单点故障吗？
- en: '**Database Schema**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据库架构**'
- en: There will just be a single table that will store the range of keys i.e prefix.
    Below will be the fields in the table
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将只有一个表来存储键范围，即前缀。以下是该表中的字段
- en: '**key_prefix**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key_prefix**'
- en: '**key_length** – It will always be 6 for now. These fields exist if we need
    7 length keys in any scenario'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**key_length** – 目前始终为6。这个字段存在，是为了在任何情况下需要7个长度的键时使用。'
- en: '**used** – If this is true then the key prefix is currently in use. If false
    then it is free to be used'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**used** – 如果为真，则表示键前缀当前正在使用中。如果为假，则表示可以使用。'
- en: '**created**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**created**'
- en: '**updated**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**updated**'
- en: '**Which Database to Use**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用哪个数据库**'
- en: We don’t have any ACID requirements so we can use the No SQL database. Also,
    we might have very large data to save as well so No SQL might be better suited. 
    This system will be a write-heavy as well as a read-heavy system. So we can use
    **Cassandra Database** here. We can do the capacity estimates of the DB and based
    on that we can decide on the number of shards we want to have. Each of the shards
    would be properly replicated as well
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有任何ACID要求，因此可以使用No SQL数据库。此外，我们可能还需要保存非常大的数据，所以No SQL可能更合适。这个系统将是一个写重型和读重型的系统。所以我们可以在这里使用**Cassandra数据库**。我们可以根据数据库的容量估算来决定我们想要的分片数。每个分片也会被适当复制。
- en: There is one more optimization we can do here to improve the latency. We can
    refill free key ranges in the cache and the KGS service can directly pick from
    there instead of going to the database every time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个优化可以减少延迟。我们可以在缓存中重新填充空闲的键范围，KGS服务可以直接从缓存中获取，而不是每次都去数据库。
- en: '**How to resolve concurrency issues**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何解决并发问题**'
- en: It could very well happen that two requests see the same prefix or range as
    free. Since there are multiple servers reading from the key DB simultaneously
    we might have a scenario where two or more servers read the same key as free from
    the key DB. There are two ways to resolve the concurrency issues we just mentioned
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能发生两个请求看到相同的前缀或范围为空闲状态。由于多个服务器同时从密钥数据库读取，我们可能会遇到两个或多个服务器同时将相同的密钥视为空闲的情况。我们刚才提到的并发问题有两种方式可以解决。
- en: Two or more servers read the same key but only one server will be able to mark
    that **key_prefix** as used in the database. Concurrency is at DB level that is
    each row is locked before being updated and we can leverage that here. Db will
    return back to the server whether any record was updated or not. If the record
    was not updated then the server can fetch a new key. If the record was updated
    then that server has got the right key.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两台或更多的服务器读取相同的密钥，但只有一台服务器能在数据库中将该**key_prefix**标记为已使用。并发性发生在数据库级别，即每一行在更新之前都会被锁定，我们可以在这里利用这一点。数据库将返回给服务器，告知记录是否已被更新。如果记录未被更新，则服务器可以获取新的密钥。如果记录已更新，则该服务器已获得正确的密钥。
- en: The other option is to use a transaction that does Find and Update in one transaction.
    Each Find and Update will return a unique key_prefix every time. This is probably
    not a recommended option because of the load it puts on the database
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种选择是使用一个事务，在一个事务中完成查找和更新。每次查找和更新都会返回一个唯一的 `key_prefix`。这可能不是推荐的选项，因为它会增加数据库的负担
- en: '**How to recover key_prefix**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何恢复key_prefix**'
- en: Tiny URL service once it has exhausted the range of keys, then it will enter
    that range into another table from which it can be recovered and put back as free
    after 2 weeks. We know for sure that after two weeks the keys will be free as
    we have an expiry of two weeks
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Tiny URL服务耗尽了密钥范围，它将把该范围插入到另一个表中，经过2周后可以从中恢复并重新标记为空闲。我们可以确定，经过两周后这些密钥会是空闲的，因为我们设置了2周的过期时间。
- en: '**What happens if the key ranges are getting exhausted**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如果密钥范围耗尽会发生什么**'
- en: This will be an unexpected condition. There will be a background worker that
    will check if the key ranges are getting exhausted. If yes then it can generate
    ranges for 7 length keys. But how it will know if the key ranges are getting exhausted.
    For keeping a rough count there could be another table that will store the user
    count of used keys.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个意外情况。将有一个后台工作进程检查密钥范围是否耗尽。如果是，它可以为7位长度的密钥生成新范围。但如何知道密钥范围是否耗尽呢？为了保持粗略计数，可能会有另一个表用来存储已使用密钥的用户数量。
- en: Whenever any range is allotted by the KGS to Tiny URL service it will publish
    a message that will be picked by a synchronous worker that is going to decrease
    the count of used keys by 1.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当KGS将一个范围分配给Tiny URL服务时，它会发布一条消息，该消息会被一个同步工作进程接收，该工作进程将减少已使用密钥的计数。
- en: Similarly, whenever a range is free we can increment this counter.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，每当一个范围是空闲的，我们可以增加这个计数器。
- en: '**What if the PasteBin never expires**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如果PasteBin永不过期会怎样**'
- en: It is easy to extend the above service to serve paste that never expires.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易扩展上述服务来处理永不过期的粘贴内容。
- en: Just that our short string will not be limited to 6 length characters. We can
    use 7 lengths, 8 length characters, or even 9 lengths as the need arises.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只是我们的短字符串不会局限于6位字符。我们可以根据需要使用7位、8位甚至9位字符。
- en: There will be no **key recovery** service
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不提供**密钥恢复**服务
- en: Once a **key_range** has been allotted we can remove it from the key DB as it
    is never meant to be freed or recovered
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦**key_range**被分配，我们可以将其从密钥数据库中移除，因为它永远不需要被释放或恢复。
- en: '**Is not KGS service a single point of failure?**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**KGS服务不是单点故障吗？**'
- en: To prevent it we will have proper replication of the key database. Also, there
    will be multiple app servers for the service itself. We will also have proper
    autoscaling set up. We can also have Disaster Management
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们将对密钥数据库进行适当的复制。此外，服务本身将有多个应用服务器。我们还将设置适当的自动扩展机制，并可以进行灾难恢复管理。
- en: '**Other common components**'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**其他常见组件**'
- en: Other common components could be
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见组件可能包括
- en: User Service – It holds the user profile information.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户服务 – 它保存用户的个人信息。
- en: Token/Auth Service – Management of User tokens
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌/认证服务 – 用户令牌的管理
- en: SMS Service- It is used for sending any kind of message back to the user. For
    example – OTP
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信服务 – 用于将任何类型的消息发送回用户。例如 – OTP
- en: Analytics Service – This could be used to track any kind of analytics
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析服务 – 这可以用来追踪任何类型的分析
- en: '**Non-Functional Requirements**'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**非功能性需求**'
- en: Let’s discuss some non-functional requirements now
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些非功能性需求。
- en: '**Scalability**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**可扩展性**'
- en: The first thing to consider with the above design is the scalability factor.
    The scalability of each of the components in the system is very important. Here
    are scalability challenges you can face and their possible resolutions
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述设计中需要首先考虑的因素是可扩展性。系统中每个组件的可扩展性非常重要。以下是您可能会遇到的可扩展性挑战及其可能的解决方案：
- en: Each of the machines in the **paste_bin** service and **KGS** service could
    only serve a limited number of requests. Hence each service here should have proper
    autoscaling set in so that based on the number of requests we can add instances
    up and autoscale them when needed
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**paste_bin**服务和**KGS**服务中的每台机器只能处理有限数量的请求。因此，每个服务都应该有合适的自动扩展设置，以便根据请求的数量，我们可以添加实例并在需要时进行自动扩展。'
- en: Your Kafka/SNS system might not be able to take that much load. We can scale
    horizontally but to a limit. If that is becoming a bottleneck then depending upon
    the geography or userId we can have two or more such systems. Service discovery
    could be used to figure out which Kafka system a request needs to go to.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的Kafka/SNS系统可能无法承受如此大的负载。我们可以进行水平扩展，但有其限度。如果这成为瓶颈，那么根据地理位置或用户ID，我们可以拥有两个或更多这样的系统。可以使用服务发现来确定请求应该发送到哪个Kafka系统。
- en: Another important factor of scalability here is that we have designed our system
    in such a way so that none of the services is bogged with too many things to do.
    There is a separation of concerns and wherever there was too much of a responsibility
    on service, we have broken it down
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性的另一个重要因素是，我们设计系统时确保没有任何服务被过多的任务拖累。我们进行了关注点分离，并且在任何服务承担过多责任的地方，都进行了拆分。
- en: '**Low latency**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**低延迟**'
- en: We can cache the newly created paste when it is created with some expiry of
    course. As and when a paste is created it is more likely to be accessed in some
    time. It will reduce latency for many of the read calls.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以缓存新创建的paste，并设置一定的过期时间。每当一个paste被创建时，它更可能在短时间内被访问。这样可以减少许多读取请求的延迟。
- en: We also created batches of key or key ranges. This prevents the Paste Bin service
    to call the KGS service every time and overall improves the latency.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还创建了键或键范围的批次。这可以防止Paste Bin服务每次都调用KGS服务，整体上提高了延迟表现。
- en: There is one more optimization we can do here to improve the latency. We can
    refill free key ranges in the cache and the KGS service can directly pick from
    there instead of going to the database every time.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个优化可以在这里进行，以提高延迟。我们可以在缓存中重新填充空闲的键范围，KGS服务可以直接从缓存中获取数据，而不是每次都去访问数据库。
- en: '**Availability**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**可用性**'
- en: In order for the system to be highly available, it is very important to have
    redundancy/backups for almost all components in the system. Here are some of the
    things that need to be done.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使系统具有高可用性，几乎所有组件都需要冗余/备份。以下是需要完成的一些事项。
- en: In the case of our DB, we need to enable replication. There should be multiple
    slaves for each of the master shard nodes.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的数据库，需要启用复制。每个主分片节点应该有多个从节点。
- en: For Redis we also need replication.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Redis，我们也需要实现复制。
- en: For data redundancy, we could be multi-region as well. This could be one of
    the benefits if one of the regions goes down.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据冗余，我们也可以实现多区域部署。如果某个区域出现故障，这将是其中一个好处。
- en: Disaster Recovery could also be set up
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以设置灾难恢复
- en: '**Alerting and Monitoring**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**警报和监控**'
- en: Alerting and Monitoring is also very important non-functional requirement. We
    should monitor each of our services and set up proper alerts as well. Some of
    the things that could be monitored are
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 警报和监控也是非常重要的非功能性需求。我们应该监控每一个服务，并设置合适的警报。可以监控的内容包括：
- en: API Response Time
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API响应时间
- en: Memory Consumption
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存消耗
- en: CPU Consumption
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 消耗
- en: Disk Space Consumption
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘空间消耗
- en: Queue Length
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列长度
- en: ….
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ….
- en: '**Moving closer to user location**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**向用户位置靠近**'
- en: There are a couple of architectures that could be followed here. One such is
    Cell Architecture. You can read more about cell architecture here – [https://github.com/wso2/reference-architecture/blob/master/reference-architecture-cell-based.md](https://github.com/wso2/reference-architecture/blob/master/reference-architecture-cell-based.md)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以采用几种架构方案。其中之一是单元架构。您可以在这里阅读更多关于单元架构的内容：[https://github.com/wso2/reference-architecture/blob/master/reference-architecture-cell-based.md](https://github.com/wso2/reference-architecture/blob/master/reference-architecture-cell-based.md)
- en: '**Avoiding Single Point of Failures**'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**避免单点故障**'
- en: A single point of failure is that part of a system that when stops working then
    it would lead the entire system to fail. We should try to prevent any single point
    of failure as well in our design. By redundancy and going multi-region we can
    prevent such things
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 单点故障是指系统中某个部分停止工作时，会导致整个系统崩溃的情况。我们在设计时应该尽量避免任何单点故障。通过冗余设计和多区域部署，我们可以防止这种情况发生。
- en: '**Conclusion**'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This is all about the system design of **Pastebin** service.  Hoped you have
    liked this article. Please share feedback in the comments
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章是关于**Pastebin**服务的系统设计。希望你喜欢这篇文章。请在评论中分享反馈。
