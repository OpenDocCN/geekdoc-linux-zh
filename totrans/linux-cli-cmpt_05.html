<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Managing Files and Directories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Managing Files and Directories</h1>
<blockquote>原文：<a href="https://learnbyexample.github.io/cli-computing/managing-files-directories.html">https://learnbyexample.github.io/cli-computing/managing-files-directories.html</a></blockquote><p>This chapter presents commands to do things that are typically handled by a file manager in GUI (also known as file explorer). For example, viewing contents of a directory, navigating to other directories, cut/copy/paste files, renaming files and so on. Some of the commands used for these purposes are provided by the shell itself.</p><p>As a good practice, make it a habit to go through the documentation of the commands you encounter. Getting used to looking up documentation from the command line will come in handy whenever you are stuck. You can also learn and experiment with options you haven't used yet.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files">example_files</a> directory has the scripts used in this chapter. See the <a href="./introduction-setup.html#setup">Setup</a> section for instructions to create the working environment.</p></blockquote><h2 id="builtin-and-external-commands"><a class="header" href="#builtin-and-external-commands">Builtin and External commands</a></h2><p>From <a href="https://www.gnu.org/software/bash/manual/bash.html#What-is-a-shell_003f">bash manual: What is a shell?</a></p><blockquote><p>Shells also provide a small set of built-in commands (builtins) implementing functionality impossible or inconvenient to obtain via separate utilities. For example, <code>cd</code>, <code>break</code>, <code>continue</code>, and <code>exec</code> cannot be implemented outside of the shell because they directly manipulate the shell itself. The <code>history</code>, <code>getopts</code>, <code>kill</code>, or <code>pwd</code> builtins, among others, could be implemented in separate utilities, but they are more convenient to use as builtin commands.</p></blockquote><p>Many of the commands needed for everyday use are external commands, i.e. not part of the shell. Some builtins, <code>pwd</code> for example, might also be available as external command on your system (and these might have differences in features too). In such cases the builtin version will be executed by default, which you can override by using the path of the external version.</p><p>You can use the <code>type</code> command to check if the tool you are using is a builtin or an external command. The <code>type</code> command is a shell builtin, and provides other features too (which will be discussed later). You can use the <code>-a</code> option to get <em>all</em> details about the given command.</p><pre><code class="language-bash">$ type -a cd
cd is a shell builtin

$ type -a ls
ls is /bin/ls

$ type -a pwd
pwd is a shell builtin
pwd is /bin/pwd
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> To look up documentation, use the <code>help</code> command for builtins and <code>man</code> for external commands (or <code>info</code> for complete documentation, where applicable). Use <code>help help</code> and <code>man man</code> for their own documentation.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Typing just <code>help</code> will give the list of builtins, along with the command's syntax.</p></blockquote><h2 id="pwd"><a class="header" href="#pwd">pwd</a></h2><p><code>pwd</code> is a shell builtin command to get the current working directory. This helps to orient yourself with respect to the filesystem. The absolute path printed is often handy to copy-paste elsewhere, in a script for example. Some users prefer their terminal emulators and/or shell prompt to always display the current working directory.</p><pre><code class="language-bash">$ pwd
/home/learnbyexample
</code></pre><h2 id="cd"><a class="header" href="#cd">cd</a></h2><p><code>cd</code> is another shell builtin. This helps to change the current working directory. Here's an example of changing the current working directory using an absolute path:</p><pre><code class="language-bash">$ pwd
/home/learnbyexample

# specifying / at end of the path is optional
$ cd /etc
$ pwd
/etc
</code></pre><p>You can use <code>-</code> as an argument to go back to the previous working directory. Continuing from the previous example:</p><pre><code class="language-bash">$ cd -
/home/learnbyexample
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Most commands will treat strings starting with <code>-</code> as a command option. You can use <code>--</code> to tell commands that all the following arguments should <em>not</em> be treated as options even if they start with <code>-</code>. For example, if you have a folder named <code>-oops</code> in the current working directory, you can use <code>cd -- -oops</code> to switch to that directory.</p></blockquote><p>Relative paths are well, relative to the current working directory:</p><ul><li><code>.</code> refers to the current directory</li><li><code>..</code> refers to the directory one hierarchy above (i.e. the parent directory)</li><li><code>../..</code> refers to the directory two hierarchies above and so on</li><li><code>cd ./-</code> will help you to switch to a directory named <code>-</code> in the current location <ul><li>you cannot use <code>cd -</code> since that'll take you to the previous working directory</li></ul></li></ul><pre><code class="language-bash">$ pwd
/home/learnbyexample

# go one hierarchy above
$ cd ..
$ pwd
/home

# change to 'learnbyexample' present in the current directory
# './' is optional in this case
$ cd ./learnbyexample
$ pwd
/home/learnbyexample

# go two hierarchies above
$ cd ../..
$ pwd
/
</code></pre><p>You can switch to the home directory using <code>cd</code> or <code>cd ~</code> or <code>cd ~/</code> from anywhere in the filesystem. This is determined by the value stored in the <code>HOME</code> shell variable. See also <a href="https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html">bash manual: Tilde Expansion</a>.</p><pre><code class="language-bash">$ pwd
/
$ echo "$HOME"
/home/learnbyexample

$ cd
$ pwd
/home/learnbyexample
</code></pre><h2 id="clear"><a class="header" href="#clear">clear</a></h2><p>You can use this command to clear the terminal screen. By default, the <code>clear</code> command will move the prompt to the top of the terminal as well as try to remove the contents of the scrollback buffer. You can use the <code>-x</code> option if you want to retain the scrollback buffer contents.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The <code>Ctrl+l</code> shortcut will also move the prompt line to the top of the terminal. It will retain any text you've typed on the prompt line and scrollback buffer contents won't be cleared.</p></blockquote><h2 id="ls"><a class="header" href="#ls">ls</a></h2><p>When you use a file explorer GUI application, you'll automatically see the directory contents. And such GUI apps typically have features to show file size, differentiate between files and folders and so on. <code>ls</code> is the equivalent command line tool with a plethora of options and functionality related to viewing the contents of directories.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> As mentioned earlier, the <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files">example_files</a> directory has the scripts used in this chapter. You can source the <code>ls.sh</code> script to follow along the examples shown in this section. See the <a href="./introduction-setup.html#setup">Setup</a> section if you haven't yet created the working environment.</p><pre><code class="language-bash"># first, cd into the 'scripts' directory
$ cd cli-computing/example_files/scripts

$ ls
cp.sh  file.sh  globs.sh  ls.sh  rm.sh    tar.sh
du.sh  find.sh  grep.sh   mv.sh  stat.sh  touch.sh

# 'ls.sh' script will create a directory named 'ls_examples'
# and automatically change to that directory as well
$ source ls.sh
$ pwd
/home/learnbyexample/cli-computing/example_files/scripts/ls_examples
</code></pre></blockquote><p>By default, the current directory contents are displayed. You can pass one or more paths as arguments. Here are some examples:</p><pre><code class="language-bash">$ ls
backups     hello_world.py  ip.txt    report.log  todos
errors.log  hi              projects  scripts

# example with a single path argument
$ ls /sys
block  class  devices   fs          kernel  power
bus    dev    firmware  hypervisor  module

# multiple paths example
# directory listings will be preceded by their names
$ ls projects backups ip.txt
ip.txt

backups:
bookmarks.html  dot_files

projects:
calculator  tictactoe
</code></pre><p>You can use the <code>-1</code> option (<code>1</code> as in numeric one, not the letter <code>l</code> which does something else) to list the contents in a single column:</p><pre><code class="language-bash">$ ls -1 backups
bookmarks.html
dot_files
</code></pre><p>The <code>-F</code> option appends a character to each filename indicating the file type (if it is other than a regular file):</p><ul><li><code>/</code> directory</li><li><code>*</code> executable file</li><li><code>@</code> symbolic link</li><li><code>|</code> FIFO</li><li><code>=</code> socket</li><li><code>&gt;</code> door</li></ul><pre><code class="language-bash">$ ls -F
backups/    hello_world.py*  ip.txt     report.log  todos/
errors.log  hi*              projects/  scripts@
</code></pre><p>If you just need to distinguish between files and directories, you can use the <code>-p</code> option:</p><pre><code class="language-bash">$ ls -p
backups/    hello_world.py  ip.txt     report.log  todos/
errors.log  hi              projects/  scripts
</code></pre><p>You can also use the <code>--color</code> option to visually distinguish file types:</p><p align="center"><img alt="example with --color option" src="../Images/a6116ee6f319066c4c2a48019a3c88c2.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/ls_color.png"/></p><p>The <code>-l</code> option displays the contents using a long listing format. You'll get details like file permissions, ownership, size, timestamp and so on. The first character of the first column distinguishes file types as <code>d</code> for directories, <code>-</code> for regular files, <code>l</code> for symbolic links, etc. Under each directory listing, the first line will display the total size of the entries (in terms of KB).</p><pre><code class="language-bash">$ ls -l hi
-rwxrwxr-x 1 learnbyexample learnbyexample 21 Dec  5  2019 hi

# you can add -G option to avoid the group column
$ ls -lG
total 7516
drwxrwxr-x 3 learnbyexample    4096 Feb  4 09:23 backups
-rw-rw-r-- 1 learnbyexample   12345 Jan  1 03:30 errors.log
-rwxrwxr-x 1 learnbyexample      42 Feb 29  2020 hello_world.py
-rwxrwxr-x 1 learnbyexample      21 Dec  5  2019 hi
-rw-rw-r-- 1 learnbyexample      10 Jul 21  2017 ip.txt
drwxrwxr-x 4 learnbyexample    4096 Mar  5 11:21 projects
-rw-rw-r-- 1 learnbyexample 7654321 Jan  1 01:01 report.log
lrwxrwxrwx 1 learnbyexample      13 May  7 15:17 scripts -&gt; ../../scripts
drwxrwxr-x 2 learnbyexample    4096 Apr  6 13:19 todos
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> Note that the timestamps showing hours and minutes instead of year depends on the relative difference with respect to the current time. So, for example, you might get <code>Feb  4  2022</code> instead of <code>Feb  4 09:23</code>.</p></blockquote><p>Use the <code>-h</code> option to show file sizes in human readable format (default is byte count).</p><pre><code class="language-bash">$ ls -lG report.log
-rw-rw-r-- 1 learnbyexample 7654321 Jan  1 01:01 report.log

$ ls -lhG report.log
-rw-rw-r-- 1 learnbyexample 7.3M Jan  1 01:01 report.log
</code></pre><p>You can use the <code>-s</code> option instead of long listing if you only need allocated file sizes and names:</p><pre><code class="language-bash">$ ls -1sh errors.log report.log
 16K errors.log
7.4M report.log
</code></pre><p>There are several options for changing the order of listing:</p><ul><li><code>-t</code> sorts by timestamp</li><li><code>-S</code> sorts by file size (not suitable for directories)</li><li><code>-v</code> version sorting (suitable for filenames with numbers in them)</li><li><code>-X</code> sorts by file extension (i.e. characters after the last <code>.</code> in the filename)</li><li><code>-r</code> reverse the listing order</li></ul><pre><code class="language-bash">$ ls -lGhtr
total 7.4M
-rw-rw-r-- 1 learnbyexample   10 Jul 21  2017 ip.txt
-rwxrwxr-x 1 learnbyexample   21 Dec  5  2019 hi
-rwxrwxr-x 1 learnbyexample   42 Feb 29  2020 hello_world.py
-rw-rw-r-- 1 learnbyexample 7.3M Jan  1 01:01 report.log
-rw-rw-r-- 1 learnbyexample  13K Jan  1 03:30 errors.log
drwxrwxr-x 3 learnbyexample 4.0K Feb  4 09:23 backups
drwxrwxr-x 4 learnbyexample 4.0K Mar  5 11:21 projects
drwxrwxr-x 2 learnbyexample 4.0K Apr  6 13:19 todos
lrwxrwxrwx 1 learnbyexample   13 May  7 15:17 scripts -&gt; ../../scripts
</code></pre><p>Filenames starting with <code>.</code> are considered as hidden files and these are NOT shown by default. You can use the <code>-a</code> option to view them. The <code>-A</code> option is similar, but doesn't show the special <code>.</code> and <code>..</code> entries.</p><pre><code class="language-bash"># . and .. point to the current and parent directories respectively
$ ls -aF backups/dot_files/
./  ../  .bashrc  .inputrc  .vimrc

# -A will exclude the . and .. entries
$ ls -A backups/dot_files/
.bashrc  .inputrc  .vimrc
</code></pre><p>The <code>-R</code> option recursively lists sub-directories as well:</p><pre><code class="language-bash">$ ls -ARF
.:
backups/    hello_world.py*  .hidden  projects/   scripts@
errors.log  hi*              ip.txt   report.log  todos/

./backups:
bookmarks.html  dot_files/

./backups/dot_files:
.bashrc  .inputrc  .vimrc

./projects:
calculator/  tictactoe/

./projects/calculator:
calc.sh

./projects/tictactoe:
game.py

./todos:
books.txt  outing.txt
</code></pre><p>Often you'd want to list only specific files or directories based on some criteria, file extension for example. The shell provides a matching technique called <strong>globs</strong> or <strong>wildcards</strong>. Some simple examples are shown below (see the <a href="./shell-features.html#wildcards">wildcards</a> section for more details).</p><p><code>*</code> is a placeholder for zero or more characters:</p><pre><code class="language-bash"># *.py *.log will give filenames ending with '.py' or '.log'
$ echo *.py *.log
hello_world.py errors.log report.log

# glob expansion can be prevented by using quotes
$ echo '*.py' *.log
*.py errors.log report.log

# long list only files ending with '.log'
$ ls -lG *.log
-rw-rw-r-- 1 learnbyexample   12345 Jan  1 03:30 errors.log
-rw-rw-r-- 1 learnbyexample 7654321 Jan  1 01:01 report.log
</code></pre><p><code>[]</code> helps you specify a set of characters to be matched once. For example, <code>[ad]</code> matches <code>a</code> or <code>d</code> once. <code>[c-i]</code> matches a range of characters from <code>c</code> to <code>i</code>.</p><pre><code class="language-bash"># entries starting with 'c' to 'i'
$ echo [c-i]*
errors.log hello_world.py hi ip.txt

$ ls -1sh [c-i]*
 16K errors.log
4.0K hello_world.py
4.0K hi
4.0K ip.txt
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> As shown in the above examples, globs are expanded by the shell. Beginners often associate globs as something specific to the <code>ls</code> command, which is why I've deliberately used <code>echo</code> as well in the above examples.</p></blockquote><p>You can use the <code>-d</code> option to <em>not</em> show directory contents:</p><pre><code class="language-bash">$ echo b*
backups
# since backups is a directory, ls will show its contents
$ ls b*
bookmarks.html  dot_files
# -d will show the directory entry instead of its contents
$ ls -d b*
backups

# a handy way to get only the directory entries
$ echo */
backups/ projects/ scripts/ todos/
$ ls -1d */
backups/
projects/
scripts/
todos/
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> I hope you have been judiciously taking notes, since there are just too many commands and features. For example, note down all the options discussed in this section. And then explore the output from the <code>ls --help</code> command.</p></blockquote><p><strong>Further Reading</strong></p><ul><li><a href="https://mywiki.wooledge.org/ParsingLs">mywiki.wooledge: avoid parsing output of ls</a></li><li><a href="https://unix.stackexchange.com/q/128985/109046">unix.stackexchange: why not parse ls?</a></li><li><a href="https://unix.stackexchange.com/q/63081/109046">unix.stackexchange: What are ./ and ../ directories?</a></li></ul><h2 id="tree"><a class="header" href="#tree">tree</a></h2><p>The <code>tree</code> command displays the contents of a directory recursively, in a hierarchical manner. Here's a screenshot of using <code>tree -a</code> from the <code>ls_examples</code> sample directory seen in the previous section. The <code>-a</code> option is used to show the hidden files as well.</p><p align="center"><img alt="example for tree command" src="../Images/496b16f19bc7368e400fbb267dbd20b9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/tree_example.png"/></p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You might have to install this command. <code>sudo apt install tree</code> can be used to get this command on Debian-like distributions.</p></blockquote><h2 id="mkdir"><a class="header" href="#mkdir">mkdir</a></h2><p>The <code>mkdir</code> command helps you to create new directories. You can pass one or more paths along with the name of the directories you want to create. Quote the names if it can contain shell special characters like space, <code>*</code> and so on.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Create a practice directory for this section:</p><pre><code class="language-bash">$ mkdir practice_mkdir
$ cd practice_mkdir
</code></pre></blockquote><p>Here's an example of creating multiple directories:</p><pre><code class="language-bash">$ mkdir reports 'low power adders'

$ ls -1
'low power adders'
reports
</code></pre><p>The <code>-p</code> option will help you to create multiple directory hierarchies in one shot:</p><pre><code class="language-bash"># error because 'a' and 'a/b' paths do not exist yet
$ mkdir a/b/c
mkdir: cannot create directory ‘a/b/c’: No such file or directory

# -p is handy in such cases
$ mkdir -p a/b/c

$ tree
.
├── a
│   └── b
│       └── c
├── low power adders
└── reports

5 directories, 0 files
</code></pre><p>The <code>-p</code> option has another functionality too. It will not complain if the directory you are trying to create already exists. This is especially helpful in shell scripts.</p><pre><code class="language-bash"># 'reports' directory was already created in an earlier example
$ mkdir reports
mkdir: cannot create directory ‘reports’: File exists
# exit status will reflect that something went wrong
$ echo $?
1

# the -p option will override such errors
$ mkdir -p reports
$ echo $?
0
</code></pre><p>As seen in the examples above, you can check the exit status of the last executed command using the <code>$?</code> special variable. <code>0</code> means everything went well and higher numbers indicate some sort of failure has occurred (the details of which you can look up in the command's manual).</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> Linux filenames can use any character other than <code>/</code> and the ASCII NUL character. Quote the arguments if it contains characters like space, <code>*</code>, etc to prevent shell expansion. Shell considers space as the argument separator, <code>*</code> is a wildcard character and so on. As a good practice, use only alphabets, numbers and underscores for filenames, unless you have some specific requirements. See also <a href="https://unix.stackexchange.com/q/269093/109046">unix.stackexchange: Characters best avoided in filenames</a>.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You can delete the practice directory if you wish:</p><pre><code class="language-bash">$ cd ..
$ rm -r practice_mkdir
</code></pre></blockquote><h2 id="touch"><a class="header" href="#touch">touch</a></h2><p>You'll usually create files using a text editor or by redirecting the output of a command to a file. For some cases, empty files are needed for testing purposes or to satisfy a particular build process. A real world use case is the empty <code>.nojekyll</code> file for <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages#static-site-generators">GitHub Pages</a>.</p><p>The <code>touch</code> command's main functionality is altering timestamps (which will be discussed in the <a href="./file-properties.html">File Properties</a> chapter). If a file doesn't exist, <code>touch</code> will create an empty file using the current timestamp. You can also pass more than one file argument if needed.</p><pre><code class="language-bash">$ mkdir practice_touch
$ cd practice_touch

$ ls ip.txt
ls: cannot access 'ip.txt': No such file or directory

$ touch ip.txt

$ ls -s ip.txt
0 ip.txt
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You can create an empty file using <code>&gt; ip.txt</code> as well, but the redirection operator will overwrite the file if it already exists.</p></blockquote><h2 id="rm"><a class="header" href="#rm">rm</a></h2><p>The <code>rm</code> command will help you to delete files and directories. You can pass one or more paths as arguments.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'rm.sh' script
$ source rm.sh
$ ls -F
empty_dir/  hello.py  loops.py  projects/  read_only.txt  reports/

# delete files ending with .py
$ rm *.py
$ ls -F
empty_dir/  projects/  read_only.txt  reports/
</code></pre><p>You'll need to add the <code>-r</code> option to recursively delete directory contents. You can use <code>rm -d</code> or the <code>rmdir</code> command to delete only empty directories.</p><pre><code class="language-bash"># -r is needed to delete directory contents recursively
$ rm reports
rm: cannot remove 'reports': Is a directory
$ rm -r reports
$ ls -F
empty_dir/  projects/  read_only.txt

# delete empty directories, same as using the 'rmdir' command
$ rm -d empty_dir
# you'll get an error if the directory is not empty
$ rm -d projects
rm: cannot remove 'projects': Directory not empty
</code></pre><p>Typos like misplaced space, wrong glob, etc could wipe out files not intended for deletion. Apart from having backups and snapshots, you could also take some mitigating steps:</p><ul><li>using <code>-i</code> option to interactively delete each file <ul><li>you can also use <code>-I</code> option for lesser number of prompts</li></ul></li><li>using <code>echo</code> as a dry run to see how the glob expands</li><li>using a trash command (see links below) instead of <code>rm</code></li></ul><p>Use <code>y</code> for confirmation and <code>n</code> to cancel deletion with the <code>-i</code> or <code>-I</code> options. Here's an example of cancelling deletion:</p><pre><code class="language-bash">$ rm -ri projects
rm: descend into directory 'projects'? n

$ ls -F
projects/  read_only.txt
</code></pre><p>And here's an example of providing confirmation at each step of the deletion process:</p><pre><code class="language-bash">$ tree projects
projects
├── calculator
│   └── calc.sh
└── tictactoe
    └── game.py

2 directories, 2 files

$ rm -ri projects
rm: descend into directory 'projects'? y
rm: descend into directory 'projects/tictactoe'? y
rm: remove regular empty file 'projects/tictactoe/game.py'? y
rm: remove directory 'projects/tictactoe'? y
rm: descend into directory 'projects/calculator'? y
rm: remove regular empty file 'projects/calculator/calc.sh'? y
rm: remove directory 'projects/calculator'? y
rm: remove directory 'projects'? y

$ ls -F
read_only.txt
</code></pre><p>The <code>-f</code> option can be used to ignore complaints about non-existing files (somewhat similar to the <code>mkdir -p</code> feature). It also helps to remove write protected files (provided you have appropriate permissions to delete those files). This option is especially useful for recursive deletion of directories that have write protected files, <code>.git/objects</code> for example.</p><pre><code class="language-bash">$ rm xyz.txt
rm: cannot remove 'xyz.txt': No such file or directory
$ echo $?
1
$ rm -f xyz.txt
$ echo $?
0

# example for removing write protected files
# you'll be asked for confirmation even without the -i/-I options
$ rm read_only.txt
rm: remove write-protected regular empty file 'read_only.txt'? n
# with -f, files will be deleted without asking for confirmation
$ rm -f read_only.txt
</code></pre><p><strong>Further Reading</strong></p><ul><li>Use a trash command (for example, <code>trash-cli</code> on Ubuntu) so that deleted files can be recovered later if needed <ul><li>see also <a href="https://unix.stackexchange.com/q/452496/109046">unix.stackexchange: creating a simple trash command</a></li></ul></li><li>Files removed using <code>rm</code> can still be recovered with time and skill <ul><li><a href="https://unix.stackexchange.com/q/80270/109046">unix.stackexchange: recover deleted files</a></li><li><a href="https://unix.stackexchange.com/q/2677/109046">unix.stackexchange: recovering accidentally deleted files</a></li></ul></li><li>Use commands like <code>shred</code> if you want to make it harder to recover deleted files <ul><li><a href="https://wiki.archlinux.org/title/Securely_wipe_disk">wiki.archlinux: Securely wipe disk</a></li></ul></li><li><a href="https://learnbyexample.github.io/curated_resources/git_and_github.html">My curated list</a> for <code>git</code> and related resources</li></ul><h2 id="cp"><a class="header" href="#cp">cp</a></h2><p>You can use the <code>cp</code> command to make copies of files and directories. With default syntax, you have to specify the source first followed by the destination. To copy multiple items, the last argument as destination can only be a directory. You'll also need to use the <code>-r</code> option to copy directories (similar to <code>rm -r</code> seen earlier).</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'cp.sh' script
$ source cp.sh
$ ls -F
backups/  reference/

# recall that . is a relative path referring to the current directory
$ cp /usr/share/dict/words .
$ ls -F
backups/  reference/  words

# error because -r is needed to copy directories
# other file arguments (if present) will still be copied
$ cp /usr/share/dict .
cp: -r not specified; omitting directory '/usr/share/dict'
$ cp -r /usr/share/dict .
$ ls -F
backups/  dict/  reference/  words
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> By default, <code>cp</code> will overwrite an existing file of the same name in the destination directory. You can use the <code>-i</code> option to interactively confirm or deny overwriting existing files. The <code>-n</code> option will prevent overwriting existing files without asking for confirmation.</p></blockquote><pre><code class="language-bash">$ echo 'hello' &gt; ip.txt
$ ls -F
backups/  dict/  ip.txt  reference/  words
$ ls backups
ip.txt  reports
$ cat backups/ip.txt
apple banana cherry
# file will be overwritten without asking for confirmation!
$ cp ip.txt backups/
$ cat backups/ip.txt
hello

# use -i to interactively confirm or deny overwriting
$ echo 'good morning' &gt; ip.txt
$ cp -i ip.txt backups/
cp: overwrite 'backups/ip.txt'? n
$ cat backups/ip.txt
hello

# use -n to prevent overwriting without needing confirmation
$ cp -n ip.txt backups/
$ cat backups/ip.txt
hello
</code></pre><p>If there's a folder in the destination path with the same name as a folder being copied, the contents will be merged. If there are files of identical names in such directories, the same rules discussed above will apply.</p><pre><code class="language-bash">$ tree backups
backups
├── ip.txt
└── reports
    └── jan.log

1 directory, 2 files

$ mkdir reports
$ touch reports/dec.log
$ cp -r reports backups/
$ tree backups
backups
├── ip.txt
└── reports
    ├── dec.log
    └── jan.log

1 directory, 3 files
</code></pre><p>Often, you'd want to copy a file (or a directory) under a different name. In such cases, you can simply use a new name while specifying the destination.</p><pre><code class="language-bash"># copy 'words' file from source as 'words_ref.txt' at destination
$ cp /usr/share/dict/words words_ref.txt

# copy 'words' file as 'words.txt' under the 'reference' directory
$ cp /usr/share/dict/words reference/words.txt

# copy 'dict' directory as 'word_lists'
$ cp -r /usr/share/dict word_lists
</code></pre><p>As mentioned earlier, to copy multiple files and directories, you'll have to specify the destination directory as the last argument.</p><pre><code class="language-bash">$ cp -r ~/.bashrc /usr/share/dict backups/

$ ls -AF backups
.bashrc  dict/  ip.txt  reports/
</code></pre><p>You can use the <code>-t</code> option to specify the destination before the source paths (helpful with the <code>find</code> command for example, will be discussed later). Here are some more notable options:</p><ul><li><code>-u</code> copy files from source only if they are newer or don't exist in the destination</li><li><code>-b</code> and <code>--backup</code> options will allow you to create backup copies of files already existing in the destination</li><li><code>--preserve</code> option will help you to copy files along with source file attributes like ownership, timestamp, etc</li></ul><p><strong>Further Reading</strong></p><ul><li><code>rsync</code> a fast, versatile, remote (and local) file-copying tool <ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories">rsync tutorial and examples</a></li></ul></li><li><a href="https://github.com/syncthing/syncthing">syncthing</a> — continuous file synchronization program</li></ul><h2 id="mv"><a class="header" href="#mv">mv</a></h2><p>You can use the <code>mv</code> command to move one or more files and directories from one location to another. Unlike <code>rm</code> and <code>cp</code>, you do not need the <code>-r</code> option for directories.</p><p>Syntax for specifying the source and destination is same as seen earlier with <code>cp</code>. Here's an example of moving a directory into another directory:</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'mv.sh' script
$ source mv.sh
$ ls -F
backups/  dot_files/  hello.py  ip.txt  loops.py  manuals/
$ ls -F backups
projects/

$ mv dot_files backups

$ ls -F
backups/  hello.py  ip.txt  loops.py  manuals/
$ ls -F backups
dot_files/  projects/
</code></pre><p>Here's an example for moving multiple files and directories to another directory:</p><pre><code class="language-bash">$ mv *.py manuals backups

$ ls -F
backups/  ip.txt
$ ls -F backups
dot_files/  hello.py  loops.py  manuals/  projects/
</code></pre><p>When you are dealing with a single file or directory, you can also <em>rename</em> them:</p><pre><code class="language-bash"># within the same directory
$ mv ip.txt report.txt
$ ls -F
backups/  report.txt

# between different directories
$ mv backups/dot_files rc_files
$ ls -F
backups/  rc_files/  report.txt
$ ls -F backups
hello.py  loops.py  manuals/  projects/
</code></pre><p>Here are some more notable options, some of which behave similar to those seen with the <code>cp</code> command:</p><ul><li><code>-i</code> interactively confirm or deny when the destination already has a file of the same name</li><li><code>-n</code> always deny overwriting of files</li><li><code>-f</code> always overwrite files</li><li><code>-t</code> specify the destination elsewhere instead of final argument</li><li><code>-u</code> move only if the files are newer or don't exist in the destination</li><li><code>-b</code> and <code>--backup</code> options will allow you to create backup copies of files already existing in the destination</li><li><code>-v</code> verbose option</li></ul><h2 id="rename"><a class="header" href="#rename">rename</a></h2><p>The <code>mv</code> command is useful for simple file renaming. <code>rename</code> helps when you need to modify one or more filenames based on a pattern. There are different implementations of the <code>rename</code> command, with wildly different set of features. See <a href="https://askubuntu.com/questions/956010/whats-the-difference-between-the-different-rename-commands">askubuntu: What's the difference between the different "rename" commands?</a> for details.</p><p>Perl implementation of the <code>rename</code> command will be discussed in this section. You'd need to know regular expressions to use this command. Basic explanations will be given here and more details can be found in the links mentioned at the end of this section. Here's an example to change the file extensions:</p><pre><code class="language-bash">$ mkdir practice_rename
$ cd practice_rename
# create sample files
$ touch caves.jpeg waterfall.JPEG flower.JPG

# substitution command syntax is s/search/replace/flags
# \. matches . character literally
# e? matches e optionally (? is a quantifier to match 0 or 1 times)
# $ anchors the match to the end of the input
# i flag matches the input case-insensitively
$ rename 's/\.jpe?g$/.jpg/i' *

$ ls
caves.jpg  flower.jpg  waterfall.jpg
$ rm *.jpg
</code></pre><p>As a good practice, use the <code>-n</code> option to see how the files will be renamed before actually renaming the files.</p><pre><code class="language-bash">$ touch 1.png 3.png 25.png 100.png
$ ls
100.png  1.png  25.png  3.png

# use the -n option for sanity check
# note that 100.png isn't part of the output, since it isn't affected
# \d matches a digit character
# \d+ matches 1 or more digits (+ is a quantifier to match 1 or more times)
# e flag treats the replacement string as Perl code
# $&amp; is a backreference to the entire matched portion
$ rename -n 's/\d+/sprintf "%03d", $&amp;/e' *.png
rename(1.png, 001.png)
rename(25.png, 025.png)
rename(3.png, 003.png)

# remove the -n option after sanity check to actually rename the files
$ rename 's/\d+/sprintf "%03d", $&amp;/e' *.png
$ ls
001.png  003.png  025.png  100.png
</code></pre><p>If the new filename already exists, you'll get an error, which you can override with the <code>-f</code> option if you wish. If you are passing filenames with path components in them, you can use the <code>-d</code> option to affect only the filename portion. Otherwise, the logic you are using might affect directory names as well.</p><pre><code class="language-bash">$ mkdir projects
$ touch projects/toc.sh projects/reports.py

# aim is to uppercase the non-extension part of the filename
# [^.]+ matches 1 or more non '.' characters
# \U changes the characters that follow to uppercase
# $&amp; is a backreference to the entire matched portion
$ rename -n -d 's/[^.]+/\U$&amp;/' projects/*
rename(projects/reports.py, projects/REPORTS.py)
rename(projects/toc.sh, projects/TOC.sh)

# without the -d option, directory name will also be affected
$ rename -n 's/[^.]+/\U$&amp;/' projects/*
rename(projects/reports.py, PROJECTS/REPORTS.py)
rename(projects/toc.sh, PROJECTS/TOC.sh)
</code></pre><p><strong>Further Reading</strong></p><ul><li><a href="https://perldoc.perl.org/perlretut">perldoc: Regexp tutorial</a></li><li>See my <a href="https://github.com/learnbyexample/learn_perl_oneliners">Perl one-liners</a> ebook for examples and more details about the Perl substitution and <code>rename</code> commands</li></ul><h2 id="ln"><a class="header" href="#ln">ln</a></h2><p>The <code>ln</code> command helps you create a link to another file or directory within the same or different location. There are two types of links — <strong>symbolic</strong> links and <strong>hard</strong> links. Symbolic links can point to both files and directories. Here are some characteristics:</p><ul><li>if the original file is deleted or moved to another location, then the symbolic link will no longer work</li><li>if the symbolic link is moved to another location, it will still work if the link was done using absolute path (for relative path, it will depend on whether or not there's another file with the same name in that location)</li><li>a symbolic link file has its own inode, permissions, timestamps, etc</li><li>some commands will work the same when original file or the symbolic file is given as the command line argument, while some require additional options (<code>du -L</code> for example)</li></ul><p>Usage is similar to the <code>cp</code> command. You have to specify the source first followed by the destination (which is optional if it is the current working directory).</p><pre><code class="language-bash">$ mkdir practice_ln
$ cd practice_ln

# destination is optional for making a link in the current directory
# -s option is needed to make symbolic links
$ ln -s /usr/share/dict/words

# you can also rename the link if needed
$ ln -s /usr/share/dict/words words.txt
$ ls -1sF
total 0
0 words@
0 words.txt@
</code></pre><p>Long listing with <code>ls -l</code> will show the path connected to links. You can also use the <code>readlink</code> command, which has features like resolving recursively to the canonical file.</p><pre><code class="language-bash"># to know which file the link points to
$ ls -lG words
lrwxrwxrwx 1 learnbyexample 21 Jul  9 13:41 words -&gt; /usr/share/dict/words
$ readlink words
/usr/share/dict/words

# the linked file may be another link
# use -f option to get the original file
$ readlink -f words
/usr/share/dict/english
</code></pre><p>Hard links can only point to another file. You cannot use them for directories and the usage is also restricted to within the same filesystem. The <code>.</code> and <code>..</code> directories are exceptions, these special purpose hard links are automatically created. Here are some more details about hard links:</p><ul><li>once a hard link is created, there is no distinction between the two files other than their paths. They have same inode, permissions, timestamps, etc</li><li>hard links will continue working even if all the other hard links are deleted</li><li>if a hard link is moved to another location, the links will still be in sync. Any change in one of them will be reflected in all the other links</li></ul><pre><code class="language-bash">$ touch apple.txt
$ ln apple.txt banana.txt

# the -i option gives inode
$ ls -1i apple.txt banana.txt
649140 banana.txt
649140 apple.txt
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You can use <code>unlink</code> or <code>rm</code> commands to delete links.</p></blockquote><p><strong>Further Reading</strong></p><ul><li><a href="https://askubuntu.com/questions/108771/what-is-the-difference-between-a-hard-link-and-a-symbolic-link">askubuntu: What is the difference between a hard link and a symbolic link?</a></li><li><a href="https://unix.stackexchange.com/q/9575/109046">unix.stackexchange: What is the difference between symbolic and hard links?</a></li><li><a href="https://unix.stackexchange.com/q/4402/109046">unix.stackexchange: What is a Superblock, Inode, Dentry and a File?</a></li></ul><h2 id="tar-and-gzip"><a class="header" href="#tar-and-gzip">tar and gzip</a></h2><p><code>tar</code> is an archiving utility. Depending on the implementation, you can also use options to compress the archive.</p><p>Here's an example that creates a single archive file from multiple input files and directories:</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'tar.sh' script
$ source tar.sh
$ ls -F
projects/  report.log  todos/

# -c option creates a new archive, any existing archive will be overwritten
# -f option allows to specify a name for the archive being created
# rest of the arguments are the files/directories to be archived
$ tar -cf bkp.tar report.log projects

$ ls -F
bkp.tar  projects/  report.log  todos/
$ ls -sh bkp.tar
7.4M bkp.tar
</code></pre><p>Once you have an archive file, you can then compress it using tools like <code>gzip</code>, <code>bzip2</code>, <code>xz</code>, etc. In the below example, the command replaces the archive file with the compressed version and adds a <code>.gz</code> suffix to indicate that <code>gzip</code> was the technique used.</p><pre><code class="language-bash"># the input '.tar' file will be overwritten with the compressed version
$ gzip bkp.tar

$ ls -F
bkp.tar.gz  projects/  report.log  todos/
$ ls -sh bkp.tar.gz
5.6M bkp.tar.gz
</code></pre><p>Use the <code>-t</code> option if you want to check the contents of the compressed file. This will work with the uncompressed <code>.tar</code> version as well.</p><pre><code class="language-bash">$ tar -tf bkp.tar.gz
report.log
projects/
projects/scripts/
projects/scripts/calc.sh
projects/errors.log
</code></pre><p>To uncompress <code>.gz</code> files, you can use <code>gunzip</code> or <code>gzip -d</code>. This will replace the compressed version with the uncompressed archive file:</p><pre><code class="language-bash"># this '.gz' file will be overwritten with the uncompressed version
$ gunzip bkp.tar.gz

$ ls -F
bkp.tar  projects/  report.log  todos/
$ ls -sh bkp.tar
7.4M bkp.tar
</code></pre><p>To extract the files from an archive, use <code>tar</code> along with the <code>-x</code> option:</p><pre><code class="language-bash">$ mkdir test_extract
$ mv bkp.tar test_extract
$ cd test_extract
$ ls
bkp.tar

$ tar -xf bkp.tar
$ tree
.
├── bkp.tar
├── projects
│   ├── errors.log
│   └── scripts
│       └── calc.sh
└── report.log

2 directories, 4 files

$ cd ..
$ rm -r test_extract
</code></pre><p>With <code>GNU tar</code>, you can compress/uncompress along with the <code>tar</code> command instead of having to use tools like <code>gzip</code> separately. For example, the <code>-z</code> option will use <code>gzip</code>, <code>-j</code> will use <code>bzip2</code> and <code>-J</code> will use <code>xz</code>. Use the <code>-a</code> option if you want <code>tar</code> to automatically select the compression technique based on the extension provided.</p><pre><code class="language-bash">$ ls -F
projects/  report.log  todos/

# -z option gives same compression as the gzip command
$ tar -zcf bkp.tar.gz report.log projects
$ ls -sh bkp.tar.gz
5.6M bkp.tar.gz

# extract original files from compressed file
$ mkdir test_extract
$ cd test_extract
$ tar -zxf ../bkp.tar.gz
$ tree
.
├── projects
│   ├── errors.log
│   └── scripts
│       └── calc.sh
└── report.log

2 directories, 3 files

$ cd ..
$ rm -r test_extract
</code></pre><p><code>tar</code> has lots and lots of options for various needs. Some are listed below, see documentation for complete details.</p><ul><li><code>-v</code> verbose option</li><li><code>-r</code> to append files to an existing archive</li><li><code>--exclude=</code> specify files to be ignored from archiving</li></ul><p>There are also commands starting with <code>z</code> to work with compressed files, for example:</p><ul><li><code>zcat</code> to display file contents of a compressed file</li><li><code>zless</code> to display file contents of a compressed file one screenful at a time</li><li><code>zgrep</code> to search compressed files</li></ul><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> If you need to work with <code>.zip</code> files, use the <code>zip</code> and <code>unzip</code> commands.</p></blockquote><p><strong>Further Reading</strong></p><ul><li><a href="https://unix.stackexchange.com/q/178127/109046">unix.stackexchange: tar files with a sorted order</a></li><li><a href="https://superuser.com/questions/252065/gzip-without-tar-why-are-they-used-together">superuser: gzip without tar? Why are they used together?</a></li><li><a href="https://unix.stackexchange.com/q/28976/109046">unix.stackexchange: xz a directory with tar using maximum compression?</a></li></ul><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The <code>ls.sh</code> script will be used for some of the exercises.</p></blockquote><p><strong>1)</strong> Which of these commands will always display the absolute path of the home directory?</p><p><em>a)</em> <code>pwd</code><br/> <em>b)</em> <code>echo "$PWD"</code><br/> <em>c)</em> <code>echo "$HOME"</code></p><p><strong>2)</strong> The current working directory has a folder named <code>-dash</code>. How would you switch to that directory?</p><p><em>a)</em> <code>cd -- -dash</code><br/> <em>b)</em> <code>cd -dash</code><br/> <em>c)</em> <code>cd ./-dash</code><br/> <em>d)</em> <code>cd \-dash</code><br/> <em>e)</em> <code>cd '-dash'</code><br/> <em>f)</em> all of the above<br/> <em>g)</em> only <em>a)</em> and <em>c)</em></p><p><strong>3)</strong> Given the directory structure as shown below, how would you change to the <code>todos</code> directory?</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'ls.sh' script
$ source ls.sh

$ ls -F
backups/    hello_world.py*  ip.txt     report.log  todos/
errors.log  hi*              projects/  scripts@
$ cd projects
$ pwd
/home/learnbyexample/cli-computing/example_files/scripts/ls_examples/projects

# ???
$ pwd
/home/learnbyexample/cli-computing/example_files/scripts/ls_examples/todos
</code></pre><p><strong>4)</strong> As per the scenario shown below, how would you change to the <code>cli-computing</code> directory under the user's home directory? And then, how would you go back to the previous working directory?</p><pre><code class="language-bash">$ pwd
/home/learnbyexample/all/projects/square_tictactoe

# ???
$ pwd
/home/learnbyexample/cli-computing

# ???
$ pwd
/home/learnbyexample/all/projects/square_tictactoe
</code></pre><p><strong>5)</strong> How'd you list the contents of the current directory, one per line, along with the size of the entries in human readable format?</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'ls.sh' script
$ source ls.sh

# ???
total 7.4M
4.0K backups
 16K errors.log
4.0K hello_world.py
4.0K hi
4.0K ip.txt
4.0K projects
7.4M report.log
   0 scripts
4.0K todos
</code></pre><p><strong>6)</strong> Which <code>ls</code> command option would you use for version based sorting of entries?</p><p><strong>7)</strong> Which <code>ls</code> command option would you use for sorting based on entry size?</p><p><strong>8)</strong> Which <code>ls</code> command option would you use for sorting based on file extension?</p><p><strong>9)</strong> What does the <code>-G</code> option of <code>ls</code> command do?</p><p><strong>10)</strong> What does the <code>-i</code> option of <code>ls</code> command do?</p><p><strong>11)</strong> List only the directories as one entry per line.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'ls.sh' script
$ source ls.sh

# ???
backups/
projects/
scripts/
todos/
</code></pre><p><strong>12)</strong> Assume that a regular file named <code>notes</code> already exists. What would happen if you use the <code>mkdir -p notes</code> command?</p><pre><code class="language-bash">$ ls -1F notes
notes

# what would happen here?
$ mkdir -p notes
</code></pre><p><strong>13)</strong> Use one or more commands to match the scenario shown below:</p><pre><code class="language-bash">$ ls -1F
cost.txt

# ???

$ ls -1F
cost.txt
ghost/
quest/
toast/
</code></pre><p><strong>14)</strong> Use one or more commands to match the scenario shown below:</p><pre><code class="language-bash"># start with an empty directory
$ ls -l
total 0

# ???

$ tree -F
.
├── hobbies/
│   ├── painting/
│   │   └── waterfall.bmp
│   ├── trekking/
│   │   └── himalayas.txt
│   └── writing/
└── shopping/
    └── festival.xlsx

5 directories, 3 files
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Don't delete this directory, will be needed in a later exercise.</p></blockquote><p><strong>15)</strong> If directories to create already exist, which <code>mkdir</code> command option would you use to not show an error?</p><p><strong>16)</strong> Use one or more commands to match the scenario given below:</p><pre><code class="language-bash">$ ls -1F
cost.txt
ghost/
quest/
toast/

# ???

$ ls -1F
quest/
</code></pre><p><strong>17)</strong> What does the <code>-f</code> option of <code>rm</code> command do?</p><p><strong>18)</strong> Which option would you use to interactively delete files using the <code>rm</code> command?</p><p><strong>19)</strong> Can the files removed by <code>rm</code> easily be restored? Do you need to take some extra steps or use special commands to make the files more difficult to recover?</p><p><strong>20)</strong> Does your Linux distribution provide a tool to send deleted files to the trash (which would help to recover deleted files)?</p><p><strong>21)</strong> Which option would you use to interactively accept/prevent the <code>cp</code> command from overwriting a file of the same name? And which option would prevent overwriting without needing manual confirmation?</p><p><strong>22)</strong> Does the <code>cp</code> command allow you to rename the file or directory being copied? If so, can you rename multiple files/directories being copied?</p><p><strong>23)</strong> What do the <code>-u</code>, <code>-b</code> and <code>-t</code> options of <code>cp</code> command do?</p><p><strong>24)</strong> What's the difference between the two commands shown below?</p><pre><code class="language-bash">$ cp ip.txt op.txt

$ mv ip.txt op.txt
</code></pre><p><strong>25)</strong> Which option would you use to interactively accept/prevent the <code>mv</code> command from overwriting a file of the same name?</p><p><strong>26)</strong> Use one or more commands to match the scenario shown below. You should have already created this directory structure in an earlier exercise.</p><pre><code class="language-bash">$ tree -F
.
├── hobbies/
│   ├── painting/
│   │   └── waterfall.bmp
│   ├── trekking/
│   │   └── himalayas.txt
│   └── writing/
└── shopping/
    └── festival.xlsx

5 directories, 3 files

# ???

$ tree -F
.
├── hobbies/
│   ├── himalayas.txt
│   └── waterfall.bmp
└── shopping/
    └── festival.xlsx

2 directories, 3 files
</code></pre><p><strong>27)</strong> What does the <code>-t</code> option of <code>mv</code> command do?</p><p><strong>28)</strong> Determine and implement the <code>rename</code> logic based on the filenames and expected output shown below.</p><pre><code class="language-bash">$ touch '(2020) report part 1.txt' 'analysis part 3 (2018).log'
$ ls -1
'(2020) report part 1.txt'
'analysis part 3 (2018).log'

# ???

$ ls -1
2020_report_part_1.txt
analysis_part_3_2018.log
</code></pre><p><strong>29)</strong> Does the <code>ln</code> command follow the same order to specify source and destination as the <code>cp</code> and <code>mv</code> commands?</p><p><strong>30)</strong> Which <code>tar</code> option helps to compress archives based on filename extension? This option can be used instead of <code>-z</code> for <code>gzip</code>, <code>-j</code> for <code>bzip2</code> and <code>-J</code> for <code>xz</code>.</p>    
</body>
</html>