["```sh # Cleanup\n# Run as root, of course.\n\ncd /var/log\ncat /dev/null > messages\ncat /dev/null > wtmp\necho \"Log files cleaned up.\"\n```", "```sh #!/bin/bash\n# Proper header for a Bash script.\n\n# Cleanup, version 2\n\n# Run as root, of course.\n# Insert code here to print error message and exit if not root.\n\nLOG_DIR=/var/log\n# Variables are better than hard-coded values.\ncd $LOG_DIR\n\ncat /dev/null > messages\ncat /dev/null > wtmp\n\necho \"Logs cleaned up.\"\n\nexit #  The right and proper method of \"exiting\" from a script.\n     #  A bare \"exit\" (no parameter) returns the exit status\n     #+ of the preceding command. \n```", "```sh #!/bin/bash\n# Cleanup, version 3\n\n#  Warning:\n#  -------\n#  This script uses quite a number of features that will be explained\n#+ later on.\n#  By the time you've finished the first half of the book,\n#+ there should be nothing mysterious about it.\n\nLOG_DIR=/var/log\nROOT_UID=0     # Only users with $UID 0 have root privileges.\nLINES=50       # Default number of lines saved.\nE_XCD=86       # Can't change directory?\nE_NOTROOT=87   # Non-root exit error.\n\n# Run as root, of course.\nif [ \"$UID\" -ne \"$ROOT_UID\" ]\nthen\n  echo \"Must be root to run this script.\"\n  exit $E_NOTROOT\nfi  \n\nif [ -n \"$1\" ]\n# Test whether command-line argument is present (non-empty).\nthen\n  lines=$1\nelse  \n  lines=$LINES # Default, if not specified on command-line.\nfi  \n\n#  Stephane Chazelas suggests the following,\n#+ as a better way of checking command-line arguments,\n#+ but this is still a bit advanced for this stage of the tutorial.\n#\n#    E_WRONGARGS=85  # Non-numerical argument (bad argument format).\n#\n#    case \"$1\" in\n#    \"\"      ) lines=50;;\n#    *[!0-9]*) echo \"Usage: `basename $0` lines-to-cleanup\";\n#     exit $E_WRONGARGS;;\n#    *       ) lines=$1;;\n#    esac\n#\n#* Skip ahead to \"Loops\" chapter to decipher all this.\n\ncd $LOG_DIR\n\nif [ `pwd` != \"$LOG_DIR\" ]  # or   if [ \"$PWD\" != \"$LOG_DIR\" ]\n                            # Not in /var/log?\nthen\n  echo \"Can't change to $LOG_DIR.\"\n  exit $E_XCD\nfi  # Doublecheck if in right directory before messing with log file.\n\n# Far more efficient is:\n#\n# cd /var/log &#124;&#124; {\n#   echo \"Cannot change to necessary directory.\" >&2\n#   exit $E_XCD;\n# }\n\ntail -n $lines messages > mesg.temp # Save last section of message log file.\nmv mesg.temp messages               # Rename it as system log file.\n\n#  cat /dev/null > messages\n#* No longer needed, as the above method is safer.\n\ncat /dev/null > wtmp  #  ': > wtmp' and '> wtmp'  have the same effect.\necho \"Log files cleaned up.\"\n#  Note that there are other log files in /var/log not affected\n#+ by this script.\n\nexit 0\n#  A zero return value from the script upon exit indicates success\n#+ to the shell.\n```", "```sh #!/bin/sh\n#!/bin/bash\n#!/usr/bin/perl\n#!/usr/bin/tcl\n#!/bin/sed -f\n#!/bin/awk -f\n```", "```sh E_WRONG_ARGS=85\nscript_parameters=\"-a -h -m -z\"\n#                  -a = all, -h = help, etc.\n\nif [ $# -ne $Number_of_expected_args ]\nthen\n  echo \"Usage: `basename $0` $script_parameters\"\n  # `basename $0` is the script's filename.\n  exit $E_WRONG_ARGS\nfi\n```", "```sh #!/bin/bash\n\necho \"Part 1 of script.\"\na=1\n\n#!/bin/bash\n# This does *not* launch a new script.\n\necho \"Part 2 of script.\"\necho $a  # Value of $a stays at 1.\n```", "```sh #!/bin/rm\n# Self-deleting script.\n\n# Nothing much seems to happen when you run this... except that the file disappears.\n\nWHATEVER=85\n\necho \"This line will never print (betcha!).\"\n\nexit $WHATEVER  # Doesn't matter. The script will not exit here.\n                # Try an echo $? after script termination.\n                # You'll get a 0, not a 85.\n```"]