- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2025-12-20 20:24:55'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Kernel Module Programming Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://sysprog21.github.io/lkmpg/](https://sysprog21.github.io/lkmpg/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang
  prefs: []
  type: TYPE_NORMAL
- en: September 28, 2025
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/78a1165dae09cd77d532c4c0e3be17a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 1 [Introduction](#introduction)
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 [Authorship](#authorship)
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 [Acknowledgements](#acknowledgements)
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 [What Is A Kernel Module?](#what-is-a-kernel-module)
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 [Kernel module package](#kernel-module-package)
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 [What Modules are in my Kernel?](#what-modules-are-in-my-kernel)
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 [Is there a need to download and compile the kernel?](#is-there-a-need-to-download-and-compile-the-kernel)
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 [Before We Begin](#before-we-begin)
  prefs: []
  type: TYPE_NORMAL
- en: 2 [Headers](#headers)
  prefs: []
  type: TYPE_NORMAL
- en: 3 [Examples](#examples)
  prefs: []
  type: TYPE_NORMAL
- en: 4 [Hello World](#hello-world)
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 [The Simplest Module](#the-simplest-module)
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 [Hello and Goodbye](#hello-and-goodbye)
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 [The __init and __exit Macros](#the-init-and-exit-macros)
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 [Licensing and Module Documentation](#licensing-and-module-documentation)
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 [Passing Command Line Arguments to a Module](#passing-command-line-arguments-to-a-module)
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 [Modules Spanning Multiple Files](#modules-spanning-multiple-files)
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 [Building modules for a precompiled kernel](#building-modules-for-a-precompiled-kernel)
  prefs: []
  type: TYPE_NORMAL
- en: 5 [Preliminaries](#preliminaries)
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 [How modules begin and end](#how-modules-begin-and-end)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 [Functions available to modules](#functions-available-to-modules)
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 [User Space vs Kernel Space](#user-space-vs-kernel-space)
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 [Name Space](#name-space)
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 [Code space](#code-space)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 [Device Drivers](#device-drivers)
  prefs: []
  type: TYPE_NORMAL
- en: 6 [Character Device drivers](#character-device-drivers)
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 [The file_operations Structure](#the-fileoperations-structure)
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 [The file structure](#the-file-structure)
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 [Registering A Device](#registering-a-device)
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 [Unregistering A Device](#unregistering-a-device)
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 [chardev.c](#chardevc)
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 [Writing Modules for Multiple Kernel Versions](#writing-modules-for-multiple-kernel-versions)
  prefs: []
  type: TYPE_NORMAL
- en: 7 [The /proc Filesystem](#the-proc-filesystem)
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 [The proc_ops Structure](#the-procops-structure)
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 [Read and Write a /proc File](#read-and-write-a-proc-file)
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 [Manage /proc file with standard filesystem](#manage-proc-file-with-standard-filesystem)
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 [Manage /proc file with seq_file](#manage-proc-file-with-seqfile)
  prefs: []
  type: TYPE_NORMAL
- en: '8 [sysfs: Interacting with your module](#sysfs-interacting-with-your-module)'
  prefs: []
  type: TYPE_NORMAL
- en: 9 [Talking To Device Files](#talking-to-device-files)
  prefs: []
  type: TYPE_NORMAL
- en: 10 [System Calls](#system-calls)
  prefs: []
  type: TYPE_NORMAL
- en: 11 [Blocking Processes and threads](#blocking-processes-and-threads)
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 [Sleep](#sleep)
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 [Completions](#completions)
  prefs: []
  type: TYPE_NORMAL
- en: 12 [Synchronization](#synchronization)
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 [Mutex](#mutex)
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 [Spinlocks](#spinlocks)
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 [Read and write locks](#read-and-write-locks)
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 [Atomic operations](#atomic-operations)
  prefs: []
  type: TYPE_NORMAL
- en: 13 [Replacing Print Macros](#replacing-print-macros)
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 [Replacement](#replacement)
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 [Flashing keyboard LEDs](#flashing-keyboard-leds)
  prefs: []
  type: TYPE_NORMAL
- en: 14 [GPIO](#gpio)
  prefs: []
  type: TYPE_NORMAL
- en: 14.1 [GPIO](#gpio1)
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 [Control the LED’s on/off state](#control-the-leds-onoff-state)
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 [DHT11 sensor](#dht-sensor)
  prefs: []
  type: TYPE_NORMAL
- en: 15 [Scheduling Tasks](#scheduling-tasks)
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 [Tasklets](#tasklets)
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 [Work queues](#work-queues)
  prefs: []
  type: TYPE_NORMAL
- en: 16 [Interrupt Handlers](#interrupt-handlers)
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 [Interrupt Handlers](#interrupt-handlers1)
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 [Detecting button presses](#detecting-button-presses)
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 [Bottom Half](#bottom-half)
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 [Threaded IRQ](#threaded-irq)
  prefs: []
  type: TYPE_NORMAL
- en: 17 [Virtual Input Device Driver](#virtual-input-device-driver)
  prefs: []
  type: TYPE_NORMAL
- en: '18 [Standardizing the interfaces: The Device Model](#standardizing-the-interfaces-the-device-model)'
  prefs: []
  type: TYPE_NORMAL
- en: 19 [Device Tree](#device-tree)
  prefs: []
  type: TYPE_NORMAL
- en: 19.1 [Introduction to Device Tree](#introduction-to-device-tree)
  prefs: []
  type: TYPE_NORMAL
- en: 19.2 [Device Tree and Kernel Modules](#device-tree-and-kernel-modules)
  prefs: []
  type: TYPE_NORMAL
- en: '19.3 [Example: Device Tree Module](#example-device-tree-module)'
  prefs: []
  type: TYPE_NORMAL
- en: 19.4 [Device Tree Source Example](#device-tree-source-example)
  prefs: []
  type: TYPE_NORMAL
- en: 19.5 [Testing Device Tree Modules](#testing-device-tree-modules)
  prefs: []
  type: TYPE_NORMAL
- en: 19.6 [Common Device Tree Functions](#common-device-tree-functions)
  prefs: []
  type: TYPE_NORMAL
- en: 20 [Optimizations](#optimizations)
  prefs: []
  type: TYPE_NORMAL
- en: 20.1 [Likely and Unlikely conditions](#likely-and-unlikely-conditions)
  prefs: []
  type: TYPE_NORMAL
- en: 20.2 [Static keys](#static-keys)
  prefs: []
  type: TYPE_NORMAL
- en: 21 [Common Pitfalls](#common-pitfalls)
  prefs: []
  type: TYPE_NORMAL
- en: 21.1 [Using standard libraries](#using-standard-libraries)
  prefs: []
  type: TYPE_NORMAL
- en: 21.2 [Disabling interrupts](#disabling-interrupts)
  prefs: []
  type: TYPE_NORMAL
- en: 22 [Where To Go From Here?](#where-to-go-from-here)
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux Kernel Module Programming Guide is a free book; you may reproduce
    or modify it under the terms of the [Open Software License](https://opensource.org/licenses/OSL-3.0),
    version 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: This book is distributed in the hope that it would be useful, but without any
    warranty, without even the implied warranty of merchantability or fitness for
    a particular purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The author encourages wide distribution of this book for personal or commercial
    use, provided the above copyright notice remains intact and the method adheres
    to the provisions of the [Open Software License](https://opensource.org/licenses/OSL-3.0).
    In summary, you may copy and distribute this book free of charge or for a profit.
    No explicit permission is required from the author for reproduction of this book
    in any medium, physical or electronic.
  prefs: []
  type: TYPE_NORMAL
- en: Derivative works and translations of this document must be placed under the
    Open Software License, and the original copyright notice must remain intact. If
    you have contributed new material to this book, you must make the material and
    source code available for your revisions. Please make revisions and updates available
    directly to the document maintainer, Jim Huang <jserv@ccns.ncku.edu.tw>. This
    will allow for the merging of updates and provide consistent revisions to the
    Linux community.
  prefs: []
  type: TYPE_NORMAL
- en: If you publish or distribute this book commercially, donations, royalties, or
    printed copies are greatly appreciated by the author and the [Linux Documentation
    Project](https://tldp.org/) (LDP). Contributing in this way shows your support
    for free software and the LDP. If you have questions or comments, please contact
    the address above.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Authorship
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Linux Kernel Module Programming Guide was initially authored by Ori Pomerantz
    for Linux v2.2\. As the Linux kernel evolved, Ori’s availability to maintain the
    document diminished. Consequently, Peter Jay Salzman assumed the role of maintainer
    and updated the guide for Linux v2.4\. Similar constraints arose for Peter when
    tracking developments in Linux v2.6, leading to Michael Burian joining as a co-maintainer
    to bring the guide up to speed with Linux v2.6\. Bob Mottram contributed to the
    guide by updating examples for Linux v3.8 and later. Jim Huang then undertook
    the task of updating the guide for recent Linux versions (v5.0 and beyond), along
    with revising the LaTeX document. The guide continues to be maintained for compatibility
    with modern kernels (v6.x series) while ensuring examples work with older LTS
    kernels.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Acknowledgements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following people have contributed corrections or good suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Amit Dhingra, Andrew Kreimer, Andrew Lin, Andy Shevchenko, Arush Sharma, Aykhan
    Hagverdili, Benno Bielmeier, Bob Lee, Brad Baker, Che-Chia Chang, Cheng-Shian
    Yeh, Cheng-Yang Chou, Chih-En Lin, Chih-Hsuan Yang, Chih-Yu Chen, Ching-Hua (Vivian)
    Lin, Chin Yik Ming, Chung-Han Tsai, cvvletter, Cyril Brulebois, Daniele Paolo
    Scarpazza, David Porter, demonsome, Dimo Velev, Ekang Monyet, Ethan Chan, Francois
    Audeon, Gilad Reti, Hao.Dong, heartofrain, Horst Schirmeier, Hsin-Hsiang Peng,
    Hung-Jen Pao, Ignacio Martin, I-Hsin Cheng, Integral, Iûnn Kiàn-îng, Jian-Xing
    Wu, Jimmy Ma, Johan Calle, keytouch, Kohei Otsuka, Kuan-Wei Chiu, manbing, Marconi
    Jiang, mengxinayan, Meng-Zong Tsai, Peter Lin, Roman Lakeev, Sam Erickson, Shao-Tse
    Hung, Shih-Sheng Yang, Stacy Prowell, Steven Lung, Tristan Lelong, Tse-Wei Lin,
    Tucker Polomik, Tyler Fanelli, VxTeemo, Wei-Hsin Yeh, Wei-Lun Tsai, Xatierlike
    Lee, Yan-Jie Chan, Yen-Yu Chen, Yin-Chiuan Chen, Yi-Wei Lin, Yo-Jung Lin, Yu-Chun
    Lin, Yu-Hsiang Tseng, YYGO.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 What Is A Kernel Module?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Involvement in the development of Linux kernel modules requires a foundation
    in the C programming language and a track record of creating conventional programs
    intended for process execution. This pursuit delves into a domain where an unregulated
    pointer, if disregarded, may potentially trigger the total elimination of an entire
    filesystem, resulting in a scenario that necessitates a complete system reboot.
  prefs: []
  type: TYPE_NORMAL
- en: A Linux kernel module is precisely defined as a code segment capable of dynamic
    loading and unloading within the kernel as needed. These modules enhance kernel
    capabilities without necessitating a system reboot. A notable example is seen
    in the device driver module, which facilitates kernel interaction with hardware
    components linked to the system. In the absence of modules, the prevailing approach
    leans toward monolithic kernels, requiring direct integration of new functionalities
    into the kernel image. This approach leads to larger kernels and necessitates
    kernel rebuilding and subsequent system rebooting when new functionalities are
    desired.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Kernel module package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linux distributions provide the commands `modprobe` , `insmod` and `depmod`
    within a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu/Debian GNU/Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On Arch Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 1.5 What Modules are in my Kernel?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To discover what modules are already loaded within your current kernel, use
    the command `lsmod` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Modules are stored within the file /proc/modules, so you can also see them
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be a long list, and you might prefer to search for something particular.
    To search for the fat module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 1.6 Is there a need to download and compile the kernel?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To effectively follow this guide, there is no obligatory requirement for performing
    such actions. Nonetheless, a prudent approach involves executing the examples
    within a test distribution on a virtual machine, thus mitigating any potential
    risk of disrupting the system.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Before We Begin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before delving into code, certain matters require attention. Variances exist
    among individuals’ systems, and distinct personal approaches are evident. The
    achievement of successful compilation and loading of the inaugural “hello world”
    program may, at times, present challenges. It is reassuring to note that overcoming
    the initial obstacle on the first attempt paves the way for subsequent endeavors
    to proceed seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Modversioning. A module compiled for one kernel will not load if a different
    kernel is booted, unless `CONFIG_MODVERSIONS` is enabled in the kernel. Module
    versioning will be discussed later in this guide. Until module versioning is covered,
    the examples in this guide may not work correctly if running a kernel with modversioning
    turned on. However, most stock Linux distribution kernels come with modversioning
    enabled. If difficulties arise when loading the modules due to versioning errors,
    consider compiling a kernel with modversioning turned off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the X Window System. It is highly recommended to extract, compile, and
    load all the examples discussed in this guide from a console. Working on these
    tasks within the X Window System is discouraged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modules cannot directly print to the screen like `printf()` can, but they can
    log information and warnings to the kernel’s log ring buffer. This output is not
    automatically displayed on any console or terminal. To view kernel module messages,
    you must use `dmesg` to read the kernel log ring buffer, or check the systemd
    journal with `journalctl -k` for kernel messages. Refer to [Section 4](#hello-world)
    for more information. The terminal or environment from which you load the module
    does not affect where the output goes—it always goes to the kernel log.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SecureBoot. Numerous modern computers arrive pre-configured with UEFI SecureBoot
    enabled—an essential security standard ensuring booting exclusively through trusted
    software endorsed by the original equipment manufacturer. Certain Linux distributions
    even ship with the default Linux kernel configured to support SecureBoot. In these
    cases, the kernel module necessitates a signed security key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Failing that, an attempt to insert your first “hello world” module would result
    in the message: “ERROR: could not insert module”. If this message “Lockdown: insmod:
    unsigned module loading is restricted; see man kernel lockdown.7” appears in the
    `dmesg` output, the simplest approach involves disabling UEFI SecureBoot from
    the boot menu of your PC or laptop, allowing the successful insertion of the “hello
    world” module. Naturally, an alternative involves undergoing intricate procedures
    such as generating keys, system key installation, and module signing to achieve
    functionality. However, this intricate process is less appropriate for beginners.
    If interested, more detailed steps for [SecureBoot](https://wiki.debian.org/SecureBoot)
    can be explored and followed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2 Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before building anything, it is necessary to install the header files for the
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu/Debian GNU/Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command provides information about the available kernel header
    files. Then, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On Arch Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On Fedora:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 3 Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the examples from this document are available within the examples subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: Should compile errors occur, it may be due to a more recent kernel version being
    in use, or there might be a need to install the corresponding kernel header files.
  prefs: []
  type: TYPE_NORMAL
- en: 4 Hello World
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 4.1 The Simplest Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most individuals beginning their programming journey typically start with some
    variant of a hello world example. It is unclear what the outcomes are for those
    who deviate from this tradition, but it seems prudent to adhere to it. The learning
    process will begin with a series of hello world programs that illustrate various
    fundamental aspects of writing a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: Presented next is the simplest possible module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a test directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Paste this into your favorite editor and save it as hello-1.c:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you will need a Makefile. If you copy and paste this, change the indentation
    to use tabs, not spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In Makefile, $(CURDIR) can be set to the absolute pathname of the current working
    directory (after all -C options are processed, if any). See more about CURDIR
    in [GNU make manual](https://www.gnu.org/software/make/manual/make.html).
  prefs: []
  type: TYPE_NORMAL
- en: And finally, just run make directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no PWD := $(CURDIR) statement in the Makefile, then it may not
    compile correctly with sudo make. This is because some environment variables are
    specified by the security policy and cannot be inherited. The default security
    policy is sudoers. In the sudoers security policy, env_reset is enabled by default,
    which restricts environment variables. Specifically, path variables are not retained
    from the user environment; they are set to default values (for more information,
    see: [sudoers manual](https://www.sudo.ws/docs/man/sudoers.man/)). You can see
    the environment variable settings by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here is a simple Makefile as an example to demonstrate the problem mentioned
    above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can use the -p flag to print out the environment variable values from
    the Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The PWD variable will not be inherited with sudo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, there are three ways to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the -E flag to temporarily preserve them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can disable env_reset by editing /etc/sudoers as root using visudo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then execute env and sudo env individually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can view and compare these logs to find differences between env_reset and
    !env_reset.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can preserve environment variables by appending them to env_keep in /etc/sudoers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After applying the above change, you can check the environment variable settings
    by:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all goes smoothly you should then find that you have a compiled hello-1.ko
    module. You can find info on it with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'should return nothing. You can try loading your new module with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The dash character will get converted to an underscore, so when you again try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see your loaded module. It can be removed again with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the dash was replaced by an underscore. To see the module’s output
    messages, use `dmesg` to view the kernel log ring buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see messages like “Hello world 1.” and “Goodbye world 1.” from your
    module. Alternatively, you can check the systemd journal for kernel messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You now know the basics of creating, compiling, installing and removing modules.
    Now for more of a description of how this module works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel modules must have at least two functions: a "start" (initialization)
    function called `init_module()` which is called when the module is `insmod` ed
    into the kernel, and an "end" (cleanup) function called `cleanup_module()` which
    is called just before it is removed from the kernel. Actually, things have changed
    starting with kernel 2.3.13\. You can now use whatever name you like for the start
    and end functions of a module, and you will learn how to do this in [Section 4.2](#hello-and-goodbye).
    In fact, the new method is the preferred method. However, many people still use
    `init_module()` and `cleanup_module()` for their start and end functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, `init_module()` either registers a handler for something with the
    kernel, or it replaces one of the kernel functions with its own code (usually
    code to do something and then call the original function). The `cleanup_module()`
    function is supposed to undo whatever `init_module()` did, so the module can be
    unloaded safely.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, every kernel module needs to include <linux/module.h>. We needed to
    include <linux/printk.h> only for the macro expansion for the `pr_alert()` log
    level, which you’ll learn about in [Item 2](#x1-121702).
  prefs: []
  type: TYPE_NORMAL
- en: A point about coding style. Another thing that may not be immediately obvious
    to anyone getting started with kernel programming is that indentation within your
    code should use tabs and not spaces. It is one of the coding conventions of the
    kernel. You may not like it, but you will need to get used to it if you ever submit
    a patch upstream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introducing print macros. In the beginning there was `printk` , usually followed
    by a priority such as `KERN_INFO` or `KERN_DEBUG` . More recently, this can also
    be expressed in abbreviated form using a set of print macros, such as `pr_info`
    and `pr_debug` . This just saves some mindless keyboard bashing and looks a bit
    neater. They can be found within [include/linux/printk.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/printk.h).
    Take time to read through the available priority macros.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Important: These functions write to the kernel log ring buffer, not directly
    to any terminal or console. To view the output from your kernel modules, you must
    use `dmesg` or `journalctl -k` .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: About Compiling. Kernel modules need to be compiled a bit differently from regular
    userspace apps. Former kernel versions required us to care much about these settings,
    which are usually stored in Makefiles. Although hierarchically organized, many
    redundant settings accumulated in sublevel Makefiles and made them large and rather
    difficult to maintain. Fortunately, there is a new way of doing these things,
    called kbuild, and the build process for external loadable modules is now fully
    integrated into the standard kernel build mechanism. To learn more about how to
    compile modules which are not part of the official kernel (such as all the examples
    you will find in this guide), see file [Documentation/kbuild/modules.rst](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/modules.rst).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional details about Makefiles for kernel modules are available in [Documentation/kbuild/makefiles.rst](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/makefiles.rst).
    Be sure to read this and the related files before starting to hack Makefiles.
    It will probably save you lots of work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here is another exercise for the reader. See that comment above the return statement
    in `init_module()` ? Change the return value to something negative, recompile
    and load the module again. What happens?
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 4.2 Hello and Goodbye
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In early kernel versions you had to use the `init_module` and `cleanup_module`
    functions, as in the first hello world example, but these days you can name those
    anything you want by using the `module_init` and `module_exit` macros. These macros
    are defined in [include/linux/module.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h).
    The only requirement is that your init and cleanup functions must be defined before
    calling those macros, otherwise you will get compilation errors. Here is an example
    of this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we have two real kernel modules under our belt. Adding another module
    is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now have a look at [drivers/char/Makefile](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/char/Makefile)
    for a real world example. As you can see, some things got hardwired into the kernel
    (obj-y) but where have all those obj-m gone? Those familiar with shell scripts
    will easily be able to spot them. For those who are not, the obj-$(CONFIG_FOO)
    entries you see everywhere expand into obj-y or obj-m, depending on whether the
    CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly
    the kind of variables that you have set in the .config file in the top-level directory
    of the Linux kernel source tree, the last time you ran `make menuconfig` or something
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 The __init and __exit Macros
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__init` macro causes the init function to be discarded and its memory freed
    once the init function finishes for built-in drivers, but not loadable modules.
    If you think about when the init function is invoked, this makes perfect sense.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an `__initdata` which works similarly to `__init` but for init
    variables rather than functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `__exit` macro causes the omission of the function when the module is built
    into the kernel, and like `__init` , has no effect for loadable modules. Again,
    if you consider when the cleanup function runs, this makes complete sense; built-in
    drivers do not need a cleanup function, while loadable modules do.
  prefs: []
  type: TYPE_NORMAL
- en: 'These macros are defined in [include/linux/init.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/init.h)
    and serve to free up kernel memory. When you boot your kernel and see something
    like Freeing unused kernel memory: 236k freed, this is precisely what the kernel
    is freeing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 4.4 Licensing and Module Documentation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Honestly, who loads or even cares about proprietary modules? If you do then
    you might have seen something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can use a few macros to indicate the license for your module. Some examples
    are "GPL", "GPL v2", "GPL and additional rights", "Dual BSD/GPL", "Dual MIT/GPL",
    "Dual MPL/GPL" and "Proprietary". They are defined within [include/linux/module.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h).
  prefs: []
  type: TYPE_NORMAL
- en: To reference what license you are using, a macro is available called `MODULE_LICENSE`
    . This and a few other macros describing the module are illustrated in the example
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 4.5 Passing Command Line Arguments to a Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modules can take command line arguments, but not with the argc/argv you might
    be used to.
  prefs: []
  type: TYPE_NORMAL
- en: To allow arguments to be passed to your module, declare the variables that will
    take the values of the command line arguments as global and then use the `module_param()`
    macro (defined in [include/linux/moduleparam.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/moduleparam.h))
    to set the mechanism up. At runtime, `insmod` will fill the variables with any
    command line arguments that are given, like `insmod mymodule.ko myvariable=5`
    . The variable declarations and macros should be placed at the beginning of the
    module for clarity. The example code should clear up my admittedly lousy explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `module_param()` macro takes 3 arguments: the name of the variable, its
    type and permissions for the corresponding file in sysfs. Integer types can be
    signed as usual or unsigned. If you would like to use arrays of integers or strings,
    see `module_param_array()` and `module_param_string()` .'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays are supported too, but things are a bit different now than they were
    in the olden days. To keep track of the number of parameters, you need to pass
    a pointer to a count variable as the third parameter. At your option, you could
    also ignore the count and pass `NULL` instead. We show both possibilities here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A good use for this is to have the module variable’s default values set, like
    a port or IO address. If the variables contain the default values, then perform
    autodetection (explained elsewhere). Otherwise, keep the current value. This will
    be made clear later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, there is a macro function, `MODULE_PARM_DESC()` , that is used to document
    arguments that the module can take. It takes two parameters: a variable name and
    a free form string describing that variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended to experiment with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 4.6 Modules Spanning Multiple Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it makes sense to divide a kernel module between several source files.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of such a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is the complete makefile for all the examples we have seen so far. The
    first five lines are nothing special, but for the last example we will need two
    lines. First we invent an object name for our combined module, second we tell
    `make` what object files are part of that module.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Building modules for a precompiled kernel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Obviously, we strongly suggest you to recompile your kernel, so that you can
    enable a number of useful debugging features, such as forced module unloading
    ( `MODULE_FORCE_UNLOAD` ): when this option is enabled, you can force the kernel
    to unload a module even when it believes it is unsafe, via a `sudo rmmod -f module`
    command. This option can save you a lot of time and a number of reboots during
    the development of a module. If you do not want to recompile your kernel then
    you should consider running the examples within a test distribution on a virtual
    machine. If you mess anything up then you can easily reboot or restore the virtual
    machine (VM).'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of cases in which you may want to load your module into a
    precompiled running kernel, such as the ones shipped with common Linux distributions,
    or a kernel you have compiled in the past. In certain circumstances you could
    require to compile and insert a module into a running kernel which you are not
    allowed to recompile, or on a machine that you prefer not to reboot. If you can’t
    think of a case that will force you to use modules for a precompiled kernel you
    might want to skip this and treat the rest of this chapter as a big footnote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you just install a kernel source tree, use it to compile your kernel
    module and you try to insert your module into the kernel, in most cases you would
    obtain an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Less cryptic information is logged to the systemd journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, your kernel refuses to accept your module because version strings
    (more precisely, version magic, see [include/linux/vermagic.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/vermagic.h))
    do not match. Incidentally, version magic strings are stored in the module object
    in the form of a static string, starting with `vermagic:` . Version data are inserted
    in your module when it is linked against the kernel/module.o file. To inspect
    version magics and other strings stored in a given module, issue the command `modinfo module.ko`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To overcome this problem we could resort to the --force-vermagic option, but
    this solution is potentially unsafe, and unquestionably unacceptable in production
    modules. Consequently, we want to compile our module in an environment which was
    identical to the one in which our precompiled kernel was built. How to do this,
    is the subject of the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, make sure that a kernel source tree is available, having exactly
    the same version as your current kernel. Then, find the configuration file which
    was used to compile your precompiled kernel. Usually, this is available in your
    current boot directory, under a name like config-5.14.x. You may just want to
    copy it to your kernel source tree: ``cp /boot/config-`uname -r` .config`` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus again on the previous error message: a closer look at the version
    magic strings suggests that, even with two configuration files which are exactly
    the same, a slight difference in the version magic could be possible, and it is
    sufficient to prevent insertion of the module into the kernel. That slight difference,
    namely the custom string which appears in the module’s version magic and not in
    the kernel’s one, is due to a modification with respect to the original, in the
    makefile that some distributions include. Then, examine your Makefile, and make
    sure that the specified version information matches exactly the one used for your
    current kernel. For example, your makefile could start as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you need to restore the value of symbol EXTRAVERSION to -rc2.
    We suggest keeping a backup copy of the makefile used to compile your kernel available
    in /lib/modules/5.14.0-rc2/build. A simple command as follows should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here `` linux-`uname -r` `` is the Linux kernel source you are attempting to
    build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, please run `make` to update configuration and version headers and objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not desire to actually compile the kernel, you can interrupt the
    build process (CTRL-C) just after the SPLIT line, because at that time, the files
    you need are ready. Now you can turn back to the directory of your module and
    compile it: It will be built exactly according to your current kernel settings,
    and it will load into it without any errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 5 Preliminaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 5.1 How modules begin and end
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A typical program starts with a `main()` function, executes a series of instructions,
    and terminates after completing these instructions. Kernel modules, however, follow
    a different pattern. A module always begins with either the `init_module` function
    or a function designated by the `module_init` call. This function acts as the
    module’s entry point, informing the kernel of the module’s functionalities and
    preparing the kernel to utilize the module’s functions when necessary. After performing
    these tasks, the entry function returns, and the module remains inactive until
    the kernel requires its code.
  prefs: []
  type: TYPE_NORMAL
- en: All modules conclude by invoking either `cleanup_module` or a function specified
    through the `module_exit` call. This serves as the module’s exit function, reversing
    the actions of the entry function by unregistering the previously registered functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: It is mandatory for every module to have both an entry and an exit function.
    While there are multiple methods to define these functions, the terms “entry function”
    and “exit function” are generally used. However, they may occasionally be referred
    to as `init_module` and `cleanup_module` , which are understood to mean the same.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Functions available to modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programmers use functions they do not define all the time. A prime example of
    this is `printf()` . You use these library functions which are provided by the
    standard C library, libc. The definitions for these functions do not actually
    enter your program until the linking stage, which ensures that the code (for `printf()`
    for example) is available, and fixes the call instruction to point to that code.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel modules are different here, too. In the hello world example, you might
    have noticed that we used a function, `pr_info()` but did not include a standard
    I/O library. That is because modules are object files whose symbols get resolved
    upon running `insmod` or `modprobe` . The definition for the symbols comes from
    the kernel itself; the only external functions you can use are the ones provided
    by the kernel. If you’re curious about what symbols have been exported by your
    kernel, take a look at /proc/kallsyms.
  prefs: []
  type: TYPE_NORMAL
- en: One point to keep in mind is the difference between library functions and system
    calls. Library functions are higher level, run completely in user space and provide
    a more convenient interface for the programmer to the functions that do the real
    work — system calls. System calls run in kernel mode on the user’s behalf and
    are provided by the kernel itself. The library function `printf()` may look like
    a very general printing function, but all it really does is format the data into
    strings and write the string data using the low-level system call `write()` ,
    which then sends the data to standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Would you like to see what system calls are made by `printf()` ? It is easy!
    Compile the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: with `gcc -Wall -o hello hello.c` . Run the executable with `strace ./hello`
    . Are you impressed? Every line you see corresponds to a system call. [strace](https://strace.io/)
    is a handy program that gives you details about what system calls a program is
    making, including which call is made, what its arguments are and what it returns.
    It is an invaluable tool for figuring out things like what files a program is
    trying to access. Towards the end, you will see a line which looks like `write(1, "hello", 5hello)`
    . There it is. The face behind the `printf()` mask. You may not be familiar with
    write, since most people use library functions for file I/O (like `fopen` , `fputs`
    , `fclose` ). If that is the case, try looking at man 2 write. The 2nd man section
    is devoted to system calls (like `kill()` and `read()` ). The 3rd man section
    is devoted to library calls, which you would probably be more familiar with (like
    `cosh()` and `random()` ).
  prefs: []
  type: TYPE_NORMAL
- en: You can even write modules to replace the kernel’s system calls, which we will
    do shortly. Crackers often make use of this sort of thing for backdoors or trojans,
    but you can write your own modules to do more benign things, like have the kernel
    log a message whenever someone attempts to delete a file on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 User Space vs Kernel Space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The kernel primarily manages access to resources, be it a video card, hard drive,
    or memory. Programs frequently vie for the same resources. For instance, as a
    document is saved, updatedb might commence updating the locate database. Sessions
    in editors like vim and processes like updatedb can simultaneously utilize the
    hard drive. The kernel’s role is to maintain order, ensuring that users do not
    access resources indiscriminately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage this, CPUs operate in different modes, each offering varying levels
    of system control. The Intel 80386 architecture, for example, featured four such
    modes, known as rings. Unix, however, utilizes only two of these rings: the highest
    ring (ring 0, also known as “supervisor mode”, where all actions are permissible)
    and the lowest ring, referred to as “user mode”.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall the discussion about library functions vs system calls. Typically, you
    use a library function in user mode. The library function calls one or more system
    calls, and these system calls execute on the library function’s behalf, but do
    so in supervisor mode since they are part of the kernel itself. Once the system
    call completes its task, it returns and execution gets transferred back to user
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Name Space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you write a small C program, you use variables which are convenient and
    make sense to the reader. If, on the other hand, you are writing routines which
    will be part of a bigger problem, any global variables you have are part of a
    community of other peoples’ global variables; some of the variable names can clash.
    When a program has lots of global variables which aren’t meaningful enough to
    be distinguished, you get namespace pollution. In large projects, effort must
    be made to remember reserved names, and to find ways to develop a scheme for naming
    unique variable names and symbols.
  prefs: []
  type: TYPE_NORMAL
- en: When writing kernel code, even the smallest module will be linked against the
    entire kernel, so this is definitely an issue. The best way to deal with this
    is to declare all your variables as static and to use a well-defined prefix for
    your symbols. By convention, all kernel prefixes are lowercase. If you do not
    want to declare everything as static, another option is to declare a symbol table
    and register it with the kernel. We will get to this later.
  prefs: []
  type: TYPE_NORMAL
- en: The file /proc/kallsyms holds all the symbols that the kernel knows about and
    which are therefore accessible to your modules since they share the kernel’s codespace.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Code space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Memory management is a very complicated subject and the majority of O’Reilly’s
    [Understanding The Linux Kernel](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/)
    exclusively covers memory management! We are not setting out to be experts on
    memory management, but we do need to know a couple of facts to even begin worrying
    about writing real modules.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not thought about what a segfault really means, you may be surprised
    to hear that pointers do not actually point to memory locations. Not real ones,
    anyway. When a process is created, the kernel sets aside a portion of real physical
    memory and hands it to the process to use for its executing code, variables, stack,
    heap and other things which a computer scientist would know about. This memory
    begins with 0x00000000 and extends up to whatever it needs to be. Since the memory
    space for any two processes does not overlap, every process that can access a
    memory address, say 0xbffff978, would be accessing a different location in real
    physical memory! The processes would be accessing an index named 0xbffff978 which
    points to some kind of offset into the region of memory set aside for that particular
    process. For the most part, a process like our Hello, World program cannot access
    the space of another process, although there are ways which we will talk about
    later.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel has its own space of memory as well. Since a module is code which
    can be dynamically inserted and removed in the kernel (as opposed to a semi-autonomous
    object), it shares the kernel’s codespace rather than having its own. Therefore,
    if your module segfaults, the kernel segfaults. And if you start writing over
    data because of an off-by-one error, then you’re trampling on kernel data (or
    code). This is even worse than it sounds, so try your best to be careful.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the aforementioned discussion applies to any operating
    system utilizing a monolithic kernel. This concept differs slightly from “building
    all your modules into the kernel”, although the underlying principle is similar.
    In contrast, there are microkernels, where modules are allocated their own code
    space. Two notable examples of microkernels include the [GNU Hurd](https://www.gnu.org/software/hurd/)
    and the [Zircon kernel](https://fuchsia.dev/fuchsia-src/concepts/kernel) of Google’s
    Fuchsia.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Device Drivers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One class of module is the device driver, which provides functionality for hardware
    like a serial port. On Unix, each piece of hardware is represented by a file located
    in /dev named a device file which provides the means to communicate with the hardware.
    The device driver provides the communication on behalf of a user program. So the
    es1370.ko sound card device driver might connect the /dev/sound device file to
    the Ensoniq ES1370 sound card. A userspace program like mp3blaster can use /dev/sound
    without ever knowing what kind of sound card is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some device files. Here are device files which represent the
    first three partitions on the primary SCSI storage devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice the column of numbers separated by a comma. The first number is called
    the device’s major number. The second number is the minor number. The major number
    tells you which driver is used to access the hardware. Each driver is assigned
    a unique major number; all device files with the same major number are controlled
    by the same driver. All the above major numbers are 8, because they’re all controlled
    by the same driver.
  prefs: []
  type: TYPE_NORMAL
- en: The minor number is used by the driver to distinguish between the various hardware
    it controls. Returning to the example above, although all three devices are handled
    by the same driver they have unique minor numbers because the driver sees them
    as being different pieces of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Devices are divided into two types: character devices and block devices. The
    difference is that block devices have a buffer for requests, so they can choose
    the best order in which to respond to the requests. This is important in the case
    of storage devices, where it is faster to read or write sectors which are close
    to each other, rather than those which are further apart. Another difference is
    that block devices can only accept input and return output in blocks (whose size
    can vary according to the device), whereas character devices are allowed to use
    as many or as few bytes as they like. Most devices in the world are character,
    because they don’t need this type of buffering, and they don’t operate with a
    fixed block size. You can tell whether a device file is for a block device or
    a character device by looking at the first character in the output of `ls -l`
    . If it is ‘b’ then it is a block device, and if it is ‘c’ then it is a character
    device. The devices you see above are block devices. Here are some character devices
    (the serial ports):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you want to see which major numbers have been assigned, you can look at [Documentation/admin-guide/devices.txt](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt).
  prefs: []
  type: TYPE_NORMAL
- en: When the system was installed, all of those device files were created by the
    `mknod` command. To create a new char device named coffee with major/minor number
    12 and 2, simply do `mknod /dev/coffee c 12 2` . You do not have to put your device
    files into /dev, but it is done by convention. Linus put his device files in /dev,
    and so should you. However, when creating a device file for testing purposes,
    it is probably OK to place it in your working directory where you compile the
    kernel module. Just be sure to put it in the right place when you’re done writing
    the device driver.
  prefs: []
  type: TYPE_NORMAL
- en: A few final points, although implicit in the previous discussion, are worth
    stating explicitly for clarity. When a device file is accessed, the kernel utilizes
    the file’s major number to identify the appropriate driver for handling the access.
    This indicates that the kernel does not necessarily rely on or need to be aware
    of the minor number. It is the driver that concerns itself with the minor number,
    using it to differentiate between various pieces of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that when referring to “hardware”, the term is used
    in a slightly more abstract sense than just a physical PCI card that can be held
    in hand. Consider the following two device files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: By now you can look at these two device files and know instantly that they are
    block devices and are handled by same driver (block major 8). Sometimes two device
    files with the same major but different minor number can actually represent the
    same piece of physical hardware. So just be aware that the word “hardware” in
    our discussion can mean something very abstract.
  prefs: []
  type: TYPE_NORMAL
- en: 6 Character Device drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 6.1 The file_operations Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `file_operations` structure is defined in [include/linux/fs.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h),
    and holds pointers to functions defined by the driver that perform various operations
    on the device. Each field of the structure corresponds to the address of some
    function defined by the driver to handle a requested operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, every character driver needs to define a function that reads from
    the device. The `file_operations` structure holds the address of the module’s
    function that performs that operation. Here is what the definition looks like
    for kernel 5.4 and later versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Some operations are not implemented by a driver. For example, a driver that
    handles a video card will not need to read from a directory structure. The corresponding
    entries in the `file_operations` structure should be set to `NULL` . [¹](#fn1x0)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a gcc extension that makes assigning to this structure more convenient.
    You will see it in modern drivers, and may catch you by surprise. This is what
    the new way of assigning to the structure looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is also a C99 way of assigning to elements of a structure, [designated
    initializers](https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html), and this
    is definitely preferred over using the GNU extension. You should use this syntax
    in case someone wants to port your driver. It will help with compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The meaning is clear, and you should be aware that any member of the structure
    which you do not explicitly assign will be initialized to `NULL` by gcc.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `struct file_operations` containing pointers to functions that
    are used to implement `read` , `write` , `open` , … system calls is commonly named
    `fops` .
  prefs: []
  type: TYPE_NORMAL
- en: Since Linux v3.14, the read, write and seek operations are guaranteed for thread-safe
    by using the `f_pos` specific lock, which makes the file position update to become
    the mutual exclusion. So, we can safely implement those operations without unnecessary
    locking.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, since Linux v5.6, the `proc_ops` structure was introduced to replace
    the use of the `file_operations` structure when registering proc handlers. See
    more information in the [Section 7.1](#the-procops-structure).
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 The file structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each device is represented in the kernel by a file structure, which is defined
    in [include/linux/fs.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h).
    Be aware that a file is a kernel level structure and never appears in a user space
    program. It is not the same thing as a `FILE` , which is defined by glibc and
    would never appear in a kernel space function. Also, its name is a bit misleading;
    it represents an abstract open ‘file’, not a file on a disk, which is represented
    by a structure named `inode` .
  prefs: []
  type: TYPE_NORMAL
- en: An instance of struct file is commonly named `filp` . You’ll also see it referred
    to as a struct file object. Resist the temptation.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and look at the definition of file. Most of the entries you see, like
    struct dentry, are not used by device drivers, and you can ignore them. This is
    because drivers do not fill file directly; they only use structures contained
    in file which are created elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Registering A Device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed earlier, char devices are accessed through device files, usually
    located in /dev. This is by convention. When writing a driver, it is OK to put
    the device file in your current directory. Just make sure you place it in /dev
    for a production driver. The major number tells you which driver handles which
    device file. The minor number is used only by the driver itself to differentiate
    which device it is operating on, just in case the driver handles more than one
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a driver to your system means registering it with the kernel. This is
    synonymous with assigning it a major number during the module’s initialization.
    You do this by using the `register_chrdev` function, defined by [include/linux/fs.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Where `unsigned int major` is the major number you want to request, `const char *name`
    is the name of the device as it will appear in /proc/devices and `struct file_operations *fops`
    is a pointer to the `file_operations` table for your driver. A negative return
    value means the registration failed. Note that we didn’t pass the minor number
    to `register_chrdev` . That is because the kernel doesn’t care about the minor
    number; only our driver uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Now the question is, how do you get a major number without hijacking one that’s
    already in use? The easiest way would be to look through [Documentation/admin-guide/devices.txt](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt)
    and pick an unused one. That is a bad way of doing things because you will never
    be sure if the number you picked will be assigned later. The answer is that you
    can ask the kernel to assign you a dynamic major number.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass a major number of 0 to `register_chrdev` , the return value will
    be the dynamically allocated major number. The downside is that you can not make
    a device file in advance, since you do not know what the major number will be.
    There are a couple of ways to do this. First, the driver itself can print the
    newly assigned number and we can make the device file by hand. Second, the newly
    registered device will have an entry in /proc/devices, and we can either make
    the device file by hand or write a shell script to read the file in and make the
    device file. The third method is that we can have our driver make the device file
    using the `device_create` function after a successful registration and `device_destroy`
    during the call to `cleanup_module` .
  prefs: []
  type: TYPE_NORMAL
- en: However, `register_chrdev()` would occupy a range of minor numbers associated
    with the given major. The recommended way to reduce waste for char device registration
    is using cdev interface.
  prefs: []
  type: TYPE_NORMAL
- en: The newer interface completes the char device registration in two distinct steps.
    First, we should register a range of device numbers, which can be completed with
    `register_chrdev_region` or `alloc_chrdev_region` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The choice between two different functions depends on whether you know the major
    numbers for your device. Using `register_chrdev_region` if you know the device
    major number and `alloc_chrdev_region` if you would like to allocate a dynamically-allocated
    major number.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we should initialize the data structure `struct cdev` for our char device
    and associate it with the device numbers. To initialize the `struct cdev` , we
    can achieve by the similar sequence of the following codes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: However, the common usage pattern will embed the `struct cdev` within a device-specific
    structure of your own. In this case, we’ll need `cdev_init` for the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Once we finish the initialization, we can add the char device to the system
    by using the `cdev_add` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To find an example using the interface, you can see ioctl.c described in [Section 9](#talking-to-device-files).
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Unregistering A Device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can not allow the kernel module to be `rmmod` ’ed whenever root feels like
    it. If the device file is opened by a process and then we remove the kernel module,
    using the file would cause a call to the memory location where the appropriate
    function (read/write) used to be. If we are lucky, no other code was loaded there,
    and we’ll get an ugly error message. If we are unlucky, another kernel module
    was loaded into the same location, which means a jump into the middle of another
    function within the kernel. The results of this would be impossible to predict,
    but they can not be very positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when you do not want to allow something, you return an error code
    (a negative number) from the function which is supposed to do it. With `cleanup_module`
    that’s impossible because it is a void function. However, there is a counter which
    keeps track of how many processes are using your module. You can see what its
    value is by looking at the 3rd field with the command `cat /proc/modules` or `lsmod`
    . If this number isn’t zero, `rmmod` will fail. Note that you do not have to check
    the counter within `cleanup_module` because the check will be performed for you
    by the system call `sys_delete_module` , defined in [include/linux/syscalls.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/syscalls.h).
    You should not use this counter directly, but there are functions defined in [include/linux/module.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h)
    which let you display this counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module_refcount(THIS_MODULE)` : Return the value of reference count of current
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: The use of `try_module_get(THIS_MODULE)` and `module_put(THIS_MODULE)`
    within a module’s own code is considered unsafe and should be avoided. The kernel
    automatically manages the reference count when file operations are in progress,
    so manual reference counting is unnecessary and can lead to race conditions. For
    a deeper understanding of when and how to properly use module reference counting,
    see [https://stackoverflow.com/questions/1741415/linux-kernel-modules-when-to-use-try-module-get-module-put](https://stackoverflow.com/questions/1741415/linux-kernel-modules-when-to-use-try-module-get-module-put).'
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 chardev.c
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next code sample creates a char driver named chardev. You can verify it
    has been registered by checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will show the device’s major number. To actually use the device, you need
    to read from /dev/chardev (or open the file with a program) and the driver will
    put the number of times the device file has been read from into the file. We do
    not support writing to the file (like `echo "hi" > /dev/chardev` ), but catch
    these attempts and tell the user that the operation is not supported. Do not worry
    if you do not see what we do with the data we read into the buffer; we do not
    do much with it. We simply read in the data and print a message acknowledging
    that we received it.
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-threaded environment, without any protection, concurrent access to
    the same memory may lead to race conditions and will not preserve performance.
    In the kernel module, this problem may happen due to multiple instances accessing
    the shared resources. Therefore, a solution is to enforce exclusive access. We
    use atomic Compare-And-Swap (CAS) to maintain the states, `CDEV_NOT_USED` and
    `CDEV_EXCLUSIVE_OPEN` , to determine whether the file is currently opened by someone
    or not. CAS compares the contents of a memory location with the expected value
    and, only if they are the same, modifies the contents of that memory location
    to the desired value. See more concurrency details in the [Section 12](#synchronization).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 6.6 Writing Modules for Multiple Kernel Versions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The system calls, which are the major interface the kernel shows to the processes,
    generally stay the same across versions. A new system call may be added, but usually
    the old ones will behave exactly like they used to. This is necessary for backward
    compatibility – a new kernel version is not supposed to break regular processes.
    In most cases, the device files will also remain the same. On the other hand,
    the internal interfaces within the kernel can and do change between versions.
  prefs: []
  type: TYPE_NORMAL
- en: There are differences between different kernel versions, and if you want to
    support multiple kernel versions, you will find yourself having to code conditional
    compilation directives. The way to do this is to compare the macro `LINUX_VERSION_CODE`
    to the macro `KERNEL_VERSION` . In version a.b.c of the kernel, the value of this
    macro would be ![216a+ 28b+ c  ](img/7b83dc18db2a578cd2fb1a4ad4ae584e.png).
  prefs: []
  type: TYPE_NORMAL
- en: 7 The /proc Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux, there is an additional mechanism for the kernel and kernel modules
    to send information to processes — the /proc filesystem. Originally designed to
    allow easy access to information about processes (hence the name), it is now used
    by every bit of the kernel which has something interesting to report, such as
    /proc/modules which provides the list of modules and /proc/meminfo which gathers
    memory usage statistics.
  prefs: []
  type: TYPE_NORMAL
- en: The method to use the proc filesystem is very similar to the one used with device
    drivers — a structure is created with all the information needed for the /proc
    file, including pointers to any handler functions (in our case there is only one,
    the one called when somebody attempts to read from the /proc file). Then, `init_module`
    registers the structure with the kernel and `cleanup_module` unregisters it.
  prefs: []
  type: TYPE_NORMAL
- en: Normal filesystems are located on a disk, rather than just in memory (which
    is where /proc is), and in that case the index-node (inode for short) number is
    a pointer to a disk location where the file’s inode is located. The inode contains
    information about the file, for example the file’s permissions, together with
    a pointer to the disk location or locations where the file’s data can be found.
  prefs: []
  type: TYPE_NORMAL
- en: Because we do not get called when the file is opened or closed, there is nowhere
    for us to put `try_module_get` and `module_put` in this module, and if the file
    is opened and then the module is removed, there is no way to avoid the consequences.
    The kernel’s automatic reference counting for file operations helps prevent module
    removal while files are in use, but /proc files require careful handling due to
    their different lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example showing how to use a /proc file. This is the HelloWorld
    for the /proc filesystem. There are three parts: create the file /proc/helloworld
    in the function `init_module` , return a value (and a buffer) when the file /proc/helloworld
    is read in the callback function `procfile_read` , and delete the file /proc/helloworld
    in the function `cleanup_module` .'
  prefs: []
  type: TYPE_NORMAL
- en: The /proc/helloworld is created when the module is loaded with the function
    `proc_create` . The return value is a pointer to `struct proc_dir_entry` , and
    it will be used to configure the file /proc/helloworld (for example, the owner
    of this file). A null return value means that the creation has failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time the file /proc/helloworld is read, the function `procfile_read`
    is called. Two parameters of this function are very important: the buffer (the
    second parameter) and the offset (the fourth one). The content of the buffer will
    be returned to the application which read it (for example the `cat` command).
    The offset is the current position in the file. If the return value of the function
    is not null, then this function is called again. So be careful with this function,
    if it never returns zero, the read function is called endlessly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 7.1 The proc_ops Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `proc_ops` structure is defined in [include/linux/proc_fs.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/proc_fs.h)
    in Linux v5.6+. In older kernels, it used `file_operations` for custom hooks in
    /proc filesystem, but it contains some members that are unnecessary in VFS, and
    every time VFS expands `file_operations` set, /proc code comes bloated. On the
    other hand, not only the space, but also some operations were saved by this structure
    to improve its performance. For example, the file which never disappears in /proc
    can set the `proc_flag` as `PROC_ENTRY_PERMANENT` to save 2 atomic ops, 1 allocation,
    1 free in per open/read/close sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Read and Write a /proc File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have seen a very simple example for a /proc file where we only read the file
    /proc/helloworld. It is also possible to write in a /proc file. It works the same
    way as read, a function is called when the /proc file is written. But there is
    a little difference with read, data comes from user, so you have to import data
    from user space to kernel space (with `copy_from_user` or `get_user` )
  prefs: []
  type: TYPE_NORMAL
- en: The reason for `copy_from_user` or `get_user` is that Linux memory (on Intel
    architecture, it may be different under some other processors) is segmented. This
    means that a pointer, by itself, does not reference a unique location in memory,
    only a location in a memory segment, and you need to know which memory segment
    it is to be able to use it. There is one memory segment for the kernel, and one
    for each of the processes.
  prefs: []
  type: TYPE_NORMAL
- en: The only memory segment accessible to a process is its own, so when writing
    regular programs to run as processes, there is no need to worry about segments.
    When you write a kernel module, normally you want to access the kernel memory
    segment, which is handled automatically by the system. However, when the content
    of a memory buffer needs to be passed between the currently running process and
    the kernel, the kernel function receives a pointer to the memory buffer which
    is in the process segment. The `put_user` and `get_user` macros allow you to access
    that memory. These functions handle only one character, you can handle several
    characters with `copy_to_user` and `copy_from_user` . As the buffer (in read or
    write function) is in kernel space, for write function you need to import data
    because it comes from user space, but not for the read function because data is
    already in kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 7.3 Manage /proc file with standard filesystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have seen how to read and write a /proc file with the /proc interface. But
    it is also possible to manage /proc file with inodes. The main concern is to use
    advanced functions, like permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, there is a standard mechanism for filesystem registration. Since every
    filesystem has to have its own functions to handle inode and file operations,
    there is a special structure to hold pointers to all those functions, `struct inode_operations`
    , which includes a pointer to `struct proc_ops` .
  prefs: []
  type: TYPE_NORMAL
- en: The difference between file and inode operations is that file operations deal
    with the file itself whereas inode operations deal with ways of referencing the
    file, such as creating links to it.
  prefs: []
  type: TYPE_NORMAL
- en: In /proc, whenever we register a new file, we’re allowed to specify which `struct inode_operations`
    will be used to access to it. This is the mechanism we use, a `struct inode_operations`
    which includes a pointer to a `struct proc_ops` which includes pointers to our
    `procfs_read` and `procfs_write` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting point here is the `module_permission` function. This function
    is called whenever a process tries to do something with the /proc file, and it
    can decide whether to allow access or not. Right now it is only based on the operation
    and the uid of the current user (as available in current, a pointer to a structure
    which includes information on the currently running process), but it could be
    based on anything we like, such as what other processes are doing with the same
    file, the time of day, or the last input we received.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the standard roles of read and write are reversed
    in the kernel. Read functions are used for output, whereas write functions are
    used for input. The reason for that is that read and write refer to the user’s
    point of view — if a process reads something from the kernel, then the kernel
    needs to output it, and if a process writes something to the kernel, then the
    kernel receives it as input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Still hungry for procfs examples? Well, first of all keep in mind, there are
    rumors around, claiming that procfs is on its way out, consider using sysfs instead.
    Consider using this mechanism, in case you want to document something kernel related
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Manage /proc file with seq_file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we have seen, writing a /proc file may be quite “complex”. So to help people
    writing /proc file, there is an API named `seq_file` that helps formatting a /proc
    file for output. It is based on sequence, which is composed of 3 functions: `start()`
    , `next()` , and `stop()` . The `seq_file` API starts a sequence when a user reads
    the /proc file.'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence begins with the call of the function `start()` . If the return is
    a non `NULL` value, the function `next()` is called; otherwise, the `stop()` function
    is called directly. This function is an iterator, the goal is to go through all
    the data. Each time `next()` is called, the function `show()` is also called.
    It writes data values in the buffer read by the user. The function `next()` is
    called until it returns `NULL` . The sequence ends when `next()` returns `NULL`
    , then the function `stop()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'BE CAREFUL: when a sequence is finished, another one starts. That means that
    at the end of function `stop()` , the function `start()` is called again. This
    loop finishes when the function `start()` returns `NULL` . You can see a scheme
    of this in the [Figure 1](#ignorespaces-how-seqfile-works).'
  prefs: []
  type: TYPE_NORMAL
- en: '![srrsYNNYtaenetoeooertuetupsstrxr((ntn))( tis)istrr teeaNreNatUaUtmLtLmeLmLen?e?ntntt  ](img/8209b6ea27687e8832cc85a37f5784c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1:How seq_file works
  prefs: []
  type: TYPE_NORMAL
- en: The `seq_file` provides basic functions for `proc_ops` , such as `seq_read`
    , `seq_lseek` , and some others. But nothing to write in the /proc file. Of course,
    you can still use the same way as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want more information, you can read this web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://lwn.net/Articles/22355/](https://lwn.net/Articles/22355/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://kernelnewbies.org/Documents/SeqFileHowTo](https://kernelnewbies.org/Documents/SeqFileHowTo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also read the code of [fs/seq_file.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/seq_file.c)
    in the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '8 sysfs: Interacting with your module'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: sysfs allows you to interact with the running kernel from userspace by reading
    or setting variables inside of modules. This can be useful for debugging purposes,
    or just as an interface for applications or scripts. You can find sysfs directories
    and files under the /sys directory on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Attributes can be exported for kobjects in the form of regular files in the
    filesystem. Sysfs forwards file I/O operations to methods defined for the attributes,
    providing a means to read and write kernel attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple attribute definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the driver model defines `struct device_attribute` like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To read or write attributes, the `show()` or `store()` method must be specified
    when declaring the attribute. For the common cases [include/linux/sysfs.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sysfs.h)
    provides convenience macros ( `__ATTR` , `__ATTR_RO` , `__ATTR_WO` , etc.) to
    make defining attributes easier as well as making code more concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a hello world module which includes the creation of a variable
    accessible via sysfs is given below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Make and install the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: What is the current value of `myvariable` ?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Set the value of `myvariable` and check that it changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remove the test module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the above case, we use a simple kobject to create a directory under sysfs,
    and communicate with its attributes. Since Linux v2.6.0, the `kobject` structure
    made its appearance. It was initially meant as a simple way of unifying kernel
    code which manages reference counted objects. After a bit of mission creep, it
    is now the glue that holds much of the device model and its sysfs interface together.
    For more information about kobject and sysfs, see [Documentation/driver-api/driver-model/driver.rst](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/driver-api/driver-model/driver.rst)
    and [https://lwn.net/Articles/51437/](https://lwn.net/Articles/51437/).
  prefs: []
  type: TYPE_NORMAL
- en: 9 Talking To Device Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Device files are supposed to represent physical devices. Most physical devices
    are used for output as well as input, so there has to be some mechanism for device
    drivers in the kernel to get the output to send to the device from processes.
    This is done by opening the device file for output and writing to it, just like
    writing to a file. In the following example, this is implemented by `device_write`
    .
  prefs: []
  type: TYPE_NORMAL
- en: This is not always enough. Imagine you had a serial port connected to a modem
    (even if you have an internal modem, it is still implemented from the CPU’s perspective
    as a serial port connected to a modem, so you don’t have to tax your imagination
    too hard). The natural thing to do would be to use the device file to write things
    to the modem (either modem commands or data to be sent through the phone line)
    and read things from the modem (either responses for commands or the data received
    through the phone line). However, this leaves open the question of what to do
    when you need to talk to the serial port itself, for example to configure the
    rate at which data is sent and received.
  prefs: []
  type: TYPE_NORMAL
- en: The answer in Unix is to use a special function called `ioctl` (short for Input
    Output ConTroL). Every device can have its own `ioctl` commands, which can be
    read ioctl’s (to send information from a process to the kernel), write ioctl’s
    (to return information to a process), both or neither. Notice here the roles of
    read and write are reversed again, so in ioctl’s read is to send information to
    the kernel and write is to receive information from the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ioctl function is called with three parameters: the file descriptor of
    the appropriate device file, the ioctl number, and a parameter, which is of type
    long so you can use a cast to use it to pass anything. You will not be able to
    pass a structure this way, but you will be able to pass a pointer to the structure.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can see there is an argument called `cmd` in `test_ioctl_ioctl()` function.
    It is the ioctl number. The ioctl number encodes the major device number, the
    type of the ioctl, the command, and the type of the parameter. This ioctl number
    is usually created by a macro call ( `_IO` , `_IOR` , `_IOW` or `_IOWR` — depending
    on the type) in a header file. This header file should then be included both by
    the programs which will use ioctl (so they can generate the appropriate ioctl’s)
    and by the kernel module (so it can understand it). In the example below, the
    header file is chardev.h and the program which uses it is userspace_ioctl.c.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use ioctls in your own kernel modules, it is best to receive
    an official ioctl assignment, so if you accidentally get somebody else’s ioctls,
    or if they get yours, you’ll know something is wrong. For more information, consult
    the kernel source tree at [Documentation/userspace-api/ioctl/ioctl-number.rst](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to be careful that concurrent access to the shared resources will
    lead to the race condition. The solution is using atomic Compare-And-Swap (CAS),
    which we mentioned at [Section 6.5](#chardevc), to enforce the exclusive access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 10 System Calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, the only thing we’ve done was to use well defined kernel mechanisms
    to register /proc files and device handlers. This is fine if you want to do something
    the kernel programmers thought you’d want, such as write a device driver. But
    what if you want to do something unusual, to change the behavior of the system
    in some way? Then, you are mostly on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this example has been unavailable since Linux v6.9\. Specifically,
    after this [commit](https://github.com/torvalds/linux/commit/1e3ad78334a69b36e107232e337f9d693dcc9df2#diff-4a16bf89a09b4f49669a30d54540f0b936ea0224dc6ee9edfa7700deb16c3e11R52),
    due to the system call table changing the implementation from an indirect function
    call table to a switch statement for security issues, such as Branch History Injection
    (BHI) attack. See more information [here](https://bugs.launchpad.net/ubuntu/+source/linux/+bug/2060909).
  prefs: []
  type: TYPE_NORMAL
- en: Should one choose not to use a virtual machine, kernel programming can become
    risky. For example, while writing the code below, the `open()` system call was
    inadvertently disrupted. This resulted in an inability to open any files, run
    programs, or shut down the system, necessitating a restart of the virtual machine.
    Fortunately, no critical files were lost in this instance. However, if such modifications
    were made on a live, mission-critical system, the consequences could be severe.
    To mitigate the risk of file loss, even in a test environment, it is advised to
    execute `sync` right before using `insmod` and `rmmod` .
  prefs: []
  type: TYPE_NORMAL
- en: Forget about /proc files, forget about device files. They are just minor details.
    Minutiae in the vast expanse of the universe. The real process to kernel communication
    mechanism, the one used by all processes, is system calls. When a process requests
    a service from the kernel (such as opening a file, forking to a new process, or
    requesting more memory), this is the mechanism used. If you want to change the
    behaviour of the kernel in interesting ways, this is the place to do it. By the
    way, if you want to see which system calls a program uses, run `strace <arguments>`
    .
  prefs: []
  type: TYPE_NORMAL
- en: In general, a process is not supposed to be able to access the kernel. It can
    not access kernel memory and it can’t call kernel functions. The hardware of the
    CPU enforces this (that is the reason why it is called “protected mode” or “page
    protection”).
  prefs: []
  type: TYPE_NORMAL
- en: System calls are an exception to this general rule. What happens is that the
    process fills the registers with the appropriate values and then calls a special
    instruction which jumps to a previously defined location in the kernel (of course,
    that location is readable by user processes, it is not writable by them). Under
    Intel CPUs, this is done by means of interrupt 0x80\. The hardware knows that
    once you jump to this location, you are no longer running in restricted user mode,
    but as the operating system kernel — and therefore you’re allowed to do whatever
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: The location in the kernel a process can jump to is called system_call. The
    procedure at that location checks the system call number, which tells the kernel
    what service the process requested. Then, it looks at the table of system calls
    ( `sys_call_table` ) to see the address of the kernel function to call. Then it
    calls the function, and after it returns, does a few system checks and then return
    back to the process (or to a different process, if the process time ran out).
    If you want to read this code, it is at the source file arch/$(architecture)/kernel/entry.S,
    after the line `ENTRY(system_call)` .
  prefs: []
  type: TYPE_NORMAL
- en: So, if we want to change the way a certain system call works, what we need to
    do is to write our own function to implement it (usually by adding a bit of our
    own code, and then calling the original function) and then change the pointer
    at `sys_call_table` to point to our function. Because we might be removed later
    and we don’t want to leave the system in an unstable state, it’s important for
    `cleanup_module` to restore the table to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: To modify the content of `sys_call_table` , we need to consider the control
    register. A control register is a processor register that changes or controls
    the general behavior of the CPU. For x86 architecture, the cr0 register has various
    control flags that modify the basic operation of the processor. The WP flag in
    cr0 stands for write protection. Once the WP flag is set, the processor disallows
    further write attempts to the read-only sections. Therefore, we must disable the
    WP flag before modifying `sys_call_table` . Since Linux v5.3, the `write_cr0`
    function cannot be used because of the sensitive cr0 bits pinned by the security
    issue, the attacker may write into CPU control registers to disable CPU protections
    like write protection. As a result, we have to provide the custom assembly routine
    to bypass it.
  prefs: []
  type: TYPE_NORMAL
- en: However, `sys_call_table` symbol is unexported to prevent misuse. But there
    have few ways to get the symbol, manual symbol lookup and `kallsyms_lookup_name`
    . Here we use both depend on the kernel version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the control-flow integrity, which is a technique to prevent the
    redirect execution code from the attacker, for making sure that the indirect calls
    go to the expected addresses and the return addresses are not changed. Since Linux
    v5.7, the kernel patched the series of control-flow enforcement (CET) for x86,
    and some configurations of GCC, like GCC versions 9 and 10 in Ubuntu Linux, will
    add with CET (the -fcf-protection option) in the kernel by default. Using that
    GCC to compile the kernel with retpoline off may result in CET being enabled in
    the kernel. You can use the following command to check out the -fcf-protection
    option is enabled or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: But CET should not be enabled in the kernel, it may break the Kprobes and bpf.
    Consequently, CET is disabled since v5.11\. To guarantee the manual symbol lookup
    worked, we only use up to v5.4.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, since Linux v5.7 `kallsyms_lookup_name` is also unexported, it
    needs certain trick to get the address of `kallsyms_lookup_name` . If `CONFIG_KPROBES`
    is enabled, we can facilitate the retrieval of function addresses by means of
    Kprobes to dynamically break into the specific kernel routine. Kprobes inserts
    a breakpoint at the entry of function by replacing the first bytes of the probed
    instruction. When a CPU hits the breakpoint, registers are stored, and the control
    will pass to Kprobes. It passes the addresses of the saved registers and the Kprobe
    struct to the handler you defined, then executes it. Kprobes can be registered
    by symbol name or address. Within the symbol name, the address will be handled
    by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, specify the address of `sys_call_table` from /proc/kallsyms and
    /boot/System.map into `sym` parameter. Following is the sample usage for /proc/kallsyms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Using the address from /boot/System.map, be careful about KASLR (Kernel Address
    Space Layout Randomization). KASLR may randomize the address of kernel code and
    data at every boot time, such as the static address listed in /boot/System.map
    will offset by some entropy. The purpose of KASLR is to protect the kernel space
    from the attacker. Without KASLR, the attacker may find the target address in
    the fixed address easily. Then the attacker can use return-oriented programming
    to insert some malicious codes to execute or receive the target data by a tampered
    pointer. KASLR mitigates these kinds of attacks because the attacker cannot immediately
    know the target address, but a brute-force attack can still work. If the address
    of a symbol in /proc/kallsyms is different from the address in /boot/System.map,
    KASLR is enabled with the kernel, which your system running on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If KASLR is enabled, we have to take care of the address from /proc/kallsyms
    each time we reboot the machine. In order to use the address from /boot/System.map,
    make sure that KASLR is disabled. You can add the nokaslr for disabling KASLR
    in next booting time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information, check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cook: Security things in Linux v5.3](https://lwn.net/Articles/804849/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unexporting the system call table](https://lwn.net/Articles/12211/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Control-flow integrity for the kernel](https://lwn.net/Articles/810077/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unexporting kallsyms_lookup_name()](https://lwn.net/Articles/813350/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kernel Probes (Kprobes)](https://www.kernel.org/doc/Documentation/kprobes.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kernel address space layout randomization](https://lwn.net/Articles/569635/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code here is an example of such a kernel module. We want to “spy”
    on a certain user, and to `pr_info()` a message whenever that user opens a file.
    Towards this end, we replace the system call to open a file with our own function,
    called `our_sys_openat` . This function checks the uid (user’s id) of the current
    process, and if it is equal to the uid we spy on, it calls `pr_info()` to display
    the name of the file to be opened. Then, either way, it calls the original `openat()`
    function with the same parameters, to actually open the file.
  prefs: []
  type: TYPE_NORMAL
- en: The `init_module` function replaces the appropriate location in `sys_call_table`
    and keeps the original pointer in a variable. The `cleanup_module` function uses
    that variable to restore everything back to normal. This approach is dangerous,
    because of the possibility of two kernel modules changing the same system call.
    Imagine we have two kernel modules, A and B. A’s openat system call will be `A_openat`
    and B’s will be `B_openat` . Now, when A is inserted into the kernel, the system
    call is replaced with `A_openat` , which will call the original `sys_openat` when
    it is done. Next, B is inserted into the kernel, which replaces the system call
    with `B_openat` , which will call what it thinks is the original system call,
    `A_openat` , when it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if B is removed first, everything will be well — it will simply restore
    the system call to `A_openat` , which calls the original. However, if A is removed
    and then B is removed, the system will crash. A’s removal will restore the system
    call to the original, `sys_openat` , cutting B out of the loop. Then, when B is
    removed, it will restore the system call to what it thinks is the original, `A_openat`
    , which is no longer in memory. At first glance, it appears we could solve this
    particular problem by checking if the system call is equal to our open function
    and if so not changing it at all (so that B won’t change the system call when
    it is removed), but that will cause an even worse problem. When A is removed,
    it sees that the system call was changed to `B_openat` so that it is no longer
    pointing to `A_openat` , so it will not restore it to `sys_openat` before it is
    removed from memory. Unfortunately, `B_openat` will still try to call `A_openat`
    which is no longer there, so that even without removing B the system would crash.
  prefs: []
  type: TYPE_NORMAL
- en: For x86 architecture, the system call table cannot be used to invoke a system
    call after commit [1e3ad78](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1e3ad78334a69b36e107232e337f9d693dcc9df2)
    since v6.9\. This commit has been backported to long term stable kernels, like
    v5.15.154+, v6.1.85+, v6.6.26+ and v6.8.5+, see this [answer](https://stackoverflow.com/a/78607015)
    for more details. In this case, thanks to Kprobes, a hook can be used instead
    on the system call entry to intercept the system call.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all the related problems make syscall stealing unfeasible for production
    use. In order to keep people from doing potentially harmful things `sys_call_table`
    is no longer exported. This means, if you want to do something more than a mere
    dry run of this example, you will have to patch your current kernel in order to
    have `sys_call_table` exported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 11 Blocking Processes and threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 11.1 Sleep
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What do you do when somebody asks you for something you can not do right away?
    If you are a human being and you are bothered by a human being, the only thing
    you can say is: "Not right now, I’m busy. Go away!". But if you are a kernel module
    and you are bothered by a process, you have another possibility. You can put the
    process to sleep until you can service it. After all, processes are being put
    to sleep by the kernel and woken up all the time (that is the way multiple processes
    appear to run on the same time on a single CPU).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This kernel module is an example of this. The file (called /proc/sleep) can
    only be opened by a single process at a time. If the file is already open, the
    kernel module calls `wait_event_interruptible` . The easiest way to keep a file
    open is to open it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This function changes the status of the task (a task is the kernel data structure
    which holds information about a process and the system call it is in, if any)
    to `TASK_INTERRUPTIBLE` , which means that the task will not run until it is woken
    up somehow, and adds it to WaitQ, the queue of tasks waiting to access the file.
    Then, the function calls the scheduler to context switch to a different process,
    one which has some use for the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: When a process is done with the file, it closes it, and `module_close` is called.
    That function wakes up all the processes in the queue (there’s no mechanism to
    only wake up one of them). It then returns and the process which just closed the
    file can continue to run. In time, the scheduler decides that that process has
    had enough and gives control of the CPU to another process. Eventually, one of
    the processes which was in the queue will be given control of the CPU by the scheduler.
    It starts at the point right after the call to `wait_event_interruptible` .
  prefs: []
  type: TYPE_NORMAL
- en: This means that the process is still in kernel mode - as far as the process
    is concerned, it issued the open system call and the system call has not returned
    yet. The process does not know somebody else used the CPU for most of the time
    between the moment it issued the call and the moment it returned.
  prefs: []
  type: TYPE_NORMAL
- en: It can then proceed to set a global variable to tell all the other processes
    that the file is still open and go on with its life. When the other processes
    get a piece of the CPU, they’ll see that global variable and go back to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: So we will use `tail -f` to keep the file open in the background, and attempt
    to access it with another background process. This way, we don’t need to switch
    to another terminal window or virtual terminal to run the second process. As soon
    as the first background process is killed with kill %1 , the second is woken up,
    is able to access the file and finally terminates.
  prefs: []
  type: TYPE_NORMAL
- en: To make our life more interesting, `module_close` does not have a monopoly on
    waking up the processes which wait to access the file. A signal, such as Ctrl
    +c (SIGINT) can also wake up a process. This is because we used `wait_event_interruptible`
    . We could have used `wait_event` instead, but that would have resulted in extremely
    angry users whose Ctrl+c’s are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we want to return with `-EINTR` immediately. This is important
    so users can, for example, kill the process before it receives the file.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more point to remember. Some times processes don’t want to sleep,
    they want either to get what they want immediately, or to be told it cannot be
    done. Such processes use the `O_NONBLOCK` flag when opening the file. The kernel
    is supposed to respond by returning with the error code `-EAGAIN` from operations
    which would otherwise block, such as opening the file in this example. The program
    `cat_nonblock` , available in the examples/other directory, can be used to open
    a file with `O_NONBLOCK` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 11.2 Completions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes one thing should happen before another within a module having multiple
    threads. Rather than using `/bin/sleep` commands, the kernel has another way to
    do this which allows timeouts or interrupts to also happen.
  prefs: []
  type: TYPE_NORMAL
- en: Completions as code synchronization mechanism have three main parts, initialization
    of struct completion synchronization object, the waiting or barrier part through
    `wait_for_completion()` , and the signalling side through a call to `complete()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the subsequent example, two threads are initiated: crank and flywheel. It
    is imperative that the crank thread starts before the flywheel thread. A completion
    state is established for each of these threads, with a distinct completion defined
    for both the crank and flywheel threads. At the exit point of each thread the
    respective completion state is updated, and `wait_for_completion` is used by the
    flywheel thread to ensure that it does not begin prematurely. The crank thread
    uses the `complete_all()` function to update the completion, which lets the flywheel
    thread continue.'
  prefs: []
  type: TYPE_NORMAL
- en: So even though `flywheel_thread` is started first you should notice when you
    load this module and run `dmesg` , that turning the crank always happens first
    because the flywheel thread waits for the crank thread to complete.
  prefs: []
  type: TYPE_NORMAL
- en: There are other variations of the `wait_for_completion` function, which include
    timeouts or being interrupted, but this basic mechanism is enough for many common
    situations without adding a lot of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 12 Synchronization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If processes running on different CPUs or in different threads try to access
    the same memory, then it is possible that strange things can happen or your system
    can lock up. To avoid this, various types of mutual exclusion kernel functions
    are available. These indicate if a section of code is "locked" or "unlocked" so
    that simultaneous attempts to run it can not happen.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Mutex
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use kernel mutexes (mutual exclusions) in much the same manner that
    you might deploy them in userland. This may be all that is needed to avoid collisions
    in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutexes in the Linux kernel enforce strict ownership: only the task that successfully
    acquired the mutex can release (or unlock) it. Attempting to release a mutex held
    by another task or releasing an unheld mutex multiple times by the same task typically
    leads to errors or undefined behavior. If a task tries to lock a mutex it already
    holds, it may be blocked or sleep, where the task waits for itself to release
    the lock.'
  prefs: []
  type: TYPE_NORMAL
- en: Before use, a mutex must be initialized through specific APIs (such as `mutex_init`
    or by using the `DEFINE_MUTEX` macro for compile-time initialization). And it
    is prohibited to directly modify the internal structure of a mutex using a memory
    manipulation function like `memset` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The various suffixes appended to mutex functions in the Linux kernel primarily
    dictate how a task waiting to acquire a lock will behave, particularly concerning
    its interruptibility.
  prefs: []
  type: TYPE_NORMAL
- en: When a task calls `mutex_lock()` , and if the mutex is currently unavailable,
    the task enters a sleep state until it can successfully obtain the lock. During
    this period, the task cannot be interrupted. In contrast, functions with the `_interruptible`
    suffix, such as `mutex_lock_interruptible()` , behave similarly to `mutex_lock()`
    but allow the waiting process to be interrupted by signals. If a task receives
    a signal (like a termination signal) while waiting for the lock, it will exit
    the waiting state and return an error code ( `-EINTR` ). This is useful for applications
    that need to handle external events even while waiting for a lock.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond these fundamental locking behaviors, other mutex functions offer specialized
    capabilities. Functions like `mutex_lock_nested` and `mutex_lock_interruptible_nested()`
    incorporate the `__nested()` functionality, providing support for nested locking.
    This prior locking mechanism aids in managing lock acquisition and preventing
    deadlocks, often employing a subclass parameter for more precise deadlock detection.
    The latter variant combines nested locking with the ability for the waiting process
    to be interrupted by signals. Another function is `mutex_trylock()` , which attempts
    to acquire the mutex without blocking. It returns 1 if the lock is successfully
    acquired and 0 if the mutex is already held by another task.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that `mutex_trylock` does not sleep, it is still generally
    not safe for use in interrupt context because its implementation isn’t atomic.
    If an interrupt occurs between checking the lock’s availability and its acquisition,
    this can lead to race conditions and potential data corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Spinlocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the name suggests, spinlocks lock up the CPU that the code is running on,
    taking 100% of its resources. Because of this you should only use the spinlock
    mechanism around code which is likely to take no more than a few milliseconds
    to run and so will not noticeably slow anything down from the user’s point of
    view.
  prefs: []
  type: TYPE_NORMAL
- en: The example here is "irq safe" in that if interrupts happen during the lock
    then they will not be forgotten and will activate when the unlock happens, using
    the `flags` variable to retain their state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Taking 100% of a CPU’s resources comes with greater responsibility. Situations
    where the kernel code monopolizes a CPU are called atomic contexts. Holding a
    spinlock is one of those situations. Sleeping in atomic contexts may leave the
    system hanging, as the occupied CPU devotes 100% of its resources doing nothing
    but sleeping. In some worse cases the system may crash. Thus, sleeping in atomic
    contexts is considered a bug in the kernel. They are sometimes called “sleep-in-atomic-context”
    in some materials.
  prefs: []
  type: TYPE_NORMAL
- en: Note that sleeping here is not limited to calling the sleep functions explicitly.
    If subsequent function calls eventually invoke a function that sleeps, it is also
    considered sleeping. Thus, it is important to pay attention to functions being
    used in atomic context. There’s no documentation recording all such functions,
    but code comments may help. Sometimes you may find comments in kernel source code
    stating that a function “may sleep”, “might sleep”, or more explicitly “the caller
    should not hold a spinlock”. Those comments are hints that a function may implicitly
    sleep and must not be called in atomic contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s differentiate between a few types of spinlock functions in the Linux
    kernel: `spin_lock()` , `spin_lock_irq()` , `spin_lock_irqsave()` , and `spin_lock_bh()`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '`spin_lock()` does not allow the CPU to sleep while waiting for the lock, which
    makes it suitable for most use cases where the critical section is short. However,
    this is problematic for real-time Linux because spinlocks in this configuration
    behave as sleeping locks. This can prevent other tasks from running and cause
    the system to become unresponsive. To address this in real-time Linux environments,
    a `raw_spin_lock()` is used, which behaves similarly to a `spin_lock()` but without
    causing the system to sleep.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `spin_lock_irq()` disables interrupts while holding the lock,
    but it does not save the interrupt state. This means that if an interrupt occurs
    while the lock is held, the interrupt state could be lost. In contrast, `spin_lock_irqsave()`
    disables interrupts and also saves the interrupt state, ensuring that interrupts
    are restored to their previous state when the lock is released. This makes `spin_lock_irqsave()`
    a safer option in scenarios where preserving the interrupt state is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `spin_lock_bh()` disables softirqs (software interrupts) but allows hardware
    interrupts to continue. Unlike `spin_lock_irq()` and `spin_lock_irqsave()` , which
    disable both hardware and software interrupts, `spin_lock_bh()` is useful when
    hardware interrupts need to remain active.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about spinlock usage and lock types, see the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lesson 1: Spin locks](https://www.kernel.org/doc/Documentation/locking/spinlocks.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lock types and their rules](https://docs.kernel.org/locking/locktypes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.3 Read and write locks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read and write locks are specialised kinds of spinlocks so that you can exclusively
    read from something or write to something. Like the earlier spinlocks example,
    the one below shows an "irq safe" situation in which if other functions were triggered
    from irqs which might also read and write to whatever you are concerned with then
    they would not disrupt the logic. As before it is a good idea to keep anything
    done within the lock as short as possible so that it does not hang up the system
    and cause users to start revolting against the tyranny of your module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you know for sure that there are no functions triggered by irqs
    which could possibly interfere with your logic then you can use the simpler `read_lock(&myrwlock)`
    and `read_unlock(&myrwlock)` or the corresponding write functions.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Atomic operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are doing simple arithmetic: adding, subtracting or bitwise operations,
    then there is another way in the multi-CPU and multi-hyperthreaded world to stop
    other parts of the system from messing with your mojo. By using atomic operations
    you can be confident that your addition, subtraction or bit flip did actually
    happen and was not overwritten by some other shenanigans. An example is shown
    below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the C11 standard adopted the built-in atomic types, the kernel already
    provided a small set of atomic types by using a bunch of tricky architecture-specific
    codes. Implementing the atomic types by C11 atomics may allow the kernel to throw
    away the architecture-specific codes and make the kernel code be more friendly
    to the people who understand the standard. But there are some problems, such as
    the memory model of the kernel doesn’t match the model formed by the C11 atomics.
    For further details, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[kernel documentation of atomic types](https://www.kernel.org/doc/Documentation/atomic_t.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Time to move to C11 atomics?](https://lwn.net/Articles/691128/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Atomic usage patterns in the kernel](https://lwn.net/Articles/698315/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13 Replacing Print Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 13.1 Replacement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Section 1.7](#before-we-begin), it was noted that the X Window System and
    kernel module programming are not conducive to integration. This remains valid
    during the development of kernel modules. However, in practical scenarios, the
    necessity emerges to relay messages to the tty (teletype) originating the module
    load command.
  prefs: []
  type: TYPE_NORMAL
- en: The term “tty” originates from teletype, which initially referred to a combined
    keyboard-printer for Unix system communication. Today, it signifies a text stream
    abstraction employed by Unix programs, encompassing physical terminals, xterms
    in X displays, and network connections like SSH.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the “current” pointer is leveraged to access the active task’s
    tty structure. Within this structure lies a pointer to a string write function,
    facilitating the string’s transmission to the tty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 13.2 Flashing keyboard LEDs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In certain conditions, you may desire a simpler and more direct way to communicate
    to the external world. Flashing keyboard LEDs can be such a solution: It is an
    immediate way to attract attention or to display a status condition. Keyboard
    LEDs are present on every hardware, they are always visible, they do not need
    any setup, and their use is rather simple and non-intrusive, compared to writing
    to a tty or a file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From v4.14 to v4.15, the timer API made a series of changes to improve memory
    safety. A buffer overflow in the area of a `timer_list` structure may be able
    to overwrite the `function` and `data` fields, providing the attacker with a way
    to use return-oriented programming (ROP) to call arbitrary functions within the
    kernel. Also, the function prototype of the callback, containing an `unsigned long`
    argument, will prevent the compiler from performing type checking. Furthermore,
    the function prototype with `unsigned long` argument may be an obstacle to the
    forward-edge protection of control-flow integrity. Thus, it is better to use a
    unique prototype to separate from the cluster that takes an `unsigned long` argument.
    The timer callback should be passed a pointer to the `timer_list` structure rather
    than an `unsigned long` argument. Then, it wraps all the information the callback
    needs, including the `timer_list` structure, into a larger structure, and it can
    use the `container_of` macro instead of the `unsigned long` value. For more information,
    see: [Improving the kernel timers API](https://lwn.net/Articles/735887/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Linux v4.14, `setup_timer` was used to initialize the timer and the
    `timer_list` structure looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Since Linux v4.14, `timer_setup` is adopted and the kernel step by step converting
    to `timer_setup` from `setup_timer` . One of the reasons why the API was changed
    is that it needed to coexist with the old version of the interface. Moreover,
    the `timer_setup` was implemented by `setup_timer` at first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `setup_timer` was then removed since v4.15\. As a result, the `timer_list`
    structure had changed to the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The following source code illustrates a minimal kernel module which, when loaded,
    starts blinking the keyboard LEDs until it is unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: If none of the examples in this chapter fit your debugging needs, there might
    yet be some other tricks to try. Ever wondered what `CONFIG_LL_DEBUG` in `make menuconfig`
    is good for? If you activate that you get low level access to the serial port.
    While this might not sound very powerful by itself, you can patch [kernel/printk.c](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/printk.c)
    or any other essential syscall to print ASCII characters, thus making it possible
    to trace virtually everything what your code does over a serial line. If you find
    yourself porting the kernel to some new and former unsupported architecture, this
    is usually amongst the first things that should be implemented. Logging over a
    netconsole might also be worth a try.
  prefs: []
  type: TYPE_NORMAL
- en: While you have seen lots of stuff that can be used to aid debugging here, there
    are some things to be aware of. Debugging is almost always intrusive. Adding debug
    code can change the situation enough to make the bug seem to disappear. Thus,
    you should keep debug code to a minimum and make sure it does not show up in production
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 14 GPIO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 14.1 GPIO
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'General Purpose Input/Output (GPIO) appears on the development board as pins.
    It acts as a bridge for communication between the development board and external
    devices. You can think of it like a switch: users can turn it on or off (Input),
    and the development board can also turn it on or off (Output).'
  prefs: []
  type: TYPE_NORMAL
- en: To implement a GPIO device driver, you use the `gpio_request()` function to
    enable a specific GPIO pin. After successfully enabling it, you can check that
    the pin is being used by looking at /sys/kernel/debug/gpio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways to register GPIOs. For example, you can use `gpio_request_one()`
    to register a GPIO while setting its direction (input or output) and initial state
    at the same time. You can also use `gpio_request_array()` to register multiple
    GPIOs at once. However, note that `gpio_request_array()` has been removed since
    Linux v6.10.
  prefs: []
  type: TYPE_NORMAL
- en: When using GPIO, you must set it as either output with `gpio_direction_output()`
    or input with `gpio_direction_input()` .
  prefs: []
  type: TYPE_NORMAL
- en: when the GPIO is set as output, you can use `gpio_set_value()` to choose to
    set it to high voltage or low voltage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when the GPIO is set as input, you can use `gpio_get_value()` to read whether
    the voltage is high or low.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.2 Control the LED’s on/off state
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Section 9](#talking-to-device-files), we learned how to communicate with
    device files. Therefore, we will further use device files to control the LED on
    and off.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation, a pull-down resistor is used. The anode of the LED is
    connected to GPIO4, and the cathode is connected to GND. For more details about
    the Raspberry Pi pin assignments, refer to [Raspberry Pi Pinout](https://pinout.xyz/).
    The materials used include a Raspberry Pi 5, an LED, jumper wires, and a 220Ω
    resistor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Make and install the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch on the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch off the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remove the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 14.3 DHT11 sensor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The DHT11 sensor is a well-known entry-level sensor commonly used to measure
    humidity and temperature. In this subsection, we will use GPIO to communicate
    through a single data line. The DHT11 communication protocol can be referred to
    in the [datasheet](https://www.mouser.com/datasheet/2/758/DHT11-Technical-Data-Sheet-Translated-Version-1143054.pdf?srsltid=AfmBOoppls-QTd864640bVtbK90sWBsFzJ_7SgjOD2EpwuLLGUSTyYnv).
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation, the data pin of the DHT11 sensor is connected to GPIO4
    on the Raspberry Pi. The sensor’s VCC and GND pins are connected to 3.3V and GND,
    respectively. For more details about the Raspberry Pi pin assignments, refer to
    [Raspberry Pi Pinout](https://pinout.xyz/). The materials used include a Raspberry
    Pi 5, a DHT11 sensor, and jumper wires.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Make and install the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the Output of the DHT11 Sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Expected Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remove the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 15 Scheduling Tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main ways of running tasks: tasklets and work queues. Tasklets
    are a quick and easy way of scheduling a single function to be run. For example,
    when triggered from an interrupt, whereas work queues are more complicated but
    also better suited to running multiple things in a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that in future tasklets may be replaced by threaded IRQs. However,
    discussion about that has been ongoing since 2007 ([Eliminating tasklets](https://lwn.net/Articles/239633)
    and [The end of tasklets](https://lwn.net/Articles/960041/)), so expecting immediate
    changes would be unwise. See the [Section 16.1](#interrupt-handlers1) for alternatives
    that avoid the tasklet debate.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Tasklets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here is an example tasklet module. The `tasklet_fn` function runs for a few
    seconds. In the meantime, execution of the `example_tasklet_init` function may
    continue to the exit point, depending on whether it is interrupted by softirq.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'So with this example loaded `dmesg` should show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Although tasklet is easy to use, it comes with several drawbacks, and developers
    have been discussing their removal from the Linux kernel. The tasklet callback
    runs in atomic context, inside a software interrupt, meaning that it cannot sleep
    or access user-space data, so not all work can be done in a tasklet handler. Also,
    the kernel only allows one instance of any given tasklet to be running at any
    given time; multiple different tasklet callbacks can run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In recent kernels, tasklets can be replaced by workqueues, timers, or threaded
    interrupts. [²](#fn2x0) While the removal of tasklets remains a longer-term goal,
    the current kernel contains more than a hundred uses of tasklets. Now developers
    are proceeding with the API changes and the macro `DECLARE_TASKLET_OLD` exists
    for compatibility. For further information, see [https://lwn.net/Articles/830964/](https://lwn.net/Articles/830964/).
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 Work queues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To add a task to the scheduler we can use a workqueue. The kernel then uses
    the Completely Fair Scheduler (CFS) to execute work within the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 16 Interrupt Handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16.1 Interrupt Handlers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Except for the last chapter, everything we did in the kernel so far we have
    done as a response to a process asking for it, either by dealing with a special
    file, sending an `ioctl()` , or issuing a system call. But the job of the kernel
    is not just to respond to process requests. Another job, which is every bit as
    important, is to speak to the hardware connected to the machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of interaction between the CPU and the rest of the computer’s
    hardware. The first type is when the CPU gives orders to the hardware, the other
    is when the hardware needs to tell the CPU something. The second, called interrupts,
    is much harder to implement because it has to be dealt with when convenient for
    the hardware, not the CPU. Hardware devices typically have a very small amount
    of RAM, and if you do not read their information when available, it is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Under Linux, hardware interrupts are called IRQs (Interrupt ReQuests). There
    are two types of IRQs, short and long. A short IRQ is one which is expected to
    take a very short period of time, during which the rest of the machine will be
    blocked and no other interrupts will be handled. A long IRQ is one which can take
    longer, and during which other interrupts may occur (but not interrupts from the
    same device). If at all possible, it is better to declare an interrupt handler
    to be long.
  prefs: []
  type: TYPE_NORMAL
- en: When the CPU receives an interrupt, it stops whatever it is doing (unless it
    is processing a more important interrupt, in which case it will deal with this
    one only when the more important one is done), saves certain parameters on the
    stack and calls the interrupt handler. This means that certain things are not
    allowed in the interrupt handler itself, because the system is in an unknown state.
    Linux kernel solves the problem by splitting interrupt handling into two parts.
    The first part executes right away and masks the interrupt line. Hardware interrupts
    must be handled quickly, and that is why we need the second part to handle the
    heavy work deferred from an interrupt handler. Historically, BH (Linux naming
    for Bottom Halves) statistically book-keeps the deferred functions. Softirq and
    its higher level abstraction, Tasklet, replace BH since Linux 2.3.
  prefs: []
  type: TYPE_NORMAL
- en: The way to implement this is to call `request_irq()` to get your interrupt handler
    called when the relevant IRQ is received.
  prefs: []
  type: TYPE_NORMAL
- en: In practice IRQ handling can be a bit more complex. Hardware is often designed
    in a way that chains two interrupt controllers, so that all the IRQs from interrupt
    controller B are cascaded to a certain IRQ from interrupt controller A. Of course,
    that requires that the kernel finds out which IRQ it really was afterwards and
    that adds overhead. Other architectures offer some special, very low overhead,
    so called "fast IRQ" or FIQs. To take advantage of them requires handlers to be
    written in assembly language, so they do not really fit into the kernel. They
    can be made to work similar to the others, but after that procedure, they are
    no longer any faster than "common" IRQs. SMP enabled kernels running on systems
    with more than one processor need to solve another truckload of problems. It is
    not enough to know if a certain IRQs has happened, it’s also important to know
    what CPU(s) it was for. People still interested in more details, might want to
    refer to "APIC" now.
  prefs: []
  type: TYPE_NORMAL
- en: This function receives the IRQ number, the name of the function, flags, a name
    for /proc/interrupts and a parameter to be passed to the interrupt handler. Usually
    there is a certain number of IRQs available. How many IRQs there are is hardware-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: The flags can be used to specify behaviors of the IRQ. For example, use `IRQF_SHARED`
    to indicate you are willing to share the IRQ with other interrupt handlers (usually
    because a number of hardware devices sit on the same IRQ); use the `IRQF_ONESHOT`
    to indicate that the IRQ is not reenabled after the handler finished. It should
    be noted that in some materials, you may encounter another set of IRQ flags named
    with the `SA` prefix. For example, the `SA_SHIRQ` and the `SA_INTERRUPT` . Those
    are the IRQ flags in the older kernels. They have been removed completely. Today
    only the `IRQF` flags are in use. This function will only succeed if there is
    not already a handler on this IRQ, or if you are both willing to share.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Detecting button presses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many popular single board computers, such as Raspberry Pi or Beagleboards, have
    a bunch of GPIO pins. Attaching buttons to those and then having a button press
    do something is a classic case in which you might need to use interrupts, so that
    instead of having the CPU waste time and battery power polling for a change in
    input state, it is better for the input to trigger the CPU to then run a particular
    handling function.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example where buttons are connected to GPIO numbers 17 and 18 and
    an LED is connected to GPIO 4\. You can change those numbers to whatever is appropriate
    for your board.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 16.3 Bottom Half
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose you want to do a bunch of stuff inside of an interrupt routine. A common
    way to avoid blocking the interrupt for a significant duration is to defer the
    time-consuming part to a workqueue. This pushes the bulk of the work off into
    the scheduler. This approach helps speed up the interrupt handling process itself,
    allowing the system to respond to the next hardware interrupt more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel developers generally discourage using tasklets due to their design limitations,
    such as memory management issues and unpredictable latencies. Instead, they recommend
    more robust mechanisms like workqueues or softirqs. To address tasklet shortcomings,
    Linux contributors introduced the BH workqueue, activated with the `WQ_BH` flag.
    This workqueue retains critical features, such as execution in atomic (softirq)
    context on the same CPU and the inability to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: The example below extends the previous code to include an additional task executed
    in process context when an interrupt is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 16.4 Threaded IRQ
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Threaded IRQ is a mechanism to organize both top-half and bottom-half of an
    IRQ at once. A threaded IRQ splits the one handler in `request_irq()` into two:
    one for the top-half, the other for the bottom-half. The `request_threaded_irq()`
    is the function for using threaded IRQs. Two handlers are registered at once in
    the `request_threaded_irq()` .'
  prefs: []
  type: TYPE_NORMAL
- en: Those two handlers run in different context. The top-half handler runs in interrupt
    context. It’s the equivalence of the handler passed to the `request_irq()` . The
    bottom-half handler on the other hand runs in its own thread. This thread is created
    on registration of a threaded IRQ. Its sole purpose is to run this bottom-half
    handler. This is where a threaded IRQ is “threaded”. If `IRQ_WAKE_THREAD` is returned
    by the top-half handler, that bottom-half serving thread will wake up. The thread
    then runs the bottom-half handler.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of how to do the same thing as before, with top and bottom
    halves, but using threads.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: A threaded IRQ is registered using `request_threaded_irq()` . This function
    only takes one additional parameter than the `request_irq()` – the bottom-half
    handling function that runs in its own thread. In this example it is the `button_bottom_half()`
    . Usage of other parameters are the same as `request_irq()` .
  prefs: []
  type: TYPE_NORMAL
- en: Presence of both handlers is not mandatory. If either of them is not needed,
    pass the `NULL` instead. A `NULL` top-half handler implies that no action is taken
    except to wake up the bottom-half serving thread, which runs the bottom-half handler.
    Similarly, a `NULL` bottom-half handler effectively acts as if `request_irq()`
    were used. In fact, this is how `request_irq()` is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Note that passing `NULL` to both handlers is considered an error and will make
    registration fail.
  prefs: []
  type: TYPE_NORMAL
- en: 17 Virtual Input Device Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input device driver is a module that provides a way to communicate with
    the interaction device via the event. For example, the keyboard can send the press
    or release event to tell the kernel what we want to do. The input device driver
    will allocate a new input structure with `input_allocate_device()` and sets up
    input bitfields, device id, version, etc. After that, registers it by calling
    `input_register_device()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, vinput, It is an API to allow easy development of virtual
    input drivers. The driver needs to export a `vinput_device()` that contains the
    virtual device name and `vinput_ops` structure that describes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the init function: `init()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the input event injection function: `send()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the readback function: `read()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then using `vinput_register_device()` and `vinput_unregister_device()` will
    add a new device to the list of support virtual input devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This function is passed a `struct vinput` already initialized with an allocated
    `struct input_dev` . The `init()` function is responsible for initializing the
    capabilities of the input device and register it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This function will receive a user string to interpret and inject the event using
    the `input_report_XXXX` or `input_event` call. The string is already copied from
    user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This function is used for debugging and should fill the buffer parameter with
    the last event sent in the virtual input device format. The buffer will then be
    copied to user.
  prefs: []
  type: TYPE_NORMAL
- en: vinput devices are created and destroyed using sysfs. And, event injection is
    done through a /dev node. The device name will be used by the userland to export
    a new virtual input device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `class_attribute` structure is similar to other attribute types we talked
    about in [Section 8](#sysfs-interacting-with-your-module):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In vinput.c, the macro `CLASS_ATTR_WO(export/unexport)` defined in [include/linux/device.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h)
    (in this case, device.h is included in [include/linux/input.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/input.h))
    will generate the `class_attribute` structures which are named class_attr_export/unexport.
    Then, put them into `vinput_class_attrs` array and the macro `ATTRIBUTE_GROUPS(vinput_class)`
    will generate the `struct attribute_group vinput_class_group` that should be assigned
    in `vinput_class` . Finally, call `class_register(&vinput_class)` to create attributes
    in sysfs.
  prefs: []
  type: TYPE_NORMAL
- en: To create a vinputX sysfs entry and /dev node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To unexport the device, just echo its id in unexport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Here the virtual keyboard is one of example to use vinput. It supports all `KEY_MAX`
    keycodes. The injection format is the `KEY_CODE` such as defined in [include/linux/input.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/input.h).
    A positive value means `KEY_PRESS` while a negative value is a `KEY_RELEASE` .
    The keyboard supports repetition when the key stays pressed for too long. The
    following demonstrates how simulation work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simulate a key press on "g" ( `KEY_G` = 34):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Simulate a key release on "g" ( `KEY_G` = 34):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '18 Standardizing the interfaces: The Device Model'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point we have seen all kinds of modules doing all kinds of things,
    but there was no consistency in their interfaces with the rest of the kernel.
    To impose some consistency such that there is at minimum a standardized way to
    start, suspend and resume a device model was added. An example is shown below,
    and you can use this as a template to add your own suspend, resume or other interface
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 19 Device Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 19.1 Introduction to Device Tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Device Tree is a data structure that describes hardware components in a system,
    particularly in embedded systems and ARM-based platforms. Instead of hard-coding
    hardware details in the kernel source, Device Tree provides a separate, human-readable
    description that the kernel can parse at boot time. This separation allows the
    same kernel binary to support multiple hardware platforms, making development
    and maintenance significantly easier.
  prefs: []
  type: TYPE_NORMAL
- en: Device Tree files (with .dts extension for source files and .dtb for compiled
    binary files) use a hierarchical structure similar to a filesystem to represent
    the hardware topology. Each hardware component is represented as a node with properties
    that describe its characteristics, such as memory addresses, interrupt numbers,
    and device-specific parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 19.2 Device Tree and Kernel Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While Device Tree is primarily used during kernel initialization, kernel modules
    can also interact with Device Tree nodes through the platform device framework.
    When the kernel parses the Device Tree at boot, it creates platform devices for
    nodes that have compatible strings. Kernel modules can then register platform
    drivers that match these compatible strings, allowing them to be automatically
    probed when the corresponding hardware is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key concepts for Device Tree interaction in kernel modules include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compatible strings: Unique identifiers that match Device Tree nodes to their
    drivers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Property reading: Functions to extract configuration data from Device Tree
    nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Platform driver framework: Infrastructure for binding drivers to devices described
    in Device Tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Device-specific data: Custom properties that can be defined for specific hardware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '19.3 Example: Device Tree Module'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following example demonstrates how a kernel module can interact with Device
    Tree nodes. This module registers a platform driver that matches specific compatible
    strings and extracts properties from the matched Device Tree nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 19.4 Device Tree Source Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use the above module, you would need a Device Tree entry like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The properties in this Device Tree node would be read by the module’s probe
    function when the device is matched. The compatible property is used to match
    the device with the driver, while other properties provide device-specific configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 19.5 Testing Device Tree Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Testing Device Tree modules can be done in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Device Tree overlays: On systems that support it (like Raspberry Pi),
    you can load Device Tree overlays at runtime to add new devices without rebooting.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modifying the main Device Tree: Add your device nodes to the system’s main
    Device Tree source file and recompile it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using QEMU: For development and testing, QEMU can emulate systems with custom
    Device Trees, allowing you to test your modules without physical hardware.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To check if your device was properly detected, you can examine the sysfs filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 19.6 Common Device Tree Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some commonly used Device Tree functions in kernel modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`of_property_read_string()` - Read a string property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_property_read_u32()` - Read a 32-bit integer property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_property_read_bool()` - Check if a boolean property exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_find_property()` - Find a property by name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_get_property()` - Get a property’s raw value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_match_device()` - Match a device against a match table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_parse_phandle()` - Parse a phandle reference to another node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions provide a robust interface for extracting configuration data
    from Device Tree nodes, allowing modules to be highly configurable without code
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 20 Optimizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 20.1 Likely and Unlikely conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you might want your code to run as quickly as possible, especially
    if it is handling an interrupt or doing something which might cause noticeable
    latency. If your code contains boolean conditions and if you know that the conditions
    are almost always likely to evaluate as either `true` or `false` , then you can
    allow the compiler to optimize for this using the `likely` and `unlikely` macros.
    For example, when allocating memory you are almost always expecting this to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: When the `unlikely` macro is used, the compiler alters its machine instruction
    output, so that it continues along the false branch and only jumps if the condition
    is true. That avoids flushing the processor pipeline. The opposite happens if
    you use the `likely` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 20.2 Static keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Static keys allow us to enable or disable kernel code paths based on the runtime
    state of a key. Their APIs have been available since 2010 (most architectures
    are already supported) and use self-modifying code to eliminate the overhead of
    cache and branch prediction. The most typical use case of static keys is for performance-sensitive
    kernel code, such as tracepoints, context switching, networking, etc. These hot
    paths of the kernel often contain branches and can be optimized easily using this
    technique. Before we can use static keys in the kernel, we need to make sure that
    gcc supports `asm goto` inline assembly, and the following kernel configurations
    are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare a static key, we need to define a global variable using the `DEFINE_STATIC_KEY_FALSE`
    or `DEFINE_STATIC_KEY_TRUE` macro defined in [include/linux/jump_label.h](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/jump_label.h).
    This macro initializes the key with the given initial value, which is either false
    or true, respectively. For example, to declare a static key with an initial value
    of false, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Once the static key has been declared, we need to add branching code to the
    module that uses the static key. For example, the code includes a fastpath, where
    a no-op instruction will be generated at compile time as the key is initialized
    to false and the branch is unlikely to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: If the key is enabled at runtime by calling `static_branch_enable(&fkey)` ,
    the fastpath will be patched with an unconditional jump instruction to the slowpath
    code `pr_alert` , so the branch will always be taken until the key is disabled
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The following kernel module derived from chardev.c, demonstrates how the static
    key works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: To check the state of the static key, we can use the /dev/key_state interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: This will display the current state of the key, which is disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the state of the static key, we can perform a write operation on
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This will enable the static key, causing the code path to switch from the fastpath
    to the slowpath.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the key is enabled or disabled at initialization and never changed,
    we can declare a static key as read-only, which means that it can only be toggled
    in the module init function. To declare a read-only static key, we can use the
    `DEFINE_STATIC_KEY_FALSE_RO` or `DEFINE_STATIC_KEY_TRUE_RO` macro instead. Attempts
    to change the key at runtime will result in a page fault. For more information,
    see [Static keys](https://www.kernel.org/doc/Documentation/static-keys.txt)
  prefs: []
  type: TYPE_NORMAL
- en: 21 Common Pitfalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 21.1 Using standard libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can not do that. In a kernel module, you can only use kernel functions which
    are the functions you can see in /proc/kallsyms.
  prefs: []
  type: TYPE_NORMAL
- en: 21.2 Disabling interrupts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might need to do this for a short time and that is OK, but if you do not
    enable them afterwards, your system will be stuck and you will have to power it
    off.
  prefs: []
  type: TYPE_NORMAL
- en: 22 Where To Go From Here?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those deeply interested in kernel programming, [kernelnewbies.org](https://kernelnewbies.org)
    and the [Documentation](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation)
    subdirectory within the kernel source code are highly recommended. Although the
    latter may not always be straightforward, it serves as a valuable initial step
    for further exploration. Echoing Linus Torvalds’ perspective, the most effective
    method to understand the kernel is through personal examination of the source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Contributions to this guide are welcome, especially if there are any significant
    inaccuracies identified. To contribute or report an issue, please initiate an
    issue at [https://github.com/sysprog21/lkmpg](https://github.com/sysprog21/lkmpg).
    Pull requests are greatly appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: Happy hacking!
  prefs: []
  type: TYPE_NORMAL
- en: '[¹](#fn1x0-bk)As of Linux kernel 6.12, several member fields have been added,
    removed, or had their prototypes changed. For example, additions include fop_flags,
    splice_eof, and uring_cmd; removals include iterate and sendpage; and the prototype
    for iopoll was modified.'
  prefs: []
  type: TYPE_NORMAL
- en: '[²](#fn2x0-bk)The goal of threaded interrupts is to push more of the work to
    separate threads, so that the minimum needed for acknowledging an interrupt is
    reduced, and therefore the time spent handling the interrupt (where it can’t handle
    any other interrupts at the same time) is reduced. See [https://lwn.net/Articles/302043/](https://lwn.net/Articles/302043/).'
  prefs: []
  type: TYPE_NORMAL
