["```sh\ncurl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_callback);\n```", "```sh\nsize_t write_callback(char *ptr, size_t size, size_t nmemb,\n                      void *userdata);\n```", "```sh\ncurl_easy_setopt(handle, CURLOPT_WRITEDATA, custom_pointer);\n```", "```sh\nstruct response {\n  char *memory;\n  size_t size;\n};\n\nstatic size_t\nmem_cb(void *contents, size_t size, size_t nmemb, void *userp)\n{\n  size_t realsize = size * nmemb;\n  struct response *mem = (struct response *)userp;\n\n  char *ptr = realloc(mem->memory, mem->size + realsize + 1);\n  if(!ptr) {\n    /* out of memory! */\n    printf(\"not enough memory (realloc returned NULL)\\n\");\n    return 0;\n  }\n\n  mem->memory = ptr;\n  memcpy(&(mem->memory[mem->size]), contents, realsize);\n  mem->size += realsize;\n  mem->memory[mem->size] = 0;\n\n  return realsize;\n}\n\nint main()\n{\n  struct response chunk = {.memory = malloc(0),\n                           .size = 0};\n\n  /* send all data to this function  */\n  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, mem_cb);\n\n  /* we pass our 'chunk' to the callback function */\n  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n\n  free(chunk.memory);\n}\n```"]