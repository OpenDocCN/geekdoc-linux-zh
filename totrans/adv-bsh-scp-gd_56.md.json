["```sh #!/usr/bin/env bash\n#-----------------------------------------------------------\n# Management of PATH, LD_LIBRARY_PATH, MANPATH variables...\n# By Emmanuel Rouat <no-email>\n# (Inspired by the bash documentation 'pathfuncs' and on\n# discussions found on stackoverflow:\n# http://stackoverflow.com/questions/370047/\n# http://stackoverflow.com/questions/273909/#346860 )\n# Last modified: Sat Sep 22 12:01:55 CEST 2012\n#\n# The following functions handle spaces correctly.\n# These functions belong in .bash_profile rather than in\n# .bashrc, I guess.\n#\n# The modular aspect of these functions should make it easy\n# to expand them to handle path substitutions instead\n# of path removal etc....\n#\n# See http://www.catonmat.net/blog/awk-one-liners-explained-part-two/\n# (item 43) for an explanation of the 'duplicate-entries' removal\n# (it's a nice trick!)\n#-----------------------------------------------------------\n\n# Show $@ (usually PATH) as list.\nfunction p_show() { local p=\"$@\" && for p; do [[ ${!p} ]] &&\necho -e ${!p//:/\\\\n}; done }\n\n# Filter out empty lines, multiple/trailing slashes, and duplicate entries.\nfunction p_filter()\n{ awk '/^[ \\t]*$/ {next} {sub(/\\/+$/, \"\");gsub(/\\/+/, \"/\")}!x[$0]++' ;}\n\n# Rebuild list of items into ':' separated word (PATH-like).\nfunction p_build() { paste -sd: ;}\n\n# Clean $1 (typically PATH) and rebuild it\nfunction p_clean()\n{ local p=${1} && eval ${p}='$(p_show ${p} &#124; p_filter &#124; p_build)' ;}\n\n# Remove $1 from $2 (found on stackoverflow, with modifications).\nfunction p_rm()\n{ local d=$(echo $1 &#124; p_filter) p=${2} &&\n  eval ${p}='$(p_show ${p} &#124; p_filter &#124; grep -xv \"${d}\" &#124; p_build)' ;}\n\n#  Same as previous, but filters on a pattern (dangerous...\n#+ don't use 'bin' or '/' as pattern!).\nfunction p_rmpat()\n{ local d=$(echo $1 &#124; p_filter) p=${2} && eval ${p}='$(p_show ${p} &#124;\n  p_filter &#124; grep -v \"${d}\" &#124; p_build)' ;}\n\n# Delete $1 from $2 and append it cleanly.\nfunction p_append()\n{ local d=$(echo $1 &#124; p_filter) p=${2} && p_rm \"${d}\" ${p} &&\n  eval ${p}='$(p_show ${p} d &#124; p_build)' ;}\n\n# Delete $1 from $2 and prepend it cleanly.\nfunction p_prepend()\n{ local d=$(echo $1 &#124; p_filter) p=${2} && p_rm \"${d}\" ${p} &&\n  eval ${p}='$(p_show d ${p} &#124; p_build)' ;}\n\n# Some tests:\necho\nMYPATH=\"/bin:/usr/bin/:/bin://bin/\"\np_append \"/project//my project/bin\" MYPATH\necho \"Append '/project//my project/bin' to '/bin:/usr/bin/:/bin://bin/'\"\necho \"(result should be: /bin:/usr/bin:/project/my project/bin)\"\necho $MYPATH\n\necho\nMYOTHERPATH=\"/bin:/usr/bin/:/bin:/project//my project/bin\"\np_prepend \"/project//my project/bin\" MYOTHERPATH\necho \"Prepend '/project//my project/bin' \\\nto '/bin:/usr/bin/:/bin:/project//my project/bin/'\"\necho \"(result should be: /project/my project/bin:/bin:/usr/bin)\"\necho $MYOTHERPATH\n\necho\np_prepend \"/project//my project/bin\" FOOPATH  # FOOPATH doesn't exist.\necho \"Prepend '/project//my project/bin' to an unset variable\"\necho \"(result should be: /project/my project/bin)\"\necho $FOOPATH\n\necho\nBARPATH=\"/a:/b/://b c://a:/my local pub\"\np_clean BARPATH\necho \"Clean BARPATH='/a:/b/://b c://a:/my local pub'\"\necho \"(result should be: /a:/b:/b c:/my local pub)\"\necho $BARPATH\n```", "```sh Doing it correctly: A quick summary\nby David Wheeler\nhttp://www.dwheeler.com/essays/filenames-in-shell.html\n\nSo, how can you process filenames correctly in shell? Here's a quick\nsummary about how to do it correctly, for the impatient who \"just want the\nanswer\". In short: Double-quote to use \"$variable\" instead of $variable,\nset IFS to just newline and tab, prefix all globs/filenames so they cannot\nbegin with \"-\" when expanded, and use one of a few templates that work\ncorrectly. Here are some of those templates that work correctly:\n\n IFS=\"$(printf '\\n\\t')\"\n # Remove SPACE, so filenames with spaces work well.\n\n #  Correct glob use:\n #+ always use \"for\" loop, prefix glob, check for existence:\n for file in ./* ; do          # Use \"./*\" ... NEVER bare \"*\" ...\n   if [ -e \"$file\" ] ; then    # Make sure it isn't an empty match.\n     COMMAND ... \"$file\" ...\n   fi\n done\n\n # Correct glob use, but requires nonstandard bash extension.\n shopt -s nullglob  #  Bash extension,\n                    #+ so that empty glob matches will work.\n for file in ./* ; do        # Use \"./*\", NEVER bare \"*\"\n   COMMAND ... \"$file\" ...\n done\n\n #  These handle all filenames correctly;\n #+ can be unwieldy if COMMAND is large:\n find ... -exec COMMAND... {} \\;\n find ... -exec COMMAND... {} \\+ # If multiple files are okay for COMMAND.\n\n #  This skips filenames with control characters\n #+ (including tab and newline).\n IFS=\"$(printf '\\n\\t')\"\n controlchars=\"$(printf '*[\\001-\\037\\177]*')\"\n for file in $(find . ! -name \"$controlchars\"') ; do\n   COMMAND \"$file\" ...\n done\n\n #  Okay if filenames can't contain tabs or newlines --\n #+ beware the assumption.\n IFS=\"$(printf '\\n\\t')\"\n for file in $(find .) ; do\n   COMMAND \"$file\" ...\n done\n\n # Requires nonstandard but common extensions in find and xargs:\n find . -print0 &#124; xargs -0 COMMAND\n\n # Requires nonstandard extensions to find and to shell (bash works).\n # variables might not stay set once the loop ends:\n find . -print0 &#124; while IFS=\"\" read -r -d \"\" file ; do ...\n   COMMAND \"$file\" # Use quoted \"$file\", not $file, everywhere.\n done\n\n #  Requires nonstandard extensions to find and to shell (bash works).\n #  Underlying system must include named pipes (FIFOs)\n #+ or the /dev/fd mechanism.\n #  In this version, variables *do* stay set after the loop ends,\n #  and you can read from stdin.\n #+ (Change the 4 to another number if fd 4 is needed.)\n\n while IFS=\"\" read -r -d \"\" file <&4 ; do\n   COMMAND \"$file\"   # Use quoted \"$file\" -- not $file, everywhere.\n done 4< <(find . -print0)\n\n #  Named pipe version.\n #  Requires nonstandard extensions to find and to shell's read (bash ok).\n #  Underlying system must include named pipes (FIFOs).\n #  Again, in this version, variables *do* stay set after the loop ends,\n #  and you can read from stdin.\n # (Change the 4 to something else if fd 4 needed).\n\n mkfifo mypipe\n\n find . -print0 > mypipe &\n while IFS=\"\" read -r -d \"\" file <&4 ; do\n   COMMAND \"$file\" # Use quoted \"$file\", not $file, everywhere.\n done 4< mypipe\n```"]