<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Shell Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Shell Features</h1>
<blockquote>原文：<a href="https://learnbyexample.github.io/cli-computing/shell-features.html">https://learnbyexample.github.io/cli-computing/shell-features.html</a></blockquote><p>This chapter focuses on Bash shell features like quoting mechanisms, wildcards, redirections, command grouping, process substitution, command substitution, etc. Others will be discussed in later chapters.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files">example_files</a> directory has the scripts and sample input files used in this chapter.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Some of the examples in this chapter use commands that will be discussed in later chapters. Basic description of what such commands do have been added here and you'll also see more examples in the rest of the chapters.</p></blockquote><h2 id="quoting-mechanisms"><a class="header" href="#quoting-mechanisms">Quoting mechanisms</a></h2><p>This section will quote (<em>heh</em>) the relevant definitions from the <a href="https://www.gnu.org/software/bash/manual/bash.html#Quoting">bash manual</a> and provide some examples for each of the four mechanisms.</p><p><em>1)</em> <strong>Escape Character</strong></p><blockquote><p>A non-quoted backslash <code>\</code> is the Bash escape character. It preserves the literal value of the next character that follows, with the exception of newline.</p><p><strong>metacharacter</strong>: A character that, when unquoted, separates words. A metacharacter is a space, tab, newline, or one of the following characters: <code>|</code>, <code>&amp;</code>, <code>;</code>, <code>(</code>, <code>)</code>, <code>&lt;</code>, or <code>&gt;</code>.</p></blockquote><p>Here's an example where unquoted shell metacharacter causes an error:</p><pre><code class="language-bash">$ echo apple;cherry
apple
cherry: command not found

# '\;' escapes the ';' character, thus losing the metacharacter meaning
$ echo apple\;cherry
apple;cherry
</code></pre><p>And here's an example where the subtler issue might not be apparent at first glance:</p><pre><code class="language-bash"># this will create two files named 'new' and 'file.txt'
# aim was to create a single file named 'new file.txt'
$ touch new file.txt
$ ls new*txt
ls: cannot access 'new*txt': No such file or directory
$ rm file.txt new

# escaping the space will create a single file named 'new file.txt'
$ touch new\ file.txt
$ ls new*txt
'new file.txt'
$ rm new\ file.txt
</code></pre><p><em>2)</em> <strong>Single Quotes</strong></p><blockquote><p>Enclosing characters in single quotes (<code>'</code>) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash.</p></blockquote><p>No character is special within single quoted strings. Here's an example:</p><pre><code class="language-bash">$ echo 'apple;cherry'
apple;cherry
</code></pre><p>You can place strings represented by different quoting mechanisms next to each other to concatenate them together. Here's an example:</p><pre><code class="language-bash"># concatenation of four strings
# 1: '@fruits = '
# 2: \'
# 3: 'apple and banana'
# 4: \'
$ echo '@fruits = '\''apple and banana'\'
@fruits = 'apple and banana'
</code></pre><p><em>3)</em> <strong>Double Quotes</strong></p><blockquote><p>Enclosing characters in double quotes (<code>"</code>) preserves the literal value of all characters within the quotes, with the exception of <code>$</code>, <code>`</code>, <code>\</code>, and, when history expansion is enabled, <code>!</code>.</p></blockquote><p>Here's an example showing variable interpolation within double quotes:</p><pre><code class="language-bash">$ qty='5'

# as seen earlier, no character is special within single quotes
$ echo 'I bought $qty apples'
I bought $qty apples

# a typical use of double quotes is to enable variable interpolation
$ echo "I bought $qty apples"
I bought 5 apples
</code></pre><p>Unless you specifically want the shell to interpret the contents of a variable, you should always quote the variable to avoid issues due to the presence of shell metacharacters.</p><pre><code class="language-bash">$ f='new file.txt'

# same as: echo 'apple banana' &gt; new file.txt
$ echo 'apple banana' &gt; $f
bash: $f: ambiguous redirect

# same as: echo 'apple banana' &gt; 'new file.txt'
$ echo 'apple banana' &gt; "$f"
$ cat "$f"
apple banana
$ rm "$f"
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See also <a href="https://unix.stackexchange.com/q/131766/109046">unix.stackexchange: Why does my shell script choke on whitespace or other special characters?</a>.</p></blockquote><p><em>4)</em> <strong>ANSI-C Quoting</strong></p><blockquote><p>Words of the form <code>$'string'</code> are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard.</p></blockquote><p>This form of quoting helps you use escape sequences like <code>\t</code> for tab, <code>\n</code> for newline and so on. You can also represent characters using their codepoint values in octal and hexadecimal formats.</p><pre><code class="language-bash"># can also use echo -e 'fig:\t42' or printf 'fig:\t42\n'
$ echo $'fig:\t42'
fig:    42

# \x27 represents the single quote character in hexadecimal format
$ echo $'@fruits = \x27apple and banana\x27'
@fruits = 'apple and banana'

# 'grep' helps you to filter lines based on the given pattern
# but it doesn't recognize escapes like '\t' for tab characters
$ printf 'fig\t42\napple 100\nball\t20\n' | grep '\t'
# in such cases, one workaround is use to ANSI-C quoting
$ printf 'fig\t42\napple 100\nball\t20\n' | grep $'\t'
fig     42
ball    20
</code></pre><p><code>printf</code> is a shell builtin which you can use to format arguments (similar to the <code>printf()</code> function from the <code>C</code> programming language). This command will be used in many more examples to come.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See <a href="https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting">bash manual: ANSI-C Quoting</a> for complete list of supported escape sequences. See <code>man ascii</code> for a table of ASCII characters and their numerical representations.</p></blockquote><h2 id="wildcards"><a class="header" href="#wildcards">Wildcards</a></h2><p>It is relatively easy to specify complete filenames as command arguments when they are few in number. And you could use features like tab completion and middle mouse button click (which pastes the last highlighted text) to assist in such cases.</p><p>But what to do if you have to deal with tens and hundreds of files (or even more)? If applicable, one way is to match all the files based on a common pattern in their filenames, for example extensions like <code>.py</code>, <code>.txt</code> and so on. Wildcards (globs) will help in such cases. This feature is provided by the shell, and thus individual commands need not worry about implementing them. Pattern matching supported by wildcards are somewhat similar to regular expressions, but there are fundamental and syntactical differences between them.</p><p>Some of the commonly used wildcards are listed below:</p><ul><li><code>*</code> match any character, zero or more times <ul><li>as a special case, <code>*</code> won't match the starting <code>.</code> of hidden files unless the <code>dotglob</code> shell option is set</li></ul></li><li><code>?</code> match any character exactly once</li><li><code>[set149]</code> match any of these characters once</li><li><code>[^set149]</code> match any characters <em>except</em> the given set of characters <ul><li>you can also use <code>[!set149]</code> to negate the character class</li></ul></li><li><code>[a-z]</code> match a range of characters from <code>a</code> to <code>z</code></li><li><code>[0-9a-fA-F]</code> match any hexadecimal character</li></ul><p>And here are some examples:</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'globs.sh' script
$ source globs.sh
$ ls
100.sh   f1.txt      f4.txt    hi.sh   math.h         report-02.log
42.txt   f2_old.txt  f7.txt    ip.txt  notes.txt      report-04.log
calc.py  f2.txt      hello.py  main.c  report-00.log  report-98.log

# beginning with 'c' or 'h' or 't'
$ ls [cht]*
calc.py  hello.py  hi.sh

# only hidden files and directories
$ ls -d .*
.  ..  .hidden  .somerc

# ending with '.c' or '.py'
$ ls *.c *.py
calc.py  hello.py  main.c

# containing 'o' as well as 'x' or 'y' or 'z' afterwards
$ ls *o*[xyz]*
f2_old.txt  hello.py  notes.txt

# ending with '.' and two more characters
$ ls *.??
100.sh  calc.py  hello.py  hi.sh

# shouldn't start with 'f' and ends with '.txt'
$ ls [^f]*.txt
42.txt  ip.txt  notes.txt

# containing digits '1' to '5' and ending with 'log'
$ ls *[1-5]*log
report-02.log  report-04.log
</code></pre><p>Since some characters are special inside the character class, you need special placement to treat them as ordinary characters:</p><ul><li><code>-</code> should be the first or the last character in the set</li><li><code>^</code> should be other than the first character</li><li><code>]</code> should be the first character</li></ul><pre><code class="language-bash">$ ls *[ns-]*
100.sh  main.c     report-00.log  report-04.log
hi.sh   notes.txt  report-02.log  report-98.log

$ touch 'a^b' 'mars[planet].txt'
$ rm -i *[]^]*
rm: remove regular empty file 'a^b'? y
rm: remove regular empty file 'mars[planet].txt'? y
</code></pre><p>A <strong>named character set</strong> is defined by a name enclosed between <code>[:</code> and <code>:]</code> and has to be used within a character class <code>[]</code>, along with any other characters as needed.</p><div class="table-wrapper"><table><thead><tr><th>Named set</th><th>Description</th></tr></thead><tbody><tr><td><code>[:digit:]</code></td><td><code>[0-9]</code></td></tr><tr><td><code>[:lower:]</code></td><td><code>[a-z]</code></td></tr><tr><td><code>[:upper:]</code></td><td><code>[A-Z]</code></td></tr><tr><td><code>[:alpha:]</code></td><td><code>[a-zA-Z]</code></td></tr><tr><td><code>[:alnum:]</code></td><td><code>[0-9a-zA-Z]</code></td></tr><tr><td><code>[:word:]</code></td><td><code>[0-9a-zA-Z_]</code></td></tr><tr><td><code>[:xdigit:]</code></td><td><code>[0-9a-fA-F]</code></td></tr><tr><td><code>[:cntrl:]</code></td><td>control characters — first 32 ASCII characters and 127th (DEL)</td></tr><tr><td><code>[:punct:]</code></td><td>all the punctuation characters</td></tr><tr><td><code>[:graph:]</code></td><td><code>[:alnum:]</code> and <code>[:punct:]</code></td></tr><tr><td><code>[:print:]</code></td><td><code>[:alnum:]</code>, <code>[:punct:]</code> and space</td></tr><tr><td><code>[:ascii:]</code></td><td>all the ASCII characters</td></tr><tr><td><code>[:blank:]</code></td><td>space and tab characters</td></tr><tr><td><code>[:space:]</code></td><td>whitespace characters</td></tr></tbody></table></div><pre><code class="language-bash"># starting with a digit character, same as: [0-9]*
$ ls [[:digit:]]*
100.sh  42.txt

# starting with a digit character or 'c'
# same as: [0-9c]*
$ ls [[:digit:]c]*
100.sh  42.txt  calc.py

# starting with a non-alphabet character
$ ls [^[:alpha:]]*
100.sh  42.txt
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> As mentioned before, you can use <code>echo</code> to test how the wildcards will expand before using a command to act upon the matching files. For example, <code>echo *.txt</code> before using commands like <code>rm *.txt</code>. One difference compared to <code>ls</code> is that <code>echo</code> will display the wildcard as is instead of showing an error if there's no match.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See <a href="https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching">bash manual: Pattern Matching</a> for more details, information on locale stuff and so on.</p></blockquote><h2 id="brace-expansion"><a class="header" href="#brace-expansion">Brace Expansion</a></h2><p>This is not a wildcard feature, you just get expanded strings. Brace expansion has two mechanisms for reducing typing:</p><ul><li>taking out common portions among multiple strings</li><li>generating a range of characters</li></ul><p>Say you want to create two files named <code>test_x.txt</code> and <code>test_y.txt</code>. These two strings have something in common at the start and the end. You can specify the unique portions as comma separated strings within a pair of curly braces and put the common parts around the braces. Multiple braces can be used as needed. Use <code>echo</code> for testing purposes.</p><pre><code class="language-bash">$ mkdir practice_brace
$ cd practice_brace

# same as: touch ip1.txt ip3.txt ip7.txt
$ touch ip{1,3,7}.txt
$ ls ip*txt
ip1.txt  ip3.txt  ip7.txt

# same as: mv ip1.txt ip_a.txt
$ mv ip{1,_a}.txt
$ ls ip*txt
ip3.txt  ip7.txt  ip_a.txt

$ echo adders/{half,full}_adder.v
adders/half_adder.v adders/full_adder.v

$ echo file{0,1}.{txt,log}
file0.txt file0.log file1.txt file1.log

# empty alternate is allowed too
$ echo file{,1}.txt
file.txt file1.txt

# example with nested braces
$ echo file.{txt,log{,.bkp}}
file.txt file.log file.log.bkp
</code></pre><p>To generate a range, specify numbers or single characters separated by <code>..</code> and an optional third argument as the step value. Here are some examples:</p><pre><code class="language-bash">$ echo {1..4}
1 2 3 4
$ echo {4..1}
4 3 2 1

$ echo {1..2}{a..b}
1a 1b 2a 2b

$ echo file{1..4}.txt
file1.txt file2.txt file3.txt file4.txt

$ echo file{1..10..2}.txt
file1.txt file3.txt file5.txt file7.txt file9.txt

$ echo file_{x..z}.txt
file_x.txt file_y.txt file_z.txt

$ echo {z..j..-3}
z w t q n k

# '0' prefix
$ echo {008..10}
008 009 010
</code></pre><p>If the use of braces doesn't match the expansion syntax, it will be left as is:</p><pre><code class="language-bash">$ echo file{1}.txt
file{1}.txt

$ echo file{1-4}.txt
file{1-4}.txt
</code></pre><h2 id="extended-and-recursive-globs"><a class="header" href="#extended-and-recursive-globs">Extended and Recursive globs</a></h2><p>From <code>man bash</code>:</p><div class="table-wrapper"><table><thead><tr><th>Extended glob</th><th>Description</th></tr></thead><tbody><tr><td><code>?(pattern-list)</code></td><td>Matches zero or one occurrence of the given patterns</td></tr><tr><td><code>*(pattern-list)</code></td><td>Matches zero or more occurrences of the given patterns</td></tr><tr><td><code>+(pattern-list)</code></td><td>Matches one or more occurrences of the given patterns</td></tr><tr><td><code>@(pattern-list)</code></td><td>Matches one of the given patterns</td></tr><tr><td><code>!(pattern-list)</code></td><td>Matches anything except one of the given patterns</td></tr></tbody></table></div><p>Extended globs are disabled by default. You can use the <code>shopt</code> builtin to set/unset <strong>sh</strong>ell <strong>opt</strong>ions like <code>extglob</code>, <code>globstar</code>, etc. You can also check what is the current status of such options.</p><pre><code class="language-bash">$ shopt extglob
extglob         off

# set extglob
$ shopt -s extglob
$ shopt extglob
extglob         on

# unset extglob
$ shopt -u extglob
$ shopt extglob
extglob         off
</code></pre><p>Here are some examples, assuming <code>extglob</code> option has already been set:</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'globs.sh' script
$ source globs.sh
$ ls
100.sh   f1.txt      f4.txt    hi.sh   math.h         report-02.log
42.txt   f2_old.txt  f7.txt    ip.txt  notes.txt      report-04.log
calc.py  f2.txt      hello.py  main.c  report-00.log  report-98.log

# one or more digits followed by '.' and then zero or more characters
$ ls +([0-9]).*
100.sh  42.txt

# same as: ls *.c *.sh
$ ls *.@(c|sh)
100.sh  hi.sh  main.c

# not ending with '.txt'
$ ls !(*.txt)
100.sh   hello.py  main.c  report-00.log  report-04.log
calc.py  hi.sh     math.h  report-02.log  report-98.log

# not ending with '.txt' or '.log'
$ ls *.!(txt|log)
100.sh  calc.py  hello.py  hi.sh  main.c  math.h
</code></pre><p>If you enable the <code>globstar</code> option, you can recursively match filenames within a specified path.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'ls.sh' script
$ source ls.sh

# with 'find' command (this will be explained in a later chapter)
$ find -name '*.txt'
./todos/books.txt
./todos/outing.txt
./ip.txt

# with 'globstar' enabled
$ shopt -s globstar
$ ls **/*.txt
ip.txt  todos/books.txt  todos/outing.txt

# another example
$ ls -1 **/*.@(py|html)
backups/bookmarks.html
hello_world.py
projects/tictactoe/game.py
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Add the <code>shopt</code> invocations to <code>~/.bashrc</code> if you want these settings applied at terminal startup. This will be discussed in the <a href="./shell-customization.html">Shell Customization</a> chapter.</p></blockquote><h2 id="set"><a class="header" href="#set">set</a></h2><p>The <code>set</code> builtin command helps you to set or unset values of shell options and positional parameters. Here are some examples for shell options:</p><pre><code class="language-bash"># disables logging command history from this point onwards
$ set +o history
# enable history logging
$ set -o history

# use vi-style CLI editing interface
$ set -o vi
# use emacs-style interface, this is usually the default
$ set -o emacs
</code></pre><p>You'll see more examples (for example, <code>set -x</code>) in later chapters. See <a href="https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin">bash manual: Set Builtin</a> for documentation.</p><h2 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h2><p>The pipe control operator <code>|</code> helps you connect the output of a command as the input of another command. This operator vastly reduces the need for temporary intermediate files. As discussed previously in the <a href="./command-line-overview.html#unix-philosophy">Unix Philosophy</a> section, command line tools usually specialize in a single task. If you can break down a problem into smaller tasks, the pipe operator will come in handy often. Here are some examples:</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'du.sh' script
$ source du.sh

# list of files
$ ls
projects  report.log  todos
# count the number of files
# you can also use: printf '%q\n' * | wc -l
$ ls -q | wc -l
3

# report the size of files/folders in human readable format
# and then sort them based on human readable sizes in ascending order
$ du -sh * | sort -h
8.0K    todos
48K     projects
7.4M    report.log
</code></pre><p>In the above examples, <code>ls</code> and <code>du</code> perform their own tasks of displaying list of files and showing file sizes respectively. After that, the <code>wc</code> and <code>sort</code> commands take care of counting and sorting the lines respectively. In such cases, the pipe operator saves you the trouble of dealing with temporary data.</p><p>Note that the <code>%q</code> format specifier in <code>printf</code> helps you quote the arguments in a way that is recognizable by the shell. The <code>-q</code> option for <code>ls</code> substitutes nongraphic characters in the filenames with a <code>?</code> character. Both of these are workarounds to prevent the counting process from getting sidetracked due to characters like newline in the filenames.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The pipe control operator <code>|&amp;</code> will be discussed later in this chapter.</p></blockquote><h3 id="tee"><a class="header" href="#tee">tee</a></h3><p>Sometimes, you might want to display the command output on the terminal as well as require the results for later use. In such cases, you can use the <code>tee</code> command:</p><pre><code class="language-bash">$ du -sh * | tee sizes.log
48K     projects
7.4M    report.log
8.0K    todos

$ cat sizes.log
48K     projects
7.4M    report.log
8.0K    todos

$ rm sizes.log
</code></pre><h2 id="redirection"><a class="header" href="#redirection">Redirection</a></h2><p>From <a href="https://www.gnu.org/software/bash/manual/bash.html#Redirections">bash manual: Redirections</a>:</p><blockquote><p>Before a command is executed, its input and output may be <em>redirected</em> using a special notation interpreted by the shell. Redirection allows commands' file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. Redirection may also be used to modify file handles in the current shell execution environment.</p></blockquote><p>There are three standard data streams:</p><ul><li><strong>standard input</strong> (<code>stdin</code> — file descriptor 0)</li><li><strong>standard output</strong> (<code>stdout</code> — file descriptor 1)</li><li><strong>standard error</strong> (<code>stderr</code> — file descriptor 2)</li></ul><p>Both the standard output and error streams are displayed on the terminal by default. The <code>stderr</code> stream is used when something goes wrong with the command usage. Each of these three streams have a predefined <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a> as mentioned above. In this section, you'll see how to redirect these three streams.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Redirections can be placed anywhere, but they are usually used at the start or end of a command. For example, the following two commands are equivalent:</p><pre><code class="language-bash">&gt;op.txt grep 'error' report.log

grep 'error' report.log &gt;op.txt
</code></pre></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Space characters between the redirection operators and the filename are optional.</p></blockquote><h3 id="redirecting-output"><a class="header" href="#redirecting-output">Redirecting output</a></h3><p>You can use the <code>&gt;</code> operator to redirect the standard output of a command to a file. A number prefix can be added to the <code>&gt;</code> operator to work with that particular file descriptor. Default is <code>1</code> (recall that the file descriptor for <code>stdout</code> is <code>1</code>), so <code>1&gt;</code> and <code>&gt;</code> perform the same operation. Use <code>&gt;&gt;</code> to append the output to a file.</p><p>The filename provided to the <code>&gt;</code> and <code>&gt;&gt;</code> operators will be created if a regular file of that name doesn't exist yet. If the file already exists, <code>&gt;</code> will overwrite that file whereas <code>&gt;&gt;</code> will append the contents.</p><pre><code class="language-bash"># change to the 'example_files/text_files' directory for this section

# save first three lines of 'sample.txt' to 'op.txt'
$ head -n3 sample.txt &gt; op.txt
$ cat op.txt
 1) Hello World
 2) 
 3) Hi there

# append last two lines of 'sample.txt' to 'op.txt'
$ tail -n2 sample.txt &gt;&gt; op.txt
$ cat op.txt
 1) Hello World
 2) 
 3) Hi there
14) He he he
15) Adios amigo

$ rm op.txt
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You can use <code>/dev/null</code> as a filename to discard the output, to provide an empty file as input for a command, etc.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You can use <code>set noclobber</code> to prevent overwriting if a file already exists. When the <code>noclobber</code> option is set, you can still overwrite a file by using <code>&gt;|</code> instead of the <code>&gt;</code> operator.</p></blockquote><h3 id="redirecting-input"><a class="header" href="#redirecting-input">Redirecting input</a></h3><p>Some commands like <code>tr</code> and <code>datamash</code> can only work with data from the standard input. This isn't an issue when you are piping data from another command, for example:</p><pre><code class="language-bash"># filter lines containing 'the' from the input file 'greeting.txt'
# and then display the results in uppercase using the 'tr' command
$ grep 'the' greeting.txt | tr 'a-z' 'A-Z'
HI THERE
</code></pre><p>You can use the <code>&lt;</code> redirection operator if you want to pass data from a file to such commands. The default prefix here is <code>0</code>, which is the file descriptor for <code>stdin</code> data. Here's an example:</p><pre><code class="language-bash">$ tr 'a-z' 'A-Z' &amp;LTgreeting.txt
HI THERE
HAVE A NICE DAY
</code></pre><p>In some cases, a tool behaves differently when processing <code>stdin</code> data compared to file input. Here's an example with <code>wc -l</code> to report the total number of lines in the input:</p><pre><code class="language-bash"># line count, filename is part of the output as well
$ wc -l purchases.txt
8 purchases.txt

# filename won't be part of the output for stdin data
# helpful for assigning the number to a variable for scripting purposes
$ wc -l &amp;LTpurchases.txt
8
</code></pre><p>Sometimes, you need to pass <code>stdin</code> data as well as other file inputs to a command. In such cases, you can use <code>-</code> to represent data from the standard input. Here's an example:</p><pre><code class="language-bash">$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

# insert a column at the start
$ printf 'ID\n1\n2\n3' | paste -d, - scores.csv
ID,Name,Maths,Physics,Chemistry
1,Ith,100,100,100
2,Cy,97,98,95
3,Lin,78,83,80
</code></pre><p>Even though a command accepts file input directly as an argument, redirecting can help for interactive usage. Here's an example:</p><pre><code class="language-bash"># display only the third field
$ &amp;LTscores.csv cut -d, -f3
Physics
100
98
83

# later, you realize that you need the first field too
# use 'up' arrow key to bring the previous command
# and modify the argument easily at the end
# if you had used cut -d, -f3 scores.csv instead,
# you'd have to navigate past the filename to modify the argument
$ &amp;LTscores.csv cut -d, -f1,3
Name,Physics
Ith,100
Cy,98
Lin,83
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> Don't use <code>cat filename | cmd</code> for passing file content as <code>stdin</code> data, unless you need to concatenate data from multiple input files. See <a href="https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat">wikipedia: UUOC</a> and <a href="https://porkmail.org/era/unix/award.html">Useless Use of Cat Award</a> for more details.</p></blockquote><h3 id="redirecting-error"><a class="header" href="#redirecting-error">Redirecting error</a></h3><p>Recall that the file descriptor for <code>stderr</code> is <code>2</code>. So, you can use <code>2&gt;</code> to redirect standard error to a file. Use <code>2&gt;&gt;</code> if you need to append the contents. Here's an example:</p><pre><code class="language-bash"># assume 'abcdxyz' doesn't exist as a shell command
$ abcdxyz
abcdxyz: command not found

# the error in such cases will be part of the stderr stream, not stdout
# so, you'll need to use 2&gt; here
$ abcdxyz 2&gt; cmderror.log
$ cat cmderror.log
abcdxyz: command not found

$ rm cmderror.log
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Use <code>/dev/null</code> as a filename if you need to discard the results.</p></blockquote><h3 id="combining-stdout-and-stderr"><a class="header" href="#combining-stdout-and-stderr">Combining stdout and stderr</a></h3><p>Newer versions of Bash provide these handy shortcuts:</p><ul><li><code>&amp;&gt;</code> redirect both <code>stdout</code> and <code>stderr</code> (overwrite if file already exists)</li><li><code>&amp;&gt;&gt;</code> redirect both <code>stdout</code> and <code>stderr</code> (append if file already exists)</li><li><code>|&amp;</code> pipe both <code>stdout</code> and <code>stderr</code> as input to another command</li></ul><p>Here's an example which assumes <code>xyz.txt</code> doesn't exist, thus leading to errors:</p><pre><code class="language-bash"># using '&gt;' will redirect only the stdout stream
# stderr will be displayed on the terminal
$ grep 'log' file_size.txt xyz.txt &gt; op.txt
grep: xyz.txt: No such file or directory

# using '&amp;&gt;' will redirect both the stdout and stderr streams
$ grep 'log' file_size.txt xyz.txt &amp;&gt; op.txt
$ cat op.txt
file_size.txt:104K    power.log
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory

$ rm op.txt
</code></pre><p>And here's an example with the <code>|&amp;</code> operator:</p><pre><code class="language-bash"># filter lines containing 'log' from the given file arguments
# and then filter lines containing 'or' from the combined stdout and stderr
$ grep 'log' file_size.txt xyz.txt |&amp; grep 'or'
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory
</code></pre><p>For earlier Bash versions, you'll have to manually redirect the streams:</p><ul><li><code>1&gt;&amp;2</code> redirects file descriptor <code>1</code> (<code>stdout</code>) to the file descriptor <code>2</code> (<code>stderr</code>)</li><li><code>2&gt;&amp;1</code> redirects file descriptor <code>2</code> (<code>stderr</code>) to the file descriptor <code>1</code> (<code>stdout</code>)</li></ul><p>Here are some examples:</p><pre><code class="language-bash"># note that the order of redirections is important here
# you can also use: 2&gt; op.txt 1&gt;&amp;2
$ grep 'log' file_size.txt xyz.txt &gt; op.txt 2&gt;&amp;1
$ cat op.txt
file_size.txt:104K    power.log
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory
$ rm op.txt

$ grep 'log' file_size.txt xyz.txt 2&gt;&amp;1 | grep 'or'
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory
</code></pre><h3 id="waiting-for-stdin"><a class="header" href="#waiting-for-stdin">Waiting for stdin</a></h3><p>Sometimes, you might mistype a command without providing input. And instead of getting an error, you'll see the cursor patiently waiting for something. This isn't the shell hanging up on you. The command is waiting for you to type data, so that it can perform its task.</p><p>Say, you typed <code>cat</code> and pressed the Enter key. Seeing the blinking cursor, you type some text and press the Enter key again. You'll see the text you just typed echoed back to you as <code>stdout</code> (which is the functionality of the <code>cat</code> command). This will continue again and again, until you tell the shell that you are done. How to do that? Press <code>Ctrl+d</code> on a fresh line or press <code>Ctrl+d</code> twice at the end of a line. In the latter case, you'll not get a newline character at the end of the data.</p><pre><code class="language-bash"># press Enter and Ctrl+d after typing all the required characters
$ cat
knock knock
knock knock
anybody here?
anybody here?

# 'tr' command here translates lowercase to uppercase
$ tr 'a-z' 'A-Z'
knock knock
KNOCK KNOCK
anybody here?
ANYBODY HERE?
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Getting output immediately after each input line depends on the command's functionality. Commands like <code>sort</code> and <code>shuf</code> will wait for the entire input data before producing the output.</p><pre><code class="language-bash"># press Ctrl+d after the third input line
$ sort
lion
zebra
bee
bee
lion
zebra
</code></pre></blockquote><p>Here's an example which has output redirection as well:</p><pre><code class="language-bash"># press Ctrl+d after the line containing 'histogram'
# filter lines containing 'is'
$ grep 'is' &gt; op.txt
hi there
this is a sample line
have a nice day
histogram

$ cat op.txt
this is a sample line
histogram

$ rm op.txt
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See also <a href="https://unix.stackexchange.com/q/16333/109046">unix.stackexchange: difference between Ctrl+c and Ctrl+d</a>.</p></blockquote><h3 id="here-documents"><a class="header" href="#here-documents">Here Documents</a></h3><p>Here Documents is another way to provide <code>stdin</code> data. In this case, the termination condition is a line matching a predefined string which is specified after the <code>&lt;&lt;</code> redirection operator. This is especially helpful for automation, since pressing <code>Ctrl+d</code> interactively isn't desirable. Here's an example:</p><pre><code class="language-bash"># EOF is typically used as the special string
$ cat &lt;&lt; 'EOF' &gt; fruits.txt
&gt; banana 2
&gt; papaya 3
&gt; mango  10
&gt; EOF

$ cat fruits.txt
banana 2
papaya 3
mango  10
$ rm fruits.txt
</code></pre><p>In the above example, the termination string was enclosed in single quotes as a good practice. Doing so prevents parameter expansion, command substitution, etc. You can also use <code>\string</code> for this purpose. If you use <code>&lt;&amp;LT-</code> instead of <code>&lt;&lt;</code>, leading tab characters can be added at the start of input lines without being part of the actual data.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Just like <code>$</code> and a space represents the primary prompt (<code>PS1</code> shell variable), <code>&gt;</code> and a space at the start of lines represents the secondary prompt <code>PS2</code> (applicable for multiline commands). Don't type these characters when you use Here Documents in a shell script.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See <a href="https://www.gnu.org/software/bash/manual/bash.html#Here-Documents">bash manual: Here Documents</a> and <a href="https://stackoverflow.com/q/2953081/4082052">stackoverflow: here documents</a> for more examples and details.</p></blockquote><h3 id="here-strings"><a class="header" href="#here-strings">Here Strings</a></h3><p>This is similar to Here Documents, but the string is passed as an argument after the <code>&lt;&lt;&lt;</code> redirection operator. Here are some examples:</p><pre><code class="language-bash">$ tr 'a-z' 'A-Z' &lt;&lt;&lt; hello
HELLO
$ tr 'a-z' 'A-Z' &lt;&lt;&lt; 'hello world'
HELLO WORLD

$ greeting='hello world'
$ tr 'a-z' 'A-Z' &gt; op.txt &lt;&lt;&lt; "$greeting"
$ cat op.txt
HELLO WORLD
$ rm op.txt
</code></pre><h3 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h3><ul><li><a href="https://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection">Short introduction to shell redirection</a></li><li><a href="https://web.archive.org/web/20221231120128/https://wiki.bash-hackers.org/howto/redirection_tutorial">Illustrated Redirection Tutorial</a></li><li><a href="https://stackoverflow.com/q/818255/4082052">stackoverflow: Redirect a stream to another file descriptor using &gt;&amp;</a></li><li><a href="https://mywiki.wooledge.org/BashFAQ/055">Difference between 2&gt;&amp;1 &gt;foo and &gt;foo 2&gt;&amp;1</a></li><li><a href="https://stackoverflow.com/q/876239/4082052">stackoverflow: Redirect and append both stdout and stderr to a file</a></li><li><a href="https://unix.stackexchange.com/q/164391/109046">unix.stackexchange: Examples for &lt;&gt; redirection</a></li></ul><h2 id="grouping-commands"><a class="header" href="#grouping-commands">Grouping commands</a></h2><p>You can use the <code>(list)</code> and <code>{ list; }</code> compound commands to redirect content for several commands. The former is executed in a subshell whereas the latter is executed in the current shell context. Spaces around <code>()</code> are optional but necessary for the <code>{}</code> version. From <a href="https://www.gnu.org/software/bash/manual/bash.html#Lists">bash manual: Lists of Commands</a>:</p><blockquote><p>A <code>list</code> is a sequence of one or more pipelines separated by one of the operators <code>;</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, or <code>||</code>, and optionally terminated by one of <code>;</code>, <code>&amp;</code>, or a newline.</p></blockquote><p>Here are some examples of command groupings:</p><pre><code class="language-bash"># change to the 'example_files/text_files' directory for this section

# the 'sed' command here gives the first line of the input
# rest of the lines are then processed by the 'sort' command
# thus, the header will always be the first line in the output
$ (sed -u '1q' ; sort) &lt; scores.csv
Name,Maths,Physics,Chemistry
Cy,97,98,95
Ith,100,100,100
Lin,78,83,80

# save first three and last two lines from 'sample.txt' to 'op.txt'
$ { head -n3 sample.txt; tail -n2 sample.txt; } &gt; op.txt
$ cat op.txt
 1) Hello World
 2) 
 3) Hi there
14) He he he
15) Adios amigo
$ rm op.txt
</code></pre><p>You might wonder why the second command did not use <code>&lt; sample.txt</code> instead of repeating the filename twice. The reason is that some commands might read more than what is required (for buffering purposes) and thus cause issues for the remaining commands. In the <code>sed+sort</code> example, the <code>-u</code> option guarantees that <code>sed</code> will not to read more than the required data. See <a href="https://unix.stackexchange.com/q/11856/109046">unix.stackexchange: sort but keep header line at the top</a> for more examples and details.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You don't need the <code>()</code> or <code>{}</code> groups to see the results of multiple commands on the terminal. Just the <code>;</code> separator between the commands would be enough. See also <a href="https://www.gnu.org/software/bash/manual/bash.html#Command-Execution-Environment">bash manual: Command Execution Environment</a>.</p><pre><code class="language-bash">$ head -n1 sample.txt ; echo 'have a nice day'
 1) Hello World
have a nice day
</code></pre></blockquote><h2 id="list-control-operators"><a class="header" href="#list-control-operators">List control operators</a></h2><p>You can use these operators to control the execution of the subsequent command depending on the exit status of the first command. From <a href="https://www.gnu.org/software/bash/manual/bash.html#Lists">bash manual: Lists of Commands</a>:</p><blockquote><p>AND and OR lists are sequences of one or more pipelines separated by the control operators <code>&amp;&amp;</code> and <code>||</code>, respectively. AND and OR lists are executed with left associativity.</p></blockquote><p>For AND list, the second command will be executed if and only if the first command exits with <code>0</code> status.</p><pre><code class="language-bash"># first command succeeds here, so the second command is also executed
$ echo 'hello' &amp;&amp; echo 'have a nice day'
hello
have a nice day

# assume 'abcdxyz' doesn't exist as a shell command
# the second command will not be executed
$ abcdxyz &amp;&amp; echo 'have a nice day'
abcdxyz: command not found

# if you use ';' instead, the second command will still be executed
$ abcdxyz ; echo 'have a nice day'
abcdxyz: command not found
have a nice day
</code></pre><p>For OR list, the second command will be executed if and only if the first command does <em>not</em> exit with <code>0</code> status.</p><pre><code class="language-bash"># since the first command succeeds, the second one won't run
$ echo 'hello' || echo 'have a nice day'
hello

# assume 'abcdxyz' doesn't exist as a shell command
# since the first command fails, the second one will run
$ abcdxyz || echo 'have a nice day'
abcdxyz: command not found
have a nice day
</code></pre><h2 id="command-substitution"><a class="header" href="#command-substitution">Command substitution</a></h2><p>Command substitution allows you to use the standard output of a command as part of another command. Trailing newlines, if any, will be removed. You can use the newer and preferred syntax <code>$(command)</code> or the older syntax <code>`command`</code>. Here are some examples:</p><pre><code class="language-bash"># sample input
$ printf 'hello\ntoday is: \n'
hello
today is:
# append output from the 'date' command to the line containing 'today'
$ printf 'hello\ntoday is: \n' | sed '/today/ s/$/'"$(date +%A)"'/'
hello
today is: Monday

# save the output of 'wc' command to a variable
# same as: line_count=`wc -l &amp;LTsample.txt`
$ line_count=$(wc -l &amp;LTsample.txt)
$ echo "$line_count"
15
</code></pre><p>Here's an example with nested substitutions:</p><pre><code class="language-bash"># dirname removes the trailing path component
$ dirname projects/tictactoe/game.py
projects/tictactoe
# basename removes the leading directory component
$ basename projects/tictactoe
tictactoe

$ proj=$(basename $(dirname projects/tictactoe/game.py))
$ echo "$proj"
tictactoe
</code></pre><p>Difference between the two types of syntax is quoted below from <a href="https://www.gnu.org/software/bash/manual/bash.html#Command-Substitution">bash manual: Command Substitution</a>:</p><blockquote><p>When the old-style backquote form of substitution is used, backslash retains its literal meaning except when followed by <code>$</code>, <code>`</code>, or <code>\</code>. The first backquote not preceded by a backslash terminates the command substitution. When using the $(command) form, all characters between the parentheses make up the command; none are treated specially.</p><p>Command substitutions may be nested. To nest when using the backquoted form, escape the inner backquotes with backslashes.</p></blockquote><h2 id="process-substitution"><a class="header" href="#process-substitution">Process substitution</a></h2><p>Instead of a file argument, you can use command output with process substitution. The syntax is <code>&lt;(list)</code>. The shell will take care of passing a filename with the standard output of those commands. Here's an example:</p><pre><code class="language-bash"># change to the 'example_files/text_files' directory for this section

$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

# can also use: paste -d, &lt;(echo 'ID'; seq 3) scores.csv
$ paste -d, &lt;(printf 'ID\n1\n2\n3') scores.csv
ID,Name,Maths,Physics,Chemistry
1,Ith,100,100,100
2,Cy,97,98,95
3,Lin,78,83,80
</code></pre><p>For the above example, you could also have used <code>-</code> to represent <code>stdin</code> piped data as seen in an earlier section. Here's an example where two substitutions are used. This essentially helps you to avoid managing multiple temporary files, similar to how the <code>|</code> pipe operator helps for single temporary file.</p><pre><code class="language-bash"># side-by-side view of sample input files
$ paste f1.txt f2.txt
1       1
2       hello
3       3
world   4

# this command gives the common lines between two files
# the files have to be sorted for the command to work properly
$ comm -12 &lt;(sort f1.txt) &lt;(sort f2.txt)
1
3
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See <a href="https://unix.stackexchange.com/q/609375/109046">this unix.stackexchange thread</a> for examples with the <code>&gt;(list)</code> form.</p></blockquote><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Use the <code>globs.sh</code> script for wildcards related exercises, unless otherwise mentioned.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Create a temporary directory for exercises that may require you to create some files. You can delete such practice directories afterwards.</p></blockquote><p><strong>1)</strong> Use the <code>echo</code> command to display the text as shown below. Use appropriate quoting as necessary.</p><pre><code class="language-nohighlight"># ???
that's    great! $x = $y + $z
</code></pre><p><strong>2)</strong> Use the <code>echo</code> command to display the values of the three variables in the format as shown below.</p><pre><code class="language-bash">$ n1=10
$ n2=90
$ op=100

# ???
10 + 90 = 100
</code></pre><p><strong>3)</strong> What will be the output of the command shown below?</p><pre><code class="language-bash">$ echo $'\x22apple\x22: \x2710\x27'
</code></pre><p><strong>4)</strong> List filenames starting with a digit character.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'globs.sh' script
$ source globs.sh

# ???
100.sh  42.txt
</code></pre><p><strong>5)</strong> List filenames whose extension do not begin with <code>t</code> or <code>l</code>. Assume extensions will have at least one character.</p><pre><code class="language-bash"># ???
100.sh  calc.py  hello.py  hi.sh  main.c  math.h
</code></pre><p><strong>6)</strong> List filenames whose extension only have a single character.</p><pre><code class="language-bash"># ???
main.c  math.h
</code></pre><p><strong>7)</strong> List filenames whose extension is not <code>txt</code>.</p><pre><code class="language-bash"># ???
100.sh   hello.py  main.c  report-00.log  report-04.log
calc.py  hi.sh     math.h  report-02.log  report-98.log
</code></pre><p><strong>8)</strong> Describe the wildcard pattern used in the command shown below.</p><pre><code class="language-bash">$ ls *[^[:word:]]*.*
report-00.log  report-02.log  report-04.log  report-98.log
</code></pre><p><strong>9)</strong> List filenames having only lowercase alphabets before the extension.</p><pre><code class="language-bash"># ???
calc.py  hello.py  hi.sh  ip.txt  main.c  math.h  notes.txt
</code></pre><p><strong>10)</strong> List filenames starting with <code>ma</code> or <code>he</code> or <code>hi</code>.</p><pre><code class="language-bash"># ???
hello.py  hi.sh  main.c  math.h
</code></pre><p><strong>11)</strong> What commands would you use to get the outputs shown below? Assume that you do not know the depth of sub-directories.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'ls.sh' script
$ source ls.sh

# filenames ending with '.txt'
# ???
ip.txt  todos/books.txt  todos/outing.txt

# directories starting with 'c' or 'd' or 'g' or 'r' or 't'
# ???
backups/dot_files/
projects/calculator/
projects/tictactoe/
todos/
</code></pre><p><strong>12)</strong> Create and change to an empty directory. Then, use brace expansion along with relevant commands to get the results shown below.</p><pre><code class="language-bash"># ???
$ ls report*
report_2020.txt  report_2021.txt  report_2022.txt

# use the 'cp' command here
# ???
$ ls report*
report_2020.txt  report_2021.txt  report_2021.txt.bkp  report_2022.txt
</code></pre><p><strong>13)</strong> What does the <code>set</code> builtin command do?</p><p><strong>14)</strong> What does the <code>|</code> pipe operator do? And when would you add the <code>tee</code> command?</p><p><strong>15)</strong> Can you infer what the following command does? <em>Hint</em>: see <code>help printf</code>.</p><pre><code class="language-bash">$ printf '%s\n' apple car dragon
apple
car
dragon
</code></pre><p><strong>16)</strong> Use brace expansion along with relevant commands and shell features to get the result shown below. <em>Hint</em>: see previous question.</p><pre><code class="language-bash">$ ls ip.txt
ls: cannot access 'ip.txt': No such file or directory

# ???
$ cat ip.txt
item_10
item_12
item_14
item_16
item_18
item_20
</code></pre><p><strong>17)</strong> With <code>ip.txt</code> containing text as shown in the previous question, use brace expansion and relevant commands to get the result shown below.</p><pre><code class="language-bash"># ???
$ cat ip.txt
item_10
item_12
item_14
item_16
item_18
item_20
apple_1_banana_6
apple_1_banana_7
apple_1_banana_8
apple_2_banana_6
apple_2_banana_7
apple_2_banana_8
apple_3_banana_6
apple_3_banana_7
apple_3_banana_8
</code></pre><p><strong>18)</strong> What are the differences between <code>&lt;</code> and <code>|</code> shell operators, if any?</p><p><strong>19)</strong> Which character is typically used to represent <code>stdin</code> data as a file argument?</p><p><strong>20)</strong> What do the following operators do?</p><p><em>a)</em> <code>1&gt;</code><br/> <em>b)</em> <code>2&gt;</code><br/> <em>c)</em> <code>&amp;&gt;</code><br/> <em>d)</em> <code>&amp;&gt;&gt;</code><br/> <em>e)</em> <code>|&amp;</code></p><p><strong>21)</strong> What will be the contents of <code>op.txt</code> if you use the following <code>grep</code> command?</p><pre><code class="language-bash"># press Ctrl+d after the line containing 'histogram'
$ grep 'hi' &gt; op.txt
hi there
this is a sample line
have a nice day
histogram

$ cat op.txt
</code></pre><p><strong>22)</strong> What will be the contents of <code>op.txt</code> if you use the following commands?</p><pre><code class="language-bash">$ qty=42
$ cat &lt;&lt; end &gt; op.txt
&gt; dragon
&gt; unicorn
&gt; apple $qty
&gt; ice cream
&gt; end

$ cat op.txt
</code></pre><p><strong>23)</strong> Correct the command to get the expected output shown below.</p><pre><code class="language-bash">$ books='cradle piranesi soulhome bastion'

# something is wrong with this command
$ sed 's/\b\w/\u&amp;/g' &lt;&lt;&lt; '$books'
$Books

# ???
Cradle Piranesi Soulhome Bastion
</code></pre><p><strong>24)</strong> Correct the command to get the expected output shown below.</p><pre><code class="language-bash"># something is wrong with this command
$ echo 'hello' ; seq 3 &gt; op.txt
hello
$ cat op.txt
1
2
3

# ???
$ cat op.txt
hello
1
2
3
</code></pre><p><strong>25)</strong> What will be the output of the following commands?</p><pre><code class="language-bash">$ printf 'hello' | tr 'a-z' 'A-Z' &amp;&amp; echo ' there'

$ printf 'hello' | tr 'a-z' 'A-Z' || echo ' there'
</code></pre><p><strong>26)</strong> Correct the command(s) to get the expected output shown below.</p><pre><code class="language-bash"># something is wrong with these commands
$ nums=$(seq 3)
$ echo $nums
1 2 3

# ???
1
2
3
</code></pre><p><strong>27)</strong> Will the following two commands produce equivalent output? If not, why not?</p><pre><code class="language-bash">$ paste -d, &lt;(seq 3) &lt;(printf '%s\n' item_{1..3})

$ printf '%s\n' {1..3},item_{1..3}
</code></pre>    
</body>
</html>