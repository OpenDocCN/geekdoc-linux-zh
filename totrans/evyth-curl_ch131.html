<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch131.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="usingcurl__tls__clientcert__md-_-_-client-certificates" class="level1" data-number="130">
<h1 data-number="130">Client certificates</h1>
<p>TLS client certificates are a way for clients to cryptographically prove to servers that they are truly the right peer (also sometimes known as Mutual TLS or mTLS). A command line that uses a client certificate specifies the certificate and the corresponding key, and they are then passed on the TLS handshake with the server.</p>
<p>You need to have your client certificate already stored in a file when doing this and you should supposedly have gotten it from the right instance via a different channel previously.</p>
<p>The key is typically protected by a password that you need to provide or get prompted for interactively.</p>
<p>curl offers options to let you specify a single file that is both the client certificate and the private key concatenated using <code>--cert</code>, or you can specify the key file independently with <code>--key</code>:</p>
<pre><code>curl --cert mycert:mypassword https://example.com
curl --cert mycert:mypassword --key mykey https://example.com</code></pre>
<p>For some TLS backends you can also pass in the key and certificate using different types:</p>
<pre><code>curl --cert mycert:mypassword --cert-type PEM \
     --key mykey --key-type PEM https://example.com</code></pre>
<p><span id="usingcurl__tls__auth__md"></span></p>
</section>
</body>
</html>
