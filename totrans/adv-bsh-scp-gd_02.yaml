- en: Chapter 1\. Shell Programming!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://tldp.org/LDP/abs/html/why-shell.html](https://tldp.org/LDP/abs/html/why-shell.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|   |  **No programming language is perfect. There is not even a single best
    language; there are only languages well suited or perhaps poorly suited for particular
    purposes.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*--Herbert Mayer**  |'
  prefs: []
  type: TYPE_NORMAL
- en: A working knowledge of shell scripting is essential to anyone wishing to become
    reasonably proficient at system administration, even if they do not anticipate
    ever having to actually write a script. Consider that as a Linux machine boots
    up, it executes the shell scripts in `/etc/rc.d` to restore the system configuration
    and set up services. A detailed understanding of these startup scripts is important
    for analyzing the behavior of a system, and possibly modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: The craft of scripting is not hard to master, since scripts can be built in
    bite-sized sections and there is only a fairly small set of shell-specific operators
    and options [[1]](#FTN.AEN62) to learn. The syntax is simple -- even austere --
    similar to that of invoking and chaining together utilities at the command line,
    and there are only a few "rules" governing their use. Most short scripts work
    right the first time, and debugging even the longer ones is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of personal computing, the BASIC language enabled
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: anyone reasonably computer proficient to write programs on an early
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: generation of microcomputers. Decades later, the Bash scripting
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: language enables anyone with a rudimentary knowledge of Linux or
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: UNIX to do the same on modern machines.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We now have miniaturized single-board computers with amazing
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: capabilities, such as the [Raspberry Pi](http://www.raspberrypi.org/).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bash scripting provides a way to explore the capabilities of these
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: fascinating devices.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A shell script is a quick-and-dirty method of prototyping a complex application.
    Getting even a limited subset of the functionality to work in a script is often
    a useful first stage in project development. In this way, the structure of the
    application can be tested and tinkered with, and the major pitfalls found before
    proceeding to the final coding in *C*, *C++*, *Java*, [Perl](wrapper.html#PERLREF),
    or *Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripting hearkens back to the classic UNIX philosophy of breaking complex
    projects into simpler subtasks, of chaining together components and utilities.
    Many consider this a better, or at least more esthetically pleasing approach to
    problem solving than using one of the new generation of high-powered all-in-one
    languages, such as *Perl*, which attempt to be all things to all people, but at
    the cost of forcing you to alter your thinking processes to fit the tool.
  prefs: []
  type: TYPE_NORMAL
- en: According to [Herbert Mayer](biblio.html#MAYERREF), "a useful language needs
    arrays, pointers, and a generic mechanism for building data structures." By these
    criteria, shell scripting falls somewhat short of being "useful." Or, perhaps
    not. . . .
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: When not to use shell scripts
  prefs: []
  type: TYPE_NORMAL
- en: Resource-intensive tasks, especially where speed is a factor (sorting, hashing,
    recursion [[2]](#FTN.AEN87) ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedures involving heavy-duty math operations, especially floating point arithmetic,
    arbitrary precision calculations, or complex numbers (use *C++* or *FORTRAN* instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform portability required (use *C* or *Java* instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex applications, where structured programming is a necessity (type-checking
    of variables, function prototypes, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mission-critical applications upon which you are betting the future of the company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Situations where *security* is important, where you need to guarantee the integrity
    of your system and protect against intrusion, cracking, and vandalism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project consists of subcomponents with interlocking dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive file operations required (*Bash* is limited to serial file access,
    and that only in a particularly clumsy and inefficient line-by-line fashion.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need native support for multi-dimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need data structures, such as linked lists or trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to generate / manipulate graphics or GUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need direct access to system hardware or external peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need port or [socket](devref1.html#SOCKETREF) I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to use libraries or interface with legacy code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proprietary, closed-source applications (Shell scripts put the source code right
    out in the open for all the world to see.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the above applies, consider a more powerful scripting language --
    perhaps *Perl*, *Tcl*, *Python*, *Ruby* -- or possibly a compiled language such
    as *C*, *C++*, or *Java*. Even then, prototyping the application as a shell script
    might still be a useful development step.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Bash, an acronym [[3]](#FTN.AEN139) for "Bourne-Again shell"
    and a pun on Stephen Bourne's now classic *Bourne* shell. Bash has become a *de
    facto* standard for shell scripting on most flavors of UNIX. Most of the principles
    this book covers apply equally well to scripting with other shells, such as the
    *Korn Shell*, from which Bash derives some of its features, [[4]](#FTN.AEN147)
    and the *C Shell* and its variants. (Note that *C Shell* programming is not recommended
    due to certain inherent problems, as pointed out in an October, 1993 [Usenet post](http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/)
    by Tom Christiansen.)
  prefs: []
  type: TYPE_NORMAL
- en: What follows is a tutorial on shell scripting. It relies heavily on examples
    to illustrate various features of the shell. The example scripts work -- they've
    been tested, insofar as possible -- and some of them are even useful in real life.
    The reader can play with the actual working code of the examples in the source
    archive (`scriptname.sh` or `scriptname.bash`), [[5]](#FTN.AEN157) give them *execute*
    permission (`**chmod u+rx scriptname**`), then run them to see what happens. Should
    the [source archive](http://bash.deta.in/abs-guide-latest.tar.bz2) not be available,
    then cut-and-paste from the [HTML](http://www.tldp.org/LDP/abs/abs-guide.html.tar.gz)
    or [pdf](http://bash.deta.in/abs-guide.pdf) rendered versions. Be aware that some
    of the scripts presented here introduce features before they are explained, and
    this may require the reader to temporarily skip ahead for enlightenment.
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise noted, [the author](mailto:thegrendel.abs@gmail.com) of this
    book wrote the example scripts that follow.
  prefs: []
  type: TYPE_NORMAL
- en: '|   |  **His countenance was bold and bashed not.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*--Edmund Spenser**  |'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [[1]](why-shell.html#AEN62) | These are referred to as [builtins](internal.html#BUILTINREF),
    features internal to the shell. |'
  prefs: []
  type: TYPE_TB
- en: '| [[2]](why-shell.html#AEN87) | Although [recursion *is* possible in a shell
    script](localvar.html#RECURSIONREF0), it tends to be slow and its implementation
    is often an [ugly kludge](recurnolocvar.html#FIBOREF). |'
  prefs: []
  type: TYPE_TB
- en: '| [[3]](why-shell.html#AEN139) | An *acronym* is an *ersatz* word formed by
    pasting together the initial letters of the words into a tongue-tripping phrase.
    This morally corrupt and pernicious practice deserves appropriately severe punishment.
    Public flogging suggests itself. |'
  prefs: []
  type: TYPE_TB
- en: '| [[4]](why-shell.html#AEN147) | Many of the features of *ksh88*, and even
    a few from the updated *ksh93* have been merged into Bash. |'
  prefs: []
  type: TYPE_TB
- en: '| [[5]](why-shell.html#AEN157) | By convention, user-written shell scripts
    that are Bourne shell compliant generally take a name with a `.sh` extension.
    System scripts, such as those found in `/etc/rc.d`, do not necessarily conform
    to this nomenclature. |'
  prefs: []
  type: TYPE_TB
