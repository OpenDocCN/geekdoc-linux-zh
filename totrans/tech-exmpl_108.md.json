["```go\ntype iPoolObject interface {\n    getID() string\n    doSomething()\n}\n```", "```go\ntype dbconnection struct {\n    id string\n}\n\nfunc (c *dbconnection) getID() string \n\nfunc (c *dbconnection) doSomething()\n```", "```go\ntype pool struct {\n    idle   []iPoolObject\n    active []iPoolObject\n    capacity int\n    mulock   *sync.Mutex\n}\n\n//InitPool Initialize the pool\nfunc initPool(poolObjects []iPoolObject) (*pool, error) {}\n\nfunc (p *pool) loan() (iPoolObject, error) {}\n\nfunc (p *pool) receive(target iPoolObject) error {}\n\nfunc (p *pool) remove(target iPoolObject) error {}\n\nfunc (p *pool) setMaxCapacity(capacity int){}\n```", "```go\ntype client struct {\n    pool *pool\n}\n\nfunc (c *client) init() {}\n\nfunc (c *client) doWork() {} \n```", "```go\npackage main\n\ntype iPoolObject interface {\n\tgetID() string //This is any id which can be used to compare two different pool objects\n\tdoSomething()\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype dbconnection struct {\n\tid string\n}\n\nfunc (c *dbconnection) getID() string {\n\treturn c.id\n}\n\nfunc (c *dbconnection) doSomething() {\n\tfmt.Printf(\"Connection with id %s in action\\n\", c.getID())\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype pool struct {\n\tidle     []iPoolObject\n\tactive   []iPoolObject\n\tcapacity int\n\tmulock   *sync.Mutex\n}\n\n//InitPool Initialize the pool\nfunc initPool(poolObjects []iPoolObject) (*pool, error) {\n\tif len(poolObjects) == 0 {\n\t\treturn nil, fmt.Errorf(\"Cannot craete a pool of 0 length\")\n\t}\n\tactive := make([]iPoolObject, 0)\n\tpool := &pool{\n\t\tidle:     poolObjects,\n\t\tactive:   active,\n\t\tcapacity: len(poolObjects),\n\t\tmulock:   new(sync.Mutex),\n\t}\n\treturn pool, nil\n}\n\nfunc (p *pool) loan() (iPoolObject, error) {\n\tp.mulock.Lock()\n\tdefer p.mulock.Unlock()\n\tif len(p.idle) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pool object free. Please request after sometime\")\n\t}\n\tobj := p.idle[0]\n\tp.idle = p.idle[1:]\n\tp.active = append(p.active, obj)\n\tfmt.Printf(\"Loan Pool Object with ID: %s\\n\", obj.getID())\n\treturn obj, nil\n}\n\nfunc (p *pool) receive(target iPoolObject) error {\n\tp.mulock.Lock()\n\tdefer p.mulock.Unlock()\n\terr := p.remove(target)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.idle = append(p.idle, target)\n\tfmt.Printf(\"Return Pool Object with ID: %s\\n\", target.getID())\n\treturn nil\n}\n\nfunc (p *pool) remove(target iPoolObject) error {\n\tcurrentActiveLength := len(p.active)\n\tfor i, obj := range p.active {\n\t\tif obj.getID() == target.getID() {\n\t\t\tp.active[currentActiveLength-1], p.active[i] = p.active[i], p.active[currentActiveLength-1]\n\t\t\tp.active = p.active[:currentActiveLength-1]\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"Targe pool object doesn't belong to the pool\")\n}\n\nfunc (p *pool) setMaxCapacity(capacity int) {\n\tp.capacity = capacity\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strconv\"\n)\n\ntype client struct {\n\tpool *pool\n}\n\nfunc (c *client) init() {\n\tconnections := make([]iPoolObject, 0)\n\tfor i := 0; i < 3; i++ {\n\t\tc := &dbconnection{id: strconv.Itoa(i)}\n\t\tconnections = append(connections, c)\n\t}\n\tvar err error\n\tc.pool, err = initPool(connections)\n\tif err != nil {\n\t\tlog.Fatalf(\"Init Pool Error: %s\", err)\n\t}\n}\n\nfunc (c *client) doWork() {\n\tfmt.Printf(\"Capacity: %d\\n\\n\", c.pool.capacity)\n\n\tconn1, err := c.pool.loan()\n\tif err != nil {\n\t\tlog.Fatalf(\"Pool Loan Error: %s\", err)\n\t}\n\tconn1.doSomething()\n\n\tfmt.Printf(\"InUse: %d\\n\\n\", c.pool.inUse)\n\tconn2, err := c.pool.loan()\n\tif err != nil {\n\t\tlog.Fatalf(\"Pool Loan Error: %s\", err)\n\t}\n\tconn2.doSomething()\n\tfmt.Printf(\"InUse: %d\\n\\n\", c.pool.inUse)\n\n\tc.pool.receive(conn1)\n\tfmt.Printf(\"InUse: %d\\n\\n\", c.pool.inUse)\n\n\tc.pool.receive(conn2)\n\tfmt.Printf(\"InUse: %d\\n\", c.pool.inUse)\n}\n```", "```go\npackage main\n\nfunc main() {\n    client := &client{}\n    client.init()\n    client.doWork()\n}\n```", "```go\nCapacity: 3\n\nLoan Pool Object with ID: 0\nConnection with id 0 in action\nInUse: 1\n\nLoan Pool Object with ID: 1\nConnection with id 1 in action\nInUse: 2\n\nReturn Pool Object with ID: 0\nInUse: 1\n\nReturn Pool Object with ID: 1\nInUse: 0\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strconv\"\n\t\"sync\"\n)\n\ntype pool struct {\n\tidle     []iPoolObject\n\tactive   []iPoolObject\n\tcapacity int\n\tinUse    int\n\tmulock   *sync.Mutex\n}\n\n//InitPool Initialize the pool\nfunc initPool(poolObjects []iPoolObject) (*pool, error) {\n\tif len(poolObjects) == 0 {\n\t\treturn nil, fmt.Errorf(\"Cannot craete a pool of 0 length\")\n\t}\n\tactive := make([]iPoolObject, 0)\n\tpool := &pool{\n\t\tidle:     poolObjects,\n\t\tactive:   active,\n\t\tcapacity: len(poolObjects),\n\t\tmulock:   new(sync.Mutex),\n\t}\n\treturn pool, nil\n}\n\nfunc (p *pool) loan() (iPoolObject, error) {\n\tp.mulock.Lock()\n\tdefer p.mulock.Unlock()\n\tif len(p.idle) == 0 {\n\t\treturn nil, fmt.Errorf(\"No pool object free. Please request after sometime\")\n\t}\n\tobj := p.idle[0]\n\tp.idle = p.idle[1:]\n\tp.active = append(p.active, obj)\n\tp.inUse = p.inUse + 1\n\tfmt.Printf(\"Loan Pool Object with ID: %s\\n\", obj.getID())\n\treturn obj, nil\n}\n\nfunc (p *pool) receive(target iPoolObject) error {\n\tp.mulock.Lock()\n\tdefer p.mulock.Unlock()\n\terr := p.remove(target)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.idle = append(p.idle, target)\n\tp.inUse = p.inUse - 1\n\tfmt.Printf(\"Return Pool Object with ID: %s\\n\", target.getID())\n\treturn nil\n}\n\nfunc (p *pool) remove(target iPoolObject) error {\n\tcurrentActiveLength := len(p.active)\n\tfor i, obj := range p.active {\n\t\tif obj.getID() == target.getID() {\n\t\t\tp.active[currentActiveLength-1], p.active[i] = p.active[i], p.active[currentActiveLength-1]\n\t\t\tp.active = p.active[:currentActiveLength-1]\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"Targe pool object doesn't belong to the pool\")\n}\n\nfunc (p *pool) setMaxCapacity(capacity int) {\n\tp.capacity = capacity\n}\n\ntype iPoolObject interface {\n\tgetID() string //This is any id which can be used to compare two different pool objects\n\tdoSomething()\n}\n\ntype dbconnection struct {\n\tid string\n}\n\nfunc (c *dbconnection) getID() string {\n\treturn c.id\n}\n\nfunc (c *dbconnection) doSomething() {\n\tfmt.Printf(\"Connection with id %s in action\\n\", c.getID())\n}\n\ntype client struct {\n\tpool *pool\n}\n\nfunc (c *client) init() {\n\tconnections := make([]iPoolObject, 0)\n\tfor i := 0; i < 3; i++ {\n\t\tc := &dbconnection{id: strconv.Itoa(i)}\n\t\tconnections = append(connections, c)\n\t}\n\tvar err error\n\tc.pool, err = initPool(connections)\n\tif err != nil {\n\t\tlog.Fatalf(\"Init Pool Error: %s\", err)\n\t}\n}\n\nfunc (c *client) doWork() {\n\tfmt.Printf(\"Capacity: %d\\n\\n\", c.pool.capacity)\n\n\tconn1, err := c.pool.loan()\n\tif err != nil {\n\t\tlog.Fatalf(\"Pool Loan Error: %s\", err)\n\t}\n\tconn1.doSomething()\n\n\tfmt.Printf(\"InUse: %d\\n\\n\", c.pool.inUse)\n\tconn2, err := c.pool.loan()\n\tif err != nil {\n\t\tlog.Fatalf(\"Pool Loan Error: %s\", err)\n\t}\n\tconn2.doSomething()\n\tfmt.Printf(\"InUse: %d\\n\\n\", c.pool.inUse)\n\n\tc.pool.receive(conn1)\n\tfmt.Printf(\"InUse: %d\\n\\n\", c.pool.inUse)\n\n\tc.pool.receive(conn2)\n\tfmt.Printf(\"InUse: %d\\n\", c.pool.inUse)\n}\n\nfunc main() {\n\tclient := &client{}\n\tclient.init()\n\tclient.doWork()\n}\n```", "```go\nCapacity: 3\n\nLoan Pool Object with ID: 0\nConnection with id 0 in action\nInUse: 1\n\nLoan Pool Object with ID: 1\nConnection with id 1 in action\nInUse: 2\n\nReturn Pool Object with ID: 0\nInUse: 1\n\nReturn Pool Object with ID: 1\nInUse: 0\n```"]