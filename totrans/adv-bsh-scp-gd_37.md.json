["```sh #!/bin/bash\n# ex74.sh\n\n# This is a buggy script.\n# Where, oh where is the error?\n\na=37\n\nif [$a -gt 27 ]\nthen\n  echo $a\nfi  \n\nexit $?   # 0! Why?\n```", "```sh ./ex74.sh: [37: command not found\n```", "```sh #!/bin/bash\n# missing-keyword.sh\n# What error message will this script generate? And why?\n\nfor a in 1 2 3\ndo\n  echo \"$a\"\n# done     # Required keyword 'done' commented out in line 8.\n\nexit 0     # Will not exit here!\n\n# === #\n\n# From command line, after script terminates:\n  echo $?    # 2\n```", "```sh missing-keyword.sh: line 10: syntax error: unexpected end of file\n\n```", "```sh #!/bin/bash\n\n#  This script is supposed to delete all filenames in current directory\n#+ containing embedded spaces.\n#  It doesn't work.\n#  Why not?\n\nbadname=`ls &#124; grep ' '`\n\n# Try this:\n# echo \"$badname\"\n\nrm \"$badname\"\n\nexit 0\n```", "```sh # Correct methods of deleting filenames containing spaces.\nrm *\\ *\nrm *\" \"*\nrm *' '*\n# Thank you. S.C.\n```", "```sh ### debecho (debug-echo), by Stefano Falsetto ###\n    ### Will echo passed parameters only if DEBUG is set to a value. ###\n    debecho () {\n      if [ ! -z \"$DEBUG\" ]; then\n         echo \"$1\" >&2\n         #         ^^^ to stderr\n      fi\n    }\n\n    DEBUG=on\n    Whatever=whatnot\n    debecho $Whatever   # whatnot\n\n    DEBUG=\n    Whatever=notwhat\n    debecho $Whatever   # (Will not echo.)\n    ```", "```sh set -u   # Or   set -o nounset\n\n    # Setting a variable to null will not trigger the error/abort.\n    # unset_var=\n\n    echo $unset_var   # Unset (and undeclared) variable.\n\n    echo \"Should not echo!\"\n\n    # sh t2.sh\n    # t2.sh: line 6: unset_var: unbound variable\n    ```", "```sh #!/bin/bash\n    # assert.sh\n\n    #######################################################################\n    assert ()                 #  If condition false,\n    {                         #+ exit from script\n                              #+ with appropriate error message.\n      E_PARAM_ERR=98\n      E_ASSERT_FAILED=99\n\n      if [ -z \"$2\" ]          #  Not enough parameters passed\n      then                    #+ to assert() function.\n        return $E_PARAM_ERR   #  No damage done.\n      fi\n\n      lineno=$2\n\n      if [ ! $1 ] \n      then\n        echo \"Assertion failed:  \\\"$1\\\"\"\n        echo \"File \\\"$0\\\", line $lineno\"    # Give name of file and line number.\n        exit $E_ASSERT_FAILED\n      # else\n      #   return\n      #   and continue executing the script.\n      fi  \n    } # Insert a similar assert() function into a script you need to debug.    \n    #######################################################################\n\n    a=5\n    b=4\n    condition=\"$a -lt $b\"     #  Error message and exit from script.\n                              #  Try setting \"condition\" to something else\n                              #+ and see what happens.\n\n    assert \"$condition\" $LINENO\n    # The remainder of the script executes only if the \"assert\" does not fail.\n\n    # Some commands.\n    # Some more commands . . .\n    echo \"This statement echoes only if the \\\"assert\\\" does not fail.\"\n    # . . .\n    # More commands . . .\n\n    exit $?\n    ```", "```sh trap '' 2\n# Ignore interrupt 2 (Control-C), with no action specified. \n\ntrap 'echo \"Control-C disabled.\"' 2\n# Message when Control-C pressed.\n```", "```sh #!/bin/bash\n# Hunting variables with a trap.\n\ntrap 'echo Variable Listing --- a = $a  b = $b' EXIT\n#  EXIT is the name of the signal generated upon exit from a script.\n#\n#  The command specified by the \"trap\" doesn't execute until\n#+ the appropriate signal is sent.\n\necho \"This prints before the \\\"trap\\\" --\"\necho \"even though the script sees the \\\"trap\\\" first.\"\necho\n\na=39\n\nb=36\n\nexit 0\n#  Note that commenting out the 'exit' command makes no difference,\n#+ since the script exits in any case after running out of commands.\n```", "```sh #!/bin/bash\n# logon.sh: A quick 'n dirty script to check whether you are on-line yet.\n\numask 177  # Make sure temp files are not world readable.\n\nTRUE=1\nLOGFILE=/var/log/messages\n#  Note that $LOGFILE must be readable\n#+ (as root, chmod 644 /var/log/messages).\nTEMPFILE=temp.$$\n#  Create a \"unique\" temp file name, using process id of the script.\n#     Using 'mktemp' is an alternative.\n#     For example:\n#     TEMPFILE=`mktemp temp.XXXXXX`\nKEYWORD=address\n#  At logon, the line \"remote IP address xxx.xxx.xxx.xxx\"\n#                      appended to /var/log/messages.\nONLINE=22\nUSER_INTERRUPT=13\nCHECK_LINES=100\n#  How many lines in log file to check.\n\ntrap 'rm -f $TEMPFILE; exit $USER_INTERRUPT' TERM INT\n#  Cleans up the temp file if script interrupted by control-c.\n\necho\n\nwhile [ $TRUE ]  #Endless loop.\ndo\n  tail -n $CHECK_LINES $LOGFILE> $TEMPFILE\n  #  Saves last 100 lines of system log file as temp file.\n  #  Necessary, since newer kernels generate many log messages at log on.\n  search=`grep $KEYWORD $TEMPFILE`\n  #  Checks for presence of the \"IP address\" phrase,\n  #+ indicating a successful logon.\n\n  if [ ! -z \"$search\" ] #  Quotes necessary because of possible spaces.\n  then\n     echo \"On-line\"\n     rm -f $TEMPFILE    #  Clean up temp file.\n     exit $ONLINE\n  else\n     echo -n \".\"        #  The -n option to echo suppresses newline,\n                        #+ so you get continuous rows of dots.\n  fi\n\n  sleep 1  \ndone  \n\n#  Note: if you change the KEYWORD variable to \"Exit\",\n#+ this script can be used while on-line\n#+ to check for an unexpected logoff.\n\n# Exercise: Change the script, per the above note,\n#           and prettify it.\n\nexit 0\n\n# Nick Drage suggests an alternate method:\n\nwhile true\n  do ifconfig ppp0 &#124; grep UP 1> /dev/null && echo \"connected\" && exit 0\n  echo -n \".\"   # Prints dots (.....) until connected.\n  sleep 2\ndone\n\n# Problem: Hitting Control-C to terminate this process may be insufficient.\n#+         (Dots may keep on echoing.)\n# Exercise: Fix this.\n\n# Stephane Chazelas has yet another alternative:\n\nCHECK_INTERVAL=1\n\nwhile ! tail -n 1 \"$LOGFILE\" &#124; grep -q \"$KEYWORD\"\ndo echo -n .\n   sleep $CHECK_INTERVAL\ndone\necho \"On-line\"\n\n# Exercise: Discuss the relative strengths and weaknesses\n#           of each of these various approaches.\n```", "```sh #! /bin/bash\n# progress-bar2.sh\n# Author: Graham Ewart (with reformatting by ABS Guide author).\n# Used in ABS Guide with permission (thanks!).\n\n# Invoke this script with bash. It doesn't work with sh.\n\ninterval=1\nlong_interval=10\n\n{\n     trap \"exit\" SIGUSR1\n     sleep $interval; sleep $interval\n     while true\n     do\n       echo -n '.'     # Use dots.\n       sleep $interval\n     done; } &         # Start a progress bar as a background process.\n\npid=$!\ntrap \"echo !; kill -USR1 $pid; wait $pid\"  EXIT        # To handle ^C.\n\necho -n 'Long-running process '\nsleep $long_interval\necho ' Finished!'\n\nkill -USR1 $pid\nwait $pid              # Stop the progress bar.\ntrap EXIT\n\nexit $?\n```", "```sh #!/bin/bash\n\ntrap 'echo \"VARIABLE-TRACE> \\$variable = \\\"$variable\\\"\"' DEBUG\n# Echoes the value of $variable after every command.\n\nvariable=29; line=$LINENO\n\necho \"  Just initialized \\$variable to $variable in line number $line.\"\n\nlet \"variable *= 3\"; line=$LINENO\necho \"  Just multiplied \\$variable by 3 in line number $line.\"\n\nexit 0\n\n#  The \"trap 'command1 . . . command2 . . .' DEBUG\" construct is\n#+ more appropriate in the context of a complex script,\n#+ where inserting multiple \"echo $variable\" statements might be\n#+ awkward and time-consuming.\n\n# Thanks, Stephane Chazelas for the pointer.\n\nOutput of script:\n\nVARIABLE-TRACE> $variable = \"\"\nVARIABLE-TRACE> $variable = \"29\"\n  Just initialized $variable to 29.\nVARIABLE-TRACE> $variable = \"29\"\nVARIABLE-TRACE> $variable = \"87\"\n  Just multiplied $variable by 3.\nVARIABLE-TRACE> $variable = \"87\"\n```", "```sh #!/bin/bash\n# parent.sh\n# Running multiple processes on an SMP box.\n# Author: Tedman Eng\n\n#  This is the first of two scripts,\n#+ both of which must be present in the current working directory.\n\nLIMIT=$1         # Total number of process to start\nNUMPROC=4        # Number of concurrent threads (forks?)\nPROCID=1         # Starting Process ID\necho \"My PID is $$\"\n\nfunction start_thread() {\n        if [ $PROCID -le $LIMIT ] ; then\n                ./child.sh $PROCID&\n                let \"PROCID++\"\n        else\n           echo \"Limit reached.\"\n           wait\n           exit\n        fi\n}\n\nwhile [ \"$NUMPROC\" -gt 0 ]; do\n        start_thread;\n        let \"NUMPROC--\"\ndone\n\nwhile true\ndo\n\ntrap \"start_thread\" SIGRTMIN\n\ndone\n\nexit 0\n\n# ======== Second script follows ========\n\n#!/bin/bash\n# child.sh\n# Running multiple processes on an SMP box.\n# This script is called by parent.sh.\n# Author: Tedman Eng\n\ntemp=$RANDOM\nindex=$1\nshift\nlet \"temp %= 5\"\nlet \"temp += 4\"\necho \"Starting $index  Time:$temp\" \"$@\"\nsleep ${temp}\necho \"Ending $index\"\nkill -s SIGRTMIN $PPID\n\nexit 0\n\n# ======================= SCRIPT AUTHOR'S NOTES ======================= #\n#  It's not completely bug free.\n#  I ran it with limit = 500 and after the first few hundred iterations,\n#+ one of the concurrent threads disappeared!\n#  Not sure if this is collisions from trap signals or something else.\n#  Once the trap is received, there's a brief moment while executing the\n#+ trap handler but before the next trap is set.  During this time, it may\n#+ be possible to miss a trap signal, thus miss spawning a child process.\n\n#  No doubt someone may spot the bug and will be writing \n#+ . . . in the future.\n\n# ===================================================================== #\n\n# ----------------------------------------------------------------------#\n\n#################################################################\n# The following is the original script written by Vernia Damiano.\n# Unfortunately, it doesn't work properly.\n#################################################################\n\n#!/bin/bash\n\n#  Must call script with at least one integer parameter\n#+ (number of concurrent processes).\n#  All other parameters are passed through to the processes started.\n\nINDICE=8        # Total number of process to start\nTEMPO=5         # Maximum sleep time per process\nE_BADARGS=65    # No arg(s) passed to script.\n\nif [ $# -eq 0 ] # Check for at least one argument passed to script.\nthen\n  echo \"Usage: `basename $0` number_of_processes [passed params]\"\n  exit $E_BADARGS\nfi\n\nNUMPROC=$1              # Number of concurrent process\nshift\nPARAMETRI=( \"$@\" )      # Parameters of each process\n\nfunction avvia() {\n         local temp\n         local index\n         temp=$RANDOM\n         index=$1\n         shift\n         let \"temp %= $TEMPO\"\n         let \"temp += 1\"\n         echo \"Starting $index Time:$temp\" \"$@\"\n         sleep ${temp}\n         echo \"Ending $index\"\n         kill -s SIGRTMIN $$\n}\n\nfunction parti() {\n         if [ $INDICE -gt 0 ] ; then\n              avvia $INDICE \"${PARAMETRI[@]}\" &\n                let \"INDICE--\"\n         else\n                trap : SIGRTMIN\n         fi\n}\n\ntrap parti SIGRTMIN\n\nwhile [ \"$NUMPROC\" -gt 0 ]; do\n         parti;\n         let \"NUMPROC--\"\ndone\n\nwait\ntrap - SIGRTMIN\n\nexit $?\n\n: <<SCRIPT_AUTHOR_COMMENTS\nI had the need to run a program, with specified options, on a number of\ndifferent files, using a SMP machine. So I thought [I'd] keep running\na specified number of processes and start a new one each time . . . one\nof these terminates.\n\nThe \"wait\" instruction does not help, since it waits for a given process\nor *all* process started in background. So I wrote [this] bash script\nthat can do the job, using the \"trap\" instruction.\n  --Vernia Damiano\nSCRIPT_AUTHOR_COMMENTS\n```", "```sh \ttrap '' 2  # Signal 2 is Control-C, now disabled.\n\tcommand\n\tcommand\n\tcommand\n\ttrap 2     # Reenables Control-C\n\n```"]