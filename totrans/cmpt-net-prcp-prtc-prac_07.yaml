- en: QUIC#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QUIC#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/quic.html](https://4ed.computer-networking.info/syllabus/default/hosts/quic.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/quic.html](https://4ed.computer-networking.info/syllabus/default/hosts/quic.html)
- en: 'QUIC [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) is
    the latest transport protocol standardized by the IETF. There are several characteristics
    that distinguish QUIC from other transport protocols:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 是 IETF
    标准化的最新传输协议。QUIC 与其他传输协议（如运行在 IP 之上的 TCP、SCTP 或 DCCP）相比，具有以下几个显著特点：
- en: QUIC supports multiple byte streams like SCTP
  id: totrans-3
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: QUIC 支持多个字节流，如 SCTP
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: QUIC includes various reliability and congestion control mechanisms like TCP
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: QUIC 包含了各种可靠性和拥塞控制机制，如 TCP
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: QUIC directly integrates the security features of TLS 1.3 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)
    instead of simply layering TLS above the transport layer
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: QUIC 直接集成了 TLS 1.3 的安全特性 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)，而不是简单地在上层传输层之上叠加
    TLS
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: QUIC can also be used to carry datagrams [**RFC 9221**](https://datatracker.ietf.org/doc/html/rfc9221.html)
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: QUIC 也可以用来携带数据报 [**RFC 9221**](https://datatracker.ietf.org/doc/html/rfc9221.html)
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: QUIC runs above UDP in contrast with other transport protocols such as TCP,
    SCTP or DCCP that run above IP
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与运行在 IP 之上的其他传输协议（如 TCP、SCTP 或 DCCP）不同，QUIC 在 UDP 之上运行
- en: From a pure layering viewpoint, QUIC can be illustrated as shown in [Fig. 84](#fig-quic-layers).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的分层角度来看，QUIC 可以如图 84 所示 [图 84](#fig-quic-layers) 展示。
- en: '![Figure made with TikZ](../Images/a5847b136176a686e0b1c30e9e363f86.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/a5847b136176a686e0b1c30e9e363f86.png)'
- en: Fig. 84 QUIC in the TCP/IP stack
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 84 QUIC 在 TCP/IP 堆栈中的位置
- en: It is unusual to layer a transport protocol above another one. QUIC opted for
    this solution for two main reasons. First, on most operating systems, any application
    can directly use UDP without requiring special privileges. This implies that QUIC
    can be implemented as a library which can be included directly inside applications.
    This contrasts with TCP, SCTP or DCCP whose implementations are either part of
    the operating system kernel or need special privileges to send raw packets. The
    second motivation is that UDP (as well as TCP and ICMP) is supported by most middleboxes
    while many of them block transport protocols that were not defined when they were
    designed [[BWFEDG2020]](../bibliography.html#bwfedg2020).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个传输协议之上分层一个传输协议是不寻常的。QUIC 选择这种解决方案主要有两个原因。首先，在大多数操作系统上，任何应用程序都可以直接使用 UDP，而不需要特殊权限。这意味着
    QUIC 可以作为一个库实现，可以直接包含在应用程序中。这与 TCP、SCTP 或 DCCP 的实现形成对比，它们的实现要么是操作系统内核的一部分，要么需要特殊权限来发送原始数据包。第二个动机是
    UDP（以及 TCP 和 ICMP）被大多数中间盒支持，而其中许多中间盒阻止了在设计时未定义的传输协议 [[BWFEDG2020]](../bibliography.html#bwfedg2020)。
- en: It is useful to note that by using UDP, QUIC slightly increases its overhead.
    Each QUIC packet carries 8 bytes of headers containing the source and destination
    ports, the length field and a checksum. UDP also comes with a performance penalty
    compared to TCP. During the last decades, operating system kernels have been optimized
    to provide high bandwidth using TCP with techniques such as TCP Segmentation Offload
    (TSO) and Generic Receive Offload (GRO). In parallel, the UDP implementation has
    not changed significantly and most of the optimizations focused on request-response
    services such as DNS servers. The situation has changed recently with some effort,
    notably on Linux, to improve UDP’s raw throughput [[DD2018]](../bibliography.html#dd2018).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要注意的是，使用 UDP，QUIC 稍微增加了其开销。每个 QUIC 数据包携带 8 字节的首部，包含源和目的端口、长度字段和校验和。与 TCP 相比，UDP
    也带来了性能上的惩罚。在过去几十年中，操作系统内核已经通过 TCP 分段卸载（TSO）和通用接收卸载（GRO）等技术进行了优化，以提供高带宽。同时，UDP
    的实现没有发生显著变化，大多数优化集中在请求-响应服务（如 DNS 服务器）上。最近，一些努力（特别是在 Linux 上）已经改变了这种状况，旨在提高 UDP
    的原始吞吐量 [[DD2018]](../bibliography.html#dd2018)。
- en: Frames and packets[#](#frames-and-packets "Link to this heading")
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧和包[#](#frames-and-packets "链接到这个标题")
- en: There is an important difference between QUIC and classical protocols like TCP
    or UDP. TCP and UDP send segments that are composed of a header followed by a
    sequence of bytes that constitutes the payload. In contrast and like SCTP, a QUIC
    packet contains a header followed by one or more frames. The QUIC header is much
    simpler and shorter than the TCP header. It only carries the information which
    is required in all QUIC packets. We will describe later the short and long QUIC
    headers. Each QUIC header starts with one byte that contains some flags and a
    32 bits version field. QUIC defines different types of frames that we will discuss
    in this chapter. Some types of QUIC frames carry user data. Other types of QUIC
    frames carry control information. Some of these frames are used during the handshake
    only while others such as acknowledgments can be sent at any time. Each QUIC frame
    is a sequence of byte that starts with a one byte Type field. [Fig. 85](#fig-quic-packet)
    shows a QUIC packet containing two frames which is placed inside a UDP datagram.
    Neither the QUIC header nor the QUIC frames need to be aligned on 32 bits boundaries
    even if this alignment is convenient for [Fig. 85](#fig-quic-packet). An important
    point to note is that a QUIC packet can mix both data and control frames in any
    order.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 与经典协议（如 TCP 或 UDP）之间存在一个重要的区别。TCP 和 UDP 发送由头部和随后的字节序列组成的段，这些字节序列构成了有效载荷。相比之下，类似于
    SCTP，一个 QUIC 数据包包含一个头部，后面跟着一个或多个帧。QUIC 头部比 TCP 头部简单得多，也更短。它只携带所有 QUIC 数据包所需的信息。我们将在后面描述短和长
    QUIC 头部。每个 QUIC 头部都以一个包含一些标志和一个 32 位版本字段的 1 字节类型字段开始。QUIC 定义了不同类型的帧，我们将在本章中讨论。某些类型的
    QUIC 帧携带用户数据。其他类型的 QUIC 帧携带控制信息。其中一些帧仅在握手期间使用，而其他帧（如确认）可以在任何时候发送。每个 QUIC 帧是一系列字节，以一个
    1 字节类型字段开始。[图 85](#fig-quic-packet) 显示了一个包含两个帧的 QUIC 数据包，该数据包位于 UDP 数据报内部。即使这种对齐对
    [图 85](#fig-quic-packet) 有利，QUIC 头部或 QUIC 帧也不需要对齐在 32 位边界上。一个需要注意的重要点是，QUIC 数据包可以以任何顺序混合数据和控制帧。
- en: '![Figure made with TikZ](../Images/67f2552f1552b239338ebf98d5fb0e85.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/67f2552f1552b239338ebf98d5fb0e85.png)'
- en: Fig. 85 A QUIC packet is sent inside a UDP datagram and contains one or more
    QUIC frames
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 85 在 UDP 数据报内部发送的 QUIC 数据包包含一个或多个 QUIC 帧
- en: Connection establishment[#](#connection-establishment "Link to this heading")
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接建立[#](#connection-establishment "链接到本标题")
- en: QUIC uses a four-way handshake to create a QUIC connection. [Fig. 86](#fig-quic-handshake)
    describes this handshake. The QUIC handshake has three main purposes. First, it
    allows to negotiate the crypto keys required to both encrypt and authenticate
    the packets that will be sent later on the connection. This is mainly done using
    TLS 1.3 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html). Second,
    it allows to negotiate different options using transport parameters. Third, the
    server can validate that the client can respond to the address used to send the
    initial packet. This validation allows to prevent denial of service attacks using
    spoofed addresses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 使用四次握手来创建 QUIC 连接。[图 86](#fig-quic-handshake) 描述了此握手过程。QUIC 握手有三个主要目的。首先，它允许协商用于加密和验证随后在连接上发送的数据包所需的加密密钥。这主要使用
    TLS 1.3 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。其次，它允许使用传输参数协商不同的选项。第三，服务器可以验证客户端能否响应用于发送初始数据包的地址。这种验证可以防止使用伪造地址的拒绝服务攻击。
- en: '![Figure made with TikZ](../Images/5e44a71ad373032f5a20d036f58c2000.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/5e44a71ad373032f5a20d036f58c2000.png)'
- en: Fig. 86 Simplified QUIC Handshake
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 86 简化的 QUIC 握手
- en: The client sends an `Initial` packet containing a `CRYPTO` frame. This packet
    carries the `TLS Client Hello` and the transport parameters proposed by the client
    for this connection. The server replies with an `Initial` packet containing also
    a `CRYPTO` frame. This one contains the `TLS Server Hello`. It is immediately
    followed by one or more `Handshake` packets containing also a `CRYPTO` frame with
    the `TLS Encrypted Extensions`. The contents of this frame is encrypted using
    the session key derived from the information contained in the `TLS Client Hello`
    and the `TLS Server Hello`. It mainly contains the certificate and the transport
    parameters of the server. This frame can be spread over several QUIC packets.
    The client replies with a `Handshake` packet that contains a `CRYPTO` frame with
    the `TLS Finished` message. The server later confirms the end of the TLS handshake
    by sending a `Handshake_Done` frame.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送一个包含`CRYPTO`帧的`Initial`数据包。此数据包携带客户端为此次连接提出的`TLS Client Hello`和传输参数。服务器以包含`CRYPTO`帧的`Initial`数据包作为回复。这个数据包包含`TLS
    Server Hello`。紧接着是一个或多个包含`TLS Encrypted Extensions`的`Handshake`数据包，这些数据包也包含`CRYPTO`帧。此帧的内容使用从`TLS
    Client Hello`和`TLS Server Hello`中提取的信息派生的会话密钥进行加密。它主要包含服务器的证书和传输参数。此帧可以分布在多个QUIC数据包中。客户端以包含带有`TLS
    Finished`消息的`CRYPTO`帧的`Handshake`数据包作为回复。服务器随后通过发送`Handshake_Done`帧来确认TLS握手的结束。
- en: Before looking at the details of the negotiation of the cryptographic parameters,
    it is interesting to see how QUIC counters denial of service attacks that use
    spoofed addresses. During such attack, host x sends packets using the address
    of host y as their source. The main risk of such attacks is that the server could
    send a large number of packets towards address y although the host owning this
    address did not try to establish a QUIC connection with the server. QUIC prevents
    such attacks by using two distinct techniques. First, and this is unusual for
    transport protocols, the Initial QUIC packet sent by the client is large. The
    first packet sent to create a QUIC connection must contain a UDP payload of at
    least 1200 bytes [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    Such a packet contains a CRYPTO frame has shown in the figure, but also padding
    frames to fill the packet. If an attacker wants to send spoofed packets to initiate
    a connection with a server, it needs to send more than one KByte for each connection
    attempt. This should be compared with the 40 bytes of the TCP and IPv4 headers
    that must be sent to initiate a TCP connection. Another advantage of sending a
    large initial packet, the client can also perform Path MTU discovery and detect
    routers that could fragment the QUIC packets.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看加密参数协商的细节之前，了解QUIC如何抵御使用欺骗地址的拒绝服务攻击是有趣的。在此类攻击期间，主机x使用主机y的地址作为其源地址发送数据包。此类攻击的主要风险是，尽管拥有该地址的宿主机没有尝试与服务器建立QUIC连接，但服务器可能会向地址y发送大量数据包。QUIC通过使用两种不同的技术来防止此类攻击。首先，对于传输协议来说这是不寻常的，客户端发送的初始QUIC数据包很大。创建QUIC连接时发送的第一个数据包必须包含至少1200字节的UDP有效载荷[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。这样的数据包包含一个如图所示的CRYPTO帧，但也包含填充帧以填充数据包。如果攻击者想要发送欺骗数据包以与服务器建立连接，它需要为每个连接尝试发送超过1K字节。这应该与必须发送以初始化TCP连接的TCP和IPv4头部的40字节进行比较。发送大初始数据包的另一个优点是，客户端还可以执行路径MTU发现并检测可能会分片QUIC数据包的路由器。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Address spoofing
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 地址欺骗
- en: In theory, an Internet host should only send packets using its IPv4 and IPv6
    source addresses. In practice, incorrectly configured hosts can use other addresses
    than their assigned one. Furthermore, attackers often change their source address
    to hide some of their activities. A frequent situation are denial of service (DoS)
    attacks. A simple DoS attack is when a host sends a large volume of packets to
    a victim. If the attacker sends these packets using another address than its official
    IP address, it makes it more difficult for the victim to identify the source of
    the attack.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，一个互联网主机应该只使用其IPv4和IPv6源地址发送数据包。在实践中，配置错误的宿主机可能会使用除其分配地址之外的地址。此外，攻击者经常更改其源地址以隐藏其部分活动。一种常见的情况是拒绝服务（DoS）攻击。简单的DoS攻击是指一个宿主机向受害者发送大量数据包。如果攻击者使用除其官方IP地址之外的地址发送这些数据包，那么受害者识别攻击源将变得更加困难。
- en: But there is another category of DoS attack that is more worrisome. If an attacker
    can send a packets using the source address of the victim to a server, the server
    would return a response to the victim. These attackers use Internet servers that
    send a large response, possibly using multiple packets to a single request packet.
    They have exploited protocols such as DNS, NTP or applications such as [memcached](https://www.memcached.org/)
    . The main problem with such attacks is that the server amplifies the volume of
    the attack generated by the clients. As there are very powerful servers on the
    Internet, this can be a huge problem and such attacks have reached volumes of
    hundreds of Gbps. The IETF and network operators have published recommendations
    to configure access networks to block spoofed packets [**RFC 2827**](https://datatracker.ietf.org/doc/html/rfc2827.html).
    Unfortunately, there are still portions of the Internet where attackers can send
    spoofed packets [[LBKKKC2019]](../bibliography.html#lbkkkc2019).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一种更令人担忧的DoS攻击类别。如果攻击者可以使用受害者的源地址向服务器发送数据包，服务器就会向受害者返回响应。这些攻击者使用发送大量响应的互联网服务器，可能使用多个数据包对一个请求数据包进行响应。他们已经利用了DNS、NTP等协议，以及[memcached](https://www.memcached.org/)等应用程序。这类攻击的主要问题是服务器放大了客户端产生的攻击量。由于互联网上有非常强大的服务器，这可能会成为一个大问题，此类攻击的规模已经达到数百Gbps。IETF和网络运营商已经发布了配置接入网络以阻止伪造数据包的建议[**RFC
    2827**](https://datatracker.ietf.org/doc/html/rfc2827.html)。不幸的是，互联网上仍有部分区域，攻击者可以发送伪造的数据包[[LBKKKC2019]](../bibliography.html#lbkkkc2019)。
- en: The second mitigation against denial-of-service attacks using spoofed packets
    operates on the server. When a server receives an initial packet from a client,
    it may respond with an initial packet as shown in [Fig. 86](#fig-quic-handshake).
    This could for example be the case of an enterprise server that receives a request
    from a host of a known enterprise subnet. The server could also want to validate
    the client and verify that the client can receive the packets that it sends. For
    this, it returns a Retry frame and a Token. This token is an opaque field that
    is constructed in a way that makes it easy for the server to validate the subsequent
    client packets and difficult for the client to predict the token that a server
    will create. A possible approach is to compute a secure hash of a message that
    contains the source IP addresses and ports used by the client, a secret value
    only known by the server and possibly some timing information to enable the server
    to ignore older tokens. Faced with the same problem, TCP syn cookies are encoded
    using fewer bits and thus inherently less secure. [Fig. 87](#fig-quic-handshake-retry)
    shows a QUIC handshake that includes a validation of the client address.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种针对使用伪造数据包的拒绝服务攻击的缓解措施是在服务器端进行的。当服务器从客户端接收到一个初始数据包时，它可能会用一个初始数据包进行响应，如图[图86](#fig-quic-handshake)所示。这可能是一个企业服务器从已知企业子网的主机接收请求的情况。服务器也可能想验证客户端并确认客户端可以接收它发送的数据包。为此，它返回一个Retry帧和一个Token。这个Token是一个不透明的字段，其构造方式使得服务器很容易验证后续的客户端数据包，而客户端很难预测服务器将创建的Token。一种可能的方法是计算包含客户端使用的源IP地址和端口号的消息的安全哈希值，这个秘密值只有服务器知道，可能还有一些时间信息，以便服务器能够忽略旧的Token。面对相同的问题，TCP
    syn cookies使用更少的位进行编码，因此本质上更不安全。[图87](#fig-quic-handshake-retry)显示了包含客户端地址验证的QUIC握手。
- en: '![Figure made with TikZ](../Images/c3f57d5ce5702e99d69cee08ac7baddb.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c3f57d5ce5702e99d69cee08ac7baddb.png)'
- en: Fig. 87 Simplified QUIC Handshake with address validation
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图87 简化的带有地址验证的QUIC握手
- en: Address validation improves the resilience of servers against denial of service
    attacks using spoofed addresses, but this comes at the expense of a longer connection
    establishment delay. QUIC version 1 includes several additional techniques to
    reduce the impact of address validation while still preventing denial of service
    attacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 地址验证提高了服务器对使用伪造地址的拒绝服务攻击的弹性，但这也带来了更长的连接建立延迟。QUIC版本1包括几种额外的技术来减少地址验证的影响，同时仍然防止拒绝服务攻击。
- en: Identifying QUIC connections[#](#identifying-quic-connections "Link to this
    heading")
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别QUIC连接[#](#identifying-quic-connections "链接到本标题")
- en: A TCP connection is identified by a four tuple \(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\).
    All packets belonging to a given connection carry this information in their IP
    and TCP headers. As QUIC runs above UDP, a simple approach could have been to
    use the UDP four tuple to identify each QUIC connection. Although simple, this
    solution would have severely restricted the flexibility of QUIC and the scalability
    of QUIC servers. The QUIC designers have opted for locally unique connection identifiers
    (CID) that are selected by the client and the server. These identifiers are placed
    in the QUIC packet headers during the handshake. When sending the Initial packet,
    the client selects a source CID that uniquely identifies the connection on the
    client and a random destination CID. Upon reception of this packet, the server
    selects its own connection identifier. It echoes the client selected CID and returns
    its selected CID. This is illustrated in [Fig. 88](#fig-quic-handshake-cid).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接由一个四元组 \(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\) 来标识。属于给定连接的所有数据包在其IP和TCP头中都携带此信息。由于QUIC在UDP之上运行，一个简单的方法可能是使用UDP四元组来标识每个QUIC连接。虽然简单，但这个解决方案会严重限制QUIC的灵活性和QUIC服务器的可扩展性。QUIC的设计者选择了由客户端和服务器选择的本地唯一连接标识符（CID）。这些标识符在握手过程中放置在QUIC数据包头中。在发送初始数据包时，客户端选择一个源CID，该CID唯一标识客户端上的连接，以及一个随机的目标CID。在接收到此数据包后，服务器选择自己的连接标识符。它回显客户端选择的CID，并返回其选择的CID。这如图[图88](#fig-quic-handshake-cid)所示。
- en: '![Figure made with TikZ](../Images/5c6ab95bb24bea00f667803dec9da315.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/5c6ab95bb24bea00f667803dec9da315.png)'
- en: Fig. 88 Connection identifiers during a simplified QUIC Handshake
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图88 简化QUIC握手过程中的连接标识符
- en: The connection identifiers selected by the client and the server uniquely identify
    the QUIC connection. However, in contrast with TCP and UDP, the two identifiers
    are not present in all packets. Since a host selects a unique identifier for each
    connection, it only needs this identifier to identify a connection to which a
    packet belongs. For this reason, the QUIC packets exchanged on a connection after
    the handshake only contain the destination CID, i.e. the CID selected by the host
    that receives the packet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器选择的连接标识符唯一标识QUIC连接。然而，与TCP和UDP不同，这两个标识符并不出现在所有数据包中。由于主机为每个连接选择一个唯一的标识符，它只需要这个标识符来识别一个数据包所属的连接。因此，握手之后在连接上交换的QUIC数据包只包含目标CID，即接收数据包的主机选择的CID。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Variable length CIDs
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度CIDs
- en: Most transport protocols rely on fixed-length fields because this simplifies
    the parsing of packet headers. For example, the TCP and UDP port numbers are encoded
    as a 16 bits field. However, using fixed-length fields also limits the extensibility
    of the protocol. A TCP server cannot listen to more than \(2^{16}\) different
    ports.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传输协议依赖于固定长度的字段，因为这样可以简化数据包头的解析。例如，TCP和UDP端口号被编码为16位字段。然而，使用固定长度字段也限制了协议的可扩展性。TCP服务器无法监听超过
    \(2^{16}\) 个不同的端口。
- en: QUIC has opted for variable length CIDs to support very different use cases.
    On the server side, the length of the selected connection identifiers will depend
    on the architecture of the server. Large sites might use a load balancer that
    distributes the connections to different physical servers. Such a load-balancer
    can leverage the CID to direct each incoming packet to the server that handles
    this connection. A simple CID would be composed of a server identifier chosen
    by the load balancer, e.g. in the high order bits of the CID, followed by a connection
    identifier selected by the physical server. Other designs are possible, e.g. by
    encrypting the CID to prevent attacks where malicious clients try to target a
    specific server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC选择了可变长度的CIDs来支持非常不同的用例。在服务器端，所选连接标识符的长度将取决于服务器的架构。大型站点可能会使用负载均衡器，将连接分发到不同的物理服务器。这样的负载均衡器可以利用CID将每个传入的数据包直接导向处理该连接的服务器。一个简单的CID将包含由负载均衡器选择的服务器标识符，例如在CID的高位，后面跟着由物理服务器选择的连接标识符。其他设计也是可能的，例如通过加密CID来防止恶意客户端尝试针对特定服务器的攻击。
- en: One the client side, variable lengths CIDs bring another benefit. As clients
    typically manage a small number of QUIC connections, they can simply rely on the
    destination port of the packets that they receive to identify the corresponding
    QUIC connection. This corresponds to a zero-length connection identifier. Such
    a CID is never sent by the server after the handshake. This limits the byte overhead
    of the packets that clients receive.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，可变长度的CID带来另一个好处。由于客户端通常管理少量QUIC连接，它们可以简单地依靠它们接收到的数据包的目标端口来识别相应的QUIC连接。这对应于零长度的连接标识符。这种CID在握手之后永远不会由服务器发送。这限制了客户端接收到的数据包的字节开销。
- en: A last point to note about these CIDs is their encoding inside the QUIC packets.
    The Initial packet contains the length and the value of both connection identifiers.
    The maximum length for a CID is 20 bytes. However, after the handshake, the packets
    that are exchanged over the QUIC connection only contain the destination CID without
    any field indicating its length. The host that has allocated the CID knows the
    length of the CIDs that it uses and can thus parse the packets that it receives
    without an explicit length information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些CID的最后一点是它们在QUIC数据包中的编码。初始数据包包含连接标识符的长度和值。CID的最大长度为20字节。然而，在握手之后，通过QUIC连接交换的数据包只包含目标CID，没有任何字段指示其长度。分配CID的主机知道它使用的CID的长度，因此可以在没有显式长度信息的情况下解析它接收到的数据包。
- en: Security keys[#](#security-keys "Link to this heading")
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全密钥[#](#security-keys "链接到本标题")
- en: We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys
    that are used to authenticate and encrypt the packets exchanged over a connection.
    As shown in [Fig. 86](#fig-quic-handshake), a QUIC connection starts with the
    exchange of four frames which can be carried in four or more packets. The first
    packet sent by the client contains the `ClientHello` TLS record. The `ClientHello`
    contains the information required to derive the session keys using Diffie-Hellman
    or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic
    Curve Diffie-Hellman [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    The `ClientHello` message also contains TLS or QUIC parameters that the client
    proposes to use during the connection. The `TLS Server Hello` returned by the
    server contains the certificate that enables the client to validate the server’s
    identity and the information required to determine the Diffie-Hellman keys. Using
    these keys, the server also encrypts the `TLS Encrypted Extensions` message that
    contains the TLS and QUIC parameters that the server has selected based on the
    ones proposed in the `ClientHello`. The server also constructs the `Finished`
    message that contains a message authentication code computed over the entire TLS
    handshake. This message is encrypted and authenticated using the session keys
    derived from the Diffie-Hellman keys. The client and the server recompute the
    hash of the entire handshake and verify both `Finished` messages. If one of these
    messages is incorrect, this indicates that either the key has not been correctly
    derived or that some of the TLS messages have been tampered. In these situations,
    the QUIC connection is terminated with an error message. The simplified TLS handshake
    used by QUIC is illustrated in [Fig. 89](#fig-quic-tls-handshake). The TLS messages
    shown in italics are encrypted using the session keys.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以讨论QUIC如何利用TLS 1.3协商用于验证和加密连接上交换的数据包的安全密钥。如图[图86](#fig-quic-handshake)所示，QUIC连接从交换四个帧开始，这些帧可以包含在四个或更多的数据包中。客户端发送的第一个数据包包含`ClientHello`
    TLS记录。`ClientHello`包含使用Diffie-Hellman或类似协议推导会话密钥所需的信息。TLS 1.3支持有限域Diffie-Hellman和椭圆曲线Diffie-Hellman
    [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。`ClientHello`消息还包含客户端在连接期间提议使用的TLS或QUIC参数。服务器返回的`TLS
    Server Hello`包含证书，使客户端能够验证服务器的身份以及确定Diffie-Hellman密钥所需的信息。使用这些密钥，服务器还加密了包含服务器根据`ClientHello`中提出的参数选择的TLS和QUIC参数的`TLS
    Encrypted Extensions`消息。服务器还构建了包含整个TLS握手计算的消息认证码的`Finished`消息。此消息使用从Diffie-Hellman密钥推导出的会话密钥加密和验证。客户端和服务器重新计算整个握手的哈希值并验证两个`Finished`消息。如果其中一个消息不正确，这表明密钥没有被正确推导，或者某些TLS消息已被篡改。在这些情况下，QUIC连接将终止并显示错误消息。QUIC使用的简化TLS握手如图[图89](#fig-quic-tls-handshake)所示。以斜体显示的TLS消息使用会话密钥加密。
- en: '![Figure made with TikZ](../Images/68b73d74f409bc3b1f789ac93a363aa3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/68b73d74f409bc3b1f789ac93a363aa3.png)'
- en: Fig. 89 Simplified TLS Handshake within a QUIC connection
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图89：QUIC连接中的简化TLS握手
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Encrypting `TLS Client Hello` and `TLS Server Hello`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加密`TLS客户端问候`和`TLS服务器问候`
- en: 'When TLS 1.3 is used above TCP, the `TLS Client Hello` and `TLS Server Hello`
    messages are sent in clear because the client and the server have not yet exchanged
    the session keys. A similar approach could have been used for QUIC, but there
    was a fear that middleboxes could analyze the contents of these initial QUIC messages
    and try to interfere with them. To add some burden on these middleboxes, QUIC
    encrypts the Initial packets using a secret that is derived from the destination
    connection ID of the client’s first Initial packet. The pseudocode below, extracted
    from [**RFC 9001**](https://datatracker.ietf.org/doc/html/rfc9001.html), shows
    how the client and the server keys are derived:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当TLS 1.3在TCP之上使用时，`TLS客户端问候`和`TLS服务器问候`消息以明文形式发送，因为客户端和服务器尚未交换会话密钥。对于QUIC，也可以采用类似的方法，但担心中间盒可能分析这些初始QUIC消息的内容并试图干扰它们。为了给这些中间盒增加一些负担，QUIC使用从客户端第一个初始数据包的目的连接ID派生出的秘密来加密初始数据包。下面的伪代码，摘自[**RFC
    9001**](https://datatracker.ietf.org/doc/html/rfc9001.html)，展示了客户端和服务器密钥是如何派生的：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since the keys used to protect the Initial packets are derived from the destination
    connection ID, any QUIC implementation, including those used on middleboxes, can
    decrypt the contents of the Initial packets.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用于保护初始数据包的密钥是从目的连接ID派生的，因此任何QUIC实现，包括那些用于中间盒的实现，都可以解密初始数据包的内容。
- en: As mentioned earlier, the client and the server can also use the TLS handshake
    to agree on specific QUIC parameters. These parameters are called transport parameters
    in QUIC [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html). 17
    different transport parameters are defined in QUIC version 1 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    and implementations can define their own transport parameters. We will discuss
    some of them in different sections of this document. A first example is the `max_udp_payload_size`
    parameter that indicates the largest UDP payload that an implementation is willing
    to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations
    used in a datacenter supporting jumbo Ethernet frames could agree on a much larger
    `max_udp_payload_size` without risking packet fragmentation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，客户端和服务器还可以使用TLS握手来就特定的QUIC参数达成一致。这些参数在QUIC中被称为传输参数[**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。在QUIC版本1
    [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)中定义了17个不同的传输参数，实现可以定义自己的传输参数。我们将在本文件的各个部分讨论其中的一些。第一个例子是`max_udp_payload_size`参数，它表示实现愿意接收的最大UDP有效载荷。此参数的最小值是1200字节。在支持巨型以太网帧的数据中心中使用的QUIC实现可以就一个更大的`max_udp_payload_size`达成一致，而不会存在数据包分片的风险。
- en: Another example of QUIC transport parameters are the `initial_source_connection_id`
    and the `original_destination_connection_id` transport parameters. As explained
    above, thanks to the `Finished` messages in the TLS handshake, the client and
    the servers can verify that their messages have not been tampered. Unfortunately,
    the authentication code included in the `Finished` messages is only computed based
    on the contents of the TLS messages (i.e. `ClientHello`, `ServerHello`, `EncryptedExtensions`
    and `Finished`). During the handshake, the client and the servers also propose
    the source and destination connection identifiers that they plan to use to identify
    the QUIC session. These identifiers are placed in the packet header and not inside
    the TLS messages. They are thus not covered by the authentication code included
    in the `Finished` message. To still authenticate these identifiers, QUIC encodes
    them as transport parameters that are included in the `ClientHello` and the `EncryptedExtensions`
    messages. The client copies the source connection identifier in the `initial_source_connection_id`
    transport parameter in its `ClientHello`. The server does the same when sending
    the `ServerHello`. It also copies in the `original_destination_connection_id`
    transport parameter the destination identifier used by the client to send the
    packet containing the `ClientHello`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 传输参数的另一个例子是 `initial_source_connection_id` 和 `original_destination_connection_id`
    传输参数。如上所述，由于 TLS 握手的 `Finished` 消息，客户端和服务器可以验证他们的消息没有被篡改。不幸的是，包含在 `Finished` 消息中的认证代码仅基于
    TLS 消息的内容（即 `ClientHello`、`ServerHello`、`EncryptedExtensions` 和 `Finished`）进行计算。在握手过程中，客户端和服务器还提出了他们计划用于识别
    QUIC 会话的源和目的连接标识符。这些标识符放置在数据包头部，而不是 TLS 消息内部。因此，它们不受 `Finished` 消息中包含的认证代码的保护。为了仍然对这些标识符进行认证，QUIC
    将它们编码为包含在 `ClientHello` 和 `EncryptedExtensions` 消息中的传输参数。客户端将其源连接标识符复制到其 `ClientHello`
    中的 `initial_source_connection_id` 传输参数中。服务器在发送 `ServerHello` 时也这样做。它还在 `original_destination_connection_id`
    传输参数中复制客户端用于发送包含 `ClientHello` 的数据包的目的标识符。
- en: The QUIC packet headers[#](#the-quic-packet-headers "Link to this heading")
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC 数据包头部[#](#the-quic-packet-headers "链接到这个标题")
- en: At this point, the QUIC session and the TLS security keys are known by the client
    and the server. They can start to exchange data. Before looking at how data is
    carried inside QUIC packets, it is interesting to explore in more details the
    packet headers that are placed inside each packet. QUIC uses variable length packet
    headers. Two different header formats exist. The first header format is the long
    header. This is the header used for the first packets of a QUIC connection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，QUIC 会话和 TLS 安全密钥由客户端和服务器所知。它们可以开始交换数据。在查看数据如何在 QUIC 数据包中传输之前，更深入地探索放置在每个数据包内的数据包头部是很有趣的。QUIC
    使用可变长度的数据包头部。存在两种不同的头部格式。第一种头部格式是长头部。这是用于 QUIC 连接的第一个数据包的头部。
- en: Internet protocol specifications usually contain figures to represent the format
    of the packet headers. This graphical format is useful to get a quick grasp at
    a header containing fixed size fields. However, when a header contains several
    variable length fields, the graphical representation can become difficult to follow.
    The QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    uses the textual representation that was also used for the TLS protocol. As an
    example, let us consider the well-known TCP header. This header is graphically
    represented as shown in [Fig. 90](#fig-quic-tcp-header).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议规范通常包含图来表示数据包头部的格式。这种图形格式对于快速掌握包含固定大小字段的头部很有用。然而，当头部包含多个可变长度字段时，图形表示可能变得难以跟随。QUIC
    规范 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 使用了与 TLS
    协议相同的文本表示。作为一个例子，让我们考虑众所周知的 TCP 头部。这个头部如图 90 所示进行图形表示。
- en: '![Figure made with TikZ](../Images/8bbfb429b7a940504df39c6677c533c7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/8bbfb429b7a940504df39c6677c533c7.png)'
- en: Fig. 90 Graphical representation of the TCP header Listing 2 Textual representation
    of the TCP header[#](#fig-quic-tcp-text-header "Link to this code")
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 90 TCP 头部的图形表示 列表 2 TCP 头部的文本表示[#](#fig-quic-tcp-text-header "链接到这段代码")
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The attentive reader will easily understand the correspondence between the two
    formats. When explaining QUIC, we use the textual representation while we stick
    to the graphical one for TCP.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者会很容易理解两种格式之间的对应关系。在解释 QUIC 时，我们使用文本表示，而坚持使用图形表示来表示 TCP。
- en: '[Listing 3](#fig-quic-long-header) shows the QUIC long header. It starts with
    one byte containing the header type in the most significant bit, two bits indicating
    the packet type and four bits that are specific to each packet packet. Then, 32
    bits carry the QUIC version number. The current version of QUIC, defined in [**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html), corresponds to version
    `0x00000001`. The header then contains the destination and source connection identifiers
    that were described previously and then a payload that is specific to each type.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3](#fig-quic-long-header) 展示了 QUIC 长头部。它以一个字节开始，这个字节中最显著的位包含头部类型，接下来是两位表示数据包类型，再接下来是四位，这四位对每个数据包都是特定的。然后，32
    位携带 QUIC 版本号。当前 QUIC 版本，由 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    定义，对应于版本 `0x00000001`。头部接着包含之前描述的目标和源连接标识符，然后是一个针对每种类型的特定有效载荷。'
- en: Listing 3 The QUIC long header[#](#fig-quic-long-header "Link to this code")
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3 QUIC 长头部 [#](#fig-quic-long-header "链接到这段代码")
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Encoding packet numbers
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据包号
- en: Most transport protocols use fixed fields to encode packet numbers or byte offsets.
    The size of this field is always a trade-off. On one hand, a small packet number
    field limits the per packet overhead. On the other hand, a large packet number
    space is required to ensure that two packets carrying different data do not use
    the same packet number. TCP uses a 32 bits sequence number field that indicates
    the position of the first byte of the payload in the bytestream. This 32 bits
    field became a concern as bandwidth increased to Gbps and beyond [**RFC 7323**](https://datatracker.ietf.org/doc/html/rfc7323.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传输协议使用固定字段来编码数据包号或字节偏移。这个字段的大小总是存在权衡。一方面，小的数据包号字段限制了每个数据包的额外开销。另一方面，需要较大的数据包号空间以确保携带不同数据的两个数据包不会使用相同的编号。TCP
    使用一个 32 位的序列号字段，该字段指示有效载荷的第一个字节在字节流中的位置。随着带宽增加到 Gbps 及以上，这个 32 位字段引起了关注 [**RFC
    7323**](https://datatracker.ietf.org/doc/html/rfc7323.html)。
- en: QUIC takes a different approach to sequence numbers. Each packet contains a
    per-packet sequence number. This number is encoded as a variable-length integer
    (`varint`). Such a `varint` has a length encoded in the two most significant bits
    of the first byte. If these bits are set to `00`, then the `varint` is encoded
    in one byte and can contain values between \(0\) and \(2^{6}-1\). If the two most
    significant bits are set to `01`, the `varint` can encode values between \(0\)
    and \(2^{14}-1\) within two bytes. When the two high order bits are set to `11`
    the `varint` can encode values between \(0\) and \(2^{62}-1\) within four bytes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 对序列号采取了不同的方法。每个数据包包含一个针对数据包的序列号。这个数字被编码为一个变长整数 (`varint`)。这样的 `varint`
    在第一个字节的最显著两位中编码了长度。如果这些位被设置为 `00`，则 `varint` 使用一个字节进行编码，可以包含从 \(0\) 到 \(2^{6}-1\)
    的值。如果两位最显著的位被设置为 `01`，则 `varint` 可以在两个字节内编码从 \(0\) 到 \(2^{14}-1\) 的值。当最高两位被设置为
    `11` 时，`varint` 可以在四个字节内编码从 \(0\) 到 \(2^{62}-1\) 的值。
- en: There are other important differences between QUIC and other transport protocols
    when considering packet numbers. First, a QUIC sender must *never* reuse the same
    packet number for two different packets sent over a QUIC connection. If data needs
    to be retransmitted, it will be resent as a frame inside a new packet. Furthermore,
    since the largest possible packet number is \(2^{62}-1\), a QUIC sender must close
    the corresponding connection once it has sent a QUIC packet carrying this packet
    number. This puts a restriction on the duration of QUIC connections. They cannot
    last forever in contrast to TCP connections such as those used to support BGP
    sessions between routers. An application that uses QUIC must be ready to restart
    a connection from time to time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到数据包号，QUIC 与其他传输协议之间存在其他重要差异。首先，QUIC 发送者必须 *永远* 不能为通过 QUIC 连接发送的两个不同数据包重用相同的包号。如果需要重传数据，它将以新数据包中的帧形式重新发送。此外，由于可能的最大包号是
    \(2^{62}-1\)，一旦发送了携带此包号的 QUIC 数据包，QUIC 发送者必须关闭相应的连接。这限制了 QUIC 连接的持续时间。它们不能像支持路由器之间
    BGP 会话的 TCP 连接那样永远存在。使用 QUIC 的应用程序必须随时准备重新启动连接。
- en: This long header is used for the `Initial`, `Handhsake` and `Retry` packets.
    Some of these packet types add new flags in the first byte and additional information
    after the connection identifiers. [Listing 4](#fig-quic-initial-header) shows
    the long header of the `Initial` packet. It contains two bits in the first byte
    that indicate the length of the packet number field. The packet specific part
    contains an option token, a length field, a packet number and a payload. The token
    length, length and packet number are encoded using variable length integers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长头用于 `Initial`、`Handshake` 和 `Retry` 数据包。这些数据包类型中的一些在第一个字节中添加了新的标志，并在连接标识符之后添加了附加信息。[列表
    4](#fig-quic-initial-header) 展示了 `Initial` 数据包的长头。它包含第一个字节中的两个位，指示包号字段长度。数据包特定部分包含一个选项令牌、一个长度字段、一个包号和有效载荷。令牌长度、长度和包号使用可变长度整数进行编码。
- en: Listing 4 The QUIC long header of the Initial packet[#](#fig-quic-initial-header
    "Link to this code")
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4 初始数据包的 QUIC 长头[#](#fig-quic-initial-header "链接到此处代码")
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The QUIC short header contains fewer fields. The most significant bit of the
    first byte is set to 1 to indicate that the packet carries a short header. The
    other flags will be discussed later. The two least significant bits of this byte
    contain the length of the packet number field. It is interesting to note that
    in contrast with the long header, there is no explicit indication of the length
    of the destination connection identifier. This connection identifier has been
    assigned by the host that receives this packet and it already knows the length
    of the connection identifiers that it uses.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 短头包含的字段较少。第一个字节的最显著位被设置为 1，以指示该数据包携带短头。其他标志将在稍后讨论。该字节最低的两个有效位包含包号字段长度。值得注意的是，与长头相比，没有明确指示目标连接标识符长度的信息。此连接标识符已由接收此数据包的主机分配，并且它已经知道它使用的连接标识符的长度。
- en: Listing 5 The QUIC short header used by 1-RTT packets[#](#fig-quic-short-header
    "Link to this code")
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5 1-RTT 数据包使用的 QUIC 短头[#](#fig-quic-short-header "链接到此处代码")
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The short header format, depicted in [Listing 5](#fig-quic-short-header), is
    used by all QUIC packets once the session keys have been derived. This usually
    happens after one round-trip-time. These packets are called the 1-RTT packets
    in the QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    This notation is used to emphasize the fact that QUIC also supports 0-RTT packets,
    i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 短头格式，如 [列表 5](#fig-quic-short-header) 所示，在会话密钥推导后由所有 QUIC 数据包使用。这通常发生在往返一次之后。这些数据包在
    QUIC 规范中被称为 1-RTT 数据包 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。这种表示法用于强调
    QUIC 也支持 0-RTT 数据包，即携带数据并且可以与 TLS 握手并行交换的数据包。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Coalescing packets
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包合并
- en: Besides the connection identifiers, another difference between the short and
    the long headers is the presence of the `Packet Length` field in the long header.
    This field might surprise the reader who is familiar with UDP since UDP also contains
    a Length field. As each QUIC packet is placed inside a UDP message, the QUIC Length
    field could seem redundant. This Length field was included in the QUIC long header
    to allow a QUIC sender to coalesce several consecutive and small packets inside
    a single UDP message. Some of the frames exchanged during the handshake are rather
    small. Sending a UDP message for each of these frames would be a waste of resources.
    Furthermore, a mix of `Initial`, `Handshake` and `0-RTT` packets are exchanged
    when creating a QUIC connection. It would not be wise to require the utilization
    of one UDP message to send each of these packets. You might observe this optimization
    when analyzing packet traces collected on QUIC servers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接标识符之外，短头和长头之间的另一个区别是长头中存在 `Packet Length` 字段。这个字段可能会让熟悉 UDP 的读者感到惊讶，因为 UDP
    也包含长度字段。由于每个 QUIC 数据包都放置在 UDP 消息中，因此 QUIC 长度字段可能看起来是多余的。这个长度字段被包含在 QUIC 长头中，以便允许
    QUIC 发送者将多个连续的小数据包合并到单个 UDP 消息中。在握手过程中交换的一些帧相当小。为每个这些帧发送 UDP 消息将是资源的浪费。此外，在创建
    QUIC 连接时，会交换 `Initial`、`Handshake` 和 `0-RTT` 数据包的混合。要求使用单个 UDP 消息发送这些数据包中的每一个是不明智的。您可能会在分析收集在
    QUIC 服务器上的数据包跟踪时观察到这种优化。
- en: 0-RTT data[#](#rtt-data "Link to this heading")
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 0-RTT 数据[#](#rtt-data "链接到此处标题")
- en: Latency is a key concern for transport protocols. The QUIC/TLS handshake that
    we have described until now allows the client and the server to agree on security
    keys within one round-trip-time. However, one round-trip-time can be a long delay
    for some applications. To minimize the impact of the connection setup time, QUIC
    allows applications to exchange data during the QUIC/TLS handshake. Such data
    is called 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client
    and the server must have previously agreed on a key which can be used to encrypt
    and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared
    key that the client and the server have shared without using the QUIC protocol
    or, and this is the most frequent solution, the key that they negotiated during
    a previous connection. In practice, the server enables 0-RTT by sending a TLS
    session ticket to the client [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    A session ticket is an encrypted record that contains information that enables
    the server to recover all the state information about a session including its
    session keys. It is also linked to the client’s address to enable the server to
    verify that a given client reuses the tickets that it has received earlier. Usually,
    these tickets also contain an expiration date. The client places the received
    ticket in the `TLS CLient Hello` that it sends in the first `Initial` packet.
    It uses the pre-shared key corresponding to this ticket to encrypt data and place
    it in one or more `0-RTT` packets. The server uses the information contained in
    the ticket to recover the key and decrypt the data of the `0-RTT` packet. [Listing
    6](#fig-quic-0-rtt-packet) shows the format of QUIC’s 0-RTT packet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是传输协议的关键关注点。我们至今所描述的 QUIC/TLS 握手允许客户端和服务器在单程往返时间内就安全密钥达成一致。然而，对于某些应用程序来说，单程往返时间可能是一个较长的延迟。为了最小化连接设置时间的影响，QUIC
    允许应用程序在 QUIC/TLS 握手期间交换数据。这种数据称为 0-RTT 数据。为了确保 0-RTT 数据的安全交换，客户端和服务器必须事先就一个可以用来加密和验证
    0-RTT 数据的密钥达成一致。这样的 0-RTT 密钥可以是客户端和服务器在没有使用 QUIC 协议的情况下共享的预共享密钥，或者，这是最常见的方法，是他们在之前连接中协商的密钥。实际上，服务器通过向客户端发送
    TLS 会话票据来启用 0-RTT [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。会话票据是一个包含使服务器能够恢复会话所有状态信息（包括其会话密钥）的加密记录。它还与客户端的地址相关联，以便服务器能够验证给定的客户端是否重复使用它之前收到的票据。通常，这些票据还包含一个过期日期。客户端将收到的票据放入它发送的第一个
    `Initial` 数据包中的 `TLS Client Hello`。它使用与该票据对应的预共享密钥来加密数据并将其放入一个或多个 `0-RTT` 数据包中。服务器使用票据中包含的信息恢复密钥并解密
    `0-RTT` 数据包的数据。[列表 6](#fig-quic-0-rtt-packet "链接到这段代码") 显示了 QUIC 的 0-RTT 数据包格式。
- en: Listing 6 The QUIC 0-RTT packet[#](#fig-quic-0-rtt-packet "Link to this code")
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6 QUIC 0-RTT 数据包[#](#fig-quic-0-rtt-packet "链接到这段代码")
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The main benefit of these `0-RTT` packets is that the client can immediately
    send encrypted data while sending its `Initial` packet. This is illustrated in
    [Fig. 91](#fig-quic-handshake-ortt) where the frames encrypted with the 0-RTT
    keys are shown in italics. Note that some of these frames can span several packets.
    `0-RTT` packets are only sent by the QUIC client since the server can send encrypted
    data immediately after having sent its `Handshake` frames. As explained earlier,
    the Initial packets are also encrypted but using keys derived from the connection
    identifiers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `0-RTT` 数据包的主要好处是客户端可以在发送其 `Initial` 数据包的同时立即发送加密数据。这在 [图 91](#fig-quic-handshake-ortt)
    中得到了说明，其中使用 0-RTT 密钥加密的帧以斜体显示。请注意，其中一些帧可以跨越多个数据包。`0-RTT` 数据包仅由 QUIC 客户端发送，因为服务器可以在发送其
    `Handshake` 数据包后立即发送加密数据。如前所述，初始数据包也是加密的，但使用的是从连接标识符派生的密钥。
- en: '![Figure made with TikZ](../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png)'
- en: Fig. 91 Simplified QUIC Handshake with 0-RTT data
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 91 带有 0-RTT 数据的简化 QUIC 握手
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replay attacks and 0-RTT packets
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重放攻击和 0-RTT 数据包
- en: Thanks to the 0-RTT packets, a client can send encrypted data to the server
    before waiting for the secure handshake. This reduces the latency of the data
    transfer, but with one important caveat. QUIC does not provide any guarantee that
    0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent
    operations. A detailed discussion of the impact of replay attacks may be found
    in [[MacCarthaigh2017]](../bibliography.html#maccarthaigh2017).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了0-RTT数据包，客户端可以在等待安全握手之前将加密数据发送到服务器。这减少了数据传输的延迟，但有一个重要的注意事项。QUIC并不保证0-RTT数据不会被重放。QUIC交换的0-RTT数据旨在用于幂等操作。关于重放攻击影响的具体讨论，可以在[[MacCarthaigh2017]](../bibliography.html#maccarthaigh2017)中找到。
- en: To understand the importance of these replay attacks, let us consider a simple
    HTTP GET request. Such a request could easily fit inside the 0-RTT packet and
    thus have lower latency. If a web browser uses it to request a static `index.html`
    file, there is no harm if the request is received twice by the server. However,
    if the GET request is part of a REST API and has side effects, then problems could
    occur depending on the type of side effect. Consider a REST API that allows a
    user to switch off the lights using his or her smartphone. Replaying this request
    two or three times will always result in the light being switched off. However,
    if the user requests to increase the room temperature by one °C, then multiple
    replays will obviously have different consequences.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些重放攻击的重要性，让我们考虑一个简单的HTTP GET请求。这样的请求可以很容易地放入0-RTT数据包中，从而降低延迟。如果网页浏览器使用它来请求静态的`index.html`文件，如果服务器收到两次请求，则没有害处。然而，如果GET请求是REST
    API的一部分并且有副作用，那么问题可能会根据副作用类型而出现。考虑一个允许用户通过智能手机关闭灯光的REST API。重放这个请求两到三次将始终导致灯光关闭。然而，如果用户请求将室温提高1°C，那么多次重放显然会有不同的后果。
- en: Closing a QUIC connection[#](#closing-a-quic-connection "Link to this heading")
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭QUIC连接[#](#closing-a-quic-connection "链接到这个标题")
- en: Before exploring how data can be exchanged over a QUIC connection, let us now
    analyze how a QUIC connection can terminate. QUIC supports three different methods
    to close a QUIC connection. QUIC’s approach to terminating connection is very
    different from the approaches used by traditional transport protocol. Before looking
    at these techniques, it is important to understand how QUIC interacts with Network
    Address Translation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索如何在QUIC连接上交换数据之前，让我们现在分析QUIC连接是如何终止的。QUIC支持三种不同的方法来关闭QUIC连接。QUIC终止连接的方法与传统传输协议所使用的方法非常不同。在查看这些技术之前，了解QUIC如何与网络地址转换（NAT）交互是非常重要的。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: QUIC and Network Address Translation
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC和网络地址转换
- en: QUIC runs above UDP and the design of QUIC was heavily influenced by the presence
    of NATs. NATs, like other middleboxes, maintain per-flow state. For TCP connections,
    many NATs rely on the `SYN`, `FIN` and `RST` flags to determine when state must
    be created or removed for a TCP connection. For UDP, this stateful approach is
    not possible and NATs create a new mapping when they observe the first packet
    of a flow and remove the mapping once the flow has been idle for sometime. The
    IETF recommends to maintain NAT mappings during at least two minutes [**RFC 4787**](https://datatracker.ietf.org/doc/html/rfc4787.html),
    but measurements show that some deployed NATs use shorter timeouts [[HNESSK2010]](../bibliography.html#hnessk2010)
    [[RWV+2016]](../bibliography.html#rwv-2016). In practice, UDP flows should probably
    send a packet every 30 seconds to ensure that the on-path NATs preserve their
    state.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC在UDP之上运行，QUIC的设计受到了NAT的存在的影响。NAT，就像其他中间盒一样，维护每个流的状态。对于TCP连接，许多NAT依赖于`SYN`、`FIN`和`RST`标志来确定何时为TCP连接创建或删除状态。对于UDP，这种有状态的方法是不可能的，NAT在观察到流的第一包时创建一个新的映射，一旦流空闲一段时间后，就删除该映射。IETF建议至少保持NAT映射两分钟[**RFC
    4787**](https://datatracker.ietf.org/doc/html/rfc4787.html)，但测量表明，一些部署的NAT使用更短的超时[[HNESSK2010]](../bibliography.html#hnessk2010)
    [[RWV+2016]](../bibliography.html#rwv-2016)。在实践中，UDP流可能需要每30秒发送一个数据包，以确保路径上的NAT保留其状态。
- en: To prevent NATs from changing the mapping associated to the IP addresses and
    ports used for a QUIC connection, QUIC hosts will need to regularly send data
    over each established QUIC connection. QUIC defines a `PING` frame that allows
    any QUIC endpoint to send a frame that will trigger a response from the other
    peer. The `PING` frame does not carry data, but the receiver of a `PING` frame
    needs to acknowledge the packet containing this frame. This creates a bidirectional
    communication and can prevent NATs from discarding the mapping associated to the
    QUIC connection.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止NAT更改与用于QUIC连接的IP地址和端口号关联的映射，QUIC主机需要定期通过每个建立的QUIC连接发送数据。QUIC定义了一个`PING`帧，允许任何QUIC端点发送一个将触发另一端响应的帧。`PING`帧不携带数据，但接收`PING`帧的接收方需要确认包含此帧的包。这创建了一个双向通信，可以防止NAT丢弃与QUIC连接关联的映射。
- en: Implicit termination of QUIC connections[#](#implicit-termination-of-quic-connections
    "Link to this heading")
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式终止QUIC连接[#](#implicit-termination-of-quic-connections "链接到本标题")
- en: Each QUIC implementation keeps in its connection state the timestamp of the
    last QUIC packet received over this connection. During the connection establishment,
    the QUIC hosts can also exchange the `max_idle_timeout` parameter that indicates
    how long (in seconds) a QUIC connection can remain idle before being automatically
    closed. The first way to close a QUIC connection is to keep it idle for this period
    of time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个QUIC实现都会在其连接状态中保存通过此连接接收到的最后一个QUIC数据包的时间戳。在连接建立过程中，QUIC主机还可以交换`max_idle_timeout`参数，该参数表示QUIC连接在自动关闭之前可以保持空闲多长时间（以秒为单位）。关闭QUIC连接的第一种方式是保持连接空闲这段时间。
- en: Explicit termination of a QUIC connection[#](#explicit-termination-of-a-quic-connection
    "Link to this heading")
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式终止QUIC连接[#](#explicit-termination-of-a-quic-connection "链接到本标题")
- en: The second technique to terminate a QUIC connection is to use the `CONNECTION_CLOSE`
    frame. This frame indicates that this connection has been closed abruptly. The
    host that receives the `CONNECTION_CLOSE` may respond with one `CONNECTION_CLOSE`
    frame. After that, it must stop sending any additional frame. It keeps the connection
    state for some time, but does not accept any new packet nor retransmit others.
    The host that sends a `CONNECTION_CLOSE` frame indicates that it will neither
    send nor accept more data. It keeps a subset of the QUIC connection state to be
    able to retransmit the `CONNECTION_CLOSE` frame if needed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 终止QUIC连接的第二种技术是使用`CONNECTION_CLOSE`帧。此帧表示此连接已被突然关闭。接收`CONNECTION_CLOSE`帧的主机可以响应一个`CONNECTION_CLOSE`帧。之后，它必须停止发送任何额外的帧。它保持连接状态一段时间，但不接受任何新包也不重传其他包。发送`CONNECTION_CLOSE`帧的主机表示它将不会发送或接收更多数据。它保留QUIC连接状态的一部分，以便在需要时重新传输`CONNECTION_CLOSE`帧。
- en: A host also sends a `CONNECTION_CLOSE` frame to abruptly terminate a connection
    if it receives an invalid frame or detects a protocol error. In this case, the
    `CONNECTION_CLOSE` frame contains a variable length integer that indicates the
    reason for the termination, the type of the frame that triggered the error and
    additional information encoded as a text string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机收到无效帧或检测到协议错误，它也会发送一个`CONNECTION_CLOSE`帧来突然终止连接。在这种情况下，`CONNECTION_CLOSE`帧包含一个可变长度的整数，表示终止的原因、触发错误的帧类型以及编码为文本字符串的附加信息。
- en: '![Figure made with TikZ](../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png)'
- en: Fig. 92 A server that refuses a connection
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图92 拒绝连接的服务器
- en: The QUIC specification also defines a third technique called stateless reset
    to cope with hosts that have lost connection state after a crash or outage. It
    relies on a 16 bytes stateless token announced together with the connection identifier.
    See [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) for all
    the details.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC规范还定义了第三种技术，称为无状态重置，以应对在崩溃或故障后丢失连接状态的主机。它依赖于与连接标识符一起宣布的16字节无状态令牌。有关所有详细信息，请参阅[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。
- en: Exchanging data over a QUIC connection[#](#exchanging-data-over-a-quic-connection
    "Link to this heading")
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在QUIC连接上交换数据[#](#exchanging-data-over-a-quic-connection "链接到本标题")
- en: The data exchanged over is QUIC connection is organized in different streams.
    A stream is a sequence of bytes. QUIC supports both unidirectional and bidirectional
    streams. Both the client and the server can create new streams over a QUIC connection.
    Each stream is identified by a stream identifier. To prevent problems when the
    client and the server try to create a stream using the same identifier, QUIC restricts
    the utilization of the stream identifiers based its two low-order bits. A QUIC
    client can only create streams whose two low order bits are set to `00` (bidirectional
    stream) or `10` (unidirectional stream). Similarly, the low order bits of the
    server-initiated streams must be set to `01` (bidirectional stream) or `11` (unidirectional
    streams). The QUIC streams are created implicitly by sending data over the stream
    with the chosen identifier. The stream identifiers start at the minimum value,
    i.e. `0x00` to `0x03` for the respective types. If a host sends stream data for
    stream `x` before having sent data over the lower-numbered streams of that type,
    then those streams are implicitly created. The stream identifier is encoded using
    a variable length integer. The largest possible stream identifier is thus \(2^{62}-1\).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QUIC 连接上交换的数据组织在不同的流中。流是一系列字节。QUIC 支持单向和双向流。客户端和服务器都可以在 QUIC 连接上创建新的流。每个流都有一个流标识符。为了避免客户端和服务器尝试使用相同的标识符创建流时出现的问题，QUIC
    限制了基于其两个最低位的流标识符的使用。QUIC 客户端只能创建两个最低位设置为 `00`（双向流）或 `10`（单向流）的流。同样，服务器发起的流的最低位必须设置为
    `01`（双向流）或 `11`（单向流）。QUIC 流通过发送具有选择标识符的数据隐式创建。流标识符使用变长整数进行编码。因此，最大的流标识符是 \(2^{62}-1\)。
- en: 'QUIC places all data inside `STREAM` frames that are then placed inside QUIC
    packets. The structure of a `STREAM` frame is shown in [Listing 7](#fig-quic-stream-frame).
    This frame contains the following information :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 将所有数据放在 `STREAM` 帧中，然后这些帧被放入 QUIC 数据包中。`STREAM` 帧的结构在 [列表 7](#fig-quic-stream-frame)
    中显示。此帧包含以下信息：
- en: the Type of the Stream frame [[1]](#f-stream-type)
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流帧的类型 [[1]](#f-stream-type)
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the identifier of the stream
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的标识符
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the offset, i.e. the position of the first byte of the Stream data in the bytestream
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量，即流数据第一个字节在字节流中的位置
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the length of the data
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据长度
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Stream Data
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流数据
- en: Listing 7 The QUIC STREAM frame[#](#fig-quic-stream-frame "Link to this code")
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7 QUIC 流帧[#](#fig-quic-stream-frame "链接到这段代码")
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `STREAM` frame carries data, but it can also terminate the corresponding
    stream. The lowest order bit of the Type field acts as a `FIN` bit. When set to
    zero, it indicates that subsequent data will be sent over this stream. When set
    to one, it indicates that the `STREAM` frame contains the last bytes sent over
    that stream. The stream is closed once the last byte of the stream has been delivered
    to the user application. Once a QUIC stream has been closed, it cannot be reused
    again over this connection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`STREAM` 帧携带数据，但它也可以终止相应的流。类型字段最低位的比特用作 `FIN` 比特。当设置为 0 时，表示后续数据将通过此流发送。当设置为
    1 时，表示 `STREAM` 帧包含通过该流发送的最后一个字节。一旦将流的最后一个字节交付给用户应用，流就会被关闭。一旦一个 QUIC 流被关闭，它就不能再在此连接上重用。'
- en: Using this information, the receiver can easily reassemble the data received
    over the different streams. As an illustration, let us consider a server that
    has created two streams (stream `1` and `5`). The server sends `ABCD..` over stream
    `1` and `123` over stream `5` and closes it after having sent the third digit.
    The data from these streams could be encoded as shown in [Listing 8](#fig-quic-streams-example).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，接收者可以轻松重新组装通过不同流接收到的数据。为了说明，让我们考虑一个创建了两个流（流 `1` 和 `5`）的服务器。服务器通过流 `1`
    发送 `ABCD..`，通过流 `5` 发送 `123` 并在发送第三个数字后关闭它。这些流的数据可以编码如 [列表 8](#fig-quic-streams-example)
    所示。
- en: Listing 8 Data sent over two different streams[#](#fig-quic-streams-example
    "Link to this code")
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8 通过两个不同流发送的数据[#](#fig-quic-streams-example "链接到这段代码")
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The penultimate frame shown in [Listing 8](#fig-quic-streams-example) has the
    `FIN` flag set. It marks the end of stream `1` that has transported three bytes
    in total. The `FIN` flag is the normal way to gracefully close a QUIC stream.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表8](#fig-quic-streams-example)中显示的倒数第二个帧设置了 `FIN` 标志。它标志着传输了总共三个字节的流 `1`
    的结束。`FIN` 标志是优雅地关闭QUIC流的标准方式。
- en: There are however cases where an application might need to cancel a stream abruptly
    without closing the corresponding connection. First, the sending side of a stream
    can decide to reset the stream. For this, it sends a `RESET_STREAM` frame that
    carries the identifier of the stream that is canceled. The receiving side of a
    stream might also need to stop receiving data over a given stream. Consider for
    example a web browser that has started to download the different images that compose
    a web while the user has already clicked on another page from the same server.
    The streams that correspond to these images become useless. In this case, our
    browser can send a `STOP_SENDING` frame to indicate that it discards the incoming
    data over the corresponding streams. Upon reception of this frame, the server
    sends a `RESET_STREAM` frame to indicate that the corresponding stream has been
    closed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，应用程序可能需要突然取消一个流，而不关闭相应的连接。首先，流的发送方可以决定重置该流。为此，它发送一个携带被取消流标识符的 `RESET_STREAM`
    帧。流的接收方也可能需要停止接收给定流的数据。例如，考虑一个用户已经点击了同一服务器的另一个页面的网页浏览器，而浏览器已经开始下载组成网页的不同图像。对应这些图像的流变得无用。在这种情况下，我们的浏览器可以发送一个
    `STOP_SENDING` 帧来指示它丢弃对应流的传入数据。在接收到此帧后，服务器发送一个 `RESET_STREAM` 帧来指示相应的流已被关闭。
- en: Flow control in QUIC[#](#flow-control-in-quic "Link to this heading")
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC中的流量控制[#](#flow-control-in-quic "链接到这个标题")
- en: Transport protocols usually allocate some resources to each established connection.
    Each QUIC connection requires memory to store its state, but also buffers to store
    the packets arrived out-of-order. In practice, the memory available for QUIC implementations
    is not unlimited and a QUIC receiver must control the amount of packets that the
    remote host can send at any time. QUIC supports flow control techniques that operate
    at different levels.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议通常为每个建立的连接分配一些资源。每个QUIC连接都需要内存来存储其状态，但也需要缓冲区来存储到达顺序错误的包。实际上，可用于QUIC实现的内存不是无限的，QUIC接收方必须控制远程主机在任何时候可以发送的包的数量。QUIC支持在不同级别操作的流量控制技术。
- en: The first level is the connection level. During the handshake, each host can
    announce the maximum number of bytes that it agrees to receive initially on the
    connection using the `initial_max_data` transport parameter. This parameter contains
    the number of bytes that the sending host agrees to receive without further notice.
    If the connection uses more bytes than initially agreed, the receiver can update
    this limit by sending a `MAX_DATA` frame at any time. This frame contains a variable
    length integer that encodes the maximum amount of stream data that can be sent
    over the connection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一级是连接级别。在握手过程中，每个主机可以使用 `initial_max_data` 传输参数宣布它同意在连接上最初接收的最大字节数。此参数包含发送主机同意接收的字节数，无需进一步通知。如果连接使用的字节数超过了最初同意的数量，接收方可以在任何时候通过发送
    `MAX_DATA` 帧来更新此限制。此帧包含一个可变长度的整数，它编码了可以通过连接发送的最大流数据量。
- en: The utilization of different streams also consumes resources on a QUIC host.
    A receiver can also restrict the number of streams that the remote host can create.
    During the handshake, the `initial_max_streams_bidi` and `initial_max_streams_uni`
    transport parameters announce the maximum number of bidirectional and unidirectional
    streams that the receiving host can accept. This limit can be modified during
    the connection by sending a `MAX_STREAMS` frame that updates the limit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在QUIC主机上使用不同的流也会消耗资源。接收方还可以限制远程主机可以创建的流的数量。在握手过程中，`initial_max_streams_bidi`
    和 `initial_max_streams_uni` 传输参数宣布接收主机可以接受的最多双向和单向流的数量。此限制可以在连接期间通过发送更新限制的 `MAX_STREAMS`
    帧来修改。
- en: Flow control can also take place at the stream level. During the handshake,
    several transport parameters allow the hosts to advertise the maximum number of
    bytes that they agree to receive on each stream. Different transport parameters
    are used to specify the limits that apply to the local/remote and unidirectional/bidirectional
    streams. These limits can be updated during the connection by sending `MAX_STREAM_DATA`
    frames. Each of these frames indicates the maximum amount of stream data that
    can be accepted on a given stream.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 流量控制也可以在流级别上进行。在握手期间，几个传输参数允许主机宣布它们同意在每条流上接收的最大字节数。不同的传输参数用于指定适用于本地/远程和单向/双向流的限制。这些限制可以通过发送`MAX_STREAM_DATA`帧在连接期间更新。这些帧中的每一个都指示了在给定流上可以接受的最大流数据量。
- en: These limits restrict the number of streams that a host can create and the amount
    of bytes that it can send. If a host is blocked by any of these limits, it may
    sent a control frame to request the remote host to extend the limit. For each
    type of flow control, there is an associated control frame which can be used to
    request an extension of the limit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制限制了主机可以创建的流数量以及它可以发送的字节数。如果一个主机被这些限制中的任何一个阻塞，它可能发送一个控制帧来请求远程主机扩展限制。对于每种类型的流量控制，都有一个相关的控制帧，可以用来请求扩展限制。
- en: A host should send a `DATA_BLOCKED` frame when it reaches the limit on the maximum
    amount of data set by the `initial_max_data` transport parameter or a previously
    received `MAX_DATA` frame. The `DATA_BLOCKED` frame contains the connection limit
    that caused the transmission to be blocked. In practice, a receiving host should
    increase the connection-level limit by sending `MAX_DATA` frames before reaching
    the limit. However, since this limit is function of the available memory, a host
    might not always be able to send a `MAX_DATA` frame. [Fig. 93](#fig-quic-example-max-data)
    provides an example packet flow with the utilization of these frames. We assume
    that the `initial_max_data` transport parameter was set to `100` bytes by the
    client during the handshake and the the server needs to send 900 bytes. The server
    creates a stream and sends 100 bytes in a `1-RTT` packet carrying a `STREAM` frame.
    At this point, the server is blocked.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机达到由`initial_max_data`传输参数或之前接收到的`MAX_DATA`帧设定的最大数据量限制时，它应该发送一个`DATA_BLOCKED`帧。`DATA_BLOCKED`帧包含导致传输被阻塞的连接限制。在实践中，接收主机应在达到限制之前通过发送`MAX_DATA`帧来增加连接级别的限制。然而，由于这个限制是可用内存的函数，主机可能并不总是能够发送一个`MAX_DATA`帧。[图93](#fig-quic-example-max-data)提供了使用这些帧的示例数据包流。我们假设客户端在握手期间将`initial_max_data`传输参数设置为`100`字节，而服务器需要发送900字节。服务器创建一个流，并在携带`STREAM`帧的`1-RTT`数据包中发送100字节。此时，服务器被阻塞。
- en: '![Figure made with TikZ](../Images/5b5d3482cca71cc31e8478d8c94c256b.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/5b5d3482cca71cc31e8478d8c94c256b.png)'
- en: Fig. 93 QUIC uses `DATA_BLOCKED` frames when a connection’s flow control is
    blocked
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图93 QUIC在连接的流量控制被阻塞时使用`DATA_BLOCKED`帧
- en: The same applies with the `STREAM_DATA_BLOCKED` frame that is sent when a host
    reaching the per-stream limit. The `STREAMS_BLOCKED` frame is used when a host
    has reached the maximum number of established streams.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机达到每流的限制时发送的`STREAM_DATA_BLOCKED`帧也是如此。当主机达到已建立流的最大数量时，使用`STREAMS_BLOCKED`帧。
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Connections blocked by flow control are not totally idle
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 被流量控制阻塞的连接并非完全空闲
- en: If a QUIC host detects that a connection is blocked by flow control, it should
    regularly send `DATA_BLOCKED` or `STREAM_DATA_BLOCKED` frames to request the remote
    host to extend the current limit. The QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    does not recommend precisely how often these frames should be sent when a connection
    is blocked by flow control. Experience with QUIC deployments will enable the QUIC
    developers to more precisely define how often these frames should be sent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个QUIC主机检测到连接被流量控制阻塞，它应该定期发送`DATA_BLOCKED`或`STREAM_DATA_BLOCKED`帧，以请求远程主机扩展当前限制。QUIC规范[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)没有明确推荐在连接被流量控制阻塞时这些帧应该发送的频率。QUIC部署的经验将使QUIC开发者能够更精确地定义这些帧应该发送的频率。
- en: 'A measurement study [[MHLQ2020]](../bibliography.html#mhlq2020) revealed that
    QUIC implementations used different strategies for flow control. They identified
    three main types of behaviors :'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一项测量研究[[MHLQ2020]](../bibliography.html#mhlq2020)揭示了QUIC实现使用了不同的流量控制策略。他们确定了三种主要的行为类型：
- en: 'Static Flow Control: the receive buffer size stays unchanged and the receiver
    simply increases the maximum allowance linearly'
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态流量控制：接收缓冲区的大小保持不变，接收方简单地线性增加最大允许量
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Growing Flow Control: the size of the receive buffer increases over time as
    the connection progresses'
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长型流量控制：随着连接的进行，接收缓冲区的大小随时间增加
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Auto-tuning: the size of the receive buffer is adjusted dynamically based on
    the estimated bandwidth and round-trip times'
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调整：接收缓冲区的大小根据估计的带宽和往返时间动态调整
- en: In 2020, three quarter of the studied implementations used a Static Flow Control
    and only one used auto-tuning. Static Flow Control can work, but this is a waste
    of memory. For example, Google’s Chrome starts with a 15 MBytes receive buffer
    and updates it linearly [[MHLQ2020]](../bibliography.html#mhlq2020). This should
    be contrasted with TCP implementations that usually start with a window of a few
    tens of KBytes and adjust it with auto-tuning. Auto-tuning is a key feature of
    modern TCP implementations [[SMM1998]](../bibliography.html#smm1998). It is expected
    that QUIC implementations will include more advanced heuristics to tune their
    flow control mechanism.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020年，三分之二的被研究实现使用了静态流量控制，只有一个是自动调整。静态流量控制可以工作，但这是一种内存浪费。例如，Google的Chrome以15
    MBytes的接收缓冲区开始，并线性更新它 [[MHLQ2020]](../bibliography.html#mhlq2020)。这应该与通常以几个十KBytes的窗口开始并使用自动调整来调整窗口大小的TCP实现进行对比。自动调整是现代TCP实现的关键特性
    [[SMM1998]](../bibliography.html#smm1998)。预计QUIC实现将包括更高级的启发式方法来调整它们的流量控制机制。
- en: QUIC Loss Detection[#](#quic-loss-detection "Link to this heading")
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC丢包检测[#](#quic-loss-detection "链接到本标题")
- en: As other transport protocols, QUIC includes mechanisms to detect transmission
    errors and packet losses. The transmission errors are usually detected by using
    the UDP checksum or at the datalink layer with the Wi-Fi or Ethernet CRCs. When
    a transmission error occurs, the corresponding packet is discarded and QUIC considers
    this error as a packet loss. Researchers have analyzed the performance of checksums
    and CRCs on real data [[SGP98]](../bibliography.html#sgp98).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他传输协议一样，QUIC包括检测传输错误和包丢失的机制。传输错误通常通过使用UDP校验和或使用Wi-Fi或以太网的CRC在数据链路层检测。当发生传输错误时，相应的包被丢弃，QUIC将此错误视为包丢失。研究人员已经分析了校验和和CRC在真实数据上的性能
    [[SGP98]](../bibliography.html#sgp98)。
- en: Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated
    and a receiver can leverage this AEAD to detect transmission errors that were
    undetected by the UDP checksum of the CRC of the lower layers. However, these
    undetected transmission errors are assumed to be rare and if QUIC a detects an
    invalid AEAD, it will consider that this error was caused by an attack and will
    stop the connection using a TLS alert [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于QUIC使用了AEAD加密方案，所有QUIC包都经过认证，接收方可以利用这一点来检测UDP校验和或下层CRC未检测到的传输错误。然而，这些未检测到的传输错误被认为是罕见的，如果QUIC检测到一个无效的AEAD，它将认为这个错误是由攻击引起的，并将使用TLS警报停止连接
    [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。
- en: There are several important differences between the loss detection and retransmission
    mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers
    always increase monotonically over a QUIC connection. A QUIC sender never sends
    twice a packet with the same packet number over a given connection. QUIC encodes
    the packet numbers as variable length integers and it does not support wrap around
    in contrast with other transport protocols. The QUIC frames contain the valuable
    information that needs to be delivered reliably. If a QUIC packet is lost, the
    frames that it contained will be retransmitted in another QUIC packet that uses
    a different packet number. Thus, the QUIC packet number serves as a unique identifier
    of a packet. This simplifies some operations such as measuring the round-trip-time
    which is more difficult in protocols such as TCP when packets are transmitted
    [[KP91]](../bibliography.html#kp91).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC与其他传输协议使用的丢包检测和重传机制之间存在几个重要差异。首先，QUIC包号在QUIC连接中总是单调递增。QUIC发送者永远不会在给定的连接中发送具有相同包号的包两次。QUIC将包号编码为变长整数，并且与其他传输协议不同，它不支持回绕。QUIC帧包含需要可靠传输的有价值信息。如果一个QUIC包丢失，包含该包的帧将在使用不同包号的另一个QUIC包中重新传输。因此，QUIC包号充当包的唯一标识符。这简化了一些操作，例如测量往返时间，这在像TCP这样的协议中更困难，因为包被传输
    [[KP91]](../bibliography.html#kp91)。
- en: Second, QUIC’s acknowledgments carry more information than the cumulative or
    selective acknowledgments used by TCP and related protocols. This enables the
    receiver to provide a more detailed view of the packets that it received. In contrast
    with TCP [**RFC 2018**](https://datatracker.ietf.org/doc/html/rfc2018.html), once
    a receiver has reported that one packet was correctly received in an acknowledgment,
    the sender of that packet can discard the corresponding frames.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，QUIC的确认携带的信息比TCP和相关协议使用的累积或选择性确认要多。这使得接收者能够提供对它接收到的数据包的更详细视图。与TCP [**RFC
    2018**](https://datatracker.ietf.org/doc/html/rfc2018.html) 相比，一旦接收者在确认中报告了一个数据包被正确接收，该数据包的发送者就可以丢弃相应的帧。
- en: Third, a QUIC sender autonomously decides which frames it sends inside each
    packet. A QUIC packet may contain both data and control frames, or only data or
    only control information. If a QUIC packet is lost, the frames that it contained
    could be retransmitted in different packets. A QUIC implementation thus needs
    to buffer the frames and mark the in-flight ones to be able to retransmit them
    if the corresponding packet was lost.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，QUIC发送者自主决定在每个数据包内发送哪些帧。一个QUIC数据包可能包含数据和控制帧，或者只包含数据或只包含控制信息。如果一个QUIC数据包丢失，它所包含的帧可以在不同的数据包中重新传输。因此，QUIC实现需要缓冲帧并标记正在传输的帧，以便在相应的数据包丢失时能够重新传输它们。
- en: Fourth, most QUIC packets are explicitly acknowledged. The only exception are
    the packets that only contain `ACK`, `PADDING` or `CONNECTION_CLOSE` frames. A
    packet that contains any other QUIC frame is called an ack-eliciting packet because
    its delivery will be confirmed by the transmission of an acknowledgment. A QUIC
    packet that carries both an `ACK` and a `STREAM` frame will thus be acknowledged.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，大多数QUIC数据包都明确地被确认。唯一的例外是只包含`ACK`、`PADDING`或`CONNECTION_CLOSE`帧的数据包。包含任何其他QUIC帧的数据包被称为ack-eliciting
    packet，因为它的交付将通过发送确认来确认。因此，携带`ACK`和`STREAM`帧的QUIC数据包将被确认。
- en: With this in mind, it is interesting to look at the format of the QUIC acknowledgments
    and then analyze how they can be used. [Listing 9](#fig-quic-ack-frame) provides
    the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types
    are used to distinguish between the acknowledgments that contain information about
    the received ECN flags (type `0x03`) or only regular acknowledgments (type `0x02`).
    The first information contained in the ACK frame is the largest packet number
    that is acknowledged by this ACK frame. This is usually the highest packet number
    received. The second information is the ACK delay. This is the delay in microseconds
    between the reception of the packet having the largest acknowledged number by
    the receiver and the transmission of the acknowledgment. This information is important
    to ensure that round-trip-times are accurately measured, even if a receiver delays
    acknowledgments. This is illustrated in [Fig. 94](#fig-quic-ack-delay). The `ACK
    Range Count` field contains the number of `ACK ranges` that are included in the
    QUIC ACK frame. This number can be set to zero if all packets were received in
    sequence without any gap. In this case, the `First ACK Range` field contains the
    number of the packet that arrived before the `Largest Acknowledged` packet number.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，研究QUIC确认的格式并分析它们如何被使用是非常有趣的。[列表9](#fig-quic-ack-frame)提供了ACK帧的格式。它可以在QUIC数据包中的任何时间发送。使用两种类型来区分包含接收到的ECN标志信息的确认（类型`0x03`）或只有常规确认（类型`0x02`）。ACK帧中包含的第一个信息是此ACK帧确认的最大数据包号。这通常是接收到的最高数据包号。第二个信息是ACK延迟。这是接收者接收具有最大确认号的数据包和发送确认之间的微秒延迟。这个信息对于确保往返时间被准确测量非常重要，即使接收者延迟确认也是如此。这如图94所示。`ACK
    Range Count`字段包含QUIC ACK帧中包含的`ACK范围`数量。如果所有数据包都按顺序接收且没有间隙，则此数字可以设置为零。在这种情况下，`First
    ACK Range`字段包含在`Largest Acknowledged`数据包号之前到达的数据包号。
- en: Listing 9 The QUIC ACK Frame[#](#fig-quic-ack-frame "Link to this code")
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9 QUIC ACK帧格式[#](#fig-quic-ack-frame "链接到这段代码")
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure made with TikZ](../Images/91a1bf7fc5600dfd204d9c3691a03f74.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/91a1bf7fc5600dfd204d9c3691a03f74.png)'
- en: Fig. 94 Utilization of the QUIC ACK delay
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图94 QUIC确认延迟的利用
- en: An `ACK` frame contains 0 or more `ACK Ranges`. The format of an `ACK range`
    is shown in [Listing 10](#fig-quic-ack-range). Each range indicates first the
    number of unacknowledged packets since the smallest acknowledged packet in the
    preceding range (or the first ACK range). The next field indicates the number
    of consecutive acknowledged packets.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ACK`帧包含0个或多个`ACK Ranges`。`ACK range`的格式在[列表 10](#fig-quic-ack-range)中显示。每个范围首先指示自前一个范围中最小的已确认数据包以来的未确认数据包数量（或第一个`ACK`范围）。下一个字段指示连续已确认数据包的数量。
- en: Listing 10 A QUIC ACK range[#](#fig-quic-ack-range "Link to this code")
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10 一个QUIC确认范围[#](#fig-quic-ack-range "链接到这段代码")
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As an example, consider a host that received the following QUIC packets: `3,4,6,7,8,9,11,14,16,18`.
    To report all the received packets, it will generate the `ACK` frame shown in
    [Listing 11](#fig-quic-sample-ack-frame).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个接收了以下QUIC数据包的主机：`3,4,6,7,8,9,11,14,16,18`。为了报告所有接收到的数据包，它将生成[列表 11](#fig-quic-sample-ack-frame)中显示的`ACK`帧。
- en: Listing 11 Sample QUIC ACK Frame[#](#fig-quic-sample-ack-frame "Link to this
    code")
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11 示例QUIC确认帧[#](#fig-quic-sample-ack-frame "链接到这段代码")
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The QUIC specification recommends to send one `ACK` frame after having received
    two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments
    strategy. However, there is ongoing work to allow the sender to provide more guidelines
    on when and how `ACK` frames should be sent.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC规范建议在收到两个诱发性数据包后发送一个`ACK`帧。这大致对应于TCP的延迟确认策略。然而，目前正在进行的工作是为了允许发送者提供更多关于何时以及如何发送`ACK`帧的指导。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When should QUIC hosts send acknowledgments
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应该何时发送QUIC主机的确认
- en: A measurement study [[MHLQ2020]](../bibliography.html#mhlq2020) analyzed how
    QUIC implementations generate acknowledgments. Two of the studied implementations
    sent acknowledgments every N packets (2 for one implementation and 10 for the
    other). Other implementations used ack frequencies that varied during the data
    transfer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一项测量研究[[MHLQ2020]](../bibliography.html#mhlq2020)分析了QUIC实现如何生成确认。被研究的两种实现中，一种每N个数据包发送一次确认（一个实现为2，另一个为10）。其他实现使用了在数据传输过程中变化的确认频率。
- en: ([`Source code`](../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py),
    [`png`](../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png), [`hires.png`](../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png),
    [`pdf`](../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ([源代码](../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py), [png](../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png),
    [hires.png](../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png),
    [pdf](../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf))
- en: '![../_images/quic-1.png](../Images/3a962b543fdebe8ff46dbfacfe31e189.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-1.png](../Images/3a962b543fdebe8ff46dbfacfe31e189.png)'
- en: Fig. 95 Acknowledgment frequencies for different QUIC servers[#](#id28 "Link
    to this image")
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图95 不同QUIC服务器的确认频率[#](#id28 "链接到这张图片")
- en: The acknowledgment frequencies should be compared with TCP that usually acknowledges
    every second packet. It is likely that QUIC implementations will tune the generation
    of their acknowledgments in the coming years based on feedback from deployment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确认频率应该与通常每秒确认一个数据包的TCP进行比较。预计在未来的几年中，QUIC实现将根据部署的反馈调整其确认的生成。
- en: It is interesting to observe that since the `ACK` frames are sent inside QUIC
    packets, they can also be acknowledged. Sending an `ACK` in response to another
    `ACK` could result in an infinite exchange of `ACK` frames. To prevent this problem,
    a QUIC sender cannot send an `ACK` frame in response to a non-eliciting QUIC packet
    and the `ACK` frames are one of the non-eliciting frame types. Note that if a
    receiver that receives many `STREAM` frames and thus sends many `ACK` frames wants
    to obtain information about the reception of its `ACK` frame, it can simply send
    one `ACK` frame inside a packet that contains an eliciting frame, e.g. a `PING`
    frame. This frame will trigger the receiver to acknowledge it and the previously
    sent `ACK` frames.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到，由于`ACK`帧是在QUIC数据包内部发送的，因此它们也可以被确认。对另一个`ACK`帧发送`ACK`可能会引起`ACK`帧的无穷交换。为了防止这个问题，QUIC发送者不能对非诱发性QUIC数据包发送`ACK`帧，而`ACK`帧就是非诱发性帧类型之一。请注意，如果一个接收者接收了大量的`STREAM`帧并因此发送了大量的`ACK`帧，想要获取其`ACK`帧的接收信息，它可以在包含诱发性帧（例如`PING`帧）的数据包中简单地发送一个`ACK`帧。这个帧将触发接收者对其进行确认以及之前发送的`ACK`帧。
- en: In contrast with other reliable transport protocols, QUIC does not use cumulative
    acknowledgments. As explained earlier, QUIC never retransmits a packet with the
    same packet number. When a packet is lost, this creates a gap that the receiver
    reports using an `ACK Range`. Such a gap will never be filled by retransmissions
    and obviously should not be reported by the receiver forever. In practice, a receiver
    will send the acknowledgment that corresponds to a given packet number several
    times and then will assume that the acknowledgment has been received. A receiver
    can also rely on other heuristics to determine that a given `ACK Range` should
    not be reported anymore. This is the case if the `ACK` frame was included in a
    packet that has been acknowledged by the other peer, but also when the gap was
    noticed several round-trip times ago.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他可靠的传输协议相比，QUIC 不使用累积确认。如前所述，QUIC 从不重新传输具有相同包号的包。当一个包丢失时，这会创建一个接收方使用 `ACK
    Range` 报告的间隙。这样的间隙永远不会通过重传来填补，并且显然不应该由接收方永远报告。在实践中，接收方会发送与给定包号相对应的确认多次，然后假设确认已被接收。接收方还可以依靠其他启发式方法来确定给定的
    `ACK Range` 不再需要报告。这种情况发生在 `ACK` 帧包含在一个已被另一对等方确认的包中时，也发生在间隙被注意到的几个往返时间之前。
- en: QUIC also allows a receiver to send information about the ECN flags in the received
    packets. Two flags of the IP header [**RFC 3168**](https://datatracker.ietf.org/doc/html/rfc3168.html)
    are reserved to indicate support for Explicit Congestion Notification. The QUIC
    ECN count field shown in [Listing 12](#fig-quic-ecn-count) contains three counters
    for the different values of the ECN flags. These counters are incremented upon
    the reception of each QUIC packet based on the values of the ECN flag of the received
    packet. Unfortunately, there are still many operational problems when using ECN
    in the global Internet [[MLBBA2018]](../bibliography.html#mlbba2018). Time will
    tell whether it is easier to deploy ECN with QUIC than with TCP.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 还允许接收方发送有关接收到的包中 ECN 标志的信息。IP 头部的两个标志 [**RFC 3168**](https://datatracker.ietf.org/doc/html/rfc3168.html)
    保留以指示对显式拥塞通知的支持。在 [列表 12](#fig-quic-ecn-count) 中显示的 QUIC ECN 计数字段包含三个计数器，用于不同
    ECN 标志的值。这些计数器在接收每个 QUIC 包时根据接收到的包的 ECN 标志值递增。不幸的是，在全局互联网中使用 ECN 仍然存在许多操作问题 [[MLBBA2018]](../bibliography.html#mlbba2018)。时间将证明使用
    QUIC 部署 ECN 是否比使用 TCP 更容易。
- en: Listing 12 A QUIC ECN Count[#](#fig-quic-ecn-count "Link to this code")
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12 A QUIC ECN Count[#](#fig-quic-ecn-count "链接到这段代码")
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: QUIC also acknowledges control frames
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 也确认控制帧
- en: Besides the STREAM frames that carry user data, QUIC uses several different
    frame types to exchange control information. These control frames, like the data
    frames, are ack-eliciting frames. This implies a host that receives such a frame
    needs to acknowledge it using an `ACK` frame.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了携带用户数据的 STREAM 帧之外，QUIC 还使用几种不同的帧类型来交换控制信息。这些控制帧，就像数据帧一样，是请求确认的帧。这意味着接收此类帧的主机需要使用一个
    `ACK` 帧来确认它。
- en: '[Fig. 97](#fig-quic-ack-initials) illustrates the beginning of a QUIC connection
    with the exchange of the `Initial` packets and the corresponding acknowledgments.
    The client sends its `TLS Client Hello` inside a `CRYPTO` frame in an `Initial`
    packet. This is the first packet sent by the client and thus its packet number
    is 0\. The server replies with a `TLS Server Hello` inside a `CRYPTO` frame in
    an `Initial` packet. Since this is the first packet sent by the server, its packet
    number is also 0\. The packet also contains an `ACK` frame that acknowledges the
    reception of the packet containing the `TLS Client Hello`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 97](#fig-quic-ack-initials) 展示了 QUIC 连接的开始，通过交换 `Initial` 包和相应的确认。客户端在一个
    `Initial` 包中将其 `TLS Client Hello` 发送在一个 `CRYPTO` 帧内。这是客户端发送的第一个包，因此其包号为 0。服务器在一个
    `Initial` 包中用 `CRYPTO` 帧回复一个 `TLS Server Hello`。由于这是服务器发送的第一个包，其包号也是 0。该包还包含一个
    `ACK` 帧，确认接收到了包含 `TLS Client Hello` 的包。'
- en: The `Handshake`, `0-RTT` and `1-RTT` packets are acknowledged similarly using
    `ACK` frames. `Handshake` packets are acknowledged in other `Handshake` packets
    while `0-RTT` and `1-RTT` packets are acknowledged inside `1-RTT` packets.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handshake`、`0-RTT` 和 `1-RTT` 包也使用 `ACK` 帧以类似的方式进行确认。`Handshake` 包在其他 `Handshake`
    包中确认，而 `0-RTT` 和 `1-RTT` 包在 `1-RTT` 包内确认。'
- en: '![Figure made with TikZ](../Images/75ed846fe9a217630046fd48dc876f1b.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/75ed846fe9a217630046fd48dc876f1b.png)'
- en: Fig. 97 QUIC also acknowledges Initial frames
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 97 QUIC 也确认 Initial 帧内容
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all QUIC servers use 0 as the packet number of their first Initial packet
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有QUIC服务器都将0用作它们第一个初始数据包的数据包编号
- en: The example shows a QUIC connection where the client sent its Initial packet
    with packet number 0 and the server also replied with a packet number set to 0\.
    This is what most QUIC implementations do. However, the QUIC specification does
    not strictly requires this. In fact, `facebook` servers in October 2022 appear
    to use random packet numbers for the Initial packet that they sent in response
    to a client. This is probably use to detect or mitigate some forms of attacks
    since the client must receive the server’s Initial packet to be able to produce
    a valid acknowledgment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示了一个QUIC连接，其中客户端发送了编号为0的初始数据包，服务器也以编号设置为0的数据包进行了回复。这是大多数QUIC实现的做法。然而，QUIC规范并没有严格要求这样做。实际上，2022年10月，`facebook`服务器似乎在响应客户端时，为发送的初始数据包使用了随机的数据包编号。这可能是用来检测或减轻某些形式的攻击，因为客户端必须接收到服务器的初始数据包才能产生有效的确认。
- en: To illustrate how QUIC uses acknowledgments, let us consider a simple QUIC connection.
    The client starts a QUIC connection with a new server, sends a request, receives
    a response and then closes the connection. There are no losses in this connection.
    [Fig. 98](#fig-quic-ack-short) illustrates this connection.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明QUIC如何使用确认，让我们考虑一个简单的QUIC连接。客户端使用新服务器启动一个QUIC连接，发送一个请求，接收一个响应，然后关闭连接。在这个连接中没有数据丢失。[图98](#fig-quic-ack-short)展示了这个连接。
- en: '![Figure made with TikZ](../Images/00d236df000f95dc0877d8231f52d999.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/00d236df000f95dc0877d8231f52d999.png)'
- en: Fig. 98 Acknowledgments in a short QUIC connection
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图98 短QUIC连接中的致谢
- en: The connection starts when the client sends an `Initial` packet containing a
    `CRYPTO` frame with the `TLS Client Hello`. The server replies with an `Initial`
    packet that contains an acknowledgment and a `CRYPTO` frame with the `TLS Server
    Hello`. The server then sends an `Initial` packet containing the `TLS Encrypted
    Extensions`. Since this is the first `Initial` packet, its packet number is set
    to 0\. In practice, it is likely that the server will need to send several packets
    to carry the certificates contained in this packet. Note that the server cannot
    send more than 3 packets in response to the client’s `Initial` packet. This limit
    was introduced in the QUIC specification to restrict the ability of attackers
    to trigger DDoS attacks by sending spoofed packets to QUIC servers [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    If the `CRYPTO` frame containing the certificates is too long, the server might
    need to wait for acknowledgments from the client before sending its last `Handshake`
    packets. The client confirms the reception of the server’s `Initial` packet by
    sending its last `Initial` packet that contains an `ACK` frame. This is the second
    `Initial` packet sent by the client and its packet number is thus 1\. Since this
    packet only contains an `ACK` frame, the server does not return an acknowledgment
    to confirm its reception.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 连接开始于客户端发送包含带有`TLS客户端问候`的`CRYPTO`帧的`Initial`数据包。服务器回复一个包含确认和一个带有`TLS服务器问候`的`CRYPTO`帧的`Initial`数据包。然后服务器发送一个包含`TLS加密扩展`的`Initial`数据包。由于这是第一个`Initial`数据包，其数据包编号被设置为0。实际上，服务器可能需要发送多个数据包来携带这个数据包中包含的证书。请注意，服务器不能向客户端的`Initial`数据包发送超过3个数据包。这个限制是在QUIC规范中引入的，以限制攻击者通过向QUIC服务器发送伪造数据包来触发DDoS攻击的能力[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。如果包含证书的`CRYPTO`帧太长，服务器可能需要等待客户端的确认，然后才能发送最后的`握手`数据包。客户端通过发送包含`ACK`帧的最后`Initial`数据包来确认已接收到服务器的`Initial`数据包。这是客户端发送的第二个`Initial`数据包，因此其数据包编号为1。由于这个数据包只包含`ACK`帧，服务器不需要返回确认来确认其接收。
- en: The client replies to the `Handshake` packet with another `Handshake` packet
    that contains a `CRYPTO` frame and acknowledges the `Handshake` packets sent by
    the server. The client’s `Handshake` packet is acknowledged by the server. The
    server starts the data exchange by sending a `1-RTT` packet carrying one or more
    stream frames to create the required streams. Since this is the first `1-RTT`
    packet sent by the server, its packet number is set to 0\. The client then sends
    its request in a `STREAM` frame. The server replies with a `1-RTT` packet that
    contains a `STREAM` frame with its response. The client ends the connection by
    sending a `CONNECTION_CLOSE` frame. In the example, the server replies with a
    `CONNECTION_CLOSE` frame, but the QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    only indicates that a host may respond with a `CONNECTION_CLOSE` in this case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端用包含 CRYPTO 帧的另一个 `Handshake` 数据包回复 `Handshake` 数据包，并确认服务器发送的 `Handshake`
    数据包。服务器的 `Handshake` 数据包被客户端确认。服务器通过发送包含一个或多个流帧的 `1-RTT` 数据包来开始数据交换，创建所需的流。由于这是服务器发送的第一个
    `1-RTT` 数据包，其数据包编号被设置为 0。然后客户端在 `STREAM` 帧中发送其请求。服务器用包含响应 `STREAM` 帧的 `1-RTT`
    数据包回复。客户端通过发送 `CONNECTION_CLOSE` 帧来结束连接。在示例中，服务器用 `CONNECTION_CLOSE` 帧回复，但 QUIC
    规范 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 只指出在这种情况下，主机可以回复一个
    `CONNECTION_CLOSE`。
- en: Observing QUIC connections[#](#observing-quic-connections "Link to this heading")
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察 QUIC 连接[#](#observing-quic-connections "链接到这个标题")
- en: We have now reviewed the main components of the QUIC specification. To illustrate
    it, let us consider a simple scenario where a client opens a QUIC connection with
    a server. We leverage Maxime Piraux’s QUIC tracker [[PDB2018]](../bibliography.html#pdb2018).
    In this example, we use the packet trace collected using the `nghttp2.org` server
    on November 22, 2021 at 18:04:52 CET. This trace is available from [https://quic-tracker.info.ucl.ac.be/traces/20211122/148](https://quic-tracker.info.ucl.ac.be/traces/20211122/148).
    You can see the contents of the packets, download it as a `.pcap` trace or visualize
    it using QLog/QViz [[MPQL2020]](../bibliography.html#mpql2020) from this web site.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经审查了 QUIC 规范的主要组件。为了说明它，让我们考虑一个简单的场景，其中客户端与服务器建立一个 QUIC 连接。我们利用 Maxime
    Piraux 的 QUIC 跟踪器 [[PDB2018]](../bibliography.html#pdb2018)。在这个例子中，我们使用 2021 年
    11 月 22 日 18:04:52 CET 在 `nghttp2.org` 服务器上收集的数据包跟踪。这个跟踪可以从 [https://quic-tracker.info.ucl.ac.be/traces/20211122/148](https://quic-tracker.info.ucl.ac.be/traces/20211122/148)
    获取。您可以看到数据包的内容，将其下载为 `.pcap` 跟踪或使用 QLog/QViz [[MPQL2020]](../bibliography.html#mpql2020)
    从这个网站进行可视化。
- en: This trace contains 16 packets. The scenario is a simple handshake with an exchange
    of data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跟踪包含 16 个数据包。场景是一个简单的握手和数据交换。
- en: '![../_images/qtracker-nghttp2-1.png](../Images/7e3eb62de8971ff53e65f8fbea028144.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-nghttp2-1.png](../Images/7e3eb62de8971ff53e65f8fbea028144.png)'
- en: Fig. 99 Sample QUIC tracker trace with `nghttp2.org` containing a successful
    handshake[#](#id32 "Link to this image")
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 99 包含成功握手的 `nghttp2.org` 的样本 QUIC 跟踪器跟踪[#](#id32 "链接到这个图像")
- en: To initiate the connection, the client sends an `Initial` QUIC packet. It is
    interesting to analyze the content of this packet. It starts with a long QUIC
    header shown in [Listing 13](#fig-trace-quic-header-p1).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立连接，客户端发送一个 `Initial` QUIC 数据包。分析这个数据包的内容很有趣。它以一个长的 QUIC 报头开始，如 [列表 13](#fig-trace-quic-header-p1)
    所示。
- en: Listing 13 The QUIC header of the first packet sent by the client[#](#fig-trace-quic-header-p1
    "Link to this code")
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13 客户端发送的第一个数据包的 QUIC 报头[#](#fig-trace-quic-header-p1 "链接到这段代码")
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The client proposes a 64 bits connection identifier and uses a random 64 bits
    identifier for the destination connection identifier. There is no token in this
    packet since this is the first connection from this client to the server. It is
    useful to note that the packet number of this `Initial` packet is set to zero.
    All QUIC connections start with a packet whose packet number is set to zero in
    contrast with TCP that uses a random sequence number. The packet contains a `CRYPTO`
    frame shown in [Listing 14](#fig-trace-quic-crypto-p1).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端提出一个 64 位的连接标识符，并使用一个随机的 64 位的标识符作为目标连接标识符。由于这是客户端到服务器的第一个连接，这个数据包中没有令牌。值得注意的是，这个
    `Initial` 数据包的数据包编号被设置为 0。与使用随机序列号的 TCP 相比，所有 QUIC 连接都以一个数据包编号设置为 0 的数据包开始。数据包包含一个在
    [列表 14](#fig-trace-quic-crypto-p1) 中显示的 `CRYPTO` 帧。
- en: Listing 14 The CRYPTO frame of the first QUIC packet sent by the client[#](#fig-trace-quic-crypto-p1
    "Link to this code")
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14 客户端发送的第一个 QUIC 数据包的 CRYPTO 帧[#](#fig-trace-quic-crypto-p1 "链接到这段代码")
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `CRYPTO` frame starts at offset 0 and has a length of `245` bytes. It contains
    a TLS 1.3 `ClientHello` message whose format is specified in [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    This `ClientHello` includes a 32 bytes secure random number, a set of proposed
    cipher suites and a series of TLS extensions. One of these extensions carries
    the QUIC transport parameters proposed by the client. On this connection, the
    QUIC tracker client proposed the following ones:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`CRYPTO` 数据帧从偏移量0开始，长度为`245`字节。它包含一个TLS 1.3 `ClientHello` 消息，其格式在[**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)中指定。此`ClientHello`包括一个32字节的加密随机数，一组提议的加密套件和一系列TLS扩展。其中之一扩展携带客户端提出的QUIC传输参数。在此连接上，QUIC跟踪器客户端提出了以下参数：'
- en: '`initial_max_stream_data_bidi_local` = 0x80004000'
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_stream_data_bidi_local` = 0x80004000'
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_stream_data_uni` = 0x80004000'
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_stream_data_uni` = 0x80004000'
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_data` = 0x80008000'
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_data` = 0x80008000'
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_streams_bidi` = 0x1'
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_streams_bidi` = 0x1'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_streams_uni` = 0x3'
  id: totrans-227
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_streams_uni` = 0x3'
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_idle_timeout` = 0x6710'
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_idle_timeout` = 0x6710'
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`active_connection_id_limit` = 0x4'
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_connection_id_limit` = 0x4'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_packet_size` = 0x45c0'
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_packet_size` = 0x45c0'
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`inital_source_connection_id` = 0xc9f54d3c298296b9'
  id: totrans-239
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inital_source_connection_id` = 0xc9f54d3c298296b9'
- en: Finally, the first QUIC packet contains a `PADDING` frame with 960 dummy bytes.
    The entire packet is 1236 bytes long.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第一个QUIC数据包包含一个包含960个空字节填充的`PADDING`数据帧。整个数据包长度为1236字节。
- en: The server responds to this `Initial` packet with two packets. The first one
    is an `Initial` packet. It starts with the header shown in [Listing 15](#fig-trace-quic-header-p2).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器用两个数据包响应这个`Initial`数据包。第一个是一个`Initial`数据包。它以[列表15](#fig-trace-quic-header-p2)中显示的头部开始。
- en: Listing 15 The QUIC header of the first packet sent by the client[#](#fig-trace-quic-header-p2
    "Link to this code")
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15 客户端发送的第一个数据包的QUIC头部[#](#fig-trace-quic-header-p2 "链接到这段代码")
- en: '[PRE14]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This server uses 18 bytes to encode its connection identifier and proposes
    the first identifier in the long header. The packet payload contains two frames:
    an `ACK` frame and a `CRYPTO` frame. The `ACK` frame ([Listing 16](#fig-trace-quic-ack-p2))
    acknowledges the reception of the `Initial` packet sent by the client. The `CRYPTO`
    frame contains the TLS ServerHello.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器使用18字节来编码其连接标识符，并在长头部中提出第一个标识符。数据包有效负载包含两个数据帧：一个`ACK`数据帧和一个`CRYPTO`数据帧。`ACK`数据帧([列表16](#fig-trace-quic-ack-p2))确认接收了客户端发送的`Initial`数据包。`CRYPTO`数据帧包含TLS
    ServerHello。
- en: Listing 16 The ACK Frame of the first packet sent by the server[#](#fig-trace-quic-ack-p2
    "Link to this code")
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16 服务器发送的第一个数据包的ACK帧[#](#fig-trace-quic-ack-p2 "链接到这段代码")
- en: '[PRE15]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The payload of these `Initial` packets is encrypted using the static key derived
    from the connection identifiers included in the long header.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`Initial`数据包的有效负载使用从长头部中包含的连接标识符派生的静态密钥加密。
- en: 'The server then sends three `Handshake` packets carrying a `CRYPTO` frame that
    contains the `TLSEncryptedExtensions`. These extensions are encrypted using the
    TLS key. They mainly contain the server certificate. It is interesting to note
    that the `packet_number` field of the first `Handshake` packet sent by the server
    is also set to zero. This is the second, but not the last, packet that we observe
    with this `packet_number`. QUIC handles packet numbers differently then other
    protocols. QUIC considers that a QUIC connection is divided in three phases:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后发送三个携带`CRYPTO`数据帧的`Handshake`数据包，该数据帧包含`TLSEncryptedExtensions`。这些扩展使用TLS密钥加密。它们主要包含服务器证书。值得注意的是，服务器发送的第一个`Handshake`数据包的`packet_number`字段也设置为0。这是第二个，但不是最后一个，我们观察到具有此`packet_number`的数据包。QUIC处理数据包编号的方式与其他协议不同。QUIC认为QUIC连接分为三个阶段：
- en: The exchange of the `Initial` packets
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Initial`数据包的交换'
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The exchange of the `Handshake` packets
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Handshake` 数据包的交换'
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The exchange of the other packets (`0-RTT`, `1-RTT`, … packets)
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他数据包的交换（`0-RTT`，`1-RTT`，… 数据包）
- en: A QUIC host restarts the `packet_number` at zero in each phase. This explains
    why it is possible to observe different packets (of different types) with the
    same `packet_number` over a QUIC connection.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段，QUIC主机都将`packet_number`重置为零。这解释了为什么可以在QUIC连接中观察到具有相同`packet_number`的不同类型的数据包。
- en: The three `Handshake` packets sent by the server contain the beginning of the
    `TLSEncryptedExtensions` sent by the server. To prevent denial of service attacks,
    the server cannot send more than three full-length packets in response to a packet
    sent by the client. The server thus needs to wait for an acknowledgment from the
    client before sending additional packets.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的三个`Handshake`数据包包含服务器发送的`TLSEncryptedExtensions`的开始部分。为了防止拒绝服务攻击，服务器不能在响应客户端发送的数据包时发送超过三个完整长度的数据包。因此，服务器在发送额外的数据包之前需要等待客户端的确认。
- en: The client sends two packets to carry these acknowledgments. First, it sends
    an `Initial` packet as the sixth packet of the trace. This packet belongs to the
    packet numbering space of the `Initial` packets. Its packet number is 1 since
    this is the second `Initial` packet sent by the client. The next acknowledgment
    is carried inside an `Handshake` packet. It acknowledges the `Handshake` packets
    0-2 sent by the server. Since this is the first `Handshake` packet sent by the
    client, its packet number is also 0.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送两个数据包来携带这些确认信息。首先，它发送一个`Initial`数据包作为跟踪的第六个数据包。这个数据包属于`Initial`数据包的编号空间。它的数据包编号是1，因为这是客户端发送的第二个`Initial`数据包。下一个确认信息包含在一个`Handshake`数据包中。它确认了服务器发送的0-2号`Handshake`数据包。由于这是客户端发送的第一个`Handshake`数据包，它的数据包编号也是0。
- en: The server then sends the eighth packet that contains the last part of the `TLSEncryptedExtensions`
    in a `CRYPTO` frame. By combining the information contained in the `Handshake`
    packets and the `Initial` packets, the client can derive the session keys.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器发送包含`TLSEncryptedExtensions`最后部分的第八个数据包，在一个`CRYPTO`帧中。通过结合`Handshake`数据包和`Initial`数据包中包含的信息，客户端可以推导出会话密钥。
- en: The server immediately sends its first `1-RTT` packet. This packet contains
    a short header shown in [Listing 17](#fig-trace-quic-short-header).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器立即发送其第一个`1-RTT`数据包。这个数据包包含一个简短的头，如[列表17](#fig-trace-quic-short-header)所示。
- en: Listing 17 The QUIC short header of the first 1-RTT packet sent by the server[#](#fig-trace-quic-short-header
    "Link to this code")
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17 服务器发送的第一个1-RTT数据包的QUIC简短头[#](#fig-trace-quic-short-header "链接到这段代码")
- en: '[PRE16]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This short header contains the connection identifier proposed by the client
    in the first `Initial` packet. The payload contains `STREAM` frames that create
    three streams. The client replies with two packets. The tenth packet of the trace
    is a `Handshake` packet that carries two frames. The `CRYPTO` frame contains the
    `TLS Finished` message that finalizes the TLS handshake. The `ACK` frame acknowledges
    the four `Handshake` packets sent by the server.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的头包含客户端在第一个`Initial`数据包中提出的连接标识符。有效载荷包含创建三个流的`STREAM`帧。客户端回复两个数据包。跟踪的第十个数据包是一个`Handshake`数据包，携带两个帧。`CRYPTO`帧包含`TLS
    Finished`消息，最终完成TLS握手。`ACK`帧确认了服务器发送的四个`Handshake`数据包。
- en: The first `1-RTT` packet sent by the client contains an `ACK` frame that acknowledges
    the `1-RTT` packet sent by the server and flow control information. The client
    sends a `MAX_DATA` frame to restrict the amount of data that the server can send
    and one `MAX_STREAM` frame for each of the three streams created by the server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的第一个`1-RTT`数据包包含一个`ACK`帧，确认了服务器发送的`1-RTT`数据包和流量控制信息。客户端发送一个`MAX_DATA`帧来限制服务器可以发送的数据量，并为服务器创建的每个流发送一个`MAX_STREAM`帧。
- en: The twelfth packet of the trace is more interesting. It contains five different
    frames that are sent by the server. First, the server send two `NEW_CONNECTION_ID`
    frames that advertise two 18 bytes long connection identifiers which can be used
    by the client to migrate the connection later. The next frame is the `HANDSHAKE_DONE`
    frame that confirms the TLS handshake. The server also sends a `NEW_TOKEN` frame
    that contains a 57 bytes long token that the client will be able to use in subsequent
    connections with the server. The last frame is a `CRYPTO` frame that contains
    two `TLS New Session Tickets`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的第十二个数据包更有趣。它包含由服务器发送的五个不同的帧。首先，服务器发送两个`NEW_CONNECTION_ID`帧，宣布了两个18字节长的连接标识符，客户端可以使用这些标识符在以后迁移连接。下一个帧是`HANDSHAKE_DONE`帧，确认了TLS握手。服务器还发送一个包含57字节长令牌的`NEW_TOKEN`帧，客户端将在随后的服务器连接中使用这个令牌。最后一个帧是一个`CRYPTO`帧，包含两个`TLS
    New Session Tickets`。
- en: A closer look at other QUIC handshakes[#](#a-closer-look-at-other-quic-handshakes
    "Link to this heading")
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深入了解其他QUIC握手[#](#a-closer-look-at-other-quic-handshakes "链接到这个标题")
- en: It is interesting to analyze how different servers perform the handshake using
    QUIC tracker. Let us first explore the [trace collected with cloudflare-quic.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)
    on the same day shown in [Fig. 100](#fig-qtracker-cloudflare). There are several
    differences with the nghttp2 trace that we analyzed above. First, the server sends
    two small packets in response to the client’s `Initial`. The first packet only
    contains an `ACK` frame. It advertises a 20 bytes long connection identifier.
    The second packet contains a `CRYPTO` frame with a `TLS Hello Retry Request`.
    This message indicates that the server did not agree with the `key_share` parameter
    of the `TLS Client Hello` sent in the first packet. The client acknowledges this
    packet and sends a new `TLS Client Hello` in the fourth packet. The server replies
    with a `TLS Server Hello` and then the `TLSEncryptedExtensions` in three QUIC
    packets. The certificate used by `cloudflare-quic.com` is more compact than the
    one used by `nghttp2.org`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 分析不同服务器如何使用QUIC tracker进行握手很有趣。让我们首先探索同一天收集的[使用cloudflare-quic.com收集的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)，如图[图100](#fig-qtracker-cloudflare)所示。与上面分析的nghttp2跟踪相比，有几个不同之处。首先，服务器向客户端的`Initial`响应发送了两个小数据包。第一个数据包只包含一个`ACK`帧。它宣布了一个20字节长的连接标识符。第二个数据包包含一个带有`TLS
    Hello Retry Request`的`CRYPTO`帧。这条消息表明服务器不同意第一个数据包中发送的`TLS Client Hello`的`key_share`参数。客户端确认这个数据包，并在第四个数据包中发送一个新的`TLS
    Client Hello`。服务器以`TLS Server Hello`响应，然后在三个QUIC数据包中发送`TLSEncryptedExtensions`。`cloudflare-quic.com`使用的证书比`nghttp2.org`使用的更紧凑。
- en: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
- en: Fig. 100 Sample quic tracker trace from cloudflare-quic.com with a successful
    handshake[#](#id33 "Link to this image")
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图100：从cloudflare-quic.com获取的quic tracker跟踪示例，展示了成功的握手[#](#id33 "链接到这张图片")
- en: The `1-RTT` packets are also slightly different. The first `1-RTT` packet sent
    by the server contains the `HANDSHAKE_DONE` frame, a `CRYPTO` frame with two `TLS
    New Session Ticket` messages and a `STREAM` frame that creates one stream. The
    server then sends two short packet. Each of these packets contains a `STREAM`
    frame that creates a new stream. These two short packets could have been packed
    in the first `1-RTT` packet sent by the server. In contrast with `nghttp2.org`,
    `cloudflare-quic.com` does advertise new connection identifiers.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`1-RTT`数据包也有所不同。服务器发送的第一个`1-RTT`数据包包含`HANDSHAKE_DONE`帧，一个带有两个`TLS New Session
    Ticket`消息的`CRYPTO`帧和一个创建一个流的`STREAM`帧。然后服务器发送两个短数据包。每个数据包都包含一个创建新流的`STREAM`帧。这两个短数据包本可以打包在服务器发送的第一个`1-RTT`数据包中。与`nghttp2.org`相比，`cloudflare-quic.com`并没有宣布新的连接标识符。'
- en: Our third example is [picoquic](https://github.com/private-octopus/picoquic).
    The [QUIC tracker trace with test.privateoctopus.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/159)
    contains 13 packets.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个例子是[picoquic](https://github.com/private-octopus/picoquic)。[使用test.privateoctopus.com进行的QUIC
    tracker跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/159)包含13个数据包。
- en: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
- en: Fig. 101 Sample QUIC tracker trace from `test.privateoctopus.com` with a successful
    handshake[#](#id34 "Link to this image")
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图101：从`test.privateoctopus.com`获取的QUIC tracker跟踪示例，展示了成功的握手[#](#id34 "链接到这张图片")
- en: picoquic uses 64 bits long connection identifiers. It manages to fit its `TLS
    Encrypted Extensions` within two `Handshake` packets. The first `1-RTT` packet
    that it sends contains a `PING` frame. The second `1-RTT` packet contains one
    `CRYPTO` frame that advertises one `TLS New Session Ticket`, three `NEW_CONNECTION_ID`
    frames and a `NEW_TOKEN` frame. This test server does not try to create new streams
    in contrast with the two others.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: picoquic使用64位长的连接标识符。它设法将其`TLS Encrypted Extensions`放入两个`Handshake`数据包中。它发送的第一个`1-RTT`数据包包含一个`PING`帧。第二个`1-RTT`数据包包含一个`CRYPTO`帧，宣布了一个`TLS
    New Session Ticket`，三个`NEW_CONNECTION_ID`帧和一个`NEW_TOKEN`帧。这个测试服务器与另外两个不同，没有尝试创建新的流。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing QUIC servers
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 比较QUIC服务器
- en: It is interesting to use the traces collected by QUIC tracker to analyze how
    different servers have selected some of the optional features of QUIC. A first
    difference between the servers is the length of the server-selected connection
    identifiers. The graph below shows that in November 2021 many servers advertised
    8 bytes CIDs, but some have opted for much longer CIDs.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 QUIC 跟踪器收集的跟踪来分析不同服务器如何选择 QUIC 的一些可选功能是非常有趣的。服务器之间的第一个区别是服务器选择的连接标识符的长度。下面的图表显示，在
    2021 年 11 月，许多服务器广告了 8 字节的 CIDs，但有些选择了更长的 CIDs。
- en: ([`Source code`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py),
    [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png), [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ([`源代码`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py), [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png),
    [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
- en: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
- en: Fig. 102 Length of the connection identifiers advertised by different QUIC servers
    (Nov 2021)[#](#id35 "Link to this image")
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 102 不同 QUIC 服务器广告的连接标识符长度（2021 年 11 月）[#](#id35 "链接到这张图片")
- en: Observing 0-RTT data in QUIC[#](#observing-0-rtt-data-in-quic "Link to this
    heading")
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察 QUIC 中的 0-RTT 数据[#](#observing-0-rtt-data-in-quic "链接到这个标题")
- en: The ability to send data immediately was one of the requirements for the design
    of QUIC. It is interesting to observe how QUIC uses the `0-RTT` packets for this
    purpose. We use a [trace collected between QUIC tracker and picoquic as our example](https://quic-tracker.info.ucl.ac.be/traces/20211122/619).
    This trace covers two QUIC connections shown in [Fig. 104](#fig-qtrack-picoquic-0rtt).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 能够立即发送数据是 QUIC 设计的要求之一。观察 QUIC 如何使用 `0-RTT` 数据包来实现这一目的是非常有趣的。我们使用了一个 [QUIC 跟踪器和
    picoquic 之间的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/619)作为我们的例子。这个跟踪覆盖了
    [图 104](#fig-qtrack-picoquic-0rtt) 中显示的两个 QUIC 连接。
- en: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
- en: Fig. 104 Sample QUIC trace with `test.privateoctopus.com` with 0-RTT packets[#](#fig-qtrack-picoquic-0rtt
    "Link to this image")
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 104 使用 `test.privateoctopus.com` 的示例 QUIC 跟踪，包含 0-RTT 数据包[#](#fig-qtrack-picoquic-0rtt
    "链接到这张图片")
- en: During the first QUIC connection, QUIC tracker receives one TLS session ticket
    in the `CRYPTO` frame contained in the 1-RTT packet that the server sent with
    packet number set to 0\. This ticket contains all the information required by
    the server to retrieve the key in a subsequent connection. QUIC tracker starts
    the second connection by sending an `Initial` packet. This packet contains a `CRYPTO`
    frame that contains the `TLS Client Hello` message. A comparison between this
    `TLS Client Hello` and the one sent to create the first connection shows that
    the latter contains the `psk_key_exchange_modes` TLS extension. This extension
    contains the information that enables the server to recover the key required to
    decrypt the `0-RTT` packet. In this example, the client sends a `0-RTT` that contains
    the beginning of a simple `HTTP GET`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次 QUIC 连接期间，QUIC 跟踪器在服务器发送的包含在 1-RTT 数据包中的 `CRYPTO` 帧中接收一个 TLS 会话票据，该数据包的包号设置为
    0。这个票据包含服务器在后续连接中检索密钥所需的所有信息。QUIC 跟踪器通过发送一个 `Initial` 数据包开始第二个连接。这个数据包包含一个 `CRYPTO`
    帧，其中包含 `TLS Client Hello` 消息。将这个 `TLS Client Hello` 与用于创建第一个连接的 `TLS Client Hello`
    进行比较，可以看出后者包含 `psk_key_exchange_modes` TLS 扩展。这个扩展包含使服务器能够恢复用于解密 `0-RTT` 数据包所需的密钥的信息。在这个例子中，客户端发送了一个包含简单
    `HTTP GET` 开始部分的 `0-RTT`。
- en: QUIC streams[#](#quic-streams "Link to this heading")
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUIC 流[#](#quic-streams "链接到这个标题")
- en: As QUIC support multiple streams, it is interesting to analyze how the streams
    are managed over a real QUIC connection. For this example, we use a [trace between
    QUIC tracker and quic.tech](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)
    summarized in [Fig. 105](#fig-qtrack-quictech). In the example, the QUIC tracker
    creates four streams and sends one `HTTP GET` request over each of them.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 QUIC 支持多个流，分析如何在真实的 QUIC 连接中管理这些流是非常有趣的。在这个例子中，我们使用了一个 [QUIC 跟踪器和 quic.tech
    之间的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)，总结在 [图 105](#fig-qtrack-quictech)。在示例中，QUIC
    跟踪器创建了四个流，并通过每个流发送一个 `HTTP GET` 请求。
- en: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
- en: Fig. 105 Sample QUIC trace with quic.tech using multiple streams[#](#fig-qtrack-quictech
    "Link to this image")
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 105 使用 quic.tech 的样本 QUIC 跟踪，包含多个流[#](#fig-qtrack-quictech "链接到这张图片")
- en: In this trace, the client creates four streams in its first `STREAM` frame sent
    in the first `1-RTT` packet. [Listing 18](#fig-quic-trace-stream-frame) shows
    the first of these `STREAM` frames. The `Type` of the `STREAM` is one octet structured
    as `0b00001OLF` where `O` is set to `1` if the `STREAM` frame contains an `Offset`
    field. Bit `L` is set to `1` if the frame contains a `Length` field. Finally,
    the `F` is set to `1` to mark the end of the `STREAM`. In this test, QUIC Tracker
    sends 17 bytes over each stream and closes it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个跟踪中，客户端在其第一个 `STREAM` 帧中创建了四个流，这个 `STREAM` 帧是在第一个 `1-RTT` 数据包中发送的。[列表 18](#fig-quic-trace-stream-frame)
    展示了这些 `STREAM` 帧中的第一个。`STREAM` 的 `Type` 字段是一个字节，结构为 `0b00001OLF`，其中 `O` 如果 `STREAM`
    帧包含 `Offset` 字段则设置为 `1`。位 `L` 如果帧包含 `Length` 字段则设置为 `1`。最后，`F` 设置为 `1` 以标记 `STREAM`
    的结束。在这个测试中，QUIC Tracker 通过每个流发送 17 字节并关闭它。
- en: Listing 18 The first QUIC STREAM frame sent by QUIC Tracker[#](#fig-quic-trace-stream-frame
    "Link to this code")
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18 由 QUIC Tracker 发送的第一个 QUIC STREAM 帧[#](#fig-quic-trace-stream-frame "链接到这段代码")
- en: '[PRE17]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The server sends each response in a `STREAM` frame. [Listing 19](#fig-quic-trace-stream-frame-2)
    shows the frame returned by the server. Its `Offset` bit is set to `1`. It carries
    the entire HTML page and its `Offset` field could have been ignored since this
    is the first frame of the stream.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在每个响应中发送一个 `STREAM` 帧。[列表 19](#fig-quic-trace-stream-frame-2) 展示了服务器返回的帧。其
    `Offset` 位被设置为 `1`。它携带整个 HTML 页面，并且由于这是流的第一个帧，其 `Offset` 字段可以被忽略。
- en: Listing 19 The QUIC STREAM frame returned by the server[#](#fig-quic-trace-stream-frame-2
    "Link to this code")
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19 服务器返回的 QUIC STREAM 帧[#](#fig-quic-trace-stream-frame-2 "链接到这段代码")
- en: '[PRE18]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Footnotes
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: Frames and packets[#](#frames-and-packets "Link to this heading")
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧和包[#](#frames-and-packets "链接到这个标题")
- en: There is an important difference between QUIC and classical protocols like TCP
    or UDP. TCP and UDP send segments that are composed of a header followed by a
    sequence of bytes that constitutes the payload. In contrast and like SCTP, a QUIC
    packet contains a header followed by one or more frames. The QUIC header is much
    simpler and shorter than the TCP header. It only carries the information which
    is required in all QUIC packets. We will describe later the short and long QUIC
    headers. Each QUIC header starts with one byte that contains some flags and a
    32 bits version field. QUIC defines different types of frames that we will discuss
    in this chapter. Some types of QUIC frames carry user data. Other types of QUIC
    frames carry control information. Some of these frames are used during the handshake
    only while others such as acknowledgments can be sent at any time. Each QUIC frame
    is a sequence of byte that starts with a one byte Type field. [Fig. 85](#fig-quic-packet)
    shows a QUIC packet containing two frames which is placed inside a UDP datagram.
    Neither the QUIC header nor the QUIC frames need to be aligned on 32 bits boundaries
    even if this alignment is convenient for [Fig. 85](#fig-quic-packet). An important
    point to note is that a QUIC packet can mix both data and control frames in any
    order.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 与经典协议（如 TCP 或 UDP）之间存在一个重要的区别。TCP 和 UDP 发送由头部和随后构成有效载荷的字节序列组成的段。相比之下，类似于
    SCTP，一个 QUIC 数据包包含一个头部后跟一个或多个帧。QUIC 头部比 TCP 头部简单得多，也更短。它只携带所有 QUIC 数据包所需的信息。我们将在后面描述短和长
    QUIC 头部。每个 QUIC 头部以一个包含一些标志和 32 位版本字段的字节开始。QUIC 定义了不同类型的帧，我们将在本章中讨论。一些类型的 QUIC
    帧携带用户数据。其他类型的 QUIC 帧携带控制信息。其中一些帧仅在握手期间使用，而其他如确认可以在任何时候发送。每个 QUIC 帧是一系列以一个字节类型字段开始的字节。[图
    85](#fig-quic-packet) 展示了一个包含两个帧的 QUIC 数据包，这些帧被放置在一个 UDP 数据报中。即使这种对齐对 [图 85](#fig-quic-packet)
    很方便，QUIC 头部或 QUIC 帧也不需要对齐在 32 位边界上。需要注意的是，一个 QUIC 数据包可以以任何顺序混合数据和控制帧。
- en: '![Figure made with TikZ](../Images/67f2552f1552b239338ebf98d5fb0e85.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/67f2552f1552b239338ebf98d5fb0e85.png)'
- en: Fig. 85 A QUIC packet is sent inside a UDP datagram and contains one or more
    QUIC frames
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 85 一个 QUIC 数据包包含在一个 UDP 数据报中，并包含一个或多个 QUIC 帧
- en: Connection establishment[#](#connection-establishment "Link to this heading")
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接建立[#](#connection-establishment "链接到这个标题")
- en: QUIC uses a four-way handshake to create a QUIC connection. [Fig. 86](#fig-quic-handshake)
    describes this handshake. The QUIC handshake has three main purposes. First, it
    allows to negotiate the crypto keys required to both encrypt and authenticate
    the packets that will be sent later on the connection. This is mainly done using
    TLS 1.3 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html). Second,
    it allows to negotiate different options using transport parameters. Third, the
    server can validate that the client can respond to the address used to send the
    initial packet. This validation allows to prevent denial of service attacks using
    spoofed addresses.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 使用四次握手来创建 QUIC 连接。[图 86](#fig-quic-handshake) 描述了此握手过程。QUIC 握手有三个主要目的。首先，它允许协商用于加密和验证随后在连接上发送的数据包所需的加密密钥。这主要使用
    TLS 1.3 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html) 完成。其次，它允许使用传输参数协商不同的选项。第三，服务器可以验证客户端能否对发送初始数据包时使用的地址做出响应。这种验证可以防止使用伪造地址进行的拒绝服务攻击。
- en: '![Figure made with TikZ](../Images/5e44a71ad373032f5a20d036f58c2000.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/5e44a71ad373032f5a20d036f58c2000.png)'
- en: Fig. 86 Simplified QUIC Handshake
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 86 简化的 QUIC 握手
- en: The client sends an `Initial` packet containing a `CRYPTO` frame. This packet
    carries the `TLS Client Hello` and the transport parameters proposed by the client
    for this connection. The server replies with an `Initial` packet containing also
    a `CRYPTO` frame. This one contains the `TLS Server Hello`. It is immediately
    followed by one or more `Handshake` packets containing also a `CRYPTO` frame with
    the `TLS Encrypted Extensions`. The contents of this frame is encrypted using
    the session key derived from the information contained in the `TLS Client Hello`
    and the `TLS Server Hello`. It mainly contains the certificate and the transport
    parameters of the server. This frame can be spread over several QUIC packets.
    The client replies with a `Handshake` packet that contains a `CRYPTO` frame with
    the `TLS Finished` message. The server later confirms the end of the TLS handshake
    by sending a `Handshake_Done` frame.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送一个包含 `CRYPTO` 帧的 `Initial` 数据包。此数据包携带客户端为该连接提出的 `TLS Client Hello` 和传输参数。服务器以包含
    `CRYPTO` 帧的 `Initial` 数据包作为回复。这个数据包包含 `TLS Server Hello`。紧接着是一个或多个包含 `TLS Encrypted
    Extensions` 的 `Handshake` 数据包，这些数据包也包含 `CRYPTO` 帧。该帧的内容使用从 `TLS Client Hello`
    和 `TLS Server Hello` 中提取的信息派生的会话密钥进行加密。它主要包含服务器的证书和传输参数。这个帧可以分布在多个 QUIC 数据包中。客户端以包含带有
    `TLS Finished` 消息的 `CRYPTO` 帧的 `Handshake` 数据包作为回复。服务器随后通过发送 `Handshake_Done`
    帧来确认 TLS 握手的结束。
- en: Before looking at the details of the negotiation of the cryptographic parameters,
    it is interesting to see how QUIC counters denial of service attacks that use
    spoofed addresses. During such attack, host x sends packets using the address
    of host y as their source. The main risk of such attacks is that the server could
    send a large number of packets towards address y although the host owning this
    address did not try to establish a QUIC connection with the server. QUIC prevents
    such attacks by using two distinct techniques. First, and this is unusual for
    transport protocols, the Initial QUIC packet sent by the client is large. The
    first packet sent to create a QUIC connection must contain a UDP payload of at
    least 1200 bytes [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    Such a packet contains a CRYPTO frame has shown in the figure, but also padding
    frames to fill the packet. If an attacker wants to send spoofed packets to initiate
    a connection with a server, it needs to send more than one KByte for each connection
    attempt. This should be compared with the 40 bytes of the TCP and IPv4 headers
    that must be sent to initiate a TCP connection. Another advantage of sending a
    large initial packet, the client can also perform Path MTU discovery and detect
    routers that could fragment the QUIC packets.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看加密参数协商的细节之前，看看QUIC如何对抗使用伪造地址的拒绝服务攻击是有趣的。在此类攻击期间，主机x使用主机y的地址作为其源地址发送数据包。此类攻击的主要风险是，尽管拥有该地址的主机没有尝试与服务器建立QUIC连接，但服务器可能会向地址y发送大量数据包。QUIC通过使用两种不同的技术来防止此类攻击。首先，这对于传输协议来说是不寻常的，客户端发送的初始QUIC数据包很大。创建QUIC连接时发送的第一个数据包必须包含至少1200字节的UDP有效负载[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。这样的数据包包含一个如图所示的CRYPTO帧，但也包含填充帧以填充数据包。如果攻击者想要发送伪造的数据包以与服务器建立连接，它需要为每个连接尝试发送超过1K字节。这应该与必须发送以启动TCP连接的TCP和IPv4头部40字节进行比较。发送大型初始数据包的另一个优点是，客户端还可以执行路径MTU发现并检测可能会分片QUIC数据包的路由器。
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Address spoofing
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 地址伪造
- en: In theory, an Internet host should only send packets using its IPv4 and IPv6
    source addresses. In practice, incorrectly configured hosts can use other addresses
    than their assigned one. Furthermore, attackers often change their source address
    to hide some of their activities. A frequent situation are denial of service (DoS)
    attacks. A simple DoS attack is when a host sends a large volume of packets to
    a victim. If the attacker sends these packets using another address than its official
    IP address, it makes it more difficult for the victim to identify the source of
    the attack.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，一个互联网主机应该只使用其分配的IPv4和IPv6源地址发送数据包。实际上，配置错误的宿主机可能会使用除其分配地址以外的其他地址。此外，攻击者经常更改其源地址以隐藏其部分活动。常见的情况是拒绝服务（DoS）攻击。简单的DoS攻击是指一个主机向受害者发送大量数据包。如果攻击者使用除其官方IP地址以外的其他地址发送这些数据包，那么受害者识别攻击源会更加困难。
- en: But there is another category of DoS attack that is more worrisome. If an attacker
    can send a packets using the source address of the victim to a server, the server
    would return a response to the victim. These attackers use Internet servers that
    send a large response, possibly using multiple packets to a single request packet.
    They have exploited protocols such as DNS, NTP or applications such as [memcached](https://www.memcached.org/)
    . The main problem with such attacks is that the server amplifies the volume of
    the attack generated by the clients. As there are very powerful servers on the
    Internet, this can be a huge problem and such attacks have reached volumes of
    hundreds of Gbps. The IETF and network operators have published recommendations
    to configure access networks to block spoofed packets [**RFC 2827**](https://datatracker.ietf.org/doc/html/rfc2827.html).
    Unfortunately, there are still portions of the Internet where attackers can send
    spoofed packets [[LBKKKC2019]](../bibliography.html#lbkkkc2019).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一种更令人担忧的拒绝服务（DoS）攻击类别。如果一个攻击者可以使用受害者的源地址向服务器发送数据包，服务器就会向受害者返回响应。这些攻击者使用发送大量响应的互联网服务器，可能使用多个数据包来响应一个请求数据包。他们已经利用了DNS、NTP等协议，以及[memcached](https://www.memcached.org/)等应用程序。这类攻击的主要问题是服务器放大了客户端产生的攻击量。由于互联网上有非常强大的服务器，这可能会成为一个大问题，并且这种攻击的规模已经达到了数百Gbps。IETF和网络运营商已经发布了配置接入网络以阻止伪造数据包的建议[**RFC
    2827**](https://datatracker.ietf.org/doc/html/rfc2827.html)。不幸的是，互联网上仍有部分区域，攻击者可以发送伪造的数据包[[LBKKKC2019]](../bibliography.html#lbkkkc2019)。
- en: The second mitigation against denial-of-service attacks using spoofed packets
    operates on the server. When a server receives an initial packet from a client,
    it may respond with an initial packet as shown in [Fig. 86](#fig-quic-handshake).
    This could for example be the case of an enterprise server that receives a request
    from a host of a known enterprise subnet. The server could also want to validate
    the client and verify that the client can receive the packets that it sends. For
    this, it returns a Retry frame and a Token. This token is an opaque field that
    is constructed in a way that makes it easy for the server to validate the subsequent
    client packets and difficult for the client to predict the token that a server
    will create. A possible approach is to compute a secure hash of a message that
    contains the source IP addresses and ports used by the client, a secret value
    only known by the server and possibly some timing information to enable the server
    to ignore older tokens. Faced with the same problem, TCP syn cookies are encoded
    using fewer bits and thus inherently less secure. [Fig. 87](#fig-quic-handshake-retry)
    shows a QUIC handshake that includes a validation of the client address.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 针对使用伪造数据包的拒绝服务攻击的第二种缓解措施在服务器端操作。当服务器从客户端接收到一个初始数据包时，它可能会以一个初始数据包作为响应，如图 [图 86](#fig-quic-handshake)
    所示。这可能是一个企业服务器从已知企业子网的主机接收请求的情况。服务器也可能想要验证客户端并确认客户端能够接收它发送的数据包。为此，它返回一个重试帧和一个令牌。这个令牌是一个不透明的字段，其构造方式使得服务器很容易验证随后的客户端数据包，而客户端很难预测服务器将创建的令牌。一种可能的方法是计算包含客户端使用的源
    IP 地址和端口的消息的安全哈希值，这个秘密值只有服务器知道，并且可能包含一些时间信息，以便服务器能够忽略较旧的令牌。面对相同的问题，TCP syn cookies
    使用更少的位进行编码，因此本质上更不安全。[图 87](#fig-quic-handshake-retry) 展示了一个包含客户端地址验证的 QUIC 握手。
- en: '![Figure made with TikZ](../Images/c3f57d5ce5702e99d69cee08ac7baddb.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的照片](../Images/c3f57d5ce5702e99d69cee08ac7baddb.png)'
- en: Fig. 87 Simplified QUIC Handshake with address validation
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 87 带有地址验证的简化版 QUIC 握手
- en: Address validation improves the resilience of servers against denial of service
    attacks using spoofed addresses, but this comes at the expense of a longer connection
    establishment delay. QUIC version 1 includes several additional techniques to
    reduce the impact of address validation while still preventing denial of service
    attacks.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 地址验证提高了服务器对使用伪造地址的拒绝服务攻击的弹性，但这也带来了更长的连接建立延迟。QUIC 版本 1 包含了多种额外的技术，以减少地址验证的影响，同时仍然防止拒绝服务攻击。
- en: Identifying QUIC connections[#](#identifying-quic-connections "Link to this
    heading")
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别 QUIC 连接[#](#identifying-quic-connections "链接到这个标题")
- en: A TCP connection is identified by a four tuple \(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\).
    All packets belonging to a given connection carry this information in their IP
    and TCP headers. As QUIC runs above UDP, a simple approach could have been to
    use the UDP four tuple to identify each QUIC connection. Although simple, this
    solution would have severely restricted the flexibility of QUIC and the scalability
    of QUIC servers. The QUIC designers have opted for locally unique connection identifiers
    (CID) that are selected by the client and the server. These identifiers are placed
    in the QUIC packet headers during the handshake. When sending the Initial packet,
    the client selects a source CID that uniquely identifies the connection on the
    client and a random destination CID. Upon reception of this packet, the server
    selects its own connection identifier. It echoes the client selected CID and returns
    its selected CID. This is illustrated in [Fig. 88](#fig-quic-handshake-cid).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 TCP 连接由一个四元组 \(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\) 确定。属于给定连接的所有数据包都在它们的
    IP 和 TCP 头部中携带此信息。由于 QUIC 在 UDP 之上运行，一个简单的方法可能是使用 UDP 四元组来标识每个 QUIC 连接。虽然简单，但这个解决方案会严重限制
    QUIC 的灵活性和 QUIC 服务器的可扩展性。QUIC 设计者选择了由客户端和服务器选择的本地唯一连接标识符（CID）。这些标识符在握手过程中放置在 QUIC
    数据包头部。当发送初始数据包时，客户端选择一个源 CID，该 CID 在客户端上唯一标识连接，并选择一个随机的目标 CID。在接收到这个数据包后，服务器选择它自己的连接标识符。它回显客户端选择的
    CID 并返回它选择的 CID。这如图 [图 88](#fig-quic-handshake-cid) 所示。
- en: '![Figure made with TikZ](../Images/5c6ab95bb24bea00f667803dec9da315.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的照片](../Images/5c6ab95bb24bea00f667803dec9da315.png)'
- en: Fig. 88 Connection identifiers during a simplified QUIC Handshake
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 88 简化版 QUIC 握手过程中的连接标识符
- en: The connection identifiers selected by the client and the server uniquely identify
    the QUIC connection. However, in contrast with TCP and UDP, the two identifiers
    are not present in all packets. Since a host selects a unique identifier for each
    connection, it only needs this identifier to identify a connection to which a
    packet belongs. For this reason, the QUIC packets exchanged on a connection after
    the handshake only contain the destination CID, i.e. the CID selected by the host
    that receives the packet.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器选择的连接标识符唯一地标识了QUIC连接。然而，与TCP和UDP不同，这两个标识符并不出现在所有数据包中。由于主机为每个连接选择一个唯一的标识符，它只需要这个标识符来识别一个数据包所属的连接。因此，握手之后在连接上交换的QUIC数据包只包含目的CID，即接收数据包的主机选择的CID。
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Variable length CIDs
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度CID
- en: Most transport protocols rely on fixed-length fields because this simplifies
    the parsing of packet headers. For example, the TCP and UDP port numbers are encoded
    as a 16 bits field. However, using fixed-length fields also limits the extensibility
    of the protocol. A TCP server cannot listen to more than \(2^{16}\) different
    ports.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传输协议依赖于固定长度的字段，因为这简化了数据包头的解析。例如，TCP和UDP端口号被编码为16位字段。然而，使用固定长度的字段也限制了协议的可扩展性。TCP服务器无法监听超过\(2^{16}\)个不同的端口。
- en: QUIC has opted for variable length CIDs to support very different use cases.
    On the server side, the length of the selected connection identifiers will depend
    on the architecture of the server. Large sites might use a load balancer that
    distributes the connections to different physical servers. Such a load-balancer
    can leverage the CID to direct each incoming packet to the server that handles
    this connection. A simple CID would be composed of a server identifier chosen
    by the load balancer, e.g. in the high order bits of the CID, followed by a connection
    identifier selected by the physical server. Other designs are possible, e.g. by
    encrypting the CID to prevent attacks where malicious clients try to target a
    specific server.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC选择了可变长度的CIDs来支持非常不同的用例。在服务器端，所选连接标识符的长度将取决于服务器的架构。大型站点可能会使用负载均衡器，将连接分发到不同的物理服务器。这样的负载均衡器可以利用CID将每个传入的数据包直接导向处理该连接的服务器。一个简单的CID可以由负载均衡器选择的服务器标识符组成，例如在CID的高位，后面跟着物理服务器选择的连接标识符。其他设计也是可能的，例如通过加密CID来防止恶意客户端尝试针对特定服务器的攻击。
- en: One the client side, variable lengths CIDs bring another benefit. As clients
    typically manage a small number of QUIC connections, they can simply rely on the
    destination port of the packets that they receive to identify the corresponding
    QUIC connection. This corresponds to a zero-length connection identifier. Such
    a CID is never sent by the server after the handshake. This limits the byte overhead
    of the packets that clients receive.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，可变长度的CIDs带来了另一个好处。由于客户端通常只管理少量QUIC连接，它们可以简单地依靠接收到的数据包的目的端口来识别相应的QUIC连接。这对应于零长度的连接标识符。这种CID在握手之后永远不会由服务器发送。这限制了客户端接收到的数据包的字节开销。
- en: A last point to note about these CIDs is their encoding inside the QUIC packets.
    The Initial packet contains the length and the value of both connection identifiers.
    The maximum length for a CID is 20 bytes. However, after the handshake, the packets
    that are exchanged over the QUIC connection only contain the destination CID without
    any field indicating its length. The host that has allocated the CID knows the
    length of the CIDs that it uses and can thus parse the packets that it receives
    without an explicit length information.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些CIDs的最后一个要注意的点是在QUIC数据包中的编码。初始数据包包含两个连接标识符的长度和值。CID的最大长度为20字节。然而，在握手之后，通过QUIC连接交换的数据包只包含目的CID，没有任何字段指示其长度。分配了CID的主机知道它使用的CID的长度，因此可以在没有显式长度信息的情况下解析它接收到的数据包。
- en: Security keys[#](#security-keys "Link to this heading")
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全密钥[#](#security-keys "链接到本标题")
- en: We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys
    that are used to authenticate and encrypt the packets exchanged over a connection.
    As shown in [Fig. 86](#fig-quic-handshake), a QUIC connection starts with the
    exchange of four frames which can be carried in four or more packets. The first
    packet sent by the client contains the `ClientHello` TLS record. The `ClientHello`
    contains the information required to derive the session keys using Diffie-Hellman
    or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic
    Curve Diffie-Hellman [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    The `ClientHello` message also contains TLS or QUIC parameters that the client
    proposes to use during the connection. The `TLS Server Hello` returned by the
    server contains the certificate that enables the client to validate the server’s
    identity and the information required to determine the Diffie-Hellman keys. Using
    these keys, the server also encrypts the `TLS Encrypted Extensions` message that
    contains the TLS and QUIC parameters that the server has selected based on the
    ones proposed in the `ClientHello`. The server also constructs the `Finished`
    message that contains a message authentication code computed over the entire TLS
    handshake. This message is encrypted and authenticated using the session keys
    derived from the Diffie-Hellman keys. The client and the server recompute the
    hash of the entire handshake and verify both `Finished` messages. If one of these
    messages is incorrect, this indicates that either the key has not been correctly
    derived or that some of the TLS messages have been tampered. In these situations,
    the QUIC connection is terminated with an error message. The simplified TLS handshake
    used by QUIC is illustrated in [Fig. 89](#fig-quic-tls-handshake). The TLS messages
    shown in italics are encrypted using the session keys.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以讨论QUIC如何利用TLS 1.3协商用于验证和加密连接上交换的数据包的安全密钥。如图86所示，QUIC连接从交换四个帧开始，这些帧可以包含在四个或更多数据包中。客户端发送的第一个数据包包含`ClientHello`
    TLS记录。`ClientHello`包含使用Diffie-Hellman或类似协议派生会话密钥所需的信息。TLS 1.3支持有限域Diffie-Hellman和椭圆曲线Diffie-Hellman
    [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。`ClientHello`消息还包含客户端在连接期间提议使用的TLS或QUIC参数。服务器返回的`TLS服务器问候`包含证书，使客户端能够验证服务器的身份以及确定Diffie-Hellman密钥所需的信息。使用这些密钥，服务器还加密了包含服务器根据`ClientHello`中提出的参数选择的TLS和QUIC参数的`TLS加密扩展`消息。服务器还构建了包含整个TLS握手计算的消息认证码的`Finished`消息。此消息使用从Diffie-Hellman密钥派生的会话密钥加密和验证。客户端和服务器重新计算整个握手的哈希值并验证两个`Finished`消息。如果其中一个消息不正确，这表明密钥没有被正确派生，或者某些TLS消息已被篡改。在这些情况下，QUIC连接将终止并显示错误消息。QUIC使用的简化TLS握手如图89所示。以斜体显示的TLS消息使用会话密钥加密。
- en: '![Figure made with TikZ](../Images/68b73d74f409bc3b1f789ac93a363aa3.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/68b73d74f409bc3b1f789ac93a363aa3.png)'
- en: Fig. 89 Simplified TLS Handshake within a QUIC connection
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图89 QUIC连接中的简化TLS握手
- en: Note
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Encrypting `TLS Client Hello` and `TLS Server Hello`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 加密`TLS客户端问候`和`TLS服务器问候`
- en: 'When TLS 1.3 is used above TCP, the `TLS Client Hello` and `TLS Server Hello`
    messages are sent in clear because the client and the server have not yet exchanged
    the session keys. A similar approach could have been used for QUIC, but there
    was a fear that middleboxes could analyze the contents of these initial QUIC messages
    and try to interfere with them. To add some burden on these middleboxes, QUIC
    encrypts the Initial packets using a secret that is derived from the destination
    connection ID of the client’s first Initial packet. The pseudocode below, extracted
    from [**RFC 9001**](https://datatracker.ietf.org/doc/html/rfc9001.html), shows
    how the client and the server keys are derived:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当TLS 1.3在TCP之上使用时，`TLS客户端问候`和`TLS服务器问候`消息以明文形式发送，因为客户端和服务器尚未交换会话密钥。对于QUIC，也可以采用类似的方法，但担心中间盒可能会分析这些初始QUIC消息的内容并试图干扰它们。为了给这些中间盒增加一些负担，QUIC使用从客户端的第一个初始数据包的目的连接ID派生出的秘密来加密初始数据包。下面的伪代码，摘自[**RFC
    9001**](https://datatracker.ietf.org/doc/html/rfc9001.html)，展示了客户端和服务器密钥是如何派生的：
- en: '[PRE19]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the keys used to protect the Initial packets are derived from the destination
    connection ID, any QUIC implementation, including those used on middleboxes, can
    decrypt the contents of the Initial packets.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用于保护初始数据包的密钥是从目标连接 ID 派生出来的，因此任何 QUIC 实现都可以解密初始数据包的内容，包括那些用于中间盒子的实现。
- en: As mentioned earlier, the client and the server can also use the TLS handshake
    to agree on specific QUIC parameters. These parameters are called transport parameters
    in QUIC [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html). 17
    different transport parameters are defined in QUIC version 1 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    and implementations can define their own transport parameters. We will discuss
    some of them in different sections of this document. A first example is the `max_udp_payload_size`
    parameter that indicates the largest UDP payload that an implementation is willing
    to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations
    used in a datacenter supporting jumbo Ethernet frames could agree on a much larger
    `max_udp_payload_size` without risking packet fragmentation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，客户端和服务器还可以使用 TLS 握手来协商特定的 QUIC 参数。这些参数在 QUIC 中被称为传输参数 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。QUIC
    版本 1 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 中定义了 17
    个不同的传输参数，实现者可以定义自己的传输参数。我们将在本文件的各个部分中讨论其中的一些。第一个例子是 `max_udp_payload_size` 参数，它表示实现者愿意接收的最大
    UDP 有效载荷大小。此参数的最小值为 1200 字节。在支持巨型以太网帧的数据中心中使用的 QUIC 实现可以协商一个更大的 `max_udp_payload_size`，而不会存在数据包分片的风险。
- en: Another example of QUIC transport parameters are the `initial_source_connection_id`
    and the `original_destination_connection_id` transport parameters. As explained
    above, thanks to the `Finished` messages in the TLS handshake, the client and
    the servers can verify that their messages have not been tampered. Unfortunately,
    the authentication code included in the `Finished` messages is only computed based
    on the contents of the TLS messages (i.e. `ClientHello`, `ServerHello`, `EncryptedExtensions`
    and `Finished`). During the handshake, the client and the servers also propose
    the source and destination connection identifiers that they plan to use to identify
    the QUIC session. These identifiers are placed in the packet header and not inside
    the TLS messages. They are thus not covered by the authentication code included
    in the `Finished` message. To still authenticate these identifiers, QUIC encodes
    them as transport parameters that are included in the `ClientHello` and the `EncryptedExtensions`
    messages. The client copies the source connection identifier in the `initial_source_connection_id`
    transport parameter in its `ClientHello`. The server does the same when sending
    the `ServerHello`. It also copies in the `original_destination_connection_id`
    transport parameter the destination identifier used by the client to send the
    packet containing the `ClientHello`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 传输参数的另一个例子是 `initial_source_connection_id` 和 `original_destination_connection_id`
    传输参数。如上所述，由于 TLS 握手中的 `Finished` 消息，客户端和服务器可以验证他们的消息没有被篡改。不幸的是，包含在 `Finished`
    消息中的认证代码仅基于 TLS 消息的内容（即 `ClientHello`、`ServerHello`、`EncryptedExtensions` 和 `Finished`）进行计算。在握手过程中，客户端和服务器还提出了他们计划用于识别
    QUIC 会话的源和目标连接标识符。这些标识符被放置在数据包头部，而不是 TLS 消息内部。因此，它们不受 `Finished` 消息中包含的认证代码的保护。为了仍然对这些标识符进行认证，QUIC
    将它们编码为传输参数，这些参数包含在 `ClientHello` 和 `EncryptedExtensions` 消息中。客户端将其源连接标识符复制到 `initial_source_connection_id`
    传输参数中，并在其 `ClientHello` 中进行操作。服务器在发送 `ServerHello` 时也这样做。它还在 `original_destination_connection_id`
    传输参数中复制客户端用于发送包含 `ClientHello` 的数据包的目标标识符。
- en: The QUIC packet headers[#](#the-quic-packet-headers "Link to this heading")
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC 数据包头部[#](#the-quic-packet-headers "链接到本标题")
- en: At this point, the QUIC session and the TLS security keys are known by the client
    and the server. They can start to exchange data. Before looking at how data is
    carried inside QUIC packets, it is interesting to explore in more details the
    packet headers that are placed inside each packet. QUIC uses variable length packet
    headers. Two different header formats exist. The first header format is the long
    header. This is the header used for the first packets of a QUIC connection.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，QUIC会话和TLS安全密钥已由客户端和服务器所知。它们可以开始交换数据。在查看数据如何在QUIC数据包内部传输之前，深入探讨每个数据包内放置的数据包头部是非常有趣的。QUIC使用可变长度的数据包头部。存在两种不同的头部格式。第一种头部格式是长头部。这是用于QUIC连接第一个数据包的头部。
- en: Internet protocol specifications usually contain figures to represent the format
    of the packet headers. This graphical format is useful to get a quick grasp at
    a header containing fixed size fields. However, when a header contains several
    variable length fields, the graphical representation can become difficult to follow.
    The QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    uses the textual representation that was also used for the TLS protocol. As an
    example, let us consider the well-known TCP header. This header is graphically
    represented as shown in [Fig. 90](#fig-quic-tcp-header).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议规范通常包含图表来表示数据包头部的格式。这种图形格式对于快速掌握包含固定大小字段的头部非常有用。然而，当头部包含多个可变长度字段时，图形表示可能变得难以追踪。QUIC规范[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)使用了与TLS协议相同的文本表示。作为一个例子，让我们考虑众所周知的TCP头部。该头部如图[图90](#fig-quic-tcp-header)所示进行图形表示。
- en: '![Figure made with TikZ](../Images/8bbfb429b7a940504df39c6677c533c7.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8bbfb429b7a940504df39c6677c533c7.png)'
- en: Fig. 90 Graphical representation of the TCP header Listing 2 Textual representation
    of the TCP header[#](#fig-quic-tcp-text-header "Link to this code")
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图90：TCP头部的图形表示 列表2：TCP头部的文本表示[#](#fig-quic-tcp-text-header "链接到这段代码")
- en: '[PRE20]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The attentive reader will easily understand the correspondence between the two
    formats. When explaining QUIC, we use the textual representation while we stick
    to the graphical one for TCP.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读的读者会很容易理解两种格式之间的对应关系。在解释QUIC时，我们使用文本表示，而坚持使用图形表示来解释TCP。
- en: '[Listing 3](#fig-quic-long-header) shows the QUIC long header. It starts with
    one byte containing the header type in the most significant bit, two bits indicating
    the packet type and four bits that are specific to each packet packet. Then, 32
    bits carry the QUIC version number. The current version of QUIC, defined in [**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html), corresponds to version
    `0x00000001`. The header then contains the destination and source connection identifiers
    that were described previously and then a payload that is specific to each type.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3](#fig-quic-long-header)显示了QUIC长头部。它以一个字节开始，该字节包含在最高有效位中的头部类型，两个位表示数据包类型，以及四个位，这些位对每个数据包都是特定的。然后，32位携带QUIC版本号。QUIC的当前版本，定义在[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)中，对应于版本`0x00000001`。然后头部包含之前描述的目标和源连接标识符，然后是一个针对每种类型的特定有效负载。'
- en: Listing 3 The QUIC long header[#](#fig-quic-long-header "Link to this code")
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3：QUIC长头部[#](#fig-quic-long-header "链接到这段代码")
- en: '[PRE21]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Encoding packet numbers
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据包编号
- en: Most transport protocols use fixed fields to encode packet numbers or byte offsets.
    The size of this field is always a trade-off. On one hand, a small packet number
    field limits the per packet overhead. On the other hand, a large packet number
    space is required to ensure that two packets carrying different data do not use
    the same packet number. TCP uses a 32 bits sequence number field that indicates
    the position of the first byte of the payload in the bytestream. This 32 bits
    field became a concern as bandwidth increased to Gbps and beyond [**RFC 7323**](https://datatracker.ietf.org/doc/html/rfc7323.html).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传输协议使用固定字段来编码数据包编号或字节偏移。这个字段的大小始终是一个权衡。一方面，小的数据包编号字段限制了每个数据包的额外开销。另一方面，需要较大的数据包编号空间以确保携带不同数据的两个数据包不使用相同的数据包编号。TCP使用32位序列号字段，该字段指示有效负载的第一个字节在字节流中的位置。随着带宽增加到Gbps及以上，这个32位字段引起了关注[**RFC
    7323**](https://datatracker.ietf.org/doc/html/rfc7323.html)。
- en: QUIC takes a different approach to sequence numbers. Each packet contains a
    per-packet sequence number. This number is encoded as a variable-length integer
    (`varint`). Such a `varint` has a length encoded in the two most significant bits
    of the first byte. If these bits are set to `00`, then the `varint` is encoded
    in one byte and can contain values between \(0\) and \(2^{6}-1\). If the two most
    significant bits are set to `01`, the `varint` can encode values between \(0\)
    and \(2^{14}-1\) within two bytes. When the two high order bits are set to `11`
    the `varint` can encode values between \(0\) and \(2^{62}-1\) within four bytes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC对序列号采取了不同的方法。每个数据包包含一个按数据包序列号。这个数字被编码为一个可变长度整数(`varint`)。这样的`varint`在第一个字节的两个最高有效位中编码了长度。如果这些位设置为`00`，则`varint`在单个字节中编码，可以包含从\(0\)到\(2^{6}-1\)的值。如果两个最高有效位设置为`01`，则`varint`可以在两个字节内编码从\(0\)到\(2^{14}-1\)的值。当两个高阶位设置为`11`时，`varint`可以在四个字节内编码从\(0\)到\(2^{62}-1\)的值。
- en: There are other important differences between QUIC and other transport protocols
    when considering packet numbers. First, a QUIC sender must *never* reuse the same
    packet number for two different packets sent over a QUIC connection. If data needs
    to be retransmitted, it will be resent as a frame inside a new packet. Furthermore,
    since the largest possible packet number is \(2^{62}-1\), a QUIC sender must close
    the corresponding connection once it has sent a QUIC packet carrying this packet
    number. This puts a restriction on the duration of QUIC connections. They cannot
    last forever in contrast to TCP connections such as those used to support BGP
    sessions between routers. An application that uses QUIC must be ready to restart
    a connection from time to time.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到数据包编号时，QUIC与其他传输协议之间存在其他重要差异。首先，QUIC发送者必须**永远**不要在QUIC连接上发送的两个不同数据包中重复使用相同的包编号。如果需要重传数据，它将以新数据包中的帧形式重新发送。此外，由于可能的最大包编号是\(2^{62}-1\)，一旦发送了携带此包编号的QUIC数据包，QUIC发送者必须关闭相应的连接。这限制了QUIC连接的持续时间。与用于支持路由器之间BGP会话的TCP连接不同，它们不能永远持续。使用QUIC的应用程序必须随时准备重新启动连接。
- en: This long header is used for the `Initial`, `Handhsake` and `Retry` packets.
    Some of these packet types add new flags in the first byte and additional information
    after the connection identifiers. [Listing 4](#fig-quic-initial-header) shows
    the long header of the `Initial` packet. It contains two bits in the first byte
    that indicate the length of the packet number field. The packet specific part
    contains an option token, a length field, a packet number and a payload. The token
    length, length and packet number are encoded using variable length integers.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长标题用于`Initial`、`Handhsake`和`Retry`数据包。这些数据包类型中的一些在第一个字节中添加了新的标志，并在连接标识符之后添加了附加信息。[列表
    4](#fig-quic-initial-header)显示了`Initial`数据包的长标题。它包含第一个字节中的两个位，表示数据包编号字段的长度。数据包特定部分包含一个选项令牌、一个长度字段、一个数据包编号和一个有效载荷。令牌长度、长度和数据包编号使用可变长度整数进行编码。
- en: Listing 4 The QUIC long header of the Initial packet[#](#fig-quic-initial-header
    "Link to this code")
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4 QUIC `Initial`数据包的长标题[#](#fig-quic-initial-header "链接到这段代码")
- en: '[PRE22]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The QUIC short header contains fewer fields. The most significant bit of the
    first byte is set to 1 to indicate that the packet carries a short header. The
    other flags will be discussed later. The two least significant bits of this byte
    contain the length of the packet number field. It is interesting to note that
    in contrast with the long header, there is no explicit indication of the length
    of the destination connection identifier. This connection identifier has been
    assigned by the host that receives this packet and it already knows the length
    of the connection identifiers that it uses.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC的短标题包含的字段较少。第一个字节的最显著位设置为1，以指示该数据包携带短标题。其他标志将在后面讨论。这个字节的最不显著两位包含数据包编号字段的长度。值得注意的是，与长标题相比，没有明确指示目标连接标识符的长度。这个连接标识符已被接收此数据包的主机分配，并且它已经知道它使用的连接标识符的长度。
- en: Listing 5 The QUIC short header used by 1-RTT packets[#](#fig-quic-short-header
    "Link to this code")
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5 1-RTT数据包使用的QUIC短标题[#](#fig-quic-short-header "链接到这段代码")
- en: '[PRE23]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The short header format, depicted in [Listing 5](#fig-quic-short-header), is
    used by all QUIC packets once the session keys have been derived. This usually
    happens after one round-trip-time. These packets are called the 1-RTT packets
    in the QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    This notation is used to emphasize the fact that QUIC also supports 0-RTT packets,
    i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 短头格式，如图 [列表 5](#fig-quic-short-header) 所示，在会话密钥生成后由所有 QUIC 数据包使用。这通常发生在一次往返时间之后。这些数据包在
    QUIC 规范 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 中被称为
    1-RTT 数据包。这种表示法用于强调 QUIC 也支持 0-RTT 数据包，即携带数据并且可以与 TLS 握手并行交换的数据包。
- en: Note
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Coalescing packets
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包合并
- en: Besides the connection identifiers, another difference between the short and
    the long headers is the presence of the `Packet Length` field in the long header.
    This field might surprise the reader who is familiar with UDP since UDP also contains
    a Length field. As each QUIC packet is placed inside a UDP message, the QUIC Length
    field could seem redundant. This Length field was included in the QUIC long header
    to allow a QUIC sender to coalesce several consecutive and small packets inside
    a single UDP message. Some of the frames exchanged during the handshake are rather
    small. Sending a UDP message for each of these frames would be a waste of resources.
    Furthermore, a mix of `Initial`, `Handshake` and `0-RTT` packets are exchanged
    when creating a QUIC connection. It would not be wise to require the utilization
    of one UDP message to send each of these packets. You might observe this optimization
    when analyzing packet traces collected on QUIC servers.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接标识符之外，短头和长头之间的另一个区别是长头中存在 `数据包长度` 字段。这个字段可能会让熟悉 UDP 的读者感到惊讶，因为 UDP 也包含长度字段。由于每个
    QUIC 数据包都放置在一个 UDP 消息中，QUIC 长度字段可能看起来是多余的。这个长度字段被包含在 QUIC 长头中，以便允许 QUIC 发送者将多个连续的小数据包合并成一个单独的
    UDP 消息。在握手过程中交换的一些帧相当小。为每个这样的帧发送一个 UDP 消息将会是资源的浪费。此外，在创建 QUIC 连接时，会交换 `初始`、`握手`
    和 `0-RTT` 数据包的混合。要求使用一个 UDP 消息来发送这些数据包中的每一个是不明智的。你可能会在分析收集在 QUIC 服务器上的数据包跟踪时观察到这种优化。
- en: 0-RTT data[#](#rtt-data "Link to this heading")
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 0-RTT 数据[#](#rtt-data "链接到本标题")
- en: Latency is a key concern for transport protocols. The QUIC/TLS handshake that
    we have described until now allows the client and the server to agree on security
    keys within one round-trip-time. However, one round-trip-time can be a long delay
    for some applications. To minimize the impact of the connection setup time, QUIC
    allows applications to exchange data during the QUIC/TLS handshake. Such data
    is called 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client
    and the server must have previously agreed on a key which can be used to encrypt
    and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared
    key that the client and the server have shared without using the QUIC protocol
    or, and this is the most frequent solution, the key that they negotiated during
    a previous connection. In practice, the server enables 0-RTT by sending a TLS
    session ticket to the client [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    A session ticket is an encrypted record that contains information that enables
    the server to recover all the state information about a session including its
    session keys. It is also linked to the client’s address to enable the server to
    verify that a given client reuses the tickets that it has received earlier. Usually,
    these tickets also contain an expiration date. The client places the received
    ticket in the `TLS CLient Hello` that it sends in the first `Initial` packet.
    It uses the pre-shared key corresponding to this ticket to encrypt data and place
    it in one or more `0-RTT` packets. The server uses the information contained in
    the ticket to recover the key and decrypt the data of the `0-RTT` packet. [Listing
    6](#fig-quic-0-rtt-packet) shows the format of QUIC’s 0-RTT packet.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是传输协议的关键关注点。我们至今所描述的 QUIC/TLS 握手允许客户端和服务器在单程往返时间内就安全密钥达成一致。然而，对于某些应用程序来说，单程往返时间可能是一个较长的延迟。为了最小化连接设置时间的影响，QUIC
    允许应用程序在 QUIC/TLS 握手期间交换数据。这种数据称为 0-RTT 数据。为了确保 0-RTT 数据的安全交换，客户端和服务器必须事先就一个可以用来加密和验证
    0-RTT 数据的密钥达成一致。这样的 0-RTT 密钥可以是客户端和服务器在没有使用 QUIC 协议的情况下共享的预共享密钥，或者，这是最常见的方法，是他们在之前连接中协商的密钥。在实践中，服务器通过向客户端发送
    TLS 会话票据来启用 0-RTT[**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。会话票据是一个包含使服务器能够恢复会话所有状态信息（包括其会话密钥）的加密记录。它还与客户端的地址相关联，以便服务器能够验证给定的客户端是否重用了它之前收到的票据。通常，这些票据还包含一个过期日期。客户端将收到的票据放入它发送的第一个
    `Initial` 数据包中的 `TLS Client Hello`。它使用与该票据对应的预共享密钥来加密数据并将其放入一个或多个 `0-RTT` 数据包中。服务器使用票据中包含的信息恢复密钥并解密
    `0-RTT` 数据包的数据。[列表 6](#fig-quic-0-rtt-packet)显示了 QUIC 的 0-RTT 数据包格式。
- en: Listing 6 The QUIC 0-RTT packet[#](#fig-quic-0-rtt-packet "Link to this code")
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6 QUIC 0-RTT 数据包[#](#fig-quic-0-rtt-packet "链接到这段代码")
- en: '[PRE24]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main benefit of these `0-RTT` packets is that the client can immediately
    send encrypted data while sending its `Initial` packet. This is illustrated in
    [Fig. 91](#fig-quic-handshake-ortt) where the frames encrypted with the 0-RTT
    keys are shown in italics. Note that some of these frames can span several packets.
    `0-RTT` packets are only sent by the QUIC client since the server can send encrypted
    data immediately after having sent its `Handshake` frames. As explained earlier,
    the Initial packets are also encrypted but using keys derived from the connection
    identifiers.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `0-RTT` 数据包的主要好处是客户端可以在发送其 `Initial` 数据包的同时立即发送加密数据。这在[图 91](#fig-quic-handshake-ortt)中有说明，其中使用
    0-RTT 密钥加密的帧以斜体显示。请注意，其中一些帧可以跨越多个数据包。`0-RTT` 数据包仅由 QUIC 客户端发送，因为服务器可以在发送其 `Handshake`
    数据包后立即发送加密数据。如前所述，初始数据包也是加密的，但使用从连接标识符派生的密钥。
- en: '![Figure made with TikZ](../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png)'
- en: Fig. 91 Simplified QUIC Handshake with 0-RTT data
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 91 带有 0-RTT 数据的简化 QUIC 握手
- en: Note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replay attacks and 0-RTT packets
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 重放攻击和 0-RTT 数据包
- en: Thanks to the 0-RTT packets, a client can send encrypted data to the server
    before waiting for the secure handshake. This reduces the latency of the data
    transfer, but with one important caveat. QUIC does not provide any guarantee that
    0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent
    operations. A detailed discussion of the impact of replay attacks may be found
    in [[MacCarthaigh2017]](../bibliography.html#maccarthaigh2017).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了0-RTT数据包，客户端可以在等待安全握手之前向服务器发送加密数据。这减少了数据传输的延迟，但有一个重要的注意事项。QUIC不提供任何保证，0-RTT数据不会被重放。QUIC交换的0-RTT数据旨在用于幂等操作。关于重放攻击影响的具体讨论，请参阅[[MacCarthaigh2017]](../bibliography.html#maccarthaigh2017)。
- en: To understand the importance of these replay attacks, let us consider a simple
    HTTP GET request. Such a request could easily fit inside the 0-RTT packet and
    thus have lower latency. If a web browser uses it to request a static `index.html`
    file, there is no harm if the request is received twice by the server. However,
    if the GET request is part of a REST API and has side effects, then problems could
    occur depending on the type of side effect. Consider a REST API that allows a
    user to switch off the lights using his or her smartphone. Replaying this request
    two or three times will always result in the light being switched off. However,
    if the user requests to increase the room temperature by one °C, then multiple
    replays will obviously have different consequences.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些重放攻击的重要性，让我们考虑一个简单的HTTP GET请求。这样的请求可以很容易地放入0-RTT数据包中，从而具有更低的延迟。如果网页浏览器使用它来请求静态`index.html`文件，如果服务器收到两次请求，则没有害处。然而，如果GET请求是REST
    API的一部分并且有副作用，那么问题将取决于副作用类型。考虑一个允许用户通过智能手机关闭灯光的REST API。重放这个请求两到三次将始终导致灯光关闭。然而，如果用户请求将室温提高1°C，那么多次重放显然会有不同的后果。
- en: Identifying QUIC connections[#](#identifying-quic-connections "Link to this
    heading")
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别QUIC连接[#](#identifying-quic-connections "链接到这个标题")
- en: A TCP connection is identified by a four tuple \(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\).
    All packets belonging to a given connection carry this information in their IP
    and TCP headers. As QUIC runs above UDP, a simple approach could have been to
    use the UDP four tuple to identify each QUIC connection. Although simple, this
    solution would have severely restricted the flexibility of QUIC and the scalability
    of QUIC servers. The QUIC designers have opted for locally unique connection identifiers
    (CID) that are selected by the client and the server. These identifiers are placed
    in the QUIC packet headers during the handshake. When sending the Initial packet,
    the client selects a source CID that uniquely identifies the connection on the
    client and a random destination CID. Upon reception of this packet, the server
    selects its own connection identifier. It echoes the client selected CID and returns
    its selected CID. This is illustrated in [Fig. 88](#fig-quic-handshake-cid).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接由一个四元组 \(IP_{Client},IP_{Server},Port_{Client},Port_{Server}\) 来标识。属于给定连接的所有数据包在其IP和TCP头部中携带此信息。由于QUIC在UDP之上运行，一个简单的方法本可以使用UDP四元组来标识每个QUIC连接。尽管简单，但这个解决方案会严重限制QUIC的灵活性和QUIC服务器的可扩展性。QUIC的设计者选择了由客户端和服务器选择的本地唯一连接标识符（CID）。这些标识符在握手过程中放置在QUIC数据包头部。当发送初始数据包时，客户端选择一个源CID，该CID唯一标识客户端上的连接，以及一个随机的目标CID。在接收到这个数据包后，服务器选择它自己的连接标识符。它回显客户端选择的CID并返回它选择的CID。这如图[图88](#fig-quic-handshake-cid)所示。
- en: '![Figure made with TikZ](../Images/5c6ab95bb24bea00f667803dec9da315.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/5c6ab95bb24bea00f667803dec9da315.png)'
- en: Fig. 88 Connection identifiers during a simplified QUIC Handshake
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图88 简化QUIC握手过程中的连接标识符
- en: The connection identifiers selected by the client and the server uniquely identify
    the QUIC connection. However, in contrast with TCP and UDP, the two identifiers
    are not present in all packets. Since a host selects a unique identifier for each
    connection, it only needs this identifier to identify a connection to which a
    packet belongs. For this reason, the QUIC packets exchanged on a connection after
    the handshake only contain the destination CID, i.e. the CID selected by the host
    that receives the packet.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器选择的连接标识符唯一标识了QUIC连接。然而，与TCP和UDP不同，这两个标识符并不存在于所有数据包中。由于主机为每个连接选择一个唯一的标识符，它只需要这个标识符来识别一个数据包所属的连接。因此，握手之后在连接上交换的QUIC数据包只包含目标CID，即接收数据包的主机选择的CID。
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Variable length CIDs
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度CIDs
- en: Most transport protocols rely on fixed-length fields because this simplifies
    the parsing of packet headers. For example, the TCP and UDP port numbers are encoded
    as a 16 bits field. However, using fixed-length fields also limits the extensibility
    of the protocol. A TCP server cannot listen to more than \(2^{16}\) different
    ports.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传输协议依赖于固定长度的字段，因为这简化了数据包头的解析。例如，TCP和UDP端口号被编码为16位字段。然而，使用固定长度字段也限制了协议的可扩展性。TCP服务器不能监听超过\(2^{16}\)个不同的端口。
- en: QUIC has opted for variable length CIDs to support very different use cases.
    On the server side, the length of the selected connection identifiers will depend
    on the architecture of the server. Large sites might use a load balancer that
    distributes the connections to different physical servers. Such a load-balancer
    can leverage the CID to direct each incoming packet to the server that handles
    this connection. A simple CID would be composed of a server identifier chosen
    by the load balancer, e.g. in the high order bits of the CID, followed by a connection
    identifier selected by the physical server. Other designs are possible, e.g. by
    encrypting the CID to prevent attacks where malicious clients try to target a
    specific server.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC选择了可变长度CID以支持非常不同的用例。在服务器端，所选连接标识符的长度将取决于服务器的架构。大型站点可能会使用负载均衡器，将连接分发到不同的物理服务器。这样的负载均衡器可以利用CID将每个传入的数据包定向到处理该连接的服务器。一个简单的CID可以由负载均衡器选择的服务器标识符组成，例如在CID的高位，然后是物理服务器选择的连接标识符。其他设计也是可能的，例如通过加密CID来防止恶意客户端尝试针对特定服务器的攻击。
- en: One the client side, variable lengths CIDs bring another benefit. As clients
    typically manage a small number of QUIC connections, they can simply rely on the
    destination port of the packets that they receive to identify the corresponding
    QUIC connection. This corresponds to a zero-length connection identifier. Such
    a CID is never sent by the server after the handshake. This limits the byte overhead
    of the packets that clients receive.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，可变长度的CIDs带来了另一个好处。由于客户端通常管理少量QUIC连接，它们可以简单地依靠接收到的数据包的目的端口来识别相应的QUIC连接。这对应于零长度的连接标识符。这种CID在握手之后永远不会由服务器发送。这限制了客户端接收到的数据包的字节开销。
- en: A last point to note about these CIDs is their encoding inside the QUIC packets.
    The Initial packet contains the length and the value of both connection identifiers.
    The maximum length for a CID is 20 bytes. However, after the handshake, the packets
    that are exchanged over the QUIC connection only contain the destination CID without
    any field indicating its length. The host that has allocated the CID knows the
    length of the CIDs that it uses and can thus parse the packets that it receives
    without an explicit length information.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些CIDs的最后一个需要注意的点是在QUIC数据包内的编码。初始数据包包含连接标识符的长度和值。CID的最大长度为20字节。然而，在握手之后，通过QUIC连接交换的数据包只包含目的CID，没有任何字段指示其长度。分配了CID的主机知道它使用的CID的长度，因此可以在没有显式长度信息的情况下解析它接收到的数据包。
- en: Security keys[#](#security-keys "Link to this heading")
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全密钥[#](#security-keys "链接到本标题")
- en: We can now discuss how QUIC leverages TLS 1.3 to negotiate the security keys
    that are used to authenticate and encrypt the packets exchanged over a connection.
    As shown in [Fig. 86](#fig-quic-handshake), a QUIC connection starts with the
    exchange of four frames which can be carried in four or more packets. The first
    packet sent by the client contains the `ClientHello` TLS record. The `ClientHello`
    contains the information required to derive the session keys using Diffie-Hellman
    or a similar protocol. TLS 1.3 supports both finite field Diffie-Hellman and Elliptic
    Curve Diffie-Hellman [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    The `ClientHello` message also contains TLS or QUIC parameters that the client
    proposes to use during the connection. The `TLS Server Hello` returned by the
    server contains the certificate that enables the client to validate the server’s
    identity and the information required to determine the Diffie-Hellman keys. Using
    these keys, the server also encrypts the `TLS Encrypted Extensions` message that
    contains the TLS and QUIC parameters that the server has selected based on the
    ones proposed in the `ClientHello`. The server also constructs the `Finished`
    message that contains a message authentication code computed over the entire TLS
    handshake. This message is encrypted and authenticated using the session keys
    derived from the Diffie-Hellman keys. The client and the server recompute the
    hash of the entire handshake and verify both `Finished` messages. If one of these
    messages is incorrect, this indicates that either the key has not been correctly
    derived or that some of the TLS messages have been tampered. In these situations,
    the QUIC connection is terminated with an error message. The simplified TLS handshake
    used by QUIC is illustrated in [Fig. 89](#fig-quic-tls-handshake). The TLS messages
    shown in italics are encrypted using the session keys.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以讨论QUIC如何利用TLS 1.3协商用于验证和加密连接上交换的数据包的安全密钥。如图[图86](#fig-quic-handshake)所示，QUIC连接从交换四个帧开始，这些帧可以包含在四个或更多数据包中。客户端发送的第一个数据包包含`ClientHello`
    TLS记录。`ClientHello`包含使用Diffie-Hellman或类似协议派生会话密钥所需的信息。TLS 1.3支持有限域Diffie-Hellman和椭圆曲线Diffie-Hellman
    [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。`ClientHello`消息还包含客户端在连接期间提议使用的TLS或QUIC参数。服务器返回的`TLS服务器问候`包含证书，使客户端能够验证服务器的身份以及确定Diffie-Hellman密钥所需的信息。使用这些密钥，服务器还加密了包含服务器根据`ClientHello`中提出的参数选择的TLS和QUIC参数的`TLS加密扩展`消息。服务器还构建了包含整个TLS握手计算的消息认证码的`Finished`消息。此消息使用从Diffie-Hellman密钥派生的会话密钥加密和验证。客户端和服务器重新计算整个握手的哈希值并验证两个`Finished`消息。如果其中一个消息不正确，这表明密钥可能没有正确派生，或者某些TLS消息已被篡改。在这些情况下，QUIC连接将终止并显示错误消息。QUIC使用的简化TLS握手如图[图89](#fig-quic-tls-handshake)所示。以斜体显示的TLS消息使用会话密钥加密。
- en: '![Figure made with TikZ](../Images/68b73d74f409bc3b1f789ac93a363aa3.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/68b73d74f409bc3b1f789ac93a363aa3.png)'
- en: Fig. 89 Simplified TLS Handshake within a QUIC connection
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图89：QUIC连接中的简化TLS握手
- en: Note
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Encrypting `TLS Client Hello` and `TLS Server Hello`
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 加密`TLS客户端问候`和`TLS服务器问候`
- en: 'When TLS 1.3 is used above TCP, the `TLS Client Hello` and `TLS Server Hello`
    messages are sent in clear because the client and the server have not yet exchanged
    the session keys. A similar approach could have been used for QUIC, but there
    was a fear that middleboxes could analyze the contents of these initial QUIC messages
    and try to interfere with them. To add some burden on these middleboxes, QUIC
    encrypts the Initial packets using a secret that is derived from the destination
    connection ID of the client’s first Initial packet. The pseudocode below, extracted
    from [**RFC 9001**](https://datatracker.ietf.org/doc/html/rfc9001.html), shows
    how the client and the server keys are derived:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当TLS 1.3在TCP之上使用时，`TLS客户端问候`和`TLS服务器问候`消息以明文形式发送，因为客户端和服务器尚未交换会话密钥。对于QUIC，也可以采用类似的方法，但担心中间盒可能会分析这些初始QUIC消息的内容并试图干扰它们。为了给这些中间盒增加一些负担，QUIC使用从客户端的第一个初始数据包的目的连接ID派生出的秘密来加密初始数据包。下面的伪代码，摘自[**RFC
    9001**](https://datatracker.ietf.org/doc/html/rfc9001.html)，展示了客户端和服务器密钥是如何派生的：
- en: '[PRE25]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the keys used to protect the Initial packets are derived from the destination
    connection ID, any QUIC implementation, including those used on middleboxes, can
    decrypt the contents of the Initial packets.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用于保护初始数据包的密钥是从目的连接ID派生的，因此任何QUIC实现，包括那些用于中间盒子的实现，都可以解密初始数据包的内容。
- en: As mentioned earlier, the client and the server can also use the TLS handshake
    to agree on specific QUIC parameters. These parameters are called transport parameters
    in QUIC [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html). 17
    different transport parameters are defined in QUIC version 1 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    and implementations can define their own transport parameters. We will discuss
    some of them in different sections of this document. A first example is the `max_udp_payload_size`
    parameter that indicates the largest UDP payload that an implementation is willing
    to receive. The minimum value for this parameter is 1200 bytes. QUIC implementations
    used in a datacenter supporting jumbo Ethernet frames could agree on a much larger
    `max_udp_payload_size` without risking packet fragmentation.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，客户端和服务器还可以使用TLS握手来商定特定的QUIC参数。这些参数在QUIC中被称为传输参数[**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。在QUIC版本1
    [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)中定义了17个不同的传输参数，并且实现可以定义自己的传输参数。我们将在本文档的不同部分讨论其中的一些。第一个例子是`max_udp_payload_size`参数，它表示实现愿意接收的最大UDP有效负载。此参数的最小值是1200字节。在支持巨型以太网帧的数据中心中使用的QUIC实现可以商定一个更大的`max_udp_payload_size`，而不会存在数据包分片的风险。
- en: Another example of QUIC transport parameters are the `initial_source_connection_id`
    and the `original_destination_connection_id` transport parameters. As explained
    above, thanks to the `Finished` messages in the TLS handshake, the client and
    the servers can verify that their messages have not been tampered. Unfortunately,
    the authentication code included in the `Finished` messages is only computed based
    on the contents of the TLS messages (i.e. `ClientHello`, `ServerHello`, `EncryptedExtensions`
    and `Finished`). During the handshake, the client and the servers also propose
    the source and destination connection identifiers that they plan to use to identify
    the QUIC session. These identifiers are placed in the packet header and not inside
    the TLS messages. They are thus not covered by the authentication code included
    in the `Finished` message. To still authenticate these identifiers, QUIC encodes
    them as transport parameters that are included in the `ClientHello` and the `EncryptedExtensions`
    messages. The client copies the source connection identifier in the `initial_source_connection_id`
    transport parameter in its `ClientHello`. The server does the same when sending
    the `ServerHello`. It also copies in the `original_destination_connection_id`
    transport parameter the destination identifier used by the client to send the
    packet containing the `ClientHello`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC传输参数的另一个例子是`initial_source_connection_id`和`original_destination_connection_id`传输参数。如上所述，由于TLS握手中的`Finished`消息，客户端和服务器可以验证他们的消息没有被篡改。不幸的是，包含在`Finished`消息中的认证代码仅基于TLS消息的内容（即`ClientHello`、`ServerHello`、`EncryptedExtensions`和`Finished`）进行计算。在握手过程中，客户端和服务器还提出了他们计划使用的源和目的连接标识符，以识别QUIC会话。这些标识符被放置在数据包头部，而不是TLS消息内部。因此，它们不受`Finished`消息中包含的认证代码的保护。为了仍然对这些标识符进行认证，QUIC将它们编码为包含在`ClientHello`和`EncryptedExtensions`消息中的传输参数。客户端将其源连接标识符复制到`initial_source_connection_id`传输参数中，并在其`ClientHello`中发送。服务器在发送`ServerHello`时也做同样的事情。它还在`original_destination_connection_id`传输参数中复制客户端用于发送包含`ClientHello`的数据包的目的标识符。
- en: The QUIC packet headers[#](#the-quic-packet-headers "Link to this heading")
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC数据包头部[#](#the-quic-packet-headers "链接到这个标题")
- en: At this point, the QUIC session and the TLS security keys are known by the client
    and the server. They can start to exchange data. Before looking at how data is
    carried inside QUIC packets, it is interesting to explore in more details the
    packet headers that are placed inside each packet. QUIC uses variable length packet
    headers. Two different header formats exist. The first header format is the long
    header. This is the header used for the first packets of a QUIC connection.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，客户端和服务器都知道了 QUIC 会话和 TLS 安全密钥。它们可以开始交换数据。在查看数据如何在 QUIC 数据包内部传输之前，更深入地探索放置在每个数据包内部的头部是有趣的。QUIC
    使用可变长度数据包头部。存在两种不同的头部格式。第一种头部格式是长头部。这是用于 QUIC 连接第一个数据包的头部。
- en: Internet protocol specifications usually contain figures to represent the format
    of the packet headers. This graphical format is useful to get a quick grasp at
    a header containing fixed size fields. However, when a header contains several
    variable length fields, the graphical representation can become difficult to follow.
    The QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    uses the textual representation that was also used for the TLS protocol. As an
    example, let us consider the well-known TCP header. This header is graphically
    represented as shown in [Fig. 90](#fig-quic-tcp-header).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议规范通常包含图表来表示数据包头部的格式。这种图形格式对于快速掌握包含固定大小字段的头部非常有用。然而，当头部包含多个可变长度字段时，图形表示可能变得难以追踪。QUIC
    规范 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 使用了与 TLS
    协议相同的文本表示。作为一个例子，让我们考虑众所周知的 TCP 头部。该头部在 [图 90](#fig-quic-tcp-header) 中以图形方式表示。
- en: '![Figure made with TikZ](../Images/8bbfb429b7a940504df39c6677c533c7.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/8bbfb429b7a940504df39c6677c533c7.png)'
- en: Fig. 90 Graphical representation of the TCP header Listing 2 Textual representation
    of the TCP header[#](#fig-quic-tcp-text-header "Link to this code")
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 90 TCP 头部的图形表示 列表 2 TCP 头部的文本表示[#](#fig-quic-tcp-text-header "链接到这段代码")
- en: '[PRE26]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The attentive reader will easily understand the correspondence between the two
    formats. When explaining QUIC, we use the textual representation while we stick
    to the graphical one for TCP.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读的读者会很容易理解两种格式之间的对应关系。当我们解释 QUIC 时，我们使用文本表示，而对于 TCP，我们坚持使用图形表示。
- en: '[Listing 3](#fig-quic-long-header) shows the QUIC long header. It starts with
    one byte containing the header type in the most significant bit, two bits indicating
    the packet type and four bits that are specific to each packet packet. Then, 32
    bits carry the QUIC version number. The current version of QUIC, defined in [**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html), corresponds to version
    `0x00000001`. The header then contains the destination and source connection identifiers
    that were described previously and then a payload that is specific to each type.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3](#fig-quic-long-header) 展示了 QUIC 长头部。它以一个字节开始，该字节包含头部类型，最高位表示头部类型，接下来两位表示数据包类型，再接下来四位是每个数据包特有的位。然后，32
    位携带 QUIC 版本号。当前版本的 QUIC，在 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    中定义，对应版本 `0x00000001`。头部接着包含之前描述的目标和源连接标识符，然后是一个针对每种类型的特定有效载荷。'
- en: Listing 3 The QUIC long header[#](#fig-quic-long-header "Link to this code")
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3 QUIC 长头部[#](#fig-quic-long-header "链接到这段代码")
- en: '[PRE27]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Encoding packet numbers
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据包编号
- en: Most transport protocols use fixed fields to encode packet numbers or byte offsets.
    The size of this field is always a trade-off. On one hand, a small packet number
    field limits the per packet overhead. On the other hand, a large packet number
    space is required to ensure that two packets carrying different data do not use
    the same packet number. TCP uses a 32 bits sequence number field that indicates
    the position of the first byte of the payload in the bytestream. This 32 bits
    field became a concern as bandwidth increased to Gbps and beyond [**RFC 7323**](https://datatracker.ietf.org/doc/html/rfc7323.html).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传输协议使用固定字段来编码数据包编号或字节偏移。这个字段的大小始终是一个权衡。一方面，小的数据包编号字段限制了每个数据包的额外开销。另一方面，需要较大的数据包编号空间以确保携带不同数据的两个数据包不使用相同的数据包编号。TCP
    使用 32 位序列号字段，该字段指示有效载荷的第一个字节在字节流中的位置。随着带宽增加到 Gbps 及以上，这个 32 位字段引起了关注 [**RFC 7323**](https://datatracker.ietf.org/doc/html/rfc7323.html)。
- en: QUIC takes a different approach to sequence numbers. Each packet contains a
    per-packet sequence number. This number is encoded as a variable-length integer
    (`varint`). Such a `varint` has a length encoded in the two most significant bits
    of the first byte. If these bits are set to `00`, then the `varint` is encoded
    in one byte and can contain values between \(0\) and \(2^{6}-1\). If the two most
    significant bits are set to `01`, the `varint` can encode values between \(0\)
    and \(2^{14}-1\) within two bytes. When the two high order bits are set to `11`
    the `varint` can encode values between \(0\) and \(2^{62}-1\) within four bytes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 对序列号采取了不同的方法。每个数据包包含一个按数据包序列号。此数字编码为变长整数 (`varint`)。这样的 `varint` 在第一个字节的两个最高有效位中编码长度。如果这些位设置为
    `00`，则 `varint` 在一个字节中编码，可以包含 \(0\) 到 \(2^{6}-1\) 之间的值。如果两个最高有效位设置为 `01`，则 `varint`
    可以在两个字节内编码 \(0\) 到 \(2^{14}-1\) 之间的值。当两个最高位设置为 `11` 时，`varint` 可以在四个字节内编码 \(0\)
    到 \(2^{62}-1\) 之间的值。
- en: There are other important differences between QUIC and other transport protocols
    when considering packet numbers. First, a QUIC sender must *never* reuse the same
    packet number for two different packets sent over a QUIC connection. If data needs
    to be retransmitted, it will be resent as a frame inside a new packet. Furthermore,
    since the largest possible packet number is \(2^{62}-1\), a QUIC sender must close
    the corresponding connection once it has sent a QUIC packet carrying this packet
    number. This puts a restriction on the duration of QUIC connections. They cannot
    last forever in contrast to TCP connections such as those used to support BGP
    sessions between routers. An application that uses QUIC must be ready to restart
    a connection from time to time.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到包号时，QUIC 与其他传输协议之间存在其他重要差异。首先，QUIC 发送者必须 *永远* 不能在同一个 QUIC 连接上为两个不同的数据包重用相同的包号。如果需要重传数据，它将以新数据包中的帧形式重新发送。此外，由于最大的包号是
    \(2^{62}-1\)，QUIC 发送者必须在发送携带此包号的 QUIC 数据包后关闭相应的连接。这限制了 QUIC 连接的持续时间。与用于支持路由器之间
    BGP 会话的 TCP 连接不同，它们不能永远持续。使用 QUIC 的应用程序必须随时准备重新启动连接。
- en: This long header is used for the `Initial`, `Handhsake` and `Retry` packets.
    Some of these packet types add new flags in the first byte and additional information
    after the connection identifiers. [Listing 4](#fig-quic-initial-header) shows
    the long header of the `Initial` packet. It contains two bits in the first byte
    that indicate the length of the packet number field. The packet specific part
    contains an option token, a length field, a packet number and a payload. The token
    length, length and packet number are encoded using variable length integers.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此长头部用于 `Initial`、`Handshake` 和 `Retry` 数据包。这些数据包类型中的一些在第一个字节中添加了新的标志，并在连接标识符之后添加了附加信息。[列表
    4](#fig-quic-initial-header) 展示了 `Initial` 数据包的长头部。它包含第一个字节中的两个位，指示包号字段长度。数据包特定部分包含一个选项令牌、一个长度字段、一个包号和有效载荷。令牌长度、长度和包号使用变长整数进行编码。
- en: Listing 4 The QUIC long header of the Initial packet[#](#fig-quic-initial-header
    "Link to this code")
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4 初始数据包的 QUIC 长头部[#](#fig-quic-initial-header "链接到此代码")
- en: '[PRE28]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The QUIC short header contains fewer fields. The most significant bit of the
    first byte is set to 1 to indicate that the packet carries a short header. The
    other flags will be discussed later. The two least significant bits of this byte
    contain the length of the packet number field. It is interesting to note that
    in contrast with the long header, there is no explicit indication of the length
    of the destination connection identifier. This connection identifier has been
    assigned by the host that receives this packet and it already knows the length
    of the connection identifiers that it uses.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 短头部包含的字段较少。第一个字节的最显著位被设置为 1，以指示该数据包携带短头部。其他标志将在后面讨论。该字节两个最低有效位包含包号字段长度。值得注意的是，与长头部相比，没有明确指示目标连接标识符的长度。此连接标识符已由接收该数据包的主机分配，并且它已经知道它使用的连接标识符的长度。
- en: Listing 5 The QUIC short header used by 1-RTT packets[#](#fig-quic-short-header
    "Link to this code")
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5 1-RTT 数据包使用的 QUIC 短头部[#](#fig-quic-short-header "链接到此代码")
- en: '[PRE29]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The short header format, depicted in [Listing 5](#fig-quic-short-header), is
    used by all QUIC packets once the session keys have been derived. This usually
    happens after one round-trip-time. These packets are called the 1-RTT packets
    in the QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    This notation is used to emphasize the fact that QUIC also supports 0-RTT packets,
    i.e. packets that carry data and can be exchanged in parallel with the TLS handshake.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 短头部格式，如图[列表 5](#fig-quic-short-header)所示，在会话密钥生成后由所有 QUIC 数据包使用。这通常发生在一次往返时间之后。这些数据包在
    QUIC 规范中被称为 1-RTT 数据包[**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。这种表示法用于强调
    QUIC 也支持 0-RTT 数据包，即携带数据并能与 TLS 握手并行交换的数据包。
- en: Note
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Coalescing packets
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 合并数据包
- en: Besides the connection identifiers, another difference between the short and
    the long headers is the presence of the `Packet Length` field in the long header.
    This field might surprise the reader who is familiar with UDP since UDP also contains
    a Length field. As each QUIC packet is placed inside a UDP message, the QUIC Length
    field could seem redundant. This Length field was included in the QUIC long header
    to allow a QUIC sender to coalesce several consecutive and small packets inside
    a single UDP message. Some of the frames exchanged during the handshake are rather
    small. Sending a UDP message for each of these frames would be a waste of resources.
    Furthermore, a mix of `Initial`, `Handshake` and `0-RTT` packets are exchanged
    when creating a QUIC connection. It would not be wise to require the utilization
    of one UDP message to send each of these packets. You might observe this optimization
    when analyzing packet traces collected on QUIC servers.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接标识符之外，短头部和长头部之间的另一个区别是长头部中存在“数据包长度”字段。这个字段可能会让熟悉 UDP 的读者感到惊讶，因为 UDP 也包含长度字段。由于每个
    QUIC 数据包都放置在一个 UDP 消息中，QUIC 长度字段可能看起来是多余的。这个长度字段被包含在 QUIC 长头部中，以便允许 QUIC 发送者将多个连续的小数据包合并到单个
    UDP 消息中。在握手过程中交换的一些帧相当小。为每个这样的帧发送一个 UDP 消息将是资源的浪费。此外，在创建 QUIC 连接时，会交换“初始”、“握手”和“0-RTT”数据包的混合。要求使用一个
    UDP 消息发送这些数据包中的每一个是不明智的。您可能会在分析收集在 QUIC 服务器上的数据包跟踪时观察到这种优化。
- en: 0-RTT data[#](#rtt-data "Link to this heading")
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 0-RTT 数据[#](#rtt-data "链接到这个标题")
- en: Latency is a key concern for transport protocols. The QUIC/TLS handshake that
    we have described until now allows the client and the server to agree on security
    keys within one round-trip-time. However, one round-trip-time can be a long delay
    for some applications. To minimize the impact of the connection setup time, QUIC
    allows applications to exchange data during the QUIC/TLS handshake. Such data
    is called 0-RTT data. To ensure that 0-RTT data is exchanged securely, the client
    and the server must have previously agreed on a key which can be used to encrypt
    and authenticate the 0-RTT data. Such a 0-RTT key could either be a pre-shared
    key that the client and the server have shared without using the QUIC protocol
    or, and this is the most frequent solution, the key that they negotiated during
    a previous connection. In practice, the server enables 0-RTT by sending a TLS
    session ticket to the client [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    A session ticket is an encrypted record that contains information that enables
    the server to recover all the state information about a session including its
    session keys. It is also linked to the client’s address to enable the server to
    verify that a given client reuses the tickets that it has received earlier. Usually,
    these tickets also contain an expiration date. The client places the received
    ticket in the `TLS CLient Hello` that it sends in the first `Initial` packet.
    It uses the pre-shared key corresponding to this ticket to encrypt data and place
    it in one or more `0-RTT` packets. The server uses the information contained in
    the ticket to recover the key and decrypt the data of the `0-RTT` packet. [Listing
    6](#fig-quic-0-rtt-packet) shows the format of QUIC’s 0-RTT packet.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是传输协议的关键关注点。我们之前所描述的 QUIC/TLS 握手允许客户端和服务器在单程往返时间内就安全密钥达成一致。然而，对于某些应用来说，单程往返时间可能是一个较长的延迟。为了最小化连接建立时间的影响，QUIC
    允许应用程序在 QUIC/TLS 握手期间交换数据。这种数据被称为 0-RTT 数据。为了确保 0-RTT 数据的安全交换，客户端和服务器必须事先就一个可以用来加密和验证
    0-RTT 数据的密钥达成一致。这样的 0-RTT 密钥可以是客户端和服务器在没有使用 QUIC 协议的情况下共享的预共享密钥，或者，这是最常见的方法，是他们在之前的连接中协商的密钥。在实践中，服务器通过向客户端发送
    TLS 会话票据来启用 0-RTT [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。会话票据是一个包含使服务器能够恢复会话所有状态信息（包括其会话密钥）的加密记录。它还与客户端的地址相关联，以便服务器能够验证给定的客户端是否重用了它之前收到的票据。通常，这些票据还包含一个过期日期。客户端将收到的票据放入它发送的第一个“Initial”数据包中的“TLS
    Client Hello”。它使用与该票据对应的预共享密钥来加密数据并将其放入一个或多个“0-RTT”数据包中。服务器使用票据中包含的信息恢复密钥并解密“0-RTT”数据包的数据。[列表
    6](#fig-quic-0-rtt-packet) 展示了 QUIC 的 0-RTT 数据包格式。
- en: Listing 6 The QUIC 0-RTT packet[#](#fig-quic-0-rtt-packet "Link to this code")
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6 QUIC 0-RTT 数据包[#](#fig-quic-0-rtt-packet "链接到这段代码")
- en: '[PRE30]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main benefit of these `0-RTT` packets is that the client can immediately
    send encrypted data while sending its `Initial` packet. This is illustrated in
    [Fig. 91](#fig-quic-handshake-ortt) where the frames encrypted with the 0-RTT
    keys are shown in italics. Note that some of these frames can span several packets.
    `0-RTT` packets are only sent by the QUIC client since the server can send encrypted
    data immediately after having sent its `Handshake` frames. As explained earlier,
    the Initial packets are also encrypted but using keys derived from the connection
    identifiers.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“0-RTT”数据包的主要好处是客户端可以在发送其“Initial”数据包的同时立即发送加密数据。这如图 91（#fig-quic-handshake-ortt）所示，其中用斜体显示了使用
    0-RTT 密钥加密的帧。请注意，这些帧中的一些可以跨越多个数据包。“0-RTT”数据包仅由 QUIC 客户端发送，因为服务器可以在发送其“Handshake”数据包后立即发送加密数据。如前所述，Initial
    数据包也是加密的，但使用的是从连接标识符派生的密钥。
- en: '![Figure made with TikZ](../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/a2b6bc24bc9d3ceb2112e03596711d2a.png)'
- en: Fig. 91 Simplified QUIC Handshake with 0-RTT data
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 91 带有 0-RTT 数据的简化 QUIC 握手
- en: Note
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replay attacks and 0-RTT packets
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 重放攻击和 0-RTT 数据包
- en: Thanks to the 0-RTT packets, a client can send encrypted data to the server
    before waiting for the secure handshake. This reduces the latency of the data
    transfer, but with one important caveat. QUIC does not provide any guarantee that
    0-RTT data will not be replayed. QUIC’s 0-RTT data exchanged is intended for idempotent
    operations. A detailed discussion of the impact of replay attacks may be found
    in [[MacCarthaigh2017]](../bibliography.html#maccarthaigh2017).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了0-RTT数据包，客户端可以在等待安全握手之前向服务器发送加密数据。这降低了数据传输的延迟，但有一个重要的前提。QUIC不提供任何保证，0-RTT数据不会被重放。QUIC交换的0-RTT数据旨在用于幂等操作。关于重放攻击影响的具体讨论，请参阅[[MacCarthaigh2017]](../bibliography.html#maccarthaigh2017)。
- en: To understand the importance of these replay attacks, let us consider a simple
    HTTP GET request. Such a request could easily fit inside the 0-RTT packet and
    thus have lower latency. If a web browser uses it to request a static `index.html`
    file, there is no harm if the request is received twice by the server. However,
    if the GET request is part of a REST API and has side effects, then problems could
    occur depending on the type of side effect. Consider a REST API that allows a
    user to switch off the lights using his or her smartphone. Replaying this request
    two or three times will always result in the light being switched off. However,
    if the user requests to increase the room temperature by one °C, then multiple
    replays will obviously have different consequences.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些重放攻击的重要性，让我们考虑一个简单的HTTP GET请求。这样的请求可以很容易地放入0-RTT数据包中，从而降低延迟。如果网页浏览器使用它来请求静态的`index.html`文件，如果请求被服务器接收两次，则没有害处。然而，如果GET请求是REST
    API的一部分并且有副作用，那么问题将取决于副作用类型。考虑一个允许用户通过智能手机关闭灯光的REST API。重放这个请求两到三次将始终导致灯光关闭。然而，如果用户请求将室温提高1°C，那么多次重放显然会有不同的后果。
- en: Closing a QUIC connection[#](#closing-a-quic-connection "Link to this heading")
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭QUIC连接[#](#closing-a-quic-connection "链接到本标题")
- en: Before exploring how data can be exchanged over a QUIC connection, let us now
    analyze how a QUIC connection can terminate. QUIC supports three different methods
    to close a QUIC connection. QUIC’s approach to terminating connection is very
    different from the approaches used by traditional transport protocol. Before looking
    at these techniques, it is important to understand how QUIC interacts with Network
    Address Translation.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索如何在QUIC连接上交换数据之前，现在让我们分析如何终止QUIC连接。QUIC支持三种不同的方法来关闭QUIC连接。QUIC终止连接的方法与传统传输协议使用的方法非常不同。在查看这些技术之前，了解QUIC如何与网络地址转换交互是非常重要的。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: QUIC and Network Address Translation
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC和网络地址转换
- en: QUIC runs above UDP and the design of QUIC was heavily influenced by the presence
    of NATs. NATs, like other middleboxes, maintain per-flow state. For TCP connections,
    many NATs rely on the `SYN`, `FIN` and `RST` flags to determine when state must
    be created or removed for a TCP connection. For UDP, this stateful approach is
    not possible and NATs create a new mapping when they observe the first packet
    of a flow and remove the mapping once the flow has been idle for sometime. The
    IETF recommends to maintain NAT mappings during at least two minutes [**RFC 4787**](https://datatracker.ietf.org/doc/html/rfc4787.html),
    but measurements show that some deployed NATs use shorter timeouts [[HNESSK2010]](../bibliography.html#hnessk2010)
    [[RWV+2016]](../bibliography.html#rwv-2016). In practice, UDP flows should probably
    send a packet every 30 seconds to ensure that the on-path NATs preserve their
    state.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC在UDP之上运行，QUIC的设计受到了NAT（网络地址转换）的强烈影响。NAT和其他中间盒一样，维护每个流的会话状态。对于TCP连接，许多NAT依赖于`SYN`、`FIN`和`RST`标志来确定何时为TCP连接创建或删除状态。对于UDP，这种有状态的方法是不可能的，NAT在观察到流的第一数据包时创建一个新的映射，一旦流空闲一段时间后，就删除该映射。IETF建议至少保持NAT映射两分钟[**RFC
    4787**](https://datatracker.ietf.org/doc/html/rfc4787.html)，但测量显示某些部署的NAT使用更短的超时[[HNESSK2010]](../bibliography.html#hnessk2010)
    [[RWV+2016]](../bibliography.html#rwv-2016)。在实践中，UDP流可能需要每30秒发送一个数据包，以确保路径上的NAT保持其状态。
- en: To prevent NATs from changing the mapping associated to the IP addresses and
    ports used for a QUIC connection, QUIC hosts will need to regularly send data
    over each established QUIC connection. QUIC defines a `PING` frame that allows
    any QUIC endpoint to send a frame that will trigger a response from the other
    peer. The `PING` frame does not carry data, but the receiver of a `PING` frame
    needs to acknowledge the packet containing this frame. This creates a bidirectional
    communication and can prevent NATs from discarding the mapping associated to the
    QUIC connection.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止NAT改变用于QUIC连接的IP地址和端口的映射，QUIC主机需要定期在每个建立的QUIC连接上发送数据。QUIC定义了一个`PING`帧，允许任何QUIC端点发送一个将触发另一端响应的帧。`PING`帧不携带数据，但`PING`帧的接收者需要确认包含此帧的数据包。这创建了一个双向通信，可以防止NAT丢弃与QUIC连接相关的映射。
- en: Implicit termination of QUIC connections[#](#implicit-termination-of-quic-connections
    "Link to this heading")
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC连接的隐式终止[#](#implicit-termination-of-quic-connections "链接到这个标题")
- en: Each QUIC implementation keeps in its connection state the timestamp of the
    last QUIC packet received over this connection. During the connection establishment,
    the QUIC hosts can also exchange the `max_idle_timeout` parameter that indicates
    how long (in seconds) a QUIC connection can remain idle before being automatically
    closed. The first way to close a QUIC connection is to keep it idle for this period
    of time.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 每个QUIC实现都会在其连接状态中保留通过此连接接收到的最后一个QUIC数据包的时间戳。在连接建立期间，QUIC主机还可以交换`max_idle_timeout`参数，该参数表示QUIC连接在自动关闭之前可以保持空闲多长时间（以秒为单位）。关闭QUIC连接的第一种方式是保持它在这个时间段内空闲。
- en: Explicit termination of a QUIC connection[#](#explicit-termination-of-a-quic-connection
    "Link to this heading")
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式终止QUIC连接[#](#explicit-termination-of-a-quic-connection "链接到这个标题")
- en: The second technique to terminate a QUIC connection is to use the `CONNECTION_CLOSE`
    frame. This frame indicates that this connection has been closed abruptly. The
    host that receives the `CONNECTION_CLOSE` may respond with one `CONNECTION_CLOSE`
    frame. After that, it must stop sending any additional frame. It keeps the connection
    state for some time, but does not accept any new packet nor retransmit others.
    The host that sends a `CONNECTION_CLOSE` frame indicates that it will neither
    send nor accept more data. It keeps a subset of the QUIC connection state to be
    able to retransmit the `CONNECTION_CLOSE` frame if needed.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 终止QUIC连接的第二种技术是使用`CONNECTION_CLOSE`帧。这个帧表示这个连接已被突然关闭。接收`CONNECTION_CLOSE`帧的主机可能会用一个`CONNECTION_CLOSE`帧进行响应。之后，它必须停止发送任何额外的帧。它保持连接状态一段时间，但不接受任何新的数据包也不重传其他数据包。发送`CONNECTION_CLOSE`帧的主机表示它将不会发送或接收更多数据。它保留QUIC连接状态的一部分，以便在需要时重新传输`CONNECTION_CLOSE`帧。
- en: A host also sends a `CONNECTION_CLOSE` frame to abruptly terminate a connection
    if it receives an invalid frame or detects a protocol error. In this case, the
    `CONNECTION_CLOSE` frame contains a variable length integer that indicates the
    reason for the termination, the type of the frame that triggered the error and
    additional information encoded as a text string.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机收到一个无效帧或检测到协议错误，它也会发送一个`CONNECTION_CLOSE`帧来突然终止连接。在这种情况下，`CONNECTION_CLOSE`帧包含一个可变长度的整数，表示终止的原因、触发错误的帧类型以及作为文本字符串编码的附加信息。
- en: '![Figure made with TikZ](../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png)'
- en: Fig. 92 A server that refuses a connection
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图92 拒绝连接的服务器
- en: The QUIC specification also defines a third technique called stateless reset
    to cope with hosts that have lost connection state after a crash or outage. It
    relies on a 16 bytes stateless token announced together with the connection identifier.
    See [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) for all
    the details.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC规范还定义了第三种技术，称为无状态重置，以应对在崩溃或故障后丢失连接状态的主机。它依赖于与连接标识符一起宣布的16字节无状态令牌。有关所有详细信息，请参阅[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。
- en: Implicit termination of QUIC connections[#](#implicit-termination-of-quic-connections
    "Link to this heading")
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC连接的隐式终止[#](#implicit-termination-of-quic-connections "链接到这个标题")
- en: Each QUIC implementation keeps in its connection state the timestamp of the
    last QUIC packet received over this connection. During the connection establishment,
    the QUIC hosts can also exchange the `max_idle_timeout` parameter that indicates
    how long (in seconds) a QUIC connection can remain idle before being automatically
    closed. The first way to close a QUIC connection is to keep it idle for this period
    of time.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 每个QUIC实现都会在其连接状态中保留最后通过此连接接收到的QUIC数据包的时间戳。在连接建立过程中，QUIC主机还可以交换`max_idle_timeout`参数，该参数表示QUIC连接在自动关闭之前可以保持空闲多长时间（以秒为单位）。关闭QUIC连接的第一种方式是保持连接空闲这段时间。
- en: Explicit termination of a QUIC connection[#](#explicit-termination-of-a-quic-connection
    "Link to this heading")
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确终止一个QUIC连接[#](#explicit-termination-of-a-quic-connection "链接到本标题")
- en: The second technique to terminate a QUIC connection is to use the `CONNECTION_CLOSE`
    frame. This frame indicates that this connection has been closed abruptly. The
    host that receives the `CONNECTION_CLOSE` may respond with one `CONNECTION_CLOSE`
    frame. After that, it must stop sending any additional frame. It keeps the connection
    state for some time, but does not accept any new packet nor retransmit others.
    The host that sends a `CONNECTION_CLOSE` frame indicates that it will neither
    send nor accept more data. It keeps a subset of the QUIC connection state to be
    able to retransmit the `CONNECTION_CLOSE` frame if needed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 终止QUIC连接的第二种技术是使用`CONNECTION_CLOSE`帧。这个帧表示这个连接已被突然关闭。接收`CONNECTION_CLOSE`帧的主机可能会用一个`CONNECTION_CLOSE`帧进行响应。之后，它必须停止发送任何额外的帧。它保持连接状态一段时间，但不接受任何新的数据包也不重传其他数据包。发送`CONNECTION_CLOSE`帧的主机表明它将不会发送或接收更多数据。它保留QUIC连接状态的一部分，以便在需要时重新传输`CONNECTION_CLOSE`帧。
- en: A host also sends a `CONNECTION_CLOSE` frame to abruptly terminate a connection
    if it receives an invalid frame or detects a protocol error. In this case, the
    `CONNECTION_CLOSE` frame contains a variable length integer that indicates the
    reason for the termination, the type of the frame that triggered the error and
    additional information encoded as a text string.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机收到一个无效的帧或检测到协议错误，它也会发送一个`CONNECTION_CLOSE`帧来突然终止连接。在这种情况下，`CONNECTION_CLOSE`帧包含一个可变长度的整数，表示终止的原因、触发错误的帧类型以及以文本字符串编码的附加信息。
- en: '![Figure made with TikZ](../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/71c2f2b4b9ff5c0918a5713a02c7511d.png)'
- en: Fig. 92 A server that refuses a connection
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图92 拒绝连接的服务器
- en: The QUIC specification also defines a third technique called stateless reset
    to cope with hosts that have lost connection state after a crash or outage. It
    relies on a 16 bytes stateless token announced together with the connection identifier.
    See [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) for all
    the details.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC规范还定义了第三种技术，称为无状态重置，以应对在崩溃或中断后丢失连接状态的主机。它依赖于与连接标识符一起宣布的16字节无状态令牌。有关所有详细信息，请参阅[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。
- en: Exchanging data over a QUIC connection[#](#exchanging-data-over-a-quic-connection
    "Link to this heading")
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在QUIC连接上交换数据[#](#exchanging-data-over-a-quic-connection "链接到本标题")
- en: The data exchanged over is QUIC connection is organized in different streams.
    A stream is a sequence of bytes. QUIC supports both unidirectional and bidirectional
    streams. Both the client and the server can create new streams over a QUIC connection.
    Each stream is identified by a stream identifier. To prevent problems when the
    client and the server try to create a stream using the same identifier, QUIC restricts
    the utilization of the stream identifiers based its two low-order bits. A QUIC
    client can only create streams whose two low order bits are set to `00` (bidirectional
    stream) or `10` (unidirectional stream). Similarly, the low order bits of the
    server-initiated streams must be set to `01` (bidirectional stream) or `11` (unidirectional
    streams). The QUIC streams are created implicitly by sending data over the stream
    with the chosen identifier. The stream identifiers start at the minimum value,
    i.e. `0x00` to `0x03` for the respective types. If a host sends stream data for
    stream `x` before having sent data over the lower-numbered streams of that type,
    then those streams are implicitly created. The stream identifier is encoded using
    a variable length integer. The largest possible stream identifier is thus \(2^{62}-1\).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QUIC 连接上交换的数据组织在不同的流中。流是一系列字节。QUIC 支持单向和双向流。客户端和服务器都可以在 QUIC 连接上创建新的流。每个流都有一个流标识符。为了防止客户端和服务器尝试使用相同的标识符创建流时出现问题，QUIC
    限制了基于其两个低阶位的流标识符的使用。QUIC 客户端只能创建两个低阶位设置为 `00`（双向流）或 `10`（单向流）的流。同样，服务器发起的流的低阶位必须设置为
    `01`（双向流）或 `11`（单向流）。QUIC 流通过在流上发送数据并使用选择的标识符隐式创建。流标识符使用可变长度整数进行编码。因此，最大的流标识符是
    \(2^{62}-1\)。
- en: 'QUIC places all data inside `STREAM` frames that are then placed inside QUIC
    packets. The structure of a `STREAM` frame is shown in [Listing 7](#fig-quic-stream-frame).
    This frame contains the following information :'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 将所有数据放在 `STREAM` 帧中，然后这些帧被放入 QUIC 数据包中。`STREAM` 帧的结构在 [列表 7](#fig-quic-stream-frame)
    中显示。此帧包含以下信息：
- en: the Type of the Stream frame [[1]](#f-stream-type)
  id: totrans-456
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流帧的类型 [[1]](#f-stream-type)
- en: ''
  id: totrans-457
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the identifier of the stream
  id: totrans-459
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的标识符
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-461
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the offset, i.e. the position of the first byte of the Stream data in the bytestream
  id: totrans-462
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量，即 Stream 数据的第一个字节在字节流中的位置
- en: ''
  id: totrans-463
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the length of the data
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据长度
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-467
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Stream Data
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流数据
- en: Listing 7 The QUIC STREAM frame[#](#fig-quic-stream-frame "Link to this code")
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7 QUIC 流帧[#](#fig-quic-stream-frame "链接到这段代码")
- en: '[PRE31]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `STREAM` frame carries data, but it can also terminate the corresponding
    stream. The lowest order bit of the Type field acts as a `FIN` bit. When set to
    zero, it indicates that subsequent data will be sent over this stream. When set
    to one, it indicates that the `STREAM` frame contains the last bytes sent over
    that stream. The stream is closed once the last byte of the stream has been delivered
    to the user application. Once a QUIC stream has been closed, it cannot be reused
    again over this connection.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`STREAM` 帧携带数据，但它也可以终止相应的流。类型字段中的最低阶位充当 `FIN` 位。当设置为 0 时，表示后续数据将通过此流发送。当设置为
    1 时，表示 `STREAM` 帧包含该流发送的最后一个字节。一旦将流的最后一个字节交付给用户应用，流就会被关闭。一旦一个 QUIC 流被关闭，它就不能在此连接上再次使用。'
- en: Using this information, the receiver can easily reassemble the data received
    over the different streams. As an illustration, let us consider a server that
    has created two streams (stream `1` and `5`). The server sends `ABCD..` over stream
    `1` and `123` over stream `5` and closes it after having sent the third digit.
    The data from these streams could be encoded as shown in [Listing 8](#fig-quic-streams-example).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，接收者可以轻松地重新组装通过不同流接收到的数据。为了说明，让我们考虑一个创建了两个流（流 `1` 和 `5`）的服务器。服务器通过流 `1`
    发送 `ABCD..`，通过流 `5` 发送 `123` 并在发送第三个数字后关闭它。这些流的数据可以编码如 [列表 8](#fig-quic-streams-example)
    所示。
- en: Listing 8 Data sent over two different streams[#](#fig-quic-streams-example
    "Link to this code")
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8 通过两个不同流发送的数据[#](#fig-quic-streams-example "链接到这段代码")
- en: '[PRE32]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The penultimate frame shown in [Listing 8](#fig-quic-streams-example) has the
    `FIN` flag set. It marks the end of stream `1` that has transported three bytes
    in total. The `FIN` flag is the normal way to gracefully close a QUIC stream.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表8](#fig-quic-streams-example)中显示的倒数第二个帧设置了`FIN`标志。它标志着传输了总共三个字节的流`1`的结束。`FIN`标志是优雅地关闭QUIC流的标准方式。
- en: There are however cases where an application might need to cancel a stream abruptly
    without closing the corresponding connection. First, the sending side of a stream
    can decide to reset the stream. For this, it sends a `RESET_STREAM` frame that
    carries the identifier of the stream that is canceled. The receiving side of a
    stream might also need to stop receiving data over a given stream. Consider for
    example a web browser that has started to download the different images that compose
    a web while the user has already clicked on another page from the same server.
    The streams that correspond to these images become useless. In this case, our
    browser can send a `STOP_SENDING` frame to indicate that it discards the incoming
    data over the corresponding streams. Upon reception of this frame, the server
    sends a `RESET_STREAM` frame to indicate that the corresponding stream has been
    closed.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，应用程序可能需要突然取消一个流，而不关闭相应的连接。首先，流的发送方可以决定重置该流。为此，它发送一个携带被取消流标识符的`RESET_STREAM`帧。流的接收方也可能需要停止接收给定流的数据。例如，考虑一个用户已经点击了同一服务器的另一个页面的网页浏览器，而浏览器已经开始下载组成网页的不同图像。对应这些图像的流变得无用。在这种情况下，我们的浏览器可以发送一个`STOP_SENDING`帧来指示它丢弃对应流的传入数据。在接收到此帧后，服务器发送一个`RESET_STREAM`帧来指示相应的流已被关闭。
- en: Flow control in QUIC[#](#flow-control-in-quic "Link to this heading")
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC中的流量控制[#](#flow-control-in-quic "链接到这个标题")
- en: Transport protocols usually allocate some resources to each established connection.
    Each QUIC connection requires memory to store its state, but also buffers to store
    the packets arrived out-of-order. In practice, the memory available for QUIC implementations
    is not unlimited and a QUIC receiver must control the amount of packets that the
    remote host can send at any time. QUIC supports flow control techniques that operate
    at different levels.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议通常为每个建立的连接分配一些资源。每个QUIC连接都需要内存来存储其状态，但也需要缓冲区来存储到达顺序错误的包。在实践中，可用于QUIC实现的内存不是无限的，QUIC接收方必须控制远程主机在任何时候可以发送的包的数量。QUIC支持在不同级别操作的流量控制技术。
- en: The first level is the connection level. During the handshake, each host can
    announce the maximum number of bytes that it agrees to receive initially on the
    connection using the `initial_max_data` transport parameter. This parameter contains
    the number of bytes that the sending host agrees to receive without further notice.
    If the connection uses more bytes than initially agreed, the receiver can update
    this limit by sending a `MAX_DATA` frame at any time. This frame contains a variable
    length integer that encodes the maximum amount of stream data that can be sent
    over the connection.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层是连接层。在握手过程中，每个主机可以使用`initial_max_data`传输参数宣布它同意在连接上最初接收的最大字节数。此参数包含发送主机同意接收的字节数，无需进一步通知。如果连接使用的字节数超过了最初同意的数量，接收方可以在任何时候通过发送`MAX_DATA`帧来更新此限制。此帧包含一个可变长度的整数，它编码了可以通过连接发送的最大流数据量。
- en: The utilization of different streams also consumes resources on a QUIC host.
    A receiver can also restrict the number of streams that the remote host can create.
    During the handshake, the `initial_max_streams_bidi` and `initial_max_streams_uni`
    transport parameters announce the maximum number of bidirectional and unidirectional
    streams that the receiving host can accept. This limit can be modified during
    the connection by sending a `MAX_STREAMS` frame that updates the limit.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在QUIC主机上使用不同的流也会消耗资源。接收方还可以限制远程主机可以创建的流的数量。在握手过程中，`initial_max_streams_bidi`和`initial_max_streams_uni`传输参数宣布接收主机可以接受的最多双向和单向流的数量。此限制可以在连接期间通过发送更新限制的`MAX_STREAMS`帧来修改。
- en: Flow control can also take place at the stream level. During the handshake,
    several transport parameters allow the hosts to advertise the maximum number of
    bytes that they agree to receive on each stream. Different transport parameters
    are used to specify the limits that apply to the local/remote and unidirectional/bidirectional
    streams. These limits can be updated during the connection by sending `MAX_STREAM_DATA`
    frames. Each of these frames indicates the maximum amount of stream data that
    can be accepted on a given stream.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 流量控制也可以在流级别上进行。在握手期间，几个传输参数允许主机宣布它们同意在每条流上接收的最大字节数。不同的传输参数用于指定适用于本地/远程和单向/双向流的限制。这些限制可以通过发送
    `MAX_STREAM_DATA` 帧在连接期间更新。这些帧中的每一个都指示了在给定流上可以接受的最大流数据量。
- en: These limits restrict the number of streams that a host can create and the amount
    of bytes that it can send. If a host is blocked by any of these limits, it may
    sent a control frame to request the remote host to extend the limit. For each
    type of flow control, there is an associated control frame which can be used to
    request an extension of the limit.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制限制了主机可以创建的流的数量以及它可以发送的字节数。如果一个主机被这些限制中的任何一个阻塞，它可能发送一个控制帧来请求远程主机扩展限制。对于每种类型的流量控制，都有一个相关的控制帧，可以用来请求扩展限制。
- en: A host should send a `DATA_BLOCKED` frame when it reaches the limit on the maximum
    amount of data set by the `initial_max_data` transport parameter or a previously
    received `MAX_DATA` frame. The `DATA_BLOCKED` frame contains the connection limit
    that caused the transmission to be blocked. In practice, a receiving host should
    increase the connection-level limit by sending `MAX_DATA` frames before reaching
    the limit. However, since this limit is function of the available memory, a host
    might not always be able to send a `MAX_DATA` frame. [Fig. 93](#fig-quic-example-max-data)
    provides an example packet flow with the utilization of these frames. We assume
    that the `initial_max_data` transport parameter was set to `100` bytes by the
    client during the handshake and the the server needs to send 900 bytes. The server
    creates a stream and sends 100 bytes in a `1-RTT` packet carrying a `STREAM` frame.
    At this point, the server is blocked.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机达到由 `initial_max_data` 传输参数或之前接收到的 `MAX_DATA` 帧设定的最大数据量限制时，应该发送一个 `DATA_BLOCKED`
    帧。这个 `DATA_BLOCKED` 帧包含了导致传输被阻塞的连接限制。在实践中，接收主机应该在达到限制之前通过发送 `MAX_DATA` 帧来增加连接级别的限制。然而，由于这个限制是可用内存的函数，主机可能并不总是能够发送一个
    `MAX_DATA` 帧。[图 93](#fig-quic-example-max-data) 展示了使用这些帧的示例数据包流。我们假设客户端在握手期间将
    `initial_max_data` 传输参数设置为 `100` 字节，而服务器需要发送 900 字节。服务器创建了一个流，并在携带 `STREAM` 帧的
    `1-RTT` 数据包中发送了 100 字节。此时，服务器被阻塞。
- en: '![Figure made with TikZ](../Images/5b5d3482cca71cc31e8478d8c94c256b.png)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/5b5d3482cca71cc31e8478d8c94c256b.png)'
- en: Fig. 93 QUIC uses `DATA_BLOCKED` frames when a connection’s flow control is
    blocked
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图 93 QUIC 在连接的流量控制被阻塞时使用 `DATA_BLOCKED` 帧进行流量控制
- en: The same applies with the `STREAM_DATA_BLOCKED` frame that is sent when a host
    reaching the per-stream limit. The `STREAMS_BLOCKED` frame is used when a host
    has reached the maximum number of established streams.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机达到每流的限制时发送的 `STREAM_DATA_BLOCKED` 帧也是如此。当一个主机达到已建立流的数量最大值时，使用 `STREAMS_BLOCKED`
    帧。
- en: Note
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Connections blocked by flow control are not totally idle
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 被流量控制阻塞的连接并非完全空闲
- en: If a QUIC host detects that a connection is blocked by flow control, it should
    regularly send `DATA_BLOCKED` or `STREAM_DATA_BLOCKED` frames to request the remote
    host to extend the current limit. The QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    does not recommend precisely how often these frames should be sent when a connection
    is blocked by flow control. Experience with QUIC deployments will enable the QUIC
    developers to more precisely define how often these frames should be sent.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 QUIC 主机检测到连接被流量控制阻塞，它应该定期发送 `DATA_BLOCKED` 或 `STREAM_DATA_BLOCKED` 帧来请求远程主机扩展当前限制。QUIC
    规范 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 并没有推荐在连接被流量控制阻塞时这些帧应该发送的精确频率。QUIC
    部署的经验将使 QUIC 开发者能够更精确地定义这些帧应该发送的频率。
- en: 'A measurement study [[MHLQ2020]](../bibliography.html#mhlq2020) revealed that
    QUIC implementations used different strategies for flow control. They identified
    three main types of behaviors :'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一项测量研究 [[MHLQ2020]](../bibliography.html#mhlq2020) 表明，QUIC 实现使用了不同的流量控制策略。他们确定了三种主要的行为类型：
- en: 'Static Flow Control: the receive buffer size stays unchanged and the receiver
    simply increases the maximum allowance linearly'
  id: totrans-491
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态流量控制：接收缓冲区的大小保持不变，接收方简单地线性增加最大允许量
- en: ''
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-493
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Growing Flow Control: the size of the receive buffer increases over time as
    the connection progresses'
  id: totrans-494
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长式流量控制：随着连接的进行，接收缓冲区的大小逐渐增加
- en: ''
  id: totrans-495
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-496
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Auto-tuning: the size of the receive buffer is adjusted dynamically based on
    the estimated bandwidth and round-trip times'
  id: totrans-497
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调整：接收缓冲区的大小根据估计的带宽和往返时间动态调整
- en: In 2020, three quarter of the studied implementations used a Static Flow Control
    and only one used auto-tuning. Static Flow Control can work, but this is a waste
    of memory. For example, Google’s Chrome starts with a 15 MBytes receive buffer
    and updates it linearly [[MHLQ2020]](../bibliography.html#mhlq2020). This should
    be contrasted with TCP implementations that usually start with a window of a few
    tens of KBytes and adjust it with auto-tuning. Auto-tuning is a key feature of
    modern TCP implementations [[SMM1998]](../bibliography.html#smm1998). It is expected
    that QUIC implementations will include more advanced heuristics to tune their
    flow control mechanism.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020年，四分之三的研究实现使用了静态流量控制，只有一个使用了自动调整。静态流量控制可以工作，但这是一种内存浪费。例如，Google的Chrome从15
    MBytes的接收缓冲区开始，并线性更新它 [[MHLQ2020]](../bibliography.html#mhlq2020)。这应该与通常从几个十KB的窗口开始并使用自动调整进行调整的TCP实现进行对比。自动调整是现代TCP实现的关键特性
    [[SMM1998]](../bibliography.html#smm1998)。预计QUIC实现将包括更高级的启发式方法来调整它们的流量控制机制。
- en: QUIC Loss Detection[#](#quic-loss-detection "Link to this heading")
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC丢包检测[#](#quic-loss-detection "链接到本标题")
- en: As other transport protocols, QUIC includes mechanisms to detect transmission
    errors and packet losses. The transmission errors are usually detected by using
    the UDP checksum or at the datalink layer with the Wi-Fi or Ethernet CRCs. When
    a transmission error occurs, the corresponding packet is discarded and QUIC considers
    this error as a packet loss. Researchers have analyzed the performance of checksums
    and CRCs on real data [[SGP98]](../bibliography.html#sgp98).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他传输协议一样，QUIC包括检测传输错误和丢包的机制。传输错误通常通过使用UDP校验和或Wi-Fi或以太网的CRC校验在数据链路层检测。当发生传输错误时，相应的数据包将被丢弃，QUIC将此错误视为丢包。研究人员已经分析了校验和和CRC在真实数据上的性能
    [[SGP98]](../bibliography.html#sgp98)。
- en: Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated
    and a receiver can leverage this AEAD to detect transmission errors that were
    undetected by the UDP checksum of the CRC of the lower layers. However, these
    undetected transmission errors are assumed to be rare and if QUIC a detects an
    invalid AEAD, it will consider that this error was caused by an attack and will
    stop the connection using a TLS alert [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于QUIC使用了AEAD加密方案，所有QUIC数据包都经过认证，接收方可以利用这一点来检测UDP校验和或下层CRC未检测到的传输错误。然而，这些未检测到的传输错误被认为是罕见的，如果QUIC检测到一个无效的AEAD，它将认为这个错误是由攻击引起的，并将使用TLS警报停止连接
    [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。
- en: There are several important differences between the loss detection and retransmission
    mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers
    always increase monotonically over a QUIC connection. A QUIC sender never sends
    twice a packet with the same packet number over a given connection. QUIC encodes
    the packet numbers as variable length integers and it does not support wrap around
    in contrast with other transport protocols. The QUIC frames contain the valuable
    information that needs to be delivered reliably. If a QUIC packet is lost, the
    frames that it contained will be retransmitted in another QUIC packet that uses
    a different packet number. Thus, the QUIC packet number serves as a unique identifier
    of a packet. This simplifies some operations such as measuring the round-trip-time
    which is more difficult in protocols such as TCP when packets are transmitted
    [[KP91]](../bibliography.html#kp91).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC与其他传输协议使用的丢包检测和重传机制之间存在几个重要差异。首先，QUIC数据包编号在QUIC连接中总是单调递增。QUIC发送者永远不会在给定连接中发送具有相同数据包编号的同一个数据包。QUIC将数据包编号编码为变长整数，并且与其他传输协议不同，它不支持回绕。QUIC帧包含需要可靠传输的宝贵信息。如果一个QUIC数据包丢失，它所包含的帧将在使用不同数据包编号的另一个QUIC数据包中重新传输。因此，QUIC数据包编号充当数据包的唯一标识符。这简化了一些操作，例如测量往返时间，这在TCP协议中当数据包传输时更为困难
    [[KP91]](../bibliography.html#kp91)。
- en: Second, QUIC’s acknowledgments carry more information than the cumulative or
    selective acknowledgments used by TCP and related protocols. This enables the
    receiver to provide a more detailed view of the packets that it received. In contrast
    with TCP [**RFC 2018**](https://datatracker.ietf.org/doc/html/rfc2018.html), once
    a receiver has reported that one packet was correctly received in an acknowledgment,
    the sender of that packet can discard the corresponding frames.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，QUIC的确认信息比TCP和相关协议使用的累积或选择性确认信息包含更多信息。这使得接收者能够提供其接收到的数据包的更详细视图。与TCP [**RFC
    2018**](https://datatracker.ietf.org/doc/html/rfc2018.html) 相比，一旦接收者报告一个数据包在确认中已被正确接收，该数据包的发送者就可以丢弃相应的帧。
- en: Third, a QUIC sender autonomously decides which frames it sends inside each
    packet. A QUIC packet may contain both data and control frames, or only data or
    only control information. If a QUIC packet is lost, the frames that it contained
    could be retransmitted in different packets. A QUIC implementation thus needs
    to buffer the frames and mark the in-flight ones to be able to retransmit them
    if the corresponding packet was lost.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，QUIC发送者自主决定在每个数据包中发送哪些帧。一个QUIC数据包可以包含数据和控制帧，或者只包含数据或只包含控制信息。如果一个QUIC数据包丢失，它包含的帧可以在不同的数据包中重新传输。因此，QUIC实现需要缓冲帧并标记正在传输的帧，以便在相应的数据包丢失时能够重新传输它们。
- en: Fourth, most QUIC packets are explicitly acknowledged. The only exception are
    the packets that only contain `ACK`, `PADDING` or `CONNECTION_CLOSE` frames. A
    packet that contains any other QUIC frame is called an ack-eliciting packet because
    its delivery will be confirmed by the transmission of an acknowledgment. A QUIC
    packet that carries both an `ACK` and a `STREAM` frame will thus be acknowledged.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，大多数QUIC数据包都明确地被确认。唯一的例外是只包含`ACK`、`PADDING`或`CONNECTION_CLOSE`帧的数据包。包含任何其他QUIC帧的数据包被称为ack-eliciting
    packet，因为它的交付将通过发送确认来得到确认。因此，携带`ACK`和`STREAM`帧的QUIC数据包将被确认。
- en: With this in mind, it is interesting to look at the format of the QUIC acknowledgments
    and then analyze how they can be used. [Listing 9](#fig-quic-ack-frame) provides
    the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types
    are used to distinguish between the acknowledgments that contain information about
    the received ECN flags (type `0x03`) or only regular acknowledgments (type `0x02`).
    The first information contained in the ACK frame is the largest packet number
    that is acknowledged by this ACK frame. This is usually the highest packet number
    received. The second information is the ACK delay. This is the delay in microseconds
    between the reception of the packet having the largest acknowledged number by
    the receiver and the transmission of the acknowledgment. This information is important
    to ensure that round-trip-times are accurately measured, even if a receiver delays
    acknowledgments. This is illustrated in [Fig. 94](#fig-quic-ack-delay). The `ACK
    Range Count` field contains the number of `ACK ranges` that are included in the
    QUIC ACK frame. This number can be set to zero if all packets were received in
    sequence without any gap. In this case, the `First ACK Range` field contains the
    number of the packet that arrived before the `Largest Acknowledged` packet number.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，研究QUIC确认的格式并分析它们如何被使用是非常有趣的。[列表9](#fig-quic-ack-frame)提供了ACK帧的格式。它可以在QUIC数据包中的任何时间发送。使用两种类型来区分包含接收到的ECN标志信息的确认（类型`0x03`）或仅包含常规确认（类型`0x02`）的确认。ACK帧中包含的第一个信息是此ACK帧确认的最大数据包编号。这通常是接收到的最高编号的数据包。第二个信息是ACK延迟。这是接收者接收具有最大确认编号的包与发送确认之间的微秒延迟。这个信息对于确保往返时间被准确测量非常重要，即使接收者延迟确认也是如此。这如图94所示。`ACK
    Range Count`字段包含包含在QUIC ACK帧中的`ACK范围`的数量。如果所有数据包都按顺序接收且没有间隙，则此数字可以设置为零。在这种情况下，`First
    ACK Range`字段包含在`Largest Acknowledged`包编号之前到达的包的编号。
- en: Listing 9 The QUIC ACK Frame[#](#fig-quic-ack-frame "Link to this code")
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9 QUIC ACK帧[#](#fig-quic-ack-frame "链接到这段代码")
- en: '[PRE33]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Figure made with TikZ](../Images/91a1bf7fc5600dfd204d9c3691a03f74.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/91a1bf7fc5600dfd204d9c3691a03f74.png)'
- en: Fig. 94 Utilization of the QUIC ACK delay
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图94 QUIC ACK延迟的利用
- en: An `ACK` frame contains 0 or more `ACK Ranges`. The format of an `ACK range`
    is shown in [Listing 10](#fig-quic-ack-range). Each range indicates first the
    number of unacknowledged packets since the smallest acknowledged packet in the
    preceding range (or the first ACK range). The next field indicates the number
    of consecutive acknowledged packets.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `ACK` 帧包含 0 个或多个 `ACK Ranges`。`ACK range` 的格式在 [列表 10](#fig-quic-ack-range
    "链接到此代码") 中显示。每个范围首先指示自前一个范围中最小的已确认数据包以来的未确认数据包数量（或第一个 `ACK range`）。下一个字段指示连续已确认数据包的数量。
- en: Listing 10 A QUIC ACK range[#](#fig-quic-ack-range "Link to this code")
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10 一个 QUIC ACK range[#](#fig-quic-ack-range "链接到此代码")
- en: '[PRE34]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As an example, consider a host that received the following QUIC packets: `3,4,6,7,8,9,11,14,16,18`.
    To report all the received packets, it will generate the `ACK` frame shown in
    [Listing 11](#fig-quic-sample-ack-frame).'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个接收了以下 QUIC 数据包的主机：`3,4,6,7,8,9,11,14,16,18`。为了报告所有接收到的数据包，它将生成如 [列表 11](#fig-quic-sample-ack-frame
    "链接到此代码") 所示的 `ACK` 帧。
- en: Listing 11 Sample QUIC ACK Frame[#](#fig-quic-sample-ack-frame "Link to this
    code")
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11 示例 QUIC ACK 帧[#](#fig-quic-sample-ack-frame "链接到此代码")
- en: '[PRE35]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The QUIC specification recommends to send one `ACK` frame after having received
    two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments
    strategy. However, there is ongoing work to allow the sender to provide more guidelines
    on when and how `ACK` frames should be sent.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 规范建议在收到两个请求确认的数据包后发送一个 `ACK` 帧。这大致对应于 TCP 的延迟确认策略。然而，目前正在进行工作，以允许发送者提供更多关于何时以及如何发送
    `ACK` 帧的指南。
- en: Note
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When should QUIC hosts send acknowledgments
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 主机何时应该发送确认
- en: A measurement study [[MHLQ2020]](../bibliography.html#mhlq2020) analyzed how
    QUIC implementations generate acknowledgments. Two of the studied implementations
    sent acknowledgments every N packets (2 for one implementation and 10 for the
    other). Other implementations used ack frequencies that varied during the data
    transfer.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 一项测量研究 [[MHLQ2020]](../bibliography.html#mhlq2020) 分析了 QUIC 实现如何生成确认。被研究的两种实现中，一种每
    N 个数据包发送一次确认（一个实现为 2，另一个为 10）。其他实现使用了在数据传输过程中变化的确认频率。
- en: ([`Source code`](../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py),
    [`png`](../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png), [`hires.png`](../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png),
    [`pdf`](../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf))
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ([`源代码`](../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py), [`png`](../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png),
    [`hires.png`](../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png),
    [`pdf`](../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf))
- en: '![../_images/quic-1.png](../Images/3a962b543fdebe8ff46dbfacfe31e189.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-1.png](../Images/3a962b543fdebe8ff46dbfacfe31e189.png)'
- en: Fig. 95 Acknowledgment frequencies for different QUIC servers[#](#id28 "Link
    to this image")
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 图 95 不同 QUIC 服务器的确认频率[#](#id28 "链接到此图像")
- en: The acknowledgment frequencies should be compared with TCP that usually acknowledges
    every second packet. It is likely that QUIC implementations will tune the generation
    of their acknowledgments in the coming years based on feedback from deployment.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 确认频率应该与通常每秒确认一个数据包的 TCP 进行比较。预计在接下来的几年中，QUIC 实现将根据部署的反馈调整其确认的生成。
- en: It is interesting to observe that since the `ACK` frames are sent inside QUIC
    packets, they can also be acknowledged. Sending an `ACK` in response to another
    `ACK` could result in an infinite exchange of `ACK` frames. To prevent this problem,
    a QUIC sender cannot send an `ACK` frame in response to a non-eliciting QUIC packet
    and the `ACK` frames are one of the non-eliciting frame types. Note that if a
    receiver that receives many `STREAM` frames and thus sends many `ACK` frames wants
    to obtain information about the reception of its `ACK` frame, it can simply send
    one `ACK` frame inside a packet that contains an eliciting frame, e.g. a `PING`
    frame. This frame will trigger the receiver to acknowledge it and the previously
    sent `ACK` frames.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到 `ACK` 帧是在 QUIC 数据包内部发送的，因此它们也可以被确认。对另一个 `ACK` 帧发送 `ACK` 可能会导致 `ACK` 帧的无穷交换。为了防止这个问题，QUIC
    发送者不能对非请求的 QUIC 数据包发送 `ACK` 帧，而 `ACK` 帧是非请求帧类型之一。请注意，如果一个接收者接收了许多 `STREAM` 帧并因此发送了许多
    `ACK` 帧，想要了解其 `ACK` 帧的接收情况，它可以在包含请求帧的数据包中简单地发送一个 `ACK` 帧，例如一个 `PING` 帧。这个帧将触发接收者对其进行确认以及之前发送的
    `ACK` 帧。
- en: In contrast with other reliable transport protocols, QUIC does not use cumulative
    acknowledgments. As explained earlier, QUIC never retransmits a packet with the
    same packet number. When a packet is lost, this creates a gap that the receiver
    reports using an `ACK Range`. Such a gap will never be filled by retransmissions
    and obviously should not be reported by the receiver forever. In practice, a receiver
    will send the acknowledgment that corresponds to a given packet number several
    times and then will assume that the acknowledgment has been received. A receiver
    can also rely on other heuristics to determine that a given `ACK Range` should
    not be reported anymore. This is the case if the `ACK` frame was included in a
    packet that has been acknowledged by the other peer, but also when the gap was
    noticed several round-trip times ago.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他可靠传输协议相比，QUIC 不使用累积确认。如前所述，QUIC 从不重新传输具有相同包号的包。当一个包丢失时，这会创建一个接收方使用 `ACK Range`
    报告的间隙。这样的间隙永远不会通过重传来填补，显然接收方不应该永远报告这个间隙。在实践中，接收方会发送与给定包号相对应的确认多次，然后假设确认已被接收。接收方还可以依靠其他启发式方法来确定某个
    `ACK Range` 不再需要报告。这种情况发生在 `ACK` 帧包含在一个已被另一对等方确认的包中时，也发生在间隙被注意到几个往返时间之前。
- en: QUIC also allows a receiver to send information about the ECN flags in the received
    packets. Two flags of the IP header [**RFC 3168**](https://datatracker.ietf.org/doc/html/rfc3168.html)
    are reserved to indicate support for Explicit Congestion Notification. The QUIC
    ECN count field shown in [Listing 12](#fig-quic-ecn-count) contains three counters
    for the different values of the ECN flags. These counters are incremented upon
    the reception of each QUIC packet based on the values of the ECN flag of the received
    packet. Unfortunately, there are still many operational problems when using ECN
    in the global Internet [[MLBBA2018]](../bibliography.html#mlbba2018). Time will
    tell whether it is easier to deploy ECN with QUIC than with TCP.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 还允许接收方发送有关接收到的包中 ECN 标志的信息。IP 头部的两个标志 [**RFC 3168**](https://datatracker.ietf.org/doc/html/rfc3168.html)
    保留以指示对显式拥塞通知的支持。在 [列表 12](#fig-quic-ecn-count) 中显示的 QUIC ECN 计数字段包含三个计数器，用于表示
    ECN 标志的不同值。这些计数器在接收到每个 QUIC 包时根据接收到的包的 ECN 标志值递增。不幸的是，在全球互联网中使用 ECN 仍然存在许多操作问题
    [[MLBBA2018]](../bibliography.html#mlbba2018)。时间将证明使用 QUIC 部署 ECN 是否比使用 TCP 更容易。
- en: Listing 12 A QUIC ECN Count[#](#fig-quic-ecn-count "Link to this code")
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12 A QUIC ECN Count[#](#fig-quic-ecn-count "链接到这段代码")
- en: '[PRE36]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: QUIC also acknowledges control frames
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 也确认控制帧
- en: Besides the STREAM frames that carry user data, QUIC uses several different
    frame types to exchange control information. These control frames, like the data
    frames, are ack-eliciting frames. This implies a host that receives such a frame
    needs to acknowledge it using an `ACK` frame.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 除了携带用户数据的 STREAM 帧之外，QUIC 还使用几种不同的帧类型来交换控制信息。这些控制帧，就像数据帧一样，是请求确认的帧。这意味着接收此类帧的主机需要使用一个
    `ACK` 帧来确认它。
- en: '[Fig. 97](#fig-quic-ack-initials) illustrates the beginning of a QUIC connection
    with the exchange of the `Initial` packets and the corresponding acknowledgments.
    The client sends its `TLS Client Hello` inside a `CRYPTO` frame in an `Initial`
    packet. This is the first packet sent by the client and thus its packet number
    is 0\. The server replies with a `TLS Server Hello` inside a `CRYPTO` frame in
    an `Initial` packet. Since this is the first packet sent by the server, its packet
    number is also 0\. The packet also contains an `ACK` frame that acknowledges the
    reception of the packet containing the `TLS Client Hello`.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 97](#fig-quic-ack-initials) 展示了 QUIC 连接的开始，通过交换 `Initial` 包和相应的确认。客户端在一个
    `Initial` 包中将其 `TLS Client Hello` 放入一个 `CRYPTO` 帧中。这是客户端发送的第一个包，因此其包号为 0。服务器在一个
    `Initial` 包中用 `CRYPTO` 帧回复一个 `TLS Server Hello`。由于这是服务器发送的第一个包，其包号也是 0。该包还包含一个
    `ACK` 帧，确认接收到了包含 `TLS Client Hello` 的包。'
- en: The `Handshake`, `0-RTT` and `1-RTT` packets are acknowledged similarly using
    `ACK` frames. `Handshake` packets are acknowledged in other `Handshake` packets
    while `0-RTT` and `1-RTT` packets are acknowledged inside `1-RTT` packets.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handshake`、`0-RTT` 和 `1-RTT` 包也使用 `ACK` 帧进行类似的确认。`Handshake` 包在其他 `Handshake`
    包中确认，而 `0-RTT` 和 `1-RTT` 包在 `1-RTT` 包内确认。'
- en: '![Figure made with TikZ](../Images/75ed846fe9a217630046fd48dc876f1b.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/75ed846fe9a217630046fd48dc876f1b.png)'
- en: Fig. 97 QUIC also acknowledges Initial frames
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图 97 QUIC 也确认 Initial 帧的存在
- en: Note
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all QUIC servers use 0 as the packet number of their first Initial packet
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有QUIC服务器都将0用作它们第一个初始数据包的数据包编号
- en: The example shows a QUIC connection where the client sent its Initial packet
    with packet number 0 and the server also replied with a packet number set to 0\.
    This is what most QUIC implementations do. However, the QUIC specification does
    not strictly requires this. In fact, `facebook` servers in October 2022 appear
    to use random packet numbers for the Initial packet that they sent in response
    to a client. This is probably use to detect or mitigate some forms of attacks
    since the client must receive the server’s Initial packet to be able to produce
    a valid acknowledgment.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了QUIC连接，其中客户端发送了编号为0的初始数据包，服务器也以编号设置为0的数据包进行了回复。这是大多数QUIC实现的做法。然而，QUIC规范并没有严格要求这样做。实际上，2022年10月，`facebook`服务器似乎在响应客户端时，为发送的初始数据包使用了随机的数据包编号。这可能是为了检测或减轻某些形式的攻击，因为客户端必须接收到服务器的初始数据包才能生成有效的确认。
- en: To illustrate how QUIC uses acknowledgments, let us consider a simple QUIC connection.
    The client starts a QUIC connection with a new server, sends a request, receives
    a response and then closes the connection. There are no losses in this connection.
    [Fig. 98](#fig-quic-ack-short) illustrates this connection.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明QUIC如何使用确认，让我们考虑一个简单的QUIC连接。客户端与一个新服务器建立QUIC连接，发送一个请求，接收一个响应，然后关闭连接。在这个连接中没有数据丢失。[图98](#fig-quic-ack-short)展示了这个连接。
- en: '![Figure made with TikZ](../Images/00d236df000f95dc0877d8231f52d999.png)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/00d236df000f95dc0877d8231f52d999.png)'
- en: Fig. 98 Acknowledgments in a short QUIC connection
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 图98 短QUIC连接中的确认
- en: The connection starts when the client sends an `Initial` packet containing a
    `CRYPTO` frame with the `TLS Client Hello`. The server replies with an `Initial`
    packet that contains an acknowledgment and a `CRYPTO` frame with the `TLS Server
    Hello`. The server then sends an `Initial` packet containing the `TLS Encrypted
    Extensions`. Since this is the first `Initial` packet, its packet number is set
    to 0\. In practice, it is likely that the server will need to send several packets
    to carry the certificates contained in this packet. Note that the server cannot
    send more than 3 packets in response to the client’s `Initial` packet. This limit
    was introduced in the QUIC specification to restrict the ability of attackers
    to trigger DDoS attacks by sending spoofed packets to QUIC servers [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    If the `CRYPTO` frame containing the certificates is too long, the server might
    need to wait for acknowledgments from the client before sending its last `Handshake`
    packets. The client confirms the reception of the server’s `Initial` packet by
    sending its last `Initial` packet that contains an `ACK` frame. This is the second
    `Initial` packet sent by the client and its packet number is thus 1\. Since this
    packet only contains an `ACK` frame, the server does not return an acknowledgment
    to confirm its reception.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 连接开始于客户端发送一个包含带有`TLS Client Hello`的`CRYPTO`帧的`Initial`数据包。服务器以包含确认和一个带有`TLS
    Server Hello`的`CRYPTO`帧的`Initial`数据包进行回复。然后服务器发送一个包含`TLS Encrypted Extensions`的`Initial`数据包。由于这是第一个`Initial`数据包，其数据包编号被设置为0。实际上，服务器可能需要发送多个数据包来携带这个数据包中包含的证书。请注意，服务器不能向客户端的`Initial`数据包发送超过3个数据包。这个限制是在QUIC规范中引入的，以限制攻击者通过向QUIC服务器发送伪造数据包来触发DDoS攻击的能力[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。如果包含证书的`CRYPTO`帧太长，服务器可能需要等待客户端的确认，然后才能发送最后的`Handshake`数据包。客户端通过发送包含`ACK`帧的最后`Initial`数据包来确认已接收服务器的`Initial`数据包。这是客户端发送的第二个`Initial`数据包，因此其数据包编号为1。由于这个数据包只包含`ACK`帧，服务器不需要返回确认来确认其接收。
- en: The client replies to the `Handshake` packet with another `Handshake` packet
    that contains a `CRYPTO` frame and acknowledges the `Handshake` packets sent by
    the server. The client’s `Handshake` packet is acknowledged by the server. The
    server starts the data exchange by sending a `1-RTT` packet carrying one or more
    stream frames to create the required streams. Since this is the first `1-RTT`
    packet sent by the server, its packet number is set to 0\. The client then sends
    its request in a `STREAM` frame. The server replies with a `1-RTT` packet that
    contains a `STREAM` frame with its response. The client ends the connection by
    sending a `CONNECTION_CLOSE` frame. In the example, the server replies with a
    `CONNECTION_CLOSE` frame, but the QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    only indicates that a host may respond with a `CONNECTION_CLOSE` in this case.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端用包含 `CRYPTO` 帧的另一个 `Handshake` 数据包回复 `Handshake` 数据包，并确认服务器发送的 `Handshake`
    数据包。服务器的 `Handshake` 数据包被客户端确认。服务器通过发送一个携带一个或多个流帧的 `1-RTT` 数据包来开始数据交换，创建所需的流。由于这是服务器发送的第一个
    `1-RTT` 数据包，其包号被设置为 0。然后客户端在一个 `STREAM` 帧中发送其请求。服务器用一个包含 `STREAM` 帧的 `1-RTT` 数据包回复，其中包含其响应。客户端通过发送一个
    `CONNECTION_CLOSE` 帧来结束连接。在示例中，服务器用一个 `CONNECTION_CLOSE` 帧回复，但 QUIC 规范 [**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 只指出，在这种情况下，主机可以响应一个
    `CONNECTION_CLOSE`。
- en: Observing QUIC connections[#](#observing-quic-connections "Link to this heading")
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察 QUIC 连接[#](#observing-quic-connections "链接到这个标题")
- en: We have now reviewed the main components of the QUIC specification. To illustrate
    it, let us consider a simple scenario where a client opens a QUIC connection with
    a server. We leverage Maxime Piraux’s QUIC tracker [[PDB2018]](../bibliography.html#pdb2018).
    In this example, we use the packet trace collected using the `nghttp2.org` server
    on November 22, 2021 at 18:04:52 CET. This trace is available from [https://quic-tracker.info.ucl.ac.be/traces/20211122/148](https://quic-tracker.info.ucl.ac.be/traces/20211122/148).
    You can see the contents of the packets, download it as a `.pcap` trace or visualize
    it using QLog/QViz [[MPQL2020]](../bibliography.html#mpql2020) from this web site.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经回顾了 QUIC 规范的主要组成部分。为了说明它，让我们考虑一个简单的场景，其中客户端与服务器建立一个 QUIC 连接。我们利用 Maxime
    Piraux 的 QUIC 跟踪器 [[PDB2018]](../bibliography.html#pdb2018)。在这个例子中，我们使用 2021 年
    11 月 22 日 18:04:52 CET 使用 `nghttp2.org` 服务器收集的包跟踪。这个跟踪可以从 [https://quic-tracker.info.ucl.ac.be/traces/20211122/148](https://quic-tracker.info.ucl.ac.be/traces/20211122/148)
    获取。您可以看到数据包的内容，将其下载为 `.pcap` 跟踪，或使用 QLog/QViz [[MPQL2020]](../bibliography.html#mpql2020)
    从此网站进行可视化。
- en: This trace contains 16 packets. The scenario is a simple handshake with an exchange
    of data.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跟踪包含 16 个数据包。场景是一个简单的握手和数据交换。
- en: '![../_images/qtracker-nghttp2-1.png](../Images/7e3eb62de8971ff53e65f8fbea028144.png)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-nghttp2-1.png](../Images/7e3eb62de8971ff53e65f8fbea028144.png)'
- en: Fig. 99 Sample QUIC tracker trace with `nghttp2.org` containing a successful
    handshake[#](#id32 "Link to this image")
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图 99 包含成功握手的 `nghttp2.org` 的样本 QUIC 跟踪器跟踪信息[#](#id32 "链接到这张图片")
- en: To initiate the connection, the client sends an `Initial` QUIC packet. It is
    interesting to analyze the content of this packet. It starts with a long QUIC
    header shown in [Listing 13](#fig-trace-quic-header-p1).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化连接，客户端发送一个 `Initial` QUIC 数据包。分析这个数据包的内容很有趣。它以一个长的 QUIC 报头开始，如 [列表 13](#fig-trace-quic-header-p1)
    所示。
- en: Listing 13 The QUIC header of the first packet sent by the client[#](#fig-trace-quic-header-p1
    "Link to this code")
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13 客户端发送的第一个数据包的 QUIC 报头[#](#fig-trace-quic-header-p1 "链接到这段代码")
- en: '[PRE37]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The client proposes a 64 bits connection identifier and uses a random 64 bits
    identifier for the destination connection identifier. There is no token in this
    packet since this is the first connection from this client to the server. It is
    useful to note that the packet number of this `Initial` packet is set to zero.
    All QUIC connections start with a packet whose packet number is set to zero in
    contrast with TCP that uses a random sequence number. The packet contains a `CRYPTO`
    frame shown in [Listing 14](#fig-trace-quic-crypto-p1).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端提出一个 64 位的连接标识符，并使用一个随机的 64 位的标识符作为目标连接标识符。由于这是客户端到服务器的第一个连接，这个数据包中没有令牌。值得注意的是，这个
    `Initial` 数据包的包号被设置为 0。所有 QUIC 连接都以一个包号设置为 0 的数据包开始，这与使用随机序列号的 TCP 相比。数据包包含一个
    `CRYPTO` 帧，如 [列表 14](#fig-trace-quic-crypto-p1) 所示。
- en: Listing 14 The CRYPTO frame of the first QUIC packet sent by the client[#](#fig-trace-quic-crypto-p1
    "Link to this code")
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14 客户端发送的第一个 QUIC 数据包的 CRYPTO 帧[#](#fig-trace-quic-crypto-p1 "链接到这段代码")
- en: '[PRE38]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `CRYPTO` frame starts at offset 0 and has a length of `245` bytes. It contains
    a TLS 1.3 `ClientHello` message whose format is specified in [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    This `ClientHello` includes a 32 bytes secure random number, a set of proposed
    cipher suites and a series of TLS extensions. One of these extensions carries
    the QUIC transport parameters proposed by the client. On this connection, the
    QUIC tracker client proposed the following ones:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`CRYPTO` 帧从偏移量 0 开始，长度为 `245` 字节。它包含一个 TLS 1.3 的 `ClientHello` 消息，其格式在 [**RFC
    8446**](https://datatracker.ietf.org/doc/html/rfc8446.html) 中指定。这个 `ClientHello`
    包含一个 32 字节的加密随机数，一组提议的加密套件和一系列 TLS 扩展。其中之一携带了客户端提出的 QUIC 传输参数。在这个连接上，QUIC 追踪器客户端提出了以下内容：'
- en: '`initial_max_stream_data_bidi_local` = 0x80004000'
  id: totrans-557
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_stream_data_bidi_local` = 0x80004000'
- en: ''
  id: totrans-558
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_stream_data_uni` = 0x80004000'
  id: totrans-560
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_stream_data_uni` = 0x80004000'
- en: ''
  id: totrans-561
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_data` = 0x80008000'
  id: totrans-563
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_data` = 0x80008000'
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_streams_bidi` = 0x1'
  id: totrans-566
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_streams_bidi` = 0x1'
- en: ''
  id: totrans-567
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_streams_uni` = 0x3'
  id: totrans-569
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_streams_uni` = 0x3'
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-571
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_idle_timeout` = 0x6710'
  id: totrans-572
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_idle_timeout` = 0x6710'
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`active_connection_id_limit` = 0x4'
  id: totrans-575
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_connection_id_limit` = 0x4'
- en: ''
  id: totrans-576
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-577
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_packet_size` = 0x45c0'
  id: totrans-578
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_packet_size` = 0x45c0'
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-580
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`inital_source_connection_id` = 0xc9f54d3c298296b9'
  id: totrans-581
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inital_source_connection_id` = 0xc9f54d3c298296b9'
- en: Finally, the first QUIC packet contains a `PADDING` frame with 960 dummy bytes.
    The entire packet is 1236 bytes long.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第一个 QUIC 数据包包含一个包含 960 个虚拟字节的 `PADDING` 帧整个数据包长度为 1236 字节。
- en: The server responds to this `Initial` packet with two packets. The first one
    is an `Initial` packet. It starts with the header shown in [Listing 15](#fig-trace-quic-header-p2).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器用两个数据包响应这个 `Initial` 数据包。第一个是一个 `Initial` 数据包。它以 [列表 15](#fig-trace-quic-header-p2)
    中显示的头部开始。
- en: Listing 15 The QUIC header of the first packet sent by the client[#](#fig-trace-quic-header-p2
    "Link to this code")
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15 客户端发送的第一个数据包的 QUIC 头部[#](#fig-trace-quic-header-p2 "链接到这段代码")
- en: '[PRE39]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This server uses 18 bytes to encode its connection identifier and proposes
    the first identifier in the long header. The packet payload contains two frames:
    an `ACK` frame and a `CRYPTO` frame. The `ACK` frame ([Listing 16](#fig-trace-quic-ack-p2))
    acknowledges the reception of the `Initial` packet sent by the client. The `CRYPTO`
    frame contains the TLS ServerHello.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用 18 字节来编码其连接标识符，并在长头部中提出第一个标识符。数据包有效负载包含两个帧：一个 `ACK` 帧和一个 `CRYPTO` 帧。`ACK`
    帧([列表 16](#fig-trace-quic-ack-p2))确认接收了客户端发送的 `Initial` 数据包。`CRYPTO` 帧包含 TLS 服务器问候语。
- en: Listing 16 The ACK Frame of the first packet sent by the server[#](#fig-trace-quic-ack-p2
    "Link to this code")
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16 服务器发送的第一个数据包的 ACK 帧[#](#fig-trace-quic-ack-p2 "链接到这段代码")
- en: '[PRE40]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The payload of these `Initial` packets is encrypted using the static key derived
    from the connection identifiers included in the long header.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Initial` 数据包的有效负载使用从长头部中包含的连接标识符派生的静态密钥进行加密。
- en: 'The server then sends three `Handshake` packets carrying a `CRYPTO` frame that
    contains the `TLSEncryptedExtensions`. These extensions are encrypted using the
    TLS key. They mainly contain the server certificate. It is interesting to note
    that the `packet_number` field of the first `Handshake` packet sent by the server
    is also set to zero. This is the second, but not the last, packet that we observe
    with this `packet_number`. QUIC handles packet numbers differently then other
    protocols. QUIC considers that a QUIC connection is divided in three phases:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器发送三个携带 `CRYPTO` 帧的 `Handshake` 数据包，该帧包含 `TLSEncryptedExtensions`。这些扩展使用
    TLS 密钥加密。它们主要包含服务器证书。值得注意的是，服务器发送的第一个 `Handshake` 数据包的 `packet_number` 字段也设置为零。这是第二个，但不是最后一个，我们观察到具有此
    `packet_number` 的数据包。QUIC 以不同于其他协议的方式处理数据包编号。QUIC 认为QUIC连接分为三个阶段：
- en: The exchange of the `Initial` packets
  id: totrans-591
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换 `Initial` 数据包
- en: ''
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-593
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The exchange of the `Handshake` packets
  id: totrans-594
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换 `Handshake` 数据包
- en: ''
  id: totrans-595
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-596
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The exchange of the other packets (`0-RTT`, `1-RTT`, … packets)
  id: totrans-597
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换其他数据包（`0-RTT`、`1-RTT` 等数据包）
- en: A QUIC host restarts the `packet_number` at zero in each phase. This explains
    why it is possible to observe different packets (of different types) with the
    same `packet_number` over a QUIC connection.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '每个阶段，QUIC 主机都将 `packet_number` 重置为零。这解释了为什么可以在QUIC连接中观察到具有相同 `packet_number`
    的不同数据包（不同类型）。 '
- en: The three `Handshake` packets sent by the server contain the beginning of the
    `TLSEncryptedExtensions` sent by the server. To prevent denial of service attacks,
    the server cannot send more than three full-length packets in response to a packet
    sent by the client. The server thus needs to wait for an acknowledgment from the
    client before sending additional packets.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的三个`Handshake`数据包包含服务器发送的`TLSEncryptedExtensions`的开始部分。为了防止拒绝服务攻击，服务器不能在响应客户端发送的数据包时发送超过三个完整长度的数据包。因此，服务器在发送额外的数据包之前需要等待客户端的确认。
- en: The client sends two packets to carry these acknowledgments. First, it sends
    an `Initial` packet as the sixth packet of the trace. This packet belongs to the
    packet numbering space of the `Initial` packets. Its packet number is 1 since
    this is the second `Initial` packet sent by the client. The next acknowledgment
    is carried inside an `Handshake` packet. It acknowledges the `Handshake` packets
    0-2 sent by the server. Since this is the first `Handshake` packet sent by the
    client, its packet number is also 0.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送两个数据包来携带这些确认信息。首先，它发送一个`Initial`数据包作为跟踪的第六个数据包。此数据包属于`Initial`数据包的包编号空间。其包编号为1，因为这是客户端发送的第二个`Initial`数据包。下一个确认信息包含在一个`Handshake`数据包中。它确认了服务器发送的0-2号`Handshake`数据包。由于这是客户端发送的第一个`Handshake`数据包，其包编号也是0。
- en: The server then sends the eighth packet that contains the last part of the `TLSEncryptedExtensions`
    in a `CRYPTO` frame. By combining the information contained in the `Handshake`
    packets and the `Initial` packets, the client can derive the session keys.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器发送第八个数据包，该数据包包含在`CRYPTO`帧中的`TLSEncryptedExtensions`的最后部分。通过结合`Handshake`数据包和`Initial`数据包中包含的信息，客户端可以推导出会话密钥。
- en: The server immediately sends its first `1-RTT` packet. This packet contains
    a short header shown in [Listing 17](#fig-trace-quic-short-header).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器立即发送其第一个`1-RTT`数据包。此数据包包含一个短头，如[列表17](#fig-trace-quic-short-header)所示。
- en: Listing 17 The QUIC short header of the first 1-RTT packet sent by the server[#](#fig-trace-quic-short-header
    "Link to this code")
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17 服务器发送的第一个1-RTT数据包的QUIC短头[#](#fig-trace-quic-short-header "链接到此代码")
- en: '[PRE41]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This short header contains the connection identifier proposed by the client
    in the first `Initial` packet. The payload contains `STREAM` frames that create
    three streams. The client replies with two packets. The tenth packet of the trace
    is a `Handshake` packet that carries two frames. The `CRYPTO` frame contains the
    `TLS Finished` message that finalizes the TLS handshake. The `ACK` frame acknowledges
    the four `Handshake` packets sent by the server.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 此短头包含客户端在第一个`Initial`数据包中提出的连接标识符。有效载荷包含创建三个流的`STREAM`帧。客户端用两个数据包进行回复。跟踪的第十个数据包是一个`Handshake`数据包，携带两个帧。`CRYPTO`帧包含`TLS
    Finished`消息，用于完成TLS握手。`ACK`帧确认了服务器发送的四个`Handshake`数据包。
- en: The first `1-RTT` packet sent by the client contains an `ACK` frame that acknowledges
    the `1-RTT` packet sent by the server and flow control information. The client
    sends a `MAX_DATA` frame to restrict the amount of data that the server can send
    and one `MAX_STREAM` frame for each of the three streams created by the server.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的第一个`1-RTT`数据包包含一个`ACK`帧，确认了服务器发送的`1-RTT`数据包和流量控制信息。客户端发送一个`MAX_DATA`帧来限制服务器可以发送的数据量，并为服务器创建的每个三个流发送一个`MAX_STREAM`帧。
- en: The twelfth packet of the trace is more interesting. It contains five different
    frames that are sent by the server. First, the server send two `NEW_CONNECTION_ID`
    frames that advertise two 18 bytes long connection identifiers which can be used
    by the client to migrate the connection later. The next frame is the `HANDSHAKE_DONE`
    frame that confirms the TLS handshake. The server also sends a `NEW_TOKEN` frame
    that contains a 57 bytes long token that the client will be able to use in subsequent
    connections with the server. The last frame is a `CRYPTO` frame that contains
    two `TLS New Session Tickets`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的第十二个数据包更有趣。它包含由服务器发送的五个不同帧。首先，服务器发送两个`NEW_CONNECTION_ID`帧，宣布了两个18字节长的连接标识符，客户端可以使用这些标识符在以后迁移连接。下一个帧是`HANDSHAKE_DONE`帧，确认了TLS握手。服务器还发送了一个`NEW_TOKEN`帧，其中包含一个57字节长的令牌，客户端将在随后的服务器连接中使用这个令牌。最后一个帧是一个`CRYPTO`帧，包含两个`TLS
    New Session Tickets`。
- en: A closer look at other QUIC handshakes[#](#a-closer-look-at-other-quic-handshakes
    "Link to this heading")
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仔细研究其他QUIC握手过程[#](#a-closer-look-at-other-quic-handshakes "链接到本标题")
- en: It is interesting to analyze how different servers perform the handshake using
    QUIC tracker. Let us first explore the [trace collected with cloudflare-quic.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)
    on the same day shown in [Fig. 100](#fig-qtracker-cloudflare). There are several
    differences with the nghttp2 trace that we analyzed above. First, the server sends
    two small packets in response to the client’s `Initial`. The first packet only
    contains an `ACK` frame. It advertises a 20 bytes long connection identifier.
    The second packet contains a `CRYPTO` frame with a `TLS Hello Retry Request`.
    This message indicates that the server did not agree with the `key_share` parameter
    of the `TLS Client Hello` sent in the first packet. The client acknowledges this
    packet and sends a new `TLS Client Hello` in the fourth packet. The server replies
    with a `TLS Server Hello` and then the `TLSEncryptedExtensions` in three QUIC
    packets. The certificate used by `cloudflare-quic.com` is more compact than the
    one used by `nghttp2.org`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 分析不同服务器如何使用QUIC跟踪器执行握手很有趣。让我们首先探索同一天显示在 [图 100](#fig-qtracker-cloudflare) 中的
    [cloudflare-quic.com 收集的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)。与上面分析的
    nghttp2 跟踪相比，有几个不同之处。首先，服务器向客户端的 `Initial` 响应发送了两个小数据包。第一个数据包只包含一个 `ACK` 帧。它宣传了一个
    20 字节长的连接标识符。第二个数据包包含一个带有 `TLS Hello Retry Request` 的 `CRYPTO` 帧。此消息表示服务器不同意第一个数据包中发送的
    `TLS Client Hello` 的 `key_share` 参数。客户端确认此数据包，并在第四个数据包中发送一个新的 `TLS Client Hello`。服务器回复一个
    `TLS Server Hello`，然后在三个QUIC数据包中发送 `TLSEncryptedExtensions`。`cloudflare-quic.com`
    使用的证书比 `nghttp2.org` 使用的更紧凑。
- en: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
- en: Fig. 100 Sample quic tracker trace from cloudflare-quic.com with a successful
    handshake[#](#id33 "Link to this image")
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 图 100 来自 cloudflare-quic.com 的成功握手的quic跟踪器示例[#](#id33 "链接到这张图片")
- en: The `1-RTT` packets are also slightly different. The first `1-RTT` packet sent
    by the server contains the `HANDSHAKE_DONE` frame, a `CRYPTO` frame with two `TLS
    New Session Ticket` messages and a `STREAM` frame that creates one stream. The
    server then sends two short packet. Each of these packets contains a `STREAM`
    frame that creates a new stream. These two short packets could have been packed
    in the first `1-RTT` packet sent by the server. In contrast with `nghttp2.org`,
    `cloudflare-quic.com` does advertise new connection identifiers.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`1-RTT` 数据包也有一些不同。服务器发送的第一个 `1-RTT` 数据包包含一个 `HANDSHAKE_DONE` 帧，一个带有两个 `TLS
    New Session Ticket` 消息的 `CRYPTO` 帧，以及一个创建一个流的 `STREAM` 帧。然后服务器发送两个短数据包。每个数据包都包含一个创建新流的
    `STREAM` 帧。这两个短数据包原本可以打包在服务器发送的第一个 `1-RTT` 数据包中。与 `nghttp2.org` 相比，`cloudflare-quic.com`
    并没有宣传新的连接标识符。'
- en: Our third example is [picoquic](https://github.com/private-octopus/picoquic).
    The [QUIC tracker trace with test.privateoctopus.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/159)
    contains 13 packets.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个例子是 [picoquic](https://github.com/private-octopus/picoquic)。[与 test.privateoctopus.com
    的QUIC跟踪器跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/159) 包含 13 个数据包。
- en: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
- en: Fig. 101 Sample QUIC tracker trace from `test.privateoctopus.com` with a successful
    handshake[#](#id34 "Link to this image")
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 图 101 来自 `test.privateoctopus.com` 的成功握手的QUIC跟踪器示例[#](#id34 "链接到这张图片")
- en: picoquic uses 64 bits long connection identifiers. It manages to fit its `TLS
    Encrypted Extensions` within two `Handshake` packets. The first `1-RTT` packet
    that it sends contains a `PING` frame. The second `1-RTT` packet contains one
    `CRYPTO` frame that advertises one `TLS New Session Ticket`, three `NEW_CONNECTION_ID`
    frames and a `NEW_TOKEN` frame. This test server does not try to create new streams
    in contrast with the two others.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: picoquic 使用 64 位长的连接标识符。它设法将其 `TLS Encrypted Extensions` 放在两个 `Handshake` 数据包中。它发送的第一个
    `1-RTT` 数据包包含一个 `PING` 帧。第二个 `1-RTT` 数据包包含一个 `CRYPTO` 帧，该帧宣传了一个 `TLS New Session
    Ticket`，三个 `NEW_CONNECTION_ID` 帧和一个 `NEW_TOKEN` 帧。与此处的两个其他测试服务器不同，这个测试服务器并没有尝试创建新的流。
- en: Note
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing QUIC servers
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 比较QUIC服务器
- en: It is interesting to use the traces collected by QUIC tracker to analyze how
    different servers have selected some of the optional features of QUIC. A first
    difference between the servers is the length of the server-selected connection
    identifiers. The graph below shows that in November 2021 many servers advertised
    8 bytes CIDs, but some have opted for much longer CIDs.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 QUIC 跟踪器收集的跟踪记录来分析不同服务器如何选择 QUIC 的一些可选功能是非常有趣的。服务器之间的第一个区别是服务器选择的连接标识符的长度。下面的图表显示，在
    2021 年 11 月，许多服务器宣布了 8 字节的 CIDs，但有些服务器选择了更长的 CIDs。
- en: ([`Source code`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py),
    [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png), [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: ([`源代码`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py), [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png),
    [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
- en: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
- en: Fig. 102 Length of the connection identifiers advertised by different QUIC servers
    (Nov 2021)[#](#id35 "Link to this image")
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图 102 不同 QUIC 服务器宣布的连接标识符长度（2021 年 11 月）[#](#id35 "链接到这张图片")
- en: Observing 0-RTT data in QUIC[#](#observing-0-rtt-data-in-quic "Link to this
    heading")
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察 QUIC 中的 0-RTT 数据[#](#observing-0-rtt-data-in-quic "链接到这个标题")
- en: The ability to send data immediately was one of the requirements for the design
    of QUIC. It is interesting to observe how QUIC uses the `0-RTT` packets for this
    purpose. We use a [trace collected between QUIC tracker and picoquic as our example](https://quic-tracker.info.ucl.ac.be/traces/20211122/619).
    This trace covers two QUIC connections shown in [Fig. 104](#fig-qtrack-picoquic-0rtt).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 能够立即发送数据是 QUIC 设计的要求之一。观察 QUIC 如何使用 `0-RTT` 数据包来完成这个目的是很有趣的。我们使用 [QUIC 跟踪器和
    picoquic 之间的跟踪记录](https://quic-tracker.info.ucl.ac.be/traces/20211122/619) 作为我们的例子。这个跟踪记录涵盖了
    [图 104](#fig-qtrack-picoquic-0rtt) 中显示的两个 QUIC 连接。
- en: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
- en: Fig. 104 Sample QUIC trace with `test.privateoctopus.com` with 0-RTT packets[#](#fig-qtrack-picoquic-0rtt
    "Link to this image")
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 图 104 使用 `test.privateoctopus.com` 的样本 QUIC 跟踪记录，包含 0-RTT 数据包[#](#fig-qtrack-picoquic-0rtt
    "链接到这张图片")
- en: During the first QUIC connection, QUIC tracker receives one TLS session ticket
    in the `CRYPTO` frame contained in the 1-RTT packet that the server sent with
    packet number set to 0\. This ticket contains all the information required by
    the server to retrieve the key in a subsequent connection. QUIC tracker starts
    the second connection by sending an `Initial` packet. This packet contains a `CRYPTO`
    frame that contains the `TLS Client Hello` message. A comparison between this
    `TLS Client Hello` and the one sent to create the first connection shows that
    the latter contains the `psk_key_exchange_modes` TLS extension. This extension
    contains the information that enables the server to recover the key required to
    decrypt the `0-RTT` packet. In this example, the client sends a `0-RTT` that contains
    the beginning of a simple `HTTP GET`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次 QUIC 连接期间，QUIC 跟踪器在服务器发送的包含在 1-RTT 数据包中的 `CRYPTO` 帧中接收到一个 TLS 会话票据。这个数据包的序号设置为
    0。这个票据包含了服务器在后续连接中检索密钥所需的所有信息。QUIC 跟踪器通过发送一个 `Initial` 数据包来启动第二个连接。这个数据包包含一个 `CRYPTO`
    帧，其中包含 `TLS Client Hello` 消息。将这个 `TLS Client Hello` 与用于创建第一个连接的 `TLS Client Hello`
    进行比较，可以看出后者包含 `psk_key_exchange_modes` TLS 扩展。这个扩展包含了使服务器能够恢复用于解密 `0-RTT` 数据包所需的密钥的信息。在这个例子中，客户端发送了一个包含简单
    `HTTP GET` 请求开始的 `0-RTT` 数据包。
- en: QUIC streams[#](#quic-streams "Link to this heading")
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUIC 流[#](#quic-streams "链接到这个标题")
- en: As QUIC support multiple streams, it is interesting to analyze how the streams
    are managed over a real QUIC connection. For this example, we use a [trace between
    QUIC tracker and quic.tech](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)
    summarized in [Fig. 105](#fig-qtrack-quictech). In the example, the QUIC tracker
    creates four streams and sends one `HTTP GET` request over each of them.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 QUIC 支持多个流，分析在真实的 QUIC 连接中如何管理流是有趣的。对于这个例子，我们使用 [QUIC 跟踪器和 quic.tech 之间的跟踪记录](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)，并在
    [图 105](#fig-qtrack-quictech) 中总结。在这个例子中，QUIC 跟踪器创建了四个流，并通过每个流发送一个 `HTTP GET`
    请求。
- en: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
- en: Fig. 105 Sample QUIC trace with quic.tech using multiple streams[#](#fig-qtrack-quictech
    "Link to this image")
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 图105 使用quic.tech的多个流的示例QUIC跟踪[#](#fig-qtrack-quictech "链接到此图像")
- en: In this trace, the client creates four streams in its first `STREAM` frame sent
    in the first `1-RTT` packet. [Listing 18](#fig-quic-trace-stream-frame) shows
    the first of these `STREAM` frames. The `Type` of the `STREAM` is one octet structured
    as `0b00001OLF` where `O` is set to `1` if the `STREAM` frame contains an `Offset`
    field. Bit `L` is set to `1` if the frame contains a `Length` field. Finally,
    the `F` is set to `1` to mark the end of the `STREAM`. In this test, QUIC Tracker
    sends 17 bytes over each stream and closes it.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个跟踪中，客户端在其第一个`STREAM`帧中创建了四个流，这个`STREAM`帧是在第一个`1-RTT`数据包中发送的。[列表18](#fig-quic-trace-stream-frame)显示了这些`STREAM`帧中的第一个。`STREAM`的`Type`是一个字节，结构为`0b00001OLF`，其中`O`如果`STREAM`帧包含`Offset`字段则设置为`1`。位`L`如果帧包含`Length`字段则设置为`1`。最后，将`F`设置为`1`以标记`STREAM`的结束。在这个测试中，QUIC
    Tracker通过每个流发送17字节并关闭它。
- en: Listing 18 The first QUIC STREAM frame sent by QUIC Tracker[#](#fig-quic-trace-stream-frame
    "Link to this code")
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18 QUIC Tracker发送的第一个QUIC `STREAM`帧[#](#fig-quic-trace-stream-frame "链接到此代码")
- en: '[PRE42]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The server sends each response in a `STREAM` frame. [Listing 19](#fig-quic-trace-stream-frame-2)
    shows the frame returned by the server. Its `Offset` bit is set to `1`. It carries
    the entire HTML page and its `Offset` field could have been ignored since this
    is the first frame of the stream.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在每个`STREAM`帧中发送每个响应。[列表19](#fig-quic-trace-stream-frame-2)显示了服务器返回的帧。其`Offset`位设置为`1`。它携带整个HTML页面，其`Offset`字段可以忽略，因为这是流的第一个帧。
- en: Listing 19 The QUIC STREAM frame returned by the server[#](#fig-quic-trace-stream-frame-2
    "Link to this code")
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19 服务器返回的QUIC `STREAM`帧[#](#fig-quic-trace-stream-frame-2 "链接到此代码")
- en: '[PRE43]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Footnotes
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: Flow control in QUIC[#](#flow-control-in-quic "Link to this heading")
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC中的流量控制[#](#flow-control-in-quic "链接到本标题")
- en: Transport protocols usually allocate some resources to each established connection.
    Each QUIC connection requires memory to store its state, but also buffers to store
    the packets arrived out-of-order. In practice, the memory available for QUIC implementations
    is not unlimited and a QUIC receiver must control the amount of packets that the
    remote host can send at any time. QUIC supports flow control techniques that operate
    at different levels.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议通常为每个已建立的连接分配一些资源。每个QUIC连接都需要内存来存储其状态，同时也需要缓冲区来存储到达顺序错误的包。在实践中，可用于QUIC实现的内存并非无限，QUIC接收器必须控制远程主机在任何时刻可以发送的包的数量。QUIC支持在不同级别上操作的流量控制技术。
- en: The first level is the connection level. During the handshake, each host can
    announce the maximum number of bytes that it agrees to receive initially on the
    connection using the `initial_max_data` transport parameter. This parameter contains
    the number of bytes that the sending host agrees to receive without further notice.
    If the connection uses more bytes than initially agreed, the receiver can update
    this limit by sending a `MAX_DATA` frame at any time. This frame contains a variable
    length integer that encodes the maximum amount of stream data that can be sent
    over the connection.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 第一级是连接级别。在握手过程中，每个主机可以使用`initial_max_data`传输参数宣布它同意在连接上最初接收的最大字节数。此参数包含发送主机同意接收的字节数，无需进一步通知。如果连接使用的字节数超过了最初同意的数量，接收器可以通过在任何时候发送一个`MAX_DATA`帧来更新此限制。此帧包含一个可变长度的整数，它编码了可以通过连接发送的最大流数据量。
- en: The utilization of different streams also consumes resources on a QUIC host.
    A receiver can also restrict the number of streams that the remote host can create.
    During the handshake, the `initial_max_streams_bidi` and `initial_max_streams_uni`
    transport parameters announce the maximum number of bidirectional and unidirectional
    streams that the receiving host can accept. This limit can be modified during
    the connection by sending a `MAX_STREAMS` frame that updates the limit.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 不同流的利用率也会消耗QUIC主机上的资源。接收器还可以限制远程主机可以创建的流的数量。在握手过程中，`initial_max_streams_bidi`和`initial_max_streams_uni`传输参数宣布接收主机可以接受的最多双向和单向流的数量。这个限制可以在连接过程中通过发送一个更新限制的`MAX_STREAMS`帧来修改。
- en: Flow control can also take place at the stream level. During the handshake,
    several transport parameters allow the hosts to advertise the maximum number of
    bytes that they agree to receive on each stream. Different transport parameters
    are used to specify the limits that apply to the local/remote and unidirectional/bidirectional
    streams. These limits can be updated during the connection by sending `MAX_STREAM_DATA`
    frames. Each of these frames indicates the maximum amount of stream data that
    can be accepted on a given stream.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 流量控制也可以在流级别上进行。在握手过程中，几个传输参数允许主机宣布它们同意在每个流上接收的最大字节数。不同的传输参数用于指定适用于本地/远程和单向/双向流的限制。这些限制可以通过发送
    `MAX_STREAM_DATA` 帧在连接期间进行更新。每个这样的帧都指示在给定的流上可以接受的最大流数据量。
- en: These limits restrict the number of streams that a host can create and the amount
    of bytes that it can send. If a host is blocked by any of these limits, it may
    sent a control frame to request the remote host to extend the limit. For each
    type of flow control, there is an associated control frame which can be used to
    request an extension of the limit.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制限制了主机可以创建的流数量以及它可以发送的字节数。如果一个主机被这些限制中的任何一个阻塞，它可能发送一个控制帧来请求远程主机扩展限制。对于每种类型的流量控制，都有一个相关的控制帧，可以用来请求扩展限制。
- en: A host should send a `DATA_BLOCKED` frame when it reaches the limit on the maximum
    amount of data set by the `initial_max_data` transport parameter or a previously
    received `MAX_DATA` frame. The `DATA_BLOCKED` frame contains the connection limit
    that caused the transmission to be blocked. In practice, a receiving host should
    increase the connection-level limit by sending `MAX_DATA` frames before reaching
    the limit. However, since this limit is function of the available memory, a host
    might not always be able to send a `MAX_DATA` frame. [Fig. 93](#fig-quic-example-max-data)
    provides an example packet flow with the utilization of these frames. We assume
    that the `initial_max_data` transport parameter was set to `100` bytes by the
    client during the handshake and the the server needs to send 900 bytes. The server
    creates a stream and sends 100 bytes in a `1-RTT` packet carrying a `STREAM` frame.
    At this point, the server is blocked.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机达到由 `initial_max_data` 传输参数或之前接收到的 `MAX_DATA` 帧设定的最大数据量限制时，应该发送一个 `DATA_BLOCKED`
    帧。`DATA_BLOCKED` 帧包含导致传输被阻塞的连接限制。在实践中，接收主机应在达到限制之前通过发送 `MAX_DATA` 帧来增加连接级别的限制。然而，由于这个限制是可用内存的函数，主机可能并不总是能够发送一个
    `MAX_DATA` 帧。[图 93](#fig-quic-example-max-data) 提供了一个使用这些帧的示例数据包流。我们假设客户端在握手期间将
    `initial_max_data` 传输参数设置为 `100` 字节，而服务器需要发送 900 字节。服务器创建了一个流，并在携带 `STREAM` 帧的
    `1-RTT` 数据包中发送了 100 字节。此时，服务器被阻塞。
- en: '![Figure made with TikZ](../Images/5b5d3482cca71cc31e8478d8c94c256b.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/5b5d3482cca71cc31e8478d8c94c256b.png)'
- en: Fig. 93 QUIC uses `DATA_BLOCKED` frames when a connection’s flow control is
    blocked
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 图 93 当连接的流量控制被阻塞时，QUIC 使用 `DATA_BLOCKED` 帧进行响应
- en: The same applies with the `STREAM_DATA_BLOCKED` frame that is sent when a host
    reaching the per-stream limit. The `STREAMS_BLOCKED` frame is used when a host
    has reached the maximum number of established streams.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机达到每个流的限制时发送的 `STREAM_DATA_BLOCKED` 帧也是如此。当主机达到已建立流的数量最大值时，使用 `STREAMS_BLOCKED`
    帧。
- en: Note
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Connections blocked by flow control are not totally idle
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 被流量控制阻塞的连接并非完全空闲
- en: If a QUIC host detects that a connection is blocked by flow control, it should
    regularly send `DATA_BLOCKED` or `STREAM_DATA_BLOCKED` frames to request the remote
    host to extend the current limit. The QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    does not recommend precisely how often these frames should be sent when a connection
    is blocked by flow control. Experience with QUIC deployments will enable the QUIC
    developers to more precisely define how often these frames should be sent.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 QUIC 主机检测到连接被流量控制阻塞，它应该定期发送 `DATA_BLOCKED` 或 `STREAM_DATA_BLOCKED` 帧来请求远程主机扩展当前限制。QUIC
    规范 [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html) 并未明确推荐在连接被流量控制阻塞时这些帧应该发送的频率。QUIC
    部署的经验将使 QUIC 开发者能够更精确地定义这些帧应该发送的频率。
- en: 'A measurement study [[MHLQ2020]](../bibliography.html#mhlq2020) revealed that
    QUIC implementations used different strategies for flow control. They identified
    three main types of behaviors :'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一项测量研究 [[MHLQ2020]](../bibliography.html#mhlq2020) 揭示了 QUIC 实现使用了不同的流量控制策略。他们确定了三种主要的行为类型：
- en: 'Static Flow Control: the receive buffer size stays unchanged and the receiver
    simply increases the maximum allowance linearly'
  id: totrans-653
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态流量控制：接收缓冲区的大小保持不变，接收方简单地线性增加最大允许量
- en: ''
  id: totrans-654
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-655
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Growing Flow Control: the size of the receive buffer increases over time as
    the connection progresses'
  id: totrans-656
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长流量控制：随着连接的进行，接收缓冲区的大小会逐渐增加
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-658
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Auto-tuning: the size of the receive buffer is adjusted dynamically based on
    the estimated bandwidth and round-trip times'
  id: totrans-659
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调整：根据估计的带宽和往返时间动态调整接收缓冲区的大小
- en: In 2020, three quarter of the studied implementations used a Static Flow Control
    and only one used auto-tuning. Static Flow Control can work, but this is a waste
    of memory. For example, Google’s Chrome starts with a 15 MBytes receive buffer
    and updates it linearly [[MHLQ2020]](../bibliography.html#mhlq2020). This should
    be contrasted with TCP implementations that usually start with a window of a few
    tens of KBytes and adjust it with auto-tuning. Auto-tuning is a key feature of
    modern TCP implementations [[SMM1998]](../bibliography.html#smm1998). It is expected
    that QUIC implementations will include more advanced heuristics to tune their
    flow control mechanism.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2020 年，四分之三的研究实现使用了静态流量控制，只有一个使用了自动调整。静态流量控制可以工作，但这是一种内存浪费。例如，Google 的 Chrome
    以 15 MBytes 的接收缓冲区开始，并线性更新它 [[MHLQ2020]](../bibliography.html#mhlq2020)。这应该与通常以几个十
    KB 的窗口开始并使用自动调整的 TCP 实现进行对比。自动调整是现代 TCP 实现的关键特性 [[SMM1998]](../bibliography.html#smm1998)。预计
    QUIC 实现将包括更高级的启发式方法来调整它们的流量控制机制。
- en: QUIC Loss Detection[#](#quic-loss-detection "Link to this heading")
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUIC 丢包检测[#](#quic-loss-detection "链接到本标题")
- en: As other transport protocols, QUIC includes mechanisms to detect transmission
    errors and packet losses. The transmission errors are usually detected by using
    the UDP checksum or at the datalink layer with the Wi-Fi or Ethernet CRCs. When
    a transmission error occurs, the corresponding packet is discarded and QUIC considers
    this error as a packet loss. Researchers have analyzed the performance of checksums
    and CRCs on real data [[SGP98]](../bibliography.html#sgp98).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他传输协议一样，QUIC 包含检测传输错误和数据包丢失的机制。传输错误通常通过使用 UDP 校验和或在数据链路层使用 Wi-Fi 或以太网的 CRC
    来检测。当发生传输错误时，相应的数据包将被丢弃，QUIC 将此错误视为数据包丢失。研究人员已经分析了校验和和 CRC 在实际数据上的性能 [[SGP98]](../bibliography.html#sgp98)。
- en: Second, since QUIC used AEAD encryption schemes, all QUIC packets are authenticated
    and a receiver can leverage this AEAD to detect transmission errors that were
    undetected by the UDP checksum of the CRC of the lower layers. However, these
    undetected transmission errors are assumed to be rare and if QUIC a detects an
    invalid AEAD, it will consider that this error was caused by an attack and will
    stop the connection using a TLS alert [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于 QUIC 使用 AEAD 加密方案，所有 QUIC 数据包都经过认证，接收方可以利用这种 AEAD 来检测由 UDP 校验和或底层 CRC
    的校验和未检测到的传输错误。然而，这些未检测到的传输错误被认为是罕见的，如果 QUIC 检测到无效的 AEAD，它将认为这种错误是由攻击引起的，并将使用 TLS
    警报停止连接 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。
- en: There are several important differences between the loss detection and retransmission
    mechanisms used by QUIC and other transport protocols. First, QUIC packet numbers
    always increase monotonically over a QUIC connection. A QUIC sender never sends
    twice a packet with the same packet number over a given connection. QUIC encodes
    the packet numbers as variable length integers and it does not support wrap around
    in contrast with other transport protocols. The QUIC frames contain the valuable
    information that needs to be delivered reliably. If a QUIC packet is lost, the
    frames that it contained will be retransmitted in another QUIC packet that uses
    a different packet number. Thus, the QUIC packet number serves as a unique identifier
    of a packet. This simplifies some operations such as measuring the round-trip-time
    which is more difficult in protocols such as TCP when packets are transmitted
    [[KP91]](../bibliography.html#kp91).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 与其他传输协议在丢包检测和重传机制之间存在几个重要差异。首先，QUIC 数据包编号在 QUIC 连接中总是单调递增。QUIC 发送者永远不会在给定连接中发送两次具有相同数据包编号的数据包。QUIC
    将数据包编号编码为变长整数，并且与其它传输协议不同，它不支持回绕。QUIC 帧包含需要可靠传输的宝贵信息。如果一个 QUIC 数据包丢失，它所包含的帧将在使用不同数据包编号的另一个
    QUIC 数据包中重新传输。因此，QUIC 数据包编号充当数据包的唯一标识符。这简化了一些操作，例如测量往返时间，这在 TCP 等协议中更困难，因为数据包传输
    [[KP91]](../bibliography.html#kp91)。
- en: Second, QUIC’s acknowledgments carry more information than the cumulative or
    selective acknowledgments used by TCP and related protocols. This enables the
    receiver to provide a more detailed view of the packets that it received. In contrast
    with TCP [**RFC 2018**](https://datatracker.ietf.org/doc/html/rfc2018.html), once
    a receiver has reported that one packet was correctly received in an acknowledgment,
    the sender of that packet can discard the corresponding frames.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，QUIC 的确认信息比 TCP 和相关协议使用的累积或选择性确认信息包含更多信息。这使得接收者能够提供它接收到的数据包的更详细视图。与 TCP [**RFC
    2018**](https://datatracker.ietf.org/doc/html/rfc2018.html) 相比，一旦接收者报告了一个数据包在确认中正确接收，该数据包的发送者就可以丢弃相应的帧。
- en: Third, a QUIC sender autonomously decides which frames it sends inside each
    packet. A QUIC packet may contain both data and control frames, or only data or
    only control information. If a QUIC packet is lost, the frames that it contained
    could be retransmitted in different packets. A QUIC implementation thus needs
    to buffer the frames and mark the in-flight ones to be able to retransmit them
    if the corresponding packet was lost.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，QUIC 发送者自主决定在每个数据包中发送哪些帧。一个 QUIC 数据包可以包含数据和控制帧，或者只包含数据或只包含控制信息。如果 QUIC 数据包丢失，它包含的帧可以在不同的数据包中重新传输。因此，QUIC
    实现需要缓冲帧并标记正在传输的帧，以便在相应的数据包丢失时能够重新传输它们。
- en: Fourth, most QUIC packets are explicitly acknowledged. The only exception are
    the packets that only contain `ACK`, `PADDING` or `CONNECTION_CLOSE` frames. A
    packet that contains any other QUIC frame is called an ack-eliciting packet because
    its delivery will be confirmed by the transmission of an acknowledgment. A QUIC
    packet that carries both an `ACK` and a `STREAM` frame will thus be acknowledged.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，大多数 QUIC 数据包都明确地被确认。唯一的例外是只包含 `ACK`、`PADDING` 或 `CONNECTION_CLOSE` 帧的数据包。包含任何其他
    QUIC 帧的数据包被称为引发确认的数据包，因为它的交付将通过发送确认来得到确认。因此，携带 `ACK` 和 `STREAM` 帧的 QUIC 数据包将被确认。
- en: With this in mind, it is interesting to look at the format of the QUIC acknowledgments
    and then analyze how they can be used. [Listing 9](#fig-quic-ack-frame) provides
    the format of an ACK frame. It can be sent at any time in a QUIC packet. Two types
    are used to distinguish between the acknowledgments that contain information about
    the received ECN flags (type `0x03`) or only regular acknowledgments (type `0x02`).
    The first information contained in the ACK frame is the largest packet number
    that is acknowledged by this ACK frame. This is usually the highest packet number
    received. The second information is the ACK delay. This is the delay in microseconds
    between the reception of the packet having the largest acknowledged number by
    the receiver and the transmission of the acknowledgment. This information is important
    to ensure that round-trip-times are accurately measured, even if a receiver delays
    acknowledgments. This is illustrated in [Fig. 94](#fig-quic-ack-delay). The `ACK
    Range Count` field contains the number of `ACK ranges` that are included in the
    QUIC ACK frame. This number can be set to zero if all packets were received in
    sequence without any gap. In this case, the `First ACK Range` field contains the
    number of the packet that arrived before the `Largest Acknowledged` packet number.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，研究 QUIC 确认的格式并分析它们如何被使用是非常有趣的。[列表 9](#fig-quic-ack-frame) 提供了 ACK 帧的格式。它可以在
    QUIC 数据包中的任何时间发送。使用两种类型来区分包含接收到的 ECN 标志信息（类型 `0x03`）或仅包含常规确认（类型 `0x02`）的确认。ACK
    帧中包含的第一个信息是此 ACK 帧确认的最大数据包号。这通常是接收到的最高数据包号。第二个信息是 ACK 延迟。这是接收者接收具有最大确认号的数据包和发送确认之间的微秒延迟。这个信息对于确保往返时间被准确测量非常重要，即使接收者延迟确认也是如此。这如图
    94 所示。[图 94](#fig-quic-ack-delay) 中的 `ACK Range Count` 字段包含 QUIC ACK 帧中包含的 `ACK
    范围` 数量。如果所有数据包都按顺序接收且没有间隙，则可以将此数字设置为零。在这种情况下，`First ACK Range` 字段包含在 `Largest
    Acknowledged` 数据包号之前到达的数据包号。
- en: Listing 9 The QUIC ACK Frame[#](#fig-quic-ack-frame "Link to this code")
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9 QUIC ACK 帧结构[#](#fig-quic-ack-frame "链接到这段代码")
- en: '[PRE44]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Figure made with TikZ](../Images/91a1bf7fc5600dfd204d9c3691a03f74.png)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/91a1bf7fc5600dfd204d9c3691a03f74.png)'
- en: Fig. 94 Utilization of the QUIC ACK delay
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 图 94 QUIC ACK 延迟的利用
- en: An `ACK` frame contains 0 or more `ACK Ranges`. The format of an `ACK range`
    is shown in [Listing 10](#fig-quic-ack-range). Each range indicates first the
    number of unacknowledged packets since the smallest acknowledged packet in the
    preceding range (or the first ACK range). The next field indicates the number
    of consecutive acknowledged packets.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ACK`帧包含0个或多个`ACK Ranges`。`ACK range`的格式在[列表10](#fig-quic-ack-range)中显示。每个范围首先指示自前一个范围中最小已确认数据包以来的未确认数据包数量（或第一个ACK范围）。下一个字段指示连续已确认数据包的数量。
- en: Listing 10 A QUIC ACK range[#](#fig-quic-ack-range "Link to this code")
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10 一个QUIC ACK范围[#](#fig-quic-ack-range "链接到这段代码")
- en: '[PRE45]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As an example, consider a host that received the following QUIC packets: `3,4,6,7,8,9,11,14,16,18`.
    To report all the received packets, it will generate the `ACK` frame shown in
    [Listing 11](#fig-quic-sample-ack-frame).'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个接收以下QUIC数据包的主机为例：`3,4,6,7,8,9,11,14,16,18`。为了报告所有接收到的数据包，它将生成如[列表11](#fig-quic-sample-ack-frame)所示的`ACK`帧。
- en: Listing 11 Sample QUIC ACK Frame[#](#fig-quic-sample-ack-frame "Link to this
    code")
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11 示例QUIC ACK帧[#](#fig-quic-sample-ack-frame "链接到这段代码")
- en: '[PRE46]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The QUIC specification recommends to send one `ACK` frame after having received
    two ack-eliciting packets. This corresponds roughly to TCP’s delayed acknowledgments
    strategy. However, there is ongoing work to allow the sender to provide more guidelines
    on when and how `ACK` frames should be sent.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC规范建议在收到两个诱发性数据包后发送一个`ACK`帧。这大致对应于TCP的延迟确认策略。然而，目前正在进行的工作是为了允许发送者提供更多关于何时以及如何发送`ACK`帧的指导。
- en: Note
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When should QUIC hosts send acknowledgments
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC主机应该在何时发送确认
- en: A measurement study [[MHLQ2020]](../bibliography.html#mhlq2020) analyzed how
    QUIC implementations generate acknowledgments. Two of the studied implementations
    sent acknowledgments every N packets (2 for one implementation and 10 for the
    other). Other implementations used ack frequencies that varied during the data
    transfer.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 一项测量研究[[MHLQ2020]](../bibliography.html#mhlq2020)分析了QUIC实现如何生成确认。被研究的两种实现中，一种每N个数据包发送一次确认（一个实现为2，另一个为10）。其他实现使用了在数据传输过程中变化的确认频率。
- en: ([`Source code`](../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py),
    [`png`](../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png), [`hires.png`](../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png),
    [`pdf`](../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf))
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ([`源代码`](../_downloads/f724e8e78dd4d39b5c97d10307f4026a/quic-1.py), [`png`](../_downloads/a15f3481b3e14916ab1bdd9e10659352/quic-1.png),
    [`hires.png`](../_downloads/27bedd3a5f1157b1f85fe100bc1519d6/quic-1.hires.png),
    [`pdf`](../_downloads/066ed33b8fcbaea1200b7e5e005a97f7/quic-1.pdf))
- en: '![../_images/quic-1.png](../Images/3a962b543fdebe8ff46dbfacfe31e189.png)'
  id: totrans-684
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-1.png](../Images/3a962b543fdebe8ff46dbfacfe31e189.png)'
- en: Fig. 95 Acknowledgment frequencies for different QUIC servers[#](#id28 "Link
    to this image")
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 图95 不同QUIC服务器的确认频率[#](#id28 "链接到这张图片")
- en: The acknowledgment frequencies should be compared with TCP that usually acknowledges
    every second packet. It is likely that QUIC implementations will tune the generation
    of their acknowledgments in the coming years based on feedback from deployment.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 确认频率应与通常每秒确认一个数据包的TCP进行比较。预计在未来几年中，QUIC的实现将根据部署反馈调整其确认的生成。
- en: It is interesting to observe that since the `ACK` frames are sent inside QUIC
    packets, they can also be acknowledged. Sending an `ACK` in response to another
    `ACK` could result in an infinite exchange of `ACK` frames. To prevent this problem,
    a QUIC sender cannot send an `ACK` frame in response to a non-eliciting QUIC packet
    and the `ACK` frames are one of the non-eliciting frame types. Note that if a
    receiver that receives many `STREAM` frames and thus sends many `ACK` frames wants
    to obtain information about the reception of its `ACK` frame, it can simply send
    one `ACK` frame inside a packet that contains an eliciting frame, e.g. a `PING`
    frame. This frame will trigger the receiver to acknowledge it and the previously
    sent `ACK` frames.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到，由于`ACK`帧是在QUIC数据包内发送的，它们也可以被确认。对另一个`ACK`帧发送`ACK`可能会导致无限交换`ACK`帧。为了防止这个问题，QUIC发送者不能对非诱发性QUIC数据包发送`ACK`帧，而`ACK`帧就是非诱发性帧类型之一。注意，如果一个接收者接收了许多`STREAM`帧并因此发送了许多`ACK`帧，想要了解其`ACK`帧的接收情况，它可以在包含诱发性帧（例如`PING`帧）的数据包中简单地发送一个`ACK`帧。这个帧将触发接收者对其进行确认，并确认之前发送的`ACK`帧。
- en: In contrast with other reliable transport protocols, QUIC does not use cumulative
    acknowledgments. As explained earlier, QUIC never retransmits a packet with the
    same packet number. When a packet is lost, this creates a gap that the receiver
    reports using an `ACK Range`. Such a gap will never be filled by retransmissions
    and obviously should not be reported by the receiver forever. In practice, a receiver
    will send the acknowledgment that corresponds to a given packet number several
    times and then will assume that the acknowledgment has been received. A receiver
    can also rely on other heuristics to determine that a given `ACK Range` should
    not be reported anymore. This is the case if the `ACK` frame was included in a
    packet that has been acknowledged by the other peer, but also when the gap was
    noticed several round-trip times ago.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他可靠传输协议不同，QUIC 不使用累积确认。如前所述，QUIC 从不重新传输具有相同数据包编号的数据包。当数据包丢失时，这会创建一个接收方使用 `ACK
    Range` 报告的间隙。这样的间隙永远不会通过重传来填补，并且显然不应该由接收方永久报告。在实践中，接收方会发送与给定数据包编号对应的确认多次，然后假定确认已被接收。接收方还可以依靠其他启发式方法来确定是否应该不再报告给定的
    `ACK Range`。这种情况发生在 `ACK` 帧包含在另一个对等方已确认的数据包中时，也发生在间隙被注意到几个往返时间之前。
- en: QUIC also allows a receiver to send information about the ECN flags in the received
    packets. Two flags of the IP header [**RFC 3168**](https://datatracker.ietf.org/doc/html/rfc3168.html)
    are reserved to indicate support for Explicit Congestion Notification. The QUIC
    ECN count field shown in [Listing 12](#fig-quic-ecn-count) contains three counters
    for the different values of the ECN flags. These counters are incremented upon
    the reception of each QUIC packet based on the values of the ECN flag of the received
    packet. Unfortunately, there are still many operational problems when using ECN
    in the global Internet [[MLBBA2018]](../bibliography.html#mlbba2018). Time will
    tell whether it is easier to deploy ECN with QUIC than with TCP.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 还允许接收方发送有关接收到的数据包中 ECN 标志的信息。IP 头部的两个标志 [**RFC 3168**](https://datatracker.ietf.org/doc/html/rfc3168.html)
    保留用于指示对显式拥塞通知的支持。图 [12](#fig-quic-ecn-count) 中显示的 QUIC ECN 计数字段包含三个计数器，用于表示 ECN
    标志的不同值。这些计数器在接收到每个 QUIC 数据包时根据接收到的数据包中 ECN 标志的值进行递增。不幸的是，在全球互联网中使用 ECN 仍然存在许多操作问题
    [[MLBBA2018]](../bibliography.html#mlbba2018)。时间将证明使用 QUIC 部署 ECN 是否比使用 TCP 更容易。
- en: Listing 12 A QUIC ECN Count[#](#fig-quic-ecn-count "Link to this code")
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12 一个 QUIC ECN 计数 [#](#fig-quic-ecn-count "链接到这段代码")
- en: '[PRE47]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: QUIC also acknowledges control frames
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 也确认控制帧
- en: Besides the STREAM frames that carry user data, QUIC uses several different
    frame types to exchange control information. These control frames, like the data
    frames, are ack-eliciting frames. This implies a host that receives such a frame
    needs to acknowledge it using an `ACK` frame.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 除了携带用户数据的 `STREAM` 数据包之外，QUIC 还使用几种不同的帧类型来交换控制信息。这些控制帧，就像数据帧一样，是引发确认的帧。这意味着接收此类帧的主机需要使用
    `ACK` 帧来确认它。
- en: '[Fig. 97](#fig-quic-ack-initials) illustrates the beginning of a QUIC connection
    with the exchange of the `Initial` packets and the corresponding acknowledgments.
    The client sends its `TLS Client Hello` inside a `CRYPTO` frame in an `Initial`
    packet. This is the first packet sent by the client and thus its packet number
    is 0\. The server replies with a `TLS Server Hello` inside a `CRYPTO` frame in
    an `Initial` packet. Since this is the first packet sent by the server, its packet
    number is also 0\. The packet also contains an `ACK` frame that acknowledges the
    reception of the packet containing the `TLS Client Hello`.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 97](#fig-quic-ack-initials) 展示了 QUIC 连接的开始，通过交换 `Initial` 数据包和相应的确认信息。客户端在
    `Initial` 数据包中的 `CRYPTO` 帧内发送其 `TLS Client Hello`。这是客户端发送的第一个数据包，因此其数据包编号为 0。服务器在
    `Initial` 数据包中的 `CRYPTO` 帧内回复 `TLS Server Hello`。由于这是服务器发送的第一个数据包，其数据包编号也是 0。数据包还包含一个
    `ACK` 帧来确认接收包含 `TLS Client Hello` 的数据包。'
- en: The `Handshake`, `0-RTT` and `1-RTT` packets are acknowledged similarly using
    `ACK` frames. `Handshake` packets are acknowledged in other `Handshake` packets
    while `0-RTT` and `1-RTT` packets are acknowledged inside `1-RTT` packets.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handshake`、`0-RTT` 和 `1-RTT` 数据包也使用 `ACK` 帧进行类似的确认。`Handshake` 数据包在其他 `Handshake`
    数据包中进行确认，而 `0-RTT` 和 `1-RTT` 数据包在 `1-RTT` 数据包中进行确认。'
- en: '![Figure made with TikZ](../Images/75ed846fe9a217630046fd48dc876f1b.png)'
  id: totrans-697
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/75ed846fe9a217630046fd48dc876f1b.png)'
- en: Fig. 97 QUIC also acknowledges Initial frames
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 图 97 QUIC 也确认 Initial 帧的存在
- en: Note
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Not all QUIC servers use 0 as the packet number of their first Initial packet
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有QUIC服务器都将0用作它们第一个初始数据包的数据包编号
- en: The example shows a QUIC connection where the client sent its Initial packet
    with packet number 0 and the server also replied with a packet number set to 0\.
    This is what most QUIC implementations do. However, the QUIC specification does
    not strictly requires this. In fact, `facebook` servers in October 2022 appear
    to use random packet numbers for the Initial packet that they sent in response
    to a client. This is probably use to detect or mitigate some forms of attacks
    since the client must receive the server’s Initial packet to be able to produce
    a valid acknowledgment.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示了一个QUIC连接，其中客户端发送了编号为0的初始数据包，服务器也以编号设置为0的数据包进行回复。这是大多数QUIC实现的做法。然而，QUIC规范并没有严格要求这样做。实际上，2022年10月，`facebook`服务器似乎在响应客户端时，为它们发送的初始数据包使用了随机的数据包编号。这可能是为了检测或减轻某些形式的攻击，因为客户端必须接收到服务器的初始数据包才能生成有效的确认。
- en: To illustrate how QUIC uses acknowledgments, let us consider a simple QUIC connection.
    The client starts a QUIC connection with a new server, sends a request, receives
    a response and then closes the connection. There are no losses in this connection.
    [Fig. 98](#fig-quic-ack-short) illustrates this connection.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明QUIC如何使用确认，让我们考虑一个简单的QUIC连接。客户端与一个新服务器建立QUIC连接，发送一个请求，接收一个响应，然后关闭连接。在这个连接中没有数据丢失。[图98](#fig-quic-ack-short)展示了这个连接。
- en: '![Figure made with TikZ](../Images/00d236df000f95dc0877d8231f52d999.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/00d236df000f95dc0877d8231f52d999.png)'
- en: Fig. 98 Acknowledgments in a short QUIC connection
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 图98 短QUIC连接中的确认
- en: The connection starts when the client sends an `Initial` packet containing a
    `CRYPTO` frame with the `TLS Client Hello`. The server replies with an `Initial`
    packet that contains an acknowledgment and a `CRYPTO` frame with the `TLS Server
    Hello`. The server then sends an `Initial` packet containing the `TLS Encrypted
    Extensions`. Since this is the first `Initial` packet, its packet number is set
    to 0\. In practice, it is likely that the server will need to send several packets
    to carry the certificates contained in this packet. Note that the server cannot
    send more than 3 packets in response to the client’s `Initial` packet. This limit
    was introduced in the QUIC specification to restrict the ability of attackers
    to trigger DDoS attacks by sending spoofed packets to QUIC servers [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html).
    If the `CRYPTO` frame containing the certificates is too long, the server might
    need to wait for acknowledgments from the client before sending its last `Handshake`
    packets. The client confirms the reception of the server’s `Initial` packet by
    sending its last `Initial` packet that contains an `ACK` frame. This is the second
    `Initial` packet sent by the client and its packet number is thus 1\. Since this
    packet only contains an `ACK` frame, the server does not return an acknowledgment
    to confirm its reception.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 连接开始于客户端发送一个包含带有`TLS Client Hello`的`CRYPTO`帧的`Initial`数据包。服务器回复一个包含确认和一个带有`TLS
    Server Hello`的`CRYPTO`帧的`Initial`数据包。然后服务器发送一个包含`TLS Encrypted Extensions`的`Initial`数据包。由于这是第一个`Initial`数据包，其数据包编号被设置为0。实际上，服务器可能需要发送多个数据包来携带这个数据包中包含的证书。请注意，服务器不能向客户端的`Initial`数据包发送超过3个数据包。这个限制是在QUIC规范中引入的，以限制攻击者通过向QUIC服务器发送伪造数据包来触发DDoS攻击的能力[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)。如果包含证书的`CRYPTO`帧太长，服务器可能需要等待客户端的确认，然后才能发送最后的`Handshake`数据包。客户端通过发送包含`ACK`帧的最后`Initial`数据包来确认已接收服务器的`Initial`数据包。这是客户端发送的第二个`Initial`数据包，因此其数据包编号为1。由于这个数据包只包含`ACK`帧，服务器不需要返回确认来确认其接收。
- en: The client replies to the `Handshake` packet with another `Handshake` packet
    that contains a `CRYPTO` frame and acknowledges the `Handshake` packets sent by
    the server. The client’s `Handshake` packet is acknowledged by the server. The
    server starts the data exchange by sending a `1-RTT` packet carrying one or more
    stream frames to create the required streams. Since this is the first `1-RTT`
    packet sent by the server, its packet number is set to 0\. The client then sends
    its request in a `STREAM` frame. The server replies with a `1-RTT` packet that
    contains a `STREAM` frame with its response. The client ends the connection by
    sending a `CONNECTION_CLOSE` frame. In the example, the server replies with a
    `CONNECTION_CLOSE` frame, but the QUIC specification [**RFC 9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)
    only indicates that a host may respond with a `CONNECTION_CLOSE` in this case.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端用包含`CRYPTO`帧的另一个`Handshake`数据包回复`Handshake`数据包，并确认服务器发送的`Handshake`数据包。服务器的`Handshake`数据包被客户端确认。服务器通过发送一个携带一个或多个流帧的`1-RTT`数据包来开始数据交换，以创建所需的流。由于这是服务器发送的第一个`1-RTT`数据包，其包号被设置为0。然后客户端在一个`STREAM`帧中发送其请求。服务器用一个包含`STREAM`帧的`1-RTT`数据包回复，其中包含其响应。客户端通过发送一个`CONNECTION_CLOSE`帧来结束连接。在示例中，服务器用一个`CONNECTION_CLOSE`帧回复，但QUIC规范[**RFC
    9000**](https://datatracker.ietf.org/doc/html/rfc9000.html)仅指出，在此情况下，主机可以响应一个`CONNECTION_CLOSE`。
- en: Observing QUIC connections[#](#observing-quic-connections "Link to this heading")
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察QUIC连接[#](#observing-quic-connections "链接到此标题")
- en: We have now reviewed the main components of the QUIC specification. To illustrate
    it, let us consider a simple scenario where a client opens a QUIC connection with
    a server. We leverage Maxime Piraux’s QUIC tracker [[PDB2018]](../bibliography.html#pdb2018).
    In this example, we use the packet trace collected using the `nghttp2.org` server
    on November 22, 2021 at 18:04:52 CET. This trace is available from [https://quic-tracker.info.ucl.ac.be/traces/20211122/148](https://quic-tracker.info.ucl.ac.be/traces/20211122/148).
    You can see the contents of the packets, download it as a `.pcap` trace or visualize
    it using QLog/QViz [[MPQL2020]](../bibliography.html#mpql2020) from this web site.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经回顾了QUIC规范的主要组成部分。为了说明它，让我们考虑一个简单的场景，其中客户端与服务器建立QUIC连接。我们利用Maxime Piraux的QUIC跟踪器[[PDB2018]](../bibliography.html#pdb2018)。在这个例子中，我们使用2021年11月22日18:04:52
    CET使用`nghttp2.org`服务器收集的数据包跟踪。这个跟踪可以从[https://quic-tracker.info.ucl.ac.be/traces/20211122/148](https://quic-tracker.info.ucl.ac.be/traces/20211122/148)获取。您可以看到数据包的内容，将其下载为`.pcap`跟踪或使用QLog/QViz
    [[MPQL2020]](../bibliography.html#mpql2020)从该网站进行可视化。
- en: This trace contains 16 packets. The scenario is a simple handshake with an exchange
    of data.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 此跟踪包含16个数据包。场景是一个简单的握手和数据交换。
- en: '![../_images/qtracker-nghttp2-1.png](../Images/7e3eb62de8971ff53e65f8fbea028144.png)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-nghttp2-1.png](../Images/7e3eb62de8971ff53e65f8fbea028144.png)'
- en: Fig. 99 Sample QUIC tracker trace with `nghttp2.org` containing a successful
    handshake[#](#id32 "Link to this image")
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 图99 使用`nghttp2.org`的QUIC跟踪器示例，包含成功的手动握手[#](#id32 "链接到此图像")
- en: To initiate the connection, the client sends an `Initial` QUIC packet. It is
    interesting to analyze the content of this packet. It starts with a long QUIC
    header shown in [Listing 13](#fig-trace-quic-header-p1).
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化连接，客户端发送一个`Initial` QUIC数据包。分析这个数据包的内容很有趣。它以一个长的QUIC头部开始，如[列表13](#fig-trace-quic-header-p1)所示。
- en: Listing 13 The QUIC header of the first packet sent by the client[#](#fig-trace-quic-header-p1
    "Link to this code")
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13 客户端发送的第一个数据包的QUIC头部[#](#fig-trace-quic-header-p1 "链接到这段代码")
- en: '[PRE48]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The client proposes a 64 bits connection identifier and uses a random 64 bits
    identifier for the destination connection identifier. There is no token in this
    packet since this is the first connection from this client to the server. It is
    useful to note that the packet number of this `Initial` packet is set to zero.
    All QUIC connections start with a packet whose packet number is set to zero in
    contrast with TCP that uses a random sequence number. The packet contains a `CRYPTO`
    frame shown in [Listing 14](#fig-trace-quic-crypto-p1).
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端提出一个64位的连接标识符，并使用一个随机的64位标识符作为目标连接标识符。由于这是客户端到服务器的第一个连接，因此此数据包中没有令牌。值得注意的是，这个`Initial`数据包的包号被设置为0。所有QUIC连接都以包号为0的数据包开始，这与使用随机序列号的TCP不同。数据包包含一个`CRYPTO`帧，如[列表14](#fig-trace-quic-crypto-p1)所示。
- en: Listing 14 The CRYPTO frame of the first QUIC packet sent by the client[#](#fig-trace-quic-crypto-p1
    "Link to this code")
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14 客户端发送的第一个QUIC数据包的CRYPTO帧[#](#fig-trace-quic-crypto-p1 "链接到这段代码")
- en: '[PRE49]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `CRYPTO` frame starts at offset 0 and has a length of `245` bytes. It contains
    a TLS 1.3 `ClientHello` message whose format is specified in [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
    This `ClientHello` includes a 32 bytes secure random number, a set of proposed
    cipher suites and a series of TLS extensions. One of these extensions carries
    the QUIC transport parameters proposed by the client. On this connection, the
    QUIC tracker client proposed the following ones:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`CRYPTO` 帧从偏移量 0 开始，长度为 `245` 字节。它包含一个 TLS 1.3 `ClientHello` 消息，其格式在 [**RFC
    8446**](https://datatracker.ietf.org/doc/html/rfc8446.html) 中指定。此 `ClientHello`
    包含一个 32 字节的加密随机数，一组提议的加密套件和一系列 TLS 扩展。其中之一携带客户端提出的 QUIC 传输参数。在此连接上，QUIC 追踪器客户端提出了以下参数：'
- en: '`initial_max_stream_data_bidi_local` = 0x80004000'
  id: totrans-719
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_stream_data_bidi_local` = 0x80004000'
- en: ''
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-721
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_stream_data_uni` = 0x80004000'
  id: totrans-722
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_stream_data_uni` = 0x80004000'
- en: ''
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-724
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_data` = 0x80008000'
  id: totrans-725
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_data` = 0x80008000'
- en: ''
  id: totrans-726
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_streams_bidi` = 0x1'
  id: totrans-728
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_streams_bidi` = 0x1'
- en: ''
  id: totrans-729
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-730
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`initial_max_streams_uni` = 0x3'
  id: totrans-731
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_max_streams_uni` = 0x3'
- en: ''
  id: totrans-732
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-733
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_idle_timeout` = 0x6710'
  id: totrans-734
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_idle_timeout` = 0x6710'
- en: ''
  id: totrans-735
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-736
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`active_connection_id_limit` = 0x4'
  id: totrans-737
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_connection_id_limit` = 0x4'
- en: ''
  id: totrans-738
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-739
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_packet_size` = 0x45c0'
  id: totrans-740
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_packet_size` = 0x45c0'
- en: ''
  id: totrans-741
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-742
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`inital_source_connection_id` = 0xc9f54d3c298296b9'
  id: totrans-743
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inital_source_connection_id` = 0xc9f54d3c298296b9'
- en: Finally, the first QUIC packet contains a `PADDING` frame with 960 dummy bytes.
    The entire packet is 1236 bytes long.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第一个 QUIC 数据包包含一个包含 960 个虚拟字节的 `PADDING` 帧。整个数据包长度为 1236 字节。
- en: The server responds to this `Initial` packet with two packets. The first one
    is an `Initial` packet. It starts with the header shown in [Listing 15](#fig-trace-quic-header-p2).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器对此 `Initial` 数据包响应两个数据包。第一个是一个 `Initial` 数据包。它以 [列表 15](#fig-trace-quic-header-p2)
    中显示的头部开始。
- en: Listing 15 The QUIC header of the first packet sent by the client[#](#fig-trace-quic-header-p2
    "Link to this code")
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15 客户端发送的第一个数据包的 QUIC 头部[#](#fig-trace-quic-header-p2 "链接到这段代码")
- en: '[PRE50]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This server uses 18 bytes to encode its connection identifier and proposes
    the first identifier in the long header. The packet payload contains two frames:
    an `ACK` frame and a `CRYPTO` frame. The `ACK` frame ([Listing 16](#fig-trace-quic-ack-p2))
    acknowledges the reception of the `Initial` packet sent by the client. The `CRYPTO`
    frame contains the TLS ServerHello.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器使用 18 字节来编码其连接标识符，并在长头部中提出第一个标识符。数据包有效负载包含两个帧：一个 `ACK` 帧和一个 `CRYPTO` 帧。`ACK`
    帧([列表 16](#fig-trace-quic-ack-p2))确认了客户端发送的 `Initial` 数据包的接收。`CRYPTO` 帧包含 TLS
    服务器问候语。
- en: Listing 16 The ACK Frame of the first packet sent by the server[#](#fig-trace-quic-ack-p2
    "Link to this code")
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16 服务器发送的第一个数据包的 ACK 帧[#](#fig-trace-quic-ack-p2 "链接到这段代码")
- en: '[PRE51]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The payload of these `Initial` packets is encrypted using the static key derived
    from the connection identifiers included in the long header.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Initial` 数据包的有效负载使用从长头部中包含的连接标识符派生的静态密钥加密。
- en: 'The server then sends three `Handshake` packets carrying a `CRYPTO` frame that
    contains the `TLSEncryptedExtensions`. These extensions are encrypted using the
    TLS key. They mainly contain the server certificate. It is interesting to note
    that the `packet_number` field of the first `Handshake` packet sent by the server
    is also set to zero. This is the second, but not the last, packet that we observe
    with this `packet_number`. QUIC handles packet numbers differently then other
    protocols. QUIC considers that a QUIC connection is divided in three phases:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器发送三个携带 `CRYPTO` 帧的 `Handshake` 数据包，该帧包含 `TLSEncryptedExtensions`。这些扩展使用
    TLS 密钥加密。它们主要包含服务器证书。值得注意的是，服务器发送的第一个 `Handshake` 数据包的 `packet_number` 字段也设置为零。这是第二个，但不是最后一个，我们观察到具有此
    `packet_number` 的数据包。QUIC 对数据包编号的处理方式与其他协议不同。QUIC 认为QUIC 连接分为三个阶段：
- en: The exchange of the `Initial` packets
  id: totrans-753
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Initial` 数据包的交换'
- en: ''
  id: totrans-754
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-755
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The exchange of the `Handshake` packets
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Handshake` 数据包的交换'
- en: ''
  id: totrans-757
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-758
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The exchange of the other packets (`0-RTT`, `1-RTT`, … packets)
  id: totrans-759
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他数据包（`0-RTT`、`1-RTT`、… 数据包）的交换
- en: A QUIC host restarts the `packet_number` at zero in each phase. This explains
    why it is possible to observe different packets (of different types) with the
    same `packet_number` over a QUIC connection.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 QUIC 主机在每个阶段都将 `packet_number` 重置为零。这解释了为什么可以在 QUIC 连接上观察到具有相同 `packet_number`
    的不同数据包（不同类型的数据包）。
- en: The three `Handshake` packets sent by the server contain the beginning of the
    `TLSEncryptedExtensions` sent by the server. To prevent denial of service attacks,
    the server cannot send more than three full-length packets in response to a packet
    sent by the client. The server thus needs to wait for an acknowledgment from the
    client before sending additional packets.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的三个`Handshake`数据包包含了服务器发送的`TLSEncryptedExtensions`的开始部分。为了防止拒绝服务攻击，服务器不能在响应客户端发送的数据包时发送超过三个完整长度的数据包。因此，服务器在发送额外的数据包之前需要等待客户端的确认。
- en: The client sends two packets to carry these acknowledgments. First, it sends
    an `Initial` packet as the sixth packet of the trace. This packet belongs to the
    packet numbering space of the `Initial` packets. Its packet number is 1 since
    this is the second `Initial` packet sent by the client. The next acknowledgment
    is carried inside an `Handshake` packet. It acknowledges the `Handshake` packets
    0-2 sent by the server. Since this is the first `Handshake` packet sent by the
    client, its packet number is also 0.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送两个数据包来携带这些确认信息。首先，它发送一个`Initial`数据包作为跟踪的第六个数据包。这个数据包属于`Initial`数据包的编号空间。它的数据包编号是1，因为这是客户端发送的第二个`Initial`数据包。下一个确认信息包含在一个`Handshake`数据包中。它确认了服务器发送的0-2号`Handshake`数据包。由于这是客户端发送的第一个`Handshake`数据包，它的数据包编号也是0。
- en: The server then sends the eighth packet that contains the last part of the `TLSEncryptedExtensions`
    in a `CRYPTO` frame. By combining the information contained in the `Handshake`
    packets and the `Initial` packets, the client can derive the session keys.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器发送包含`TLSEncryptedExtensions`最后部分的第八个数据包，在一个`CRYPTO`帧中。通过结合`Handshake`数据包和`Initial`数据包中包含的信息，客户端可以推导出会话密钥。
- en: The server immediately sends its first `1-RTT` packet. This packet contains
    a short header shown in [Listing 17](#fig-trace-quic-short-header).
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器立即发送其第一个`1-RTT`数据包。这个数据包包含一个短头部，如[列表17](#fig-trace-quic-short-header)所示。
- en: Listing 17 The QUIC short header of the first 1-RTT packet sent by the server[#](#fig-trace-quic-short-header
    "Link to this code")
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17 服务器发送的第一个1-RTT数据包的QUIC短头部[#](#fig-trace-quic-short-header "链接到这段代码")
- en: '[PRE52]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This short header contains the connection identifier proposed by the client
    in the first `Initial` packet. The payload contains `STREAM` frames that create
    three streams. The client replies with two packets. The tenth packet of the trace
    is a `Handshake` packet that carries two frames. The `CRYPTO` frame contains the
    `TLS Finished` message that finalizes the TLS handshake. The `ACK` frame acknowledges
    the four `Handshake` packets sent by the server.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这个短头部包含了客户端在第一个`Initial`数据包中提出的连接标识符。有效载荷包含创建三个流的`STREAM`帧。客户端用两个数据包进行回复。跟踪的第十个数据包是一个携带两个帧的`Handshake`数据包。`CRYPTO`帧包含了最终化TLS握手的`TLS
    Finished`消息。`ACK`帧确认了服务器发送的四个`Handshake`数据包。
- en: The first `1-RTT` packet sent by the client contains an `ACK` frame that acknowledges
    the `1-RTT` packet sent by the server and flow control information. The client
    sends a `MAX_DATA` frame to restrict the amount of data that the server can send
    and one `MAX_STREAM` frame for each of the three streams created by the server.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的第一个`1-RTT`数据包包含一个`ACK`帧，确认了服务器发送的`1-RTT`数据包和流量控制信息。客户端发送一个`MAX_DATA`帧来限制服务器可以发送的数据量，并为服务器创建的每个流发送一个`MAX_STREAM`帧。
- en: The twelfth packet of the trace is more interesting. It contains five different
    frames that are sent by the server. First, the server send two `NEW_CONNECTION_ID`
    frames that advertise two 18 bytes long connection identifiers which can be used
    by the client to migrate the connection later. The next frame is the `HANDSHAKE_DONE`
    frame that confirms the TLS handshake. The server also sends a `NEW_TOKEN` frame
    that contains a 57 bytes long token that the client will be able to use in subsequent
    connections with the server. The last frame is a `CRYPTO` frame that contains
    two `TLS New Session Tickets`.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的第十二个数据包更有趣。它包含了服务器发送的五个不同的帧。首先，服务器发送两个`NEW_CONNECTION_ID`帧，宣传两个18字节长的连接标识符，客户端可以用这些标识符在以后迁移连接。下一个帧是`HANDSHAKE_DONE`帧，确认了TLS握手。服务器还发送一个包含57字节长令牌的`NEW_TOKEN`帧，客户端将在随后的服务器连接中使用这个令牌。最后一个帧是一个包含两个`TLS
    New Session Tickets`的`CRYPTO`帧。
- en: A closer look at other QUIC handshakes[#](#a-closer-look-at-other-quic-handshakes
    "Link to this heading")
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深入了解其他QUIC握手[#](#a-closer-look-at-other-quic-handshakes "链接到这个标题")
- en: It is interesting to analyze how different servers perform the handshake using
    QUIC tracker. Let us first explore the [trace collected with cloudflare-quic.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)
    on the same day shown in [Fig. 100](#fig-qtracker-cloudflare). There are several
    differences with the nghttp2 trace that we analyzed above. First, the server sends
    two small packets in response to the client’s `Initial`. The first packet only
    contains an `ACK` frame. It advertises a 20 bytes long connection identifier.
    The second packet contains a `CRYPTO` frame with a `TLS Hello Retry Request`.
    This message indicates that the server did not agree with the `key_share` parameter
    of the `TLS Client Hello` sent in the first packet. The client acknowledges this
    packet and sends a new `TLS Client Hello` in the fourth packet. The server replies
    with a `TLS Server Hello` and then the `TLSEncryptedExtensions` in three QUIC
    packets. The certificate used by `cloudflare-quic.com` is more compact than the
    one used by `nghttp2.org`.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 分析不同服务器如何使用 QUIC 跟踪器进行握手很有趣。让我们首先探索同一天显示在 [图 100](#fig-qtracker-cloudflare)
    中的 [使用 cloudflare-quic.com 收集的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)。与上面分析的
    nghttp2 跟踪相比，有几个不同之处。首先，服务器向客户端的 `Initial` 响应发送了两个小数据包。第一个数据包只包含一个 `ACK` 帧。它宣布了一个
    20 字节长的连接标识符。第二个数据包包含一个带有 `TLS Hello Retry Request` 的 `CRYPTO` 帧。这条消息表明服务器不同意第一个数据包中发送的
    `TLS Client Hello` 的 `key_share` 参数。客户端确认此数据包，并在第四个数据包中发送一个新的 `TLS Client Hello`。服务器以
    `TLS Server Hello` 响应，然后在三个 QUIC 数据包中发送 `TLSEncryptedExtensions`。`cloudflare-quic.com`
    使用的证书比 `nghttp2.org` 使用的更紧凑。
- en: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
- en: Fig. 100 Sample quic tracker trace from cloudflare-quic.com with a successful
    handshake[#](#id33 "Link to this image")
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 图 100 从 cloudflare-quic.com 获取的 QUIC 跟踪器跟踪示例，成功握手[#](#id33 "链接到这张图片")
- en: The `1-RTT` packets are also slightly different. The first `1-RTT` packet sent
    by the server contains the `HANDSHAKE_DONE` frame, a `CRYPTO` frame with two `TLS
    New Session Ticket` messages and a `STREAM` frame that creates one stream. The
    server then sends two short packet. Each of these packets contains a `STREAM`
    frame that creates a new stream. These two short packets could have been packed
    in the first `1-RTT` packet sent by the server. In contrast with `nghttp2.org`,
    `cloudflare-quic.com` does advertise new connection identifiers.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '`1-RTT` 数据包也有所不同。服务器发送的第一个 `1-RTT` 数据包包含 `HANDSHAKE_DONE` 帧，一个带有两个 `TLS New
    Session Ticket` 消息的 `CRYPTO` 帧，以及创建一个流的 `STREAM` 帧。然后服务器发送两个短数据包。每个数据包都包含一个创建新流的
    `STREAM` 帧。这两个短数据包本可以打包在服务器发送的第一个 `1-RTT` 数据包中。与 `nghttp2.org` 相比，`cloudflare-quic.com`
    并没有宣布新的连接标识符。'
- en: Our third example is [picoquic](https://github.com/private-octopus/picoquic).
    The [QUIC tracker trace with test.privateoctopus.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/159)
    contains 13 packets.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个例子是 [picoquic](https://github.com/private-octopus/picoquic)。包含测试 `test.privateoctopus.com`
    的 [QUIC 跟踪器跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/159) 包含 13
    个数据包。
- en: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
  id: totrans-776
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
- en: Fig. 101 Sample QUIC tracker trace from `test.privateoctopus.com` with a successful
    handshake[#](#id34 "Link to this image")
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 图 101 从 `test.privateoctopus.com` 获取的 QUIC 跟踪器跟踪示例，成功握手[#](#id34 "链接到这张图片")
- en: picoquic uses 64 bits long connection identifiers. It manages to fit its `TLS
    Encrypted Extensions` within two `Handshake` packets. The first `1-RTT` packet
    that it sends contains a `PING` frame. The second `1-RTT` packet contains one
    `CRYPTO` frame that advertises one `TLS New Session Ticket`, three `NEW_CONNECTION_ID`
    frames and a `NEW_TOKEN` frame. This test server does not try to create new streams
    in contrast with the two others.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: picoquic 使用 64 位长的连接标识符。它设法将其 `TLS Encrypted Extensions` 放在两个 `Handshake` 数据包中。它发送的第一个
    `1-RTT` 数据包包含一个 `PING` 帧。第二个 `1-RTT` 数据包包含一个 `CRYPTO` 帧，宣布了一个 `TLS New Session
    Ticket`，三个 `NEW_CONNECTION_ID` 帧和一个 `NEW_TOKEN` 帧。与此测试服务器不同，这两个其他服务器并没有尝试创建新的流。
- en: Note
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing QUIC servers
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 比较QUIC服务器
- en: It is interesting to use the traces collected by QUIC tracker to analyze how
    different servers have selected some of the optional features of QUIC. A first
    difference between the servers is the length of the server-selected connection
    identifiers. The graph below shows that in November 2021 many servers advertised
    8 bytes CIDs, but some have opted for much longer CIDs.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QUIC追踪器收集的跟踪来分析不同服务器如何选择QUIC的一些可选功能很有趣。服务器之间的第一个区别是服务器选择的连接标识符的长度。下面的图表显示，在2021年11月，许多服务器宣布了8字节的CID，但有些选择了更长的CID。
- en: ([`Source code`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py),
    [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png), [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: ([`源代码`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py), [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png),
    [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
- en: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
- en: Fig. 102 Length of the connection identifiers advertised by different QUIC servers
    (Nov 2021)[#](#id35 "Link to this image")
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 图102 不同QUIC服务器宣布的连接标识符的长度（2021年11月）[#](#id35 "链接到这张图片")
- en: Observing 0-RTT data in QUIC[#](#observing-0-rtt-data-in-quic "Link to this
    heading")
  id: totrans-785
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察QUIC中的0-RTT数据[#](#observing-0-rtt-data-in-quic "链接到这个标题")
- en: The ability to send data immediately was one of the requirements for the design
    of QUIC. It is interesting to observe how QUIC uses the `0-RTT` packets for this
    purpose. We use a [trace collected between QUIC tracker and picoquic as our example](https://quic-tracker.info.ucl.ac.be/traces/20211122/619).
    This trace covers two QUIC connections shown in [Fig. 104](#fig-qtrack-picoquic-0rtt).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 立即发送数据的能力是QUIC设计的要求之一。观察QUIC如何使用`0-RTT`数据包来实现这一目的很有趣。我们使用了一个[在QUIC追踪器和picoquic之间收集的跟踪作为我们的示例](https://quic-tracker.info.ucl.ac.be/traces/20211122/619)。这个跟踪覆盖了[图104](#fig-qtrack-picoquic-0rtt)中显示的两个QUIC连接。
- en: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
- en: Fig. 104 Sample QUIC trace with `test.privateoctopus.com` with 0-RTT packets[#](#fig-qtrack-picoquic-0rtt
    "Link to this image")
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 图104 使用`test.privateoctopus.com`和0-RTT数据包的样本QUIC跟踪[#](#fig-qtrack-picoquic-0rtt
    "链接到这张图片")
- en: During the first QUIC connection, QUIC tracker receives one TLS session ticket
    in the `CRYPTO` frame contained in the 1-RTT packet that the server sent with
    packet number set to 0\. This ticket contains all the information required by
    the server to retrieve the key in a subsequent connection. QUIC tracker starts
    the second connection by sending an `Initial` packet. This packet contains a `CRYPTO`
    frame that contains the `TLS Client Hello` message. A comparison between this
    `TLS Client Hello` and the one sent to create the first connection shows that
    the latter contains the `psk_key_exchange_modes` TLS extension. This extension
    contains the information that enables the server to recover the key required to
    decrypt the `0-RTT` packet. In this example, the client sends a `0-RTT` that contains
    the beginning of a simple `HTTP GET`.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次QUIC连接期间，QUIC追踪器在服务器发送的包含在1-RTT数据包中的`CRYPTO`帧中接收了一个TLS会话票据，该数据包的包号设置为0。这个票据包含服务器在后续连接中检索密钥所需的所有信息。QUIC追踪器通过发送一个`Initial`数据包开始第二个连接。这个数据包包含一个`CRYPTO`帧，其中包含`TLS
    Client Hello`消息。将这个`TLS Client Hello`与用于创建第一个连接的`TLS Client Hello`进行比较，可以看出后者包含`psk_key_exchange_modes`
    TLS扩展。这个扩展包含使服务器能够恢复用于解密`0-RTT`数据包所需的密钥的信息。在这个例子中，客户端发送了一个包含简单`HTTP GET`开始的`0-RTT`。
- en: QUIC streams[#](#quic-streams "Link to this heading")
  id: totrans-790
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUIC流[#](#quic-streams "链接到这个标题")
- en: As QUIC support multiple streams, it is interesting to analyze how the streams
    are managed over a real QUIC connection. For this example, we use a [trace between
    QUIC tracker and quic.tech](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)
    summarized in [Fig. 105](#fig-qtrack-quictech). In the example, the QUIC tracker
    creates four streams and sends one `HTTP GET` request over each of them.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 由于QUIC支持多个流，分析如何在真实的QUIC连接中管理这些流很有趣。对于这个例子，我们使用了一个[QUIC追踪器和quic.tech之间的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)，总结在[图105](#fig-qtrack-quictech)中。在这个例子中，QUIC追踪器创建了四个流，并通过每个流发送一个`HTTP
    GET`请求。
- en: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
- en: Fig. 105 Sample QUIC trace with quic.tech using multiple streams[#](#fig-qtrack-quictech
    "Link to this image")
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 图105 使用quic.tech和多个流进行的样本QUIC跟踪[#](#fig-qtrack-quictech "链接到此图像")
- en: In this trace, the client creates four streams in its first `STREAM` frame sent
    in the first `1-RTT` packet. [Listing 18](#fig-quic-trace-stream-frame) shows
    the first of these `STREAM` frames. The `Type` of the `STREAM` is one octet structured
    as `0b00001OLF` where `O` is set to `1` if the `STREAM` frame contains an `Offset`
    field. Bit `L` is set to `1` if the frame contains a `Length` field. Finally,
    the `F` is set to `1` to mark the end of the `STREAM`. In this test, QUIC Tracker
    sends 17 bytes over each stream and closes it.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个跟踪中，客户端在其第一个`1-RTT`数据包中发送的第一个`STREAM`帧中创建了四个流。[列表18](#fig-quic-trace-stream-frame)显示了这些`STREAM`帧中的第一个。`STREAM`的`Type`是一个字节，结构为`0b00001OLF`，其中`O`设置为`1`，如果`STREAM`帧包含`Offset`字段。位`L`设置为`1`，如果帧包含`Length`字段。最后，将`F`设置为`1`以标记`STREAM`的结束。在这个测试中，QUIC
    Tracker在每个流上发送17字节并关闭它。
- en: Listing 18 The first QUIC STREAM frame sent by QUIC Tracker[#](#fig-quic-trace-stream-frame
    "Link to this code")
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18 QUIC Tracker发送的第一个QUIC STREAM帧[#](#fig-quic-trace-stream-frame "链接到此代码")
- en: '[PRE53]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The server sends each response in a `STREAM` frame. [Listing 19](#fig-quic-trace-stream-frame-2)
    shows the frame returned by the server. Its `Offset` bit is set to `1`. It carries
    the entire HTML page and its `Offset` field could have been ignored since this
    is the first frame of the stream.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在每个响应中都发送一个`STREAM`帧。[列表19](#fig-quic-trace-stream-frame-2)显示了服务器返回的帧。其`Offset`位设置为`1`。它携带整个HTML页面，其`Offset`字段可以忽略，因为这是流的第一个帧。
- en: Listing 19 The QUIC STREAM frame returned by the server[#](#fig-quic-trace-stream-frame-2
    "Link to this code")
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19 服务器返回的QUIC STREAM帧[#](#fig-quic-trace-stream-frame-2 "链接到此代码")
- en: '[PRE54]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Footnotes
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: A closer look at other QUIC handshakes[#](#a-closer-look-at-other-quic-handshakes
    "Link to this heading")
  id: totrans-801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仔细观察其他QUIC握手过程[#](#a-closer-look-at-other-quic-handshakes "链接到本标题")
- en: It is interesting to analyze how different servers perform the handshake using
    QUIC tracker. Let us first explore the [trace collected with cloudflare-quic.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)
    on the same day shown in [Fig. 100](#fig-qtracker-cloudflare). There are several
    differences with the nghttp2 trace that we analyzed above. First, the server sends
    two small packets in response to the client’s `Initial`. The first packet only
    contains an `ACK` frame. It advertises a 20 bytes long connection identifier.
    The second packet contains a `CRYPTO` frame with a `TLS Hello Retry Request`.
    This message indicates that the server did not agree with the `key_share` parameter
    of the `TLS Client Hello` sent in the first packet. The client acknowledges this
    packet and sends a new `TLS Client Hello` in the fourth packet. The server replies
    with a `TLS Server Hello` and then the `TLSEncryptedExtensions` in three QUIC
    packets. The certificate used by `cloudflare-quic.com` is more compact than the
    one used by `nghttp2.org`.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 分析不同服务器如何使用QUIC跟踪器执行握手过程很有趣。让我们首先探索[使用cloudflare-quic.com收集的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/140)，如图[图100](#fig-qtracker-cloudflare)所示，这是同一天的数据。与上面分析的nghttp2跟踪相比，有几个不同之处。首先，服务器向客户端的`Initial`响应发送两个小数据包。第一个数据包只包含一个`ACK`帧。它宣布了一个20字节长的连接标识符。第二个数据包包含一个带有`TLS
    Hello Retry Request`的`CRYPTO`帧。此消息表示服务器不同意第一个数据包中发送的`TLS Client Hello`的`key_share`参数。客户端确认此数据包，并在第四个数据包中发送一个新的`TLS
    Client Hello`。服务器以`TLS Server Hello`响应，然后在三个QUIC数据包中发送`TLSEncryptedExtensions`。`cloudflare-quic.com`使用的证书比`nghttp2.org`使用的更紧凑。
- en: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-cloudflare-1.png](../Images/a4fa4ae4fe251c2d4e5c87d9bfdd4cf5.png)'
- en: Fig. 100 Sample quic tracker trace from cloudflare-quic.com with a successful
    handshake[#](#id33 "Link to this image")
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 图100 cloudflare-quic.com的样本quic tracker跟踪，成功握手[#](#id33 "链接到此图像")
- en: The `1-RTT` packets are also slightly different. The first `1-RTT` packet sent
    by the server contains the `HANDSHAKE_DONE` frame, a `CRYPTO` frame with two `TLS
    New Session Ticket` messages and a `STREAM` frame that creates one stream. The
    server then sends two short packet. Each of these packets contains a `STREAM`
    frame that creates a new stream. These two short packets could have been packed
    in the first `1-RTT` packet sent by the server. In contrast with `nghttp2.org`,
    `cloudflare-quic.com` does advertise new connection identifiers.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`1-RTT`数据包也有所不同。服务器发送的第一个`1-RTT`数据包包含`HANDSHAKE_DONE`帧，一个带有两个`TLS New Session
    Ticket`消息的`CRYPTO`帧和一个创建一个流的`STREAM`帧。然后服务器发送两个短的包。每个这些包都包含一个创建新流的`STREAM`帧。这两个短的包原本可以打包在服务器发送的第一个`1-RTT`数据包中。与`nghttp2.org`和`cloudflare-quic.com`不同，它们并没有宣布新的连接标识符。'
- en: Our third example is [picoquic](https://github.com/private-octopus/picoquic).
    The [QUIC tracker trace with test.privateoctopus.com](https://quic-tracker.info.ucl.ac.be/traces/20211122/159)
    contains 13 packets.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个例子是[picoquic](https://github.com/private-octopus/picoquic)。包含`test.privateoctopus.com`的[QUIC追踪器跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/159)包含13个数据包。
- en: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
  id: totrans-807
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-1.png](../Images/2caed6d4f9f898a962846ed3d2e47a9b.png)'
- en: Fig. 101 Sample QUIC tracker trace from `test.privateoctopus.com` with a successful
    handshake[#](#id34 "Link to this image")
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 图101 来自`test.privateoctopus.com`的样本QUIC追踪器跟踪，成功握手[#](#id34 "链接到这张图片")
- en: picoquic uses 64 bits long connection identifiers. It manages to fit its `TLS
    Encrypted Extensions` within two `Handshake` packets. The first `1-RTT` packet
    that it sends contains a `PING` frame. The second `1-RTT` packet contains one
    `CRYPTO` frame that advertises one `TLS New Session Ticket`, three `NEW_CONNECTION_ID`
    frames and a `NEW_TOKEN` frame. This test server does not try to create new streams
    in contrast with the two others.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: picoquic使用64位长的连接标识符。它设法将其`TLS Encrypted Extensions`放入两个`Handshake`包中。它发送的第一个`1-RTT`包包含一个`PING`帧。第二个`1-RTT`包包含一个`CRYPTO`帧，宣布了一个`TLS
    New Session Ticket`，三个`NEW_CONNECTION_ID`帧和一个`NEW_TOKEN`帧。这个测试服务器与另外两个不同，它不尝试创建新的流。
- en: Note
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing QUIC servers
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 比较QUIC服务器
- en: It is interesting to use the traces collected by QUIC tracker to analyze how
    different servers have selected some of the optional features of QUIC. A first
    difference between the servers is the length of the server-selected connection
    identifiers. The graph below shows that in November 2021 many servers advertised
    8 bytes CIDs, but some have opted for much longer CIDs.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QUIC追踪器收集的跟踪来分析不同的服务器如何选择QUIC的一些可选功能很有趣。服务器之间的第一个区别是服务器选择的连接标识符的长度。下面的图表显示，在2021年11月，许多服务器宣布了8字节的CID，但有些选择了更长的CID。
- en: ([`Source code`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py),
    [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png), [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: ([`源代码`](../_downloads/9cb98f81542ce0bb932c6d7f336bf804/quic-2.py), [`png`](../_downloads/264a415d0d57130ed130b3fdc939eb0b/quic-2.png),
    [`hires.png`](../_downloads/f2f50846f3e8478e899f2135f464b16d/quic-2.hires.png),
    [`pdf`](../_downloads/97f3989f543f73fda5beb58c52797b66/quic-2.pdf))
- en: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quic-2.png](../Images/8fa0ce7b276beb5ece519f6198e8c9be.png)'
- en: Fig. 102 Length of the connection identifiers advertised by different QUIC servers
    (Nov 2021)[#](#id35 "Link to this image")
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 图102 不同QUIC服务器宣布的连接标识符长度（2021年11月）[#](#id35 "链接到这张图片")
- en: Observing 0-RTT data in QUIC[#](#observing-0-rtt-data-in-quic "Link to this
    heading")
  id: totrans-816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察QUIC中的0-RTT数据[#](#observing-0-rtt-data-in-quic "链接到这个标题")
- en: The ability to send data immediately was one of the requirements for the design
    of QUIC. It is interesting to observe how QUIC uses the `0-RTT` packets for this
    purpose. We use a [trace collected between QUIC tracker and picoquic as our example](https://quic-tracker.info.ucl.ac.be/traces/20211122/619).
    This trace covers two QUIC connections shown in [Fig. 104](#fig-qtrack-picoquic-0rtt).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 立即发送数据的能力是QUIC设计的要求之一。观察QUIC如何使用`0-RTT`数据包来实现这一目的很有趣。我们使用了一个[在QUIC追踪器和picoquic之间收集的跟踪作为我们的示例](https://quic-tracker.info.ucl.ac.be/traces/20211122/619)。这个跟踪覆盖了[图104](#fig-qtrack-picoquic-0rtt)中显示的两个QUIC连接。
- en: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-picoquic-0rtt.png](../Images/805be77f81fd67d0f4dbcd3429f9074d.png)'
- en: Fig. 104 Sample QUIC trace with `test.privateoctopus.com` with 0-RTT packets[#](#fig-qtrack-picoquic-0rtt
    "Link to this image")
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 图104 使用`test.privateoctopus.com`的0-RTT数据包的样本QUIC跟踪[#](#fig-qtrack-picoquic-0rtt
    "链接到这张图片")
- en: During the first QUIC connection, QUIC tracker receives one TLS session ticket
    in the `CRYPTO` frame contained in the 1-RTT packet that the server sent with
    packet number set to 0\. This ticket contains all the information required by
    the server to retrieve the key in a subsequent connection. QUIC tracker starts
    the second connection by sending an `Initial` packet. This packet contains a `CRYPTO`
    frame that contains the `TLS Client Hello` message. A comparison between this
    `TLS Client Hello` and the one sent to create the first connection shows that
    the latter contains the `psk_key_exchange_modes` TLS extension. This extension
    contains the information that enables the server to recover the key required to
    decrypt the `0-RTT` packet. In this example, the client sends a `0-RTT` that contains
    the beginning of a simple `HTTP GET`.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次 QUIC 连接期间，QUIC 跟踪器在服务器发送的包含在 1-RTT 数据包中的 `CRYPTO` 帧中接收到一个 TLS 会话票据，该数据包的包号设置为
    0。这个票据包含服务器在后续连接中检索密钥所需的所有信息。QUIC Tracker 通过发送一个 `Initial` 数据包开始第二个连接。这个数据包包含一个
    `CRYPTO` 帧，其中包含 `TLS Client Hello` 消息。将这个 `TLS Client Hello` 与用于创建第一个连接的 `TLS
    Client Hello` 进行比较，后者包含 `psk_key_exchange_modes` TLS 扩展。这个扩展包含使服务器能够恢复用于解密 `0-RTT`
    数据包所需的密钥的信息。在这个例子中，客户端发送了一个包含简单 `HTTP GET` 开始部分的 `0-RTT`。
- en: QUIC streams[#](#quic-streams "Link to this heading")
  id: totrans-821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUIC 流[#](#quic-streams "链接到这个标题")
- en: As QUIC support multiple streams, it is interesting to analyze how the streams
    are managed over a real QUIC connection. For this example, we use a [trace between
    QUIC tracker and quic.tech](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)
    summarized in [Fig. 105](#fig-qtrack-quictech). In the example, the QUIC tracker
    creates four streams and sends one `HTTP GET` request over each of them.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 QUIC 支持多流，分析在真实 QUIC 连接中如何管理这些流是非常有趣的。对于这个例子，我们使用了一个 [QUIC 跟踪器和 quic.tech
    之间的跟踪](https://quic-tracker.info.ucl.ac.be/traces/20211122/375)，总结在 [图 105](#fig-qtrack-quictech)。在示例中，QUIC
    跟踪器创建了四个流，并通过每个流发送一个 `HTTP GET` 请求。
- en: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/qtracker-quictech-1.png](../Images/0b2f8631f4b24e652268e6a998c32faa.png)'
- en: Fig. 105 Sample QUIC trace with quic.tech using multiple streams[#](#fig-qtrack-quictech
    "Link to this image")
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 图 105 使用 quic.tech 的多流 QUIC 跟踪示例[#](#fig-qtrack-quictech "链接到这张图片")
- en: In this trace, the client creates four streams in its first `STREAM` frame sent
    in the first `1-RTT` packet. [Listing 18](#fig-quic-trace-stream-frame) shows
    the first of these `STREAM` frames. The `Type` of the `STREAM` is one octet structured
    as `0b00001OLF` where `O` is set to `1` if the `STREAM` frame contains an `Offset`
    field. Bit `L` is set to `1` if the frame contains a `Length` field. Finally,
    the `F` is set to `1` to mark the end of the `STREAM`. In this test, QUIC Tracker
    sends 17 bytes over each stream and closes it.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个跟踪中，客户端在其第一个 `1-RTT` 数据包中发送的第一个 `STREAM` 帧中创建了四个流。[列表 18](#fig-quic-trace-stream-frame)
    展示了这些 `STREAM` 帧中的第一个。`STREAM` 的 `Type` 是一个字节，结构为 `0b00001OLF`，其中 `O` 如果 `STREAM`
    帧包含 `Offset` 字段则设置为 `1`。位 `L` 如果帧包含 `Length` 字段则设置为 `1`。最后，`F` 设置为 `1` 以标记 `STREAM`
    的结束。在这个测试中，QUIC Tracker 通过每个流发送 17 字节并关闭它。
- en: Listing 18 The first QUIC STREAM frame sent by QUIC Tracker[#](#fig-quic-trace-stream-frame
    "Link to this code")
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18 QUIC Tracker 发送的第一个 QUIC STREAM 帧[#](#fig-quic-trace-stream-frame "链接到这段代码")
- en: '[PRE55]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The server sends each response in a `STREAM` frame. [Listing 19](#fig-quic-trace-stream-frame-2)
    shows the frame returned by the server. Its `Offset` bit is set to `1`. It carries
    the entire HTML page and its `Offset` field could have been ignored since this
    is the first frame of the stream.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在每个响应中发送一个 `STREAM` 帧。[列表 19](#fig-quic-trace-stream-frame-2) 展示了服务器返回的帧。其
    `Offset` 位设置为 `1`。它携带整个 HTML 页面，并且由于这是流的第一个帧，其 `Offset` 字段可以被忽略。
- en: Listing 19 The QUIC STREAM frame returned by the server[#](#fig-quic-trace-stream-frame-2
    "Link to this code")
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19 服务器返回的 QUIC STREAM 帧[#](#fig-quic-trace-stream-frame-2 "链接到这段代码")
- en: '[PRE56]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Footnotes
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
