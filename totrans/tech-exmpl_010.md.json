["```go\n{\n    \"a\": \"bff5a400\", #Pointer to \"a\" minHeap Node\n    \"b\": \"bff5a3f6\" #Pointer to \"a\" minHeap Node\n}\n```", "```go\n[\n    {\n        Key: \"b\",    \n        Value: \"2\",\n        Index: 0,\n        Count: 1    \n    },\n    {\n        Key: \"a\",    \n        Value: \"1\",\n        Index: 1,\n        Count: 2    \n    }\n\n]\n```", "```go\ntype Cache struct {\n\tminHeap      *minheap\n\tstorage      map[string]*minHeapNode\n\tevictionAlgo evictionAlgo\n\tcapacity     int\n\tmaxCapacity  int\n}\n\nfunc initCache(evictionAlgo evictionAlgo, maxCapacity int) Cache {}\n\nfunc (this *Cache) setEvictionAlgo(e evictionAlgo) {}\n\nfunc (this *Cache) set(key, value string) {}\n\nfunc (this *Cache) get(key string) string {}\n\nfunc (this *Cache) evict() string {}\n\nfunc (this *Cache) print() {}\n```", "```go\ntype minheap struct {\n\theapArray []*minHeapNode\n\tsize      int\n}\n\ntype minHeapNode struct {\n\tkey   string\n\tvalue string\n\tindex int\n\tcount int\n}\n\nfunc newMinHeap() *minheap {}\n\nfunc (this *minheap) insert(node *minHeapNode) error {}\n\nfunc (this *minheap) upHeapify(index int) {}\n\nfunc (this *minheap) downHeapify(current int) {}\n\nfunc (this *minheap) remove() *minHeapNode {}\n\nfunc (this *minheap) print() {}\n```", "```go\ntype evictionAlgo interface {\n\tevict(c *Cache) *minHeapNode\n\tget(node *minHeapNode, c *Cache)\n\tset(node *minHeapNode, c *Cache)\n\tset_overwrite(node *minHeapNode, value string, c *Cache)\n}\n```", "```go\ntype lfu struct {\n}\n\nfunc (l *lfu) evict(c *Cache) *minHeapNode {}\n\nfunc (l *lfu) get(node *minHeapNode, c *Cache) {}\n\nfunc (l *lfu) set(node *minHeapNode, c *Cache) {}\n\nfunc (l *lfu) set_overwrite(node *minHeapNode, value string, c *Cache) {}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype minheap struct {\n\theapArray []*minHeapNode\n\tsize      int\n}\n\ntype minHeapNode struct {\n\tkey   string\n\tvalue string\n\tindex int\n\tcount int\n}\n\nfunc newMinHeap() *minheap {\n\tminheap := &minheap{\n\t\theapArray: []*minHeapNode{},\n\t\tsize:      0,\n\t}\n\treturn minheap\n}\n\nfunc (this *minheap) leaf(index int) bool {\n\tif index >= (this.size/2) && index <= this.size {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (this *minheap) parent(index int) *minHeapNode {\n\tparentIndex := (index - 1) / 2\n\treturn this.heapArray[parentIndex]\n}\n\nfunc (this *minheap) leftchild(index int) *minHeapNode {\n\tleftChildIndex := 2*index + 1\n\tif leftChildIndex > this.size-1 {\n\t\treturn nil\n\t}\n\treturn this.heapArray[leftChildIndex]\n}\n\nfunc (this *minheap) rightchild(index int) *minHeapNode {\n\trightChildIndex := 2*index + 2\n\tif rightChildIndex > this.size-1 {\n\t\treturn nil\n\t}\n\treturn this.heapArray[rightChildIndex]\n}\n\nfunc (this *minheap) insert(node *minHeapNode) error {\n\tthis.heapArray = append(this.heapArray, node)\n\tthis.size++\n\tnode.index = this.size - 1\n\tthis.upHeapify(this.size - 1)\n\treturn nil\n}\n\nfunc (this *minheap) swap(first, second *minHeapNode) {\n\tthis.heapArray[first.index] = second\n\tthis.heapArray[second.index] = first\n\ttemp := first.index\n\tfirst.index = second.index\n\tsecond.index = temp\n}\n\nfunc (this *minheap) upHeapify(index int) {\n\tparentNode := this.parent(index)\n\tfor this.heapArray[index].count < parentNode.count {\n\t\tthis.swap(this.heapArray[index], this.parent(index))\n\t}\n}\n\nfunc (this *minheap) downHeapify(current int) {\n\tif this.leaf(current) {\n\t\treturn\n\t}\n\tcurrNode := this.heapArray[current]\n\tsmallest := currNode\n\tsmallestIndex := currNode.index\n\tleftChildNode := this.leftchild(current)\n\trightChildNode := this.rightchild(current)\n\t//If current is smallest then return\n\tif leftChildNode != nil && leftChildNode.count < smallest.count {\n\t\tsmallest = leftChildNode\n\t\tsmallestIndex = leftChildNode.index\n\t}\n\tif rightChildNode != nil && rightChildNode.count < smallest.count {\n\t\tsmallest = rightChildNode\n\t\tsmallestIndex = rightChildNode.index\n\t}\n\tif smallest != currNode {\n\t\tthis.swap(currNode, smallest)\n\t\tthis.downHeapify(smallestIndex)\n\t}\n\treturn\n}\nfunc (this *minheap) buildMinHeap() {\n\tfor index := ((this.size / 2) - 1); index >= 0; index-- {\n\t\tthis.downHeapify(index)\n\t}\n}\n\nfunc (this *minheap) getMinimum() *minHeapNode {\n\ttop := this.heapArray[0]\n\tthis.heapArray[0] = this.heapArray[this.size-1]\n\tthis.heapArray[0].index = 0\n\tthis.heapArray = this.heapArray[:(this.size)-1]\n\tthis.size--\n\tthis.downHeapify(0)\n\treturn top\n}\n\nfunc (this *minheap) print() {\n\tfmt.Println(\"Printing MinHeap:\")\n\tfor _, v := range this.heapArray {\n\t\tfmt.Printf(\"%+v\\n\", *v)\n\t}\n}\n```", "```go\npackage main\n\ntype evictionAlgo interface {\n\tevict(c *Cache) *minHeapNode\n\tget(node *minHeapNode, c *Cache)\n\tset(node *minHeapNode, c *Cache)\n\tset_overwrite(node *minHeapNode, value string, c *Cache)\n}\n\nfunc createEvictioAlgo(algoType string) evictionAlgo {\n\tif algoType == \"lfu\" {\n\t\treturn &lfu{}\n\t}\n\n\treturn nil\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype lfu struct {\n}\n\nfunc (l *lfu) evict(c *Cache) *minHeapNode {\n\tnode := c.minHeap.getMinimum()\n\tfmt.Printf(\"Evicting by lfu strtegy. Evicted Node Key: %s\", node.key)\n\treturn node\n}\n\nfunc (l *lfu) get(node *minHeapNode, c *Cache) {\n\tfmt.Printf(\"Shuffling node with key:%s in the minHeap due to get operation\\n\", node.key)\n\tnode.count++\n\tc.minHeap.downHeapify(node.index)\n}\n\nfunc (l *lfu) set(node *minHeapNode, c *Cache) {\n\tfmt.Printf(\"Adding a new node with key:%s to minHeap due to set operation\\n\", node.key)\n\tnode.count++\n\tc.minHeap.insert(node)\n}\n\nfunc (l *lfu) set_overwrite(node *minHeapNode, value string, c *Cache) {\n\tfmt.Printf(\"Shuffling node with key:%s in the minHeap due to set_overwrite operation\\n\", node.key)\n\tnode.value = value\n\tnode.count++\n\tc.minHeap.downHeapify(node.index)\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype Cache struct {\n\tminHeap      *minheap\n\tstorage      map[string]*minHeapNode\n\tevictionAlgo evictionAlgo\n\tcapacity     int\n\tmaxCapacity  int\n}\n\nfunc initCache(evictionAlgo evictionAlgo, maxCapacity int) Cache {\n\tstorage := make(map[string]*minHeapNode)\n\treturn Cache{\n\t\tminHeap:      newMinHeap(),\n\t\tstorage:      storage,\n\t\tevictionAlgo: evictionAlgo,\n\t\tcapacity:     0,\n\t\tmaxCapacity:  maxCapacity,\n\t}\n}\n\nfunc (this *Cache) setEvictionAlgo(e evictionAlgo) {\n\tthis.evictionAlgo = e\n}\n\nfunc (this *Cache) set(key, value string) {\n\tnode_ptr, ok := this.storage[key]\n\tif ok {\n\t\tthis.evictionAlgo.set_overwrite(node_ptr, value, this)\n\t\treturn\n\t}\n\tif this.capacity == this.maxCapacity {\n\t\tevictedKey := this.evict()\n\t\tdelete(this.storage, evictedKey)\n\t}\n\tnode := &minHeapNode{key: key, value: value}\n\tthis.storage[key] = node\n\tthis.evictionAlgo.set(node, this)\n\tthis.capacity++\n}\n\nfunc (this *Cache) get(key string) string {\n\tnode_ptr, ok := this.storage[key]\n\tif ok {\n\t\tthis.evictionAlgo.get(node_ptr, this)\n\t\treturn (*node_ptr).value\n\t}\n\treturn \"\"\n}\n\nfunc (this *Cache) evict() string {\n\tminHeapNode := this.evictionAlgo.evict(this)\n\tthis.capacity--\n\treturn minHeapNode.key\n}\n\nfunc (this *Cache) print() {\n\tfmt.Println(\"Printing Entire Cache:\")\n\tfmt.Println(\"Printing Map:\")\n\tfor k, v := range this.storage {\n\t\tfmt.Printf(\"key :%s value: %s\\n\", k, (*v).value)\n\t}\n\tthis.minHeap.print()\n\tfmt.Println()\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tlfu := createEvictioAlgo(\"lfu\")\n\tcache := initCache(lfu, 3)\n\tcache.set(\"a\", \"1\")\n\tcache.print()\n\n\tcache.set(\"b\", \"2\")\n\tcache.print()\n\n\tcache.set(\"c\", \"3\")\n\tcache.print()\n\n\tvalue := cache.get(\"a\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tvalue = cache.get(\"b\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tvalue = cache.get(\"c\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tcache.set(\"d\", \"4\")\n\tcache.print()\n\n\tcache.set(\"e\", \"5\")\n\tcache.print()\n}\n```", "```go\nAdding a new node with key:a to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nPrinting MinHeap:\n{key:a value:1 index:0 count:1}\n\nAdding a new node with key:b to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nPrinting MinHeap:\n{key:a value:1 index:0 count:1}\n{key:b value:2 index:1 count:1}\n\nAdding a new node with key:c to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nPrinting MinHeap:\n{key:a value:1 index:0 count:1}\n{key:b value:2 index:1 count:1}\n{key:c value:3 index:2 count:1}\n\nShuffling node with key:a in the minHeap due to get operation\nkey: a, value: 1\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nPrinting MinHeap:\n{key:b value:2 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:c value:3 index:2 count:1}\n\nShuffling node with key:b in the minHeap due to get operation\nkey: a, value: 2\nPrinting Entire Cache:\nPrinting Map:\nkey :b value: 2\nkey :c value: 3\nkey :a value: 1\nPrinting MinHeap:\n{key:c value:3 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n\nShuffling node with key:c in the minHeap due to get operation\nkey: a, value: 3\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nPrinting MinHeap:\n{key:c value:3 index:0 count:2}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n\nEvicting by lfu strtegy. Evicted Node Key: cAdding a new node with key:d to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :d value: 4\nPrinting MinHeap:\n{key:d value:4 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n\nEvicting by lfu strtegy. Evicted Node Key: dAdding a new node with key:e to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :e value: 5\nPrinting MinHeap:\n{key:e value:5 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n```", "```go\npackage main\n\nimport \"fmt\"\n\ntype minheap struct {\n\theapArray []*minHeapNode\n\tsize      int\n}\n\ntype minHeapNode struct {\n\tkey   string\n\tvalue string\n\tindex int\n\tcount int\n}\n\nfunc newMinHeap() *minheap {\n\tminheap := &minheap{\n\t\theapArray: []*minHeapNode{},\n\t\tsize:      0,\n\t}\n\treturn minheap\n}\n\nfunc (this *minheap) leaf(index int) bool {\n\tif index >= (this.size/2) && index <= this.size {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (this *minheap) parent(index int) *minHeapNode {\n\tparentIndex := (index - 1) / 2\n\treturn this.heapArray[parentIndex]\n}\n\nfunc (this *minheap) leftchild(index int) *minHeapNode {\n\tleftChildIndex := 2*index + 1\n\tif leftChildIndex > this.size-1 {\n\t\treturn nil\n\t}\n\treturn this.heapArray[leftChildIndex]\n}\n\nfunc (this *minheap) rightchild(index int) *minHeapNode {\n\trightChildIndex := 2*index + 2\n\tif rightChildIndex > this.size-1 {\n\t\treturn nil\n\t}\n\treturn this.heapArray[rightChildIndex]\n}\n\nfunc (this *minheap) insert(node *minHeapNode) error {\n\tthis.heapArray = append(this.heapArray, node)\n\tthis.size++\n\tnode.index = this.size - 1\n\tthis.upHeapify(this.size - 1)\n\treturn nil\n}\n\nfunc (this *minheap) swap(first, second *minHeapNode) {\n\tthis.heapArray[first.index] = second\n\tthis.heapArray[second.index] = first\n\ttemp := first.index\n\tfirst.index = second.index\n\tsecond.index = temp\n}\n\nfunc (this *minheap) upHeapify(index int) {\n\tparentNode := this.parent(index)\n\tfor this.heapArray[index].count < parentNode.count {\n\t\tthis.swap(this.heapArray[index], this.parent(index))\n\t}\n}\n\nfunc (this *minheap) downHeapify(current int) {\n\tif this.leaf(current) {\n\t\treturn\n\t}\n\tcurrNode := this.heapArray[current]\n\tsmallest := currNode\n\tsmallestIndex := currNode.index\n\tleftChildNode := this.leftchild(current)\n\trightChildNode := this.rightchild(current)\n\t//If current is smallest then return\n\tif leftChildNode != nil && leftChildNode.count < smallest.count {\n\t\tsmallest = leftChildNode\n\t\tsmallestIndex = leftChildNode.index\n\t}\n\tif rightChildNode != nil && rightChildNode.count < smallest.count {\n\t\tsmallest = rightChildNode\n\t\tsmallestIndex = rightChildNode.index\n\t}\n\tif smallest != currNode {\n\t\tthis.swap(currNode, smallest)\n\t\tthis.downHeapify(smallestIndex)\n\t}\n\treturn\n}\nfunc (this *minheap) buildMinHeap() {\n\tfor index := ((this.size / 2) - 1); index >= 0; index-- {\n\t\tthis.downHeapify(index)\n\t}\n}\n\nfunc (this *minheap) getMinimum() *minHeapNode {\n\ttop := this.heapArray[0]\n\tthis.heapArray[0] = this.heapArray[this.size-1]\n\tthis.heapArray[0].index = 0\n\tthis.heapArray = this.heapArray[:(this.size)-1]\n\tthis.size--\n\tthis.downHeapify(0)\n\treturn top\n}\n\nfunc (this *minheap) print() {\n\tfmt.Println(\"Printing MinHeap:\")\n\tfor _, v := range this.heapArray {\n\t\tfmt.Printf(\"%+v\\n\", *v)\n\t}\n}\n\ntype evictionAlgo interface {\n\tevict(c *Cache) *minHeapNode\n\tget(node *minHeapNode, c *Cache)\n\tset(node *minHeapNode, c *Cache)\n\tset_overwrite(node *minHeapNode, value string, c *Cache)\n}\n\nfunc createEvictioAlgo(algoType string) evictionAlgo {\n\tif algoType == \"lfu\" {\n\t\treturn &lfu{}\n\t}\n\n\treturn nil\n}\n\ntype lfu struct {\n}\n\nfunc (l *lfu) evict(c *Cache) *minHeapNode {\n\tnode := c.minHeap.getMinimum()\n\tfmt.Printf(\"Evicting by lfu strtegy. Evicted Node Key: %s\", node.key)\n\treturn node\n}\n\nfunc (l *lfu) get(node *minHeapNode, c *Cache) {\n\tfmt.Printf(\"Shuffling node with key:%s in the minHeap due to get operation\\n\", node.key)\n\tnode.count++\n\tc.minHeap.downHeapify(node.index)\n}\n\nfunc (l *lfu) set(node *minHeapNode, c *Cache) {\n\tfmt.Printf(\"Adding a new node with key:%s to minHeap due to set operation\\n\", node.key)\n\tnode.count++\n\tc.minHeap.insert(node)\n}\n\nfunc (l *lfu) set_overwrite(node *minHeapNode, value string, c *Cache) {\n\tfmt.Printf(\"Shuffling node with key:%s in the minHeap due to set_overwrite operation\\n\", node.key)\n\tnode.value = value\n\tnode.count++\n\tc.minHeap.downHeapify(node.index)\n}\n\ntype Cache struct {\n\tminHeap      *minheap\n\tstorage      map[string]*minHeapNode\n\tevictionAlgo evictionAlgo\n\tcapacity     int\n\tmaxCapacity  int\n}\n\nfunc initCache(evictionAlgo evictionAlgo, maxCapacity int) Cache {\n\tstorage := make(map[string]*minHeapNode)\n\treturn Cache{\n\t\tminHeap:      newMinHeap(),\n\t\tstorage:      storage,\n\t\tevictionAlgo: evictionAlgo,\n\t\tcapacity:     0,\n\t\tmaxCapacity:  maxCapacity,\n\t}\n}\n\nfunc (this *Cache) setEvictionAlgo(e evictionAlgo) {\n\tthis.evictionAlgo = e\n}\n\nfunc (this *Cache) set(key, value string) {\n\tnode_ptr, ok := this.storage[key]\n\tif ok {\n\t\tthis.evictionAlgo.set_overwrite(node_ptr, value, this)\n\t\treturn\n\t}\n\tif this.capacity == this.maxCapacity {\n\t\tevictedKey := this.evict()\n\t\tdelete(this.storage, evictedKey)\n\t}\n\tnode := &minHeapNode{key: key, value: value}\n\tthis.storage[key] = node\n\tthis.evictionAlgo.set(node, this)\n\tthis.capacity++\n}\n\nfunc (this *Cache) get(key string) string {\n\tnode_ptr, ok := this.storage[key]\n\tif ok {\n\t\tthis.evictionAlgo.get(node_ptr, this)\n\t\treturn (*node_ptr).value\n\t}\n\treturn \"\"\n}\n\nfunc (this *Cache) evict() string {\n\tminHeapNode := this.evictionAlgo.evict(this)\n\tthis.capacity--\n\treturn minHeapNode.key\n}\n\nfunc (this *Cache) print() {\n\tfmt.Println(\"Printing Entire Cache:\")\n\tfmt.Println(\"Printing Map:\")\n\tfor k, v := range this.storage {\n\t\tfmt.Printf(\"key :%s value: %s\\n\", k, (*v).value)\n\t}\n\tthis.minHeap.print()\n\tfmt.Println()\n}\n\nfunc main() {\n\tlfu := createEvictioAlgo(\"lfu\")\n\tcache := initCache(lfu, 3)\n\tcache.set(\"a\", \"1\")\n\tcache.print()\n\n\tcache.set(\"b\", \"2\")\n\tcache.print()\n\n\tcache.set(\"c\", \"3\")\n\tcache.print()\n\n\tvalue := cache.get(\"a\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tvalue = cache.get(\"b\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tvalue = cache.get(\"c\")\n\tfmt.Printf(\"key: a, value: %s\\n\", value)\n\tcache.print()\n\n\tcache.set(\"d\", \"4\")\n\tcache.print()\n\n\tcache.set(\"e\", \"5\")\n\tcache.print()\n}\n```", "```go\nAdding a new node with key:a to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nPrinting MinHeap:\n{key:a value:1 index:0 count:1}\n\nAdding a new node with key:b to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :b value: 2\nkey :a value: 1\nPrinting MinHeap:\n{key:a value:1 index:0 count:1}\n{key:b value:2 index:1 count:1}\n\nAdding a new node with key:c to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nPrinting MinHeap:\n{key:a value:1 index:0 count:1}\n{key:b value:2 index:1 count:1}\n{key:c value:3 index:2 count:1}\n\nShuffling node with key:a in the minHeap due to get operation\nkey: a, value: 1\nPrinting Entire Cache:\nPrinting Map:\nkey :c value: 3\nkey :a value: 1\nkey :b value: 2\nPrinting MinHeap:\n{key:b value:2 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:c value:3 index:2 count:1}\n\nShuffling node with key:b in the minHeap due to get operation\nkey: a, value: 2\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :c value: 3\nPrinting MinHeap:\n{key:c value:3 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n\nShuffling node with key:c in the minHeap due to get operation\nkey: a, value: 3\nPrinting Entire Cache:\nPrinting Map:\nkey :b value: 2\nkey :c value: 3\nkey :a value: 1\nPrinting MinHeap:\n{key:c value:3 index:0 count:2}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n\nEvicting by lfu strtegy. Evicted Node Key: cAdding a new node with key:d to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :d value: 4\nkey :a value: 1\nkey :b value: 2\nPrinting MinHeap:\n{key:d value:4 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n\nEvicting by lfu strtegy. Evicted Node Key: dAdding a new node with key:e to minHeap due to set operation\nPrinting Entire Cache:\nPrinting Map:\nkey :a value: 1\nkey :b value: 2\nkey :e value: 5\nPrinting MinHeap:\n{key:e value:5 index:0 count:1}\n{key:a value:1 index:1 count:2}\n{key:b value:2 index:2 count:2}\n```"]