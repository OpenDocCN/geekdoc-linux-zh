<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch236.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="transfers__conn__proxies__md-_-_-proxies" class="level1" data-number="235">
<h1 data-number="235">Proxies</h1>
<p>A proxy in a network context is a middle man, a server in between you as a client and the remote server you want to communicate with. The client contacts the middle man which then goes on to contact the remote server for you.</p>
<p>This style of proxy use is sometimes used by companies and organizations, in which case you are usually required to use them to reach the target server.</p>
<p>There are several different kinds of proxies and different protocols to use when communicating with a proxy, and libcurl supports a few of the most common proxy protocols. It is important to realize that the protocol used to the proxy is not necessarily the same protocol used to the remote server.</p>
<p>When setting up a transfer with libcurl you need to point out the server name and port number of the proxy. You may find that your favorite browsers can do this in slightly more advanced ways than libcurl can, and we get into such details in later sections.</p>
<section id="transfers__conn__proxies__md-_-_-proxy-types" class="level2" data-number="235.1">
<h2 data-number="235.1">Proxy types</h2>
<p>libcurl supports the two major proxy types: SOCKS and HTTP proxies. More specifically, it supports both SOCKS4 and SOCKS5 with or without remote name lookup, as well as both HTTP and HTTPS to the local proxy.</p>
<p>The easiest way to specify which kind of proxy you are talking to is to set the scheme part of the proxy hostname string (<code>CURLOPT_PROXY</code>) to match it:</p>
<pre><code>socks4://proxy.example.com:12345/
socks4a://proxy.example.com:12345/
socks5://proxy.example.com:12345/
socks5h://proxy.example.com:12345/
http://proxy.example.com:12345/
https://proxy.example.com:12345/</code></pre>
<p><code>socks4</code> - means SOCKS4 with local name resolving</p>
<p><code>socks4a</code> - means SOCKS4 with proxy’s name resolving</p>
<p><code>socks5</code> - means SOCKS5 with local name resolving</p>
<p><code>socks5h</code> - means SOCKS5 with proxy’s name resolving</p>
<p><code>http</code> - means HTTP, which always lets the proxy resolve names</p>
<p><code>https</code> - means HTTPS <strong>to the proxy</strong>, which always lets the proxy resolve names.</p>
<p>You can also opt to set the type of the proxy with a separate option if you prefer to only set the hostname, using <code>CURLOPT_PROXYTYPE</code>. Similarly, you can set the proxy port number to use with <code>CURLOPT_PROXYPORT</code>.</p>
</section>
<section id="transfers__conn__proxies__md-_-_-local-or-proxy-name-lookup" class="level2" data-number="235.2">
<h2 data-number="235.2">Local or proxy name lookup</h2>
<p>In a section above you can see that different proxy setups allow the name resolving to be done by different parties involved in the transfer. You can in several cases either have the client resolve the server hostname and pass on the IP address to the proxy to connect to - which of course assumes that the name lookup works accurately on the client system - or you can hand over the name to the proxy to have the proxy resolve the name; converting it to an IP address to connect to.</p>
<p>When you are using an HTTP or HTTPS proxy, you always give the name to the proxy to resolve.</p>
</section>
<section id="transfers__conn__proxies__md-_-_-which-proxy" class="level2" data-number="235.3">
<h2 data-number="235.3">Which proxy?</h2>
<p>If your network connection requires the use of a proxy to reach the destination, you must figure this out and tell libcurl to use the correct proxy. There is no support in libcurl to make it automatically figure out or detect a proxy.</p>
<p>When using a browser, it is popular to provide the proxy with a PAC script or other means but none of those are recognized by libcurl.</p>
<section id="transfers__conn__proxies__md-_-_-proxy-environment-variables" class="level3" data-number="235.3.1">
<h3 data-number="235.3.1">Proxy environment variables</h3>
<p>If no proxy option has been set, libcurl checks for the existence of specially named environment variables before it performs its transfer to see if a proxy is requested to get used.</p>
<p>You can specify the proxy by setting a variable named <code>[scheme]_proxy</code> to hold the proxy hostname (the same way you would specify the host with <code>-x</code>). If you want to tell curl to use a proxy when accessing an HTTP server, you set the <code>http_proxy</code> environment variable. Like this:</p>
<pre><code>http_proxy=http://proxy.example.com:80</code></pre>
<p>The proxy example above is for HTTP, but can of course also set <code>ftp_proxy</code>, <code>https_proxy</code>, and so on for the specific protocols you want to proxy. All these proxy environment variable names except http_proxy can also be specified in uppercase, like <code>HTTPS_PROXY</code>.</p>
<p>To set a single variable that controls <em>all</em> protocols, the <code>ALL_PROXY</code> exists. If a specific protocol variable one exists, such a one takes precedence.</p>
<p>When using environment variables to set a proxy, you could easily end up in a situation where one or a few hostnames should be excluded from going through the proxy. This can be done with the <code>NO_PROXY</code> variable - or the corresponding <code>CURLOPT_NOPROXY</code> libcurl option. Set that to a comma-separated list of hostnames that should not use a proxy when being accessed. You can set NO_PROXY to be a single asterisk (‘*’) to match all hosts.</p>
</section>
</section>
<section id="transfers__conn__proxies__md-_-_-http-proxy" class="level2" data-number="235.4">
<h2 data-number="235.4">HTTP proxy</h2>
<p>The HTTP protocol details exactly how an HTTP proxy should be used. Instead of sending the request to the actual remote server, the client (libcurl) instead asks the proxy for the specific resource. The connection to the HTTP proxy is made using plain unencrypted HTTP.</p>
<p>If an HTTPS resource is requested, libcurl instead issues a <code>CONNECT</code> request to the proxy. Such a request opens a tunnel through the proxy, where it passes data through without understanding it. This way, libcurl can establish a secure end-to-end TLS connection even when an HTTP proxy is present.</p>
<p>You <em>can</em> proxy non-HTTP protocols over an HTTP proxy, but since this is mostly done by the CONNECT method to tunnel data through it requires that the proxy is configured to allow the client to connect to those other particular remote port numbers. Many HTTP proxies are setup to inhibit connections to other port numbers than 80 and 443.</p>
</section>
<section id="transfers__conn__proxies__md-_-_-https-proxy" class="level2" data-number="235.5">
<h2 data-number="235.5">HTTPS proxy</h2>
<p>An HTTPS proxy is similar to an HTTP proxy but allows the client to connect to it using a secure HTTPS connection. Since the proxy connection is separate from the connection to the remote site even in this situation, as HTTPS to the remote site is tunneled through the HTTPS connection to the proxy, libcurl provides a whole set of TLS options for the proxy connection that are separate from the connection to the remote host.</p>
<p>For example, <code>CURLOPT_PROXY_CAINFO</code> is the same functionality for the HTTPS proxy as <code>CURLOPT_CAINFO</code> is for the remote host. <code>CURLOPT_PROXY_SSL_VERIFYPEER</code> is the proxy version of <code>CURLOPT_SSL_VERIFYPEER</code> and so on.</p>
<p>HTTPS proxies are still today fairly unusual in organizations and companies.</p>
</section>
<section id="transfers__conn__proxies__md-_-_-proxy-authentication" class="level2" data-number="235.6">
<h2 data-number="235.6">Proxy authentication</h2>
<p>Authentication with a proxy means that you need to provide valid credentials in the handshake negotiation with the proxy itself. The proxy authentication is then in addition to and separate of the possible authentication or lack of authentication with the remote host.</p>
<p>libcurl supports authentication with HTTP, HTTPS and SOCKS5 proxies. The key option is then <code>CURLOPT_PROXYUSERPWD</code> which sets the username and password to use - unless you set it within the <code>CURLOPT_PROXY</code> string.</p>
</section>
<section id="transfers__conn__proxies__md-_-_-http-proxy-headers" class="level2" data-number="235.7">
<h2 data-number="235.7">HTTP Proxy headers</h2>
<p>With an HTTP or HTTP proxy, libcurl issues a request to the proxy that includes a set of headers. An application can of course modify the headers, just like for requests sent to servers.</p>
<p>libcurl offers the <code>CURLOPT_PROXYHEADER</code> for controlling the headers that are sent to a proxy <strong>when there is a separate request sent to the server</strong>. This typically means the initial <code>CONNECT</code> request sent to a proxy for setting up a tunnel through the proxy.</p>
<p><span id="transfers__control__README__md"></span></p>
</section>
</section>
</body>
</html>
