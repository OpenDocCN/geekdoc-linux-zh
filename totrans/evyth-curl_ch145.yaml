- en: Responses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应
- en: When an HTTP client talks HTTP to a server, the server responds with an HTTP
    response message or curl considers it an error and returns 52 with the error message
    `Empty reply from server`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个HTTP客户端与服务器进行HTTP通信时，服务器会以HTTP响应消息响应，或者curl将其视为错误并返回52，错误信息为“从服务器收到空回复”。
- en: Size of an HTTP response
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP响应的大小
- en: An HTTP response has a certain size and curl needs to figure it out. There are
    several different ways to signal the end of an HTTP response but the most basic
    way is to use the `Content-Length:` header in the response and with that specify
    the exact number of bytes in the response body.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应有一个确定的大小，curl需要找出它。有几种不同的方式来表示HTTP响应的结束，但最基本的方式是使用响应中的`Content-Length:`头，并指定响应体的确切字节数。
- en: 'Some early HTTP server implementations had problems with file sizes greater
    than 2GB and wrongly managed to send Content-Length: headers with negative sizes
    or otherwise just plain wrong data. curl can be told to ignore the Content-Length:
    header completely with `--ignore-content-length`. Doing so may have some other
    negative side-effects but should at least let you get the data.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一些早期的HTTP服务器实现存在文件大小超过2GB的问题，并错误地发送了带有负大小的`Content-Length:`头或其他错误数据。curl可以被告知完全忽略`Content-Length:`头，使用`--ignore-content-length`。这样做可能会有一些其他负面影响，但至少应该让你得到数据。
- en: HTTP response codes
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP响应代码
- en: An HTTP transfer gets a 3 digit response code back in the first response line.
    The response code is the server’s way of giving the client a hint about how the
    request was handled.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP传输在第一行响应中会收到一个三位数的响应代码。响应代码是服务器向客户端提供有关请求处理方式的提示的方式。
- en: It is important to note that curl does not consider it an error even if the
    response code would indicate that the requested document could not be delivered
    (or similar). curl considers a successful sending and receiving of HTTP to be
    good.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，即使响应代码表明请求的文档无法提供（或类似情况），curl也不会将其视为错误。curl认为成功发送和接收HTTP是好的。
- en: 'The first digit of the HTTP response code is a kind of error class:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应代码的第一位数字是一种错误类别：
- en: '1xx: transient response, more is coming'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1xx：短暂响应，还有更多内容
- en: '2xx: success'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2xx：成功
- en: '3xx: a redirect'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3xx：重定向
- en: '4xx: the client asked for something the server could not or would not deliver'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4xx：客户端请求了服务器无法或不愿意提供的内容
- en: '5xx: there is a problem in the server'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5xx：服务器存在问题
- en: Remember that you can use curl’s `--write-out` option to extract the response
    code. See the [–write-out](ch081.xhtml#usingcurl__verbose__writeout__md) section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以使用curl的`--write-out`选项来提取响应代码。请参阅[–write-out](ch081.xhtml#usingcurl__verbose__writeout__md)部分。
- en: To make curl return an error for response codes >= 400, you need to use `--fail`
    or `--fail-with-body`. Then curl exits with error code 22 for such occurrences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使curl对于响应代码>=400返回错误，你需要使用`--fail`或`--fail-with-body`。然后curl会以错误代码22退出，表示此类情况。
- en: CONNECT response codes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CONNECT响应代码
- en: Since there can be an HTTP request and a separate CONNECT request in the same
    curl transfer, we often separate the CONNECT response (from the proxy) from the
    remote server’s HTTP response.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在同一个curl传输中可能存在HTTP请求和单独的CONNECT请求，我们通常将CONNECT响应（来自代理）与远程服务器的HTTP响应分开。
- en: The CONNECT is also an HTTP request so it gets response codes in the same numeric
    range and you can use `--write-out` to extract that code as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CONNECT也是一个HTTP请求，因此它会在相同的数字范围内获得响应代码，你也可以使用`--write-out`来提取该代码。
- en: Chunked transfer encoding
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分块传输编码
- en: An HTTP 1.1 server can decide to respond with a chunked encoded response, a
    feature that was not present in HTTP 1.0.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1服务器可以选择以分块编码的响应来响应，这是HTTP 1.0中不存在的一个特性。
- en: 'When receiving a chunked response, there is no Content-Length: for the response
    to indicate its size. Instead, there is a `Transfer-Encoding: chunked` header
    that tells curl there is chunked data coming and then in the response body, the
    data comes in a series of chunks. Every individual chunk starts with the size
    of that particular chunk (in hexadecimal), then a newline and then the contents
    of the chunk. This is repeated over and over until the end of the response, which
    is signaled with a zero sized chunk. The point of this response encoding is for
    the client to be able to figure out when the response has ended even though the
    server did not know the full size before it started to send it. This is usually
    the case when the response is dynamic and generated at the point when the request
    comes.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '当接收到分块响应时，响应中没有Content-Length:来指示其大小。相反，有一个`Transfer-Encoding: chunked`头信息告诉curl即将接收分块数据，然后在响应体中，数据以一系列数据块的形式出现。每个单独的数据块以该特定数据块的大小（十六进制表示）开始，然后是一个换行符，接着是数据块的内容。这个过程会一直重复，直到响应结束，响应结束的信号是一个零大小的数据块。这种响应编码的目的是让客户端能够确定响应何时结束，即使服务器在开始发送之前并不知道完整的响应大小。这通常发生在响应是动态生成，且在请求到达时生成的情况下。'
- en: Clients like curl decode the chunks and do not show the chunk sizes to users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端如curl会解码数据块，但不会向用户显示数据块的大小。
- en: Gzipped transfers
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩传输
- en: 'Responses over HTTP can be sent in compressed format. This is most commonly
    done by the server when it includes a `Content-Encoding: gzip` in the response
    as a hint to the client. Compressed responses make a lot of sense when either
    static resources are sent (that were compressed previously) or even in runtime
    when there is more CPU power available than bandwidth. Sending a much smaller
    amount of data is often preferred.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '通过HTTP发送的响应可以是压缩格式。这通常是在服务器在响应中包含`Content-Encoding: gzip`时完成的，作为向客户端的提示。当发送静态资源（之前已压缩）或在运行时CPU功率大于带宽时，压缩响应非常有意义。发送更少的数据量通常更受欢迎。'
- en: 'You can ask curl to both ask for compressed content *and* automatically and
    transparently uncompress gzipped data when receiving content encoded gzip (or
    in fact any other compression algorithm that curl understands) by using `--compressed`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以要求curl请求压缩内容，并在接收到内容编码为gzip（或实际上curl理解的任何其他压缩算法）时自动和透明地解压缩数据，使用`--compressed`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Transfer encoding
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输编码
- en: A less common feature used with transfer encoding is compression.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与传输编码一起使用的较少见的功能是压缩。
- en: Compression in itself is common. Over time the dominant and web compatible way
    to do compression for HTTP has become to use `Content-Encoding` as described in
    the section above. But HTTP was originally intended and specified to allow transparent
    compression as a transfer encoding, and curl supports this feature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩本身很常见。随着时间的推移，HTTP压缩的主要和兼容网络的方式已经变成了使用上面章节中描述的`Content-Encoding`。但HTTP最初旨在并指定允许透明压缩作为传输编码，curl支持这一功能。
- en: 'The client then simply asks the server to do compression transfer encoding
    and if acceptable, it responds with a header indicating that it does and curl
    then transparently decompresses that data on arrival. A curl user asks for a compressed
    transfer encoding with `--tr-encoding`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端随后简单地要求服务器执行压缩传输编码，如果服务器接受，它会以一个头信息响应表示它执行了压缩，curl随后在到达时透明地解压缩这些数据。curl用户请求压缩传输编码使用`--tr-encoding`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It should be noted that not many HTTP servers in the wild support this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，野外中支持这一功能的HTTP服务器并不多。
- en: Pass on transfer encoding
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递传输编码
- en: In some situations you may want to use curl as a proxy or other in-between software.
    In those cases, curl’s way to deal with transfer-encoding headers and then decoding
    the actual data transparently may not be desired, if the end receiver *also* expects
    to do the same.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望将curl用作代理或其他中间软件。在这些情况下，curl处理传输编码头信息并透明解码实际数据的方式可能不受期望，如果最终接收者*也*期望做同样的事情。
- en: You can then ask curl to pass on the received data, without decoding it. That
    means passing on the sizes in the chunked encoding format or the compressed format
    when compressed transfer encoding is used etc.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以要求curl传递接收到的数据，而不对其进行解码。这意味着在分块编码格式或压缩格式中传递大小，当使用压缩传输编码时等。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
