<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch159.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="http__post__url-encode__md-_-_-url-encode-data" class="level1" data-number="158">
<h1 data-number="158">URL encode data</h1>
<p>Percent-encoding, also known as URL encoding, is technically a mechanism for encoding data so that it can appear in URLs. This encoding is typically used when sending POSTs with the <code>application/x-www-form-urlencoded</code> content type, such as the ones curl sends with <code>--data</code> and <code>--data-binary</code> etc.</p>
<p>The command-line options mentioned above all require that you provide properly encoded data, data you need to make sure already exists in the right format. While that gives you a lot of freedom, it is also a bit inconvenient at times.</p>
<p>To help you send data you have not already encoded, curl offers the <code>--data-urlencode</code> option. This option offers several different ways to URL encode the data you give it.</p>
<p>You use it like <code>--data-urlencode data</code> in the same style as the other –data options. To be CGI-compliant, the <strong>data</strong> part should begin with a name followed by a separator and a content specification. The <strong>data</strong> part can be passed to curl using one of the following syntaxes:</p>
<ul>
<li><p><code>content</code>: URL encode the content and pass that on. Just be careful so that the content does not contain any <code>=</code> or <code>@</code> symbols, as that then makes the syntax match one of the other cases below.</p></li>
<li><p><code>=content</code>: URL encode the content and pass that on. The initial <code>=</code> symbol is not included in the data.</p></li>
<li><p><code>name=content</code>: URL encode the content part and pass that on. Note that the name part is expected to be URL encoded already.</p></li>
<li><p><code>@filename</code>: load data from the given file (including any newlines), URL encode that data and pass it on in the POST.</p></li>
<li><p><code>name@filename</code>: load data from the given file (including any newlines), URL encode that data and pass it on in the POST. The name part gets an equal sign appended, resulting in <code>name=urlencoded-file-content</code>. Note that the name is expected to be URL encoded already.</p></li>
</ul>
<p>As an example, you could POST a name to have it encoded by curl:</p>
<pre><code>curl --data-urlencode &quot;name=John Doe (Junior)&quot; http://example.com</code></pre>
<p>…which would send the following data in the actual request body:</p>
<pre><code>name=John%20Doe%20%28Junior%29</code></pre>
<p>If you store the string <code>John Doe (Junior)</code> in a file named <code>contents.txt</code>, you can tell curl to send that contents URL encoded using the field name ‘user’ like this:</p>
<pre><code>curl --data-urlencode user@contents.txt http://example.com</code></pre>
<p>In both these examples above, the field name is not URL encoded but is passed on as-is. If you want to URL encode the field name as well, like if you want to pass on a field name called <code>user name</code>, you can ask curl to encode the entire string by prefixing it with an equals sign (that does not get sent):</p>
<pre><code>curl --data-urlencode &quot;=user name=John Doe (Junior)&quot; http://example.com</code></pre>
<p><span id="http__post__convert-to-get__md"></span></p>
</section>
</body>
</html>
