<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch145.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="http__response__md-_-_-responses" class="level1" data-number="144">
<h1 data-number="144">Responses</h1>
<p>When an HTTP client talks HTTP to a server, the server responds with an HTTP response message or curl considers it an error and returns 52 with the error message <code>Empty reply from server</code>.</p>
<section id="http__response__md-_-_-size-of-an-http-response" class="level2" data-number="144.1">
<h2 data-number="144.1">Size of an HTTP response</h2>
<p>An HTTP response has a certain size and curl needs to figure it out. There are several different ways to signal the end of an HTTP response but the most basic way is to use the <code>Content-Length:</code> header in the response and with that specify the exact number of bytes in the response body.</p>
<p>Some early HTTP server implementations had problems with file sizes greater than 2GB and wrongly managed to send Content-Length: headers with negative sizes or otherwise just plain wrong data. curl can be told to ignore the Content-Length: header completely with <code>--ignore-content-length</code>. Doing so may have some other negative side-effects but should at least let you get the data.</p>
</section>
<section id="http__response__md-_-_-http-response-codes" class="level2" data-number="144.2">
<h2 data-number="144.2">HTTP response codes</h2>
<p>An HTTP transfer gets a 3 digit response code back in the first response line. The response code is the server’s way of giving the client a hint about how the request was handled.</p>
<p>It is important to note that curl does not consider it an error even if the response code would indicate that the requested document could not be delivered (or similar). curl considers a successful sending and receiving of HTTP to be good.</p>
<p>The first digit of the HTTP response code is a kind of error class:</p>
<ul>
<li>1xx: transient response, more is coming</li>
<li>2xx: success</li>
<li>3xx: a redirect</li>
<li>4xx: the client asked for something the server could not or would not deliver</li>
<li>5xx: there is a problem in the server</li>
</ul>
<p>Remember that you can use curl’s <code>--write-out</code> option to extract the response code. See the <a href="ch081.xhtml#usingcurl__verbose__writeout__md">–write-out</a> section.</p>
<p>To make curl return an error for response codes &gt;= 400, you need to use <code>--fail</code> or <code>--fail-with-body</code>. Then curl exits with error code 22 for such occurrences.</p>
</section>
<section id="http__response__md-_-_-connect-response-codes" class="level2" data-number="144.3">
<h2 data-number="144.3">CONNECT response codes</h2>
<p>Since there can be an HTTP request and a separate CONNECT request in the same curl transfer, we often separate the CONNECT response (from the proxy) from the remote server’s HTTP response.</p>
<p>The CONNECT is also an HTTP request so it gets response codes in the same numeric range and you can use <code>--write-out</code> to extract that code as well.</p>
</section>
<section id="http__response__md-_-_-chunked-transfer-encoding" class="level2" data-number="144.4">
<h2 data-number="144.4">Chunked transfer encoding</h2>
<p>An HTTP 1.1 server can decide to respond with a chunked encoded response, a feature that was not present in HTTP 1.0.</p>
<p>When receiving a chunked response, there is no Content-Length: for the response to indicate its size. Instead, there is a <code>Transfer-Encoding: chunked</code> header that tells curl there is chunked data coming and then in the response body, the data comes in a series of chunks. Every individual chunk starts with the size of that particular chunk (in hexadecimal), then a newline and then the contents of the chunk. This is repeated over and over until the end of the response, which is signaled with a zero sized chunk. The point of this response encoding is for the client to be able to figure out when the response has ended even though the server did not know the full size before it started to send it. This is usually the case when the response is dynamic and generated at the point when the request comes.</p>
<p>Clients like curl decode the chunks and do not show the chunk sizes to users.</p>
</section>
<section id="http__response__md-_-_-gzipped-transfers" class="level2" data-number="144.5">
<h2 data-number="144.5">Gzipped transfers</h2>
<p>Responses over HTTP can be sent in compressed format. This is most commonly done by the server when it includes a <code>Content-Encoding: gzip</code> in the response as a hint to the client. Compressed responses make a lot of sense when either static resources are sent (that were compressed previously) or even in runtime when there is more CPU power available than bandwidth. Sending a much smaller amount of data is often preferred.</p>
<p>You can ask curl to both ask for compressed content <em>and</em> automatically and transparently uncompress gzipped data when receiving content encoded gzip (or in fact any other compression algorithm that curl understands) by using <code>--compressed</code>:</p>
<pre><code>curl --compressed http://example.com/</code></pre>
</section>
<section id="http__response__md-_-_-transfer-encoding" class="level2" data-number="144.6">
<h2 data-number="144.6">Transfer encoding</h2>
<p>A less common feature used with transfer encoding is compression.</p>
<p>Compression in itself is common. Over time the dominant and web compatible way to do compression for HTTP has become to use <code>Content-Encoding</code> as described in the section above. But HTTP was originally intended and specified to allow transparent compression as a transfer encoding, and curl supports this feature.</p>
<p>The client then simply asks the server to do compression transfer encoding and if acceptable, it responds with a header indicating that it does and curl then transparently decompresses that data on arrival. A curl user asks for a compressed transfer encoding with <code>--tr-encoding</code>:</p>
<pre><code>curl --tr-encoding http://example.com/</code></pre>
<p>It should be noted that not many HTTP servers in the wild support this.</p>
</section>
<section id="http__response__md-_-_-pass-on-transfer-encoding" class="level2" data-number="144.7">
<h2 data-number="144.7">Pass on transfer encoding</h2>
<p>In some situations you may want to use curl as a proxy or other in-between software. In those cases, curl’s way to deal with transfer-encoding headers and then decoding the actual data transparently may not be desired, if the end receiver <em>also</em> expects to do the same.</p>
<p>You can then ask curl to pass on the received data, without decoding it. That means passing on the sizes in the chunked encoding format or the compressed format when compressed transfer encoding is used etc.</p>
<pre><code>curl --raw http://example.com/</code></pre>
<p><span id="http__auth__md"></span></p>
</section>
</section>
</body>
</html>
