["```sh\n$ echo apple;cherry\napple\ncherry: command not found\n\n# '\\;' escapes the ';' character, thus losing the metacharacter meaning\n$ echo apple\\;cherry\napple;cherry \n```", "```sh\n# this will create two files named 'new' and 'file.txt'\n# aim was to create a single file named 'new file.txt'\n$ touch new file.txt\n$ ls new*txt\nls: cannot access 'new*txt': No such file or directory\n$ rm file.txt new\n\n# escaping the space will create a single file named 'new file.txt'\n$ touch new\\ file.txt\n$ ls new*txt\n'new file.txt'\n$ rm new\\ file.txt \n```", "```sh\n$ echo 'apple;cherry'\napple;cherry \n```", "```sh\n# concatenation of four strings\n# 1: '@fruits = '\n# 2: \\'\n# 3: 'apple and banana'\n# 4: \\'\n$ echo '@fruits = '\\''apple and banana'\\'\n@fruits = 'apple and banana' \n```", "```sh\n$ qty='5'\n\n# as seen earlier, no character is special within single quotes\n$ echo 'I bought $qty apples'\nI bought $qty apples\n\n# a typical use of double quotes is to enable variable interpolation\n$ echo \"I bought $qty apples\"\nI bought 5 apples \n```", "```sh\n$ f='new file.txt'\n\n# same as: echo 'apple banana' > new file.txt\n$ echo 'apple banana' > $f\nbash: $f: ambiguous redirect\n\n# same as: echo 'apple banana' > 'new file.txt'\n$ echo 'apple banana' > \"$f\"\n$ cat \"$f\"\napple banana\n$ rm \"$f\" \n```", "```sh\n# can also use echo -e 'fig:\\t42' or printf 'fig:\\t42\\n'\n$ echo $'fig:\\t42'\nfig:    42\n\n# \\x27 represents the single quote character in hexadecimal format\n$ echo $'@fruits = \\x27apple and banana\\x27'\n@fruits = 'apple and banana'\n\n# 'grep' helps you to filter lines based on the given pattern\n# but it doesn't recognize escapes like '\\t' for tab characters\n$ printf 'fig\\t42\\napple 100\\nball\\t20\\n' | grep '\\t'\n# in such cases, one workaround is use to ANSI-C quoting\n$ printf 'fig\\t42\\napple 100\\nball\\t20\\n' | grep $'\\t'\nfig     42\nball    20 \n```", "```sh\n# change to the 'scripts' directory and source the 'globs.sh' script\n$ source globs.sh\n$ ls\n100.sh   f1.txt      f4.txt    hi.sh   math.h         report-02.log\n42.txt   f2_old.txt  f7.txt    ip.txt  notes.txt      report-04.log\ncalc.py  f2.txt      hello.py  main.c  report-00.log  report-98.log\n\n# beginning with 'c' or 'h' or 't'\n$ ls [cht]*\ncalc.py  hello.py  hi.sh\n\n# only hidden files and directories\n$ ls -d .*\n.  ..  .hidden  .somerc\n\n# ending with '.c' or '.py'\n$ ls *.c *.py\ncalc.py  hello.py  main.c\n\n# containing 'o' as well as 'x' or 'y' or 'z' afterwards\n$ ls *o*[xyz]*\nf2_old.txt  hello.py  notes.txt\n\n# ending with '.' and two more characters\n$ ls *.??\n100.sh  calc.py  hello.py  hi.sh\n\n# shouldn't start with 'f' and ends with '.txt'\n$ ls [^f]*.txt\n42.txt  ip.txt  notes.txt\n\n# containing digits '1' to '5' and ending with 'log'\n$ ls *[1-5]*log\nreport-02.log  report-04.log \n```", "```sh\n$ ls *[ns-]*\n100.sh  main.c     report-00.log  report-04.log\nhi.sh   notes.txt  report-02.log  report-98.log\n\n$ touch 'a^b' 'mars[planet].txt'\n$ rm -i *[]^]*\nrm: remove regular empty file 'a^b'? y\nrm: remove regular empty file 'mars[planet].txt'? y \n```", "```sh\n# starting with a digit character, same as: [0-9]*\n$ ls [[:digit:]]*\n100.sh  42.txt\n\n# starting with a digit character or 'c'\n# same as: [0-9c]*\n$ ls [[:digit:]c]*\n100.sh  42.txt  calc.py\n\n# starting with a non-alphabet character\n$ ls [^[:alpha:]]*\n100.sh  42.txt \n```", "```sh\n$ mkdir practice_brace\n$ cd practice_brace\n\n# same as: touch ip1.txt ip3.txt ip7.txt\n$ touch ip{1,3,7}.txt\n$ ls ip*txt\nip1.txt  ip3.txt  ip7.txt\n\n# same as: mv ip1.txt ip_a.txt\n$ mv ip{1,_a}.txt\n$ ls ip*txt\nip3.txt  ip7.txt  ip_a.txt\n\n$ echo adders/{half,full}_adder.v\nadders/half_adder.v adders/full_adder.v\n\n$ echo file{0,1}.{txt,log}\nfile0.txt file0.log file1.txt file1.log\n\n# empty alternate is allowed too\n$ echo file{,1}.txt\nfile.txt file1.txt\n\n# example with nested braces\n$ echo file.{txt,log{,.bkp}}\nfile.txt file.log file.log.bkp \n```", "```sh\n$ echo {1..4}\n1 2 3 4\n$ echo {4..1}\n4 3 2 1\n\n$ echo {1..2}{a..b}\n1a 1b 2a 2b\n\n$ echo file{1..4}.txt\nfile1.txt file2.txt file3.txt file4.txt\n\n$ echo file{1..10..2}.txt\nfile1.txt file3.txt file5.txt file7.txt file9.txt\n\n$ echo file_{x..z}.txt\nfile_x.txt file_y.txt file_z.txt\n\n$ echo {z..j..-3}\nz w t q n k\n\n# '0' prefix\n$ echo {008..10}\n008 009 010 \n```", "```sh\n$ echo file{1}.txt\nfile{1}.txt\n\n$ echo file{1-4}.txt\nfile{1-4}.txt \n```", "```sh\n$ shopt extglob\nextglob         off\n\n# set extglob\n$ shopt -s extglob\n$ shopt extglob\nextglob         on\n\n# unset extglob\n$ shopt -u extglob\n$ shopt extglob\nextglob         off \n```", "```sh\n# change to the 'scripts' directory and source the 'globs.sh' script\n$ source globs.sh\n$ ls\n100.sh   f1.txt      f4.txt    hi.sh   math.h         report-02.log\n42.txt   f2_old.txt  f7.txt    ip.txt  notes.txt      report-04.log\ncalc.py  f2.txt      hello.py  main.c  report-00.log  report-98.log\n\n# one or more digits followed by '.' and then zero or more characters\n$ ls +([0-9]).*\n100.sh  42.txt\n\n# same as: ls *.c *.sh\n$ ls *.@(c|sh)\n100.sh  hi.sh  main.c\n\n# not ending with '.txt'\n$ ls !(*.txt)\n100.sh   hello.py  main.c  report-00.log  report-04.log\ncalc.py  hi.sh     math.h  report-02.log  report-98.log\n\n# not ending with '.txt' or '.log'\n$ ls *.!(txt|log)\n100.sh  calc.py  hello.py  hi.sh  main.c  math.h \n```", "```sh\n# change to the 'scripts' directory and source the 'ls.sh' script\n$ source ls.sh\n\n# with 'find' command (this will be explained in a later chapter)\n$ find -name '*.txt'\n./todos/books.txt\n./todos/outing.txt\n./ip.txt\n\n# with 'globstar' enabled\n$ shopt -s globstar\n$ ls **/*.txt\nip.txt  todos/books.txt  todos/outing.txt\n\n# another example\n$ ls -1 **/*.@(py|html)\nbackups/bookmarks.html\nhello_world.py\nprojects/tictactoe/game.py \n```", "```sh\n# disables logging command history from this point onwards\n$ set +o history\n# enable history logging\n$ set -o history\n\n# use vi-style CLI editing interface\n$ set -o vi\n# use emacs-style interface, this is usually the default\n$ set -o emacs \n```", "```sh\n# change to the 'scripts' directory and source the 'du.sh' script\n$ source du.sh\n\n# list of files\n$ ls\nprojects  report.log  todos\n# count the number of files\n# you can also use: printf '%q\\n' * | wc -l\n$ ls -q | wc -l\n3\n\n# report the size of files/folders in human readable format\n# and then sort them based on human readable sizes in ascending order\n$ du -sh * | sort -h\n8.0K    todos\n48K     projects\n7.4M    report.log \n```", "```sh\n$ du -sh * | tee sizes.log\n48K     projects\n7.4M    report.log\n8.0K    todos\n\n$ cat sizes.log\n48K     projects\n7.4M    report.log\n8.0K    todos\n\n$ rm sizes.log \n```", "```sh\n> >op.txt grep 'error' report.log\n> \n> grep 'error' report.log >op.txt \n> ```", "```sh\n# change to the 'example_files/text_files' directory for this section\n\n# save first three lines of 'sample.txt' to 'op.txt'\n$ head -n3 sample.txt > op.txt\n$ cat op.txt\n 1) Hello World\n 2) \n 3) Hi there\n\n# append last two lines of 'sample.txt' to 'op.txt'\n$ tail -n2 sample.txt >> op.txt\n$ cat op.txt\n 1) Hello World\n 2) \n 3) Hi there\n14) He he he\n15) Adios amigo\n\n$ rm op.txt \n```", "```sh\n# filter lines containing 'the' from the input file 'greeting.txt'\n# and then display the results in uppercase using the 'tr' command\n$ grep 'the' greeting.txt | tr 'a-z' 'A-Z'\nHI THERE \n```", "```sh\n$ tr 'a-z' 'A-Z' &LTgreeting.txt\nHI THERE\nHAVE A NICE DAY \n```", "```sh\n# line count, filename is part of the output as well\n$ wc -l purchases.txt\n8 purchases.txt\n\n# filename won't be part of the output for stdin data\n# helpful for assigning the number to a variable for scripting purposes\n$ wc -l &LTpurchases.txt\n8 \n```", "```sh\n$ cat scores.csv\nName,Maths,Physics,Chemistry\nIth,100,100,100\nCy,97,98,95\nLin,78,83,80\n\n# insert a column at the start\n$ printf 'ID\\n1\\n2\\n3' | paste -d, - scores.csv\nID,Name,Maths,Physics,Chemistry\n1,Ith,100,100,100\n2,Cy,97,98,95\n3,Lin,78,83,80 \n```", "```sh\n# display only the third field\n$ &LTscores.csv cut -d, -f3\nPhysics\n100\n98\n83\n\n# later, you realize that you need the first field too\n# use 'up' arrow key to bring the previous command\n# and modify the argument easily at the end\n# if you had used cut -d, -f3 scores.csv instead,\n# you'd have to navigate past the filename to modify the argument\n$ &LTscores.csv cut -d, -f1,3\nName,Physics\nIth,100\nCy,98\nLin,83 \n```", "```sh\n# assume 'abcdxyz' doesn't exist as a shell command\n$ abcdxyz\nabcdxyz: command not found\n\n# the error in such cases will be part of the stderr stream, not stdout\n# so, you'll need to use 2> here\n$ abcdxyz 2> cmderror.log\n$ cat cmderror.log\nabcdxyz: command not found\n\n$ rm cmderror.log \n```", "```sh\n# using '>' will redirect only the stdout stream\n# stderr will be displayed on the terminal\n$ grep 'log' file_size.txt xyz.txt > op.txt\ngrep: xyz.txt: No such file or directory\n\n# using '&>' will redirect both the stdout and stderr streams\n$ grep 'log' file_size.txt xyz.txt &> op.txt\n$ cat op.txt\nfile_size.txt:104K    power.log\nfile_size.txt:746K    report.log\ngrep: xyz.txt: No such file or directory\n\n$ rm op.txt \n```", "```sh\n# filter lines containing 'log' from the given file arguments\n# and then filter lines containing 'or' from the combined stdout and stderr\n$ grep 'log' file_size.txt xyz.txt |& grep 'or'\nfile_size.txt:746K    report.log\ngrep: xyz.txt: No such file or directory \n```", "```sh\n# note that the order of redirections is important here\n# you can also use: 2> op.txt 1>&2\n$ grep 'log' file_size.txt xyz.txt > op.txt 2>&1\n$ cat op.txt\nfile_size.txt:104K    power.log\nfile_size.txt:746K    report.log\ngrep: xyz.txt: No such file or directory\n$ rm op.txt\n\n$ grep 'log' file_size.txt xyz.txt 2>&1 | grep 'or'\nfile_size.txt:746K    report.log\ngrep: xyz.txt: No such file or directory \n```", "```sh\n# press Enter and Ctrl+d after typing all the required characters\n$ cat\nknock knock\nknock knock\nanybody here?\nanybody here?\n\n# 'tr' command here translates lowercase to uppercase\n$ tr 'a-z' 'A-Z'\nknock knock\nKNOCK KNOCK\nanybody here?\nANYBODY HERE? \n```", "```sh\n> # press Ctrl+d after the third input line\n> $ sort\n> lion\n> zebra\n> bee\n> bee\n> lion\n> zebra \n> ```", "```sh\n# press Ctrl+d after the line containing 'histogram'\n# filter lines containing 'is'\n$ grep 'is' > op.txt\nhi there\nthis is a sample line\nhave a nice day\nhistogram\n\n$ cat op.txt\nthis is a sample line\nhistogram\n\n$ rm op.txt \n```", "```sh\n# EOF is typically used as the special string\n$ cat << 'EOF' > fruits.txt\n> banana 2\n> papaya 3\n> mango  10\n> EOF\n\n$ cat fruits.txt\nbanana 2\npapaya 3\nmango  10\n$ rm fruits.txt \n```", "```sh\n$ tr 'a-z' 'A-Z' <<< hello\nHELLO\n$ tr 'a-z' 'A-Z' <<< 'hello world'\nHELLO WORLD\n\n$ greeting='hello world'\n$ tr 'a-z' 'A-Z' > op.txt <<< \"$greeting\"\n$ cat op.txt\nHELLO WORLD\n$ rm op.txt \n```", "```sh\n# change to the 'example_files/text_files' directory for this section\n\n# the 'sed' command here gives the first line of the input\n# rest of the lines are then processed by the 'sort' command\n# thus, the header will always be the first line in the output\n$ (sed -u '1q' ; sort) < scores.csv\nName,Maths,Physics,Chemistry\nCy,97,98,95\nIth,100,100,100\nLin,78,83,80\n\n# save first three and last two lines from 'sample.txt' to 'op.txt'\n$ { head -n3 sample.txt; tail -n2 sample.txt; } > op.txt\n$ cat op.txt\n 1) Hello World\n 2) \n 3) Hi there\n14) He he he\n15) Adios amigo\n$ rm op.txt \n```", "```sh\n> $ head -n1 sample.txt ; echo 'have a nice day'\n>  1) Hello World\n> have a nice day \n> ```", "```sh\n# first command succeeds here, so the second command is also executed\n$ echo 'hello' && echo 'have a nice day'\nhello\nhave a nice day\n\n# assume 'abcdxyz' doesn't exist as a shell command\n# the second command will not be executed\n$ abcdxyz && echo 'have a nice day'\nabcdxyz: command not found\n\n# if you use ';' instead, the second command will still be executed\n$ abcdxyz ; echo 'have a nice day'\nabcdxyz: command not found\nhave a nice day \n```", "```sh\n# since the first command succeeds, the second one won't run\n$ echo 'hello' || echo 'have a nice day'\nhello\n\n# assume 'abcdxyz' doesn't exist as a shell command\n# since the first command fails, the second one will run\n$ abcdxyz || echo 'have a nice day'\nabcdxyz: command not found\nhave a nice day \n```", "```sh\n# sample input\n$ printf 'hello\\ntoday is: \\n'\nhello\ntoday is:\n# append output from the 'date' command to the line containing 'today'\n$ printf 'hello\\ntoday is: \\n' | sed '/today/ s/$/'\"$(date +%A)\"'/'\nhello\ntoday is: Monday\n\n# save the output of 'wc' command to a variable\n# same as: line_count=`wc -l &LTsample.txt`\n$ line_count=$(wc -l &LTsample.txt)\n$ echo \"$line_count\"\n15 \n```", "```sh\n# dirname removes the trailing path component\n$ dirname projects/tictactoe/game.py\nprojects/tictactoe\n# basename removes the leading directory component\n$ basename projects/tictactoe\ntictactoe\n\n$ proj=$(basename $(dirname projects/tictactoe/game.py))\n$ echo \"$proj\"\ntictactoe \n```", "```sh\n# change to the 'example_files/text_files' directory for this section\n\n$ cat scores.csv\nName,Maths,Physics,Chemistry\nIth,100,100,100\nCy,97,98,95\nLin,78,83,80\n\n# can also use: paste -d, <(echo 'ID'; seq 3) scores.csv\n$ paste -d, <(printf 'ID\\n1\\n2\\n3') scores.csv\nID,Name,Maths,Physics,Chemistry\n1,Ith,100,100,100\n2,Cy,97,98,95\n3,Lin,78,83,80 \n```", "```sh\n# side-by-side view of sample input files\n$ paste f1.txt f2.txt\n1       1\n2       hello\n3       3\nworld   4\n\n# this command gives the common lines between two files\n# the files have to be sorted for the command to work properly\n$ comm -12 <(sort f1.txt) <(sort f2.txt)\n1\n3 \n```", "```sh\n# ???\nthat's    great! $x = $y + $z \n```", "```sh\n$ n1=10\n$ n2=90\n$ op=100\n\n# ???\n10 + 90 = 100 \n```", "```sh\n$ echo $'\\x22apple\\x22: \\x2710\\x27' \n```", "```sh\n# change to the 'scripts' directory and source the 'globs.sh' script\n$ source globs.sh\n\n# ???\n100.sh  42.txt \n```", "```sh\n# ???\n100.sh  calc.py  hello.py  hi.sh  main.c  math.h \n```", "```sh\n# ???\nmain.c  math.h \n```", "```sh\n# ???\n100.sh   hello.py  main.c  report-00.log  report-04.log\ncalc.py  hi.sh     math.h  report-02.log  report-98.log \n```", "```sh\n$ ls *[^[:word:]]*.*\nreport-00.log  report-02.log  report-04.log  report-98.log \n```", "```sh\n# ???\ncalc.py  hello.py  hi.sh  ip.txt  main.c  math.h  notes.txt \n```", "```sh\n# ???\nhello.py  hi.sh  main.c  math.h \n```", "```sh\n# change to the 'scripts' directory and source the 'ls.sh' script\n$ source ls.sh\n\n# filenames ending with '.txt'\n# ???\nip.txt  todos/books.txt  todos/outing.txt\n\n# directories starting with 'c' or 'd' or 'g' or 'r' or 't'\n# ???\nbackups/dot_files/\nprojects/calculator/\nprojects/tictactoe/\ntodos/ \n```", "```sh\n# ???\n$ ls report*\nreport_2020.txt  report_2021.txt  report_2022.txt\n\n# use the 'cp' command here\n# ???\n$ ls report*\nreport_2020.txt  report_2021.txt  report_2021.txt.bkp  report_2022.txt \n```", "```sh\n$ printf '%s\\n' apple car dragon\napple\ncar\ndragon \n```", "```sh\n$ ls ip.txt\nls: cannot access 'ip.txt': No such file or directory\n\n# ???\n$ cat ip.txt\nitem_10\nitem_12\nitem_14\nitem_16\nitem_18\nitem_20 \n```", "```sh\n# ???\n$ cat ip.txt\nitem_10\nitem_12\nitem_14\nitem_16\nitem_18\nitem_20\napple_1_banana_6\napple_1_banana_7\napple_1_banana_8\napple_2_banana_6\napple_2_banana_7\napple_2_banana_8\napple_3_banana_6\napple_3_banana_7\napple_3_banana_8 \n```", "```sh\n# press Ctrl+d after the line containing 'histogram'\n$ grep 'hi' > op.txt\nhi there\nthis is a sample line\nhave a nice day\nhistogram\n\n$ cat op.txt \n```", "```sh\n$ qty=42\n$ cat << end > op.txt\n> dragon\n> unicorn\n> apple $qty\n> ice cream\n> end\n\n$ cat op.txt \n```", "```sh\n$ books='cradle piranesi soulhome bastion'\n\n# something is wrong with this command\n$ sed 's/\\b\\w/\\u&/g' <<< '$books'\n$Books\n\n# ???\nCradle Piranesi Soulhome Bastion \n```", "```sh\n# something is wrong with this command\n$ echo 'hello' ; seq 3 > op.txt\nhello\n$ cat op.txt\n1\n2\n3\n\n# ???\n$ cat op.txt\nhello\n1\n2\n3 \n```", "```sh\n$ printf 'hello' | tr 'a-z' 'A-Z' && echo ' there'\n\n$ printf 'hello' | tr 'a-z' 'A-Z' || echo ' there' \n```", "```sh\n# something is wrong with these commands\n$ nums=$(seq 3)\n$ echo $nums\n1 2 3\n\n# ???\n1\n2\n3 \n```", "```sh\n$ paste -d, <(seq 3) <(printf '%s\\n' item_{1..3})\n\n$ printf '%s\\n' {1..3},item_{1..3} \n```"]