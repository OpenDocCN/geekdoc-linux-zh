- en: Assorted Text Processing Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://learnbyexample.github.io/cli-computing/assorted-text-processing-tools.html](https://learnbyexample.github.io/cli-computing/assorted-text-processing-tools.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are way too many specialized text processing tools. This chapter will
    discuss some of the commands that haven't been covered in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) The [example_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files)
    directory has the sample input files used in this chapter.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[seq](#seq)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `seq` command is a handy tool to generate a sequence of numbers in ascending
    or descending order. Both integer and floating-point numbers are supported. You
    can also customize the formatting for numbers and the separator between them.
  prefs: []
  type: TYPE_NORMAL
- en: You need three numbers to generate an arithmetic progression — **start**, **step**
    and **stop**. When you pass only a single number as the stop value, the default
    start and step values are assumed to be `1`. Passing two numbers are considered
    as start and stop values (in that order).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By using a negative step value, you can generate sequences in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-s` option to change the separator *between* the numbers of
    a sequence. A single newline character is always the character added after the
    final number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `-w` option will equalize the width of the output numbers using leading
    zeros. The largest width between the start and stop values will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-f` option for `printf` style floating-point number formatting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[shuf](#shuf)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, `shuf` will randomize the order of input lines. You can use the
    `-n` option to limit the number of output lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-e` option to specify multiple input lines as arguments to
    the command. The `-r` option helps if you want to allow input lines to be repeated.
    This option is usually paired with `-n` to limit the number of lines in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` option will help you generate random positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[cut](#cut)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cut` is a handy tool for many field processing use cases. The features are
    limited compared to the `awk` and `perl` commands, but the reduced scope also
    leads to faster processing.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `cut` splits the input content into fields based on the tab character,
    which you can change using the `-d` option. The `-f` option allows you to select
    a desired field from each input line. To extract multiple fields, specify the
    selections separated by the comma character. By default, lines not containing
    the input delimiter will still be part of the output. You can use the `-s` option
    to suppress such lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-` character to specify field ranges. The starting or ending
    field number can be skipped, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Use the `--output-delimiter` option to customize the output separator to any
    string of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `--complement` option allows you to invert the field selections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-b` or `-c` options to select specified bytes from each input
    line. The syntax is same as the `-f` option. The `-c` option is intended for multibyte
    character selection, but for now it works exactly as the `-b` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[column](#column)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `column` command is a nifty tool to align the input data column wise. By
    default, whitespace is used as the input delimiter. Space character is used to
    align the output columns, so whitespace characters like tab will get converted
    to spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-s` option to customize the input delimiter. Note that the
    output delimiter will still be made up of spaces only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![warning](../Images/b5314b4a0acf0f436c4bf59486793342.png) Input should have
    a newline at the end, otherwise you''ll get an error:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '[tr](#tr)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tr` helps you to map one set of characters to another set of characters. Features
    like range, repeats, character sets, squeeze, complement, etc makes it a must
    know text processing tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tr` works only on `stdin` data, so you''ll need to use shell input redirection
    for file input. Here are some basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `-d` option to specify a set of characters to be deleted. The
    `-c` option will invert the first set of characters. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `-s` option changes consecutive repeated characters to a single copy of
    that character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[paste](#paste)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`paste` is typically used to merge two or more files column wise. It also has
    a handy feature for serializing data. By default, `paste` adds a tab character
    between the corresponding lines of input files.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `-d` option to change the delimiter between the columns. The
    separator is added even if the data has been exhausted for some of the input files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can use empty files to get multicharacter separation between the columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you use `-` multiple times, `paste` will consume a line from `stdin` data
    every time `-` is encountered. This is different from using the same filename
    multiple times, in which case they are treated as separate inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `-s` option allows you to combine all the input lines from a file into a
    single line using the given delimiter. Multiple input files are treated separately.
    `paste` will ensure to add a final newline character even if it isn't present
    in the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[pr](#pr)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Paginate or columnate FILE(s) for printing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As stated in the above quote from the manual, the `pr` command is mainly used
    for those two tasks. This section will discuss only the columnate features and
    some miscellaneous tasks. Here's a pagination example if you are interested in
    exploring further. The `pr` command will add blank lines, a header and so on to
    make it suitable for printing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--columns` and `-a` options can be used to merge the input lines in two
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: split the input file and then merge them as columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: merge consecutive lines, similar to the `paste` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's an example to get started. Note that `-N` is same as using `--columns=N`
    where `N` is the number of columns you want in the output. The default page width
    is `72`, which means each column can only have a maximum of `72/N` characters
    (including the separator). Tab and space characters will be used to fill the columns
    as needed. You can use the `-J` option to prevent `pr` from truncating longer
    columns. The `-t` option is used here to turn off the pagination features.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can customize the separator using the `-s` option. The default is a tab
    character which you can change to any other string value. The `-s` option also
    turns off line truncation, so the `-J` option isn't needed. Use the `-a` option
    to merge consecutive lines, similar to the `paste` command example seen earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, the default page width of `72` can still cause issues, which you can
    prevent by using the `-w` option. The `-w` option overrides the effect of the
    `-s` option on line truncation, so use the `-J` option as well unless you really
    need truncation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Two or more input files can be merged column wise using the `-m` option. As
    seen before, the `-t` option is needed to ignore pagination features and `-s`
    can be used to customize the separator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[rev](#rev)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rev` command reverses each input line character wise. The newline character
    *won''t* be added to the end if it wasn''t present in the input. Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[split](#split)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `split` command is useful to divide the input into smaller parts based on
    the number of lines, bytes, file size, etc. You can also execute another command
    on the divided parts before saving the results. An example use case is sending
    a large file as multiple parts as a workaround for online transfer size limits.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `split` command divides the input `1000` lines at a time. Newline
    character is the default line separator. You can pass a single file or `stdin`
    data as the input. Use `cat` if you need to concatenate multiple input sources.
    By default, the output files will be named `xaa`, `xab`, `xac` and so on (where
    `x` is the prefix). If the filenames are exhausted, two more letters will be appended
    and the pattern will continue as needed. If the number of input lines is not evenly
    divisible, the last file will contain less than `1000` lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) For more examples,
    customization options and other details, see the [split chapter](https://learnbyexample.github.io/cli_text_processing_coreutils/split.html)
    from my [CLI text processing with GNU Coreutils](https://github.com/learnbyexample/cli_text_processing_coreutils)
    ebook.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[csplit](#csplit)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `csplit` command is useful to divide the input into smaller parts based
    on line numbers and regular expression patterns.
  prefs: []
  type: TYPE_NORMAL
- en: You can split the input into two based on a particular line number. To do so,
    specify the line number after the input source (filename or `stdin` data). The
    first output file will have the input lines *before* the given line number and
    the second output file will have the rest of the contents. By default, the output
    files will be named `xx00`, `xx01`, `xx02` and so on (where `xx` is the prefix).
    The numerical suffix will automatically use more digits if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also split the input based on a line matching the given regular expression.
    The output produced will vary based on the `//` or `%%` delimiters being used
    to surround the regexp. When `/regexp/` is used, output is similar to the line
    number based splitting. The first output file will have the input lines *before*
    the first occurrence of a line matching the given regexp and the second output
    file will have the rest of the contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this sample input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of splitting the input file using the `/regexp/` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When `%regexp%` is used, the lines occurring before the matching line won't
    be part of the output. Only the line matching the given regexp and the rest of
    the contents will be part of the single output file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) For more examples,
    customization options and other details, see the [csplit chapter](https://learnbyexample.github.io/cli_text_processing_coreutils/csplit.html)
    from my [CLI text processing with GNU Coreutils](https://github.com/learnbyexample/cli_text_processing_coreutils)
    ebook.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[xargs](#xargs)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, `xargs` executes the `echo` command for the arguments extracted
    from `stdin` data (or file input via the `-a` option). The `-n` option helps to
    customize how many arguments should be passed at a time. Together, these features
    can be used to reshape whitespace separated data as shown in the examples below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `-L` option to specify how many input lines should be combined
    at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Note that `xargs -L1`
    is not the same as `awk ''{$1=$1} 1''` since `xargs` will discard blank lines.
    Also, trailing blank characters will cause the next line to be considered as part
    of the current line. For example:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'You can use the `-d` option to specify a custom single character input delimiter.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[Exercises](#exercises)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![info](../Images/147d5d96e6e103c258c8b5f99e9505a9.png) Use the [example_files/text_files](https://github.com/learnbyexample/cli-computing/tree/master/example_files/text_files)
    directory for input files used in the following exercises.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**1)** Generate the following sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**2)** Is the sequence shown below possible to generate with `seq`? If so,
    how?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**3)** Display three random words from `/usr/share/dict/words` (or an equivalent
    dictionary word file) containing `s` and `e` and `t` in any order. The output
    shown below is just an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**4)** Briefly describe the purpose of the `shuf` command options `-i`, `-e`
    and `-r`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**5)** Why does the below command not work as expected? What other tools can
    you use in such cases?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**6)** Display except the second field in the format shown below. Can you construct
    two different solutions?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**7)** Extract the first three characters from the input lines as shown below.
    Can you also use the `head` command for this purpose? If not, why not?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**8)** Display only the first and third columns of the `scores.csv` input file
    in the format as shown below. Note that only space characters are present between
    the two columns, not tab.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**9)** Display the contents of `table.txt` in the format shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**10)** Implement [ROT13](https://en.wikipedia.org/wiki/ROT13) cipher using
    the `tr` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**11)** Retain only alphabets, digits and whitespace characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**12)** Use `tr` to get the output shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**13)** `paste -s` works separately for multiple input files. How would you
    workaround this if you needed to treat all the input files as a single source?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**14)** Use appropriate options to get the expected output shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**15)** Use the `pr` command to get the expected output shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**16)** Use the `pr` command to join the input files `fruits.txt` and `ip.txt`
    as shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**17)** The `cut` command doesn''t support a way to choose the last `N` fields.
    Which tool presented in this chapter can be combined to work with `cut` to get
    the output shown below?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**18)** Go through the `split` documentation and use appropriate options to
    get the output shown below for the input file `purchases.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**19)** Go through the `split` documentation and use appropriate options to
    get the output shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**20)** Split the input file `purchases.txt` such that the text before a line
    containing `powder` is part of the first file and the rest are part of the second
    file as shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**21)** Write a generic solution that transposes comma delimited data. Example
    input/output is shown below. You can use any tool(s) presented in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**22)** Reshape the contents of `table.txt` to the expected output shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
