<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch296.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="internals__timeouts__md-_-_-timeouts" class="level1" data-number="295">
<h1 data-number="295">Timeouts</h1>
<p>All internals need to be written non-blocking and cannot just hang around and wait for things to occur. At the same time, the multi interface allows users to call libcurl to perform virtually at any time, even if no action has happened or a timeout has triggered.</p>
<section id="internals__timeouts__md-_-_-exposes-just-a-single-timeout-to-apps" class="level2" data-number="295.1">
<h2 data-number="295.1">Exposes just a single timeout to apps</h2>
<p>In the external API libcurl provides a single timeout at a time, no matter how many concurrent transfers and what options are set. An application can get the timeout value it with <code>curl_multi_timeout()</code> or in a <code>CURLMOPT_TIMERFUNCTION</code> callback, depending on what API it wants to use.</p>
<p>Internally, this is done like this:</p>
<ul>
<li>Every easy handle keeps an array of timeouts, in a sorted order. The closest (next-timeout) in time is first in the list.</li>
<li>All easy handles are put in a <em>splay tree</em> which is binary self-balancing search tree that makes it fast to insert and remove nodes depending on their timeouts.</li>
<li>As soon as any handleâ€™s next-timeout changes, the splay tree is re-balanced.</li>
</ul>
<p>Extracting the easy handles with expired timeouts is a quick operation.</p>
</section>
<section id="internals__timeouts__md-_-_-set-a-timeout" class="level2" data-number="295.2">
<h2 data-number="295.2">Set a timeout</h2>
<p>The internal function for <em>setting</em> a timeout is called <code>Curl_expire()</code>. It asks that libcurl gets called again for this handle in a certain amount of milliseconds into the future. A timeout is set with a specific ID, to make sure that it overrides previous values set for the same timeout etc. The existing timeout IDs are limited and the set is hard-coded.</p>
<p>A timeout can be removed again with <code>Curl_expire_clear()</code>, which then removes that timeout from the list of timeouts for the given easy handle.</p>
</section>
<section id="internals__timeouts__md-_-_-expired-timeouts" class="level2" data-number="295.3">
<h2 data-number="295.3">Expired timeouts</h2>
<p>Expiration of a timeout means that the application knows that it needs to call libcurl again. When the <em>socket_action</em> API is used, it even knows to call libcurl again for a specific given easy handle for which the timeout has expired.</p>
<p>There is no other special action or activity happening when a timeout expires than that the perform function is called. Each state or internal function needs to know what times or states to check for and act accordingly when called (again).</p>
<p><span id="internals__windows-vs-unix__md"></span></p>
</section>
</section>
</body>
</html>
