<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch056.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="cmdline__urls__scheme__md-_-_-scheme" class="level1" data-number="55">
<h1 data-number="55">Scheme</h1>
<p>URLs start with the “scheme”, which is the official name for the <code>http://</code> part. That tells which protocol the URL uses. The scheme must be a known one that this version of curl supports or it shows an error message and stops. Additionally, the scheme must neither start with nor contain any whitespace.</p>
<section id="cmdline__urls__scheme__md-_-_-the-scheme-separator" class="level2" data-number="55.1">
<h2 data-number="55.1">The scheme separator</h2>
<p>The scheme identifier is separated from the rest of the URL by the <code>://</code> sequence. That is a colon and two forward slashes. There exists URL formats with only one slash, but curl does not support any of them. There are two additional notes to be aware of, about the number of slashes:</p>
<p>curl allows some illegal syntax and tries to correct it internally; so it also understands and accepts URLs with one or three slashes, even though they are in fact not properly formed URLs. curl does this because the browsers started this practice so it has led to such URLs being used in the wild every now and then.</p>
<p><code>file://</code> URLs are written as <code>file://&lt;hostname&gt;/&lt;path&gt;</code> but the only hostnames that are okay to use are <code>localhost</code>, <code>127.0.0.1</code> or a blank (nothing at all):</p>
<pre><code>file://localhost/path/to/file
file://127.0.0.1/path/to/file
file:///path/to/file</code></pre>
<p>Inserting any other hostname in there makes recent versions of curl return an error.</p>
<p>Pay special attention to the third example above (<code>file:///path/to/file</code>). That is <em>three</em> slashes before the path. That is again an area with common mistakes and where browsers allow users to use the wrong syntax so as a special exception, curl on Windows also allows this incorrect format:</p>
<pre><code>file://X:/path/to/file</code></pre>
<p>… where X is a windows-style drive letter.</p>
</section>
<section id="cmdline__urls__scheme__md-_-_-without-scheme" class="level2" data-number="55.2">
<h2 data-number="55.2">Without scheme</h2>
<p>As a convenience, curl also allows users to leave out the scheme part from URLs. Then it guesses which protocol to use based on the first part of the hostname. That guessing is basic, as it just checks if the first part of the hostname matches one of a set of protocols, and assumes you meant to use that protocol. This heuristic is based on the fact that servers traditionally used to be named like that. The protocols that are detected this way are FTP, DICT, LDAP, IMAP, SMTP and POP3. Any other hostname in a scheme-less URL makes curl default to HTTP.</p>
<p>For example, this gets a file from an FTP site:</p>
<pre><code>curl ftp.funet.fi/README</code></pre>
<p>While this gets data from an HTTP server:</p>
<pre><code>curl example.com</code></pre>
<p>You can modify the default protocol to something other than HTTP with the <code>--proto-default</code> option.</p>
</section>
<section id="cmdline__urls__scheme__md-_-_-supported-schemes" class="level2" data-number="55.3">
<h2 data-number="55.3">Supported schemes</h2>
<p>curl supports or can be made to support (if built so) the following transfer schemes and protocols:</p>
<p>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP, WS and WSS</p>
<p><span id="cmdline__urls__auth__md"></span></p>
</section>
</section>
</body>
</html>
