- en: Internet protocols#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html](https://4ed.computer-networking.info/syllabus/default/hosts/network-host.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The main objective of the network layer is to allow hosts, connected to different
    networks, to exchange information through intermediate systems called [router](../glossary.html#term-router).
    The unit of information in the network layer is called a [packet](../glossary.html#term-packet).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/666a41088f52b54a3b4670a0295154bb.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 106 The network layer in the reference model
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before explaining the network layer in detail, it is useful to begin by analyzing
    the service provided by the datalink layer. There are many variants of the datalink
    layer. Some provide a connection-oriented service while others provide a connectionless
    service. In this section, we focus on connectionless datalink layer services as
    they are the most widely used. Using a connection-oriented datalink layer causes
    some problems that are beyond the scope of this chapter. See [**RFC 3819**](https://datatracker.ietf.org/doc/html/rfc3819.html)
    for a discussion on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/e94f023d5f58d59588d996bb0d388d15.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 107 The point-to-point datalink layer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are three main types of datalink layers. The simplest datalink layer is
    when there are only two communicating systems that are directly connected through
    the physical layer. Such a datalink layer is used when there is a point-to-point
    link between the two communicating systems. The two systems can be hosts or routers.
    PPP, defined in [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html),
    is an example of such a point-to-point datalink layer. Datalink layers exchange
    frames and a datalink [frame](../glossary.html#term-frame) sent by a datalink
    layer entity on the left is transmitted through the physical layer, so that it
    can reach the datalink layer entity on the right. Point-to-point datalink layers
    can either provide an unreliable service (frames can be corrupted or lost) or
    a reliable service (in this case, the datalink layer includes retransmission mechanisms
    similar to the ones used in the transport layer). The unreliable service is frequently
    used above physical layers (e.g. optical fiber, twisted pairs) having a low bit
    error ratio while reliability mechanisms are often used in wireless networks to
    recover locally from transmission errors.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of datalink layer is the one used in Local Area Networks (LAN).
    Conceptually, a LAN is a set of communicating devices such that any two devices
    can directly exchange frames through the datalink layer. Both hosts and routers
    can be connected to a LAN. Some LANs only connect a few devices, but there are
    LANs that can connect hundreds or even thousands of devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/simple-lan.png](../Images/a7152d7ccb5142638996cde819a282cb.png)](../_images/simple-lan.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 108 A local area network[#](#id30 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, we describe the organization and the operation of Local
    Area Networks. An important difference between the point-to-point datalink layers
    and the datalink layers used in LANs is that in a LAN, each communicating device
    is identified by a unique datalink layer address. This address is usually embedded
    in the hardware of the device and different types of LANs use different types
    of datalink layer addresses. Most LANs use 48-bits long addresses that are usually
    called MAC addresses. A communicating device attached to a LAN can send a datalink
    frame to any other communicating device that is attached to the same LAN. Most
    LANs also support special broadcast and multicast datalink layer addresses. A
    frame sent to the broadcast address of the LAN is delivered to all communicating
    devices that are attached to the LAN. The multicast addresses are used to identify
    groups of communicating devices. When a frame is sent towards a multicast datalink
    layer address, it is delivered by the LAN to all communicating devices that belong
    to the corresponding group.
  prefs: []
  type: TYPE_NORMAL
- en: The third type of datalink layers are used in Non-Broadcast Multi-Access (NBMA)
    networks. These networks are used to interconnect devices like a LAN. All devices
    attached to an NBMA network are identified by a unique datalink layer address.
    However, and this is the main difference between an NBMA network and a traditional
    LAN, the NBMA service only supports unicast. The datalink layer service provided
    by an NBMA network supports neither broadcast nor multicast.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately no datalink layer is able to send frames of unlimited size. Each
    datalink layer is characterized by a maximum frame size. There are more than a
    dozen different datalink layers and unfortunately most of them use a different
    maximum frame size. The network layer must cope with the heterogeneity of the
    datalink layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two different network layer protocols coexist on the Internet: IP version 4
    and IP version 6\. As explained earlier, these two protocols allow a host to send
    packets to any other host. Both protocols support variable-length packets. The
    most important difference between IPv4 and IPv6 is the size of the IP addresses.
    IPv4 uses addresses that are encoded as a 32 bits long (4 bytes) bit string. IPv6
    addresses are much longer. An IPv6 address is encoded as a 128 bits long (16 bytes)
    bit string.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we describe how hosts use these two protocols to send and receive
    packets. We do not discuss how IP addresses are allocated and how IP packets can
    be efficiently forwarded through the Internet. These parts of IPv4 and IPv6 are
    discussed in the second part of the book.
  prefs: []
  type: TYPE_NORMAL
- en: IP version 4[#](#ip-version-4 "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IP version 4 is the data plane protocol of the network layer in the TCP/IP
    protocol suite. The design of IP version 4 was based on the following assumptions
    :'
  prefs: []
  type: TYPE_NORMAL
- en: IP should provide an unreliable connectionless service (TCP provides reliability
    when required by the application)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP operates with the datagram transmission mode
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP addresses have a fixed size of 32 bits
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP must be usable above different types of datalink layers
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP hosts exchange variable length packets
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 addresses are encoded as a 32 bits field. IPv4 addresses are often represented
    in dotted-decimal format as a sequence of four integers separated by a dot. The
    first integer is the decimal representation of the most significant byte of the
    32 bits IPv4 address, … For example,
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3.4 corresponds to 00000001000000100000001100000100
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 127.0.0.1 corresponds to 01111111000000000000000000000001
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 255.255.255.255 corresponds to 11111111111111111111111111111111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: An IPv4 address is used to identify an interface on a router or a host. A router
    has thus as many IPv4 addresses as the number of interfaces that it has in the
    datalink layer. Most hosts have a single datalink layer interface and thus have
    a single IPv4 address. However, with the growth of wireless, more and more hosts
    have several datalink layer interfaces (e.g. an Ethernet interface and a WiFi
    interface). These hosts are said to be multihomed. A multihomed host with two
    interfaces has thus two IPv4 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Many Internet hosts are attached to [Local Area Networks](../glossary.html#term-Local-Area-Networks)
    (LANs) such as Wi-Fi or Ethernet networks. We will describe the operation of these
    networks in more details in the second part of the book, but at this stage, the
    important point to know about these LANs is that they provide a connectionless
    datalink layer service. On a LAN, each device is identified by a unique 48 bits
    long address that is called a [MAC address](../glossary.html#term-MAC-address)
    (MAC stands for [Medium Access Control](../glossary.html#term-Medium-Access-Control)
    that will be explained in details in the second part). To ensure the unicity of
    the MAC addresses, these addresses are usually hardwired directly on the network
    interface cards. Each vendor of network cards ensures that all the interfaces
    that it sells have a unique MAC address. The devices attached a LAN can exchanged
    frames easily. A [frame](../glossary.html#term-frame) is a sequence of bytes that
    starts with a fixed-length header followed by a payload and for some types of
    LANs a trailer. The frame header contains the MAC address of the source of the
    frame and the MAC address of the destination of the frame. The frame payload carries
    the information exchanged and the trailer can contain a CRC to detect transmission
    errors or other types of control information.
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/frame-ip.svg](../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 109 A datalink layer frame containing an IPv4 packet[#](#id31 "Link to
    this image")
  prefs: []
  type: TYPE_NORMAL
- en: When several hosts are attached to the same LAN, they can quickly exchange IP
    packets by placing these packets inside datalink layer frames. If host A knows
    the MAC address of host B, it can send an IP packet as the payload of a frame
    whose source MAC address is its own MAC address and destination MAC address is
    B’s MAC address. We will detail later how a host can automatically learn the MAC
    address of another host.
  prefs: []
  type: TYPE_NORMAL
- en: When a host is attached to a LAN, it can directly send packets to the other
    hosts attached to the same LAN. To reach remote hosts, it must first send its
    packets to a router, also attached to the LAN. The router will be able to forward
    the packet to other routers such that it reaches its final destination.
  prefs: []
  type: TYPE_NORMAL
- en: When a host attached to a LAN sends an IP packet, it needs to know whether the
    destination is attached to the same LAN or not. If the destination is attached
    to the same LAN, the host can simply place the packet inside a frame and us the
    datalink layer to deliver it directly to its final destination. Otherwise, the
    host must the datalink layer to send the packet inside a frame to the LAN router
    that will take care of the packet. IPv4 and IPv6 solve this problem by grouping
    IP addresses in subnets. An [IP subnet](../glossary.html#term-IP-subnet) is the
    set of all IP addresses that have the same prefix. It is represented as an IP
    address followed by n, the number of bits in the common prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high order bits of the
    address and the host identifier is encoded in the low order bits of the address.
    This is illustrated below with a 22 bits subnetwork identifier shown in blue and
    a 12 bits host identifier in red.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 110 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  prefs: []
  type: TYPE_NORMAL
- en: A subnet identifier or IPv4 prefix is usually [[1]](#fnetmask) represented as
    A.B.C.D/p where A.B.C.D is the network address obtained by concatenating the subnet
    identifier with a host identifier containing only 0 and p is the length of the
    subnet identifier in bits. The table below provides examples of IP subnets.
  prefs: []
  type: TYPE_NORMAL
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Class A, B, or C addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'Today’s IPv4 implementations use variable-length subnets defined in [**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html). With variable-length
    subnets, the subnet identifier can be any size, from 1 to 31 bits. Variable-length
    subnets allow the network operators to use a subnet that better matches the number
    of hosts that are placed inside the subnet. Before the publication of [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html),
    IPv4 address blocks were divided in classes of addresses. [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)
    defined three classes of IPv4 addresses depending on their high order bits:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Class A addresses are the addresses whose high order bit is set to zero. The
    high order byte of this address was the network identifier and the 24 low order
    bits the host identifier. They correspond to today’s `\8` subnets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class B addresses are the addresses whose two high order bits are set to one
    followed by zero. The next fourteen bits are the network identifier and the low
    order sixteen bits the host identifier. They correspond to today’s `/16` subnets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class C addresses are the addresses whose three high order bits are set to one
    followed by one and then zero. The next fourteen bits are the network identifier
    and the low order twenty four bits the host identifier. They correspond to today’s
    `/24` subnets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, address blocks were allocated based on the address class required.
    Large companies, network providers and some universities asked for a Class A addresses
    and obtained it. Many universities requested a Class B address. However, this
    allocation was inefficient as Class A address blocks are much larger than the
    needs of most enterprises while Class C are too small. [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)
    suppressed this inefficient allocation. Nowadays, the IPv4 addressing space is
    almost fully utilized, except some reserved blocks. The [IPv4 Address Report](https://ipv4.potaroo.net/)
    provides a detailed report on the evolution of the allocated IPv4 addressing space.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv4 addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in [**RFC 5735**](https://datatracker.ietf.org/doc/html/rfc5735.html).
    These include :'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 packets[#](#ipv4-packets "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IPv4 packet format was defined in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    It is shown in [Fig. 111](#fig-ipv4-header-detail). Apart from a few clarifications
    and some backward compatible changes, the IPv4 packet format did not change significantly
    since the publication of [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    All IPv4 packets use the 20 bytes header shown in figure [Fig. 111](#fig-ipv4-header-detail).
    Some IPv4 packets contain an optional header extension that is described later.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 111 The IP version 4 header[#](#id33 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'The main fields of the IPv4 header are :'
  prefs: []
  type: TYPE_NORMAL
- en: a 4 bits version that indicates the version of IP used to build the header.
    Using a version field in the header allows the network layer protocol to evolve.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 4 bits IP Header Length (IHL) that indicates the length of the IP header in
    32 bits words. This field allows IPv4 to use options if required, but as it is
    encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits DS field that is used for Quality of Service and whose usage is described
    later.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits Protocol field that indicates the transport layer protocol that must
    process the packet’s payload at the destination. Common values for this field
    [[2]](#fprotocolnumber) are 6 for TCP and 17 for UDP
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits length field that indicates the total length of the entire IPv4 packet
    (header and payload) in bytes. This implies that an IPv4 packet cannot be longer
    than 65535 bytes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits source address field that contains the IPv4 address of the source
    host
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits destination address field that contains the IPv4 address of the destination
    host
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits checksum that protects only the IPv4 header against transmission errors
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The other fields of the IPv4 header are used for specific purposes. The first
    is the 8 bits Time To Live (TTL) field. This field is used by IPv4 to avoid the
    risk of having an IPv4 packet caught in an infinite loop due to a transient or
    permanent error in routing tables [[3]](#fttl). We will discuss in part two why
    such problems can happen. The TTL field of the IPv4 header ensures that even if
    there are forwarding loops in the network, packets will not loop forever. Hosts
    send their IPv4 packets with a positive TTL (usually 64 or more [[4]](#finitialttl)).
    When a router receives an IPv4 packet, it first decrements the TTL by one. If
    the TTL becomes 0, the packet is discarded and a message is sent back to the packet’s
    source (see section [ICMP](#icmp)). Otherwise, the router performs a lookup in
    its forwarding table to forward the packet.
  prefs: []
  type: TYPE_NORMAL
- en: A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is
    used above many very different datalink layers. Each datalink layer has its own
    characteristics and as indicated earlier, each datalink layer is characterized
    by a maximum frame size. From IP’s point of view, a datalink layer interface is
    characterized by its Maximum Transmission Unit (MTU). The MTU of an interface
    is the largest IPv4 packet (including header) that it can send. The table below
    provides some common MTU sizes [[5]](#f6lowpan).
  prefs: []
  type: TYPE_NORMAL
- en: '| Datalink layer | MTU |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | 1500 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | 2272 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ATM (AAL5) | 9180 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 802.15.4 | 102 or 81 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Token Ring | 4464 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| FDDI | 4352 bytes |'
  prefs: []
  type: TYPE_TB
- en: Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink
    layer technologies that are used today are able to send a 64 KBytes IPv4 packet
    inside a frame. Consider a client attached to a Token Ring network that wishes
    to send packets to a server connected to an Ethernet network. The client could
    send a 4 KBytes packet that would need to be fragmented inside the network to
    reach the server.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these problems, IPv4 includes a packet fragmentation and reassembly
    mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if
    the packet is too long to be sent via the datalink layer. In IPv4, fragmentation
    is completely performed in the IP layer and a large IPv4 is fragmented into two
    or more IPv4 packets (called fragments). The IPv4 fragments of a large packet
    are normal IPv4 packets that are forwarded towards the destination of the large
    packet by intermediate routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPv4 fragmentation mechanism relies on four fields of the IPv4 header :
    Length, Identification, the flags and the Fragment Offset. The IPv4 header contains
    two flags : More fragments and Don’t Fragment (DF). When the DF flag is set, this
    indicates that the packet cannot be fragmented.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic operation of the IPv4 fragmentation is as follows. A large packet
    is fragmented into two or more fragments. The size of all fragments, except the
    last one, is equal to the Maximum Transmission Unit of the link used to forward
    the packet. Each IPv4 packet contains a 16 bits Identification field. When a packet
    is fragmented, the Identification of the large packet is copied in all fragments
    to allow the destination to reassemble the received fragments together. In each
    fragment, the Fragment Offset indicates, in units of 8 bytes, the position of
    the payload of the fragment in the payload of the original packet. The Length
    field in each fragment indicates the length of the payload of the fragment as
    in a normal IPv4 packet. Finally, the More fragments flag is set only in the last
    fragment of a large packet.
  prefs: []
  type: TYPE_NORMAL
- en: The following pseudo-code details the IPv4 fragmentation algorithm, assuming
    that the packet does not contain IP options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The fragments of an IPv4 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv4 packet is a fragment
    or not by checking the value of the More fragments flag and the Fragment Offset.
    If the Fragment Offset is set to 0 and the More fragments flag is reset, the received
    packet has not been fragmented. Otherwise, the packet has been fragmented and
    must be reassembled. The reassembly algorithm relies on the Identification field
    of the received fragments to associate a fragment with the corresponding packet
    being reassembled. Furthermore, the Fragment Offset field indicates the position
    of the fragment payload in the original non fragmented packet. Finally, the packet
    with the More fragments flag reset allows the destination to determine the total
    length of the original no fragmented packet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bound the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: The original IP specification, in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html),
    defined several types of options that can be added to the IP header. Each option
    is encoded using a type length value format. They are not widely used today. Additional
    details may be found in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  prefs: []
  type: TYPE_NORMAL
- en: '## ICMP version 4[#](#icmp-version-4 "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMP is defined in [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html).
    ICMP messages are carried as the payload of IP packets (the protocol value reserved
    for ICMP is 1). [Fig. 112](#fig-icmpv4-header) illustrates the IPv4 header. An
    ICMP message is composed of an 8 byte header and a variable length payload that
    usually contains the first bytes of the packet that triggered the transmission
    of the ICMP message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/icmpv4.png](../Images/c6f49e0d69bec409a194b8b0090a586c.png)](../_images/icmpv4.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 112 ICMP version 4 [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html)[#](#id34
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: In the ICMP header, the Type and Code fields indicate the type of problem that
    was detected by the sender of the ICMP message. The Checksum protects the entire
    ICMP message against transmission errors and the Data field contains additional
    information for some ICMP messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main types of ICMP messages are :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Destination unreachable : a Destination unreachable ICMP message is sent when
    a packet cannot be delivered to its destination due to routing problems. Different
    types of non reachability are distinguished :'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Network unreachable : this ICMP message is sent by a router that does not have
    a route for the subnet containing the destination address of the packet'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Host unreachable : this ICMP message is sent by a router that is attached to
    the subnet that contains the destination address of the packet, but this destination
    address cannot be reached at this time'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Protocol unreachable : this ICMP message is sent by a destination host that
    has received a packet, but does not support the transport protocol indicated in
    the packet’s Protocol field'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Port unreachable : this ICMP message is sent by a destination host that has
    received a packet destined to a port number, but no server process is bound to
    this port'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fragmentation needed : this ICMP message is sent by a router that receives
    a packet with the Don’t Fragment flag set that is larger than the MTU of the outgoing
    interface'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ping(8)* is often used by network operators to verify that a given IP address
    is reachable. Each host is supposed [[6]](#fpingproblems) to reply with an ICMP
    Echo reply message when its receives an ICMP Echo request message. A sample usage
    of *ping(8)* is shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Another very useful debugging tool is *traceroute(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the TTL exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose TTL is set to 1 it decrements the TTL and
    is forced to return to the sending host a TTL exceeded ICMP message containing
    the header and the first bytes of the discarded IP packet. To discover all routers
    on a network path, a simple solution is to first send a packet whose TTL is set
    to 1, then a packet whose TTL is set to 2, etc. A sample traceroute output is
    shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above *traceroute(8)* output shows a 17 hops path between a host at UCLouvain
    and one of the main IETF servers. For each hop, traceroute provides the IPv4 address
    of the router that sent the ICMP message and the measured round-trip-time between
    the source and this router. traceroute sends three probes with each TTL value.
    In some cases, such as at the tenth hop above, the ICMP messages may be received
    from different addresses. This is usually because different packets from the same
    source have followed different paths [[7]](#ftraceroutemore) in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Another important utilization of ICMP messages is to discover the maximum MTU
    that can be used to reach a destination without fragmentation. As explained earlier,
    when an IPv4 router receives a packet that is larger than the MTU of the outgoing
    link, it must fragment the packet. Unfortunately, fragmentation is a complex operation
    and routers cannot perform it at line rate [[KM1995]](../bibliography.html#km1995).
    Furthermore, when a TCP segment is transported in an IP packet that is fragmented
    in the network, the loss of a single fragment forces TCP to retransmit the entire
    segment (and thus all the fragments). If TCP was able to send only packets that
    do not require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  prefs: []
  type: TYPE_NORMAL
- en: ICMP, combined with the Don’t fragment (DF) IPv4 flag, is used by TCP implementations
    to discover the largest MTU size that is allowed to reach a destination host without
    causing network fragmentation. This is the Path MTU discovery mechanism defined
    in [**RFC 1191**](https://datatracker.ietf.org/doc/html/rfc1191.html). A TCP implementation
    that includes Path MTU discovery (most do) requests the IPv4 layer to send all
    segments inside IPv4 packets having the DF flag set. This prohibits intermediate
    routers from fragmenting these packets. If a router needs to forward a packet
    which cannot be fragmented over a link with a smaller MTU, it returns a Fragmentation
    needed ICMP message to the source, indicating the MTU of its outgoing link. This
    ICMP message contains in the MTU of the router’s outgoing link in its Data field.
    Upon reception of this ICMP message, the source TCP implementation adjusts its
    Maximum Segment Size (MSS) so that the packets containing the segments that it
    sends can be forwarded by this router without requiring fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Operation of IPv4 hosts[#](#operation-of-ipv4-hosts "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point of the description of IPv4, it is useful to have a detailed look
    at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest
    case is when a host needs to send a segment in an IPv4 packet. The host performs
    two operations. First, it must decide on which interface the packet will be sent.
    Second it must create the corresponding IP packet(s).
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the discussion in this section, we ignore the utilization of IPv4
    options. This is not a severe limitation as today IPv4 packets rarely contain
    options. Details about the processing of the IPv4 options may be found in the
    relevant RFCs, such as [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 host having \(n\) datalink layer interfaces manages \(n+1\) IPv4 addresses
    :'
  prefs: []
  type: TYPE_NORMAL
- en: the 127.0.0.1/32 IPv4 address assigned by convention to its loopback address
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: one A.B.C.D/p IPv4 address assigned to each of its \(n\) datalink layer interfaces
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a host maintains a routing table containing one entry for its loopback
    address and one entry for each subnet identifier assigned to its interfaces. Furthermore,
    the host usually uses one of its interfaces as the default interface when sending
    packets that are not addressed to a directly connected destination. This is represented
    by the default route : 0.0.0.0/0 that is associated to one interface.'
  prefs: []
  type: TYPE_NORMAL
- en: When a transport protocol running on the host requests the transmission of a
    segment, it usually provides the IPv4 destination address to the IPv4 layer in
    addition to the segment [[12]](#fiddf). The IPv4 implementation first performs
    a longest prefix match with the destination address in its routing table. The
    lookup returns the identification of the interface that must be used to send the
    packet. The host can then create the IPv4 packet containing the segment. The source
    IPv4 address of the packet is the IPv4 address of the host on the interface returned
    by the longest prefix match. The Protocol field of the packet is set to the identification
    of the local transport protocol which created the segment. The TTL field of the
    packet is set to the default TTL used by the host. The host must now choose the
    packet’s Identification. This Identification is important if the packet becomes
    fragmented in the network, as it ensures that the destination is able to reassemble
    the received fragments. Ideally, a sending host should never send a packet twice
    with the same Identification to the same destination host, in order to ensure
    that all fragments are correctly reassembled by the destination. Unfortunately,
    with a 16 bits Identification field and an expected MSL of 2 minutes, this implies
    that the maximum bandwidth to a given destination is limited to roughly 286 Mbps.
    With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps [**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) if fragmentation must
    be possible [[12]](#fiddf). This is very low and is another reason why hosts are
    highly encouraged to avoid fragmentation. If; despite all of this, the MTU of
    the outgoing interface is smaller than the packet’s length, the packet is fragmented.
    Finally, the packet’s checksum is computed before transmission.
  prefs: []
  type: TYPE_NORMAL
- en: When a host receives an IPv4 packet destined to itself, there are several operations
    that it must perform. First, it must check the packet’s checksum. If the checksum
    is incorrect, the packet is discarded. Then, it must check whether the packet
    has been fragmented. If yes, the packet is passed to the reassembly algorithm
    described earlier. Otherwise, the packet must be passed to the upper layer. This
    is done by looking at the Protocol field (6 for TCP, 17 for UDP). If the host
    does not implement the transport layer protocol corresponding to the received
    Protocol field, it sends a Protocol unreachable ICMP message to the sending host.
    If the received packet contains an ICMP message (Protocol field set to 1), the
    processing is more complex. An Echo-request ICMP message triggers the transmission
    of an ICMP Echo-reply message. The other types of ICMP messages indicate an error
    that was caused by a previously transmitted packet. These ICMP messages are usually
    forwarded to the transport protocol that sent the erroneous packet. This can be
    done by inspecting the contents of the ICMP message that includes the header and
    the first 64 bits of the erroneous packet. If the IP packet did not contain options,
    which is the case for most IPv4 packets, the transport protocol can find in the
    first 32 bits of the transport header the source and destination ports to determine
    the affected transport flow. This is important for Path MTU discovery for example.
  prefs: []
  type: TYPE_NORMAL
- en: IP version 6[#](#ip-version-6 "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the late 1980s and early 1990s the growth of the Internet was causing several
    operational problems on routers. Many of these routers had a single CPU and up
    to 1 MByte of RAM to store their operating system, packet buffers and routing
    tables. Given the rate of allocation of IPv4 prefixes to companies and universities
    willing to join the Internet, the routing tables where growing very quickly and
    some feared that all IPv4 prefixes would quickly be allocated. In 1987, a study
    cited in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html), estimated
    that there would be 100,000 networks in the near future. In August 1990, estimates
    indicated that the class B space would be exhausted by March 1994.
  prefs: []
  type: TYPE_NORMAL
- en: Two types of solution were developed to solve this problem. The first short
    term solution was the introduction of Classless Inter Domain Routing ([CIDR](../glossary.html#term-CIDR)).
    A second short term solution was the Network Address Translation ([NAT](../glossary.html#term-NAT))
    mechanism, defined in [**RFC 1631**](https://datatracker.ietf.org/doc/html/rfc1631.html).
    NAT allowed multiple hosts to share a single public IPv4 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in parallel with these short-term solutions, which have allowed the
    IPv4 Internet to continue to be usable until now, the Internet Engineering Task
    Force started working on developing a replacement for IPv4\. This work started
    with an open call for proposals, outlined in [**RFC 1550**](https://datatracker.ietf.org/doc/html/rfc1550.html).
    Several groups responded to this call with proposals for a next generation Internet
    Protocol (IPng) :'
  prefs: []
  type: TYPE_NORMAL
- en: TUBA proposed in [**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html)
    and [**RFC 1561**](https://datatracker.ietf.org/doc/html/rfc1561.html)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PIP proposed in [**RFC 1621**](https://datatracker.ietf.org/doc/html/rfc1621.html)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SIPP proposed in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The IETF decided to pursue the development of IPng based on the SIPP proposal.
    As IP version 5 was already used by the experimental ST-2 protocol defined in
    [**RFC 1819**](https://datatracker.ietf.org/doc/html/rfc1819.html), the successor
    of IP version 4 is IP version 6\. The initial IP version 6 defined in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)
    was designed based on the following assumptions :'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addresses are encoded as a 128 bits field
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The IPv6 header has a simple format that can easily be parsed by hardware devices
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A host should be able to configure its IPv6 address automatically
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Security must be part of IPv6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The IPng address size
  prefs: []
  type: TYPE_NORMAL
- en: When the work on IPng started, it was clear that 32 bits was too small to encode
    an IPng address and all proposals used longer addresses. However, there were many
    discussions about the most suitable address length. A first approach, proposed
    by SIPP in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html),
    was to use 64 bit addresses. A 64 bits address space was 4 billion times larger
    than the IPv4 address space and, furthermore, from an implementation perspective,
    64 bit CPUs were being considered and 64 bit addresses would naturally fit inside
    their registers. Another approach was to use an existing address format. This
    was the TUBA proposal ([**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html))
    that reuses the ISO CLNP 20 bytes addresses. The 20 bytes addresses provided room
    for growth, but using ISO CLNP was not favored by the IETF partially due to political
    reasons, despite the fact that mature CLNP implementations were already available.
    128 bits appeared to be a reasonable compromise at that time.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addressing architecture[#](#ipv6-addressing-architecture "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The experience of IPv4 revealed that the scalability of a network layer protocol
    heavily depends on its addressing architecture. The designers of IPv6 spent a
    lot of effort defining its addressing architecture [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html).
    All IPv6 addresses are 128 bits wide. This implies that there are \(340,282,366,920,938,463,463,374,607,431,768,211,456
    (3.4 \times 10^{38})\) different IPv6 addresses. As the surface of the Earth is
    about 510,072,000 \(km^2\), this implies that there are about \(6.67 \times 10^{23}\)
    IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only
    8 addresses per square kilometer, this is a significant improvement on paper.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Textual representation of IPv6 addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16 bits blocks containing only bits set to 0. For example,'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address
    is used to identify one datalink-layer interface on a host. If a host has several
    datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then
    it needs several IPv6 addresses. In general, an IPv6 unicast address is structured
    as shown in [Fig. 113](#fig-ipv6-addr-structure).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/334d256816526fa56f8d5037c79a8b94.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 113 Structure of IPv6 unicast addresses
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The IETF has reserved some IPv6 addresses for a special usage. The two most
    important ones are :'
  prefs: []
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` (`::1` in compact form) is the IPv6 loopback address. This
    is the address of a logical interface that is always up and running on IPv6 enabled
    hosts.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` (`::` in compact form) is the unspecified IPv6 address. This
    is the IPv6 address that a host can use as source address when trying to acquire
    an official address.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The last type of unicast IPv6 addresses are the Link Local Unicast addresses
    shown in [Fig. 114](#fig-ipv6-link-local). These addresses are part of the fe80::/10
    address block and are defined in [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html).
    Each host can compute its own link local address by concatenating the fe80::/64
    prefix with the 64 bits identifier of its interface. Link local addresses can
    be used when hosts that are attached to the same link (or local area network)
    need to exchange packets. They are used notably for address discovery and auto-configuration
    purposes. Their usage is restricted to each link and a router cannot forward a
    packet whose source or destination address is a link local address. Link local
    addresses have also been defined for IPv4 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    However, the IPv4 link local addresses are only used when a host cannot obtain
    a regular IPv4 address, e.g. on an isolated LAN.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/85809a63cecf02a8a699a08cbd775118.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 114 IPv6 link local address structure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All IPv6 hosts have several addresses
  prefs: []
  type: TYPE_NORMAL
- en: An important consequence of the IPv6 unicast addressing architecture and the
    utilization of link-local addresses is that each IPv6 host has several IPv6 addresses.
    This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses described above are unicast addresses. These addresses are used
    to identify (interfaces on) hosts and routers. They can appear as source and destination
    addresses in the IPv6 packets. When a host sends a packet towards a unicast address,
    this packet is delivered by the network to its final destination. There are situations,
    such as when delivering video or television signal to a large number of receivers,
    where it is useful to have a network that can efficiently deliver the same packet
    to a large number of receivers. This is the multicast service. A multicast service
    can be provided in a LAN. In this case, a multicast address identifies a set of
    receivers and each frame sent towards this address is delivered to all receivers
    in the group. Multicast can also be used in a network containing routers and hosts.
    In this case, a multicast address identifies also a group of receivers and the
    network delivers efficiently each multicast packet to all members of the group.
    Consider for example the network shown in [Fig. 115](#fig-ipv6-simple-network).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 115 A simple network with hosts and routers
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume that `B` and `D` are part of a multicast group. If `A` sends a multicast
    packet towards this group, then `R1` will replicate the packet to forward it to
    `R2` and `R3`. `R2` would forward the packet towards `B`. `R3` would forward the
    packet towards `R4` that would deliver it to `D`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)
    defines the structure of the IPv6 multicast addresses [[8]](#fmultiiana). This
    structure is depicted in [Fig. 116](#fig-ipv6-multicast-addr).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 116 IPv6 multicast address structure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The low order 112 bits of an IPv6 multicast address are the group’s identifier.
    The high order bits are used as a marker to distinguish multicast addresses from
    unicast addresses. Notably, the 4-bit Flags field indicates whether the address
    is temporary or permanent. Finally, the Scope field indicates the boundaries of
    the forwarding of packets destined to a particular address. A link-local scope
    indicates that a router should not forward a packet destined to such a multicast
    address. An organization local-scope indicates that a packet sent to such a multicast
    destination address should not leave the organization. Finally the global scope
    is intended for multicast groups spanning the global Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Among these addresses, some are well known. For example, all hosts automatically
    belong to the `ff02::1` multicast group while all routers automatically belong
    to the `ff02::2` multicast group. A detailed discussion of IPv6 multicast is outside
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '### IPv6 packet[#](#ipv6-packet "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 packet format was heavily inspired by the packet format proposed for
    the SIPP protocol in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html).
    The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 117](#fig-ipv6-header-detail).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 117 The IP version 6 header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the source and destination addresses, the IPv6 header contains the
    following fields :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version : a 4 bits field set to 6 and intended to allow IP to evolve in the
    future if needed'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Traffic class : this 8 bits field indicates the type of service expected by
    this packet and contains the `CE` and `ECT` flags that are used by Explicit Congestion
    Notification'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flow Label : this field was initially intended to be used to tag packets belonging
    to the same flow. A recent document, [**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)
    describes some possible usages of this field, but it is too early to tell whether
    it will be really used.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Payload Length : this is the size of the packet payload in bytes. As the length
    is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of
    payload.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next Header : this 8-bit field indicates the type [[9]](#fianaprotocol) of
    header that follows the IPv6 header. It can be a transport layer header (e.g.
    6 for TCP or 17 for UDP) or an IPv6 option.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hop Limit : this 8-bit field indicates the number of routers that can forward
    the packet. It is decremented by one by each router and prevents packets from
    looping forever inside the network.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting to note that there is no checksum inside the IPv6 header.
    This is mainly because all datalink layers and transport protocols include a checksum
    or a CRC to protect their frames/segments against transmission errors. Adding
    a checksum in the IPv6 header would have forced each router to recompute the checksum
    of all packets, with limited benefit in detecting errors. In practice, an IP checksum
    allows for catching errors that occur inside routers (e.g. due to memory corruption)
    before the packet reaches its destination. However, this benefit was found to
    be too small given the reliability of current memories and the cost of computing
    the checksum on each router [[10]](#fipv4checksum).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a host receives an IPv6 packet, it needs to determine which transport
    protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is
    the first role of the Next header field. The [IANA](https://www.iana.org) which
    manages the allocation of Internet resources and protocol parameters, maintains
    an official list of transport protocols [[9]](#fianaprotocol). The following protocol
    numbers are reserved :'
  prefs: []
  type: TYPE_NORMAL
- en: '`TCP` uses Next Header number `6`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UDP` uses Next Header number `17`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SCTP` uses Next Header number `132`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an IPv6 packet that contains an TCP segment would appear as shown
    in [Fig. 118](#fig-ipv6-tcp).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 118 An IPv6 packet containing an TCP segment[#](#id40 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: However, the Next header has broader usages than simply indicating the transport
    protocol which is responsible for the packet payload. An IPv6 packet can contain
    a chain of headers and the last one indicates the transport protocol that is responsible
    for the packet payload. Supporting a chain of headers is a clever design from
    an extensibility viewpoint. As we will see, this chain of headers has several
    usages.
  prefs: []
  type: TYPE_NORMAL
- en: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) defines
    several types of IPv6 extension headers that could be added to an IPv6 packet
    :'
  prefs: []
  type: TYPE_NORMAL
- en: Hop-by-Hop Options header. This option is processed by routers and hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Destination Options header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Routing header. This option is processed by some nodes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragment header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Authentication header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulating Security Payload. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two headers are used to add security above IPv6 and implement IPSec.
    They are described in [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    and [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) and are
    outside the scope of this document.
  prefs: []
  type: TYPE_NORMAL
- en: The Hop-by-Hop Options header was designed to make IPv6 easily extensible. In
    theory, this option could be used to define new fields that were not foreseen
    when IPv6 was designed. It is intended to be processed by both routers and hosts.
    Deploying an extension to a network protocol can be difficult in practice since
    some nodes already support the extensions while others still use the old version
    and do not understand the extension. To deal with this issue, the IPv6 designers
    opted for a Type-Length-Value encoding of these IPv6 options. The Hop-by-Hop Options
    header is encoded as show in [Fig. 119](#fig-ipv6-hbhoption).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 119 The IPv6 Hop-by-Hop Options header[#](#id41 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'In this optional header, the Next Header field is used to support the chain
    of headers. It indicates the type of the next header in the chain. IPv6 headers
    have different lengths. The Hdr Ext Len field indicates the total length of the
    option header in bytes. The Opt. Type field indicates the type of option. These
    types are encoded such that their high order bits specify how the header needs
    to be handled by nodes that do not recognize it. The following values are defined
    for the two high order bits :'
  prefs: []
  type: TYPE_NORMAL
- en: '`00` : if a node does not recognize this header, it can be safely skipped and
    the processing continues with the subsequent header'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`01` : if a node does not recognize this header, the packet must be discarded'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`10` (resp. `11`) : if a node does not recognize this header, it must return
    a control packet (ICMP, see later) back to the source (resp. except if the destination
    was a multicast address)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: This encoding allows the designers of protocol extensions to specify whether
    the option must be supported by all nodes on a path or not. Still, deploying such
    an extension can be difficult in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Two hop-by-hop options have been defined. [**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    specifies the jumbogram that enables IPv6 to support packets containing a payload
    larger than 65535 bytes. These jumbo packets have their payload length set to
    0 and the jumbogram option contains the packet length as a 32 bits field. Such
    packets can only be sent from a source to a destination if all the routers on
    the path support this option. However, as of this writing it does not seem that
    the jumbogram option has been implemented. The router alert option defined in
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) is the second
    example of a hop-by-hop option. The packets that contain this option should be
    processed in a special way by intermediate routers. This option is used for IP
    packets that carry Resource Reservation Protocol (RSVP) messages, but this is
    outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Destinations Option header uses the same format as the Hop-by-Hop Options
    header. It has some usages, e.g. to support mobile nodes [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html),
    but these are outside the scope of this document.
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Options header is more important. An important problem in the network
    layer is the ability to handle heterogeneous datalink layers. Most datalink layer
    technologies can only transmit and receive frames that are shorter than a given
    maximum frame size. Unfortunately, all datalink layer technologies use different
    maximum frames sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Each datalink layer has its own characteristics and as indicated earlier, each
    datalink layer is characterized by a maximum frame size. From IP’s point of view,
    a datalink layer interface is characterized by its Maximum Transmission Unit (MTU).
    The MTU of an interface is the largest packet (including header) that it can send.
    The table below provides some common MTU sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '| Datalink layer | MTU |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | 1500 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | 2272 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ATM (AAL5) | 9180 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 802.15.4 | 102 or 81 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Token Ring | 4464 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| FDDI | 4352 bytes |'
  prefs: []
  type: TYPE_TB
- en: Although IPv6 can send 64 KBytes long packets, few datalink layer technologies
    that are used today are able to send a 64 KBytes packet inside a frame. Furthermore,
    as illustrated in [Fig. 120](#fig-ipv6-need-fragmentation), another problem is
    that a host may send a packet that would be too large for one of the datalink
    layers used by the intermediate routers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/1baf064048236d27ceffa188e5e44d59.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 120 The need for fragmentation and reassembly
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve these problems, IPv6 includes a packet fragmentation and reassembly
    mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate
    routers. However, experience with IPv4 has shown that fragmenting packets in routers
    was costly [[KM1995]](../bibliography.html#km1995). For this reason, the developers
    of IPv6 have decided that routers would not fragment packets anymore. In IPv6,
    fragmentation is only performed by the source host. If a source has to send a
    packet which is larger than the MTU of the outgoing interface, the packet needs
    to be fragmented before being transmitted. In IPv6, each packet fragment is an
    IPv6 packet that includes the Fragmentation header shown in [Fig. 121](#fig-ipv6-fragment-header).
    This header is included by the source in each packet fragment. The receiver uses
    them to reassemble the received fragments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 121 IPv6 fragmentation header[#](#id43 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: If a router receives a packet that is too long to be forwarded, the packet is
    dropped and the router returns an ICMPv6 message to inform the sender of the problem.
    The sender can then either fragment the packet or perform Path MTU discovery.
    In IPv6, packet fragmentation is performed only by the source by using IPv6 options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In IPv6, fragmentation is performed exclusively by the source host and relies
    on the fragmentation header. This 64 bits header is composed of six fields :'
  prefs: []
  type: TYPE_NORMAL
- en: a Next Header field that indicates the type of the header that follows the fragmentation
    header
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: two Reserved fields set to 0.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Fragment Offset is a 13-bit unsigned integer that contains the offset, in
    8 bytes units, of the data following this header, relative to the start of the
    original packet.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the More flag, which is set to 0 in the last fragment of a packet and to 1 in
    all other fragments.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the 32-bit Identification field indicates to which original packet a fragment
    belongs. When a host sends fragmented packets, it should ensure that it does not
    reuse the same identification field for packets sent to the same destination during
    a period of MSL seconds. This is easier with the 32 bits identification used in
    the IPv6 fragmentation header, than with the 16 bits identification field of the
    IPv4 header.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Some IPv6 implementations send the fragments of a packet in increasing fragment
    offset order, starting from the first fragment. Others send the fragments in reverse
    order, starting from the last fragment. The latter solution can be advantageous
    for the host that needs to reassemble the fragments, as it can easily allocate
    the buffer required to reassemble all fragments of the packet upon reception of
    the last fragment. When a host receives the first fragment of an IPv6 packet,
    it cannot know a priori the length of the entire IPv6 packet.
  prefs: []
  type: TYPE_NORMAL
- en: '[Fig. 122](#fig-ipv6-fragmentation-example) provides an example of a fragmented
    IPv6 packet containing a UDP segment. The Next Header type reserved for the IPv6
    fragmentation option is 44.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 122 IPv6 fragmentation example[#](#id44 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: The following pseudo-code details the IPv6 fragmentation, assuming that the
    packet does not contain options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the above pseudocode, we maintain a single 32 bits counter that is incremented
    for each packet that needs to be fragmented. Other implementations to compute
    the packet identification are possible. [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    only requires that two fragmented packets that are sent within the MSL between
    the same pair of hosts have different identifications.
  prefs: []
  type: TYPE_NORMAL
- en: The fragments of an IPv6 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv6 packet is a fragment
    or not by checking whether it contains a fragment header. If so, all fragments
    with the some identification must be reassembled together. The reassembly algorithm
    relies on the Identification field of the received fragments to associate a fragment
    with the corresponding packet being reassembled. Furthermore, the Fragment Offset
    field indicates the position of the fragment payload in the original non-fragmented
    packet. Finally, the packet with the M flag reset allows the destination to determine
    the total length of the original non-fragmented packet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bind the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Header compression on low bandwidth links
  prefs: []
  type: TYPE_NORMAL
- en: Given the size of the IPv6 header, it can cause huge overhead on low bandwidth
    links, especially when small packets are exchanged such as for Voice over IP applications.
    In such environments, several techniques can be used to reduce the overhead. A
    first solution is to use data compression in the datalink layer to compress all
    the information exchanged [[Thomborson1992]](../bibliography.html#thomborson1992).
    These techniques are similar to the data compression algorithms used in tools
    such as *compress(1)* or *gzip(1)* [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html).
    They compress streams of bits without taking advantage of the fact that these
    streams contain IP packets with a known structure. A second solution is to compress
    the IP and TCP header. These header compression techniques, such as the one defined
    in [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html) take advantage
    of the redundancy found in successive packets from the same flow to significantly
    reduce the size of the protocol headers. Another solution is to define a compressed
    encoding of the IPv6 header that matches the capabilities of the underlying datalink
    layer [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html).
  prefs: []
  type: TYPE_NORMAL
- en: The last type of IPv6 header extension is the Routing header. The `type 0` routing
    header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    is an example of an IPv6 option that must be processed by some routers. This option
    is encoded as shown in [Fig. 123](#fig-ipv6-rh0).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 123 The Type 0 routing header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'The type 0 routing option was intended to allow a host to indicate a loose
    source route that should be followed by a packet by specifying the addresses of
    some of the routers that must forward this packet. Unfortunately, further work
    with this routing header, including an entertaining demonstration with [scapy](https://www.secdev.org/projects/scapy/)
    [[BE2007]](../bibliography.html#be2007) , revealed severe security problems with
    this routing header. For this reason, loose source routing with the type 0 routing
    header has been removed from the IPv6 specification [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html).  ###
    ICMP version 6[#](#icmp-version-6 "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMPv6 is defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html).
    It is used both to report problems that occurred while processing an IPv6 packet,
    but also to distribute addresses.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 messages are carried inside IPv6 packets (the Next Header field for ICMPv6
    is `58`). Each ICMP message contains a 32 bits header with an 8 bits type field,
    a code field and a 16 bits checksum computed over the entire ICMPv6 message. The
    message body contains a copy of the IPv6 packet in error. The ICMPv6 header is
    shown in [Fig. 124](#fig-icmpv6-header).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 124 ICMP version 6 packet format[#](#id46 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'ICMPv6 specifies two classes of messages : error messages that indicate a problem
    in handling a packet and informational messages. Four types of error messages
    are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`Destination Unreachable. Such an ICMPv6 message is sent when the destination
    address of a packet is unreachable. The code field of the ICMP header contains
    additional information about the type of unreachability. The following codes are
    specified in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` : No route to destination. This indicates that the router that sent the
    ICMPv6 message did not have a route towards the packet’s destination'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` : Communication with destination administratively prohibited. This indicates
    that a firewall has refused to forward the packet towards its final destination.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Beyond scope of source address. This message can be sent if the source
    is using link-local addresses to reach a global unicast address outside its subnet.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Address unreachable. This message indicates that the packet reached the
    subnet of the destination, but the host that owns this destination address cannot
    be reached.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Port unreachable. This message indicates that the IPv6 packet was received
    by the destination, but there was no application listening to the specified port.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Packet Too Big. The router that was to send the ICMPv6 message received
    an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message
    contains the MTU of this link in bytes. This allows the sending host to implement
    Path MTU discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Time Exceeded. This error message can be sent either by a router or by
    a host. A router would set code to 0 to report the reception of a packet whose
    Hop Limit reached 0. A host would set code to 1 to report that it was unable to
    reassemble received IPv6 fragments.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Parameter Problem. This ICMPv6 message is used to report either the reception
    of an IPv6 packet with an erroneous header field (code 0) or an unknown Next Header
    or IP option (codes 1 and 2). In this case, the message body contains the erroneous
    IPv6 packet and the first 32 bits of the message body contain a pointer to the
    error.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The Destination Unreachable ICMP error message is returned when a packet cannot
    be forwarded to its final destination. The first four ICMPv6 error messages (type
    `1`, codes `0-3`) are generated by routers while hosts may return code `4` when
    there is no application bound to the corresponding port number.
  prefs: []
  type: TYPE_NORMAL
- en: The Packet Too Big ICMP messages enable the source host to discover the MTU
    size that it can safely use to reach a given destination. To understand its operation,
    consider the (academic) scenario shown in [Fig. 125](#fig-ipv6-mtu-discovery).
    In this figure, the labels on each link represent the maximum packet size supported
    by this link.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 125 Example for IPv6 MTU discovery
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `A` sends a 1500 bytes packet, `R1` will return an ICMPv6 error message indicating
    a maximum packet length of 1400 bytes. `A` would then fragment the packet before
    retransmitting it. The small fragment would go through, but the large fragment
    will be refused by `R2` that would return an ICMPv6 error message. `A` can fragment
    again the packet and send it to the final destination as two fragments.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, an IPv6 implementation does not store the transmitted packets to
    be able to retransmit them if needed. However, since TCP (and SCTP) buffer the
    segments that they transmit, a similar approach can be used in transport protocols
    to detect the largest MTU on a path towards a given destination. This technique
    is called PathMTU Discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html).
  prefs: []
  type: TYPE_NORMAL
- en: When a TCP segment is transported in an IP packet that is fragmented in the
    network, the loss of a single fragment forces TCP to retransmit the entire segment
    (and thus all the fragments). If TCP was able to send only packets that do not
    require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 is used by TCP implementations to discover the largest MTU size that
    is allowed to reach a destination host without causing network fragmentation.
    A TCP implementation parses the Packets Too Big ICMP messages that it receives.
    These ICMP messages contain the MTU of the router’s outgoing link in their Data
    field. Upon reception of such an ICMP message, the source TCP implementation adjusts
    its Maximum Segment Size (MSS) so that the packets containing the segments that
    it sends can be forwarded by this router without requiring fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two types of informational ICMPv6 messages are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    : echo request and echo reply, which are used to test the reachability of a destination
    by using *ping6(8)*. Each host is supposed to reply with an ICMP Echo reply message
    when it receives an ICMP Echo request message. A sample usage of *ping6(8)* is
    shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another very useful debugging tool is *traceroute6(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the Time exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose Hop Limit is set to `1` it is forced to return
    to the sending host a Time exceeded ICMP message containing the header and the
    first bytes of the discarded packet. To discover all routers on a network path,
    a simple solution is to first send a packet whose Hop Limit is set to 1, then
    a packet whose Hop Limit is set to 2, etc. A sample traceroute6 output is shown
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Rate limitation of ICMP messages
  prefs: []
  type: TYPE_NORMAL
- en: High-end hardware based routers use special purpose chips on their interfaces
    to forward IPv6 packets at line rate. These chips are optimized to process correct
    IP packets. They are not able to create ICMP messages at line rate. When such
    a chip receives an IP packet that triggers an ICMP message, it interrupts the
    main CPU of the router and the software running on this CPU processes the packet.
    This CPU is much slower than the hardware acceleration found on the interfaces
    [[Gill2004]](../bibliography.html#gill2004). It would be overloaded if it had
    to process IP packets at line rate and generate one ICMP message for each received
    packet. To protect this CPU, high-end routers limit the rate at which the hardware
    can interrupt the main CPU and thus the rate at which ICMP messages can be generated.
    This implies that not all erroneous IP packets cause the transmission of an ICMP
    message. The risk of overloading the main CPU of the router is also the reason
    why using hop-by-hop IPv6 options, including the router alert option is discouraged
    [[#falert]_](#id49).
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: IP version 4[#](#ip-version-4 "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IP version 4 is the data plane protocol of the network layer in the TCP/IP
    protocol suite. The design of IP version 4 was based on the following assumptions
    :'
  prefs: []
  type: TYPE_NORMAL
- en: IP should provide an unreliable connectionless service (TCP provides reliability
    when required by the application)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP operates with the datagram transmission mode
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP addresses have a fixed size of 32 bits
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP must be usable above different types of datalink layers
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: IP hosts exchange variable length packets
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 addresses are encoded as a 32 bits field. IPv4 addresses are often represented
    in dotted-decimal format as a sequence of four integers separated by a dot. The
    first integer is the decimal representation of the most significant byte of the
    32 bits IPv4 address, … For example,
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3.4 corresponds to 00000001000000100000001100000100
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 127.0.0.1 corresponds to 01111111000000000000000000000001
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 255.255.255.255 corresponds to 11111111111111111111111111111111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: An IPv4 address is used to identify an interface on a router or a host. A router
    has thus as many IPv4 addresses as the number of interfaces that it has in the
    datalink layer. Most hosts have a single datalink layer interface and thus have
    a single IPv4 address. However, with the growth of wireless, more and more hosts
    have several datalink layer interfaces (e.g. an Ethernet interface and a WiFi
    interface). These hosts are said to be multihomed. A multihomed host with two
    interfaces has thus two IPv4 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Many Internet hosts are attached to [Local Area Networks](../glossary.html#term-Local-Area-Networks)
    (LANs) such as Wi-Fi or Ethernet networks. We will describe the operation of these
    networks in more details in the second part of the book, but at this stage, the
    important point to know about these LANs is that they provide a connectionless
    datalink layer service. On a LAN, each device is identified by a unique 48 bits
    long address that is called a [MAC address](../glossary.html#term-MAC-address)
    (MAC stands for [Medium Access Control](../glossary.html#term-Medium-Access-Control)
    that will be explained in details in the second part). To ensure the unicity of
    the MAC addresses, these addresses are usually hardwired directly on the network
    interface cards. Each vendor of network cards ensures that all the interfaces
    that it sells have a unique MAC address. The devices attached a LAN can exchanged
    frames easily. A [frame](../glossary.html#term-frame) is a sequence of bytes that
    starts with a fixed-length header followed by a payload and for some types of
    LANs a trailer. The frame header contains the MAC address of the source of the
    frame and the MAC address of the destination of the frame. The frame payload carries
    the information exchanged and the trailer can contain a CRC to detect transmission
    errors or other types of control information.
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/frame-ip.svg](../Images/0aa00ff1beaaa1688c62ca1888c0cfe8.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 109 A datalink layer frame containing an IPv4 packet[#](#id31 "Link to
    this image")
  prefs: []
  type: TYPE_NORMAL
- en: When several hosts are attached to the same LAN, they can quickly exchange IP
    packets by placing these packets inside datalink layer frames. If host A knows
    the MAC address of host B, it can send an IP packet as the payload of a frame
    whose source MAC address is its own MAC address and destination MAC address is
    B’s MAC address. We will detail later how a host can automatically learn the MAC
    address of another host.
  prefs: []
  type: TYPE_NORMAL
- en: When a host is attached to a LAN, it can directly send packets to the other
    hosts attached to the same LAN. To reach remote hosts, it must first send its
    packets to a router, also attached to the LAN. The router will be able to forward
    the packet to other routers such that it reaches its final destination.
  prefs: []
  type: TYPE_NORMAL
- en: When a host attached to a LAN sends an IP packet, it needs to know whether the
    destination is attached to the same LAN or not. If the destination is attached
    to the same LAN, the host can simply place the packet inside a frame and us the
    datalink layer to deliver it directly to its final destination. Otherwise, the
    host must the datalink layer to send the packet inside a frame to the LAN router
    that will take care of the packet. IPv4 and IPv6 solve this problem by grouping
    IP addresses in subnets. An [IP subnet](../glossary.html#term-IP-subnet) is the
    set of all IP addresses that have the same prefix. It is represented as an IP
    address followed by n, the number of bits in the common prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high order bits of the
    address and the host identifier is encoded in the low order bits of the address.
    This is illustrated below with a 22 bits subnetwork identifier shown in blue and
    a 12 bits host identifier in red.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 110 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  prefs: []
  type: TYPE_NORMAL
- en: A subnet identifier or IPv4 prefix is usually [[1]](#fnetmask) represented as
    A.B.C.D/p where A.B.C.D is the network address obtained by concatenating the subnet
    identifier with a host identifier containing only 0 and p is the length of the
    subnet identifier in bits. The table below provides examples of IP subnets.
  prefs: []
  type: TYPE_NORMAL
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Class A, B, or C addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'Today’s IPv4 implementations use variable-length subnets defined in [**RFC
    1519**](https://datatracker.ietf.org/doc/html/rfc1519.html). With variable-length
    subnets, the subnet identifier can be any size, from 1 to 31 bits. Variable-length
    subnets allow the network operators to use a subnet that better matches the number
    of hosts that are placed inside the subnet. Before the publication of [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html),
    IPv4 address blocks were divided in classes of addresses. [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)
    defined three classes of IPv4 addresses depending on their high order bits:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Class A addresses are the addresses whose high order bit is set to zero. The
    high order byte of this address was the network identifier and the 24 low order
    bits the host identifier. They correspond to today’s `\8` subnets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class B addresses are the addresses whose two high order bits are set to one
    followed by zero. The next fourteen bits are the network identifier and the low
    order sixteen bits the host identifier. They correspond to today’s `/16` subnets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Class C addresses are the addresses whose three high order bits are set to one
    followed by one and then zero. The next fourteen bits are the network identifier
    and the low order twenty four bits the host identifier. They correspond to today’s
    `/24` subnets.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, address blocks were allocated based on the address class required.
    Large companies, network providers and some universities asked for a Class A addresses
    and obtained it. Many universities requested a Class B address. However, this
    allocation was inefficient as Class A address blocks are much larger than the
    needs of most enterprises while Class C are too small. [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)
    suppressed this inefficient allocation. Nowadays, the IPv4 addressing space is
    almost fully utilized, except some reserved blocks. The [IPv4 Address Report](https://ipv4.potaroo.net/)
    provides a detailed report on the evolution of the allocated IPv4 addressing space.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv4 addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in [**RFC 5735**](https://datatracker.ietf.org/doc/html/rfc5735.html).
    These include :'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 packets[#](#ipv4-packets "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IPv4 packet format was defined in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    It is shown in [Fig. 111](#fig-ipv4-header-detail). Apart from a few clarifications
    and some backward compatible changes, the IPv4 packet format did not change significantly
    since the publication of [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    All IPv4 packets use the 20 bytes header shown in figure [Fig. 111](#fig-ipv4-header-detail).
    Some IPv4 packets contain an optional header extension that is described later.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 111 The IP version 4 header[#](#id33 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'The main fields of the IPv4 header are :'
  prefs: []
  type: TYPE_NORMAL
- en: a 4 bits version that indicates the version of IP used to build the header.
    Using a version field in the header allows the network layer protocol to evolve.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 4 bits IP Header Length (IHL) that indicates the length of the IP header in
    32 bits words. This field allows IPv4 to use options if required, but as it is
    encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits DS field that is used for Quality of Service and whose usage is described
    later.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits Protocol field that indicates the transport layer protocol that must
    process the packet’s payload at the destination. Common values for this field
    [[2]](#fprotocolnumber) are 6 for TCP and 17 for UDP
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits length field that indicates the total length of the entire IPv4 packet
    (header and payload) in bytes. This implies that an IPv4 packet cannot be longer
    than 65535 bytes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits source address field that contains the IPv4 address of the source
    host
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits destination address field that contains the IPv4 address of the destination
    host
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits checksum that protects only the IPv4 header against transmission errors
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The other fields of the IPv4 header are used for specific purposes. The first
    is the 8 bits Time To Live (TTL) field. This field is used by IPv4 to avoid the
    risk of having an IPv4 packet caught in an infinite loop due to a transient or
    permanent error in routing tables [[3]](#fttl). We will discuss in part two why
    such problems can happen. The TTL field of the IPv4 header ensures that even if
    there are forwarding loops in the network, packets will not loop forever. Hosts
    send their IPv4 packets with a positive TTL (usually 64 or more [[4]](#finitialttl)).
    When a router receives an IPv4 packet, it first decrements the TTL by one. If
    the TTL becomes 0, the packet is discarded and a message is sent back to the packet’s
    source (see section [ICMP](#icmp)). Otherwise, the router performs a lookup in
    its forwarding table to forward the packet.
  prefs: []
  type: TYPE_NORMAL
- en: A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is
    used above many very different datalink layers. Each datalink layer has its own
    characteristics and as indicated earlier, each datalink layer is characterized
    by a maximum frame size. From IP’s point of view, a datalink layer interface is
    characterized by its Maximum Transmission Unit (MTU). The MTU of an interface
    is the largest IPv4 packet (including header) that it can send. The table below
    provides some common MTU sizes [[5]](#f6lowpan).
  prefs: []
  type: TYPE_NORMAL
- en: '| Datalink layer | MTU |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | 1500 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | 2272 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ATM (AAL5) | 9180 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 802.15.4 | 102 or 81 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Token Ring | 4464 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| FDDI | 4352 bytes |'
  prefs: []
  type: TYPE_TB
- en: Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink
    layer technologies that are used today are able to send a 64 KBytes IPv4 packet
    inside a frame. Consider a client attached to a Token Ring network that wishes
    to send packets to a server connected to an Ethernet network. The client could
    send a 4 KBytes packet that would need to be fragmented inside the network to
    reach the server.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these problems, IPv4 includes a packet fragmentation and reassembly
    mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if
    the packet is too long to be sent via the datalink layer. In IPv4, fragmentation
    is completely performed in the IP layer and a large IPv4 is fragmented into two
    or more IPv4 packets (called fragments). The IPv4 fragments of a large packet
    are normal IPv4 packets that are forwarded towards the destination of the large
    packet by intermediate routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPv4 fragmentation mechanism relies on four fields of the IPv4 header :
    Length, Identification, the flags and the Fragment Offset. The IPv4 header contains
    two flags : More fragments and Don’t Fragment (DF). When the DF flag is set, this
    indicates that the packet cannot be fragmented.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic operation of the IPv4 fragmentation is as follows. A large packet
    is fragmented into two or more fragments. The size of all fragments, except the
    last one, is equal to the Maximum Transmission Unit of the link used to forward
    the packet. Each IPv4 packet contains a 16 bits Identification field. When a packet
    is fragmented, the Identification of the large packet is copied in all fragments
    to allow the destination to reassemble the received fragments together. In each
    fragment, the Fragment Offset indicates, in units of 8 bytes, the position of
    the payload of the fragment in the payload of the original packet. The Length
    field in each fragment indicates the length of the payload of the fragment as
    in a normal IPv4 packet. Finally, the More fragments flag is set only in the last
    fragment of a large packet.
  prefs: []
  type: TYPE_NORMAL
- en: The following pseudo-code details the IPv4 fragmentation algorithm, assuming
    that the packet does not contain IP options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The fragments of an IPv4 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv4 packet is a fragment
    or not by checking the value of the More fragments flag and the Fragment Offset.
    If the Fragment Offset is set to 0 and the More fragments flag is reset, the received
    packet has not been fragmented. Otherwise, the packet has been fragmented and
    must be reassembled. The reassembly algorithm relies on the Identification field
    of the received fragments to associate a fragment with the corresponding packet
    being reassembled. Furthermore, the Fragment Offset field indicates the position
    of the fragment payload in the original non fragmented packet. Finally, the packet
    with the More fragments flag reset allows the destination to determine the total
    length of the original no fragmented packet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bound the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: The original IP specification, in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html),
    defined several types of options that can be added to the IP header. Each option
    is encoded using a type length value format. They are not widely used today. Additional
    details may be found in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 packets[#](#ipv4-packets "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IPv4 packet format was defined in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    It is shown in [Fig. 111](#fig-ipv4-header-detail). Apart from a few clarifications
    and some backward compatible changes, the IPv4 packet format did not change significantly
    since the publication of [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
    All IPv4 packets use the 20 bytes header shown in figure [Fig. 111](#fig-ipv4-header-detail).
    Some IPv4 packets contain an optional header extension that is described later.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 111 The IP version 4 header[#](#id33 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'The main fields of the IPv4 header are :'
  prefs: []
  type: TYPE_NORMAL
- en: a 4 bits version that indicates the version of IP used to build the header.
    Using a version field in the header allows the network layer protocol to evolve.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 4 bits IP Header Length (IHL) that indicates the length of the IP header in
    32 bits words. This field allows IPv4 to use options if required, but as it is
    encoded as a 4 bits field, the IPv4 header cannot be longer than 64 bytes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits DS field that is used for Quality of Service and whose usage is described
    later.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an 8 bits Protocol field that indicates the transport layer protocol that must
    process the packet’s payload at the destination. Common values for this field
    [[2]](#fprotocolnumber) are 6 for TCP and 17 for UDP
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits length field that indicates the total length of the entire IPv4 packet
    (header and payload) in bytes. This implies that an IPv4 packet cannot be longer
    than 65535 bytes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits source address field that contains the IPv4 address of the source
    host
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 32 bits destination address field that contains the IPv4 address of the destination
    host
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16 bits checksum that protects only the IPv4 header against transmission errors
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The other fields of the IPv4 header are used for specific purposes. The first
    is the 8 bits Time To Live (TTL) field. This field is used by IPv4 to avoid the
    risk of having an IPv4 packet caught in an infinite loop due to a transient or
    permanent error in routing tables [[3]](#fttl). We will discuss in part two why
    such problems can happen. The TTL field of the IPv4 header ensures that even if
    there are forwarding loops in the network, packets will not loop forever. Hosts
    send their IPv4 packets with a positive TTL (usually 64 or more [[4]](#finitialttl)).
    When a router receives an IPv4 packet, it first decrements the TTL by one. If
    the TTL becomes 0, the packet is discarded and a message is sent back to the packet’s
    source (see section [ICMP](#icmp)). Otherwise, the router performs a lookup in
    its forwarding table to forward the packet.
  prefs: []
  type: TYPE_NORMAL
- en: A second problem for IPv4 is the heterogeneity of the datalink layer. IPv4 is
    used above many very different datalink layers. Each datalink layer has its own
    characteristics and as indicated earlier, each datalink layer is characterized
    by a maximum frame size. From IP’s point of view, a datalink layer interface is
    characterized by its Maximum Transmission Unit (MTU). The MTU of an interface
    is the largest IPv4 packet (including header) that it can send. The table below
    provides some common MTU sizes [[5]](#f6lowpan).
  prefs: []
  type: TYPE_NORMAL
- en: '| Datalink layer | MTU |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | 1500 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | 2272 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ATM (AAL5) | 9180 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 802.15.4 | 102 or 81 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Token Ring | 4464 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| FDDI | 4352 bytes |'
  prefs: []
  type: TYPE_TB
- en: Although an IPv4 host can theoretically send 64 KBytes long packets, few datalink
    layer technologies that are used today are able to send a 64 KBytes IPv4 packet
    inside a frame. Consider a client attached to a Token Ring network that wishes
    to send packets to a server connected to an Ethernet network. The client could
    send a 4 KBytes packet that would need to be fragmented inside the network to
    reach the server.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these problems, IPv4 includes a packet fragmentation and reassembly
    mechanism. Both hosts and intermediate routers may fragment an IPv4 packet if
    the packet is too long to be sent via the datalink layer. In IPv4, fragmentation
    is completely performed in the IP layer and a large IPv4 is fragmented into two
    or more IPv4 packets (called fragments). The IPv4 fragments of a large packet
    are normal IPv4 packets that are forwarded towards the destination of the large
    packet by intermediate routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPv4 fragmentation mechanism relies on four fields of the IPv4 header :
    Length, Identification, the flags and the Fragment Offset. The IPv4 header contains
    two flags : More fragments and Don’t Fragment (DF). When the DF flag is set, this
    indicates that the packet cannot be fragmented.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic operation of the IPv4 fragmentation is as follows. A large packet
    is fragmented into two or more fragments. The size of all fragments, except the
    last one, is equal to the Maximum Transmission Unit of the link used to forward
    the packet. Each IPv4 packet contains a 16 bits Identification field. When a packet
    is fragmented, the Identification of the large packet is copied in all fragments
    to allow the destination to reassemble the received fragments together. In each
    fragment, the Fragment Offset indicates, in units of 8 bytes, the position of
    the payload of the fragment in the payload of the original packet. The Length
    field in each fragment indicates the length of the payload of the fragment as
    in a normal IPv4 packet. Finally, the More fragments flag is set only in the last
    fragment of a large packet.
  prefs: []
  type: TYPE_NORMAL
- en: The following pseudo-code details the IPv4 fragmentation algorithm, assuming
    that the packet does not contain IP options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The fragments of an IPv4 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv4 packet is a fragment
    or not by checking the value of the More fragments flag and the Fragment Offset.
    If the Fragment Offset is set to 0 and the More fragments flag is reset, the received
    packet has not been fragmented. Otherwise, the packet has been fragmented and
    must be reassembled. The reassembly algorithm relies on the Identification field
    of the received fragments to associate a fragment with the corresponding packet
    being reassembled. Furthermore, the Fragment Offset field indicates the position
    of the fragment payload in the original non fragmented packet. Finally, the packet
    with the More fragments flag reset allows the destination to determine the total
    length of the original no fragmented packet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bound the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: The original IP specification, in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html),
    defined several types of options that can be added to the IP header. Each option
    is encoded using a type length value format. They are not widely used today. Additional
    details may be found in [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  prefs: []
  type: TYPE_NORMAL
- en: '## ICMP version 4[#](#icmp-version-4 "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMP is defined in [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html).
    ICMP messages are carried as the payload of IP packets (the protocol value reserved
    for ICMP is 1). [Fig. 112](#fig-icmpv4-header) illustrates the IPv4 header. An
    ICMP message is composed of an 8 byte header and a variable length payload that
    usually contains the first bytes of the packet that triggered the transmission
    of the ICMP message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/icmpv4.png](../Images/c6f49e0d69bec409a194b8b0090a586c.png)](../_images/icmpv4.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 112 ICMP version 4 [**RFC 792**](https://datatracker.ietf.org/doc/html/rfc792.html)[#](#id34
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: In the ICMP header, the Type and Code fields indicate the type of problem that
    was detected by the sender of the ICMP message. The Checksum protects the entire
    ICMP message against transmission errors and the Data field contains additional
    information for some ICMP messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main types of ICMP messages are :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Destination unreachable : a Destination unreachable ICMP message is sent when
    a packet cannot be delivered to its destination due to routing problems. Different
    types of non reachability are distinguished :'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Network unreachable : this ICMP message is sent by a router that does not have
    a route for the subnet containing the destination address of the packet'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Host unreachable : this ICMP message is sent by a router that is attached to
    the subnet that contains the destination address of the packet, but this destination
    address cannot be reached at this time'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Protocol unreachable : this ICMP message is sent by a destination host that
    has received a packet, but does not support the transport protocol indicated in
    the packet’s Protocol field'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Port unreachable : this ICMP message is sent by a destination host that has
    received a packet destined to a port number, but no server process is bound to
    this port'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fragmentation needed : this ICMP message is sent by a router that receives
    a packet with the Don’t Fragment flag set that is larger than the MTU of the outgoing
    interface'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ping(8)* is often used by network operators to verify that a given IP address
    is reachable. Each host is supposed [[6]](#fpingproblems) to reply with an ICMP
    Echo reply message when its receives an ICMP Echo request message. A sample usage
    of *ping(8)* is shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another very useful debugging tool is *traceroute(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the TTL exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose TTL is set to 1 it decrements the TTL and
    is forced to return to the sending host a TTL exceeded ICMP message containing
    the header and the first bytes of the discarded IP packet. To discover all routers
    on a network path, a simple solution is to first send a packet whose TTL is set
    to 1, then a packet whose TTL is set to 2, etc. A sample traceroute output is
    shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The above *traceroute(8)* output shows a 17 hops path between a host at UCLouvain
    and one of the main IETF servers. For each hop, traceroute provides the IPv4 address
    of the router that sent the ICMP message and the measured round-trip-time between
    the source and this router. traceroute sends three probes with each TTL value.
    In some cases, such as at the tenth hop above, the ICMP messages may be received
    from different addresses. This is usually because different packets from the same
    source have followed different paths [[7]](#ftraceroutemore) in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Another important utilization of ICMP messages is to discover the maximum MTU
    that can be used to reach a destination without fragmentation. As explained earlier,
    when an IPv4 router receives a packet that is larger than the MTU of the outgoing
    link, it must fragment the packet. Unfortunately, fragmentation is a complex operation
    and routers cannot perform it at line rate [[KM1995]](../bibliography.html#km1995).
    Furthermore, when a TCP segment is transported in an IP packet that is fragmented
    in the network, the loss of a single fragment forces TCP to retransmit the entire
    segment (and thus all the fragments). If TCP was able to send only packets that
    do not require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  prefs: []
  type: TYPE_NORMAL
- en: ICMP, combined with the Don’t fragment (DF) IPv4 flag, is used by TCP implementations
    to discover the largest MTU size that is allowed to reach a destination host without
    causing network fragmentation. This is the Path MTU discovery mechanism defined
    in [**RFC 1191**](https://datatracker.ietf.org/doc/html/rfc1191.html). A TCP implementation
    that includes Path MTU discovery (most do) requests the IPv4 layer to send all
    segments inside IPv4 packets having the DF flag set. This prohibits intermediate
    routers from fragmenting these packets. If a router needs to forward a packet
    which cannot be fragmented over a link with a smaller MTU, it returns a Fragmentation
    needed ICMP message to the source, indicating the MTU of its outgoing link. This
    ICMP message contains in the MTU of the router’s outgoing link in its Data field.
    Upon reception of this ICMP message, the source TCP implementation adjusts its
    Maximum Segment Size (MSS) so that the packets containing the segments that it
    sends can be forwarded by this router without requiring fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Operation of IPv4 hosts[#](#operation-of-ipv4-hosts "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point of the description of IPv4, it is useful to have a detailed look
    at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest
    case is when a host needs to send a segment in an IPv4 packet. The host performs
    two operations. First, it must decide on which interface the packet will be sent.
    Second it must create the corresponding IP packet(s).
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the discussion in this section, we ignore the utilization of IPv4
    options. This is not a severe limitation as today IPv4 packets rarely contain
    options. Details about the processing of the IPv4 options may be found in the
    relevant RFCs, such as [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 host having \(n\) datalink layer interfaces manages \(n+1\) IPv4 addresses
    :'
  prefs: []
  type: TYPE_NORMAL
- en: the 127.0.0.1/32 IPv4 address assigned by convention to its loopback address
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: one A.B.C.D/p IPv4 address assigned to each of its \(n\) datalink layer interfaces
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a host maintains a routing table containing one entry for its loopback
    address and one entry for each subnet identifier assigned to its interfaces. Furthermore,
    the host usually uses one of its interfaces as the default interface when sending
    packets that are not addressed to a directly connected destination. This is represented
    by the default route : 0.0.0.0/0 that is associated to one interface.'
  prefs: []
  type: TYPE_NORMAL
- en: When a transport protocol running on the host requests the transmission of a
    segment, it usually provides the IPv4 destination address to the IPv4 layer in
    addition to the segment [[12]](#fiddf). The IPv4 implementation first performs
    a longest prefix match with the destination address in its routing table. The
    lookup returns the identification of the interface that must be used to send the
    packet. The host can then create the IPv4 packet containing the segment. The source
    IPv4 address of the packet is the IPv4 address of the host on the interface returned
    by the longest prefix match. The Protocol field of the packet is set to the identification
    of the local transport protocol which created the segment. The TTL field of the
    packet is set to the default TTL used by the host. The host must now choose the
    packet’s Identification. This Identification is important if the packet becomes
    fragmented in the network, as it ensures that the destination is able to reassemble
    the received fragments. Ideally, a sending host should never send a packet twice
    with the same Identification to the same destination host, in order to ensure
    that all fragments are correctly reassembled by the destination. Unfortunately,
    with a 16 bits Identification field and an expected MSL of 2 minutes, this implies
    that the maximum bandwidth to a given destination is limited to roughly 286 Mbps.
    With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps [**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) if fragmentation must
    be possible [[12]](#fiddf). This is very low and is another reason why hosts are
    highly encouraged to avoid fragmentation. If; despite all of this, the MTU of
    the outgoing interface is smaller than the packet’s length, the packet is fragmented.
    Finally, the packet’s checksum is computed before transmission.
  prefs: []
  type: TYPE_NORMAL
- en: When a host receives an IPv4 packet destined to itself, there are several operations
    that it must perform. First, it must check the packet’s checksum. If the checksum
    is incorrect, the packet is discarded. Then, it must check whether the packet
    has been fragmented. If yes, the packet is passed to the reassembly algorithm
    described earlier. Otherwise, the packet must be passed to the upper layer. This
    is done by looking at the Protocol field (6 for TCP, 17 for UDP). If the host
    does not implement the transport layer protocol corresponding to the received
    Protocol field, it sends a Protocol unreachable ICMP message to the sending host.
    If the received packet contains an ICMP message (Protocol field set to 1), the
    processing is more complex. An Echo-request ICMP message triggers the transmission
    of an ICMP Echo-reply message. The other types of ICMP messages indicate an error
    that was caused by a previously transmitted packet. These ICMP messages are usually
    forwarded to the transport protocol that sent the erroneous packet. This can be
    done by inspecting the contents of the ICMP message that includes the header and
    the first 64 bits of the erroneous packet. If the IP packet did not contain options,
    which is the case for most IPv4 packets, the transport protocol can find in the
    first 32 bits of the transport header the source and destination ports to determine
    the affected transport flow. This is important for Path MTU discovery for example.
  prefs: []
  type: TYPE_NORMAL
- en: Operation of IPv4 hosts[#](#operation-of-ipv4-hosts "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point of the description of IPv4, it is useful to have a detailed look
    at how an IPv4 implementation sends, receives and forwards IPv4 packets. The simplest
    case is when a host needs to send a segment in an IPv4 packet. The host performs
    two operations. First, it must decide on which interface the packet will be sent.
    Second it must create the corresponding IP packet(s).
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the discussion in this section, we ignore the utilization of IPv4
    options. This is not a severe limitation as today IPv4 packets rarely contain
    options. Details about the processing of the IPv4 options may be found in the
    relevant RFCs, such as [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 host having \(n\) datalink layer interfaces manages \(n+1\) IPv4 addresses
    :'
  prefs: []
  type: TYPE_NORMAL
- en: the 127.0.0.1/32 IPv4 address assigned by convention to its loopback address
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: one A.B.C.D/p IPv4 address assigned to each of its \(n\) datalink layer interfaces
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a host maintains a routing table containing one entry for its loopback
    address and one entry for each subnet identifier assigned to its interfaces. Furthermore,
    the host usually uses one of its interfaces as the default interface when sending
    packets that are not addressed to a directly connected destination. This is represented
    by the default route : 0.0.0.0/0 that is associated to one interface.'
  prefs: []
  type: TYPE_NORMAL
- en: When a transport protocol running on the host requests the transmission of a
    segment, it usually provides the IPv4 destination address to the IPv4 layer in
    addition to the segment [[12]](#fiddf). The IPv4 implementation first performs
    a longest prefix match with the destination address in its routing table. The
    lookup returns the identification of the interface that must be used to send the
    packet. The host can then create the IPv4 packet containing the segment. The source
    IPv4 address of the packet is the IPv4 address of the host on the interface returned
    by the longest prefix match. The Protocol field of the packet is set to the identification
    of the local transport protocol which created the segment. The TTL field of the
    packet is set to the default TTL used by the host. The host must now choose the
    packet’s Identification. This Identification is important if the packet becomes
    fragmented in the network, as it ensures that the destination is able to reassemble
    the received fragments. Ideally, a sending host should never send a packet twice
    with the same Identification to the same destination host, in order to ensure
    that all fragments are correctly reassembled by the destination. Unfortunately,
    with a 16 bits Identification field and an expected MSL of 2 minutes, this implies
    that the maximum bandwidth to a given destination is limited to roughly 286 Mbps.
    With a more realistic 1500 bytes MTU, that bandwidth drops to 6.4 Mbps [**RFC
    4963**](https://datatracker.ietf.org/doc/html/rfc4963.html) if fragmentation must
    be possible [[12]](#fiddf). This is very low and is another reason why hosts are
    highly encouraged to avoid fragmentation. If; despite all of this, the MTU of
    the outgoing interface is smaller than the packet’s length, the packet is fragmented.
    Finally, the packet’s checksum is computed before transmission.
  prefs: []
  type: TYPE_NORMAL
- en: When a host receives an IPv4 packet destined to itself, there are several operations
    that it must perform. First, it must check the packet’s checksum. If the checksum
    is incorrect, the packet is discarded. Then, it must check whether the packet
    has been fragmented. If yes, the packet is passed to the reassembly algorithm
    described earlier. Otherwise, the packet must be passed to the upper layer. This
    is done by looking at the Protocol field (6 for TCP, 17 for UDP). If the host
    does not implement the transport layer protocol corresponding to the received
    Protocol field, it sends a Protocol unreachable ICMP message to the sending host.
    If the received packet contains an ICMP message (Protocol field set to 1), the
    processing is more complex. An Echo-request ICMP message triggers the transmission
    of an ICMP Echo-reply message. The other types of ICMP messages indicate an error
    that was caused by a previously transmitted packet. These ICMP messages are usually
    forwarded to the transport protocol that sent the erroneous packet. This can be
    done by inspecting the contents of the ICMP message that includes the header and
    the first 64 bits of the erroneous packet. If the IP packet did not contain options,
    which is the case for most IPv4 packets, the transport protocol can find in the
    first 32 bits of the transport header the source and destination ports to determine
    the affected transport flow. This is important for Path MTU discovery for example.
  prefs: []
  type: TYPE_NORMAL
- en: IP version 6[#](#ip-version-6 "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the late 1980s and early 1990s the growth of the Internet was causing several
    operational problems on routers. Many of these routers had a single CPU and up
    to 1 MByte of RAM to store their operating system, packet buffers and routing
    tables. Given the rate of allocation of IPv4 prefixes to companies and universities
    willing to join the Internet, the routing tables where growing very quickly and
    some feared that all IPv4 prefixes would quickly be allocated. In 1987, a study
    cited in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html), estimated
    that there would be 100,000 networks in the near future. In August 1990, estimates
    indicated that the class B space would be exhausted by March 1994.
  prefs: []
  type: TYPE_NORMAL
- en: Two types of solution were developed to solve this problem. The first short
    term solution was the introduction of Classless Inter Domain Routing ([CIDR](../glossary.html#term-CIDR)).
    A second short term solution was the Network Address Translation ([NAT](../glossary.html#term-NAT))
    mechanism, defined in [**RFC 1631**](https://datatracker.ietf.org/doc/html/rfc1631.html).
    NAT allowed multiple hosts to share a single public IPv4 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in parallel with these short-term solutions, which have allowed the
    IPv4 Internet to continue to be usable until now, the Internet Engineering Task
    Force started working on developing a replacement for IPv4\. This work started
    with an open call for proposals, outlined in [**RFC 1550**](https://datatracker.ietf.org/doc/html/rfc1550.html).
    Several groups responded to this call with proposals for a next generation Internet
    Protocol (IPng) :'
  prefs: []
  type: TYPE_NORMAL
- en: TUBA proposed in [**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html)
    and [**RFC 1561**](https://datatracker.ietf.org/doc/html/rfc1561.html)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: PIP proposed in [**RFC 1621**](https://datatracker.ietf.org/doc/html/rfc1621.html)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SIPP proposed in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The IETF decided to pursue the development of IPng based on the SIPP proposal.
    As IP version 5 was already used by the experimental ST-2 protocol defined in
    [**RFC 1819**](https://datatracker.ietf.org/doc/html/rfc1819.html), the successor
    of IP version 4 is IP version 6\. The initial IP version 6 defined in [**RFC 1752**](https://datatracker.ietf.org/doc/html/rfc1752.html)
    was designed based on the following assumptions :'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addresses are encoded as a 128 bits field
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The IPv6 header has a simple format that can easily be parsed by hardware devices
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A host should be able to configure its IPv6 address automatically
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Security must be part of IPv6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The IPng address size
  prefs: []
  type: TYPE_NORMAL
- en: When the work on IPng started, it was clear that 32 bits was too small to encode
    an IPng address and all proposals used longer addresses. However, there were many
    discussions about the most suitable address length. A first approach, proposed
    by SIPP in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html),
    was to use 64 bit addresses. A 64 bits address space was 4 billion times larger
    than the IPv4 address space and, furthermore, from an implementation perspective,
    64 bit CPUs were being considered and 64 bit addresses would naturally fit inside
    their registers. Another approach was to use an existing address format. This
    was the TUBA proposal ([**RFC 1347**](https://datatracker.ietf.org/doc/html/rfc1347.html))
    that reuses the ISO CLNP 20 bytes addresses. The 20 bytes addresses provided room
    for growth, but using ISO CLNP was not favored by the IETF partially due to political
    reasons, despite the fact that mature CLNP implementations were already available.
    128 bits appeared to be a reasonable compromise at that time.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addressing architecture[#](#ipv6-addressing-architecture "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The experience of IPv4 revealed that the scalability of a network layer protocol
    heavily depends on its addressing architecture. The designers of IPv6 spent a
    lot of effort defining its addressing architecture [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html).
    All IPv6 addresses are 128 bits wide. This implies that there are \(340,282,366,920,938,463,463,374,607,431,768,211,456
    (3.4 \times 10^{38})\) different IPv6 addresses. As the surface of the Earth is
    about 510,072,000 \(km^2\), this implies that there are about \(6.67 \times 10^{23}\)
    IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only
    8 addresses per square kilometer, this is a significant improvement on paper.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Textual representation of IPv6 addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16 bits blocks containing only bits set to 0. For example,'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address
    is used to identify one datalink-layer interface on a host. If a host has several
    datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then
    it needs several IPv6 addresses. In general, an IPv6 unicast address is structured
    as shown in [Fig. 113](#fig-ipv6-addr-structure).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/334d256816526fa56f8d5037c79a8b94.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 113 Structure of IPv6 unicast addresses
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The IETF has reserved some IPv6 addresses for a special usage. The two most
    important ones are :'
  prefs: []
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` (`::1` in compact form) is the IPv6 loopback address. This
    is the address of a logical interface that is always up and running on IPv6 enabled
    hosts.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` (`::` in compact form) is the unspecified IPv6 address. This
    is the IPv6 address that a host can use as source address when trying to acquire
    an official address.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The last type of unicast IPv6 addresses are the Link Local Unicast addresses
    shown in [Fig. 114](#fig-ipv6-link-local). These addresses are part of the fe80::/10
    address block and are defined in [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html).
    Each host can compute its own link local address by concatenating the fe80::/64
    prefix with the 64 bits identifier of its interface. Link local addresses can
    be used when hosts that are attached to the same link (or local area network)
    need to exchange packets. They are used notably for address discovery and auto-configuration
    purposes. Their usage is restricted to each link and a router cannot forward a
    packet whose source or destination address is a link local address. Link local
    addresses have also been defined for IPv4 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    However, the IPv4 link local addresses are only used when a host cannot obtain
    a regular IPv4 address, e.g. on an isolated LAN.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/85809a63cecf02a8a699a08cbd775118.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 114 IPv6 link local address structure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All IPv6 hosts have several addresses
  prefs: []
  type: TYPE_NORMAL
- en: An important consequence of the IPv6 unicast addressing architecture and the
    utilization of link-local addresses is that each IPv6 host has several IPv6 addresses.
    This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses described above are unicast addresses. These addresses are used
    to identify (interfaces on) hosts and routers. They can appear as source and destination
    addresses in the IPv6 packets. When a host sends a packet towards a unicast address,
    this packet is delivered by the network to its final destination. There are situations,
    such as when delivering video or television signal to a large number of receivers,
    where it is useful to have a network that can efficiently deliver the same packet
    to a large number of receivers. This is the multicast service. A multicast service
    can be provided in a LAN. In this case, a multicast address identifies a set of
    receivers and each frame sent towards this address is delivered to all receivers
    in the group. Multicast can also be used in a network containing routers and hosts.
    In this case, a multicast address identifies also a group of receivers and the
    network delivers efficiently each multicast packet to all members of the group.
    Consider for example the network shown in [Fig. 115](#fig-ipv6-simple-network).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 115 A simple network with hosts and routers
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume that `B` and `D` are part of a multicast group. If `A` sends a multicast
    packet towards this group, then `R1` will replicate the packet to forward it to
    `R2` and `R3`. `R2` would forward the packet towards `B`. `R3` would forward the
    packet towards `R4` that would deliver it to `D`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)
    defines the structure of the IPv6 multicast addresses [[8]](#fmultiiana). This
    structure is depicted in [Fig. 116](#fig-ipv6-multicast-addr).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 116 IPv6 multicast address structure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The low order 112 bits of an IPv6 multicast address are the group’s identifier.
    The high order bits are used as a marker to distinguish multicast addresses from
    unicast addresses. Notably, the 4-bit Flags field indicates whether the address
    is temporary or permanent. Finally, the Scope field indicates the boundaries of
    the forwarding of packets destined to a particular address. A link-local scope
    indicates that a router should not forward a packet destined to such a multicast
    address. An organization local-scope indicates that a packet sent to such a multicast
    destination address should not leave the organization. Finally the global scope
    is intended for multicast groups spanning the global Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Among these addresses, some are well known. For example, all hosts automatically
    belong to the `ff02::1` multicast group while all routers automatically belong
    to the `ff02::2` multicast group. A detailed discussion of IPv6 multicast is outside
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '### IPv6 packet[#](#ipv6-packet "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 packet format was heavily inspired by the packet format proposed for
    the SIPP protocol in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html).
    The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 117](#fig-ipv6-header-detail).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 117 The IP version 6 header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the source and destination addresses, the IPv6 header contains the
    following fields :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version : a 4 bits field set to 6 and intended to allow IP to evolve in the
    future if needed'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Traffic class : this 8 bits field indicates the type of service expected by
    this packet and contains the `CE` and `ECT` flags that are used by Explicit Congestion
    Notification'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flow Label : this field was initially intended to be used to tag packets belonging
    to the same flow. A recent document, [**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)
    describes some possible usages of this field, but it is too early to tell whether
    it will be really used.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Payload Length : this is the size of the packet payload in bytes. As the length
    is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of
    payload.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next Header : this 8-bit field indicates the type [[9]](#fianaprotocol) of
    header that follows the IPv6 header. It can be a transport layer header (e.g.
    6 for TCP or 17 for UDP) or an IPv6 option.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hop Limit : this 8-bit field indicates the number of routers that can forward
    the packet. It is decremented by one by each router and prevents packets from
    looping forever inside the network.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting to note that there is no checksum inside the IPv6 header.
    This is mainly because all datalink layers and transport protocols include a checksum
    or a CRC to protect their frames/segments against transmission errors. Adding
    a checksum in the IPv6 header would have forced each router to recompute the checksum
    of all packets, with limited benefit in detecting errors. In practice, an IP checksum
    allows for catching errors that occur inside routers (e.g. due to memory corruption)
    before the packet reaches its destination. However, this benefit was found to
    be too small given the reliability of current memories and the cost of computing
    the checksum on each router [[10]](#fipv4checksum).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a host receives an IPv6 packet, it needs to determine which transport
    protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is
    the first role of the Next header field. The [IANA](https://www.iana.org) which
    manages the allocation of Internet resources and protocol parameters, maintains
    an official list of transport protocols [[9]](#fianaprotocol). The following protocol
    numbers are reserved :'
  prefs: []
  type: TYPE_NORMAL
- en: '`TCP` uses Next Header number `6`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UDP` uses Next Header number `17`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SCTP` uses Next Header number `132`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an IPv6 packet that contains an TCP segment would appear as shown
    in [Fig. 118](#fig-ipv6-tcp).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 118 An IPv6 packet containing an TCP segment[#](#id40 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: However, the Next header has broader usages than simply indicating the transport
    protocol which is responsible for the packet payload. An IPv6 packet can contain
    a chain of headers and the last one indicates the transport protocol that is responsible
    for the packet payload. Supporting a chain of headers is a clever design from
    an extensibility viewpoint. As we will see, this chain of headers has several
    usages.
  prefs: []
  type: TYPE_NORMAL
- en: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) defines
    several types of IPv6 extension headers that could be added to an IPv6 packet
    :'
  prefs: []
  type: TYPE_NORMAL
- en: Hop-by-Hop Options header. This option is processed by routers and hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Destination Options header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Routing header. This option is processed by some nodes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragment header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Authentication header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulating Security Payload. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two headers are used to add security above IPv6 and implement IPSec.
    They are described in [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    and [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) and are
    outside the scope of this document.
  prefs: []
  type: TYPE_NORMAL
- en: The Hop-by-Hop Options header was designed to make IPv6 easily extensible. In
    theory, this option could be used to define new fields that were not foreseen
    when IPv6 was designed. It is intended to be processed by both routers and hosts.
    Deploying an extension to a network protocol can be difficult in practice since
    some nodes already support the extensions while others still use the old version
    and do not understand the extension. To deal with this issue, the IPv6 designers
    opted for a Type-Length-Value encoding of these IPv6 options. The Hop-by-Hop Options
    header is encoded as show in [Fig. 119](#fig-ipv6-hbhoption).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 119 The IPv6 Hop-by-Hop Options header[#](#id41 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'In this optional header, the Next Header field is used to support the chain
    of headers. It indicates the type of the next header in the chain. IPv6 headers
    have different lengths. The Hdr Ext Len field indicates the total length of the
    option header in bytes. The Opt. Type field indicates the type of option. These
    types are encoded such that their high order bits specify how the header needs
    to be handled by nodes that do not recognize it. The following values are defined
    for the two high order bits :'
  prefs: []
  type: TYPE_NORMAL
- en: '`00` : if a node does not recognize this header, it can be safely skipped and
    the processing continues with the subsequent header'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`01` : if a node does not recognize this header, the packet must be discarded'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`10` (resp. `11`) : if a node does not recognize this header, it must return
    a control packet (ICMP, see later) back to the source (resp. except if the destination
    was a multicast address)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: This encoding allows the designers of protocol extensions to specify whether
    the option must be supported by all nodes on a path or not. Still, deploying such
    an extension can be difficult in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Two hop-by-hop options have been defined. [**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    specifies the jumbogram that enables IPv6 to support packets containing a payload
    larger than 65535 bytes. These jumbo packets have their payload length set to
    0 and the jumbogram option contains the packet length as a 32 bits field. Such
    packets can only be sent from a source to a destination if all the routers on
    the path support this option. However, as of this writing it does not seem that
    the jumbogram option has been implemented. The router alert option defined in
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) is the second
    example of a hop-by-hop option. The packets that contain this option should be
    processed in a special way by intermediate routers. This option is used for IP
    packets that carry Resource Reservation Protocol (RSVP) messages, but this is
    outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Destinations Option header uses the same format as the Hop-by-Hop Options
    header. It has some usages, e.g. to support mobile nodes [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html),
    but these are outside the scope of this document.
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Options header is more important. An important problem in the network
    layer is the ability to handle heterogeneous datalink layers. Most datalink layer
    technologies can only transmit and receive frames that are shorter than a given
    maximum frame size. Unfortunately, all datalink layer technologies use different
    maximum frames sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Each datalink layer has its own characteristics and as indicated earlier, each
    datalink layer is characterized by a maximum frame size. From IP’s point of view,
    a datalink layer interface is characterized by its Maximum Transmission Unit (MTU).
    The MTU of an interface is the largest packet (including header) that it can send.
    The table below provides some common MTU sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '| Datalink layer | MTU |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | 1500 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | 2272 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ATM (AAL5) | 9180 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 802.15.4 | 102 or 81 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Token Ring | 4464 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| FDDI | 4352 bytes |'
  prefs: []
  type: TYPE_TB
- en: Although IPv6 can send 64 KBytes long packets, few datalink layer technologies
    that are used today are able to send a 64 KBytes packet inside a frame. Furthermore,
    as illustrated in [Fig. 120](#fig-ipv6-need-fragmentation), another problem is
    that a host may send a packet that would be too large for one of the datalink
    layers used by the intermediate routers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/1baf064048236d27ceffa188e5e44d59.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 120 The need for fragmentation and reassembly
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve these problems, IPv6 includes a packet fragmentation and reassembly
    mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate
    routers. However, experience with IPv4 has shown that fragmenting packets in routers
    was costly [[KM1995]](../bibliography.html#km1995). For this reason, the developers
    of IPv6 have decided that routers would not fragment packets anymore. In IPv6,
    fragmentation is only performed by the source host. If a source has to send a
    packet which is larger than the MTU of the outgoing interface, the packet needs
    to be fragmented before being transmitted. In IPv6, each packet fragment is an
    IPv6 packet that includes the Fragmentation header shown in [Fig. 121](#fig-ipv6-fragment-header).
    This header is included by the source in each packet fragment. The receiver uses
    them to reassemble the received fragments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 121 IPv6 fragmentation header[#](#id43 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: If a router receives a packet that is too long to be forwarded, the packet is
    dropped and the router returns an ICMPv6 message to inform the sender of the problem.
    The sender can then either fragment the packet or perform Path MTU discovery.
    In IPv6, packet fragmentation is performed only by the source by using IPv6 options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In IPv6, fragmentation is performed exclusively by the source host and relies
    on the fragmentation header. This 64 bits header is composed of six fields :'
  prefs: []
  type: TYPE_NORMAL
- en: a Next Header field that indicates the type of the header that follows the fragmentation
    header
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: two Reserved fields set to 0.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Fragment Offset is a 13-bit unsigned integer that contains the offset, in
    8 bytes units, of the data following this header, relative to the start of the
    original packet.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the More flag, which is set to 0 in the last fragment of a packet and to 1 in
    all other fragments.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the 32-bit Identification field indicates to which original packet a fragment
    belongs. When a host sends fragmented packets, it should ensure that it does not
    reuse the same identification field for packets sent to the same destination during
    a period of MSL seconds. This is easier with the 32 bits identification used in
    the IPv6 fragmentation header, than with the 16 bits identification field of the
    IPv4 header.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Some IPv6 implementations send the fragments of a packet in increasing fragment
    offset order, starting from the first fragment. Others send the fragments in reverse
    order, starting from the last fragment. The latter solution can be advantageous
    for the host that needs to reassemble the fragments, as it can easily allocate
    the buffer required to reassemble all fragments of the packet upon reception of
    the last fragment. When a host receives the first fragment of an IPv6 packet,
    it cannot know a priori the length of the entire IPv6 packet.
  prefs: []
  type: TYPE_NORMAL
- en: '[Fig. 122](#fig-ipv6-fragmentation-example) provides an example of a fragmented
    IPv6 packet containing a UDP segment. The Next Header type reserved for the IPv6
    fragmentation option is 44.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 122 IPv6 fragmentation example[#](#id44 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: The following pseudo-code details the IPv6 fragmentation, assuming that the
    packet does not contain options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the above pseudocode, we maintain a single 32 bits counter that is incremented
    for each packet that needs to be fragmented. Other implementations to compute
    the packet identification are possible. [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    only requires that two fragmented packets that are sent within the MSL between
    the same pair of hosts have different identifications.
  prefs: []
  type: TYPE_NORMAL
- en: The fragments of an IPv6 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv6 packet is a fragment
    or not by checking whether it contains a fragment header. If so, all fragments
    with the some identification must be reassembled together. The reassembly algorithm
    relies on the Identification field of the received fragments to associate a fragment
    with the corresponding packet being reassembled. Furthermore, the Fragment Offset
    field indicates the position of the fragment payload in the original non-fragmented
    packet. Finally, the packet with the M flag reset allows the destination to determine
    the total length of the original non-fragmented packet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bind the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Header compression on low bandwidth links
  prefs: []
  type: TYPE_NORMAL
- en: Given the size of the IPv6 header, it can cause huge overhead on low bandwidth
    links, especially when small packets are exchanged such as for Voice over IP applications.
    In such environments, several techniques can be used to reduce the overhead. A
    first solution is to use data compression in the datalink layer to compress all
    the information exchanged [[Thomborson1992]](../bibliography.html#thomborson1992).
    These techniques are similar to the data compression algorithms used in tools
    such as *compress(1)* or *gzip(1)* [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html).
    They compress streams of bits without taking advantage of the fact that these
    streams contain IP packets with a known structure. A second solution is to compress
    the IP and TCP header. These header compression techniques, such as the one defined
    in [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html) take advantage
    of the redundancy found in successive packets from the same flow to significantly
    reduce the size of the protocol headers. Another solution is to define a compressed
    encoding of the IPv6 header that matches the capabilities of the underlying datalink
    layer [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html).
  prefs: []
  type: TYPE_NORMAL
- en: The last type of IPv6 header extension is the Routing header. The `type 0` routing
    header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    is an example of an IPv6 option that must be processed by some routers. This option
    is encoded as shown in [Fig. 123](#fig-ipv6-rh0).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 123 The Type 0 routing header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'The type 0 routing option was intended to allow a host to indicate a loose
    source route that should be followed by a packet by specifying the addresses of
    some of the routers that must forward this packet. Unfortunately, further work
    with this routing header, including an entertaining demonstration with [scapy](https://www.secdev.org/projects/scapy/)
    [[BE2007]](../bibliography.html#be2007) , revealed severe security problems with
    this routing header. For this reason, loose source routing with the type 0 routing
    header has been removed from the IPv6 specification [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html).  ###
    ICMP version 6[#](#icmp-version-6 "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMPv6 is defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html).
    It is used both to report problems that occurred while processing an IPv6 packet,
    but also to distribute addresses.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 messages are carried inside IPv6 packets (the Next Header field for ICMPv6
    is `58`). Each ICMP message contains a 32 bits header with an 8 bits type field,
    a code field and a 16 bits checksum computed over the entire ICMPv6 message. The
    message body contains a copy of the IPv6 packet in error. The ICMPv6 header is
    shown in [Fig. 124](#fig-icmpv6-header).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 124 ICMP version 6 packet format[#](#id46 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'ICMPv6 specifies two classes of messages : error messages that indicate a problem
    in handling a packet and informational messages. Four types of error messages
    are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`Destination Unreachable. Such an ICMPv6 message is sent when the destination
    address of a packet is unreachable. The code field of the ICMP header contains
    additional information about the type of unreachability. The following codes are
    specified in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` : No route to destination. This indicates that the router that sent the
    ICMPv6 message did not have a route towards the packet’s destination'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` : Communication with destination administratively prohibited. This indicates
    that a firewall has refused to forward the packet towards its final destination.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Beyond scope of source address. This message can be sent if the source
    is using link-local addresses to reach a global unicast address outside its subnet.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Address unreachable. This message indicates that the packet reached the
    subnet of the destination, but the host that owns this destination address cannot
    be reached.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Port unreachable. This message indicates that the IPv6 packet was received
    by the destination, but there was no application listening to the specified port.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Packet Too Big. The router that was to send the ICMPv6 message received
    an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message
    contains the MTU of this link in bytes. This allows the sending host to implement
    Path MTU discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Time Exceeded. This error message can be sent either by a router or by
    a host. A router would set code to 0 to report the reception of a packet whose
    Hop Limit reached 0. A host would set code to 1 to report that it was unable to
    reassemble received IPv6 fragments.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Parameter Problem. This ICMPv6 message is used to report either the reception
    of an IPv6 packet with an erroneous header field (code 0) or an unknown Next Header
    or IP option (codes 1 and 2). In this case, the message body contains the erroneous
    IPv6 packet and the first 32 bits of the message body contain a pointer to the
    error.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The Destination Unreachable ICMP error message is returned when a packet cannot
    be forwarded to its final destination. The first four ICMPv6 error messages (type
    `1`, codes `0-3`) are generated by routers while hosts may return code `4` when
    there is no application bound to the corresponding port number.
  prefs: []
  type: TYPE_NORMAL
- en: The Packet Too Big ICMP messages enable the source host to discover the MTU
    size that it can safely use to reach a given destination. To understand its operation,
    consider the (academic) scenario shown in [Fig. 125](#fig-ipv6-mtu-discovery).
    In this figure, the labels on each link represent the maximum packet size supported
    by this link.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 125 Example for IPv6 MTU discovery
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `A` sends a 1500 bytes packet, `R1` will return an ICMPv6 error message indicating
    a maximum packet length of 1400 bytes. `A` would then fragment the packet before
    retransmitting it. The small fragment would go through, but the large fragment
    will be refused by `R2` that would return an ICMPv6 error message. `A` can fragment
    again the packet and send it to the final destination as two fragments.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, an IPv6 implementation does not store the transmitted packets to
    be able to retransmit them if needed. However, since TCP (and SCTP) buffer the
    segments that they transmit, a similar approach can be used in transport protocols
    to detect the largest MTU on a path towards a given destination. This technique
    is called PathMTU Discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html).
  prefs: []
  type: TYPE_NORMAL
- en: When a TCP segment is transported in an IP packet that is fragmented in the
    network, the loss of a single fragment forces TCP to retransmit the entire segment
    (and thus all the fragments). If TCP was able to send only packets that do not
    require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 is used by TCP implementations to discover the largest MTU size that
    is allowed to reach a destination host without causing network fragmentation.
    A TCP implementation parses the Packets Too Big ICMP messages that it receives.
    These ICMP messages contain the MTU of the router’s outgoing link in their Data
    field. Upon reception of such an ICMP message, the source TCP implementation adjusts
    its Maximum Segment Size (MSS) so that the packets containing the segments that
    it sends can be forwarded by this router without requiring fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two types of informational ICMPv6 messages are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    : echo request and echo reply, which are used to test the reachability of a destination
    by using *ping6(8)*. Each host is supposed to reply with an ICMP Echo reply message
    when it receives an ICMP Echo request message. A sample usage of *ping6(8)* is
    shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Another very useful debugging tool is *traceroute6(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the Time exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose Hop Limit is set to `1` it is forced to return
    to the sending host a Time exceeded ICMP message containing the header and the
    first bytes of the discarded packet. To discover all routers on a network path,
    a simple solution is to first send a packet whose Hop Limit is set to 1, then
    a packet whose Hop Limit is set to 2, etc. A sample traceroute6 output is shown
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Rate limitation of ICMP messages
  prefs: []
  type: TYPE_NORMAL
- en: High-end hardware based routers use special purpose chips on their interfaces
    to forward IPv6 packets at line rate. These chips are optimized to process correct
    IP packets. They are not able to create ICMP messages at line rate. When such
    a chip receives an IP packet that triggers an ICMP message, it interrupts the
    main CPU of the router and the software running on this CPU processes the packet.
    This CPU is much slower than the hardware acceleration found on the interfaces
    [[Gill2004]](../bibliography.html#gill2004). It would be overloaded if it had
    to process IP packets at line rate and generate one ICMP message for each received
    packet. To protect this CPU, high-end routers limit the rate at which the hardware
    can interrupt the main CPU and thus the rate at which ICMP messages can be generated.
    This implies that not all erroneous IP packets cause the transmission of an ICMP
    message. The risk of overloading the main CPU of the router is also the reason
    why using hop-by-hop IPv6 options, including the router alert option is discouraged
    [[#falert]_](#id49).
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addressing architecture[#](#ipv6-addressing-architecture "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The experience of IPv4 revealed that the scalability of a network layer protocol
    heavily depends on its addressing architecture. The designers of IPv6 spent a
    lot of effort defining its addressing architecture [**RFC 3513**](https://datatracker.ietf.org/doc/html/rfc3513.html).
    All IPv6 addresses are 128 bits wide. This implies that there are \(340,282,366,920,938,463,463,374,607,431,768,211,456
    (3.4 \times 10^{38})\) different IPv6 addresses. As the surface of the Earth is
    about 510,072,000 \(km^2\), this implies that there are about \(6.67 \times 10^{23}\)
    IPv6 addresses per square meter on Earth. Compared to IPv4, which offers only
    8 addresses per square kilometer, this is a significant improvement on paper.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Textual representation of IPv6 addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16 bits blocks containing only bits set to 0. For example,'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 supports unicast, multicast and anycast addresses. An IPv6 unicast address
    is used to identify one datalink-layer interface on a host. If a host has several
    datalink layer interfaces (e.g. an Ethernet interface and a WiFi interface), then
    it needs several IPv6 addresses. In general, an IPv6 unicast address is structured
    as shown in [Fig. 113](#fig-ipv6-addr-structure).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/334d256816526fa56f8d5037c79a8b94.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 113 Structure of IPv6 unicast addresses
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The IETF has reserved some IPv6 addresses for a special usage. The two most
    important ones are :'
  prefs: []
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` (`::1` in compact form) is the IPv6 loopback address. This
    is the address of a logical interface that is always up and running on IPv6 enabled
    hosts.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` (`::` in compact form) is the unspecified IPv6 address. This
    is the IPv6 address that a host can use as source address when trying to acquire
    an official address.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The last type of unicast IPv6 addresses are the Link Local Unicast addresses
    shown in [Fig. 114](#fig-ipv6-link-local). These addresses are part of the fe80::/10
    address block and are defined in [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html).
    Each host can compute its own link local address by concatenating the fe80::/64
    prefix with the 64 bits identifier of its interface. Link local addresses can
    be used when hosts that are attached to the same link (or local area network)
    need to exchange packets. They are used notably for address discovery and auto-configuration
    purposes. Their usage is restricted to each link and a router cannot forward a
    packet whose source or destination address is a link local address. Link local
    addresses have also been defined for IPv4 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    However, the IPv4 link local addresses are only used when a host cannot obtain
    a regular IPv4 address, e.g. on an isolated LAN.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/85809a63cecf02a8a699a08cbd775118.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 114 IPv6 link local address structure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All IPv6 hosts have several addresses
  prefs: []
  type: TYPE_NORMAL
- en: An important consequence of the IPv6 unicast addressing architecture and the
    utilization of link-local addresses is that each IPv6 host has several IPv6 addresses.
    This implies that all IPv6 stacks must be able to handle multiple IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses described above are unicast addresses. These addresses are used
    to identify (interfaces on) hosts and routers. They can appear as source and destination
    addresses in the IPv6 packets. When a host sends a packet towards a unicast address,
    this packet is delivered by the network to its final destination. There are situations,
    such as when delivering video or television signal to a large number of receivers,
    where it is useful to have a network that can efficiently deliver the same packet
    to a large number of receivers. This is the multicast service. A multicast service
    can be provided in a LAN. In this case, a multicast address identifies a set of
    receivers and each frame sent towards this address is delivered to all receivers
    in the group. Multicast can also be used in a network containing routers and hosts.
    In this case, a multicast address identifies also a group of receivers and the
    network delivers efficiently each multicast packet to all members of the group.
    Consider for example the network shown in [Fig. 115](#fig-ipv6-simple-network).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/bae1061d88df9cf3ecd419cee229cdb6.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 115 A simple network with hosts and routers
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume that `B` and `D` are part of a multicast group. If `A` sends a multicast
    packet towards this group, then `R1` will replicate the packet to forward it to
    `R2` and `R3`. `R2` would forward the packet towards `B`. `R3` would forward the
    packet towards `R4` that would deliver it to `D`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [**RFC 4291**](https://datatracker.ietf.org/doc/html/rfc4291.html)
    defines the structure of the IPv6 multicast addresses [[8]](#fmultiiana). This
    structure is depicted in [Fig. 116](#fig-ipv6-multicast-addr).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/90e0f4fee894cdfe0a7cdf32cebf5097.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 116 IPv6 multicast address structure
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The low order 112 bits of an IPv6 multicast address are the group’s identifier.
    The high order bits are used as a marker to distinguish multicast addresses from
    unicast addresses. Notably, the 4-bit Flags field indicates whether the address
    is temporary or permanent. Finally, the Scope field indicates the boundaries of
    the forwarding of packets destined to a particular address. A link-local scope
    indicates that a router should not forward a packet destined to such a multicast
    address. An organization local-scope indicates that a packet sent to such a multicast
    destination address should not leave the organization. Finally the global scope
    is intended for multicast groups spanning the global Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Among these addresses, some are well known. For example, all hosts automatically
    belong to the `ff02::1` multicast group while all routers automatically belong
    to the `ff02::2` multicast group. A detailed discussion of IPv6 multicast is outside
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '### IPv6 packet[#](#ipv6-packet "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 packet format was heavily inspired by the packet format proposed for
    the SIPP protocol in [**RFC 1710**](https://datatracker.ietf.org/doc/html/rfc1710.html).
    The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 117](#fig-ipv6-header-detail).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 117 The IP version 6 header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id39
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the source and destination addresses, the IPv6 header contains the
    following fields :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version : a 4 bits field set to 6 and intended to allow IP to evolve in the
    future if needed'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Traffic class : this 8 bits field indicates the type of service expected by
    this packet and contains the `CE` and `ECT` flags that are used by Explicit Congestion
    Notification'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flow Label : this field was initially intended to be used to tag packets belonging
    to the same flow. A recent document, [**RFC 6437**](https://datatracker.ietf.org/doc/html/rfc6437.html)
    describes some possible usages of this field, but it is too early to tell whether
    it will be really used.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Payload Length : this is the size of the packet payload in bytes. As the length
    is encoded as a 16 bits field, an IPv6 packet can contain up to 65535 bytes of
    payload.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next Header : this 8-bit field indicates the type [[9]](#fianaprotocol) of
    header that follows the IPv6 header. It can be a transport layer header (e.g.
    6 for TCP or 17 for UDP) or an IPv6 option.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hop Limit : this 8-bit field indicates the number of routers that can forward
    the packet. It is decremented by one by each router and prevents packets from
    looping forever inside the network.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: It is interesting to note that there is no checksum inside the IPv6 header.
    This is mainly because all datalink layers and transport protocols include a checksum
    or a CRC to protect their frames/segments against transmission errors. Adding
    a checksum in the IPv6 header would have forced each router to recompute the checksum
    of all packets, with limited benefit in detecting errors. In practice, an IP checksum
    allows for catching errors that occur inside routers (e.g. due to memory corruption)
    before the packet reaches its destination. However, this benefit was found to
    be too small given the reliability of current memories and the cost of computing
    the checksum on each router [[10]](#fipv4checksum).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a host receives an IPv6 packet, it needs to determine which transport
    protocol (UDP, TCP, SCTP, …) needs to handle the payload of the packet. This is
    the first role of the Next header field. The [IANA](https://www.iana.org) which
    manages the allocation of Internet resources and protocol parameters, maintains
    an official list of transport protocols [[9]](#fianaprotocol). The following protocol
    numbers are reserved :'
  prefs: []
  type: TYPE_NORMAL
- en: '`TCP` uses Next Header number `6`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UDP` uses Next Header number `17`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SCTP` uses Next Header number `132`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an IPv6 packet that contains an TCP segment would appear as shown
    in [Fig. 118](#fig-ipv6-tcp).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-tcp.svg](../Images/6b433eadd436f66e88bc838b2d95ab25.png)](../_images/ipv6-tcp.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 118 An IPv6 packet containing an TCP segment[#](#id40 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: However, the Next header has broader usages than simply indicating the transport
    protocol which is responsible for the packet payload. An IPv6 packet can contain
    a chain of headers and the last one indicates the transport protocol that is responsible
    for the packet payload. Supporting a chain of headers is a clever design from
    an extensibility viewpoint. As we will see, this chain of headers has several
    usages.
  prefs: []
  type: TYPE_NORMAL
- en: '[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) defines
    several types of IPv6 extension headers that could be added to an IPv6 packet
    :'
  prefs: []
  type: TYPE_NORMAL
- en: Hop-by-Hop Options header. This option is processed by routers and hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Destination Options header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Routing header. This option is processed by some nodes.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fragment header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Authentication header. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulating Security Payload. This option is processed only by hosts.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two headers are used to add security above IPv6 and implement IPSec.
    They are described in [**RFC 2402**](https://datatracker.ietf.org/doc/html/rfc2402.html)
    and [**RFC 2406**](https://datatracker.ietf.org/doc/html/rfc2406.html) and are
    outside the scope of this document.
  prefs: []
  type: TYPE_NORMAL
- en: The Hop-by-Hop Options header was designed to make IPv6 easily extensible. In
    theory, this option could be used to define new fields that were not foreseen
    when IPv6 was designed. It is intended to be processed by both routers and hosts.
    Deploying an extension to a network protocol can be difficult in practice since
    some nodes already support the extensions while others still use the old version
    and do not understand the extension. To deal with this issue, the IPv6 designers
    opted for a Type-Length-Value encoding of these IPv6 options. The Hop-by-Hop Options
    header is encoded as show in [Fig. 119](#fig-ipv6-hbhoption).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-hbh.svg](../Images/342b609792a5cdad56255af20171a375.png)](../_images/ipv6-hbh.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 119 The IPv6 Hop-by-Hop Options header[#](#id41 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'In this optional header, the Next Header field is used to support the chain
    of headers. It indicates the type of the next header in the chain. IPv6 headers
    have different lengths. The Hdr Ext Len field indicates the total length of the
    option header in bytes. The Opt. Type field indicates the type of option. These
    types are encoded such that their high order bits specify how the header needs
    to be handled by nodes that do not recognize it. The following values are defined
    for the two high order bits :'
  prefs: []
  type: TYPE_NORMAL
- en: '`00` : if a node does not recognize this header, it can be safely skipped and
    the processing continues with the subsequent header'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`01` : if a node does not recognize this header, the packet must be discarded'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`10` (resp. `11`) : if a node does not recognize this header, it must return
    a control packet (ICMP, see later) back to the source (resp. except if the destination
    was a multicast address)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: This encoding allows the designers of protocol extensions to specify whether
    the option must be supported by all nodes on a path or not. Still, deploying such
    an extension can be difficult in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Two hop-by-hop options have been defined. [**RFC 2675**](https://datatracker.ietf.org/doc/html/rfc2675.html)
    specifies the jumbogram that enables IPv6 to support packets containing a payload
    larger than 65535 bytes. These jumbo packets have their payload length set to
    0 and the jumbogram option contains the packet length as a 32 bits field. Such
    packets can only be sent from a source to a destination if all the routers on
    the path support this option. However, as of this writing it does not seem that
    the jumbogram option has been implemented. The router alert option defined in
    [**RFC 2711**](https://datatracker.ietf.org/doc/html/rfc2711.html) is the second
    example of a hop-by-hop option. The packets that contain this option should be
    processed in a special way by intermediate routers. This option is used for IP
    packets that carry Resource Reservation Protocol (RSVP) messages, but this is
    outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Destinations Option header uses the same format as the Hop-by-Hop Options
    header. It has some usages, e.g. to support mobile nodes [**RFC 6275**](https://datatracker.ietf.org/doc/html/rfc6275.html),
    but these are outside the scope of this document.
  prefs: []
  type: TYPE_NORMAL
- en: The Fragment Options header is more important. An important problem in the network
    layer is the ability to handle heterogeneous datalink layers. Most datalink layer
    technologies can only transmit and receive frames that are shorter than a given
    maximum frame size. Unfortunately, all datalink layer technologies use different
    maximum frames sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Each datalink layer has its own characteristics and as indicated earlier, each
    datalink layer is characterized by a maximum frame size. From IP’s point of view,
    a datalink layer interface is characterized by its Maximum Transmission Unit (MTU).
    The MTU of an interface is the largest packet (including header) that it can send.
    The table below provides some common MTU sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '| Datalink layer | MTU |'
  prefs: []
  type: TYPE_TB
- en: '| Ethernet | 1500 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | 2272 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ATM (AAL5) | 9180 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| 802.15.4 | 102 or 81 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| Token Ring | 4464 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| FDDI | 4352 bytes |'
  prefs: []
  type: TYPE_TB
- en: Although IPv6 can send 64 KBytes long packets, few datalink layer technologies
    that are used today are able to send a 64 KBytes packet inside a frame. Furthermore,
    as illustrated in [Fig. 120](#fig-ipv6-need-fragmentation), another problem is
    that a host may send a packet that would be too large for one of the datalink
    layers used by the intermediate routers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/1baf064048236d27ceffa188e5e44d59.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 120 The need for fragmentation and reassembly
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve these problems, IPv6 includes a packet fragmentation and reassembly
    mechanism. In IPv4, fragmentation was performed by both the hosts and the intermediate
    routers. However, experience with IPv4 has shown that fragmenting packets in routers
    was costly [[KM1995]](../bibliography.html#km1995). For this reason, the developers
    of IPv6 have decided that routers would not fragment packets anymore. In IPv6,
    fragmentation is only performed by the source host. If a source has to send a
    packet which is larger than the MTU of the outgoing interface, the packet needs
    to be fragmented before being transmitted. In IPv6, each packet fragment is an
    IPv6 packet that includes the Fragmentation header shown in [Fig. 121](#fig-ipv6-fragment-header).
    This header is included by the source in each packet fragment. The receiver uses
    them to reassemble the received fragments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-fragment.svg](../Images/bf5635c8afb9faf01ffd82e5c9a79010.png)](../_images/ipv6-fragment.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 121 IPv6 fragmentation header[#](#id43 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: If a router receives a packet that is too long to be forwarded, the packet is
    dropped and the router returns an ICMPv6 message to inform the sender of the problem.
    The sender can then either fragment the packet or perform Path MTU discovery.
    In IPv6, packet fragmentation is performed only by the source by using IPv6 options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In IPv6, fragmentation is performed exclusively by the source host and relies
    on the fragmentation header. This 64 bits header is composed of six fields :'
  prefs: []
  type: TYPE_NORMAL
- en: a Next Header field that indicates the type of the header that follows the fragmentation
    header
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: two Reserved fields set to 0.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Fragment Offset is a 13-bit unsigned integer that contains the offset, in
    8 bytes units, of the data following this header, relative to the start of the
    original packet.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the More flag, which is set to 0 in the last fragment of a packet and to 1 in
    all other fragments.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the 32-bit Identification field indicates to which original packet a fragment
    belongs. When a host sends fragmented packets, it should ensure that it does not
    reuse the same identification field for packets sent to the same destination during
    a period of MSL seconds. This is easier with the 32 bits identification used in
    the IPv6 fragmentation header, than with the 16 bits identification field of the
    IPv4 header.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Some IPv6 implementations send the fragments of a packet in increasing fragment
    offset order, starting from the first fragment. Others send the fragments in reverse
    order, starting from the last fragment. The latter solution can be advantageous
    for the host that needs to reassemble the fragments, as it can easily allocate
    the buffer required to reassemble all fragments of the packet upon reception of
    the last fragment. When a host receives the first fragment of an IPv6 packet,
    it cannot know a priori the length of the entire IPv6 packet.
  prefs: []
  type: TYPE_NORMAL
- en: '[Fig. 122](#fig-ipv6-fragmentation-example) provides an example of a fragmented
    IPv6 packet containing a UDP segment. The Next Header type reserved for the IPv6
    fragmentation option is 44.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-frag-example.png](../Images/4d1256f56efdd49bd1e8367b8821cdac.png)](../_images/ipv6-frag-example.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 122 IPv6 fragmentation example[#](#id44 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: The following pseudo-code details the IPv6 fragmentation, assuming that the
    packet does not contain options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above pseudocode, we maintain a single 32 bits counter that is incremented
    for each packet that needs to be fragmented. Other implementations to compute
    the packet identification are possible. [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    only requires that two fragmented packets that are sent within the MSL between
    the same pair of hosts have different identifications.
  prefs: []
  type: TYPE_NORMAL
- en: The fragments of an IPv6 packet may arrive at the destination in any order,
    as each fragment is forwarded independently in the network and may follow different
    paths. Furthermore, some fragments may be lost and never reach the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The reassembly algorithm used by the destination host is roughly as follows.
    First, the destination can verify whether a received IPv6 packet is a fragment
    or not by checking whether it contains a fragment header. If so, all fragments
    with the some identification must be reassembled together. The reassembly algorithm
    relies on the Identification field of the received fragments to associate a fragment
    with the corresponding packet being reassembled. Furthermore, the Fragment Offset
    field indicates the position of the fragment payload in the original non-fragmented
    packet. Finally, the packet with the M flag reset allows the destination to determine
    the total length of the original non-fragmented packet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the reassembly algorithm must deal with the unreliability of the IP
    network. This implies that a fragment may be duplicated or a fragment may never
    reach the destination. The destination can easily detect fragment duplication
    thanks to the Fragment Offset. To deal with fragment losses, the reassembly algorithm
    must bind the time during which the fragments of a packet are stored in its buffer
    while the packet is being reassembled. This can be implemented by starting a timer
    when the first fragment of a packet is received. If the packet has not been reassembled
    upon expiration of the timer, all fragments are discarded and the packet is considered
    to be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Header compression on low bandwidth links
  prefs: []
  type: TYPE_NORMAL
- en: Given the size of the IPv6 header, it can cause huge overhead on low bandwidth
    links, especially when small packets are exchanged such as for Voice over IP applications.
    In such environments, several techniques can be used to reduce the overhead. A
    first solution is to use data compression in the datalink layer to compress all
    the information exchanged [[Thomborson1992]](../bibliography.html#thomborson1992).
    These techniques are similar to the data compression algorithms used in tools
    such as *compress(1)* or *gzip(1)* [**RFC 1951**](https://datatracker.ietf.org/doc/html/rfc1951.html).
    They compress streams of bits without taking advantage of the fact that these
    streams contain IP packets with a known structure. A second solution is to compress
    the IP and TCP header. These header compression techniques, such as the one defined
    in [**RFC 5795**](https://datatracker.ietf.org/doc/html/rfc5795.html) take advantage
    of the redundancy found in successive packets from the same flow to significantly
    reduce the size of the protocol headers. Another solution is to define a compressed
    encoding of the IPv6 header that matches the capabilities of the underlying datalink
    layer [**RFC 4944**](https://datatracker.ietf.org/doc/html/rfc4944.html).
  prefs: []
  type: TYPE_NORMAL
- en: The last type of IPv6 header extension is the Routing header. The `type 0` routing
    header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    is an example of an IPv6 option that must be processed by some routers. This option
    is encoded as shown in [Fig. 123](#fig-ipv6-rh0).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/ipv6-routing-0.svg](../Images/276a7739af129da2cd8c3b5ec430d381.png)](../_images/ipv6-routing-0.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 123 The Type 0 routing header ([**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html))[#](#id45
    "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: The type 0 routing option was intended to allow a host to indicate a loose source
    route that should be followed by a packet by specifying the addresses of some
    of the routers that must forward this packet. Unfortunately, further work with
    this routing header, including an entertaining demonstration with [scapy](https://www.secdev.org/projects/scapy/)
    [[BE2007]](../bibliography.html#be2007) , revealed severe security problems with
    this routing header. For this reason, loose source routing with the type 0 routing
    header has been removed from the IPv6 specification [**RFC 5095**](https://datatracker.ietf.org/doc/html/rfc5095.html).
  prefs: []
  type: TYPE_NORMAL
- en: '### ICMP version 6[#](#icmp-version-6 "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes necessary for intermediate routers or the destination host to
    inform the sender of the packet of a problem that occurred while processing a
    packet. In the TCP/IP protocol suite, this reporting is done by the Internet Control
    Message Protocol (ICMP). ICMPv6 is defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html).
    It is used both to report problems that occurred while processing an IPv6 packet,
    but also to distribute addresses.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 messages are carried inside IPv6 packets (the Next Header field for ICMPv6
    is `58`). Each ICMP message contains a 32 bits header with an 8 bits type field,
    a code field and a 16 bits checksum computed over the entire ICMPv6 message. The
    message body contains a copy of the IPv6 packet in error. The ICMPv6 header is
    shown in [Fig. 124](#fig-icmpv6-header).
  prefs: []
  type: TYPE_NORMAL
- en: '[![../_images/icmpv6.svg](../Images/8440c110b309073d9f6a09bf2e22fccb.png)](../_images/icmpv6.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Fig. 124 ICMP version 6 packet format[#](#id46 "Link to this image")
  prefs: []
  type: TYPE_NORMAL
- en: 'ICMPv6 specifies two classes of messages : error messages that indicate a problem
    in handling a packet and informational messages. Four types of error messages
    are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`Destination Unreachable. Such an ICMPv6 message is sent when the destination
    address of a packet is unreachable. The code field of the ICMP header contains
    additional information about the type of unreachability. The following codes are
    specified in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0` : No route to destination. This indicates that the router that sent the
    ICMPv6 message did not have a route towards the packet’s destination'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` : Communication with destination administratively prohibited. This indicates
    that a firewall has refused to forward the packet towards its final destination.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Beyond scope of source address. This message can be sent if the source
    is using link-local addresses to reach a global unicast address outside its subnet.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Address unreachable. This message indicates that the packet reached the
    subnet of the destination, but the host that owns this destination address cannot
    be reached.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Port unreachable. This message indicates that the IPv6 packet was received
    by the destination, but there was no application listening to the specified port.'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2` : Packet Too Big. The router that was to send the ICMPv6 message received
    an IPv6 packet that is larger than the MTU of the outgoing link. The ICMPv6 message
    contains the MTU of this link in bytes. This allows the sending host to implement
    Path MTU discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`3` : Time Exceeded. This error message can be sent either by a router or by
    a host. A router would set code to 0 to report the reception of a packet whose
    Hop Limit reached 0. A host would set code to 1 to report that it was unable to
    reassemble received IPv6 fragments.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`4` : Parameter Problem. This ICMPv6 message is used to report either the reception
    of an IPv6 packet with an erroneous header field (code 0) or an unknown Next Header
    or IP option (codes 1 and 2). In this case, the message body contains the erroneous
    IPv6 packet and the first 32 bits of the message body contain a pointer to the
    error.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The Destination Unreachable ICMP error message is returned when a packet cannot
    be forwarded to its final destination. The first four ICMPv6 error messages (type
    `1`, codes `0-3`) are generated by routers while hosts may return code `4` when
    there is no application bound to the corresponding port number.
  prefs: []
  type: TYPE_NORMAL
- en: The Packet Too Big ICMP messages enable the source host to discover the MTU
    size that it can safely use to reach a given destination. To understand its operation,
    consider the (academic) scenario shown in [Fig. 125](#fig-ipv6-mtu-discovery).
    In this figure, the labels on each link represent the maximum packet size supported
    by this link.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure made with TikZ](../Images/e23b2c7ce0cb93b476e5ddffb5e9c552.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 125 Example for IPv6 MTU discovery
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `A` sends a 1500 bytes packet, `R1` will return an ICMPv6 error message indicating
    a maximum packet length of 1400 bytes. `A` would then fragment the packet before
    retransmitting it. The small fragment would go through, but the large fragment
    will be refused by `R2` that would return an ICMPv6 error message. `A` can fragment
    again the packet and send it to the final destination as two fragments.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, an IPv6 implementation does not store the transmitted packets to
    be able to retransmit them if needed. However, since TCP (and SCTP) buffer the
    segments that they transmit, a similar approach can be used in transport protocols
    to detect the largest MTU on a path towards a given destination. This technique
    is called PathMTU Discovery [**RFC 1981**](https://datatracker.ietf.org/doc/html/rfc1981.html).
  prefs: []
  type: TYPE_NORMAL
- en: When a TCP segment is transported in an IP packet that is fragmented in the
    network, the loss of a single fragment forces TCP to retransmit the entire segment
    (and thus all the fragments). If TCP was able to send only packets that do not
    require fragmentation in the network, it could retransmit only the information
    that was lost in the network. In addition, IP reassembly causes several challenges
    at high speed as discussed in [**RFC 4963**](https://datatracker.ietf.org/doc/html/rfc4963.html).
    Using IP fragmentation to allow UDP applications to exchange large messages raises
    several security issues [[KPS2003]](../bibliography.html#kps2003).
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 is used by TCP implementations to discover the largest MTU size that
    is allowed to reach a destination host without causing network fragmentation.
    A TCP implementation parses the Packets Too Big ICMP messages that it receives.
    These ICMP messages contain the MTU of the router’s outgoing link in their Data
    field. Upon reception of such an ICMP message, the source TCP implementation adjusts
    its Maximum Segment Size (MSS) so that the packets containing the segments that
    it sends can be forwarded by this router without requiring fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two types of informational ICMPv6 messages are defined in [**RFC 4443**](https://datatracker.ietf.org/doc/html/rfc4443.html)
    : echo request and echo reply, which are used to test the reachability of a destination
    by using *ping6(8)*. Each host is supposed to reply with an ICMP Echo reply message
    when it receives an ICMP Echo request message. A sample usage of *ping6(8)* is
    shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another very useful debugging tool is *traceroute6(8)*. The traceroute man page
    describes this tool as “print the route packets take to network host”. traceroute
    uses the Time exceeded ICMP messages to discover the intermediate routers on the
    path towards a destination. The principle behind traceroute is very simple. When
    a router receives an IP packet whose Hop Limit is set to `1` it is forced to return
    to the sending host a Time exceeded ICMP message containing the header and the
    first bytes of the discarded packet. To discover all routers on a network path,
    a simple solution is to first send a packet whose Hop Limit is set to 1, then
    a packet whose Hop Limit is set to 2, etc. A sample traceroute6 output is shown
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Rate limitation of ICMP messages
  prefs: []
  type: TYPE_NORMAL
- en: High-end hardware based routers use special purpose chips on their interfaces
    to forward IPv6 packets at line rate. These chips are optimized to process correct
    IP packets. They are not able to create ICMP messages at line rate. When such
    a chip receives an IP packet that triggers an ICMP message, it interrupts the
    main CPU of the router and the software running on this CPU processes the packet.
    This CPU is much slower than the hardware acceleration found on the interfaces
    [[Gill2004]](../bibliography.html#gill2004). It would be overloaded if it had
    to process IP packets at line rate and generate one ICMP message for each received
    packet. To protect this CPU, high-end routers limit the rate at which the hardware
    can interrupt the main CPU and thus the rate at which ICMP messages can be generated.
    This implies that not all erroneous IP packets cause the transmission of an ICMP
    message. The risk of overloading the main CPU of the router is also the reason
    why using hop-by-hop IPv6 options, including the router alert option is discouraged
    [[#falert]_](#id49).
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
