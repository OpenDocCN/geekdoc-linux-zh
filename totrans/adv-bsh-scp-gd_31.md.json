["```sh command-1 && command-2 && command-3 && ... command-n\n```", "```sh equation()\n\n{  # core algorithm used for doubling and halving the coordinates\n   [[ ${cdx} ]] && ((y=cy+(ccy-cdy)${2}2))\n   eval ${1}+=\\\"${x} ${y} \\\"\n}\n```", "```sh #!/bin/bash\n# and list\n\nif [ ! -z \"$1\" ] && echo \"Argument #1 = $1\" && [ ! -z \"$2\" ] && \\\n#                ^^                         ^^               ^^\necho \"Argument #2 = $2\"\nthen\n  echo \"At least 2 arguments passed to script.\"\n  # All the chained commands return true.\nelse\n  echo \"Fewer than 2 arguments passed to script.\"\n  # At least one of the chained commands returns false.\nfi  \n# Note that \"if [ ! -z $1 ]\" works, but its alleged equivalent,\n#   \"if [ -n $1 ]\" does not.\n#     However, quoting fixes this.\n#  if \"[ -n \"$1\" ]\" works.\n#           ^  ^    Careful!\n# It is always best to QUOTE the variables being tested.\n\n# This accomplishes the same thing, using \"pure\" if/then statements.\nif [ ! -z \"$1\" ]\nthen\n  echo \"Argument #1 = $1\"\nfi\nif [ ! -z \"$2\" ]\nthen\n  echo \"Argument #2 = $2\"\n  echo \"At least 2 arguments passed to script.\"\nelse\n  echo \"Fewer than 2 arguments passed to script.\"\nfi\n# It's longer and more ponderous than using an \"and list\".\n\nexit $?\n```", "```sh #!/bin/bash\n\nARGS=1        # Number of arguments expected.\nE_BADARGS=85  # Exit value if incorrect number of args passed.\n\ntest $# -ne $ARGS && \\\n#    ^^^^^^^^^^^^ condition #1\necho \"Usage: `basename $0` $ARGS argument(s)\" && exit $E_BADARGS\n#                                             ^^\n#  If condition #1 tests true (wrong number of args passed to script),\n#+ then the rest of the line executes, and script terminates.\n\n# Line below executes only if the above test fails.\necho \"Correct number of arguments passed to this script.\"\n\nexit 0\n\n# To check exit value, do a \"echo $?\" after script termination.\n```", "```sh arg1=$@ && [ -z \"$arg1\" ] && arg1=DEFAULT\n\n              # Set $arg1 to command-line arguments, if any.\n              # But . . . set to DEFAULT if not specified on command-line.\n```", "```sh command-1 &#124;&#124; command-2 &#124;&#124; command-3 &#124;&#124; ... command-n\n```", "```sh #!/bin/bash\n\n#  delete.sh, a not-so-cunning file deletion utility.\n#  Usage: delete filename\n\nE_BADARGS=85\n\nif [ -z \"$1\" ]\nthen\n  echo \"Usage: `basename $0` filename\"\n  exit $E_BADARGS  # No arg? Bail out.\nelse  \n  file=$1          # Set filename.\nfi  \n\n[ ! -f \"$file\" ] && echo \"File \\\"$file\\\" not found. \\\nCowardly refusing to delete a nonexistent file.\"\n# AND LIST, to give error message if file not present.\n# Note echo message continuing on to a second line after an escape.\n\n[ ! -f \"$file\" ] &#124;&#124; (rm -f $file; echo \"File \\\"$file\\\" deleted.\")\n# OR LIST, to delete file if present.\n\n# Note logic inversion above.\n# AND LIST executes on true, OR LIST on false.\n\nexit $?\n```", "```sh # ==> The following snippets from the /etc/rc.d/init.d/single\n#+==> script by Miquel van Smoorenburg\n#+==> illustrate use of \"and\" and \"or\" lists.\n# ==> \"Arrowed\" comments added by document author.\n\n[ -x /usr/bin/clear ] && /usr/bin/clear\n  # ==> If /usr/bin/clear exists, then invoke it.\n  # ==> Checking for the existence of a command before calling it\n  #+==> avoids error messages and other awkward consequences.\n\n  # ==> . . .\n\n# If they want to run something in single user mode, might as well run it...\nfor i in /etc/rc1.d/S[0-9][0-9]* ; do\n        # Check if the script is there.\n        [ -x \"$i\" ] &#124;&#124; continue\n  # ==> If corresponding file in $PWD *not* found,\n  #+==> then \"continue\" by jumping to the top of the loop.\n\n        # Reject backup files and files generated by rpm.\n        case \"$1\" in\n                *.rpmsave&#124;*.rpmorig&#124;*.rpmnew&#124;*~&#124;*.orig)\n                        continue;;\n        esac\n        [ \"$i\" = \"/etc/rc1.d/S00single\" ] && continue\n  # ==> Set script name, but don't execute it yet.\n        $i start\ndone\n\n  # ==> . . .\n```", "```sh false && true &#124;&#124; echo false         # false\n\n# Same result as\n( false && true ) &#124;&#124; echo false     # false\n# But NOT\nfalse && ( true &#124;&#124; echo false )     # (nothing echoed)\n\n#  Note left-to-right grouping and evaluation of statements.\n\n#  It's usually best to avoid such complexities.\n\n#  Thanks, S.C.\n```"]