<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Datalink layer technologies#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Datalink layer technologies#</h1>
<blockquote>原文：<a href="https://4ed.computer-networking.info/syllabus/default/networks/lan.html">https://4ed.computer-networking.info/syllabus/default/networks/lan.html</a></blockquote>

<p>In this chapter, we review the key characteristics of several datalink layer technologies. We discuss in more detail the technologies that are widely used today. A detailed survey of all datalink layer technologies would be outside the scope of this book.</p>
<section id="the-point-to-point-protocol">
<span id="index-0"/><h2>The Point-to-Point Protocol<a class="headerlink" href="#the-point-to-point-protocol" title="Link to this heading">#</a></h2>
<p>Many point-to-point datalink layers <a class="footnote-reference brackets" href="#flapb" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> have been developed, starting in the 1960s. In this section, we focus on the protocols that are often used to transport IP packets between hosts or routers that are directly connected by a point-to-point link. This link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.</p>
<p id="index-1">The first solution to transport IP packets over a serial line was proposed in <span class="target" id="index-2"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1055.html"><strong>RFC 1055</strong></a> and is known as <cite>Serial Line IP</cite> (SLIP). SLIP is a simple character stuffing technique applied to IP packets. SLIP defines two special characters : <cite>END</cite> (decimal 192) and <cite>ESC</cite> (decimal 219). <cite>END</cite> appears at the beginning and at the end of each transmitted IP packet and the sender adds <cite>ESC</cite> before each <cite>END</cite> character inside each transmitted IP packet. SLIP only supports the transmission of IP packets and it assumes that the two communicating hosts/routers have been manually configured with each other’s IP address. SLIP was mainly used over links offering bandwidth of often less than 20 Kbps.  On such a low bandwidth link, sending 20 bytes of IP header followed by 20 bytes of TCP header for each TCP segment takes a lot of time. This initiated the development of a family of compression techniques to efficiently compress the TCP/IP headers. The first header compression technique proposed in <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1144.html"><strong>RFC 1144</strong></a> was designed to exploit the redundancy between several consecutive segments that belong to the same TCP connection. In all these segments, the IP addresses and port numbers are always the same. Furthermore, fields such as the sequence and acknowledgment numbers do not change in a random way. <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1144.html"><strong>RFC 1144</strong></a> defined simple techniques to reduce the redundancy found in successive segments. The development of header compression techniques continued and there are still improvements being developed now <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5795.html"><strong>RFC 5795</strong></a>.</p>
<p>While SLIP was implemented and used in some environments, it had several limitations discussed in <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1055.html"><strong>RFC 1055</strong></a>. The <cite>Point-to-Point Protocol</cite> (PPP) was designed shortly after and is specified in <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1548.html"><strong>RFC 1548</strong></a>. PPP aims to support IP and other network layer protocols over various types of serial lines. PPP is in fact a family of three protocols that are used together :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The <cite>Point-to-Point Protocol</cite> defines the framing technique to transport network layer packets.</p></li>
<li><p>The <cite>Link Control Protocol</cite> that is used to negotiate options and authenticate the session by using username and password or other types of credentials</p></li>
<li><p>The <cite>Network Control Protocol</cite> that is specific for each network layer protocol. It is used to negotiate options that are specific for each protocol. For example, IPv4’s NCP <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1548.html"><strong>RFC 1548</strong></a> can negotiate the IPv4 address to be used, the IPv4 address of the DNS resolver. IPv6’s NCP is defined in <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5072.html"><strong>RFC 5072</strong></a>.</p></li>
</ol>
</div></blockquote>
<p>The PPP framing <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1662.html"><strong>RFC 1662</strong></a> was inspired by the datalink layer protocols standardized by ITU-T and ISO. A typical PPP frame is composed of the fields shown in the figure below. A PPP frame starts with a one byte flag containing <cite>01111110</cite>. PPP can use bit stuffing or character stuffing depending on the environment where the protocol is used. The address and control fields are present for backward compatibility reasons. The 16 bit Protocol field contains the identifier <a class="footnote-reference brackets" href="#fpppid" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> of the network layer protocol that is carried in the PPP frame. <cite>0x002d</cite> is used for an IPv4 packet compressed with <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1144.html"><strong>RFC 1144</strong></a> while <cite>0x002f</cite> is used for an uncompressed IPv4 packet. <cite>0xc021</cite> is used by the Link Control Protocol, <cite>0xc023</cite> is used by the Password Authentication Protocol (PAP). <cite>0x0057</cite> is used for IPv6 packets. PPP supports variable length packets, but LCP can negotiate a maximum packet length. The PPP frame ends with a Frame Check Sequence. The default is a 16 bits CRC, but some implementations can negotiate a 32 bits CRC. The frame ends with the <cite>01111110</cite> flag.</p>
<figure class="align-center" id="id186">
<a class="reference internal image-reference" href="../_images/ppp.svg"><img alt="../_images/ppp.svg" src="../Images/49b08aa9821170a5792f0c343aa273c5.png" style="width: 571.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ppp.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 166 </span><span class="caption-text">PPP frame format</span><a class="headerlink" href="#id186" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-12">PPP played a key role in allowing Internet Service Providers to provide dial-up access over modems in the late 1990s and early 2000s. ISPs operated modem banks connected to the telephone network. For these ISPs, a key issue was to authenticate each user connected through the telephone network. This authentication was performed by using the <cite>Extensible Authentication Protocol</cite> (EAP) defined in <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3748.html"><strong>RFC 3748</strong></a>. EAP is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dial-up lines. Several authentication methods, starting from the simple username/password pairs to more complex schemes have been defined and implemented. When ISPs started to upgrade their physical infrastructure to provide Internet access over <cite>Asymmetric Digital Subscriber Lines</cite> (ADSL), they tried to reuse their existing authentication (and billing) systems. To meet these requirements, the IETF developed specifications to allow PPP frames to be transported over other networks than the point-to-point links for which PPP was designed. Nowadays, most ADSL deployments use PPP over either ATM <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2364.html"><strong>RFC 2364</strong></a> or Ethernet <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2516.html"><strong>RFC 2516</strong></a>.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="flapb" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/LAPB">LAPB</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/HDLC">HDLC</a> were widely used datalink layer protocols.</p>
</aside>
<aside class="footnote brackets" id="fpppid" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>The IANA maintains the registry of all assigned PPP protocol fields at : <a class="reference external" href="http://www.iana.org/assignments/ppp-numbers">http://www.iana.org/assignments/ppp-numbers</a></p>
</aside>
</aside>
</section>
<section id="ethernet">
<span id="chapter-ethernet"/><h2>Ethernet<a class="headerlink" href="#ethernet" title="Link to this heading">#</a></h2>
<p>Ethernet was designed in the 1970s at the Palo Alto Research Center <a class="reference internal" href="../bibliography.html#metcalfe1976" id="id3"><span>[Metcalfe1976]</span></a>. The first prototype <a class="footnote-reference brackets" href="#fethernethistory" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> used a coaxial cable as the shared medium and 3 Mbps of bandwidth. Ethernet was improved during the late 1970s and in the 1980s, Digital Equipment, Intel and Xerox published the first official Ethernet specification <a class="reference internal" href="../bibliography.html#dix" id="id5"><span>[DIX]</span></a>. This specification defines several important parameters for Ethernet networks. The first decision was to standardize the commercial Ethernet at 10 Mbps. The second decision was the duration of the <cite>slot time</cite>. In Ethernet, a long <cite>slot time</cite> enables networks to span a long distance but forces the host to use a larger minimum frame size. The compromise was a <cite>slot time</cite> of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes.</p>
<p>The third decision was the frame format. The experimental 3 Mbps Ethernet network built at Xerox used short frames containing 8 bit source and destination addresses fields, a 16 bit type indication, up to 554 bytes of payload and a 16 bit CRC. Using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. Although the initial Ethernet specification <a class="reference internal" href="../bibliography.html#dix" id="id6"><span>[DIX]</span></a> only allowed up to 1024 hosts on an Ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. The first change was to require each host attached to an Ethernet network to have a globally unique datalink layer address. Until then, datalink layer addresses were manually configured on each host. <a class="reference internal" href="../bibliography.html#dp1981" id="id7"><span>[DP1981]</span></a> went against that state of the art and noted “<cite>Suitable installation-specific administrative procedures are also needed for assigning numbers to hosts on a network. If a host is moved from one network to another it may be necessary to change its host  number if its former number is in use on the new network. This is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). It is anticipated that in future office environments, hosts locations will change as often as telephones are changed in present-day offices.</cite>” The second change introduced by Ethernet was to encode each address as a 48 bits field <a class="reference internal" href="../bibliography.html#dp1981" id="id8"><span>[DP1981]</span></a>. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages <a class="reference internal" href="../bibliography.html#dp1981" id="id9"><span>[DP1981]</span></a> including the ability to allocate large blocks of addresses to manufacturers. Eventually, other LAN technologies opted for 48 bits addresses as well <a class="reference internal" href="../bibliography.html#ieee802" id="id10"><span>[IEEE802]</span></a> . The third change introduced by Ethernet was the definition of <cite>broadcast</cite> and <cite>multicast</cite> addresses. The need for <cite>multicast</cite> Ethernet was foreseen in <a class="reference internal" href="../bibliography.html#dp1981" id="id11"><span>[DP1981]</span></a> and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer.</p>
<p id="index-16">The datalink layer addresses used in Ethernet networks are often called MAC addresses. They are structured as shown in figure <a class="reference internal" href="#fig-ethernet-add-format"><span class="std std-numref">Fig. 167</span></a>. The first bit of the address indicates whether the address identifies a network adapter or a multicast group. The upper 24 bits are used to encode an Organization Unique Identifier (OUI). This OUI identifies a block of addresses that has been allocated by the secretariat <a class="footnote-reference brackets" href="#foui" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> that is responsible for the uniqueness of Ethernet addresses to a manufacturer. Once a manufacturer has received an OUI, it can build and sell products with one of the 16 million addresses in this block.</p>
<blockquote>
<div><div class="figure" id="id187" style="text-align: center">
<span id="fig-ethernet-add-format"/><p><img src="../Images/f3897860be3ce498f407c1420b6944b8.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f2e9d3ff34766ddc27f681efa69e39d0be36bb07.png"/></p>
<p><span class="caption-number">Fig. 167 </span><span class="caption-text">48 bits Ethernet address format</span></p>
</div></div></blockquote>
<p id="index-17">The original 10 Mbps Ethernet specification <a class="reference internal" href="../bibliography.html#dix" id="id13"><span>[DIX]</span></a> defined a simple frame format where each frame is composed of five fields. The Ethernet frame starts with a preamble (not shown in figure <a class="reference internal" href="#fig-ethernet-dix"><span class="std std-numref">Fig. 169</span></a>) that is used by the physical layer of the receiver to synchronize its clock with the sender’s clock. The first field of the frame is the destination address. As this address is placed at the beginning of the frame, an Ethernet interface can quickly verify whether it is the frame recipient and if not, cancel the processing of the arriving frame. The second field is the source address. While the destination address can be either a unicast or a multicast/broadcast address, the source address must always be a unicast address. The third field is a 16 bits integer that indicates which type of network layer packet is carried inside the frame. This field is often called the <cite>EtherType</cite>. Frequently used <cite>EtherType</cite> values <a class="footnote-reference brackets" href="#fethertype" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> include <cite>0x0800</cite> for IPv4, <cite>0x86DD</cite> for IPv6 <a class="footnote-reference brackets" href="#fipv6ether" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> and <cite>0x806</cite> for the Address Resolution Protocol (ARP).</p>
<p>The fourth part of the Ethernet frame is the payload. The minimum length of the payload is 46 bytes to ensure a minimum frame size, including the header of 512 bits. The Ethernet payload cannot be longer than 1500 bytes. This size was found reasonable when the first Ethernet specification was written. At that time, Xerox had been using its experimental 3 Mbps Ethernet that offered 554 bytes of payload and <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1122.html"><strong>RFC 1122</strong></a> required a minimum MTU of 572 bytes for IPv4. 1500 bytes was large enough to support these needs without forcing the network adapters to contain overly large memories. Furthermore, simulations and measurement studies performed in Ethernet networks revealed that CSMA/CD was able to achieve a very high utilization. This is illustrated in figure <a class="reference internal" href="#fig-ethernet-utilization"><span class="std std-numref">Fig. 168</span></a> based on <a class="reference internal" href="../bibliography.html#sh1980" id="id16"><span>[SH1980]</span></a>, which shows the channel utilization achieved in Ethernet networks containing different numbers of hosts that are sending frames of different sizes.</p>
<figure class="align-center" id="id188">
<span id="fig-ethernet-utilization"/><a class="reference internal image-reference" href="../_images/ethernet-util.png"><img alt="../_images/ethernet-util.png" src="../Images/da4b08a7d46cd9d4962e244a40694091.png" style="width: 436.79999999999995px; height: 280.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-util.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 168 </span><span class="caption-text">Impact of the frame length on the maximum channel utilization <a class="reference internal" href="../bibliography.html#sh1980" id="id17"><span>[SH1980]</span></a></span><a class="headerlink" href="#id188" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The last field of the Ethernet frame is a 32 bit Cyclical Redundancy Check (CRC). This CRC is able to catch a much larger number of transmission errors than the Internet checksum used by IP, UDP and TCP <a class="reference internal" href="../bibliography.html#sgp98" id="id18"><span>[SGP98]</span></a>. The format of the Ethernet frame is shown in figure <a class="reference internal" href="#fig-ethernet-dix"><span class="std std-numref">Fig. 169</span></a> .</p>
<figure class="align-center" id="fig-ethernet-dix">
<span id="index-19"/><a class="reference internal image-reference" href="../_images/ethernet-dix.svg"><img alt="../_images/ethernet-dix.svg" src="../Images/163da7add640c911c0e0db0efe6683b0.png" style="width: 604.0px; height: 272.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-dix.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 169 </span><span class="caption-text">Ethernet DIX frame format</span><a class="headerlink" href="#fig-ethernet-dix" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Where should the CRC be located in a frame ?</p>
<p>The transport and datalink layers usually chose different strategies to place their CRCs or checksums. Transport layer protocols usually place their CRCs or checksums in the segment header. Datalink layer protocols sometimes place their CRC in the frame header, but often in a trailer at the end of the frame. This choice reflects implementation assumptions, but also influences performance <span class="target" id="index-20"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc893.html"><strong>RFC 893</strong></a>. When the CRC is placed in the trailer, as in Ethernet, the datalink layer can compute it while transmitting the frame and insert it at the end of the transmission. All Ethernet interfaces use this optimization today. When the checksum is placed in the header, as in a TCP segment, it is impossible for the network interface to compute it while transmitting the segment. Some network interfaces provide hardware assistance to compute the TCP checksum, but this is more complex than if the TCP checksum were placed in the trailer <a class="footnote-reference brackets" href="#ftso" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p>
</div>
<p id="index-22"><span id="index-21"/>The Ethernet frame format discussed above is specified in <a class="reference internal" href="../bibliography.html#dix" id="id20"><span>[DIX]</span></a>. This is the format used to send both IPv4 <span class="target" id="index-23"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc894.html"><strong>RFC 894</strong></a> and IPv6 packets <span class="target" id="index-24"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2464.html"><strong>RFC 2464</strong></a>. After the publication of <a class="reference internal" href="../bibliography.html#dix" id="id21"><span>[DIX]</span></a>, the Institute of Electrical and Electronic Engineers (IEEE) began to standardize several Local Area Network technologies. IEEE worked on several LAN technologies, starting with Ethernet, Token Ring and Token Bus. These three technologies were completely different, but they all agreed to use the 48 bits MAC addresses specified initially for Ethernet <a class="reference internal" href="../bibliography.html#ieee802" id="id22"><span>[IEEE802]</span></a> . While developing its Ethernet standard <a class="reference internal" href="../bibliography.html#ieee802-3" id="id23"><span>[IEEE802.3]</span></a>, the IEEE 802.3 working group was confronted with a problem. Ethernet mandated a minimum payload size of 46 bytes, while some companies were looking for a LAN technology that could transparently transport short frames containing only a few bytes of payload. Such a frame can be sent by an Ethernet host by padding it to ensure that the payload is at least 46 bytes long. However since the Ethernet header <a class="reference internal" href="../bibliography.html#dix" id="id24"><span>[DIX]</span></a> does not contain a length field, it is impossible for the receiver to determine how many useful bytes were placed inside the payload field. To solve this problem, the IEEE decided to replace the <cite>Type</cite> field of the Ethernet <a class="reference internal" href="../bibliography.html#dix" id="id25"><span>[DIX]</span></a> header with a length field <a class="footnote-reference brackets" href="#ftypelen" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>. This <cite>Length</cite> field contains the number of useful bytes in the frame payload. The payload must still contain at least 46 bytes, but padding bytes are added by the sender and removed by the receiver. In order to add the <cite>Length</cite> field without significantly changing the frame format, IEEE had to remove the <cite>Type</cite> field. Without this field, it is impossible for a receiving host to identify the type of network layer packet inside a received frame. To solve this new problem, IEEE developed a completely new sublayer called the Logical Link Control <a class="reference internal" href="../bibliography.html#ieee802-2" id="id27"><span>[IEEE802.2]</span></a>. Several protocols were defined in this sublayer. One of them provided a slightly different version of the <cite>Type</cite> field of the original Ethernet frame format. Another contained acknowledgments and retransmissions to provide a reliable service… In practice, <a class="reference internal" href="../bibliography.html#ieee802-2" id="id28"><span>[IEEE802.2]</span></a> is never used to support IP in Ethernet networks. Figure <a class="reference internal" href="#fig-ethernet-8023-frame"><span class="std std-numref">Fig. 170</span></a> shows the official <a class="reference internal" href="../bibliography.html#ieee802-3" id="id29"><span>[IEEE802.3]</span></a> frame format.</p>
<figure class="align-center" id="fig-ethernet-8023-frame">
<a class="reference internal image-reference" href="../_images/ethernet-8023.svg"><img alt="../_images/ethernet-8023.svg" src="../Images/79781bc50862d2a32133ea8cd17bc68b.png" style="width: 604.0px; height: 272.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-8023.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 170 </span><span class="caption-text">Ethernet 802.3 frame format</span><a class="headerlink" href="#fig-ethernet-8023-frame" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>What is the Ethernet service ?</p>
<p>An Ethernet network provides an unreliable connectionless service. It supports three different transmission modes : <cite>unicast</cite>, <cite>multicast</cite> and <cite>broadcast</cite>. While the Ethernet service is unreliable in theory, a good Ethernet network should, in practice, provide a service that:</p>
<ul class="simple">
<li><p>delivers frames to their destination with a very high probability of successful delivery</p></li>
<li><p>does not reorder the transmitted frames</p></li>
</ul>
<p>The first property is a consequence of the utilization of CSMA/CD. The second property is a consequence of the physical organization of the Ethernet network as a shared bus. These two properties are important and all revisions to the Ethernet technology have preserved them.</p>
</div>
<p id="index-25">Several physical layers have been defined for Ethernet networks. The first physical layer, usually called 10Base5, provided 10 Mbps over a thick coaxial cable. The characteristics of the cable and the transceivers that were used then enabled the utilization of 500 meter long segments. A 10Base5 network can also include repeaters between segments.</p>
<p id="index-26">The second physical layer was 10Base2. This physical layer used a thin coaxial cable that was easier to install than the 10Base5 cable, but could not be longer than 185 meters. A 10BaseF physical layer was also defined to transport Ethernet over point-to-point optical links. The major change to the physical layer was the support of twisted pairs in the 10BaseT specification. Twisted pair cables are traditionally used to support the telephone service in office buildings. Most office buildings today are equipped with structured cabling. Several twisted pair cables are installed between any room and a central telecom closet per building or per floor in large buildings. These telecom closets act as concentration points for the telephone service but also for LANs.</p>
<p id="index-27">The introduction of the twisted pairs led to two major changes to Ethernet. The first change concerns the physical topology of the network. 10Base2 and 10Base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. A 10BaseT network is a star-shaped network. All the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. From a maintenance perspective, this is a major improvement. The cable is a weak point in 10Base2 and 10Base5 networks. Any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. With 10BaseT, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. The second major change introduced by 10BaseT was that is was impossible to build a 10BaseT network by simply connecting all the twisted pairs together. All the twisted pairs must be connected to a relay that operates in the physical layer. This relay is called an <cite>Ethernet hub</cite>. A <cite>hub</cite> is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. Some <cite>hubs</cite> are also able to convert the electrical signal from one physical layer to another (e.g. 10BaseT to 10Base2 conversion). An Ethernet hub is a relay that operates at the physical layer as shown in figure <a class="reference internal" href="#fig-ethernet-hub"><span class="std std-numref">Fig. 171</span></a>.</p>
<blockquote>
<div><div class="figure" id="id189" style="text-align: center">
<span id="fig-ethernet-hub"/><p><img src="../Images/32f9a71dd5d981a251f55babe3afd5bc.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-584cb66589f7736db42cfe159cf03f93214d29b6.png"/></p>
<p><span class="caption-number">Fig. 171 </span><span class="caption-text">Ethernet hubs in the reference model</span></p>
</div></div></blockquote>
<p id="index-28">Computers can directly be attached to Ethernet hubs. Ethernet hubs themselves can be attached to other Ethernet hubs to build a larger network. However, some important guidelines must be followed when building a complex network with hubs. First, the network topology must be a tree. As hubs are relays in the physical layer, adding a link between <cite>Hub2</cite> and <cite>Hub3</cite> in the network of figure <a class="reference internal" href="#fig-network-hubs"><span class="std std-numref">Fig. 172</span></a> would create an electrical shortcut that would completely disrupt the network. This implies that there cannot be any redundancy in a hub-based network. A failure of a hub or of a link between two hubs would partition the network into two isolated networks. Second, as hubs are relays in the physical layer, collisions can happen and must be handled by CSMA/CD as in a 10Base5 network. This implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2 microseconds <cite>slot time</cite>. If the delay is longer, collisions between short frames may not be correctly detected. This constraint limits the geographical spread of 10BaseT networks containing hubs.</p>
<figure class="align-center" id="fig-network-hubs">
<a class="reference internal image-reference" href="../_images/ethernet-net-hub.png"><img alt="../_images/ethernet-net-hub.png" src="../Images/7b0810c7bcca0cc446f10cbc40ffc06f.png" style="width: 350.0px; height: 193.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-net-hub.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 172 </span><span class="caption-text">A hierarchical Ethernet network composed of hubs</span><a class="headerlink" href="#fig-network-hubs" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-29">In the late 1980s, 10 Mbps became too slow for some applications and network manufacturers developed several LAN technologies that offered higher bandwidth, such as the 100 Mbps FDDI LAN that used optical fibers. As the development of 10Base5, 10Base2 and 10BaseT had shown that Ethernet could be adapted to different physical layers, several manufacturers started to work on 100 Mbps Ethernet and convinced IEEE to standardize this new technology that was initially called <cite>Fast Ethernet</cite>. <cite>Fast Ethernet</cite> was designed under two constraints. First, <cite>Fast Ethernet</cite> had to support twisted pairs. Although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. Second, <cite>Fast Ethernet</cite> had to be perfectly compatible with the existing 10 Mbps Ethernet to allow <cite>Fast Ethernet</cite> technology to be used initially as a backbone technology to interconnect 10 Mbps Ethernet networks. This forced <cite>Fast Ethernet</cite> to use exactly the same frame format as 10 Mbps Ethernet. This implied that the minimum <cite>Fast Ethernet</cite> frame size remained at 512 bits. To preserve CSMA/CD with this minimum frame size and 100 Mbps instead of 10 Mbps, the duration of the <cite>slot time</cite> was decreased to 5.12 microseconds.</p>
<p>The evolution of Ethernet did not stop. In 1998, the IEEE published a first standard to provide Gigabit Ethernet over optical fibers. Several other types of physical layers were added afterwards. The <a class="reference external" href="http://en.wikipedia.org/wiki/10_gigabit_Ethernet">10 Gigabit Ethernet</a> standard appeared in 2002. Work is ongoing to develop <a class="reference external" href="http://www.ieee802.org/3/ba/public/index.html">standards</a> for 40 Gigabit and 100 Gigabit Ethernet and some are thinking about <a class="reference external" href="http://www.networkworld.com/news/2009/042009-terabit-ethernet.html">Terabit Ethernet</a>. The table below lists the main Ethernet standards. A more detailed list may be found at <a class="reference external" href="http://en.wikipedia.org/wiki/Ethernet_physical_layer">http://en.wikipedia.org/wiki/Ethernet_physical_layer</a>.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Standard</p></th>
<th class="head"><p>Comments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10Base5</p></td>
<td><p>Thick coaxial cable, 500m</p></td>
</tr>
<tr class="row-odd"><td><p>10Base2</p></td>
<td><p>Thin coaxial cable, 185m</p></td>
</tr>
<tr class="row-even"><td><p>10BaseT</p></td>
<td><p>Two pairs of category 3+ UTP</p></td>
</tr>
<tr class="row-odd"><td><p>10Base-F</p></td>
<td><p>10 Mb/s over optical fiber</p></td>
</tr>
<tr class="row-even"><td><p>100Base-Tx</p></td>
<td><p>Category 5 UTP or STP, 100 m maximum</p></td>
</tr>
<tr class="row-odd"><td><p>100Base-FX</p></td>
<td><p>Two multi-mode optical fiber, 2 km maximum</p></td>
</tr>
<tr class="row-even"><td><p>1000Base-CX</p></td>
<td><p>Two pairs shielded twisted pair, 25m maximum</p></td>
</tr>
<tr class="row-odd"><td><p>1000Base-SX</p></td>
<td><p>Two multi-mode or single mode optical fibers with lasers</p></td>
</tr>
<tr class="row-even"><td><p>10 Gbps</p></td>
<td><p>Optical fiber but also Category 6 UTP</p></td>
</tr>
<tr class="row-odd"><td><p>40-100 Gbps</p></td>
<td><p>Optical fiber (experiences are performed with copper)</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fethernethistory" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>Additional information about the history of the Ethernet technology may be found at <a class="reference external" href="http://ethernethistory.typepad.com/">http://ethernethistory.typepad.com/</a></p>
</aside>
<aside class="footnote brackets" id="foui" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">4</a><span class="fn-bracket">]</span></span>
<p>Initially, the OUIs were allocated by Xerox <a class="reference internal" href="../bibliography.html#dp1981" id="id30"><span>[DP1981]</span></a>. However, once Ethernet became an IEEE and later an ISO standard, the allocation of the OUIs moved to IEEE. The list of all OUI allocations may be found at <a class="reference external" href="http://standards.ieee.org/regauth/oui/index.shtml">http://standards.ieee.org/regauth/oui/index.shtml</a></p>
</aside>
<aside class="footnote brackets" id="fethertype" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">5</a><span class="fn-bracket">]</span></span>
<p>The official list of all assigned Ethernet type values is available from <a class="reference external" href="http://standards.ieee.org/regauth/ethertype/eth.txt">http://standards.ieee.org/regauth/ethertype/eth.txt</a></p>
</aside>
<aside class="footnote brackets" id="fipv6ether" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">6</a><span class="fn-bracket">]</span></span>
<p>The attentive reader may question the need for different <cite>EtherTypes</cite> for IPv4 and IPv6 while the IP header already contains a version field that can be used to distinguish between IPv4 and IPv6 packets. Theoretically, IPv4 and IPv6 could have used the same <cite>EtherType</cite>. Unfortunately, developers of the early IPv6 implementations found that some devices did not check the version field of the IPv4 packets that they received and parsed frames whose <cite>EtherType</cite> was set to <cite>0x0800</cite> as IPv4 packets. Sending IPv6 packets to such devices would have caused disruptions. To avoid this problem, the IETF decided to apply for a distinct <cite>EtherType</cite> value for IPv6. Such a choice is now mandated by <span class="target" id="index-30"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6274.html"><strong>RFC 6274</strong></a> (section 3.1), although we can find a funny counter-example in <span class="target" id="index-31"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6214.html"><strong>RFC 6214</strong></a>.</p>
</aside>
<aside class="footnote brackets" id="ftso" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">7</a><span class="fn-bracket">]</span></span>
<p>These network interfaces compute the TCP checksum while a segment is transferred from the host memory to the network interface <a class="reference internal" href="../bibliography.html#sh2004" id="id31"><span>[SH2004]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="ftypelen" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">8</a><span class="fn-bracket">]</span></span>
<p>Fortunately, IEEE was able to define the <a class="reference internal" href="../bibliography.html#ieee802-3" id="id32"><span>[IEEE802.3]</span></a> frame format while maintaining backward compatibility with the Ethernet <a class="reference internal" href="../bibliography.html#dix" id="id33"><span>[DIX]</span></a> frame format. The trick was to only assign values above 1500 as <cite>EtherType</cite> values. When a host receives a frame, it can determine whether the frame’s format by checking its <cite>EtherType/Length</cite> field. A value lower smaller than <cite>1501</cite> is clearly a length indicator and thus an <a class="reference internal" href="../bibliography.html#ieee802-3" id="id34"><span>[IEEE802.3]</span></a> frame. A value larger than <cite>1501</cite> can only be type and thus a <a class="reference internal" href="../bibliography.html#dix" id="id35"><span>[DIX]</span></a> frame.</p>
</aside>
</aside>
<section id="ethernet-switches">
<h3>Ethernet Switches<a class="headerlink" href="#ethernet-switches" title="Link to this heading">#</a></h3>
<p id="index-32">Increasing the physical layer bandwidth as in <cite>Fast Ethernet</cite> was only one of the solutions to improve the performance of Ethernet LANs. A second solution was to replace the hubs with more intelligent devices. As <cite>Ethernet hubs</cite> operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach of the network. From a performance perspective, it would be more interesting to have devices that operate in the datalink layer and can analyze the destination address of each frame and forward the frames selectively on the link that leads to the destination. Such devices are usually called <cite>Ethernet switches</cite> <a class="footnote-reference brackets" href="#fbridges" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.  An <cite>Ethernet switch</cite> is a relay that operates in the datalink layer as is illustrated in figure <a class="reference internal" href="#fig-switch-ref-model"><span class="std std-numref">Fig. 173</span></a>.</p>
<blockquote>
<div><div class="figure" id="id190" style="text-align: center">
<span id="fig-switch-ref-model"/><p><img src="../Images/3ec5ee9e5eca2555bf183e60ae86fbcd.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e1555d4c718c2c7404c9c6f65a9b4f2f3cddf818.png"/></p>
<p><span class="caption-number">Fig. 173 </span><span class="caption-text">Ethernet switches in the reference model</span></p>
</div></div></blockquote>
<p id="index-33">An <cite>Ethernet switch</cite> understands the format of the Ethernet frames and can selectively forward frames over each interface. For this, each <cite>Ethernet switch</cite> maintains a <cite>MAC address table</cite>. This table contains, for each MAC address known by the switch, the identifier of the switch’s port over which a frame sent towards this address must be forwarded to reach its destination. This is illustrated in figure <a class="reference internal" href="#fig-operation-switch"><span class="std std-numref">Fig. 174</span></a> with the <cite>MAC address table</cite> of the bottom switch. When the switch receives a frame destined to address <cite>B</cite>, it forwards the frame on its South port. If it receives a frame destined to address <cite>D</cite>, it forwards it only on its North port.</p>
<figure class="align-center" id="fig-operation-switch">
<a class="reference internal image-reference" href="../_images/datalink-fig-013-c.png"><img alt="../_images/datalink-fig-013-c.png" src="../Images/dea7b4a82ab8e1e49a6b3ef793fecc58.png" style="width: 350.0px; height: 262.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-013-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 174 </span><span class="caption-text">Operation of Ethernet switches</span><a class="headerlink" href="#fig-operation-switch" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-34">One of the selling points of Ethernet networks is that, thanks to the utilization of 48 bits MAC addresses, an Ethernet LAN is plug and play at the datalink layer. When two hosts are attached to the same Ethernet segment or hub, they can immediately exchange Ethernet frames without requiring any configuration. It is important to retain this plug and play capability for Ethernet switches as well. This implies that Ethernet switches must be able to build their MAC address table automatically without requiring any manual configuration. This automatic configuration is performed by the <cite>MAC address learning</cite> algorithm that runs on each Ethernet switch. This algorithm extracts the source address of the received frames and remembers the port over which a frame from each source Ethernet address has been received. This information is inserted into the MAC address table that the switch uses to forward frames. This allows the switch to automatically learn the ports that it can use to reach each destination address, provided that this host has previously sent at least one frame. This is not a problem since most upper layer protocols use acknowledgments at some layer and thus even an Ethernet printer sends Ethernet frames as well.</p>
<p>The pseudo-code below details how an Ethernet switch forwards Ethernet frames. It first updates its <cite>MAC address table</cite> with the source address of the frame. The <cite>MAC address table</cite> used by some switches also contains a timestamp that is updated each time a frame is received from each known source address. This timestamp is used to remove from the <cite>MAC address table</cite> entries that have not been active during the last <cite>n</cite> minutes. This limits the growth of the <cite>MAC address table</cite>, but also allows hosts to move from one port to another. The switch uses its <cite>MAC address table</cite> to forward the received unicast frame. If there is an entry for the frame’s destination address in the <cite>MAC address table</cite>, the frame is forwarded selectively on the port listed in this entry. Otherwise, the switch does not know how to reach the destination address and it must forward the frame on all its ports except the port from which the frame has been received. This ensures that the frame will reach its destination, at the expense of some unnecessary transmissions. These unnecessary transmissions will only last until the destination has sent its first frame. Multicast and Broadcast frames are also forwarded in a similar way.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># Arrival of frame F on port P</span>
<span class="c1"># Table : MAC address table dictionary : addr-&gt;port</span>
<span class="c1"># Ports : list of all ports on the switch</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">SourceAddress</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">DestinationAddress</span>
<span class="n">Table</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>  <span class="c1">#  src heard on port P</span>
<span class="k">if</span> <span class="n">is_unicast</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">Table</span><span class="p">:</span>
        <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Table</span><span class="p">[</span><span class="n">dst</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">Ports</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
               <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># multicast or broadcast destination</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">Ports</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
            <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Security issues with Ethernet hubs and switches</p>
<p>From a security perspective, Ethernet hubs have the same drawbacks as the older coaxial cable. A host attached to a hub will be able to capture all the frames exchanged between any pair of hosts attached to the same hub.
Ethernet switches are much better from this perspective thanks to the selective forwarding, a host will usually only receive the frames destined to itself as well as the multicast, broadcast and unknown frames. However, this does not imply that switches are completely secure. There are, unfortunately, attacks against Ethernet switches. From a security perspective, the <cite>MAC address table</cite> is one of the fragile elements of an Ethernet switch. This table has a fixed size. Some low-end switches can store a few tens or a few hundreds of addresses while higher-end switches can store tens of thousands of addresses or more. From a security point of view, a limited resource can be the target of Denial of Service attacks. Unfortunately, such attacks are also possible on Ethernet switches. A malicious host could overflow the <cite>MAC address table</cite> of the switch by generating thousands of frames with random source addresses. Once the <cite>MAC address table</cite> is full, the switch needs to broadcast all the frames that it receives. At this point, an attacker will receive unicast frames that are not destined to its address. The ARP attack discussed in the previous chapter could also occur with Ethernet switches <a class="reference internal" href="../bibliography.html#vyncke2007" id="id37"><span>[Vyncke2007]</span></a>. Recent switches implement several types of defenses against these attacks, but they need to be carefully configured by the network administrator. See <a class="reference internal" href="../bibliography.html#vyncke2007" id="id38"><span>[Vyncke2007]</span></a> for a detailed discussion on security issues with Ethernet switches.</p>
</div>
<p>The <cite>MAC address learning</cite> algorithm combined with the forwarding algorithm work well in a tree-shaped network such as the one shown above. However, to deal with link and switch failures, network administrators often add redundant links to ensure that their network remains connected even after a failure. Let us consider what happens in the Ethernet network shown in figure <a class="reference internal" href="#fig-ethernet-loop"><span class="std std-numref">Fig. 175</span></a>.</p>
<figure class="align-center" id="fig-ethernet-loop">
<a class="reference internal image-reference" href="../_images/datalink-fig-014-c.png"><img alt="../_images/datalink-fig-014-c.png" src="../Images/e8f49a8642a420b51358c162a7018bf9.png" style="width: 400.0px; height: 221.60000000000002px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-014-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 175 </span><span class="caption-text">Ethernet switches in a loop</span><a class="headerlink" href="#fig-ethernet-loop" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>When all switches boot, their <cite>MAC address table</cite> is empty. Assume that host <cite>A</cite> sends a frame towards host <cite>C</cite>. Upon reception of this frame, switch1 updates its <cite>MAC address table</cite> to remember that address <cite>A</cite> is reachable via its West port. As there is no entry for address <cite>C</cite> in switch1’s <cite>MAC address table</cite>, the frame is forwarded to both switch2 and switch3. When switch2 receives the frame, its updates its <cite>MAC address table</cite> for address <cite>A</cite> and forwards the frame to host <cite>C</cite> as well as to switch3. switch3 has thus received two copies of the same frame. As switch3 does not know how to reach the destination address, it forwards the frame received from switch1 to switch2 and the frame received from switch2 to switch1… The single frame sent by host <cite>A</cite> will be continuously duplicated by the switches until their <cite>MAC address table</cite> contains an entry for address <cite>C</cite>. Quickly, all the available link bandwidth will be used to forward all the copies of this frame. As Ethernet does not contain any <cite>TTL</cite> or <cite>HopLimit</cite>, this loop will never stop.</p>
<p>The <cite>MAC address learning</cite> algorithm allows switches to be plug-and-play. Unfortunately, the loops that arise when the network topology is not a tree are a severe problem. Forcing the switches to only be used in tree-shaped networks as hubs would be a severe limitation. To solve this problem, the inventors of Ethernet switches have developed the <cite>Spanning Tree Protocol</cite>. This protocol allows switches to automatically disable ports on Ethernet switches to ensure that the network does not contain any cycle that could cause frames to loop forever.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fbridges" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">9</a><span class="fn-bracket">]</span></span>
<p>The first Ethernet relays that operated in the datalink layers were called <cite>bridges</cite>. In practice, the main difference between switches and bridges is that bridges were usually implemented in software while switches are hardware-based devices. Throughout this text, we always use <cite>switch</cite> when referring to a relay in the datalink layer, but you might still see the word <cite>bridge</cite>.</p>
</aside>
</aside>
</section>
<section id="the-spanning-tree-protocol-802-1d">
<h3>The Spanning Tree Protocol (802.1d)<a class="headerlink" href="#the-spanning-tree-protocol-802-1d" title="Link to this heading">#</a></h3>
<p>The <cite>Spanning Tree Protocol</cite> (STP), proposed in <a class="reference internal" href="../bibliography.html#perlman1985" id="id39"><span>[Perlman1985]</span></a>, is a distributed protocol that is used by switches to reduce the network topology to a spanning tree, so that there are no cycles in the topology. For example, consider the network shown in figure <a class="reference internal" href="#fig-ethernet-spanning"><span class="std std-numref">Fig. 176</span></a>. In this figure, each bold line corresponds to an Ethernet to which two Ethernet switches are attached. This network contains several cycles that must be broken to allow Ethernet switches, using the MAC address learning algorithm, to exchange frames.</p>
<figure class="align-center" id="fig-ethernet-spanning">
<a class="reference internal image-reference" href="../_images/datalink-fig-015-c.png"><img alt="../_images/datalink-fig-015-c.png" src="../Images/5a29a9d52b3209b13650c40e94203b2e.png" style="width: 350.0px; height: 219.1px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-015-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 176 </span><span class="caption-text">Spanning tree computed in a switched Ethernet network</span><a class="headerlink" href="#fig-ethernet-spanning" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this network, the STP will compute the following spanning tree. <cite>Switch1</cite> will be the root of the tree. All the interfaces of <cite>Switch1</cite>, <cite>Switch2</cite> and <cite>Switch7</cite> are part of the spanning tree. Only the interface connected to <cite>LAN B</cite> will be active on <cite>Switch9</cite>. <cite>LAN H</cite> will only be served by <cite>Switch7</cite> and the port of <cite>Switch44</cite> on <cite>LAN G</cite> will be disabled. A frame originating on <cite>LAN B</cite> and destined for <cite>LAN A</cite> will be forwarded by <cite>Switch7</cite> on <cite>LAN C</cite>, then by <cite>Switch1</cite> on <cite>LAN E</cite>, then by <cite>Switch44</cite> on <cite>LAN F</cite> and eventually by <cite>Switch2</cite> on <cite>LAN A</cite>.</p>
<p>Switches running the <cite>Spanning Tree Protocol</cite> exchange <cite>BPDUs</cite>. These <cite>BPDUs</cite> are always sent as frames with destination MAC address as the <cite>ALL_BRIDGES</cite> reserved multicast MAC address. Each switch has a unique 64 bit <cite>identifier</cite>. To ensure uniqueness, the lower 48 bits of the identifier are set to the unique MAC address allocated to the switch by its manufacturer. The high order 16 bits of the switch identifier can be configured by the network administrator to influence the topology of the spanning tree. The default value for these high order bits is 32768.</p>
<p>The switches exchange <cite>BPDUs</cite> to build the spanning tree. Intuitively, the spanning tree is built by first selecting the switch with the smallest <cite>identifier</cite> as the root of the tree. The branches of the spanning tree are then composed of the shortest paths that allow all of the switches that compose the network to be reached.
The <cite>BPDUs</cite> exchanged by the switches contain the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>identifier</cite> of the root switch (<cite>R</cite>)</p></li>
<li><p>the <cite>cost</cite> of the shortest path between the switch that sent the <cite>BPDU</cite> and the root switch (<cite>c</cite>)</p></li>
<li><p>the <cite>identifier</cite> of the switch that sent the <cite>BPDU</cite> (<cite>T</cite>)</p></li>
<li><p>the number of the switch port over which the <cite>BPDU</cite> was sent (<cite>p</cite>)</p></li>
</ul>
</div></blockquote>
<p>We will use the notation <cite>&lt;R,c,T,p&gt;</cite> to represent a <cite>BPDU</cite> whose <cite>root identifier</cite> is <cite>R</cite>, <cite>cost</cite> is <cite>c</cite> and that was sent from the port <cite>p</cite> of switch <cite>T</cite>.  The construction of the spanning tree depends on an ordering relationship among the <cite>BPDUs</cite>. This ordering relationship could be implemented by the Python function below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># returns True if bpdu b1 is better than bpdu b2</span>
<span class="k">def</span><span class="w"> </span><span class="nf">better</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">p</span><span class="p">)))</span>
</pre></div>
</div>
<p>In addition to the <cite>identifier</cite> discussed above, the network administrator can also configure a <cite>cost</cite> to be associated to each switch port. Usually, the <cite>cost</cite> of a port depends on its bandwidth and the <a class="reference internal" href="../bibliography.html#ieee802-1d" id="id40"><span>[IEEE802.1d]</span></a> standard recommends the values below. Of course, the network administrator may choose other values. We will use the notation <cite>cost[p]</cite> to indicate the cost associated to port <cite>p</cite> in this section.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Bandwidth</p></th>
<th class="head"><p>Cost</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10 Mbps</p></td>
<td><p>2000000</p></td>
</tr>
<tr class="row-odd"><td><p>100 Mbps</p></td>
<td><p>200000</p></td>
</tr>
<tr class="row-even"><td><p>1 Gbps</p></td>
<td><p>20000</p></td>
</tr>
<tr class="row-odd"><td><p>10 Gbps</p></td>
<td><p>2000</p></td>
</tr>
<tr class="row-even"><td><p>100 Gbps</p></td>
<td><p>200</p></td>
</tr>
</tbody>
</table>
</div>
<p>The <cite>Spanning Tree Protocol</cite> uses its own terminology that we illustrate in the figure above. A switch port can be in three different states : <cite>Root</cite>, <cite>Designated</cite> and <cite>Blocked</cite>. All the ports of the <cite>root</cite> switch are in the <cite>Designated</cite> state. The state of the ports on the other switches is determined based on the <cite>BPDU</cite> received on each port.</p>
<p>The <cite>Spanning Tree Protocol</cite> uses the ordering relationship to build the spanning tree. Each switch listens to <cite>BPDUs</cite> on its ports. When <cite>BPDU = &lt;R,c,T,p&gt;</cite> is received on port <cite>q</cite>, the switch computes the port’s <cite>root priority vector</cite>: <cite>V[q] = &lt;R,c+cost[q],T,p,q&gt;</cite> , where <cite>cost[q]</cite> is the cost associated to the port over which the <cite>BPDU</cite> was received. The switch stores in a table the last <cite>root priority vector</cite> received on each port. The switch then compares its own <cite>identifier</cite> with the smallest <cite>root identifier</cite> stored in this table. If its own <cite>identifier</cite> is smaller, then the switch is the root of the spanning tree and is, by definition, at a distance <cite>0</cite> of the root. The <cite>BPDU</cite> of the switch is then <cite>&lt;R,0,R,p&gt;</cite>, where <cite>R</cite> is the switch <cite>identifier</cite> and <cite>p</cite> will be set to the port number over which the <cite>BPDU</cite> is sent.</p>
<p>Otherwise, the switch chooses the best priority vector from its table, <cite>bv = &lt;R,c+cost[q’],T,p,q’&gt;</cite>. The port <cite>q’</cite>, over which this best root priority vector was learned, is the switch port that is closest to the <cite>root</cite> switch. This port becomes the <cite>Root</cite> port of the switch. There is only one <cite>Root</cite> port per switch (except for the <cite>Root</cite> switches whose ports are all <cite>Designated</cite>). The switch can then compute its own <cite>BPDU</cite> as <cite>BPDU = &lt;R,c’,S,p&gt;</cite> , where <cite>R</cite> is the <cite>root identifier</cite>, <cite>c’</cite> the cost of the best root priority vector, <cite>S</cite> the identifier of the switch and <cite>p</cite> will be replaced by the number of the port over which the <cite>BPDU</cite> will be sent.</p>
<p>To determine the state of its other ports, the switch compares its own <cite>BPDU</cite> with the last <cite>BPDU</cite> received on each port. Note that the comparison is done by using the <cite>BPDUs</cite> and not the <cite>root priority vectors</cite>. If the switch’s <cite>BPDU</cite> is better than the last <cite>BPDU</cite> of this port, the port becomes a <cite>Designated</cite> port. Otherwise, the port becomes a <cite>Blocked</cite> port.</p>
<p>The state of each port is important when considering the transmission of <cite>BPDUs</cite>. The root switch regularly sends its own <cite>BPDU</cite> over all of its (<cite>Designated</cite>) ports. This <cite>BPDU</cite> is received on the <cite>Root</cite> port of all the switches that are directly connected to the <cite>root switch</cite>. Each of these switches computes its own <cite>BPDU</cite> and sends this <cite>BPDU</cite> over all its <cite>Designated</cite> ports. These <cite>BPDUs</cite> are then received on the <cite>Root</cite> port of downstream switches, which then compute their own <cite>BPDU</cite>, etc. When the network topology is stable, switches send their own <cite>BPDU</cite> on all their <cite>Designated</cite> ports, once they receive a <cite>BPDU</cite> on their <cite>Root</cite> port. No <cite>BPDU</cite> is sent on a <cite>Blocked</cite> port. Switches listen for <cite>BPDUs</cite> on their <cite>Blocked</cite> and <cite>Designated</cite> ports, but no <cite>BPDU</cite> should be received over these ports when the topology is stable. The utilization of the ports for both <cite>BPDUs</cite> and data frames is summarized in the table below.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Port state</p></th>
<th class="head"><p>Receives BPDUs</p></th>
<th class="head"><p>Sends BPDU</p></th>
<th class="head"><p>Handles data frames</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocked</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>Root</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>Designated</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
</div>
<p>To illustrate the operation of the <cite>Spanning Tree Protocol</cite>, let us consider the simple network topology in the figure <a class="reference internal" href="#fig-stp-example"><span class="std std-numref">Fig. 177</span></a>.</p>
<figure class="align-center" id="fig-stp-example">
<a class="reference internal image-reference" href="../_images/datalink-fig-016-c.svg"><img alt="../_images/datalink-fig-016-c.svg" src="../Images/400b4ebfa6c09b6f49710e52c919a9a1.png" style="width: 561.3px; height: 478.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-016-c.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 177 </span><span class="caption-text">A simple Spanning tree computed in a switched Ethernet network</span><a class="headerlink" href="#fig-stp-example" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Assume that <cite>Switch4</cite> is the first to boot. It sends its own <cite>BPDU = &lt;4,0,4,1&gt;</cite> (resp. <cite>BPDU = &lt;4,0,4,2&gt;</cite>) on port 1 (resp. port 2). When <cite>Switch1</cite> boots, it sends <cite>BPDU = &lt;1,0,1,1&gt;</cite>. This <cite>BPDU</cite> is received by <cite>Switch4</cite>, which updates its <cite>BPDU</cite> and root priority vector tables and computes a new <cite>BPDU = &lt;1,3,4,1&gt;</cite> (resp. <cite>BPDU = &lt;1,3,4,2&gt;</cite>) on port 1 (resp. port 2). Indeed, there is only one root priority vector and hence, it is the best one. Port 1 of <cite>Switch4</cite> becomes the <cite>Root</cite> port while its second port is still in the <cite>Designated</cite> state.</p>
<p>Assume now that <cite>Switch9</cite> boots and immediately receives <cite>Switch1</cite> ‘s <cite>BPDU</cite> on port 1. <cite>Switch9</cite> computes its own <cite>BPDU = &lt;1,1,9,1&gt;</cite> (resp. <cite>BPDU = &lt;1,1,9,2&gt;</cite>) on port 1 (resp. port 2) and port 1 becomes the <cite>Root</cite> port of this switch. The <cite>BPDU</cite> is sent on port 2 of <cite>Switch9</cite> and reaches <cite>Switch4</cite>. <cite>Switch4</cite> compares the priority vectors. It notices that the last computed vector (i.e., <cite>V[2] = &lt;1,2,9,2,2&gt;</cite>) is better than <cite>V[1] = &lt;1,3,1,1,1&gt;</cite>. Thus, <cite>Switch4</cite>’s <cite>BPDU</cite> is recomputed and port 2 becomes the <cite>Root</cite> port of <cite>Switch4</cite>. <cite>Switch4</cite> compares its new <cite>BPDU = &lt;1,2,4,p&gt;</cite> with the last <cite>BPDU</cite> received on each port (except for the <cite>Root</cite> port). Port 1 becomes a <cite>Blocked</cite> port on <cite>Switch4</cite> because the <cite>BPDU=&lt;1,0,1,1&gt;</cite> received on this port is better.</p>
<p>During the computation of the spanning tree, switches discard all received data frames, as at that time the network topology is not guaranteed to be loop-free. Once that topology has been stable for some time, the switches again start to use the MAC learning algorithm to forward data frames. Only the <cite>Root</cite> and <cite>Designated</cite> ports are used to forward data frames. Switches discard all the data frames received on their <cite>Blocked</cite> ports and never forward frames on these ports.</p>
<p>Switches, ports and links can fail in a switched Ethernet network. When a failure occurs, the switches must be able to recompute the spanning tree to recover from the failure. The <cite>Spanning Tree Protocol</cite> relies on regular transmissions of the <cite>BPDUs</cite> to detect these failures. A <cite>BPDU</cite> contains two additional fields : the <cite>Age</cite> of the <cite>BPDU</cite> and the <cite>Maximum Age</cite>. The <cite>Age</cite> contains the amount of time that has passed since the root switch initially originated the <cite>BPDU</cite>. The root switch sends its <cite>BPDU</cite> with an <cite>Age</cite> of zero and each switch that computes its own <cite>BPDU</cite> increments its <cite>Age</cite> by one. The <cite>Age</cite> of the <cite>BPDUs</cite> stored on a switch’s table is also incremented every second. A <cite>BPDU</cite> expires when its <cite>Age</cite> reaches the <cite>Maximum Age</cite>. When the network is stable, this does not happen as <cite>BPDU</cite> s are regularly sent by the <cite>root</cite> switch and downstream switches. However, if the <cite>root</cite> fails or the network becomes partitioned, <cite>BPDU</cite> will expire and switches will recompute their own <cite>BPDU</cite> and restart the <cite>Spanning Tree Protocol</cite>. Once a topology change has been detected, the forwarding of the data frames stops as the topology is not guaranteed to be loop-free. Additional details about the reaction to failures may be found in <a class="reference internal" href="../bibliography.html#ieee802-1d" id="id41"><span>[IEEE802.1d]</span></a>.</p>
</section>
<section id="virtual-lans">
<span id="index-35"/><h3>Virtual LANs<a class="headerlink" href="#virtual-lans" title="Link to this heading">#</a></h3>
<p>Another important advantage of Ethernet switches is the ability to create Virtual Local Area Networks (VLANs). A virtual LAN can be defined as a <cite>set of ports attached to one or more Ethernet switches</cite>. A switch can support several VLANs and it runs one MAC learning algorithm for each Virtual LAN. When a switch receives a frame with an unknown or a multicast destination, it forwards it over all the ports that belong to the same Virtual LAN but not over the ports that belong to other Virtual LANs. Similarly, when a switch learns a source address on a port, it associates it to the Virtual LAN of this port and uses this information only when forwarding frames on this Virtual LAN.</p>
<p>Figure <a class="reference internal" href="#fig-vlan"><span class="std std-numref">Fig. 178</span></a> illustrates a switched Ethernet network with three Virtual LANs. <cite>VLAN2</cite> and <cite>VLAN3</cite> only require a local configuration of switch <cite>S1</cite>. Host <cite>C</cite> can exchange frames with host <cite>D</cite>, but not with hosts that are outside of its VLAN. <cite>VLAN1</cite> is more complex as there are ports of this VLAN on several switches. To support such VLANs, local configuration is not sufficient anymore. When a switch receives a frame from another switch, it must be able to determine the VLAN in which the frame originated to use the correct MAC table to forward the frame. This is done by assigning an identifier to each Virtual LAN and placing this identifier inside the headers of the frames that are exchanged between switches.</p>
<figure class="align-center" id="fig-vlan">
<a class="reference internal image-reference" href="../_images/datalink-fig-017-c.png"><img alt="../_images/datalink-fig-017-c.png" src="../Images/2d641cc82f586881a3a072f7fc5bfdc8.png" style="width: 350.0px; height: 127.39999999999999px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-017-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 178 </span><span class="caption-text">Virtual Local Area Networks in a switched Ethernet network</span><a class="headerlink" href="#fig-vlan" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>IEEE defined in the <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id42"><span>[IEEE802.1q]</span></a> standard a special header to encode the VLAN identifiers. This 32 bit header includes a 12 bit VLAN field that contains the VLAN identifier of each frame. The format of the <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id43"><span>[IEEE802.1q]</span></a> header is shown in figure <a class="reference internal" href="#fig-8021q"><span class="std std-numref">Fig. 179</span></a>.</p>
<figure class="align-center" id="fig-8021q">
<a class="reference internal image-reference" href="../_images/8021q.svg"><img alt="../_images/8021q.svg" src="../Images/a5322aedde97417cdbe8bf165a0df75e.png" style="width: 571.0px; height: 96.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/8021q.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 179 </span><span class="caption-text">Format of the 802.1q header</span><a class="headerlink" href="#fig-8021q" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id44"><span>[IEEE802.1q]</span></a> header is inserted immediately after the source MAC address in the Ethernet frame (i.e. before the EtherType field). The maximum frame size is increased by 4 bytes. It is encoded in 32 bits and contains four fields. The Tag Protocol Identifier is set to <cite>0x8100</cite> to allow the receiver to detect the presence of this additional header. The <cite>Priority Code Point</cite> (PCP) is a three bit field that is used to support different transmission priorities for the frame. Value <cite>0</cite> is the lowest priority and value <cite>7</cite> the highest. Frames with a higher priority can expect to be forwarded earlier than frames having a lower priority. The <cite>C</cite> bit is used for compatibility between Ethernet and Token Ring networks. The last 12 bits of the 802.1q header contain the VLAN identifier. Value <cite>0</cite> indicates that the frame does not belong to any VLAN while value <cite>0xFFF</cite> is reserved. This implies that 4094 different VLAN identifiers can be used in an Ethernet network.</p>
</section>
</section>
<section id="wireless-networks">
<h2>802.11 wireless networks<a class="headerlink" href="#wireless-networks" title="Link to this heading">#</a></h2>
<p>The radio spectrum is a limited resource that must be shared by everyone. During most of the twentieth century, governments and international organizations have regulated most of the radio spectrum. This regulation controls the utilization of the radio spectrum, in order to prevent interference among different users. A company that wants to use a frequency range in a given region must apply for a license from the regulator. Most regulators charge a fee for the utilization of the radio spectrum and some governments have encouraged competition among companies bidding for the same frequency to increase the license fees.</p>
<p>In the 1970s, after the first experiments with ALOHANet, interest in wireless networks grew. Many experiments were done on and outside the ARPANet. One of these experiments was the <a class="reference external" href="http://news.bbc.co.uk/2/hi/programmes/click_online/8639590.stm">first mobile phone</a> , which was developed and tested in 1973. This experimental mobile phone was the starting point for the first generation analog mobile phones. Given the growing demand for mobile phones, it was clear that the analog mobile phone technology was not sufficient to support a large number of users.  To support more users and new services, researchers in several countries worked on the development of digital mobile telephones. In 1987, several European countries decided to develop the standards for a common cellular telephone system across Europe : the <cite>Global System for Mobile Communications</cite> (GSM). Since then, the standards have evolved and more than three billion users are connected to GSM networks today.</p>
<p id="index-36">While most of the frequency ranges of the radio spectrum are reserved for specific applications and require a special license, there are a few exceptions. These exceptions are known as the <a class="reference external" href="http://en.wikipedia.org/wiki/ISM_band">Industrial, Scientific and Medical</a> (ISM) radio bands. These bands can be used for industrial, scientific and medical applications without requiring a license from the regulator. For example, some radio-controlled models use the 27 MHz ISM band and some cordless telephones operate in the 915 MHz ISM. In 1985, the 2.400-2.500 GHz band was added to the list of ISM bands. This frequency range corresponds to the frequencies that are emitted by microwave ovens. Sharing this band with licensed applications would have likely caused interference, given the large number of microwave ovens that are used. Despite the risk of interference with microwave ovens, the opening of the 2.400-2.500 GHz allowed the networking industry to develop several wireless network techniques to allow computers to exchange data without using cables. In this section, we discuss in more detail the most popular one, i.e. the WiFi <a class="reference internal" href="../bibliography.html#ieee802-11" id="id45"><span>[IEEE802.11]</span></a> family of wireless networks. Other wireless networking techniques such as <a class="reference external" href="http://en.wikipedia.org/wiki/BlueTooth">BlueTooth</a> or <a class="reference external" href="http://en.wikipedia.org/wiki/HiperLAN">HiperLAN</a> use the same frequency range.</p>
<p>Today, WiFi is a very popular wireless networking technology. There are more than several hundreds of millions of WiFi devices. The development of this technology started in the late 1980s with the <a class="reference external" href="http://en.wikipedia.org/wiki/WaveLAN">WaveLAN</a> proprietary wireless network. WaveLAN operated at 2 Mbps and used different frequency bands in different regions of the world. In the early 1990s, the <a class="reference external" href="https://www.ieee.org">IEEE</a> created the <a class="reference external" href="http://www.ieee802.org/11/">802.11 working group</a> to standardize a family of wireless network technologies. This working group was very prolific and produced several wireless networking standards that use different frequency ranges and different physical layers. The table below provides a summary of the main 802.11 standards.</p>
<div class="pst-scrollable-table-container"><table class="table" id="table-wifi">
<thead>
<tr class="row-odd"><th class="head"><p>Standard</p></th>
<th class="head"><p>Frequency</p></th>
<th class="head"><p>Typical
throughput</p></th>
<th class="head"><p>Max
bandwidth</p></th>
<th class="head"><p>Range (m)
indoor/outdoor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>802.11</p></td>
<td><p>2.4 GHz</p></td>
<td><p>0.9 Mbps</p></td>
<td><p>2 Mbps</p></td>
<td><p>20/100</p></td>
</tr>
<tr class="row-odd"><td><p>802.11a</p></td>
<td><p>5 GHz</p></td>
<td><p>23 Mbps</p></td>
<td><p>54 Mbps</p></td>
<td><p>35/120</p></td>
</tr>
<tr class="row-even"><td><p>802.11b</p></td>
<td><p>2.4 GHz</p></td>
<td><p>4.3 Mbps</p></td>
<td><p>11 Mbps</p></td>
<td><p>38/140</p></td>
</tr>
<tr class="row-odd"><td><p>802.11g</p></td>
<td><p>2.4 GHz</p></td>
<td><p>19 Mbps</p></td>
<td><p>54 Mbps</p></td>
<td><p>38/140</p></td>
</tr>
<tr class="row-even"><td><p>802.11n</p></td>
<td><p>2.4/5 GHz</p></td>
<td><p>74 Mbps</p></td>
<td><p>150 Mbps</p></td>
<td><p>70/250</p></td>
</tr>
</tbody>
</table>
</div>
<p>When developing its family of standards, the <a class="reference external" href="http://www.ieee802.org/11/">IEEE 802.11 working group</a> took a similar approach as the <a class="reference external" href="http://www.ieee802.org/3/">IEEE 802.3 working group</a> that developed various types of physical layers for Ethernet networks. 802.11 networks use the CSMA/CA Medium Access Control technique described earlier and they all assume the same architecture and use the same frame format.</p>
<p id="index-37">The architecture of WiFi networks is slightly different from the Local Area Networks that we have discussed until now. There are, in practice, two main types of WiFi networks : <cite>independent</cite> or <cite>adhoc</cite> networks  and <cite>infrastructure</cite> networks <a class="footnote-reference brackets" href="#fbss" id="id46" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. An <cite>independent</cite> or <cite>adhoc</cite> network is composed of a set of devices that communicate with each other. These devices play the same role and the <cite>adhoc</cite> network is usually not connected to the global Internet. <cite>Adhoc</cite> networks are used when for example a few laptops need to exchange information or to connect a computer with a WiFi printer.</p>
<figure class="align-center" id="fig-wifi-adhoc">
<a class="reference internal image-reference" href="../_images/datalink-fig-018-c.png"><img alt="../_images/datalink-fig-018-c.png" src="../Images/04f0be24510b17bef06b3589cb0893eb.png" style="width: 300.0px; height: 240.6px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-018-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 180 </span><span class="caption-text">An 802.11 independent or adhoc network</span><a class="headerlink" href="#fig-wifi-adhoc" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-38">Most WiFi networks are <cite>infrastructure</cite> networks. An <cite>infrastructure</cite> network contains one or more <cite>access points</cite> that are attached to a fixed Local Area Network (usually an Ethernet network) that is connected to other networks such as the Internet. Figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-wifi-infra</span></code> shows such a network with two access points and four WiFi devices. Each WiFi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the LAN.</p>
<figure class="align-center" id="fig-wifi-infra">
<a class="reference internal image-reference" href="../_images/datalink-fig-019-c.png"><img alt="../_images/datalink-fig-019-c.png" src="../Images/f0d5e9e6d0d36f1759d63a3558c0f00a.png" style="width: 350.0px; height: 197.39999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-019-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 181 </span><span class="caption-text">An 802.11 infrastructure network</span><a class="headerlink" href="#fig-wifi-infra" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>An 802.11 access point is a relay that operates in the datalink layer like switches. Figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-wifi-ap</span></code> represents the layers of the reference model that are involved when a WiFi host communicates with a host attached to an Ethernet network through an access point.</p>
<blockquote>
<div><div class="figure" id="id191" style="text-align: center">
<span id="fig-wifi-ap"/><p><img src="../Images/0faeff9a8c796e457aba98b2fbbe785f.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-a62a95cfae1b52cdf547afc8f83e99597b9bda64.png"/></p>
<p><span class="caption-number">Fig. 182 </span><span class="caption-text">An 802.11 access point</span></p>
</div></div></blockquote>
<p id="index-39">802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in Ethernet LANs. We review the key parts of the 802.11 frames. Additional details may be found in <a class="reference internal" href="../bibliography.html#ieee802-11" id="id47"><span>[IEEE802.11]</span></a> and <a class="reference internal" href="../bibliography.html#gast2002" id="id48"><span>[Gast2002]</span></a> . An 802.11 frame contains a fixed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits CRC. Although the payload can contain up to 2324 bytes, most 802.11 deployments use a maximum payload size of 1500 bytes as they are used in <cite>infrastructure</cite> networks attached to Ethernet LANs. An 802.11 data frame is shown in figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-80211-packet</span></code>.</p>
<figure class="align-center" id="fig-80211-packet">
<a class="reference internal image-reference" href="../_images/80211.svg"><img alt="../_images/80211.svg" src="../Images/d4417bb14a34ecaa4ca9eb5590e752b4.png" style="width: 571.0px; height: 352.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/80211.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 183 </span><span class="caption-text">802.11 data frame format</span><a class="headerlink" href="#fig-80211-packet" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The first part of the 802.11 header is the 16 bit <cite>Frame Control</cite> field. This field contains flags that indicate the type of frame (data frame, RTS/CTS, acknowledgment, management frames, etc), whether the frame is sent to or from a fixed LAN, etc <a class="reference internal" href="../bibliography.html#ieee802-11" id="id49"><span>[IEEE802.11]</span></a>. The <cite>Duration</cite> is a 16 bit field that is used to reserve the transmission channel. In data frames, the <cite>Duration</cite> field is usually set to the time required to transmit one acknowledgment frame after a SIFS delay. Note that the <cite>Duration</cite> field must be set to zero in multicast and broadcast frames. As these frames are not acknowledged, there is no need to reserve the transmission channel after their transmission. The <cite>Sequence control</cite> field contains a 12 bits sequence number that is incremented for each data frame and a 4 bits fragment number.</p>
<p>The astute reader may have noticed that the 802.11 data frames contain three 48-bits address fields <a class="footnote-reference brackets" href="#f4addresses" id="id50" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> . This is surprising compared to other protocols in the network and datalink layers whose headers only contain a source and a destination address. The need for a third address in the 802.11 header comes from the <cite>infrastructure</cite> networks. In such a network, frames are usually exchanged between routers and servers attached to the LAN and WiFi devices attached to one of the access points. The role of the three address fields is specified by bit flags in the <cite>Frame Control</cite> field.</p>
<p>When a frame is sent from a WiFi device to a server attached to the same LAN as the access point, the first address of the frame is set to the MAC address of the access point, the second address is set to the MAC address of the source WiFi device and the third address is the address of the final destination on the LAN. When the server replies, it sends an Ethernet frame whose source address is its MAC address and the destination address is the MAC address of the WiFi device. This frame is captured by the access point that converts the Ethernet header into an 802.11 frame header. The 802.11 frame sent by the access point contains three addresses : the first address is the MAC address of the destination WiFi device, the second address is the MAC address of the access point and the third address the MAC address of the server that sent the frame.</p>
<p>802.11 control frames are simpler than data frames. They contain a <cite>Frame Control</cite>, a <cite>Duration</cite> field and one or two addresses. The acknowledgment frames are very small. They only contain the address of the destination of the acknowledgment. There is no source address and no <cite>Sequence Control</cite> field in the acknowledgment frames. This is because the acknowledgment frame can easily be associated to the previous frame that it acknowledges. Indeed, each unicast data frame contains a <cite>Duration</cite> field that is used to reserve the transmission channel to ensure that no collision will affect the acknowledgment frame. The <cite>Sequence Control</cite> field is mainly used by the receiver to remove duplicate frames. Duplicate frames are detected as follows. Each data frame contains a 12 bits sequence number in the <cite>Sequence Control</cite> field and the <cite>Frame Control</cite> field contains the <cite>Retry</cite> bit flag that is set when a frame is transmitted.  Each 802.11 receiver stores the most recent sequence number received from each source address in frames whose <cite>Retry</cite> bit is reset. Upon reception of a frame with the <cite>Retry</cite> bit set, the receiver verifies its sequence number to determine whether it is a duplicated frame or not.</p>
<figure class="align-center" id="fig-80211-cts-ack">
<a class="reference internal image-reference" href="../_images/80211-cts.svg"><img alt="../_images/80211-cts.svg" src="../Images/fdb6baf01dc9eef915a1a9a2b7a211ab.png" style="width: 571.0px; height: 176.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/80211-cts.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 184 </span><span class="caption-text">IEEE 802.11 ACK and CTS frames</span><a class="headerlink" href="#fig-80211-cts-ack" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-40">802.11 RTS/CTS frames are used to reserve the transmission channel, in order to transmit one data frame and its acknowledgment. The RTS frames contain a <cite>Duration</cite> and the transmitter and receiver addresses. The <cite>Duration</cite> field of the RTS frame indicates the duration of the entire reservation (i.e. the time required to transmit the CTS, the data frame, the acknowledgments and the required SIFS delays). The CTS frame has the same format as the acknowledgment frame.</p>
<figure class="align-center" id="fig-80211-rst">
<a class="reference internal image-reference" href="../_images/80211-rts.svg"><img alt="../_images/80211-rts.svg" src="../Images/3e40ea29420fe60b879e78422f5de602.png" style="width: 571.0px; height: 224.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/80211-rts.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 185 </span><span class="caption-text">IEEE 802.11 RTS frame format</span><a class="headerlink" href="#fig-80211-rst" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The 802.11 service</p>
<p>Despite the utilization of acknowledgments, the 802.11 layer only provides an unreliable connectionless service like Ethernet networks that do not use acknowledgments. The 802.11 acknowledgments are used to minimize the probability of frame duplication. They do not guarantee that all frames will be correctly received by their recipients. Like Ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. Furthermore, it should be noted that 802.11 networks do not use acknowledgments for multicast and broadcast frames. This implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.</p>
</div>
<p id="index-41">In addition to the data and control frames that we have briefly described above, 802.11 networks use several types of management frames. These management frames are used for various purposes. We briefly describe some of these frames below. A detailed discussion may be found in <a class="reference internal" href="../bibliography.html#ieee802-11" id="id51"><span>[IEEE802.11]</span></a> and <a class="reference internal" href="../bibliography.html#gast2002" id="id52"><span>[Gast2002]</span></a>.</p>
<p>A first type of management frames are the <cite>beacon</cite> frames. These frames are broadcasted regularly by access points. Each <cite>beacon frame</cite> contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a <cite>Service Set Identity</cite> (SSID). The SSID is a null-terminated ASCII string that can contain up to 32 characters. An access point may support several SSIDs and announce them in beacon frames. An access point may also choose to remain silent and not advertise beacon frames. In this case, WiFi stations may send <cite>Probe request</cite> frames to force the available access points to return a <cite>Probe response</cite> frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>IP over 802.11</p>
<p>Two types of encapsulation schemes were defined to support IP in Ethernet networks : the original encapsulation scheme, built above the Ethernet DIX format is defined in <span class="target" id="index-42"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc894.html"><strong>RFC 894</strong></a> and a second encapsulation <span class="target" id="index-43"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1042.html"><strong>RFC 1042</strong></a> scheme, built above the LLC/SNAP protocol <a class="reference internal" href="../bibliography.html#ieee802-2" id="id53"><span>[IEEE802.2]</span></a>. In 802.11 networks, the situation is simpler and only the <span class="target" id="index-44"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1042.html"><strong>RFC 1042</strong></a> encapsulation is used. In practice, this encapsulation adds 6 bytes to the 802.11 header. The first four bytes correspond to the LLC/SNAP header. They are followed by the two bytes Ethernet Type field (<cite>0x800</cite> for IP and <cite>0x806</cite> for ARP). Figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-ip-80211</span></code> shows an IP packet encapsulated in an 802.11 frame.</p>
</div>
<figure class="align-center" id="fig-ip-80211">
<a class="reference internal image-reference" href="../_images/ip-80211.svg"><img alt="../_images/ip-80211.svg" src="../Images/67e54b3cd9e60b19209b0a7114c48c39.png" style="width: 571.0px; height: 336.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ip-80211.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 186 </span><span class="caption-text">IP over IEEE 802.11</span><a class="headerlink" href="#fig-ip-80211" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The second important utilization of the management frames is to allow a WiFi station to be associated with an access point. When a WiFi station starts, it listens to beacon frames to find the available SSIDs. To be allowed to send and receive frames via an access point, a WiFi station must be associated to this access point. If the access point does not use any security mechanism to secure the wireless transmission, the WiFi station simply sends an <cite>Association request</cite> frame to its preferred access point (usually the access point that it receives with the strongest radio signal). This frame contains some parameters chosen by the WiFi station and the SSID that it requests to join. The access point replies with an <cite>Association response frame</cite> if it accepts the WiFI station.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fbss" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id46">10</a><span class="fn-bracket">]</span></span>
<p>The 802.11 working group defined the <cite>basic service set (BSS)</cite> as a group of devices that communicate with each other. We continue to use <cite>network</cite> when referring to a set of devices that communicate.</p>
</aside>
<aside class="footnote brackets" id="f4addresses" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id50">11</a><span class="fn-bracket">]</span></span>
<p>In fact, the <a class="reference internal" href="../bibliography.html#ieee802-11" id="id54"><span>[IEEE802.11]</span></a> frame format contains a fourth optional address field. This fourth address is only used when an 802.11 wireless network is used to interconnect bridges attached to two classical LAN networks.</p>
</aside>
</aside>
</section>
&#13;

<span id="index-0"/><h2>The Point-to-Point Protocol<a class="headerlink" href="#the-point-to-point-protocol" title="Link to this heading">#</a></h2>
<p>Many point-to-point datalink layers <a class="footnote-reference brackets" href="#flapb" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> have been developed, starting in the 1960s. In this section, we focus on the protocols that are often used to transport IP packets between hosts or routers that are directly connected by a point-to-point link. This link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.</p>
<p id="index-1">The first solution to transport IP packets over a serial line was proposed in <span class="target" id="index-2"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1055.html"><strong>RFC 1055</strong></a> and is known as <cite>Serial Line IP</cite> (SLIP). SLIP is a simple character stuffing technique applied to IP packets. SLIP defines two special characters : <cite>END</cite> (decimal 192) and <cite>ESC</cite> (decimal 219). <cite>END</cite> appears at the beginning and at the end of each transmitted IP packet and the sender adds <cite>ESC</cite> before each <cite>END</cite> character inside each transmitted IP packet. SLIP only supports the transmission of IP packets and it assumes that the two communicating hosts/routers have been manually configured with each other’s IP address. SLIP was mainly used over links offering bandwidth of often less than 20 Kbps.  On such a low bandwidth link, sending 20 bytes of IP header followed by 20 bytes of TCP header for each TCP segment takes a lot of time. This initiated the development of a family of compression techniques to efficiently compress the TCP/IP headers. The first header compression technique proposed in <span class="target" id="index-3"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1144.html"><strong>RFC 1144</strong></a> was designed to exploit the redundancy between several consecutive segments that belong to the same TCP connection. In all these segments, the IP addresses and port numbers are always the same. Furthermore, fields such as the sequence and acknowledgment numbers do not change in a random way. <span class="target" id="index-4"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1144.html"><strong>RFC 1144</strong></a> defined simple techniques to reduce the redundancy found in successive segments. The development of header compression techniques continued and there are still improvements being developed now <span class="target" id="index-5"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5795.html"><strong>RFC 5795</strong></a>.</p>
<p>While SLIP was implemented and used in some environments, it had several limitations discussed in <span class="target" id="index-6"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1055.html"><strong>RFC 1055</strong></a>. The <cite>Point-to-Point Protocol</cite> (PPP) was designed shortly after and is specified in <span class="target" id="index-7"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1548.html"><strong>RFC 1548</strong></a>. PPP aims to support IP and other network layer protocols over various types of serial lines. PPP is in fact a family of three protocols that are used together :</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The <cite>Point-to-Point Protocol</cite> defines the framing technique to transport network layer packets.</p></li>
<li><p>The <cite>Link Control Protocol</cite> that is used to negotiate options and authenticate the session by using username and password or other types of credentials</p></li>
<li><p>The <cite>Network Control Protocol</cite> that is specific for each network layer protocol. It is used to negotiate options that are specific for each protocol. For example, IPv4’s NCP <span class="target" id="index-8"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1548.html"><strong>RFC 1548</strong></a> can negotiate the IPv4 address to be used, the IPv4 address of the DNS resolver. IPv6’s NCP is defined in <span class="target" id="index-9"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5072.html"><strong>RFC 5072</strong></a>.</p></li>
</ol>
</div></blockquote>
<p>The PPP framing <span class="target" id="index-10"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1662.html"><strong>RFC 1662</strong></a> was inspired by the datalink layer protocols standardized by ITU-T and ISO. A typical PPP frame is composed of the fields shown in the figure below. A PPP frame starts with a one byte flag containing <cite>01111110</cite>. PPP can use bit stuffing or character stuffing depending on the environment where the protocol is used. The address and control fields are present for backward compatibility reasons. The 16 bit Protocol field contains the identifier <a class="footnote-reference brackets" href="#fpppid" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> of the network layer protocol that is carried in the PPP frame. <cite>0x002d</cite> is used for an IPv4 packet compressed with <span class="target" id="index-11"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1144.html"><strong>RFC 1144</strong></a> while <cite>0x002f</cite> is used for an uncompressed IPv4 packet. <cite>0xc021</cite> is used by the Link Control Protocol, <cite>0xc023</cite> is used by the Password Authentication Protocol (PAP). <cite>0x0057</cite> is used for IPv6 packets. PPP supports variable length packets, but LCP can negotiate a maximum packet length. The PPP frame ends with a Frame Check Sequence. The default is a 16 bits CRC, but some implementations can negotiate a 32 bits CRC. The frame ends with the <cite>01111110</cite> flag.</p>
<figure class="align-center" id="id186">
<a class="reference internal image-reference" href="../_images/ppp.svg"><img alt="../_images/ppp.svg" src="../Images/49b08aa9821170a5792f0c343aa273c5.png" style="width: 571.0px; height: 256.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ppp.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 166 </span><span class="caption-text">PPP frame format</span><a class="headerlink" href="#id186" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-12">PPP played a key role in allowing Internet Service Providers to provide dial-up access over modems in the late 1990s and early 2000s. ISPs operated modem banks connected to the telephone network. For these ISPs, a key issue was to authenticate each user connected through the telephone network. This authentication was performed by using the <cite>Extensible Authentication Protocol</cite> (EAP) defined in <span class="target" id="index-13"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3748.html"><strong>RFC 3748</strong></a>. EAP is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dial-up lines. Several authentication methods, starting from the simple username/password pairs to more complex schemes have been defined and implemented. When ISPs started to upgrade their physical infrastructure to provide Internet access over <cite>Asymmetric Digital Subscriber Lines</cite> (ADSL), they tried to reuse their existing authentication (and billing) systems. To meet these requirements, the IETF developed specifications to allow PPP frames to be transported over other networks than the point-to-point links for which PPP was designed. Nowadays, most ADSL deployments use PPP over either ATM <span class="target" id="index-14"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2364.html"><strong>RFC 2364</strong></a> or Ethernet <span class="target" id="index-15"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2516.html"><strong>RFC 2516</strong></a>.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="flapb" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/LAPB">LAPB</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/HDLC">HDLC</a> were widely used datalink layer protocols.</p>
</aside>
<aside class="footnote brackets" id="fpppid" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>The IANA maintains the registry of all assigned PPP protocol fields at : <a class="reference external" href="http://www.iana.org/assignments/ppp-numbers">http://www.iana.org/assignments/ppp-numbers</a></p>
</aside>
</aside>
&#13;

<span id="chapter-ethernet"/><h2>Ethernet<a class="headerlink" href="#ethernet" title="Link to this heading">#</a></h2>
<p>Ethernet was designed in the 1970s at the Palo Alto Research Center <a class="reference internal" href="../bibliography.html#metcalfe1976" id="id3"><span>[Metcalfe1976]</span></a>. The first prototype <a class="footnote-reference brackets" href="#fethernethistory" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> used a coaxial cable as the shared medium and 3 Mbps of bandwidth. Ethernet was improved during the late 1970s and in the 1980s, Digital Equipment, Intel and Xerox published the first official Ethernet specification <a class="reference internal" href="../bibliography.html#dix" id="id5"><span>[DIX]</span></a>. This specification defines several important parameters for Ethernet networks. The first decision was to standardize the commercial Ethernet at 10 Mbps. The second decision was the duration of the <cite>slot time</cite>. In Ethernet, a long <cite>slot time</cite> enables networks to span a long distance but forces the host to use a larger minimum frame size. The compromise was a <cite>slot time</cite> of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes.</p>
<p>The third decision was the frame format. The experimental 3 Mbps Ethernet network built at Xerox used short frames containing 8 bit source and destination addresses fields, a 16 bit type indication, up to 554 bytes of payload and a 16 bit CRC. Using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. Although the initial Ethernet specification <a class="reference internal" href="../bibliography.html#dix" id="id6"><span>[DIX]</span></a> only allowed up to 1024 hosts on an Ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. The first change was to require each host attached to an Ethernet network to have a globally unique datalink layer address. Until then, datalink layer addresses were manually configured on each host. <a class="reference internal" href="../bibliography.html#dp1981" id="id7"><span>[DP1981]</span></a> went against that state of the art and noted “<cite>Suitable installation-specific administrative procedures are also needed for assigning numbers to hosts on a network. If a host is moved from one network to another it may be necessary to change its host  number if its former number is in use on the new network. This is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). It is anticipated that in future office environments, hosts locations will change as often as telephones are changed in present-day offices.</cite>” The second change introduced by Ethernet was to encode each address as a 48 bits field <a class="reference internal" href="../bibliography.html#dp1981" id="id8"><span>[DP1981]</span></a>. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages <a class="reference internal" href="../bibliography.html#dp1981" id="id9"><span>[DP1981]</span></a> including the ability to allocate large blocks of addresses to manufacturers. Eventually, other LAN technologies opted for 48 bits addresses as well <a class="reference internal" href="../bibliography.html#ieee802" id="id10"><span>[IEEE802]</span></a> . The third change introduced by Ethernet was the definition of <cite>broadcast</cite> and <cite>multicast</cite> addresses. The need for <cite>multicast</cite> Ethernet was foreseen in <a class="reference internal" href="../bibliography.html#dp1981" id="id11"><span>[DP1981]</span></a> and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer.</p>
<p id="index-16">The datalink layer addresses used in Ethernet networks are often called MAC addresses. They are structured as shown in figure <a class="reference internal" href="#fig-ethernet-add-format"><span class="std std-numref">Fig. 167</span></a>. The first bit of the address indicates whether the address identifies a network adapter or a multicast group. The upper 24 bits are used to encode an Organization Unique Identifier (OUI). This OUI identifies a block of addresses that has been allocated by the secretariat <a class="footnote-reference brackets" href="#foui" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> that is responsible for the uniqueness of Ethernet addresses to a manufacturer. Once a manufacturer has received an OUI, it can build and sell products with one of the 16 million addresses in this block.</p>
<blockquote>
<div><div class="figure" id="id187" style="text-align: center">
<span id="fig-ethernet-add-format"/><p><img src="../Images/f3897860be3ce498f407c1420b6944b8.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-f2e9d3ff34766ddc27f681efa69e39d0be36bb07.png"/></p>
<p><span class="caption-number">Fig. 167 </span><span class="caption-text">48 bits Ethernet address format</span></p>
</div></div></blockquote>
<p id="index-17">The original 10 Mbps Ethernet specification <a class="reference internal" href="../bibliography.html#dix" id="id13"><span>[DIX]</span></a> defined a simple frame format where each frame is composed of five fields. The Ethernet frame starts with a preamble (not shown in figure <a class="reference internal" href="#fig-ethernet-dix"><span class="std std-numref">Fig. 169</span></a>) that is used by the physical layer of the receiver to synchronize its clock with the sender’s clock. The first field of the frame is the destination address. As this address is placed at the beginning of the frame, an Ethernet interface can quickly verify whether it is the frame recipient and if not, cancel the processing of the arriving frame. The second field is the source address. While the destination address can be either a unicast or a multicast/broadcast address, the source address must always be a unicast address. The third field is a 16 bits integer that indicates which type of network layer packet is carried inside the frame. This field is often called the <cite>EtherType</cite>. Frequently used <cite>EtherType</cite> values <a class="footnote-reference brackets" href="#fethertype" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> include <cite>0x0800</cite> for IPv4, <cite>0x86DD</cite> for IPv6 <a class="footnote-reference brackets" href="#fipv6ether" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> and <cite>0x806</cite> for the Address Resolution Protocol (ARP).</p>
<p>The fourth part of the Ethernet frame is the payload. The minimum length of the payload is 46 bytes to ensure a minimum frame size, including the header of 512 bits. The Ethernet payload cannot be longer than 1500 bytes. This size was found reasonable when the first Ethernet specification was written. At that time, Xerox had been using its experimental 3 Mbps Ethernet that offered 554 bytes of payload and <span class="target" id="index-18"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1122.html"><strong>RFC 1122</strong></a> required a minimum MTU of 572 bytes for IPv4. 1500 bytes was large enough to support these needs without forcing the network adapters to contain overly large memories. Furthermore, simulations and measurement studies performed in Ethernet networks revealed that CSMA/CD was able to achieve a very high utilization. This is illustrated in figure <a class="reference internal" href="#fig-ethernet-utilization"><span class="std std-numref">Fig. 168</span></a> based on <a class="reference internal" href="../bibliography.html#sh1980" id="id16"><span>[SH1980]</span></a>, which shows the channel utilization achieved in Ethernet networks containing different numbers of hosts that are sending frames of different sizes.</p>
<figure class="align-center" id="id188">
<span id="fig-ethernet-utilization"/><a class="reference internal image-reference" href="../_images/ethernet-util.png"><img alt="../_images/ethernet-util.png" src="../Images/da4b08a7d46cd9d4962e244a40694091.png" style="width: 436.79999999999995px; height: 280.7px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-util.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 168 </span><span class="caption-text">Impact of the frame length on the maximum channel utilization <a class="reference internal" href="../bibliography.html#sh1980" id="id17"><span>[SH1980]</span></a></span><a class="headerlink" href="#id188" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The last field of the Ethernet frame is a 32 bit Cyclical Redundancy Check (CRC). This CRC is able to catch a much larger number of transmission errors than the Internet checksum used by IP, UDP and TCP <a class="reference internal" href="../bibliography.html#sgp98" id="id18"><span>[SGP98]</span></a>. The format of the Ethernet frame is shown in figure <a class="reference internal" href="#fig-ethernet-dix"><span class="std std-numref">Fig. 169</span></a> .</p>
<figure class="align-center" id="fig-ethernet-dix">
<span id="index-19"/><a class="reference internal image-reference" href="../_images/ethernet-dix.svg"><img alt="../_images/ethernet-dix.svg" src="../Images/163da7add640c911c0e0db0efe6683b0.png" style="width: 604.0px; height: 272.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-dix.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 169 </span><span class="caption-text">Ethernet DIX frame format</span><a class="headerlink" href="#fig-ethernet-dix" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Where should the CRC be located in a frame ?</p>
<p>The transport and datalink layers usually chose different strategies to place their CRCs or checksums. Transport layer protocols usually place their CRCs or checksums in the segment header. Datalink layer protocols sometimes place their CRC in the frame header, but often in a trailer at the end of the frame. This choice reflects implementation assumptions, but also influences performance <span class="target" id="index-20"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc893.html"><strong>RFC 893</strong></a>. When the CRC is placed in the trailer, as in Ethernet, the datalink layer can compute it while transmitting the frame and insert it at the end of the transmission. All Ethernet interfaces use this optimization today. When the checksum is placed in the header, as in a TCP segment, it is impossible for the network interface to compute it while transmitting the segment. Some network interfaces provide hardware assistance to compute the TCP checksum, but this is more complex than if the TCP checksum were placed in the trailer <a class="footnote-reference brackets" href="#ftso" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.</p>
</div>
<p id="index-22"><span id="index-21"/>The Ethernet frame format discussed above is specified in <a class="reference internal" href="../bibliography.html#dix" id="id20"><span>[DIX]</span></a>. This is the format used to send both IPv4 <span class="target" id="index-23"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc894.html"><strong>RFC 894</strong></a> and IPv6 packets <span class="target" id="index-24"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2464.html"><strong>RFC 2464</strong></a>. After the publication of <a class="reference internal" href="../bibliography.html#dix" id="id21"><span>[DIX]</span></a>, the Institute of Electrical and Electronic Engineers (IEEE) began to standardize several Local Area Network technologies. IEEE worked on several LAN technologies, starting with Ethernet, Token Ring and Token Bus. These three technologies were completely different, but they all agreed to use the 48 bits MAC addresses specified initially for Ethernet <a class="reference internal" href="../bibliography.html#ieee802" id="id22"><span>[IEEE802]</span></a> . While developing its Ethernet standard <a class="reference internal" href="../bibliography.html#ieee802-3" id="id23"><span>[IEEE802.3]</span></a>, the IEEE 802.3 working group was confronted with a problem. Ethernet mandated a minimum payload size of 46 bytes, while some companies were looking for a LAN technology that could transparently transport short frames containing only a few bytes of payload. Such a frame can be sent by an Ethernet host by padding it to ensure that the payload is at least 46 bytes long. However since the Ethernet header <a class="reference internal" href="../bibliography.html#dix" id="id24"><span>[DIX]</span></a> does not contain a length field, it is impossible for the receiver to determine how many useful bytes were placed inside the payload field. To solve this problem, the IEEE decided to replace the <cite>Type</cite> field of the Ethernet <a class="reference internal" href="../bibliography.html#dix" id="id25"><span>[DIX]</span></a> header with a length field <a class="footnote-reference brackets" href="#ftypelen" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>. This <cite>Length</cite> field contains the number of useful bytes in the frame payload. The payload must still contain at least 46 bytes, but padding bytes are added by the sender and removed by the receiver. In order to add the <cite>Length</cite> field without significantly changing the frame format, IEEE had to remove the <cite>Type</cite> field. Without this field, it is impossible for a receiving host to identify the type of network layer packet inside a received frame. To solve this new problem, IEEE developed a completely new sublayer called the Logical Link Control <a class="reference internal" href="../bibliography.html#ieee802-2" id="id27"><span>[IEEE802.2]</span></a>. Several protocols were defined in this sublayer. One of them provided a slightly different version of the <cite>Type</cite> field of the original Ethernet frame format. Another contained acknowledgments and retransmissions to provide a reliable service… In practice, <a class="reference internal" href="../bibliography.html#ieee802-2" id="id28"><span>[IEEE802.2]</span></a> is never used to support IP in Ethernet networks. Figure <a class="reference internal" href="#fig-ethernet-8023-frame"><span class="std std-numref">Fig. 170</span></a> shows the official <a class="reference internal" href="../bibliography.html#ieee802-3" id="id29"><span>[IEEE802.3]</span></a> frame format.</p>
<figure class="align-center" id="fig-ethernet-8023-frame">
<a class="reference internal image-reference" href="../_images/ethernet-8023.svg"><img alt="../_images/ethernet-8023.svg" src="../Images/79781bc50862d2a32133ea8cd17bc68b.png" style="width: 604.0px; height: 272.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-8023.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 170 </span><span class="caption-text">Ethernet 802.3 frame format</span><a class="headerlink" href="#fig-ethernet-8023-frame" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>What is the Ethernet service ?</p>
<p>An Ethernet network provides an unreliable connectionless service. It supports three different transmission modes : <cite>unicast</cite>, <cite>multicast</cite> and <cite>broadcast</cite>. While the Ethernet service is unreliable in theory, a good Ethernet network should, in practice, provide a service that:</p>
<ul class="simple">
<li><p>delivers frames to their destination with a very high probability of successful delivery</p></li>
<li><p>does not reorder the transmitted frames</p></li>
</ul>
<p>The first property is a consequence of the utilization of CSMA/CD. The second property is a consequence of the physical organization of the Ethernet network as a shared bus. These two properties are important and all revisions to the Ethernet technology have preserved them.</p>
</div>
<p id="index-25">Several physical layers have been defined for Ethernet networks. The first physical layer, usually called 10Base5, provided 10 Mbps over a thick coaxial cable. The characteristics of the cable and the transceivers that were used then enabled the utilization of 500 meter long segments. A 10Base5 network can also include repeaters between segments.</p>
<p id="index-26">The second physical layer was 10Base2. This physical layer used a thin coaxial cable that was easier to install than the 10Base5 cable, but could not be longer than 185 meters. A 10BaseF physical layer was also defined to transport Ethernet over point-to-point optical links. The major change to the physical layer was the support of twisted pairs in the 10BaseT specification. Twisted pair cables are traditionally used to support the telephone service in office buildings. Most office buildings today are equipped with structured cabling. Several twisted pair cables are installed between any room and a central telecom closet per building or per floor in large buildings. These telecom closets act as concentration points for the telephone service but also for LANs.</p>
<p id="index-27">The introduction of the twisted pairs led to two major changes to Ethernet. The first change concerns the physical topology of the network. 10Base2 and 10Base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. A 10BaseT network is a star-shaped network. All the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. From a maintenance perspective, this is a major improvement. The cable is a weak point in 10Base2 and 10Base5 networks. Any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. With 10BaseT, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. The second major change introduced by 10BaseT was that is was impossible to build a 10BaseT network by simply connecting all the twisted pairs together. All the twisted pairs must be connected to a relay that operates in the physical layer. This relay is called an <cite>Ethernet hub</cite>. A <cite>hub</cite> is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. Some <cite>hubs</cite> are also able to convert the electrical signal from one physical layer to another (e.g. 10BaseT to 10Base2 conversion). An Ethernet hub is a relay that operates at the physical layer as shown in figure <a class="reference internal" href="#fig-ethernet-hub"><span class="std std-numref">Fig. 171</span></a>.</p>
<blockquote>
<div><div class="figure" id="id189" style="text-align: center">
<span id="fig-ethernet-hub"/><p><img src="../Images/32f9a71dd5d981a251f55babe3afd5bc.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-584cb66589f7736db42cfe159cf03f93214d29b6.png"/></p>
<p><span class="caption-number">Fig. 171 </span><span class="caption-text">Ethernet hubs in the reference model</span></p>
</div></div></blockquote>
<p id="index-28">Computers can directly be attached to Ethernet hubs. Ethernet hubs themselves can be attached to other Ethernet hubs to build a larger network. However, some important guidelines must be followed when building a complex network with hubs. First, the network topology must be a tree. As hubs are relays in the physical layer, adding a link between <cite>Hub2</cite> and <cite>Hub3</cite> in the network of figure <a class="reference internal" href="#fig-network-hubs"><span class="std std-numref">Fig. 172</span></a> would create an electrical shortcut that would completely disrupt the network. This implies that there cannot be any redundancy in a hub-based network. A failure of a hub or of a link between two hubs would partition the network into two isolated networks. Second, as hubs are relays in the physical layer, collisions can happen and must be handled by CSMA/CD as in a 10Base5 network. This implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2 microseconds <cite>slot time</cite>. If the delay is longer, collisions between short frames may not be correctly detected. This constraint limits the geographical spread of 10BaseT networks containing hubs.</p>
<figure class="align-center" id="fig-network-hubs">
<a class="reference internal image-reference" href="../_images/ethernet-net-hub.png"><img alt="../_images/ethernet-net-hub.png" src="../Images/7b0810c7bcca0cc446f10cbc40ffc06f.png" style="width: 350.0px; height: 193.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ethernet-net-hub.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 172 </span><span class="caption-text">A hierarchical Ethernet network composed of hubs</span><a class="headerlink" href="#fig-network-hubs" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-29">In the late 1980s, 10 Mbps became too slow for some applications and network manufacturers developed several LAN technologies that offered higher bandwidth, such as the 100 Mbps FDDI LAN that used optical fibers. As the development of 10Base5, 10Base2 and 10BaseT had shown that Ethernet could be adapted to different physical layers, several manufacturers started to work on 100 Mbps Ethernet and convinced IEEE to standardize this new technology that was initially called <cite>Fast Ethernet</cite>. <cite>Fast Ethernet</cite> was designed under two constraints. First, <cite>Fast Ethernet</cite> had to support twisted pairs. Although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. Second, <cite>Fast Ethernet</cite> had to be perfectly compatible with the existing 10 Mbps Ethernet to allow <cite>Fast Ethernet</cite> technology to be used initially as a backbone technology to interconnect 10 Mbps Ethernet networks. This forced <cite>Fast Ethernet</cite> to use exactly the same frame format as 10 Mbps Ethernet. This implied that the minimum <cite>Fast Ethernet</cite> frame size remained at 512 bits. To preserve CSMA/CD with this minimum frame size and 100 Mbps instead of 10 Mbps, the duration of the <cite>slot time</cite> was decreased to 5.12 microseconds.</p>
<p>The evolution of Ethernet did not stop. In 1998, the IEEE published a first standard to provide Gigabit Ethernet over optical fibers. Several other types of physical layers were added afterwards. The <a class="reference external" href="http://en.wikipedia.org/wiki/10_gigabit_Ethernet">10 Gigabit Ethernet</a> standard appeared in 2002. Work is ongoing to develop <a class="reference external" href="http://www.ieee802.org/3/ba/public/index.html">standards</a> for 40 Gigabit and 100 Gigabit Ethernet and some are thinking about <a class="reference external" href="http://www.networkworld.com/news/2009/042009-terabit-ethernet.html">Terabit Ethernet</a>. The table below lists the main Ethernet standards. A more detailed list may be found at <a class="reference external" href="http://en.wikipedia.org/wiki/Ethernet_physical_layer">http://en.wikipedia.org/wiki/Ethernet_physical_layer</a>.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Standard</p></th>
<th class="head"><p>Comments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10Base5</p></td>
<td><p>Thick coaxial cable, 500m</p></td>
</tr>
<tr class="row-odd"><td><p>10Base2</p></td>
<td><p>Thin coaxial cable, 185m</p></td>
</tr>
<tr class="row-even"><td><p>10BaseT</p></td>
<td><p>Two pairs of category 3+ UTP</p></td>
</tr>
<tr class="row-odd"><td><p>10Base-F</p></td>
<td><p>10 Mb/s over optical fiber</p></td>
</tr>
<tr class="row-even"><td><p>100Base-Tx</p></td>
<td><p>Category 5 UTP or STP, 100 m maximum</p></td>
</tr>
<tr class="row-odd"><td><p>100Base-FX</p></td>
<td><p>Two multi-mode optical fiber, 2 km maximum</p></td>
</tr>
<tr class="row-even"><td><p>1000Base-CX</p></td>
<td><p>Two pairs shielded twisted pair, 25m maximum</p></td>
</tr>
<tr class="row-odd"><td><p>1000Base-SX</p></td>
<td><p>Two multi-mode or single mode optical fibers with lasers</p></td>
</tr>
<tr class="row-even"><td><p>10 Gbps</p></td>
<td><p>Optical fiber but also Category 6 UTP</p></td>
</tr>
<tr class="row-odd"><td><p>40-100 Gbps</p></td>
<td><p>Optical fiber (experiences are performed with copper)</p></td>
</tr>
</tbody>
</table>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fethernethistory" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>Additional information about the history of the Ethernet technology may be found at <a class="reference external" href="http://ethernethistory.typepad.com/">http://ethernethistory.typepad.com/</a></p>
</aside>
<aside class="footnote brackets" id="foui" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">4</a><span class="fn-bracket">]</span></span>
<p>Initially, the OUIs were allocated by Xerox <a class="reference internal" href="../bibliography.html#dp1981" id="id30"><span>[DP1981]</span></a>. However, once Ethernet became an IEEE and later an ISO standard, the allocation of the OUIs moved to IEEE. The list of all OUI allocations may be found at <a class="reference external" href="http://standards.ieee.org/regauth/oui/index.shtml">http://standards.ieee.org/regauth/oui/index.shtml</a></p>
</aside>
<aside class="footnote brackets" id="fethertype" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">5</a><span class="fn-bracket">]</span></span>
<p>The official list of all assigned Ethernet type values is available from <a class="reference external" href="http://standards.ieee.org/regauth/ethertype/eth.txt">http://standards.ieee.org/regauth/ethertype/eth.txt</a></p>
</aside>
<aside class="footnote brackets" id="fipv6ether" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">6</a><span class="fn-bracket">]</span></span>
<p>The attentive reader may question the need for different <cite>EtherTypes</cite> for IPv4 and IPv6 while the IP header already contains a version field that can be used to distinguish between IPv4 and IPv6 packets. Theoretically, IPv4 and IPv6 could have used the same <cite>EtherType</cite>. Unfortunately, developers of the early IPv6 implementations found that some devices did not check the version field of the IPv4 packets that they received and parsed frames whose <cite>EtherType</cite> was set to <cite>0x0800</cite> as IPv4 packets. Sending IPv6 packets to such devices would have caused disruptions. To avoid this problem, the IETF decided to apply for a distinct <cite>EtherType</cite> value for IPv6. Such a choice is now mandated by <span class="target" id="index-30"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6274.html"><strong>RFC 6274</strong></a> (section 3.1), although we can find a funny counter-example in <span class="target" id="index-31"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6214.html"><strong>RFC 6214</strong></a>.</p>
</aside>
<aside class="footnote brackets" id="ftso" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">7</a><span class="fn-bracket">]</span></span>
<p>These network interfaces compute the TCP checksum while a segment is transferred from the host memory to the network interface <a class="reference internal" href="../bibliography.html#sh2004" id="id31"><span>[SH2004]</span></a>.</p>
</aside>
<aside class="footnote brackets" id="ftypelen" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">8</a><span class="fn-bracket">]</span></span>
<p>Fortunately, IEEE was able to define the <a class="reference internal" href="../bibliography.html#ieee802-3" id="id32"><span>[IEEE802.3]</span></a> frame format while maintaining backward compatibility with the Ethernet <a class="reference internal" href="../bibliography.html#dix" id="id33"><span>[DIX]</span></a> frame format. The trick was to only assign values above 1500 as <cite>EtherType</cite> values. When a host receives a frame, it can determine whether the frame’s format by checking its <cite>EtherType/Length</cite> field. A value lower smaller than <cite>1501</cite> is clearly a length indicator and thus an <a class="reference internal" href="../bibliography.html#ieee802-3" id="id34"><span>[IEEE802.3]</span></a> frame. A value larger than <cite>1501</cite> can only be type and thus a <a class="reference internal" href="../bibliography.html#dix" id="id35"><span>[DIX]</span></a> frame.</p>
</aside>
</aside>
<section id="ethernet-switches">
<h3>Ethernet Switches<a class="headerlink" href="#ethernet-switches" title="Link to this heading">#</a></h3>
<p id="index-32">Increasing the physical layer bandwidth as in <cite>Fast Ethernet</cite> was only one of the solutions to improve the performance of Ethernet LANs. A second solution was to replace the hubs with more intelligent devices. As <cite>Ethernet hubs</cite> operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach of the network. From a performance perspective, it would be more interesting to have devices that operate in the datalink layer and can analyze the destination address of each frame and forward the frames selectively on the link that leads to the destination. Such devices are usually called <cite>Ethernet switches</cite> <a class="footnote-reference brackets" href="#fbridges" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.  An <cite>Ethernet switch</cite> is a relay that operates in the datalink layer as is illustrated in figure <a class="reference internal" href="#fig-switch-ref-model"><span class="std std-numref">Fig. 173</span></a>.</p>
<blockquote>
<div><div class="figure" id="id190" style="text-align: center">
<span id="fig-switch-ref-model"/><p><img src="../Images/3ec5ee9e5eca2555bf183e60ae86fbcd.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e1555d4c718c2c7404c9c6f65a9b4f2f3cddf818.png"/></p>
<p><span class="caption-number">Fig. 173 </span><span class="caption-text">Ethernet switches in the reference model</span></p>
</div></div></blockquote>
<p id="index-33">An <cite>Ethernet switch</cite> understands the format of the Ethernet frames and can selectively forward frames over each interface. For this, each <cite>Ethernet switch</cite> maintains a <cite>MAC address table</cite>. This table contains, for each MAC address known by the switch, the identifier of the switch’s port over which a frame sent towards this address must be forwarded to reach its destination. This is illustrated in figure <a class="reference internal" href="#fig-operation-switch"><span class="std std-numref">Fig. 174</span></a> with the <cite>MAC address table</cite> of the bottom switch. When the switch receives a frame destined to address <cite>B</cite>, it forwards the frame on its South port. If it receives a frame destined to address <cite>D</cite>, it forwards it only on its North port.</p>
<figure class="align-center" id="fig-operation-switch">
<a class="reference internal image-reference" href="../_images/datalink-fig-013-c.png"><img alt="../_images/datalink-fig-013-c.png" src="../Images/dea7b4a82ab8e1e49a6b3ef793fecc58.png" style="width: 350.0px; height: 262.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-013-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 174 </span><span class="caption-text">Operation of Ethernet switches</span><a class="headerlink" href="#fig-operation-switch" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-34">One of the selling points of Ethernet networks is that, thanks to the utilization of 48 bits MAC addresses, an Ethernet LAN is plug and play at the datalink layer. When two hosts are attached to the same Ethernet segment or hub, they can immediately exchange Ethernet frames without requiring any configuration. It is important to retain this plug and play capability for Ethernet switches as well. This implies that Ethernet switches must be able to build their MAC address table automatically without requiring any manual configuration. This automatic configuration is performed by the <cite>MAC address learning</cite> algorithm that runs on each Ethernet switch. This algorithm extracts the source address of the received frames and remembers the port over which a frame from each source Ethernet address has been received. This information is inserted into the MAC address table that the switch uses to forward frames. This allows the switch to automatically learn the ports that it can use to reach each destination address, provided that this host has previously sent at least one frame. This is not a problem since most upper layer protocols use acknowledgments at some layer and thus even an Ethernet printer sends Ethernet frames as well.</p>
<p>The pseudo-code below details how an Ethernet switch forwards Ethernet frames. It first updates its <cite>MAC address table</cite> with the source address of the frame. The <cite>MAC address table</cite> used by some switches also contains a timestamp that is updated each time a frame is received from each known source address. This timestamp is used to remove from the <cite>MAC address table</cite> entries that have not been active during the last <cite>n</cite> minutes. This limits the growth of the <cite>MAC address table</cite>, but also allows hosts to move from one port to another. The switch uses its <cite>MAC address table</cite> to forward the received unicast frame. If there is an entry for the frame’s destination address in the <cite>MAC address table</cite>, the frame is forwarded selectively on the port listed in this entry. Otherwise, the switch does not know how to reach the destination address and it must forward the frame on all its ports except the port from which the frame has been received. This ensures that the frame will reach its destination, at the expense of some unnecessary transmissions. These unnecessary transmissions will only last until the destination has sent its first frame. Multicast and Broadcast frames are also forwarded in a similar way.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># Arrival of frame F on port P</span>
<span class="c1"># Table : MAC address table dictionary : addr-&gt;port</span>
<span class="c1"># Ports : list of all ports on the switch</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">SourceAddress</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">DestinationAddress</span>
<span class="n">Table</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>  <span class="c1">#  src heard on port P</span>
<span class="k">if</span> <span class="n">is_unicast</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">Table</span><span class="p">:</span>
        <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Table</span><span class="p">[</span><span class="n">dst</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">Ports</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
               <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># multicast or broadcast destination</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">Ports</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
            <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Security issues with Ethernet hubs and switches</p>
<p>From a security perspective, Ethernet hubs have the same drawbacks as the older coaxial cable. A host attached to a hub will be able to capture all the frames exchanged between any pair of hosts attached to the same hub.
Ethernet switches are much better from this perspective thanks to the selective forwarding, a host will usually only receive the frames destined to itself as well as the multicast, broadcast and unknown frames. However, this does not imply that switches are completely secure. There are, unfortunately, attacks against Ethernet switches. From a security perspective, the <cite>MAC address table</cite> is one of the fragile elements of an Ethernet switch. This table has a fixed size. Some low-end switches can store a few tens or a few hundreds of addresses while higher-end switches can store tens of thousands of addresses or more. From a security point of view, a limited resource can be the target of Denial of Service attacks. Unfortunately, such attacks are also possible on Ethernet switches. A malicious host could overflow the <cite>MAC address table</cite> of the switch by generating thousands of frames with random source addresses. Once the <cite>MAC address table</cite> is full, the switch needs to broadcast all the frames that it receives. At this point, an attacker will receive unicast frames that are not destined to its address. The ARP attack discussed in the previous chapter could also occur with Ethernet switches <a class="reference internal" href="../bibliography.html#vyncke2007" id="id37"><span>[Vyncke2007]</span></a>. Recent switches implement several types of defenses against these attacks, but they need to be carefully configured by the network administrator. See <a class="reference internal" href="../bibliography.html#vyncke2007" id="id38"><span>[Vyncke2007]</span></a> for a detailed discussion on security issues with Ethernet switches.</p>
</div>
<p>The <cite>MAC address learning</cite> algorithm combined with the forwarding algorithm work well in a tree-shaped network such as the one shown above. However, to deal with link and switch failures, network administrators often add redundant links to ensure that their network remains connected even after a failure. Let us consider what happens in the Ethernet network shown in figure <a class="reference internal" href="#fig-ethernet-loop"><span class="std std-numref">Fig. 175</span></a>.</p>
<figure class="align-center" id="fig-ethernet-loop">
<a class="reference internal image-reference" href="../_images/datalink-fig-014-c.png"><img alt="../_images/datalink-fig-014-c.png" src="../Images/e8f49a8642a420b51358c162a7018bf9.png" style="width: 400.0px; height: 221.60000000000002px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-014-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 175 </span><span class="caption-text">Ethernet switches in a loop</span><a class="headerlink" href="#fig-ethernet-loop" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>When all switches boot, their <cite>MAC address table</cite> is empty. Assume that host <cite>A</cite> sends a frame towards host <cite>C</cite>. Upon reception of this frame, switch1 updates its <cite>MAC address table</cite> to remember that address <cite>A</cite> is reachable via its West port. As there is no entry for address <cite>C</cite> in switch1’s <cite>MAC address table</cite>, the frame is forwarded to both switch2 and switch3. When switch2 receives the frame, its updates its <cite>MAC address table</cite> for address <cite>A</cite> and forwards the frame to host <cite>C</cite> as well as to switch3. switch3 has thus received two copies of the same frame. As switch3 does not know how to reach the destination address, it forwards the frame received from switch1 to switch2 and the frame received from switch2 to switch1… The single frame sent by host <cite>A</cite> will be continuously duplicated by the switches until their <cite>MAC address table</cite> contains an entry for address <cite>C</cite>. Quickly, all the available link bandwidth will be used to forward all the copies of this frame. As Ethernet does not contain any <cite>TTL</cite> or <cite>HopLimit</cite>, this loop will never stop.</p>
<p>The <cite>MAC address learning</cite> algorithm allows switches to be plug-and-play. Unfortunately, the loops that arise when the network topology is not a tree are a severe problem. Forcing the switches to only be used in tree-shaped networks as hubs would be a severe limitation. To solve this problem, the inventors of Ethernet switches have developed the <cite>Spanning Tree Protocol</cite>. This protocol allows switches to automatically disable ports on Ethernet switches to ensure that the network does not contain any cycle that could cause frames to loop forever.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fbridges" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">9</a><span class="fn-bracket">]</span></span>
<p>The first Ethernet relays that operated in the datalink layers were called <cite>bridges</cite>. In practice, the main difference between switches and bridges is that bridges were usually implemented in software while switches are hardware-based devices. Throughout this text, we always use <cite>switch</cite> when referring to a relay in the datalink layer, but you might still see the word <cite>bridge</cite>.</p>
</aside>
</aside>
</section>
<section id="the-spanning-tree-protocol-802-1d">
<h3>The Spanning Tree Protocol (802.1d)<a class="headerlink" href="#the-spanning-tree-protocol-802-1d" title="Link to this heading">#</a></h3>
<p>The <cite>Spanning Tree Protocol</cite> (STP), proposed in <a class="reference internal" href="../bibliography.html#perlman1985" id="id39"><span>[Perlman1985]</span></a>, is a distributed protocol that is used by switches to reduce the network topology to a spanning tree, so that there are no cycles in the topology. For example, consider the network shown in figure <a class="reference internal" href="#fig-ethernet-spanning"><span class="std std-numref">Fig. 176</span></a>. In this figure, each bold line corresponds to an Ethernet to which two Ethernet switches are attached. This network contains several cycles that must be broken to allow Ethernet switches, using the MAC address learning algorithm, to exchange frames.</p>
<figure class="align-center" id="fig-ethernet-spanning">
<a class="reference internal image-reference" href="../_images/datalink-fig-015-c.png"><img alt="../_images/datalink-fig-015-c.png" src="../Images/5a29a9d52b3209b13650c40e94203b2e.png" style="width: 350.0px; height: 219.1px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-015-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 176 </span><span class="caption-text">Spanning tree computed in a switched Ethernet network</span><a class="headerlink" href="#fig-ethernet-spanning" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this network, the STP will compute the following spanning tree. <cite>Switch1</cite> will be the root of the tree. All the interfaces of <cite>Switch1</cite>, <cite>Switch2</cite> and <cite>Switch7</cite> are part of the spanning tree. Only the interface connected to <cite>LAN B</cite> will be active on <cite>Switch9</cite>. <cite>LAN H</cite> will only be served by <cite>Switch7</cite> and the port of <cite>Switch44</cite> on <cite>LAN G</cite> will be disabled. A frame originating on <cite>LAN B</cite> and destined for <cite>LAN A</cite> will be forwarded by <cite>Switch7</cite> on <cite>LAN C</cite>, then by <cite>Switch1</cite> on <cite>LAN E</cite>, then by <cite>Switch44</cite> on <cite>LAN F</cite> and eventually by <cite>Switch2</cite> on <cite>LAN A</cite>.</p>
<p>Switches running the <cite>Spanning Tree Protocol</cite> exchange <cite>BPDUs</cite>. These <cite>BPDUs</cite> are always sent as frames with destination MAC address as the <cite>ALL_BRIDGES</cite> reserved multicast MAC address. Each switch has a unique 64 bit <cite>identifier</cite>. To ensure uniqueness, the lower 48 bits of the identifier are set to the unique MAC address allocated to the switch by its manufacturer. The high order 16 bits of the switch identifier can be configured by the network administrator to influence the topology of the spanning tree. The default value for these high order bits is 32768.</p>
<p>The switches exchange <cite>BPDUs</cite> to build the spanning tree. Intuitively, the spanning tree is built by first selecting the switch with the smallest <cite>identifier</cite> as the root of the tree. The branches of the spanning tree are then composed of the shortest paths that allow all of the switches that compose the network to be reached.
The <cite>BPDUs</cite> exchanged by the switches contain the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>identifier</cite> of the root switch (<cite>R</cite>)</p></li>
<li><p>the <cite>cost</cite> of the shortest path between the switch that sent the <cite>BPDU</cite> and the root switch (<cite>c</cite>)</p></li>
<li><p>the <cite>identifier</cite> of the switch that sent the <cite>BPDU</cite> (<cite>T</cite>)</p></li>
<li><p>the number of the switch port over which the <cite>BPDU</cite> was sent (<cite>p</cite>)</p></li>
</ul>
</div></blockquote>
<p>We will use the notation <cite>&lt;R,c,T,p&gt;</cite> to represent a <cite>BPDU</cite> whose <cite>root identifier</cite> is <cite>R</cite>, <cite>cost</cite> is <cite>c</cite> and that was sent from the port <cite>p</cite> of switch <cite>T</cite>.  The construction of the spanning tree depends on an ordering relationship among the <cite>BPDUs</cite>. This ordering relationship could be implemented by the Python function below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># returns True if bpdu b1 is better than bpdu b2</span>
<span class="k">def</span><span class="w"> </span><span class="nf">better</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">p</span><span class="p">)))</span>
</pre></div>
</div>
<p>In addition to the <cite>identifier</cite> discussed above, the network administrator can also configure a <cite>cost</cite> to be associated to each switch port. Usually, the <cite>cost</cite> of a port depends on its bandwidth and the <a class="reference internal" href="../bibliography.html#ieee802-1d" id="id40"><span>[IEEE802.1d]</span></a> standard recommends the values below. Of course, the network administrator may choose other values. We will use the notation <cite>cost[p]</cite> to indicate the cost associated to port <cite>p</cite> in this section.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Bandwidth</p></th>
<th class="head"><p>Cost</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10 Mbps</p></td>
<td><p>2000000</p></td>
</tr>
<tr class="row-odd"><td><p>100 Mbps</p></td>
<td><p>200000</p></td>
</tr>
<tr class="row-even"><td><p>1 Gbps</p></td>
<td><p>20000</p></td>
</tr>
<tr class="row-odd"><td><p>10 Gbps</p></td>
<td><p>2000</p></td>
</tr>
<tr class="row-even"><td><p>100 Gbps</p></td>
<td><p>200</p></td>
</tr>
</tbody>
</table>
</div>
<p>The <cite>Spanning Tree Protocol</cite> uses its own terminology that we illustrate in the figure above. A switch port can be in three different states : <cite>Root</cite>, <cite>Designated</cite> and <cite>Blocked</cite>. All the ports of the <cite>root</cite> switch are in the <cite>Designated</cite> state. The state of the ports on the other switches is determined based on the <cite>BPDU</cite> received on each port.</p>
<p>The <cite>Spanning Tree Protocol</cite> uses the ordering relationship to build the spanning tree. Each switch listens to <cite>BPDUs</cite> on its ports. When <cite>BPDU = &lt;R,c,T,p&gt;</cite> is received on port <cite>q</cite>, the switch computes the port’s <cite>root priority vector</cite>: <cite>V[q] = &lt;R,c+cost[q],T,p,q&gt;</cite> , where <cite>cost[q]</cite> is the cost associated to the port over which the <cite>BPDU</cite> was received. The switch stores in a table the last <cite>root priority vector</cite> received on each port. The switch then compares its own <cite>identifier</cite> with the smallest <cite>root identifier</cite> stored in this table. If its own <cite>identifier</cite> is smaller, then the switch is the root of the spanning tree and is, by definition, at a distance <cite>0</cite> of the root. The <cite>BPDU</cite> of the switch is then <cite>&lt;R,0,R,p&gt;</cite>, where <cite>R</cite> is the switch <cite>identifier</cite> and <cite>p</cite> will be set to the port number over which the <cite>BPDU</cite> is sent.</p>
<p>Otherwise, the switch chooses the best priority vector from its table, <cite>bv = &lt;R,c+cost[q’],T,p,q’&gt;</cite>. The port <cite>q’</cite>, over which this best root priority vector was learned, is the switch port that is closest to the <cite>root</cite> switch. This port becomes the <cite>Root</cite> port of the switch. There is only one <cite>Root</cite> port per switch (except for the <cite>Root</cite> switches whose ports are all <cite>Designated</cite>). The switch can then compute its own <cite>BPDU</cite> as <cite>BPDU = &lt;R,c’,S,p&gt;</cite> , where <cite>R</cite> is the <cite>root identifier</cite>, <cite>c’</cite> the cost of the best root priority vector, <cite>S</cite> the identifier of the switch and <cite>p</cite> will be replaced by the number of the port over which the <cite>BPDU</cite> will be sent.</p>
<p>To determine the state of its other ports, the switch compares its own <cite>BPDU</cite> with the last <cite>BPDU</cite> received on each port. Note that the comparison is done by using the <cite>BPDUs</cite> and not the <cite>root priority vectors</cite>. If the switch’s <cite>BPDU</cite> is better than the last <cite>BPDU</cite> of this port, the port becomes a <cite>Designated</cite> port. Otherwise, the port becomes a <cite>Blocked</cite> port.</p>
<p>The state of each port is important when considering the transmission of <cite>BPDUs</cite>. The root switch regularly sends its own <cite>BPDU</cite> over all of its (<cite>Designated</cite>) ports. This <cite>BPDU</cite> is received on the <cite>Root</cite> port of all the switches that are directly connected to the <cite>root switch</cite>. Each of these switches computes its own <cite>BPDU</cite> and sends this <cite>BPDU</cite> over all its <cite>Designated</cite> ports. These <cite>BPDUs</cite> are then received on the <cite>Root</cite> port of downstream switches, which then compute their own <cite>BPDU</cite>, etc. When the network topology is stable, switches send their own <cite>BPDU</cite> on all their <cite>Designated</cite> ports, once they receive a <cite>BPDU</cite> on their <cite>Root</cite> port. No <cite>BPDU</cite> is sent on a <cite>Blocked</cite> port. Switches listen for <cite>BPDUs</cite> on their <cite>Blocked</cite> and <cite>Designated</cite> ports, but no <cite>BPDU</cite> should be received over these ports when the topology is stable. The utilization of the ports for both <cite>BPDUs</cite> and data frames is summarized in the table below.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Port state</p></th>
<th class="head"><p>Receives BPDUs</p></th>
<th class="head"><p>Sends BPDU</p></th>
<th class="head"><p>Handles data frames</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocked</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>Root</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>Designated</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
</div>
<p>To illustrate the operation of the <cite>Spanning Tree Protocol</cite>, let us consider the simple network topology in the figure <a class="reference internal" href="#fig-stp-example"><span class="std std-numref">Fig. 177</span></a>.</p>
<figure class="align-center" id="fig-stp-example">
<a class="reference internal image-reference" href="../_images/datalink-fig-016-c.svg"><img alt="../_images/datalink-fig-016-c.svg" src="../Images/400b4ebfa6c09b6f49710e52c919a9a1.png" style="width: 561.3px; height: 478.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-016-c.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 177 </span><span class="caption-text">A simple Spanning tree computed in a switched Ethernet network</span><a class="headerlink" href="#fig-stp-example" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Assume that <cite>Switch4</cite> is the first to boot. It sends its own <cite>BPDU = &lt;4,0,4,1&gt;</cite> (resp. <cite>BPDU = &lt;4,0,4,2&gt;</cite>) on port 1 (resp. port 2). When <cite>Switch1</cite> boots, it sends <cite>BPDU = &lt;1,0,1,1&gt;</cite>. This <cite>BPDU</cite> is received by <cite>Switch4</cite>, which updates its <cite>BPDU</cite> and root priority vector tables and computes a new <cite>BPDU = &lt;1,3,4,1&gt;</cite> (resp. <cite>BPDU = &lt;1,3,4,2&gt;</cite>) on port 1 (resp. port 2). Indeed, there is only one root priority vector and hence, it is the best one. Port 1 of <cite>Switch4</cite> becomes the <cite>Root</cite> port while its second port is still in the <cite>Designated</cite> state.</p>
<p>Assume now that <cite>Switch9</cite> boots and immediately receives <cite>Switch1</cite> ‘s <cite>BPDU</cite> on port 1. <cite>Switch9</cite> computes its own <cite>BPDU = &lt;1,1,9,1&gt;</cite> (resp. <cite>BPDU = &lt;1,1,9,2&gt;</cite>) on port 1 (resp. port 2) and port 1 becomes the <cite>Root</cite> port of this switch. The <cite>BPDU</cite> is sent on port 2 of <cite>Switch9</cite> and reaches <cite>Switch4</cite>. <cite>Switch4</cite> compares the priority vectors. It notices that the last computed vector (i.e., <cite>V[2] = &lt;1,2,9,2,2&gt;</cite>) is better than <cite>V[1] = &lt;1,3,1,1,1&gt;</cite>. Thus, <cite>Switch4</cite>’s <cite>BPDU</cite> is recomputed and port 2 becomes the <cite>Root</cite> port of <cite>Switch4</cite>. <cite>Switch4</cite> compares its new <cite>BPDU = &lt;1,2,4,p&gt;</cite> with the last <cite>BPDU</cite> received on each port (except for the <cite>Root</cite> port). Port 1 becomes a <cite>Blocked</cite> port on <cite>Switch4</cite> because the <cite>BPDU=&lt;1,0,1,1&gt;</cite> received on this port is better.</p>
<p>During the computation of the spanning tree, switches discard all received data frames, as at that time the network topology is not guaranteed to be loop-free. Once that topology has been stable for some time, the switches again start to use the MAC learning algorithm to forward data frames. Only the <cite>Root</cite> and <cite>Designated</cite> ports are used to forward data frames. Switches discard all the data frames received on their <cite>Blocked</cite> ports and never forward frames on these ports.</p>
<p>Switches, ports and links can fail in a switched Ethernet network. When a failure occurs, the switches must be able to recompute the spanning tree to recover from the failure. The <cite>Spanning Tree Protocol</cite> relies on regular transmissions of the <cite>BPDUs</cite> to detect these failures. A <cite>BPDU</cite> contains two additional fields : the <cite>Age</cite> of the <cite>BPDU</cite> and the <cite>Maximum Age</cite>. The <cite>Age</cite> contains the amount of time that has passed since the root switch initially originated the <cite>BPDU</cite>. The root switch sends its <cite>BPDU</cite> with an <cite>Age</cite> of zero and each switch that computes its own <cite>BPDU</cite> increments its <cite>Age</cite> by one. The <cite>Age</cite> of the <cite>BPDUs</cite> stored on a switch’s table is also incremented every second. A <cite>BPDU</cite> expires when its <cite>Age</cite> reaches the <cite>Maximum Age</cite>. When the network is stable, this does not happen as <cite>BPDU</cite> s are regularly sent by the <cite>root</cite> switch and downstream switches. However, if the <cite>root</cite> fails or the network becomes partitioned, <cite>BPDU</cite> will expire and switches will recompute their own <cite>BPDU</cite> and restart the <cite>Spanning Tree Protocol</cite>. Once a topology change has been detected, the forwarding of the data frames stops as the topology is not guaranteed to be loop-free. Additional details about the reaction to failures may be found in <a class="reference internal" href="../bibliography.html#ieee802-1d" id="id41"><span>[IEEE802.1d]</span></a>.</p>
</section>
<section id="virtual-lans">
<span id="index-35"/><h3>Virtual LANs<a class="headerlink" href="#virtual-lans" title="Link to this heading">#</a></h3>
<p>Another important advantage of Ethernet switches is the ability to create Virtual Local Area Networks (VLANs). A virtual LAN can be defined as a <cite>set of ports attached to one or more Ethernet switches</cite>. A switch can support several VLANs and it runs one MAC learning algorithm for each Virtual LAN. When a switch receives a frame with an unknown or a multicast destination, it forwards it over all the ports that belong to the same Virtual LAN but not over the ports that belong to other Virtual LANs. Similarly, when a switch learns a source address on a port, it associates it to the Virtual LAN of this port and uses this information only when forwarding frames on this Virtual LAN.</p>
<p>Figure <a class="reference internal" href="#fig-vlan"><span class="std std-numref">Fig. 178</span></a> illustrates a switched Ethernet network with three Virtual LANs. <cite>VLAN2</cite> and <cite>VLAN3</cite> only require a local configuration of switch <cite>S1</cite>. Host <cite>C</cite> can exchange frames with host <cite>D</cite>, but not with hosts that are outside of its VLAN. <cite>VLAN1</cite> is more complex as there are ports of this VLAN on several switches. To support such VLANs, local configuration is not sufficient anymore. When a switch receives a frame from another switch, it must be able to determine the VLAN in which the frame originated to use the correct MAC table to forward the frame. This is done by assigning an identifier to each Virtual LAN and placing this identifier inside the headers of the frames that are exchanged between switches.</p>
<figure class="align-center" id="fig-vlan">
<a class="reference internal image-reference" href="../_images/datalink-fig-017-c.png"><img alt="../_images/datalink-fig-017-c.png" src="../Images/2d641cc82f586881a3a072f7fc5bfdc8.png" style="width: 350.0px; height: 127.39999999999999px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-017-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 178 </span><span class="caption-text">Virtual Local Area Networks in a switched Ethernet network</span><a class="headerlink" href="#fig-vlan" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>IEEE defined in the <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id42"><span>[IEEE802.1q]</span></a> standard a special header to encode the VLAN identifiers. This 32 bit header includes a 12 bit VLAN field that contains the VLAN identifier of each frame. The format of the <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id43"><span>[IEEE802.1q]</span></a> header is shown in figure <a class="reference internal" href="#fig-8021q"><span class="std std-numref">Fig. 179</span></a>.</p>
<figure class="align-center" id="fig-8021q">
<a class="reference internal image-reference" href="../_images/8021q.svg"><img alt="../_images/8021q.svg" src="../Images/a5322aedde97417cdbe8bf165a0df75e.png" style="width: 571.0px; height: 96.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/8021q.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 179 </span><span class="caption-text">Format of the 802.1q header</span><a class="headerlink" href="#fig-8021q" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id44"><span>[IEEE802.1q]</span></a> header is inserted immediately after the source MAC address in the Ethernet frame (i.e. before the EtherType field). The maximum frame size is increased by 4 bytes. It is encoded in 32 bits and contains four fields. The Tag Protocol Identifier is set to <cite>0x8100</cite> to allow the receiver to detect the presence of this additional header. The <cite>Priority Code Point</cite> (PCP) is a three bit field that is used to support different transmission priorities for the frame. Value <cite>0</cite> is the lowest priority and value <cite>7</cite> the highest. Frames with a higher priority can expect to be forwarded earlier than frames having a lower priority. The <cite>C</cite> bit is used for compatibility between Ethernet and Token Ring networks. The last 12 bits of the 802.1q header contain the VLAN identifier. Value <cite>0</cite> indicates that the frame does not belong to any VLAN while value <cite>0xFFF</cite> is reserved. This implies that 4094 different VLAN identifiers can be used in an Ethernet network.</p>
</section>
&#13;

<h3>Ethernet Switches<a class="headerlink" href="#ethernet-switches" title="Link to this heading">#</a></h3>
<p id="index-32">Increasing the physical layer bandwidth as in <cite>Fast Ethernet</cite> was only one of the solutions to improve the performance of Ethernet LANs. A second solution was to replace the hubs with more intelligent devices. As <cite>Ethernet hubs</cite> operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach of the network. From a performance perspective, it would be more interesting to have devices that operate in the datalink layer and can analyze the destination address of each frame and forward the frames selectively on the link that leads to the destination. Such devices are usually called <cite>Ethernet switches</cite> <a class="footnote-reference brackets" href="#fbridges" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.  An <cite>Ethernet switch</cite> is a relay that operates in the datalink layer as is illustrated in figure <a class="reference internal" href="#fig-switch-ref-model"><span class="std std-numref">Fig. 173</span></a>.</p>
<blockquote>
<div><div class="figure" id="id190" style="text-align: center">
<span id="fig-switch-ref-model"/><p><img src="../Images/3ec5ee9e5eca2555bf183e60ae86fbcd.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-e1555d4c718c2c7404c9c6f65a9b4f2f3cddf818.png"/></p>
<p><span class="caption-number">Fig. 173 </span><span class="caption-text">Ethernet switches in the reference model</span></p>
</div></div></blockquote>
<p id="index-33">An <cite>Ethernet switch</cite> understands the format of the Ethernet frames and can selectively forward frames over each interface. For this, each <cite>Ethernet switch</cite> maintains a <cite>MAC address table</cite>. This table contains, for each MAC address known by the switch, the identifier of the switch’s port over which a frame sent towards this address must be forwarded to reach its destination. This is illustrated in figure <a class="reference internal" href="#fig-operation-switch"><span class="std std-numref">Fig. 174</span></a> with the <cite>MAC address table</cite> of the bottom switch. When the switch receives a frame destined to address <cite>B</cite>, it forwards the frame on its South port. If it receives a frame destined to address <cite>D</cite>, it forwards it only on its North port.</p>
<figure class="align-center" id="fig-operation-switch">
<a class="reference internal image-reference" href="../_images/datalink-fig-013-c.png"><img alt="../_images/datalink-fig-013-c.png" src="../Images/dea7b4a82ab8e1e49a6b3ef793fecc58.png" style="width: 350.0px; height: 262.5px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-013-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 174 </span><span class="caption-text">Operation of Ethernet switches</span><a class="headerlink" href="#fig-operation-switch" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-34">One of the selling points of Ethernet networks is that, thanks to the utilization of 48 bits MAC addresses, an Ethernet LAN is plug and play at the datalink layer. When two hosts are attached to the same Ethernet segment or hub, they can immediately exchange Ethernet frames without requiring any configuration. It is important to retain this plug and play capability for Ethernet switches as well. This implies that Ethernet switches must be able to build their MAC address table automatically without requiring any manual configuration. This automatic configuration is performed by the <cite>MAC address learning</cite> algorithm that runs on each Ethernet switch. This algorithm extracts the source address of the received frames and remembers the port over which a frame from each source Ethernet address has been received. This information is inserted into the MAC address table that the switch uses to forward frames. This allows the switch to automatically learn the ports that it can use to reach each destination address, provided that this host has previously sent at least one frame. This is not a problem since most upper layer protocols use acknowledgments at some layer and thus even an Ethernet printer sends Ethernet frames as well.</p>
<p>The pseudo-code below details how an Ethernet switch forwards Ethernet frames. It first updates its <cite>MAC address table</cite> with the source address of the frame. The <cite>MAC address table</cite> used by some switches also contains a timestamp that is updated each time a frame is received from each known source address. This timestamp is used to remove from the <cite>MAC address table</cite> entries that have not been active during the last <cite>n</cite> minutes. This limits the growth of the <cite>MAC address table</cite>, but also allows hosts to move from one port to another. The switch uses its <cite>MAC address table</cite> to forward the received unicast frame. If there is an entry for the frame’s destination address in the <cite>MAC address table</cite>, the frame is forwarded selectively on the port listed in this entry. Otherwise, the switch does not know how to reach the destination address and it must forward the frame on all its ports except the port from which the frame has been received. This ensures that the frame will reach its destination, at the expense of some unnecessary transmissions. These unnecessary transmissions will only last until the destination has sent its first frame. Multicast and Broadcast frames are also forwarded in a similar way.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># Arrival of frame F on port P</span>
<span class="c1"># Table : MAC address table dictionary : addr-&gt;port</span>
<span class="c1"># Ports : list of all ports on the switch</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">SourceAddress</span>
<span class="n">dst</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">DestinationAddress</span>
<span class="n">Table</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>  <span class="c1">#  src heard on port P</span>
<span class="k">if</span> <span class="n">is_unicast</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">Table</span><span class="p">:</span>
        <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Table</span><span class="p">[</span><span class="n">dst</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">Ports</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
               <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># multicast or broadcast destination</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">Ports</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">P</span><span class="p">:</span>
            <span class="n">forward_frame</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Security issues with Ethernet hubs and switches</p>
<p>From a security perspective, Ethernet hubs have the same drawbacks as the older coaxial cable. A host attached to a hub will be able to capture all the frames exchanged between any pair of hosts attached to the same hub.
Ethernet switches are much better from this perspective thanks to the selective forwarding, a host will usually only receive the frames destined to itself as well as the multicast, broadcast and unknown frames. However, this does not imply that switches are completely secure. There are, unfortunately, attacks against Ethernet switches. From a security perspective, the <cite>MAC address table</cite> is one of the fragile elements of an Ethernet switch. This table has a fixed size. Some low-end switches can store a few tens or a few hundreds of addresses while higher-end switches can store tens of thousands of addresses or more. From a security point of view, a limited resource can be the target of Denial of Service attacks. Unfortunately, such attacks are also possible on Ethernet switches. A malicious host could overflow the <cite>MAC address table</cite> of the switch by generating thousands of frames with random source addresses. Once the <cite>MAC address table</cite> is full, the switch needs to broadcast all the frames that it receives. At this point, an attacker will receive unicast frames that are not destined to its address. The ARP attack discussed in the previous chapter could also occur with Ethernet switches <a class="reference internal" href="../bibliography.html#vyncke2007" id="id37"><span>[Vyncke2007]</span></a>. Recent switches implement several types of defenses against these attacks, but they need to be carefully configured by the network administrator. See <a class="reference internal" href="../bibliography.html#vyncke2007" id="id38"><span>[Vyncke2007]</span></a> for a detailed discussion on security issues with Ethernet switches.</p>
</div>
<p>The <cite>MAC address learning</cite> algorithm combined with the forwarding algorithm work well in a tree-shaped network such as the one shown above. However, to deal with link and switch failures, network administrators often add redundant links to ensure that their network remains connected even after a failure. Let us consider what happens in the Ethernet network shown in figure <a class="reference internal" href="#fig-ethernet-loop"><span class="std std-numref">Fig. 175</span></a>.</p>
<figure class="align-center" id="fig-ethernet-loop">
<a class="reference internal image-reference" href="../_images/datalink-fig-014-c.png"><img alt="../_images/datalink-fig-014-c.png" src="../Images/e8f49a8642a420b51358c162a7018bf9.png" style="width: 400.0px; height: 221.60000000000002px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-014-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 175 </span><span class="caption-text">Ethernet switches in a loop</span><a class="headerlink" href="#fig-ethernet-loop" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>When all switches boot, their <cite>MAC address table</cite> is empty. Assume that host <cite>A</cite> sends a frame towards host <cite>C</cite>. Upon reception of this frame, switch1 updates its <cite>MAC address table</cite> to remember that address <cite>A</cite> is reachable via its West port. As there is no entry for address <cite>C</cite> in switch1’s <cite>MAC address table</cite>, the frame is forwarded to both switch2 and switch3. When switch2 receives the frame, its updates its <cite>MAC address table</cite> for address <cite>A</cite> and forwards the frame to host <cite>C</cite> as well as to switch3. switch3 has thus received two copies of the same frame. As switch3 does not know how to reach the destination address, it forwards the frame received from switch1 to switch2 and the frame received from switch2 to switch1… The single frame sent by host <cite>A</cite> will be continuously duplicated by the switches until their <cite>MAC address table</cite> contains an entry for address <cite>C</cite>. Quickly, all the available link bandwidth will be used to forward all the copies of this frame. As Ethernet does not contain any <cite>TTL</cite> or <cite>HopLimit</cite>, this loop will never stop.</p>
<p>The <cite>MAC address learning</cite> algorithm allows switches to be plug-and-play. Unfortunately, the loops that arise when the network topology is not a tree are a severe problem. Forcing the switches to only be used in tree-shaped networks as hubs would be a severe limitation. To solve this problem, the inventors of Ethernet switches have developed the <cite>Spanning Tree Protocol</cite>. This protocol allows switches to automatically disable ports on Ethernet switches to ensure that the network does not contain any cycle that could cause frames to loop forever.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fbridges" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">9</a><span class="fn-bracket">]</span></span>
<p>The first Ethernet relays that operated in the datalink layers were called <cite>bridges</cite>. In practice, the main difference between switches and bridges is that bridges were usually implemented in software while switches are hardware-based devices. Throughout this text, we always use <cite>switch</cite> when referring to a relay in the datalink layer, but you might still see the word <cite>bridge</cite>.</p>
</aside>
</aside>
&#13;

<h3>The Spanning Tree Protocol (802.1d)<a class="headerlink" href="#the-spanning-tree-protocol-802-1d" title="Link to this heading">#</a></h3>
<p>The <cite>Spanning Tree Protocol</cite> (STP), proposed in <a class="reference internal" href="../bibliography.html#perlman1985" id="id39"><span>[Perlman1985]</span></a>, is a distributed protocol that is used by switches to reduce the network topology to a spanning tree, so that there are no cycles in the topology. For example, consider the network shown in figure <a class="reference internal" href="#fig-ethernet-spanning"><span class="std std-numref">Fig. 176</span></a>. In this figure, each bold line corresponds to an Ethernet to which two Ethernet switches are attached. This network contains several cycles that must be broken to allow Ethernet switches, using the MAC address learning algorithm, to exchange frames.</p>
<figure class="align-center" id="fig-ethernet-spanning">
<a class="reference internal image-reference" href="../_images/datalink-fig-015-c.png"><img alt="../_images/datalink-fig-015-c.png" src="../Images/5a29a9d52b3209b13650c40e94203b2e.png" style="width: 350.0px; height: 219.1px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-015-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 176 </span><span class="caption-text">Spanning tree computed in a switched Ethernet network</span><a class="headerlink" href="#fig-ethernet-spanning" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>In this network, the STP will compute the following spanning tree. <cite>Switch1</cite> will be the root of the tree. All the interfaces of <cite>Switch1</cite>, <cite>Switch2</cite> and <cite>Switch7</cite> are part of the spanning tree. Only the interface connected to <cite>LAN B</cite> will be active on <cite>Switch9</cite>. <cite>LAN H</cite> will only be served by <cite>Switch7</cite> and the port of <cite>Switch44</cite> on <cite>LAN G</cite> will be disabled. A frame originating on <cite>LAN B</cite> and destined for <cite>LAN A</cite> will be forwarded by <cite>Switch7</cite> on <cite>LAN C</cite>, then by <cite>Switch1</cite> on <cite>LAN E</cite>, then by <cite>Switch44</cite> on <cite>LAN F</cite> and eventually by <cite>Switch2</cite> on <cite>LAN A</cite>.</p>
<p>Switches running the <cite>Spanning Tree Protocol</cite> exchange <cite>BPDUs</cite>. These <cite>BPDUs</cite> are always sent as frames with destination MAC address as the <cite>ALL_BRIDGES</cite> reserved multicast MAC address. Each switch has a unique 64 bit <cite>identifier</cite>. To ensure uniqueness, the lower 48 bits of the identifier are set to the unique MAC address allocated to the switch by its manufacturer. The high order 16 bits of the switch identifier can be configured by the network administrator to influence the topology of the spanning tree. The default value for these high order bits is 32768.</p>
<p>The switches exchange <cite>BPDUs</cite> to build the spanning tree. Intuitively, the spanning tree is built by first selecting the switch with the smallest <cite>identifier</cite> as the root of the tree. The branches of the spanning tree are then composed of the shortest paths that allow all of the switches that compose the network to be reached.
The <cite>BPDUs</cite> exchanged by the switches contain the following information :</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>identifier</cite> of the root switch (<cite>R</cite>)</p></li>
<li><p>the <cite>cost</cite> of the shortest path between the switch that sent the <cite>BPDU</cite> and the root switch (<cite>c</cite>)</p></li>
<li><p>the <cite>identifier</cite> of the switch that sent the <cite>BPDU</cite> (<cite>T</cite>)</p></li>
<li><p>the number of the switch port over which the <cite>BPDU</cite> was sent (<cite>p</cite>)</p></li>
</ul>
</div></blockquote>
<p>We will use the notation <cite>&lt;R,c,T,p&gt;</cite> to represent a <cite>BPDU</cite> whose <cite>root identifier</cite> is <cite>R</cite>, <cite>cost</cite> is <cite>c</cite> and that was sent from the port <cite>p</cite> of switch <cite>T</cite>.  The construction of the spanning tree depends on an ordering relationship among the <cite>BPDUs</cite>. This ordering relationship could be implemented by the Python function below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># returns True if bpdu b1 is better than bpdu b2</span>
<span class="k">def</span><span class="w"> </span><span class="nf">better</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">((</span><span class="n">b1</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">b2</span><span class="o">.</span><span class="n">p</span><span class="p">)))</span>
</pre></div>
</div>
<p>In addition to the <cite>identifier</cite> discussed above, the network administrator can also configure a <cite>cost</cite> to be associated to each switch port. Usually, the <cite>cost</cite> of a port depends on its bandwidth and the <a class="reference internal" href="../bibliography.html#ieee802-1d" id="id40"><span>[IEEE802.1d]</span></a> standard recommends the values below. Of course, the network administrator may choose other values. We will use the notation <cite>cost[p]</cite> to indicate the cost associated to port <cite>p</cite> in this section.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Bandwidth</p></th>
<th class="head"><p>Cost</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10 Mbps</p></td>
<td><p>2000000</p></td>
</tr>
<tr class="row-odd"><td><p>100 Mbps</p></td>
<td><p>200000</p></td>
</tr>
<tr class="row-even"><td><p>1 Gbps</p></td>
<td><p>20000</p></td>
</tr>
<tr class="row-odd"><td><p>10 Gbps</p></td>
<td><p>2000</p></td>
</tr>
<tr class="row-even"><td><p>100 Gbps</p></td>
<td><p>200</p></td>
</tr>
</tbody>
</table>
</div>
<p>The <cite>Spanning Tree Protocol</cite> uses its own terminology that we illustrate in the figure above. A switch port can be in three different states : <cite>Root</cite>, <cite>Designated</cite> and <cite>Blocked</cite>. All the ports of the <cite>root</cite> switch are in the <cite>Designated</cite> state. The state of the ports on the other switches is determined based on the <cite>BPDU</cite> received on each port.</p>
<p>The <cite>Spanning Tree Protocol</cite> uses the ordering relationship to build the spanning tree. Each switch listens to <cite>BPDUs</cite> on its ports. When <cite>BPDU = &lt;R,c,T,p&gt;</cite> is received on port <cite>q</cite>, the switch computes the port’s <cite>root priority vector</cite>: <cite>V[q] = &lt;R,c+cost[q],T,p,q&gt;</cite> , where <cite>cost[q]</cite> is the cost associated to the port over which the <cite>BPDU</cite> was received. The switch stores in a table the last <cite>root priority vector</cite> received on each port. The switch then compares its own <cite>identifier</cite> with the smallest <cite>root identifier</cite> stored in this table. If its own <cite>identifier</cite> is smaller, then the switch is the root of the spanning tree and is, by definition, at a distance <cite>0</cite> of the root. The <cite>BPDU</cite> of the switch is then <cite>&lt;R,0,R,p&gt;</cite>, where <cite>R</cite> is the switch <cite>identifier</cite> and <cite>p</cite> will be set to the port number over which the <cite>BPDU</cite> is sent.</p>
<p>Otherwise, the switch chooses the best priority vector from its table, <cite>bv = &lt;R,c+cost[q’],T,p,q’&gt;</cite>. The port <cite>q’</cite>, over which this best root priority vector was learned, is the switch port that is closest to the <cite>root</cite> switch. This port becomes the <cite>Root</cite> port of the switch. There is only one <cite>Root</cite> port per switch (except for the <cite>Root</cite> switches whose ports are all <cite>Designated</cite>). The switch can then compute its own <cite>BPDU</cite> as <cite>BPDU = &lt;R,c’,S,p&gt;</cite> , where <cite>R</cite> is the <cite>root identifier</cite>, <cite>c’</cite> the cost of the best root priority vector, <cite>S</cite> the identifier of the switch and <cite>p</cite> will be replaced by the number of the port over which the <cite>BPDU</cite> will be sent.</p>
<p>To determine the state of its other ports, the switch compares its own <cite>BPDU</cite> with the last <cite>BPDU</cite> received on each port. Note that the comparison is done by using the <cite>BPDUs</cite> and not the <cite>root priority vectors</cite>. If the switch’s <cite>BPDU</cite> is better than the last <cite>BPDU</cite> of this port, the port becomes a <cite>Designated</cite> port. Otherwise, the port becomes a <cite>Blocked</cite> port.</p>
<p>The state of each port is important when considering the transmission of <cite>BPDUs</cite>. The root switch regularly sends its own <cite>BPDU</cite> over all of its (<cite>Designated</cite>) ports. This <cite>BPDU</cite> is received on the <cite>Root</cite> port of all the switches that are directly connected to the <cite>root switch</cite>. Each of these switches computes its own <cite>BPDU</cite> and sends this <cite>BPDU</cite> over all its <cite>Designated</cite> ports. These <cite>BPDUs</cite> are then received on the <cite>Root</cite> port of downstream switches, which then compute their own <cite>BPDU</cite>, etc. When the network topology is stable, switches send their own <cite>BPDU</cite> on all their <cite>Designated</cite> ports, once they receive a <cite>BPDU</cite> on their <cite>Root</cite> port. No <cite>BPDU</cite> is sent on a <cite>Blocked</cite> port. Switches listen for <cite>BPDUs</cite> on their <cite>Blocked</cite> and <cite>Designated</cite> ports, but no <cite>BPDU</cite> should be received over these ports when the topology is stable. The utilization of the ports for both <cite>BPDUs</cite> and data frames is summarized in the table below.</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Port state</p></th>
<th class="head"><p>Receives BPDUs</p></th>
<th class="head"><p>Sends BPDU</p></th>
<th class="head"><p>Handles data frames</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Blocked</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>Root</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>Designated</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
</div>
<p>To illustrate the operation of the <cite>Spanning Tree Protocol</cite>, let us consider the simple network topology in the figure <a class="reference internal" href="#fig-stp-example"><span class="std std-numref">Fig. 177</span></a>.</p>
<figure class="align-center" id="fig-stp-example">
<a class="reference internal image-reference" href="../_images/datalink-fig-016-c.svg"><img alt="../_images/datalink-fig-016-c.svg" src="../Images/400b4ebfa6c09b6f49710e52c919a9a1.png" style="width: 561.3px; height: 478.2px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-016-c.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 177 </span><span class="caption-text">A simple Spanning tree computed in a switched Ethernet network</span><a class="headerlink" href="#fig-stp-example" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Assume that <cite>Switch4</cite> is the first to boot. It sends its own <cite>BPDU = &lt;4,0,4,1&gt;</cite> (resp. <cite>BPDU = &lt;4,0,4,2&gt;</cite>) on port 1 (resp. port 2). When <cite>Switch1</cite> boots, it sends <cite>BPDU = &lt;1,0,1,1&gt;</cite>. This <cite>BPDU</cite> is received by <cite>Switch4</cite>, which updates its <cite>BPDU</cite> and root priority vector tables and computes a new <cite>BPDU = &lt;1,3,4,1&gt;</cite> (resp. <cite>BPDU = &lt;1,3,4,2&gt;</cite>) on port 1 (resp. port 2). Indeed, there is only one root priority vector and hence, it is the best one. Port 1 of <cite>Switch4</cite> becomes the <cite>Root</cite> port while its second port is still in the <cite>Designated</cite> state.</p>
<p>Assume now that <cite>Switch9</cite> boots and immediately receives <cite>Switch1</cite> ‘s <cite>BPDU</cite> on port 1. <cite>Switch9</cite> computes its own <cite>BPDU = &lt;1,1,9,1&gt;</cite> (resp. <cite>BPDU = &lt;1,1,9,2&gt;</cite>) on port 1 (resp. port 2) and port 1 becomes the <cite>Root</cite> port of this switch. The <cite>BPDU</cite> is sent on port 2 of <cite>Switch9</cite> and reaches <cite>Switch4</cite>. <cite>Switch4</cite> compares the priority vectors. It notices that the last computed vector (i.e., <cite>V[2] = &lt;1,2,9,2,2&gt;</cite>) is better than <cite>V[1] = &lt;1,3,1,1,1&gt;</cite>. Thus, <cite>Switch4</cite>’s <cite>BPDU</cite> is recomputed and port 2 becomes the <cite>Root</cite> port of <cite>Switch4</cite>. <cite>Switch4</cite> compares its new <cite>BPDU = &lt;1,2,4,p&gt;</cite> with the last <cite>BPDU</cite> received on each port (except for the <cite>Root</cite> port). Port 1 becomes a <cite>Blocked</cite> port on <cite>Switch4</cite> because the <cite>BPDU=&lt;1,0,1,1&gt;</cite> received on this port is better.</p>
<p>During the computation of the spanning tree, switches discard all received data frames, as at that time the network topology is not guaranteed to be loop-free. Once that topology has been stable for some time, the switches again start to use the MAC learning algorithm to forward data frames. Only the <cite>Root</cite> and <cite>Designated</cite> ports are used to forward data frames. Switches discard all the data frames received on their <cite>Blocked</cite> ports and never forward frames on these ports.</p>
<p>Switches, ports and links can fail in a switched Ethernet network. When a failure occurs, the switches must be able to recompute the spanning tree to recover from the failure. The <cite>Spanning Tree Protocol</cite> relies on regular transmissions of the <cite>BPDUs</cite> to detect these failures. A <cite>BPDU</cite> contains two additional fields : the <cite>Age</cite> of the <cite>BPDU</cite> and the <cite>Maximum Age</cite>. The <cite>Age</cite> contains the amount of time that has passed since the root switch initially originated the <cite>BPDU</cite>. The root switch sends its <cite>BPDU</cite> with an <cite>Age</cite> of zero and each switch that computes its own <cite>BPDU</cite> increments its <cite>Age</cite> by one. The <cite>Age</cite> of the <cite>BPDUs</cite> stored on a switch’s table is also incremented every second. A <cite>BPDU</cite> expires when its <cite>Age</cite> reaches the <cite>Maximum Age</cite>. When the network is stable, this does not happen as <cite>BPDU</cite> s are regularly sent by the <cite>root</cite> switch and downstream switches. However, if the <cite>root</cite> fails or the network becomes partitioned, <cite>BPDU</cite> will expire and switches will recompute their own <cite>BPDU</cite> and restart the <cite>Spanning Tree Protocol</cite>. Once a topology change has been detected, the forwarding of the data frames stops as the topology is not guaranteed to be loop-free. Additional details about the reaction to failures may be found in <a class="reference internal" href="../bibliography.html#ieee802-1d" id="id41"><span>[IEEE802.1d]</span></a>.</p>
&#13;

<span id="index-35"/><h3>Virtual LANs<a class="headerlink" href="#virtual-lans" title="Link to this heading">#</a></h3>
<p>Another important advantage of Ethernet switches is the ability to create Virtual Local Area Networks (VLANs). A virtual LAN can be defined as a <cite>set of ports attached to one or more Ethernet switches</cite>. A switch can support several VLANs and it runs one MAC learning algorithm for each Virtual LAN. When a switch receives a frame with an unknown or a multicast destination, it forwards it over all the ports that belong to the same Virtual LAN but not over the ports that belong to other Virtual LANs. Similarly, when a switch learns a source address on a port, it associates it to the Virtual LAN of this port and uses this information only when forwarding frames on this Virtual LAN.</p>
<p>Figure <a class="reference internal" href="#fig-vlan"><span class="std std-numref">Fig. 178</span></a> illustrates a switched Ethernet network with three Virtual LANs. <cite>VLAN2</cite> and <cite>VLAN3</cite> only require a local configuration of switch <cite>S1</cite>. Host <cite>C</cite> can exchange frames with host <cite>D</cite>, but not with hosts that are outside of its VLAN. <cite>VLAN1</cite> is more complex as there are ports of this VLAN on several switches. To support such VLANs, local configuration is not sufficient anymore. When a switch receives a frame from another switch, it must be able to determine the VLAN in which the frame originated to use the correct MAC table to forward the frame. This is done by assigning an identifier to each Virtual LAN and placing this identifier inside the headers of the frames that are exchanged between switches.</p>
<figure class="align-center" id="fig-vlan">
<a class="reference internal image-reference" href="../_images/datalink-fig-017-c.png"><img alt="../_images/datalink-fig-017-c.png" src="../Images/2d641cc82f586881a3a072f7fc5bfdc8.png" style="width: 350.0px; height: 127.39999999999999px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-017-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 178 </span><span class="caption-text">Virtual Local Area Networks in a switched Ethernet network</span><a class="headerlink" href="#fig-vlan" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>IEEE defined in the <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id42"><span>[IEEE802.1q]</span></a> standard a special header to encode the VLAN identifiers. This 32 bit header includes a 12 bit VLAN field that contains the VLAN identifier of each frame. The format of the <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id43"><span>[IEEE802.1q]</span></a> header is shown in figure <a class="reference internal" href="#fig-8021q"><span class="std std-numref">Fig. 179</span></a>.</p>
<figure class="align-center" id="fig-8021q">
<a class="reference internal image-reference" href="../_images/8021q.svg"><img alt="../_images/8021q.svg" src="../Images/a5322aedde97417cdbe8bf165a0df75e.png" style="width: 571.0px; height: 96.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/8021q.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 179 </span><span class="caption-text">Format of the 802.1q header</span><a class="headerlink" href="#fig-8021q" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="../bibliography.html#ieee802-1q" id="id44"><span>[IEEE802.1q]</span></a> header is inserted immediately after the source MAC address in the Ethernet frame (i.e. before the EtherType field). The maximum frame size is increased by 4 bytes. It is encoded in 32 bits and contains four fields. The Tag Protocol Identifier is set to <cite>0x8100</cite> to allow the receiver to detect the presence of this additional header. The <cite>Priority Code Point</cite> (PCP) is a three bit field that is used to support different transmission priorities for the frame. Value <cite>0</cite> is the lowest priority and value <cite>7</cite> the highest. Frames with a higher priority can expect to be forwarded earlier than frames having a lower priority. The <cite>C</cite> bit is used for compatibility between Ethernet and Token Ring networks. The last 12 bits of the 802.1q header contain the VLAN identifier. Value <cite>0</cite> indicates that the frame does not belong to any VLAN while value <cite>0xFFF</cite> is reserved. This implies that 4094 different VLAN identifiers can be used in an Ethernet network.</p>
&#13;

<h2>802.11 wireless networks<a class="headerlink" href="#wireless-networks" title="Link to this heading">#</a></h2>
<p>The radio spectrum is a limited resource that must be shared by everyone. During most of the twentieth century, governments and international organizations have regulated most of the radio spectrum. This regulation controls the utilization of the radio spectrum, in order to prevent interference among different users. A company that wants to use a frequency range in a given region must apply for a license from the regulator. Most regulators charge a fee for the utilization of the radio spectrum and some governments have encouraged competition among companies bidding for the same frequency to increase the license fees.</p>
<p>In the 1970s, after the first experiments with ALOHANet, interest in wireless networks grew. Many experiments were done on and outside the ARPANet. One of these experiments was the <a class="reference external" href="http://news.bbc.co.uk/2/hi/programmes/click_online/8639590.stm">first mobile phone</a> , which was developed and tested in 1973. This experimental mobile phone was the starting point for the first generation analog mobile phones. Given the growing demand for mobile phones, it was clear that the analog mobile phone technology was not sufficient to support a large number of users.  To support more users and new services, researchers in several countries worked on the development of digital mobile telephones. In 1987, several European countries decided to develop the standards for a common cellular telephone system across Europe : the <cite>Global System for Mobile Communications</cite> (GSM). Since then, the standards have evolved and more than three billion users are connected to GSM networks today.</p>
<p id="index-36">While most of the frequency ranges of the radio spectrum are reserved for specific applications and require a special license, there are a few exceptions. These exceptions are known as the <a class="reference external" href="http://en.wikipedia.org/wiki/ISM_band">Industrial, Scientific and Medical</a> (ISM) radio bands. These bands can be used for industrial, scientific and medical applications without requiring a license from the regulator. For example, some radio-controlled models use the 27 MHz ISM band and some cordless telephones operate in the 915 MHz ISM. In 1985, the 2.400-2.500 GHz band was added to the list of ISM bands. This frequency range corresponds to the frequencies that are emitted by microwave ovens. Sharing this band with licensed applications would have likely caused interference, given the large number of microwave ovens that are used. Despite the risk of interference with microwave ovens, the opening of the 2.400-2.500 GHz allowed the networking industry to develop several wireless network techniques to allow computers to exchange data without using cables. In this section, we discuss in more detail the most popular one, i.e. the WiFi <a class="reference internal" href="../bibliography.html#ieee802-11" id="id45"><span>[IEEE802.11]</span></a> family of wireless networks. Other wireless networking techniques such as <a class="reference external" href="http://en.wikipedia.org/wiki/BlueTooth">BlueTooth</a> or <a class="reference external" href="http://en.wikipedia.org/wiki/HiperLAN">HiperLAN</a> use the same frequency range.</p>
<p>Today, WiFi is a very popular wireless networking technology. There are more than several hundreds of millions of WiFi devices. The development of this technology started in the late 1980s with the <a class="reference external" href="http://en.wikipedia.org/wiki/WaveLAN">WaveLAN</a> proprietary wireless network. WaveLAN operated at 2 Mbps and used different frequency bands in different regions of the world. In the early 1990s, the <a class="reference external" href="https://www.ieee.org">IEEE</a> created the <a class="reference external" href="http://www.ieee802.org/11/">802.11 working group</a> to standardize a family of wireless network technologies. This working group was very prolific and produced several wireless networking standards that use different frequency ranges and different physical layers. The table below provides a summary of the main 802.11 standards.</p>
<div class="pst-scrollable-table-container"><table class="table" id="table-wifi">
<thead>
<tr class="row-odd"><th class="head"><p>Standard</p></th>
<th class="head"><p>Frequency</p></th>
<th class="head"><p>Typical
throughput</p></th>
<th class="head"><p>Max
bandwidth</p></th>
<th class="head"><p>Range (m)
indoor/outdoor</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>802.11</p></td>
<td><p>2.4 GHz</p></td>
<td><p>0.9 Mbps</p></td>
<td><p>2 Mbps</p></td>
<td><p>20/100</p></td>
</tr>
<tr class="row-odd"><td><p>802.11a</p></td>
<td><p>5 GHz</p></td>
<td><p>23 Mbps</p></td>
<td><p>54 Mbps</p></td>
<td><p>35/120</p></td>
</tr>
<tr class="row-even"><td><p>802.11b</p></td>
<td><p>2.4 GHz</p></td>
<td><p>4.3 Mbps</p></td>
<td><p>11 Mbps</p></td>
<td><p>38/140</p></td>
</tr>
<tr class="row-odd"><td><p>802.11g</p></td>
<td><p>2.4 GHz</p></td>
<td><p>19 Mbps</p></td>
<td><p>54 Mbps</p></td>
<td><p>38/140</p></td>
</tr>
<tr class="row-even"><td><p>802.11n</p></td>
<td><p>2.4/5 GHz</p></td>
<td><p>74 Mbps</p></td>
<td><p>150 Mbps</p></td>
<td><p>70/250</p></td>
</tr>
</tbody>
</table>
</div>
<p>When developing its family of standards, the <a class="reference external" href="http://www.ieee802.org/11/">IEEE 802.11 working group</a> took a similar approach as the <a class="reference external" href="http://www.ieee802.org/3/">IEEE 802.3 working group</a> that developed various types of physical layers for Ethernet networks. 802.11 networks use the CSMA/CA Medium Access Control technique described earlier and they all assume the same architecture and use the same frame format.</p>
<p id="index-37">The architecture of WiFi networks is slightly different from the Local Area Networks that we have discussed until now. There are, in practice, two main types of WiFi networks : <cite>independent</cite> or <cite>adhoc</cite> networks  and <cite>infrastructure</cite> networks <a class="footnote-reference brackets" href="#fbss" id="id46" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. An <cite>independent</cite> or <cite>adhoc</cite> network is composed of a set of devices that communicate with each other. These devices play the same role and the <cite>adhoc</cite> network is usually not connected to the global Internet. <cite>Adhoc</cite> networks are used when for example a few laptops need to exchange information or to connect a computer with a WiFi printer.</p>
<figure class="align-center" id="fig-wifi-adhoc">
<a class="reference internal image-reference" href="../_images/datalink-fig-018-c.png"><img alt="../_images/datalink-fig-018-c.png" src="../Images/04f0be24510b17bef06b3589cb0893eb.png" style="width: 300.0px; height: 240.6px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-018-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 180 </span><span class="caption-text">An 802.11 independent or adhoc network</span><a class="headerlink" href="#fig-wifi-adhoc" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-38">Most WiFi networks are <cite>infrastructure</cite> networks. An <cite>infrastructure</cite> network contains one or more <cite>access points</cite> that are attached to a fixed Local Area Network (usually an Ethernet network) that is connected to other networks such as the Internet. Figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-wifi-infra</span></code> shows such a network with two access points and four WiFi devices. Each WiFi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the LAN.</p>
<figure class="align-center" id="fig-wifi-infra">
<a class="reference internal image-reference" href="../_images/datalink-fig-019-c.png"><img alt="../_images/datalink-fig-019-c.png" src="../Images/f0d5e9e6d0d36f1759d63a3558c0f00a.png" style="width: 350.0px; height: 197.39999999999998px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/datalink-fig-019-c.png"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 181 </span><span class="caption-text">An 802.11 infrastructure network</span><a class="headerlink" href="#fig-wifi-infra" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>An 802.11 access point is a relay that operates in the datalink layer like switches. Figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-wifi-ap</span></code> represents the layers of the reference model that are involved when a WiFi host communicates with a host attached to an Ethernet network through an access point.</p>
<blockquote>
<div><div class="figure" id="id191" style="text-align: center">
<span id="fig-wifi-ap"/><p><img src="../Images/0faeff9a8c796e457aba98b2fbbe785f.png" alt="Figure made with TikZ" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/tikz-a62a95cfae1b52cdf547afc8f83e99597b9bda64.png"/></p>
<p><span class="caption-number">Fig. 182 </span><span class="caption-text">An 802.11 access point</span></p>
</div></div></blockquote>
<p id="index-39">802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in Ethernet LANs. We review the key parts of the 802.11 frames. Additional details may be found in <a class="reference internal" href="../bibliography.html#ieee802-11" id="id47"><span>[IEEE802.11]</span></a> and <a class="reference internal" href="../bibliography.html#gast2002" id="id48"><span>[Gast2002]</span></a> . An 802.11 frame contains a fixed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits CRC. Although the payload can contain up to 2324 bytes, most 802.11 deployments use a maximum payload size of 1500 bytes as they are used in <cite>infrastructure</cite> networks attached to Ethernet LANs. An 802.11 data frame is shown in figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-80211-packet</span></code>.</p>
<figure class="align-center" id="fig-80211-packet">
<a class="reference internal image-reference" href="../_images/80211.svg"><img alt="../_images/80211.svg" src="../Images/d4417bb14a34ecaa4ca9eb5590e752b4.png" style="width: 571.0px; height: 352.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/80211.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 183 </span><span class="caption-text">802.11 data frame format</span><a class="headerlink" href="#fig-80211-packet" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The first part of the 802.11 header is the 16 bit <cite>Frame Control</cite> field. This field contains flags that indicate the type of frame (data frame, RTS/CTS, acknowledgment, management frames, etc), whether the frame is sent to or from a fixed LAN, etc <a class="reference internal" href="../bibliography.html#ieee802-11" id="id49"><span>[IEEE802.11]</span></a>. The <cite>Duration</cite> is a 16 bit field that is used to reserve the transmission channel. In data frames, the <cite>Duration</cite> field is usually set to the time required to transmit one acknowledgment frame after a SIFS delay. Note that the <cite>Duration</cite> field must be set to zero in multicast and broadcast frames. As these frames are not acknowledged, there is no need to reserve the transmission channel after their transmission. The <cite>Sequence control</cite> field contains a 12 bits sequence number that is incremented for each data frame and a 4 bits fragment number.</p>
<p>The astute reader may have noticed that the 802.11 data frames contain three 48-bits address fields <a class="footnote-reference brackets" href="#f4addresses" id="id50" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a> . This is surprising compared to other protocols in the network and datalink layers whose headers only contain a source and a destination address. The need for a third address in the 802.11 header comes from the <cite>infrastructure</cite> networks. In such a network, frames are usually exchanged between routers and servers attached to the LAN and WiFi devices attached to one of the access points. The role of the three address fields is specified by bit flags in the <cite>Frame Control</cite> field.</p>
<p>When a frame is sent from a WiFi device to a server attached to the same LAN as the access point, the first address of the frame is set to the MAC address of the access point, the second address is set to the MAC address of the source WiFi device and the third address is the address of the final destination on the LAN. When the server replies, it sends an Ethernet frame whose source address is its MAC address and the destination address is the MAC address of the WiFi device. This frame is captured by the access point that converts the Ethernet header into an 802.11 frame header. The 802.11 frame sent by the access point contains three addresses : the first address is the MAC address of the destination WiFi device, the second address is the MAC address of the access point and the third address the MAC address of the server that sent the frame.</p>
<p>802.11 control frames are simpler than data frames. They contain a <cite>Frame Control</cite>, a <cite>Duration</cite> field and one or two addresses. The acknowledgment frames are very small. They only contain the address of the destination of the acknowledgment. There is no source address and no <cite>Sequence Control</cite> field in the acknowledgment frames. This is because the acknowledgment frame can easily be associated to the previous frame that it acknowledges. Indeed, each unicast data frame contains a <cite>Duration</cite> field that is used to reserve the transmission channel to ensure that no collision will affect the acknowledgment frame. The <cite>Sequence Control</cite> field is mainly used by the receiver to remove duplicate frames. Duplicate frames are detected as follows. Each data frame contains a 12 bits sequence number in the <cite>Sequence Control</cite> field and the <cite>Frame Control</cite> field contains the <cite>Retry</cite> bit flag that is set when a frame is transmitted.  Each 802.11 receiver stores the most recent sequence number received from each source address in frames whose <cite>Retry</cite> bit is reset. Upon reception of a frame with the <cite>Retry</cite> bit set, the receiver verifies its sequence number to determine whether it is a duplicated frame or not.</p>
<figure class="align-center" id="fig-80211-cts-ack">
<a class="reference internal image-reference" href="../_images/80211-cts.svg"><img alt="../_images/80211-cts.svg" src="../Images/fdb6baf01dc9eef915a1a9a2b7a211ab.png" style="width: 571.0px; height: 176.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/80211-cts.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 184 </span><span class="caption-text">IEEE 802.11 ACK and CTS frames</span><a class="headerlink" href="#fig-80211-cts-ack" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p id="index-40">802.11 RTS/CTS frames are used to reserve the transmission channel, in order to transmit one data frame and its acknowledgment. The RTS frames contain a <cite>Duration</cite> and the transmitter and receiver addresses. The <cite>Duration</cite> field of the RTS frame indicates the duration of the entire reservation (i.e. the time required to transmit the CTS, the data frame, the acknowledgments and the required SIFS delays). The CTS frame has the same format as the acknowledgment frame.</p>
<figure class="align-center" id="fig-80211-rst">
<a class="reference internal image-reference" href="../_images/80211-rts.svg"><img alt="../_images/80211-rts.svg" src="../Images/3e40ea29420fe60b879e78422f5de602.png" style="width: 571.0px; height: 224.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/80211-rts.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 185 </span><span class="caption-text">IEEE 802.11 RTS frame format</span><a class="headerlink" href="#fig-80211-rst" title="Link to this image">#</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The 802.11 service</p>
<p>Despite the utilization of acknowledgments, the 802.11 layer only provides an unreliable connectionless service like Ethernet networks that do not use acknowledgments. The 802.11 acknowledgments are used to minimize the probability of frame duplication. They do not guarantee that all frames will be correctly received by their recipients. Like Ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. Furthermore, it should be noted that 802.11 networks do not use acknowledgments for multicast and broadcast frames. This implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.</p>
</div>
<p id="index-41">In addition to the data and control frames that we have briefly described above, 802.11 networks use several types of management frames. These management frames are used for various purposes. We briefly describe some of these frames below. A detailed discussion may be found in <a class="reference internal" href="../bibliography.html#ieee802-11" id="id51"><span>[IEEE802.11]</span></a> and <a class="reference internal" href="../bibliography.html#gast2002" id="id52"><span>[Gast2002]</span></a>.</p>
<p>A first type of management frames are the <cite>beacon</cite> frames. These frames are broadcasted regularly by access points. Each <cite>beacon frame</cite> contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a <cite>Service Set Identity</cite> (SSID). The SSID is a null-terminated ASCII string that can contain up to 32 characters. An access point may support several SSIDs and announce them in beacon frames. An access point may also choose to remain silent and not advertise beacon frames. In this case, WiFi stations may send <cite>Probe request</cite> frames to force the available access points to return a <cite>Probe response</cite> frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>IP over 802.11</p>
<p>Two types of encapsulation schemes were defined to support IP in Ethernet networks : the original encapsulation scheme, built above the Ethernet DIX format is defined in <span class="target" id="index-42"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc894.html"><strong>RFC 894</strong></a> and a second encapsulation <span class="target" id="index-43"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1042.html"><strong>RFC 1042</strong></a> scheme, built above the LLC/SNAP protocol <a class="reference internal" href="../bibliography.html#ieee802-2" id="id53"><span>[IEEE802.2]</span></a>. In 802.11 networks, the situation is simpler and only the <span class="target" id="index-44"/><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1042.html"><strong>RFC 1042</strong></a> encapsulation is used. In practice, this encapsulation adds 6 bytes to the 802.11 header. The first four bytes correspond to the LLC/SNAP header. They are followed by the two bytes Ethernet Type field (<cite>0x800</cite> for IP and <cite>0x806</cite> for ARP). Figure <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig-ip-80211</span></code> shows an IP packet encapsulated in an 802.11 frame.</p>
</div>
<figure class="align-center" id="fig-ip-80211">
<a class="reference internal image-reference" href="../_images/ip-80211.svg"><img alt="../_images/ip-80211.svg" src="../Images/67e54b3cd9e60b19209b0a7114c48c39.png" style="width: 571.0px; height: 336.0px;" data-original-src="https://4ed.computer-networking.info/syllabus/default/_images/ip-80211.svg"/>
</a>
<figcaption>
<p><span class="caption-number">Fig. 186 </span><span class="caption-text">IP over IEEE 802.11</span><a class="headerlink" href="#fig-ip-80211" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The second important utilization of the management frames is to allow a WiFi station to be associated with an access point. When a WiFi station starts, it listens to beacon frames to find the available SSIDs. To be allowed to send and receive frames via an access point, a WiFi station must be associated to this access point. If the access point does not use any security mechanism to secure the wireless transmission, the WiFi station simply sends an <cite>Association request</cite> frame to its preferred access point (usually the access point that it receives with the strongest radio signal). This frame contains some parameters chosen by the WiFi station and the SSID that it requests to join. The access point replies with an <cite>Association response frame</cite> if it accepts the WiFI station.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fbss" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id46">10</a><span class="fn-bracket">]</span></span>
<p>The 802.11 working group defined the <cite>basic service set (BSS)</cite> as a group of devices that communicate with each other. We continue to use <cite>network</cite> when referring to a set of devices that communicate.</p>
</aside>
<aside class="footnote brackets" id="f4addresses" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id50">11</a><span class="fn-bracket">]</span></span>
<p>In fact, the <a class="reference internal" href="../bibliography.html#ieee802-11" id="id54"><span>[IEEE802.11]</span></a> frame format contains a fourth optional address field. This fourth address is only used when an 802.11 wireless network is used to interconnect bridges attached to two classical LAN networks.</p>
</aside>
</aside>
    
</body>
</html>