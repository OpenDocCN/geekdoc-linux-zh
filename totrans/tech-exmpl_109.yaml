- en: Design an In-Memory Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://techbyexample.com/design-in-memory-cache/](https://techbyexample.com/design-in-memory-cache/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '[Overview](#Overview "Overview")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Set(key int, value int)](#Setkey_int_value_int "Set(key int, value int)")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Get(key int)](#Getkey_int "Get(key int)")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Low-Level Design](#Low-Level_Design "Low-Level Design")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UML Diagram](#UML_Diagram "UML Diagram")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Program](#Program "Program")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The objective is to Design an in-memory cache. Below are the requirements
  prefs: []
  type: TYPE_NORMAL
- en: It should support **Set** and **Get** Operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O(1) Time Complexity for both **Set** and **Get**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume the maximum capacity of the cache is 3\. Once the cache is full and there
    is one more key to be inserted then one of the existing entries needs to be deleted
    from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion should be based on eviction algorithm – FIFO or LRU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume key and value in the cache are of type string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The eviction Algorithm it should support is **First-In-First-Out(FIFO)** and
    **Least Recently Used (LRU)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Eviction Algorithm should be pluggable. That means that you should be able
    to change your eviction algorithm at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below are the high-level things we will have in our design
  prefs: []
  type: TYPE_NORMAL
- en: We will have a **Cache** class that will act as an interface for interacting
    with the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache** class will be using a combination of a **Map** and a **Doubly-linked
    List** for storing everything. Both map and doubly-linked list are used so that
    get and set are of  O(1) even with evictions. How this is achieved, we will later
    in this tutorial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Map** will have the key of type string and the value of the type pointer
    to a node in the **Doubly-linked List**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each node of the **Doubly Linked List** will contain the key as well as value.
    Each node will also have a pointer to the previous node in the double linked list
    and a pointer to the next node in the **doubly linked list**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be an **evictionAlgorithm** interface. There will be **LRU** and
    **FIFO** class which implements this **evictionAlgorithm** Interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache class will also embed an instance of **evictionAlgorithm** interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**evictionAlgorithm** interface exists to decouple our **Cache** class with
    the algorithm such that we should be able to change the algorithm at run time.
    Also **Cache** class should not change when a new algorithm is being added. This
    is where **Strategy DesignPattern** comes into the picture. The strategy pattern
    suggests creating a family of the algorithm with each algorithm having its own
    class. Each of these classes follows the same interface and this makes the algorithm
    interchangeable within the family. Let’s say the common interface name is **evictionAlgo**.
    Then **FIFO** and **LRU** classes will implement this interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Now our main **Cache** class will embed **evictionAlgo** interface. Instead
    of implementing all types of eviction algorithms in itself, our Cache class will
    delegate all of them to the **evictionAlgo** interface. Since evictionAlgo is
    an interface, we can run time change the algorithm to either be LRU, or FIFO without
    any change in Cache class.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will use the Factory Design Pattern to create the instance of each
    of the algorithms ie. FIFO, LRU
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how Get and Set are going to work in O(1) time
  prefs: []
  type: TYPE_NORMAL
- en: '**Set(key int, value int)**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any set operation, it will first create a doubly-linked list node with key
    and value supplied. Then an entry will be made into the map with key as the input
    key and value as the address of the node. Once the node is created, then there
    are two cases
  prefs: []
  type: TYPE_NORMAL
- en: '**The cache is not full** –  In this case, it will pass the control to the
    current evictionAlgorithm interface. The evictionAlgorithm interface is going
    to do insert that node in a double-linked list either at the end or at the front
    depending upon the current eviction algorithm. Every operation is O(1) here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The cache is full** – In this case, it will pass the control to the current
    evictionAlgorithm interface to evict one of the nodes based upon the current eviction
    Algorithm. Once that node is evicted it will insert the new node. Every operation
    is O(1) here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get(key int)**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any Get operation, it will first check the map if the given key exists.
    If it exists then it will fetch the address of the node pointed to by key in the
    map. It will then fetch the value from the node. Then it will pass the control
    to the current evictionAlgorithm interface. The evictionAlgorithm interface is
    going to shuffle the current node in the doubly-linked list either at the end
    or front depending upon the current eviction algorithm. Every operation is O(1)
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-Level Design**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is the low-level design expressed in go programming language. Later we
    will see a UML diagram as well as a working example
  prefs: []
  type: TYPE_NORMAL
- en: '**Cache Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Doubly Linked List**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Eviction Algorithm Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**FIFO Algorithm** – It implements the Eviction Algorithm Interface'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**LRU Algorithm** – It implements the Eviction Algorithm Interface'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**UML Diagram**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/93ba75ea015d9c055a7f090acda77d83.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Program**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the full working code in go programming language if anyone is interested.
  prefs: []
  type: TYPE_NORMAL
- en: '**doublylinklist.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**evictionAlgorithm.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**lru.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**fifo.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**cache.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**main.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Conclusion**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is all about designing an In-Memory Cache. Hope you have liked this article.
    Please share feedback in the comments
  prefs: []
  type: TYPE_NORMAL
- en: '[cache](https://techbyexample.com/tag/cache/)*   [fifo](https://techbyexample.com/tag/fifo/)*   [lru](https://techbyexample.com/tag/lru/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
