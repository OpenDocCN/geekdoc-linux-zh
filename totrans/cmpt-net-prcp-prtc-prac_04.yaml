- en: Network security#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络安全#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/security.html](https://4ed.computer-networking.info/syllabus/default/hosts/security.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://4ed.computer-networking.info/syllabus/default/hosts/security.html](https://4ed.computer-networking.info/syllabus/default/hosts/security.html)'
- en: In the early days, data networks were mainly used by researchers and security
    was not a concern. A few users were connected and capable of using the network.
    Almost all the devices attached to the network were openly accessible and users
    were trusted. As the utilization of the networks grew, security concerns started
    to appear. In universities, researchers and professors did not always trust their
    students and required some forms of access control. On standalone computers, the
    common access control mechanism is the password. A username is assigned to each
    user and when this user wants to access the computer, he or she needs to provide
    his/her username and his/her password. Most passwords are composed of a sequence
    of characters. The strength of the password is function of the difficulty of guessing
    the characters chosen by each user. Various guidelines have been defined on how
    to select a good password [[1]](#fpasswords). Some systems require regular modifications
    of the passwords chosen by their users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，数据网络主要被研究人员使用，安全性并不是一个关注点。只有少数用户连接并能够使用网络。几乎所有连接到网络的设备都是公开可访问的，用户被信任。随着网络的利用增长，安全问题开始出现。在大学里，研究人员和教授并不总是信任他们的学生，并需要某种形式的访问控制。在独立计算机上，常见的访问控制机制是密码。每个用户都分配了一个用户名，当这个用户想要访问计算机时，他或她需要提供他的/她的用户名和密码。大多数密码由一系列字符组成。密码的强度取决于猜测每个用户选择的字符的难度。已经定义了各种关于如何选择一个好的密码的指南[[1]](#fpasswords)。一些系统要求用户定期更改他们选择的密码。
- en: When the first computers were attached to data networks, applications were developed
    to enable them to access to remote computers through the network. To authenticate
    the remote users, these applications have also relied on usernames and passwords.
    When a user connects to a distant computer, she sends her username through the
    network and then provides her password to confirm her identity. This authentication
    scheme is presented in the time sequence diagram below.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一台计算机连接到数据网络时，开发了应用程序以使它们能够通过网络访问远程计算机。为了验证远程用户，这些应用程序也依赖于用户名和密码。当用户连接到远程计算机时，她通过网络发送她的用户名，然后提供她的密码以确认她的身份。此身份验证方案在下方的时序图中展示。
- en: '![msc {'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(I'm Alice)\n\n" ] ,
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(I'm Alice)\n\n" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(I'm Alice)\n\n" ];
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(I'm Alice)\n\n" ];
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "DATA.req(Password:)\n\n" ] ,
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "DATA.req(Password:)\n\n" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a [ label = "DATA.ind(Password:)\n\n" ];
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "DATA.ind(Password:)\n\n" ];
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(1234xyz$)\n\n" ] ,
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(1234xyz$)\n\n" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(1234xyz$)\n\n" ];
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(1234xyz$)\n\n" ];
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "DATA.req(Access)\n\n" ] ,
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "DATA.req(Access)\n\n" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a [ label = "DATA.ind(Access)\n\n" ];
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "DATA.ind(Access)\n\n" ];
- en: '}](../Images/ee7754cb2df3b43180ffc3b27a683d83.png)<map id="155fbd15184cf522dc2c2ef20abe46b4639509c2"
    name="155fbd15184cf522dc2c2ef20abe46b4639509c2"></map>'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/ee7754cb2df3b43180ffc3b27a683d83.png)<map id="155fbd15184cf522dc2c2ef20abe46b4639509c2"
    name="155fbd15184cf522dc2c2ef20abe46b4639509c2"></map>'
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alice and Bob
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob
- en: Alice and Bob are the first names that are used in examples for security techniques.
    They first appeared in a seminal paper by Diffie and Hellman [[DH1976]](../bibliography.html#dh1976).
    Since then, Alice and Bob are the most frequently used names to represent the
    users who interact with a network. Other characters such as Eve or Mallory have
    been added over the years. We will explain their respective roles later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob是用于安全技术示例中的第一个名字。它们首次出现在Diffie和Hellman的一篇开创性论文中[[DH1976]](../bibliography.html#dh1976)。从那时起，Alice和Bob成为表示与网络交互的用户时最常用的名字。多年来，还添加了其他角色，如Eve或Mallory。我们将在后面解释它们各自的角色。
- en: Security threats[#](#security-threats "Link to this heading")
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全威胁[#](#security-threats "链接到这个标题")
- en: When analyzing security issues in computer networks, it is useful to reason
    about the capabilities of the attacker who wants to exploit some breach in the
    security of the network. There are different types of attackers. Some have generic
    capabilities, others are specific to a given technology or network protocol. In
    this section, we discuss some important threats that a network architect must
    take into account.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析计算机网络中的安全问题时，考虑想要利用网络安全漏洞的攻击者的能力是有用的。存在不同类型的攻击者。一些具有通用能力，而另一些则特定于某种技术或网络协议。在本节中，我们将讨论网络架构师必须考虑的一些重要威胁。
- en: The first type of attacker is called the passive attacker. A passive attacker
    is someone able to observe and usually store the information (e.g. the packets)
    exchanged in a given network or subset of it (e.g. a specific link). This attacker
    has access to all the data passing through this specific link. This is the most
    basic type of attacker and many network technologies are vulnerable to such attacks.
    In the above example, a passive attacker could easily capture the password sent
    by Alice and reuse it later to be authenticated as Alice on the remote computer.
    This is illustrated in the figure below where we do not show anymore the `DATA.req`
    and `DATA.ind` primitives but only the messages exchanged. Throughout this chapter,
    we will always use Eve as a user who is able to eavesdrop the data passing in
    front of her.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种攻击者被称为被动攻击者。被动攻击者是指能够观察并通常存储在给定网络或其子集（例如，特定链路）中交换的信息（例如，数据包）的人。这种攻击者可以访问通过此特定链路的所有数据。这是最基本的攻击类型，许多网络技术都容易受到此类攻击。在上面的示例中，被动攻击者可以轻易地捕获Alice发送的密码，并在以后将其重用来在远程计算机上以Alice的身份进行认证。这在下图中得到了说明，其中我们不再显示`DATA.req`和`DATA.ind`原语，而只显示交换的消息。在本章中，我们将始终使用Eve作为能够监听她面前通过的数据的用户。
- en: '![msc {'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Eve", linecolour=red],
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Eve", linecolour=red],
- en: d [label="", linecolour=white],
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: e [label="Bob", linecolour=black],
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e [label="Bob", linecolour=black],
- en: f [label="", linecolour=white];
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f [label="", linecolour=white];
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>e [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>e [ label = "我是Alice\n\n", arcskip="1"];
- en: e=>f [ label = "" ];
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ];
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: e=>f [ label = "" ] ,
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ] ,
- en: e>>b [ label = "Password:\n\n", arcskip="1"];
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e>>b [ label = "密码：\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ];
- en: b>>e [ label = "1234xyz$\n\n", arcskip="1"];
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>e [ label = "1234xyz$\n\n", arcskip="1"];
- en: e=>f [ label = "" ];
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ];
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: e=>f [ label = "" ] ,
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ] ,
- en: e>>b [ label = "Access\n\n", arcskip="1"];
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e>>b [ label = "访问\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/f4b5846cad3728586ed1ef7e20d24afb.png)<map id="17921862b047d560c7fe7db8be3c8ccaa1e34782"
    name="17921862b047d560c7fe7db8be3c8ccaa1e34782"></map>'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f4b5846cad3728586ed1ef7e20d24afb.png)<map id="17921862b047d560c7fe7db8be3c8ccaa1e34782"
    name="17921862b047d560c7fe7db8be3c8ccaa1e34782"></map>'
- en: In the above example, Eve can capture all the packets exchanged by Bob and Alice.
    This implies that Eve can discover Alice’s username and Alice’s password. With
    this information, Eve can then authenticate as Alice on Bob’s computer and do
    whatever Alice is authorized to do. This is a major problem from a security point
    of view. To prevent this attack, Alice should never send her password in clear
    over a network where someone could eavesdrop the information. In some networks,
    such as an open wireless network, an attacker can easily collect all the data
    sent by a particular user. In other networks, this is a bit more complex depending
    on the network technology used, but various software packages exist to automate
    this process. As will be described later, the best approach to prevent this type
    of attack is to rely on cryptographic techniques to ensure that passwords are
    never sent in clear.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，Eve可以捕获Bob和Alice交换的所有数据包。这意味着Eve可以发现Alice的用户名和密码。有了这些信息，Eve就可以在Bob的计算机上以Alice的身份进行认证，并执行Alice被授权执行的所有操作。这是一个重大的安全问题。为了防止这种攻击，Alice永远不应该在网络中发送她的密码，因为有人可能会监听信息。在一些网络中，例如开放的无线网络，攻击者可以轻易地收集特定用户发送的所有数据。在其他网络中，这要复杂一些，具体取决于使用的网络技术，但存在各种软件包来自动化此过程。正如稍后将要描述的，防止此类攻击的最佳方法是依靠加密技术来确保密码永远不会以明文形式发送。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Pervasive monitoring
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍监控
- en: In the previous example, we have explained how Eve could capture data from a
    particular user. This is not the only attack of this type. In 2013, based on documents
    collected by Edward Snowden, the press revealed that several governmental agencies
    were collecting lots of data on various links that compose the global Internet
    [[Greenwald2014]](../bibliography.html#greenwald2014). Thanks to this massive
    amount of data, these governmental agencies have been able to extract lots of
    information about the behavior of Internet users. Like Eve, they are in a position
    to extract passwords, usernames and other privacy sensitive data from all the
    packets that they have captured. However, it seems that these agencies were often
    more interested in various meta data, e.g. information showing with whom a given
    user communicates than the actual data exchanged. These revelations have shocked
    the Internet community and the [Internet Engineering Task Force](https://www.ietf.org)
    that manages the standardization of Internet protocols has declared in [**RFC
    7258**](https://datatracker.ietf.org/doc/html/rfc7258.html) that such pervasive
    monitoring is an attack that need to be countered in the development of new protocols.
    Several new protocols and extensions to existing ones are being developed to counter
    these attacks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们解释了Eve如何捕获特定用户的数据。这不是这种类型攻击的唯一一种。2013年，基于爱德华·斯诺登收集的文件，媒体揭露了几家政府机构正在收集全球互联网组成的各种链接的大量数据[[Greenwald2014]](../bibliography.html#greenwald2014)。得益于这大量数据，这些政府机构能够提取大量关于互联网用户行为的信息。像Eve一样，他们处于从他们捕获的所有数据包中提取密码、用户名和其他隐私敏感数据的位置。然而，似乎这些机构对各种元数据更感兴趣，例如显示特定用户与谁交流的信息，而不是实际交换的数据。这些揭露震惊了互联网社区和负责管理互联网协议标准化的[互联网工程任务组](https://www.ietf.org)，该组织在[**RFC
    7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)中声明，这种普遍监控是一种需要在开发新协议时进行反击的攻击。正在开发一些新的协议和对现有协议的扩展，以应对这些攻击。
- en: Eavesdropping and pervasive monitoring are not the only possible attacks against
    a network. Another type of attacker is the active attacker. In the literature,
    these attacks are often called Man in the middle or MITM attacks. Such attacks
    occur when one user, let us call him Mallory, has managed to configure the network
    so that he can both capture and modify the packets exchanged by two users. The
    simplest scenario is when Mallory controls a router that is on the path used by
    both Alice and Bob. For example, Alice could be connected to a WiFi access router
    controlled by Mallory and Bob would be a regular server on the Internet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 监听和普遍监控并不是对网络发起攻击的唯一方式。还有一种攻击者是主动攻击者。在文献中，这类攻击通常被称为中间人攻击或MITM攻击。这种攻击发生在某个用户，让我们称他为Mallory，成功配置了网络，使他能够捕获和修改两个用户之间交换的数据包。最简单的场景是当Mallory控制着一个同时被Alice和Bob使用的路由器。例如，Alice可能连接到由Mallory控制的WiFi接入路由器，而Bob则是一个普通的互联网服务器。
- en: '![Figure made with TikZ](../Images/c7ceeff3d8a02de071eac1377ed85bc7.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c7ceeff3d8a02de071eac1377ed85bc7.png)'
- en: As Mallory receives all the packets sent by both Bob and Alice, he can modify
    them at will. For example, he could modify the commands sent by Alice to the server
    managed by Bob and change the responses sent by the server. This type of attack
    is very powerful and sometimes difficult to counter without relying on advanced
    cryptographic techniques.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Mallory接收到了Bob和Alice发送的所有数据包，他可以随意修改它们。例如，他可以修改Alice发送给Bob管理的服务器的命令，并更改服务器发送的响应。这种攻击非常强大，有时在没有依赖高级加密技术的情况下很难进行反击。
- en: The last type of attack that we consider in this introduction are the Denial
    of Service or DoS attacks. During such an attack, the attacker generates enough
    packets to saturate a given service and prevent it from operating correctly. The
    simplest Denial of Service attack is to send more packets that the bandwidth of
    the link that attaches the target to the network. The target could be a single
    server, a company or even an entire country. If these packets all come from the
    same source, then the victim can identify the attacker and contact the law enforcement
    authorities. In practice, such denial of service attacks do not originate from
    a single source. The attacker usually compromises a (possibly very large) set
    of sources and forces them to send packets to saturate a given target. Since the
    attacking traffic comes from a wide range of sources, it is difficult for the
    victim to locate the culprit and also to counter the attack. Saturating a link
    is the simplest example of Distributed Denial of Service (DDoS) attacks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍中，我们考虑的最后一种攻击类型是拒绝服务或DoS攻击。在此类攻击期间，攻击者生成足够的数据包来饱和特定的服务，并阻止其正确运行。最简单的拒绝服务攻击就是发送比连接目标到网络的数据链带宽更多的数据包。目标可能是一台服务器、一家公司，甚至是一个整个国家。如果这些数据包都来自同一个源头，那么受害者可以识别攻击者并联系执法机构。在实践中，这种拒绝服务攻击并不来自单一源头。攻击者通常会破坏（可能非常大）的一组源头，并迫使它们向特定的目标发送数据包以饱和目标。由于攻击流量来自广泛的源头，受害者很难定位肇事者，也难以对抗攻击。饱和链路是分布式拒绝服务（DDoS）攻击的最简单例子。
- en: In practice, there is a possibility of denial of service attacks as soon as
    there is a limited resource somewhere in the network. This resource can be the
    bandwidth of a link, but it could also be the computational power of a server,
    its memory or even the size of tables used by a given protocol implementation.
    Defending against real DoS attacks can be difficult, especially if the attacker
    controls a large number of sources that are used to launch the attacks. In terms
    of bandwidth, DoS attacks composed of a few Gbps to a few tens of Gbps of traffic
    are frequent on the Internet. In 2015, [github.com](http://www.github.com) suffered
    from a distributed DoS that reached a top bandwidth of 400 Gbps according to some
    [reports](http://www.techworld.com/news/security/worlds-largest-ddos-attack-reached-400gbps-says-arbor-networks-3595715/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，只要网络中某个地方存在有限的资源，就可能发生拒绝服务攻击。这种资源可以是数据链的带宽，但也可能是服务器的计算能力、其内存，甚至是特定协议实现使用的表的大小。防御真正的DoS攻击可能很困难，特别是如果攻击者控制了大量用于发起攻击的源头。从带宽的角度来看，由几Gbps到几十Gbps流量组成的DoS攻击在互联网上很常见。2015年，[github.com](http://www.github.com)遭受了一次分布式DoS攻击，根据一些[报道](http://www.techworld.com/news/security/worlds-largest-ddos-attack-reached-400gbps-says-arbor-networks-3595715/)，其峰值带宽达到了400
    Gbps。
- en: When designing network protocols and applications that will be deployed on a
    large scale, it is important to take those DDoS attacks into account. Attackers
    use different strategies to launch DDoS attacks. Some have managed to gain control
    of a large number of sources by injecting malware on them. Others, and this is
    where protocol designers have an important role to play, simply exploit design
    flaws in some protocols. Consider a simple request-response protocol where the
    client sends a request and the server replies with a response. Often the response
    is larger or much larger than the request sent by the client. Consider that such
    a simple protocol is used over a datagram network. When Alice sends a datagram
    to Bob containing her request, Bob extracts both the request and Alice’s address
    from the packet. He then sends his response in a single packet destined to Alice.
    Mallory would like to create a DoS attack against Alice without being identified.
    Since he has studied the specification of this protocol, he can send a request
    to Bob inside a packet having Alice’s address as its source address. Bob will
    process the request and send his (large) response to Alice. If the response has
    the same size as the request, Mallory is producing a reflection attack since his
    packets are reflected by Bob. Alice would think that she is attacked by Bob. If
    there are many servers that operate the same service as Bob, Mallory could hide
    behind a large number of such reflectors. Unfortunately, the reflection attack
    can also become an amplification attack. This happens when the response sent by
    Bob is larger than the request that it has received. If the response is \(k\)
    times larger than the request, then when Mallory consumes 1 Gbps of bandwidth
    to send requests, his victim receives \(k\) Gbps of attack traffic. Such amplification
    attacks are a very important problem and protocol designers should ensure that
    they never send a large response before having received the proof that the request
    that they have received originated from the source indicated in the request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计将在大规模上部署的网络协议和应用时，考虑那些DDoS攻击是很重要的。攻击者使用不同的策略来发起DDoS攻击。有些人通过在这些设备上注入恶意软件，成功控制了大量来源。其他人，这也是协议设计者扮演重要角色的地方，只是利用某些协议的设计缺陷。考虑一个简单的请求-响应协议，其中客户端发送请求，服务器以响应的形式回复。通常，响应的大小大于或远大于客户端发送的请求。考虑这样一个简单的协议在数据报网络上的使用。当Alice向Bob发送包含其请求的数据报时，Bob从数据包中提取请求和Alice的地址。然后，他发送一个单独的数据包作为对Alice的响应。Mallory想要对Alice发起DoS攻击而不被识别。由于他已经研究了该协议的规范，他可以在一个数据包中向Bob发送请求，该数据包的源地址是Alice的地址。Bob将处理请求，并将他的（大）响应发送给Alice。如果响应的大小与请求相同，Mallory正在产生一个反射攻击，因为他的数据包被Bob反射。Alice会认为她被Bob攻击了。如果有许多服务器运行与Bob相同的服务，Mallory可以隐藏在大量这样的反射器后面。不幸的是，反射攻击也可以变成放大攻击。这种情况发生在Bob发送的响应比它接收到的请求更大的情况下。如果响应是请求的\(k\)倍大，那么当Mallory消耗1
    Gbps的带宽来发送请求时，他的受害者会接收到\(k\) Gbps的攻击流量。这种放大攻击是一个非常重要的问题，协议设计者应确保在收到请求已从请求中指示的源发出的证明之前，他们永远不会发送一个大的响应。
- en: Cryptographic primitives[#](#cryptographic-primitives "Link to this heading")
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学原语[#](#cryptographic-primitives "链接到这个标题")
- en: Cryptography techniques have initially been defined and used by spies and armies
    to exchange secret information in manner that ensures that adversaries cannot
    decode the information even if they capture the message or the person carrying
    the message. A wide range of techniques have been defined. The first techniques
    relied on their secrecy to operate. One of the first encryption schemes is attributed
    to Julius Caesar. When he sent confidential information to his generals, he would
    encode each message by replacing each letter with another letter that is \(n\)
    positions after this letter in the alphabet. For example, the message SECRET becomes
    VHFUHW when encoded using Caesar’s cipher. This technique could have puzzled some
    soldiers during Caesar’s wars, but today even young kids can recover the original
    message from the ciphered one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 密码技术最初是由间谍和军队定义和使用的，目的是以确保即使敌手截获了信息或携带信息的人，也无法解码信息的方式来交换秘密信息。已经定义了多种技术。最初的技术依赖于其保密性来运作。最早的加密方案之一归功于尤利乌斯·凯撒。当他向他的将军们发送机密信息时，他会通过将每个字母替换为字母表中该字母之后
    \(n\) 个位置的字母来编码每条信息。例如，信息“SECRET”在凯撒密码编码后变为“VHFUHW”。这种技术在凯撒的战争中可能会让一些士兵感到困惑，但如今甚至小孩子也能从加密的信息中恢复出原始信息。
- en: 'The security of the Caesar cipher depends on the confidentiality of the algorithm,
    but experience has shown that it is impossible to assume that an algorithm will
    remain secret, even for military applications. Instead, cryptographic techniques
    must be designed by assuming that the algorithm will be public and known to anyone.
    However, its behavior must be controlled by a small parameter, known as the key,
    that will only be known by the users who need to communicate secretly. This principle
    is attributed to Auguste Kerckhoff, a French cryptographer who first documented
    it :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码的安全性依赖于算法的保密性，但经验表明，即使对于军事应用，也无法假设算法会保持保密。相反，密码技术必须设计成假设算法将是公开的，并且任何人都能知道。然而，其行为必须由一个小的参数控制，即密钥，只有需要秘密通信的用户才知道。这个原理归功于法国密码学家奥古斯特·凯克霍夫，他首次记录了这一原理：
- en: A cryptographic algorithm should be secure even if the attacker knows everything
    about the system, except one parameter known as the secret key.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个加密算法即使在攻击者知道系统的一切信息，除了被称为密钥的一个参数的情况下，也应该是安全的。
- en: This principle is important because it remains the basic assumption of all cryptographers.
    Any system that relies on the secrecy of its algorithm to be considered secure
    is doomed to fail and be broken one day.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原理很重要，因为它仍然是所有密码学家的基本假设。任何依赖于其算法保密性来被认为是安全的系统注定会失败，并最终被破解。
- en: With the Kerckhoff principle, we can now discuss a simple but powerful encryption
    scheme that relies on the XOR logic operation. This operation is easily implemented
    in hardware and is supported by all microprocessors. Given a secret, \(K\), it
    is possible to encode a message M by computing \(C_M = K \oplus M\). The receiver
    of this messages can recover the original message as since \(M = K \oplus (K \oplus
    M)\). This XOR operation is the key operation of the perfect cipher that is also
    called the Vernam cipher or the one-time pad. This cipher relies on a key that
    contains purely random bits. The encrypted message is then produced by XORing
    all the bits of the message with all the bits of the key. Since the key is random,
    it is impossible for an attacker to recover the original text (or plain text)
    from the encrypted one. From a security viewpoint, the one-time-pad is the best
    solution provided that the key is as long as the message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据凯克霍夫原理，我们现在可以讨论一个简单但强大的加密方案，该方案依赖于XOR逻辑运算。这种运算在硬件中很容易实现，并且所有微处理器都支持它。给定一个秘密，\(K\)，可以通过计算
    \(C_M = K \oplus M\) 来编码信息 \(M\)。接收这条信息的接收者可以通过 \(M = K \oplus (K \oplus M)\)
    恢复原始信息。这个XOR运算是完美密码（也称为Vernam密码或一次性密码）的关键操作。这种密码依赖于一个包含纯随机位的密钥。加密信息是通过将信息的所有位与密钥的所有位进行XOR运算来生成的。由于密钥是随机的，攻击者无法从加密的信息中恢复出原始文本（或明文）。从安全角度来看，只要密钥的长度与信息相同，一次性密码就是最佳解决方案。
- en: Unfortunately, it is difficult to use this cipher in practice since the key
    must be as long as the message that needs to be transmitted. If the key is smaller
    than the message and the message is divided into blocks that have the same length
    as the key, then the scheme becomes less secure since the same key is used to
    decrypt different parts of the message. In practice, XOR is often one of the basic
    operations used by encryption schemes. To be usable, the deployed encryption schemes
    use keys that are composed of a small number of bits, typically 56, 64, 128, 256,
    …
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，在实际应用中很难使用这种密码，因为密钥的长度必须与需要传输的消息长度相同。如果密钥的长度小于消息长度，并且消息被分成与密钥长度相同的块，那么该方案的安全性就会降低，因为相同的密钥被用来解密消息的不同部分。在实践中，XOR通常是被加密方案中使用的最基本操作之一。为了能够使用，部署的加密方案使用由少量比特组成的密钥，通常是56、64、128、256位……
- en: 'A secret key encryption scheme is a perfectly reversible functions, i.e. given
    an encryption function E, there is an associated decryption function D such that
    \(\forall K, \forall M : D(K, E(K,M))=M\).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '秘密密钥加密方案是一个完全可逆的函数，即给定一个加密函数E，存在一个相关的解密函数D，使得\(\forall K, \forall M : D(K,
    E(K,M))=M\)。'
- en: 'Various secret key cryptographic functions have been proposed, implemented
    and deployed. The most popular ones are :'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了各种秘密密钥加密函数，并已实施和部署。其中最受欢迎的是：
- en: DES, the Data Encryption Standard that became a standard in 1977 and has been
    widely used by industry. It uses 56 bits keys that are not considered sufficiently
    secure nowadays since attackers can launch brute-force attacks by testing all
    possible keys. Triple DES combines three 56 bits keys, making the brute force
    attacks more difficult.
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES（数据加密标准），1977年成为标准并被工业界广泛使用。它使用56位密钥，现在被认为不够安全，因为攻击者可以通过测试所有可能的密钥来发起暴力攻击。三重DES结合了三个56位密钥，使得暴力攻击更加困难。
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RC4 is an encryption scheme defined in the late 1980s by Ron Rivest for RSA
    Security. Given the speed of its software implementation, it has been included
    in various protocols and implementations. However, cryptographers have identified
    several weaknesses in this algorithm. It is now deprecated and should not be used
    anymore [**RFC 7465**](https://datatracker.ietf.org/doc/html/rfc7465.html).
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC4是由Ron Rivest在1980年代末为RSA Security定义的加密方案。由于其软件实现的快速性，它被包含在各种协议和实现中。然而，密码学家已经发现了该算法的几个弱点。现在它已被弃用，不应再使用[**RFC
    7465**](https://datatracker.ietf.org/doc/html/rfc7465.html)。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: AES or the Advanced Encryption Standard is an encryption scheme that was designed
    by the Belgian cryptographers Joan Daemen and Vincent Rijmen in 2001 [[DR2002]](../bibliography.html#dr2002).
    This algorithm has been standardized by the U.S. National Institute of Standards
    and Technology (NIST). It is now used by a wide range of applications and various
    hardware and software implementations exist. Many microprocessors include special
    instructions that ease the implementation of AES. AES divides the message to be
    encrypted in blocks of 128 bits and uses keys of length 128, 192 or 256 bits.
    The block size and the key length are important parameters of an encryption scheme.
    The block size indicates the smallest message that can be encrypted and forces
    the sender to divide each message in blocks of the supported size. If the message
    is larger than an integer number of blocks, then the message must be padded before
    being encrypted and this padding must be removed after decryption. The key size
    indicates the resistance of the encryption scheme against brute force attacks,
    i.e. attacks where the attacker tries all possible keys to find the correct one.
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES或高级加密标准是由比利时密码学家Joan Daemen和Vincent Rijmen于2001年设计的加密方案[[DR2002]](../bibliography.html#dr2002)。该算法已被美国国家标准与技术研究院（NIST）标准化。现在它被广泛应用于各种应用和硬件及软件实现中。许多微处理器包括专门的指令，以简化AES的实现。AES将待加密的消息分成128位的块，并使用128、192或256位的密钥。块大小和密钥长度是加密方案的重要参数。块大小表示可以加密的最小消息，并强制发送者将每条消息分成支持大小的块。如果消息的长度大于整数倍的块大小，那么在加密之前必须对消息进行填充，并且在解密后必须移除这种填充。密钥大小表示加密方案对暴力攻击的抵抗力，即攻击者尝试所有可能的密钥以找到正确密钥的攻击。
- en: AES is widely used as of this writing, but other secret key encryption schemes
    continue to appear. ChaCha20, proposed by D. Bernstein is now used by several
    internet protocols [**RFC 7539**](https://datatracker.ietf.org/doc/html/rfc7539.html).
    A detailed discussion of encryption schemes is outside the scope of this book.
    We will consider encryption schemes as black boxes whose operation depends on
    a single key. A detailed overview of several of these schemes may be found in
    [[MVV2011]](../bibliography.html#mvv2011).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文写作时，AES 被广泛使用，但其他秘密密钥加密方案仍在出现。ChaCha20，由 D. Bernstein 提出，现在被几个互联网协议使用 [**RFC
    7539**](https://datatracker.ietf.org/doc/html/rfc7539.html)。加密方案的详细讨论超出了本书的范围。我们将考虑加密方案作为黑盒，其操作依赖于单个密钥。这些方案中的几个详细概述可以在
    [[MVV2011]](../bibliography.html#mvv2011) 中找到。
- en: 'In the 1970s, Diffie and Hellman proposed in their seminal paper [[DH1976]](../bibliography.html#dh1976),
    a different type of encryption : public key cryptography. In public key cryptography,
    each user has two different keys :'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 20 世纪 70 年代，Diffie 和 Hellman 在他们的开创性论文 [[DH1976]](../bibliography.html#dh1976)
    中提出了不同类型的加密：公钥加密。在公钥加密中，每个用户都有两个不同的密钥：
- en: a public key (\(K_{pub}\)) that he can distribute to everyone
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥 (\(K_{pub}\))，他可以向每个人分发
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a private key (\(K_{priv}\)) that he needs to store in a secure manner and never
    reveal to anyone
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私钥 (\(K_{priv}\))，他需要以安全的方式存储，并且永远不向任何人透露
- en: These two keys are generated together and they are linked by a complex mathematical
    relationship that is such that it is computationally difficult to compute \(K_{priv}\)
    from \(K_{pub}\).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个密钥一起生成，并且它们通过一个复杂的数学关系相互关联，这种关系使得从 \(K_{pub}\) 计算出 \(K_{priv}\) 在计算上是困难的。
- en: 'A public key cryptographic scheme is a combination of two functions :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密方案是两个函数的组合：
- en: an encryption function, \(E_{p}\), that takes a key and a message as parameters
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个加密函数，\(E_{p}\)，它接受密钥和消息作为参数
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a decryption function, \(D_{p}\), that takes a key and a message as parameters
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解密函数，\(D_{p}\)，它接受密钥和消息作为参数
- en: 'The public key is used to encrypt a message so that it can only be read by
    the intended recipient. For example, let us consider two users : Alice and Bob.
    Alice (resp. Bob) uses the keys \(A_{priv}\) and \(A_{pub}\) (resp. \(B_{priv}\)
    and \(B_{pub}\)). To send a secure message M to Alice, Bob computes \(CM=E_p(A_{pub},M)\)
    and Alice can decrypt it by using \(D_p(A_{priv},CM)=D_p(A_{priv},E_p(A_{pub},M))=M\).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥用于加密消息，以便只有预期的接收者才能阅读。例如，让我们考虑两个用户：爱丽丝和鲍勃。爱丽丝（分别鲍勃）使用密钥 \(A_{priv}\) 和 \(A_{pub}\)（分别
    \(B_{priv}\) 和 \(B_{pub}\)）。要向爱丽丝发送安全消息 M，鲍勃计算 \(CM=E_p(A_{pub},M)\)，而爱丽丝可以通过使用
    \(D_p(A_{priv},CM)=D_p(A_{priv},E_p(A_{pub},M))=M\) 来解密它。
- en: 'Several public key encryption schemes have been proposed. Two of them have
    reached wide deployment :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了几种公钥加密方案。其中两个已经达到广泛部署：
- en: The Rivest Shamir Adleman (RSA) algorithm [[2]](#frsa) proposed in [[RSA1978]](../bibliography.html#rsa1978)
    that relies on modular exponentiation with large integers.
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rivest Shamir Adleman (RSA) 算法 [[2]](#frsa)，在 [[RSA1978]](../bibliography.html#rsa1978)
    中提出，依赖于大整数的模幂运算。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The Elliptic Curve Cryptography techniques [[3]](#fecc) that rely on special
    properties of elliptic curves.
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于椭圆曲线特殊性质的椭圆曲线密码学技术 [[3]](#fecc)。
- en: Another interesting property of public key cryptography is its ability to compute
    signatures that can be used to authenticate a message. This capability comes from
    the utilization of two different keys that are linked together. If Alice wants
    to sign a message M, she can compute \(SM=E_p(A_{priv},M)\). Anyone who receives
    this signed messaged can extract its content as \(D_p(A_{pub},SM)=D_p(A_{pub},E_p(A_{priv},M))=M\).
    Everyone can use \(A_{pub}\) to check that the message was signed by using Alice’s
    private key (\(A_{priv}\)). Since this key is only known by Alice, the ability
    to decrypt SM is a proof that the message was signed by Alice herself.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学的另一个有趣特性是其计算签名的功能，这些签名可以用来验证消息。这种能力来自于两个不同密钥的利用，它们相互关联。如果爱丽丝想要签名消息 M，她可以计算
    \(SM=E_p(A_{priv},M)\)。任何收到这个签名消息的人都可以提取其内容作为 \(D_p(A_{pub},SM)=D_p(A_{pub},E_p(A_{priv},M))=M\)。每个人都可以使用
    \(A_{pub}\) 来检查消息是否由爱丽丝的私钥 (\(A_{priv}\)) 签名。由于这个密钥只有爱丽丝知道，解密 SM 的能力是消息由爱丽丝本人签名的证明。
- en: In practice, encrypting a message to sign it can be computationally costly,
    in particular if the message is a large file. A faster solution would be to summarize
    the document and only sign the summary of the document. A naive approach could
    be based on a checksum or CRC computed over the message. Alice would then compute
    \(C=Checksum(M)\) and \(SC=E_p(A_{priv},C)\). She would then send both M and SC
    to the recipient of the message who can easily compute C from SC and verify the
    authenticity of the message. Unfortunately, this solution does not protect Alice
    and the message’s recipient against a man-in-the-middle attack. If Mallory can
    intercept the message sent by Alice, he can easily modify Alice’s message and
    tweak it so that it has the same checksum as the original one. The CRCs, although
    more complex to compute, suffer from the same problem.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，为了签名而加密一条消息可能会造成计算上的开销，尤其是如果消息是一个大文件。一个更快的解决方案是对文档进行总结，并仅对文档的总结进行签名。一个简单的方法可能是基于对消息计算校验和或
    CRC。Alice 会计算 \(C=Checksum(M)\) 和 \(SC=E_p(A_{priv},C)\)。然后她会将 M 和 SC 发送给消息的接收者，接收者可以轻松地从
    SC 计算出 C 并验证消息的真实性。不幸的是，这个解决方案并不能保护 Alice 和消息接收者免受中间人攻击。如果 Mallory 可以拦截 Alice
    发送的消息，他可以轻松地修改 Alice 的消息，并调整它使其具有与原始消息相同的校验和。CRC 虽然计算起来更复杂，但存在同样的问题。
- en: 'To efficiently sign messages, Alice needs to be able to compute a summary of
    her message in a way that makes prohibits an attacker from generating a different
    message that has the same summary. Cryptographic hash functions were designed
    to solve this problem. The ideal hash function is a function that returns a different
    number for every possible input. In practice, it is impossible to find such a
    function. Cryptographic hash functions are an approximation of this perfect summarization
    function. They compute a summary of a given message in 128, 160, 256 bits or more.
    They also exhibit the avalanche effect. This effect indicates that a small change
    in the message causes a large change in the hash value. Finally hash functions
    are very difficult to invert. Knowing a hash value, it is computationally very
    difficult to find the corresponding input message. Several hash functions have
    been proposed by cryptographers. The most popular ones are :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地签名消息，Alice 需要能够以阻止攻击者生成具有相同摘要的不同消息的方式计算她消息的摘要。加密哈希函数被设计来解决这个问题。理想的哈希函数是对于每个可能的输入都返回不同数字的函数。在实践中，找到这样的函数是不可能的。加密哈希函数是这个完美摘要函数的近似。它们计算给定消息的摘要，长度为
    128 位、160 位、256 位或更多。它们还表现出雪崩效应。这种效应表明，消息中的微小变化会导致哈希值的大幅变化。最后，哈希函数非常难以逆向。知道哈希值，在计算上很难找到相应的输入消息。密码学家们提出了几种哈希函数。最受欢迎的包括：
- en: MD5, originally proposed in [**RFC 1321**](https://datatracker.ietf.org/doc/html/rfc1321.html).
    It has been used in a wide range of applications. In 2010, attacks against MD5
    were published and this hash function is now deprecated.
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: MD5，最初在 [**RFC 1321**](https://datatracker.ietf.org/doc/html/rfc1321.html) 中提出。它被广泛应用于各种应用中。2010
    年，针对 MD5 的攻击被公布，这个哈希函数现在已被弃用。
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SHA-1 is a cryptographic hash function that was standardized by the NIST in
    1995\. It outputs 160 bits results. It is now used in a variety of network protocols.
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA-1 是一种由 NIST 在 1995 年标准化的加密哈希函数。它输出 160 位的结果。它现在被用于各种网络协议中。
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SHA-2 is another family of cryptographic hash functions designed by the NIST.
    Different variants of SHA-2 can produce has values of 224, 256, 384 or 512 bits.
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA-2 是由 NIST 设计的另一系列加密哈希函数。SHA-2 的不同变体可以生成 224 位、256 位、384 位或 512 位的哈希值。
- en: Another important point about cryptographic algorithms is that often these algorithms
    require random numbers to operate correctly (e.g. to generate keys). Generating
    good random numbers is difficult and any implementation of cryptographic algorithms
    should also include a secure random number generator. [**RFC 4086**](https://datatracker.ietf.org/doc/html/rfc4086.html)
    provides useful recommendations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加密算法的另一个重要点是，这些算法通常需要随机数来正确运行（例如，生成密钥）。生成好的随机数是困难的，任何加密算法的实现都应该包括一个安全的随机数生成器。[**RFC
    4086**](https://datatracker.ietf.org/doc/html/rfc4086.html) 提供了有用的建议。
- en: Cryptographic protocols[#](#cryptographic-protocols "Link to this heading")
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密协议[#](#cryptographic-protocols "链接到这个标题")
- en: We can now combine the cryptographic operations described in the previous section
    to build some protocols to securely exchange information. Let us first go back
    to the problem of authenticating Alice on Bob’s computer. We have shown earlier
    that using a simple password for this purpose is insecure in the presence of attackers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将上一节中描述的加密操作组合起来，构建一些用于安全交换信息的协议。让我们首先回到在Bob的计算机上验证爱丽丝身份的问题。我们之前已经表明，在存在攻击者的情况下，使用简单的密码来达到这个目的是不安全的。
- en: A naive approach would be to rely on hash functions. Since hash functions are
    non-invertible, Alice and Bob could decide to use them to exchange Alice’s password
    in a secure manner. Then, Alice could be authenticated by using the following
    exchange.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是依赖于哈希函数。由于哈希函数是不可逆的，爱丽丝和鲍勃可以决定使用它们以安全的方式交换爱丽丝的密码。然后，可以使用以下交换来验证爱丽丝。
- en: '![msc {'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="爱丽丝", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="鲍勃", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "我是爱丽丝\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Prove it\n\n", arcskip="1"];
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "证明\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "Hash(passwd)\n\n", arcskip="1"];
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Hash(密码)\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Access granted\n\n", arcskip="1"];
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "访问允许\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/8ce774d886954a61fe3332c085b81a4f.png)<map id="e9d4cd4a36e66a6415dde6e83ecc95535122af78"
    name="e9d4cd4a36e66a6415dde6e83ecc95535122af78"></map>'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/8ce774d886954a61fe3332c085b81a4f.png)<map id="e9d4cd4a36e66a6415dde6e83ecc95535122af78"
    name="e9d4cd4a36e66a6415dde6e83ecc95535122af78"></map>'
- en: Since the hash function cannot be inverted, an eavesdropper cannot extract Alice’s
    password by simply observing the data exchanged. However, Alice’s real password
    is not the objective of an attacker. The main objective for Mallory is to be authenticated
    as Alice. If Mallory can capture Hash(passwd), he can simply replay this data,
    without being able to invert the hash function. This is called a replay attack.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希函数不可逆，窃听者不能仅通过观察交换的数据来提取爱丽丝的密码。然而，攻击者的主要目标并不是爱丽丝的真实密码。Mallory的主要目标是验证自己为爱丽丝。如果Mallory能够捕获到Hash(密码)，他可以简单地重放这些数据，而无需能够逆转哈希函数。这被称为重放攻击。
- en: To counter this replay attack, we need to ensure that Alice never sends the
    same information twice to Bob. A possible mode of operation is shown below.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗这种重放攻击，我们需要确保爱丽丝永远不会向鲍勃发送相同的信息两次。下面是一种可能的操作模式。
- en: '![msc {'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="爱丽丝", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="鲍勃", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "我是爱丽丝\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:764192\n\n", arcskip="1"];
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "挑战：764192\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "Hash(764192||passwd)\n\n", arcskip="1"];
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Hash(764192||密码)\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Access\n\n", arcskip="1"];
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "访问\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/d68b2f1363c49e52d5bce558f315b1ad.png)<map id="20f577439fc03098f4163306e3e3d06fd0e01a3f"
    name="20f577439fc03098f4163306e3e3d06fd0e01a3f"></map>'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d68b2f1363c49e52d5bce558f315b1ad.png)<map id="20f577439fc03098f4163306e3e3d06fd0e01a3f"
    name="20f577439fc03098f4163306e3e3d06fd0e01a3f"></map>'
- en: To authenticate herself, Alice sends her user identifier to Bob. Bob replies
    with a random number as a challenge to verify that Alice knows the shared secret
    (i.e. her password). Alice replies with the result of the computation of a hash
    function (e.g. SHA-1) over a string that is the concatenation between the random
    number chosen by Bob and Alice’s password. The random number chosen by Bob is
    often called a nonce since this is a number that should only be used once. Bob
    performs the same computation locally and can check the message returned by Alice.
    This type of authentication scheme has been used in various protocols. It prevents
    replay attacks. If Eve captures the messages exchanged by Alice and Bob, she cannot
    recover Alice’s password from the messages exchanged since hash functions are
    non-invertible. Furthermore, she cannot replay the hashed value since Bob will
    always send a different nonce.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证自己的身份，爱丽丝向鲍勃发送她的用户标识符。鲍勃回复一个随机数作为挑战，以验证爱丽丝知道共享的秘密（即她的密码）。爱丽丝回复计算出的哈希函数（例如SHA-1）的结果，该函数作用在一个字符串上，该字符串是鲍勃选择的随机数和爱丽丝的密码的连接。鲍勃选择的随机数通常被称为nonce，因为这个数字只能使用一次。鲍勃在本地执行相同的计算，并可以检查爱丽丝返回的消息。这种认证方案已在各种协议中使用。它防止重放攻击。如果伊芙捕获了爱丽丝和鲍勃之间交换的消息，她无法从这些消息中恢复爱丽丝的密码，因为哈希函数是不可逆的。此外，她无法重放哈希值，因为鲍勃总是会发送一个不同的nonce。
- en: Unfortunately, this solution forces Bob to store Alice’s password in clear.
    Any breach in the security of Bob’s computer would reveal Alice’s password. Such
    breaches unfortunately occur and some of them have led to the dissemination of
    millions of passwords.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个解决方案迫使鲍勃在计算机上存储爱丽丝的明文密码。鲍勃计算机的安全漏洞会泄露爱丽丝的密码。不幸的是，这种漏洞确实发生了，其中一些导致了数百万个密码的泄露。
- en: 'A better approach would be to authenticate Alice without storing her password
    in clear on Bob’s computer. For this, Alice computes a hash chain as proposed
    by Lamport in [[Lamport1981]](../bibliography.html#lamport1981). A hash chain
    is a sequence of applications of a hash function (H) on an input string. If Alice’s
    password is P, then her 10 steps hash chain is : \(H(H(H(H(H(H(H(H(H(H(P))))))))))\).
    The result of this hash chain will be stored on Bob’s computer together with the
    value 10. This number is the maximum number of remaining authentications for Alice
    on Bob’s computer. To authenticate Alice, Bob sends the remaining number of authentications,
    i.e. 10 in this example. Since Alice knows her password, P, she can compute \(H^9(P)=H(H(H(H(H(H(H(H(H(P)))))))))\)
    and send this information to Bob. Bob computes the hash of the value received
    from Alice (\(H(H^9(P))\)) and verifies that this value is equal to the value
    stored in his database. It then decrements the number of authorized authentications
    and stores \(H^9(P)\) in his database. Bob is now ready for the next authentication
    of Alice. When the number of authorized authentications reaches zero, the hash
    chain needs to be reinitialized. If Eve captures \((H^n(P))\), she cannot use
    it to authenticate herself as Alice on Bob’s computer because Bob will have decremented
    its number of authorized authentications. Furthermore, given that hash functions
    are not invertible, Eve cannot compute \(H^{n-1}(P)\) from \(H^{n}(P)\).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是在鲍勃的计算机上不存储爱丽丝的明文密码来验证爱丽丝的身份。为此，爱丽丝计算一个哈希链，如Lamport在[[Lamport1981]](../bibliography.html#lamport1981)中提出的。哈希链是对输入字符串应用哈希函数（H）的序列。如果爱丽丝的密码是P，那么她的10步哈希链是：\(H(H(H(H(H(H(H(H(H(H(P))))))))))\)。这个哈希链的结果将存储在鲍勃的计算机上，同时存储值10。这个数字是爱丽丝在鲍勃的计算机上剩余的最大认证次数。为了验证爱丽丝，鲍勃发送剩余的认证次数，即本例中的10。由于爱丽丝知道她的密码P，她可以计算\(H^9(P)=H(H(H(H(H(H(H(H(H(P)))))))))\)并将此信息发送给鲍勃。鲍勃计算从爱丽丝那里收到的值的哈希（\(H(H^9(P))\)）并验证这个值是否等于他数据库中存储的值。然后，他减少授权认证的次数并将\(H^9(P)\)存储在他的数据库中。现在鲍勃已准备好进行爱丽丝的下一个认证。当授权认证次数达到零时，需要重新初始化哈希链。如果伊芙捕获了\((H^n(P))\)，她不能用它来在鲍勃的计算机上作为爱丽丝进行认证，因为鲍勃会减少其授权认证的次数。此外，鉴于哈希函数是不可逆的，伊芙不能从\(H^{n}(P)\)计算出\(H^{n-1}(P)\)。
- en: The two protocols above prevent eavesdropping attacks, but not man-in-the-middle
    attacks. If Mallory can intercept the messages sent by Alice, he could force her
    to reveal \(H^n(P)\) and then use this information to authenticate as Alice on
    Bob’s computer. In practice, hash chains should only be used when the communicating
    users know that there cannot be any man-in-the-middle on their communication.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两种协议可以防止窃听攻击，但不能防止中间人攻击。如果Mallory可以拦截Alice发送的消息，他可以迫使她透露\(H^n(P)\)，然后利用这些信息在Bob的计算机上冒充Alice。在实践中，只有在通信用户知道他们的通信中不可能有中间人时，才应使用哈希链。
- en: 'Public key cryptography provides another possibility to allow Alice to authenticate
    herself on Bob’s computer. Assume again that Alice and Bob know each other from
    previous encounters. Alice knows Bob’s public key (\(Bob_{pub}\)) and Bob also
    knows Alice’s key (\(Alice_{pub}\)). To authenticate herself, Alice could send
    her user identifier. Bob would reply with a random number encrypted with Alice’s
    public key : \(E_p(Alice_{pub},R)\). Alice can decrypt this message to recover
    R and sends \(E_p(Bob_{pub},R)\). Bob decrypts the nonce and confirms that Alice
    knows \(Alice_{priv}\). If an eavesdropper captures the messages exchanged, he
    cannot recover the value R which could be used as a key to encrypt the information
    with a secret key algorithm. This is illustrated in the time sequence diagram
    below.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学为Alice在Bob的计算机上验证自己的身份提供了另一种可能性。再次假设Alice和Bob从之前的接触中认识彼此。Alice知道Bob的公钥（\(Bob_{pub}\)），而Bob也知道Alice的密钥（\(Alice_{pub}\)）。为了验证自己的身份，Alice可以发送她的用户标识符。Bob会用Alice的公钥加密一个随机数作为回复：\(E_p(Alice_{pub},R)\)。Alice可以解密这条消息以恢复R，并发送\(E_p(Bob_{pub},R)\)。Bob解密这个随机数并确认Alice知道\(Alice_{priv}\)。如果窃听者捕获了交换的消息，他无法恢复R的值，这个值可以用作密钥，通过秘密密钥算法加密信息。这在下方的时序图中得到了说明。
- en: '![msc {'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "E_p(Alice_{pub},R)", arcskip="1"];
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "E_p(Alice_{pub},R)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Bob_{pub},R)", arcskip="1"];
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Bob_{pub},R)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/f7eeac697813279f3277f20eb023de49.png)<map id="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"
    name="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"></map>'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f7eeac697813279f3277f20eb023de49.png)<map id="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"
    name="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"></map>'
- en: 'A drawback of this approach is that Bob is forced to perform two public key
    computations : one encryption to send the random nonce to Alice and one decryption
    to recover the nonce encrypted by Alice. If these computations are costly from
    a CPU viewpoint, this creates a risk of Denial of Service Attacks were attackers
    could try to access Bob’s computer and force it to perform such costly computations.
    Bob is more at risk than Alice in this situation and he should not perform complex
    operations before being sure that he is talking with Alice. An alternative is
    shown in the time sequence diagram below.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是Bob被迫执行两次公钥计算：一次加密将随机数发送给Alice，一次解密恢复Alice加密的随机数。如果这些计算从CPU的角度来看成本高昂，这就会产生拒绝服务攻击的风险，攻击者可能会尝试访问Bob的计算机并迫使其执行这些昂贵的计算。在这种情况下，Bob比Alice风险更大，他应该在确定自己正在与Alice交谈之前不执行复杂操作。下方的时序图中展示了另一种方法。
- en: '![msc {'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "R\n\n", arcskip="1"];
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "R\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Alice_{priv},R)\n\n", arcskip="1"];
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R)\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/5d0252030a1e74f0aa10edc4572b381d.png)<map id="26127d2d1ccdbf50c7d1c6d967ea621292da9631"
    name="26127d2d1ccdbf50c7d1c6d967ea621292da9631"></map>'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/5d0252030a1e74f0aa10edc4572b381d.png)<map id="26127d2d1ccdbf50c7d1c6d967ea621292da9631"
    name="26127d2d1ccdbf50c7d1c6d967ea621292da9631"></map>'
- en: Here, Bob simply sends a random nonce to Alice and verifies her signature. Since
    the random nonce and the signature could be captured by an eavesdropper, they
    cannot be used as a secret key to encrypt further data. However Bob could propose
    a secret key and send it encrypted with Alice’s public key in response to the
    signed nonce that he received.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，鲍勃简单地给爱丽丝发送一个随机数，并验证她的签名。由于随机数和签名可能被窃听者捕获，因此它们不能用作加密更多数据的密钥。然而，鲍勃可以提出一个密钥，并将其与爱丽丝的公钥一起加密，作为对收到的签名随机数的回应。
- en: The solution described above works provided that Bob and Alice know their respective
    public keys before communicating. Otherwise, the protocol is not secure against
    man-in-the-middle attackers. Consider Mallory sitting in the middle between Alice
    and Bob and assume that neither Alice nor Bob knows the other’s public key.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述的解决方案在鲍勃和爱丽丝在通信前知道他们各自的公钥的情况下是有效的。否则，该协议不能抵御中间人攻击者。考虑玛洛里坐在爱丽丝和鲍勃之间的中间，并假设爱丽丝和鲍勃都不知道对方的公钥。
- en: '![msc {'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: x [label="", linecolour=white],
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x [label="", linecolour=white],
- en: y [label="Mallory", textcolour="red", linecolour=red],
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y [label="Mallory", textcolour="red", linecolour=red],
- en: z [label="", linecolour=white],
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = " " ] ,
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = " " ] ,
- en: b>>y [ label = "I'm Alice key=Alice_{pub}", arcskip="1" ];
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>y [ label = "I'm Alice key=Alice_{pub}", arcskip="1" ];
- en: y>>c [ label = "I'm Alice key=Mallory_{pub}", textcolour="red", arcskip="1"
    ];
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y>>c [ label = "I'm Alice key=Mallory_{pub}", textcolour="red", arcskip="1"
    ];
- en: c=>d [ label = "" ];
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "R", arcskip="1"];
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "R", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>y [ label = "E_p(Alice_{priv},R)", arcskip="1"];
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>y [ label = "E_p(Alice_{priv},R)", arcskip="1"];
- en: y>>c [ label = "E_p(Mallory_{priv},R)", textcolour="red",  arcskip="1"];
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y>>c [ label = "E_p(Mallory_{priv},R)", textcolour="red",  arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Access", arcskip="1"];
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Access", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/0638f4c9db9fea46091250d1fe48d4c9.png)<map id="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"
    name="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"></map>'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/0638f4c9db9fea46091250d1fe48d4c9.png)<map id="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"
    name="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"></map>'
- en: In the above example, Alice sends her public key, (\(Alice_{pub}\)), in her
    first message together with her identity. Mallory intercepts the message and replaces
    Alice’s key with his own key, (\(Mallory_{pub}\)). Bob replies with a nonce, R.
    Alice then signs the random nonce to prove that she knows \(Alice_{priv}\). Mallory
    discards the information and instead computes \(E_p(Mallory_{priv},R)\). Bob now
    thinks that he is discussing with Alice while Mallory sits in the middle.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，爱丽丝在她的第一条消息中发送了她的公钥（\(Alice_{pub}\)），以及她的身份。玛洛里拦截了消息，并用他自己的密钥（\(Mallory_{pub}\)）替换了爱丽丝的密钥。鲍勃回复了一个随机数，R。然后爱丽丝对随机数进行签名以证明她知道
    \(Alice_{priv}\)。玛洛里丢弃了信息，并计算 \(E_p(Mallory_{priv},R)\)。现在鲍勃认为他正在与爱丽丝交谈，而玛洛里坐在中间。
- en: There are situations where symmetric authentication is required. In this case,
    each user must perform some computation with his/her private key. A possible exchange
    is the following. Alice sends her certificate to Bob. Bob replies with a nonce,
    \(R1\), and provides his certificate. Alice encrypts \(R1\) with her private key
    and generates a nonce, \(R2\). Bob verifies Alice’s computation and encrypts \(R2\)
    with his private key. Alice verifies the computation and both have been authenticated.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要对称认证。在这种情况下，每个用户必须使用他的/她的私钥进行一些计算。一个可能的交换如下。爱丽丝将她的证书发送给鲍勃。鲍勃回复一个随机数，\(R1\)，并提供他的证书。爱丽丝使用她的私钥加密
    \(R1\) 并生成一个随机数，\(R2\)。鲍勃验证爱丽丝的计算，并使用他的私钥加密 \(R2\)。爱丽丝验证计算，双方都完成了认证。
- en: '![msc {'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice", arcskip="1"];
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:R1", arcskip="1"];
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:R1", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Alice_{priv},R1),R2", arcskip="1"];
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R1),R2", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "E_p(Bob_{priv},R2)", arcskip="1"];
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "E_p(Bob_{priv},R2)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/682391126620ce67dffa1f33ee972f1b.png)<map id="dc928c892b0c31362bbfde7cc4e2025e18374729"
    name="dc928c892b0c31362bbfde7cc4e2025e18374729"></map>'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/682391126620ce67dffa1f33ee972f1b.png)<map id="dc928c892b0c31362bbfde7cc4e2025e18374729"
    name="dc928c892b0c31362bbfde7cc4e2025e18374729"></map>'
- en: The protocol described above works, but it takes a long time for Bob to authenticate
    Alice and for Alice to authenticate Bob. A faster authentication could be the
    following.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上文描述的协议是可行的，但鲍勃验证爱丽丝和爱丽丝验证鲍勃都需要很长时间。更快的验证方式可以是以下这样。
- en: '![msc {'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice, R2", arcskip="1"];
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice, R2", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:R1,E_p(Bob_{priv},R2)", arcskip="1"];
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:R1,E_p(Bob_{priv},R2)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ，
- en: b>>c [ label = "E_p(Alice_{priv},R1)", arcskip="1"];
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R1)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/d9c1e952550357ddf872d47493c46bd4.png)<map id="b006024cf4bbd5812ac6af177e9c613098b52e42"
    name="b006024cf4bbd5812ac6af177e9c613098b52e42"></map>'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d9c1e952550357ddf872d47493c46bd4.png)<map id="b006024cf4bbd5812ac6af177e9c613098b52e42"
    name="b006024cf4bbd5812ac6af177e9c613098b52e42"></map>'
- en: 'Alice sends her random nonce, \(R2\). Bob signs \(R2\) and sends his nonce
    : \(R1\). Alice signs \(R1\) and both are authenticated.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝发送她的随机数，\(R2\)。鲍勃签署 \(R2\) 并发送他的随机数：\(R1\)。爱丽丝签署 \(R1\)，双方都完成了验证。
- en: Now consider that Mallory wants to be authenticated as Alice. The above protocol
    has a subtle flaw that could be exploited by Mallory. This flaw can be exploited
    if Alice and Bob can act as both client and server. Knowing this, Mallory could
    operate as follows. Mallory starts an authentication with Bob faking himself as
    Alice. He sends a first message to Bob including Alice’s identity.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑玛洛丽想要作为爱丽丝进行验证的情况。上述协议存在一个细微的缺陷，可能会被玛洛丽利用。如果爱丽丝和鲍勃可以同时作为客户端和服务器，这个缺陷就可以被利用。了解这一点后，玛洛丽可以如下操作。玛洛丽开始与鲍勃进行验证，假装自己是爱丽丝。他向鲍勃发送第一条消息，包括爱丽丝的身份。
- en: '![msc {'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Mallory", textcolour="red", linecolour=black],
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Mallory", textcolour="red", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice,RA", arcskip="1"];
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice,RA", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:RB,E_p(Bob_{priv},RA)", arcskip="1"];
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:RB,E_p(Bob_{priv},RA)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/0129748f31a23c4c1ec10d426878fd81.png)<map id="b30892ea80e85d5226bffe1067bd495dabafda9e"
    name="b30892ea80e85d5226bffe1067bd495dabafda9e"></map>'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/0129748f31a23c4c1ec10d426878fd81.png)<map id="b30892ea80e85d5226bffe1067bd495dabafda9e"
    name="b30892ea80e85d5226bffe1067bd495dabafda9e"></map>'
- en: In this exchange, Bob authenticates himself by signing the \(RA\) nonce that
    was sent by Mallory. Now, to authenticate as Alice, Mallory needs to compute the
    signature of nonce \(RB\) with Alice’s private key. Mallory does not know Alice’s
    key, but he could exploit the protocol to force Alice to perform the required
    computation. For this, Mallory can start an authentication to Alice as shown below.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次交换中，鲍勃通过签署由玛洛丽发送的 \(RA\) 随机数来验证自己。现在，为了作为爱丽丝进行验证，玛洛丽需要使用爱丽丝的私钥计算随机数 \(RB\)
    的签名。玛洛丽不知道爱丽丝的密钥，但他可以利用该协议强制爱丽丝执行所需的计算。为此，玛洛丽可以像下面这样开始对爱丽丝的验证。
- en: '![msc {'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Mallory", textcolour="red",linecolour=black],
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Mallory", textcolour="red",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Alice", linecolour=black],
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Alice", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Mallory,RB", arcskip="1"];
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Mallory,RB", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:RX,E_p(Alice_{priv},RB)", arcskip="1"];
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:RX,E_p(Alice_{priv},RB)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/cd66745b390b62a38dfe355eb3a5cc12.png)<map id="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"
    name="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"></map>'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/cd66745b390b62a38dfe355eb3a5cc12.png)<map id="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"
    name="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"></map>'
- en: In this example, Mallory has forced Alice to compute \(E_p(Alice_{priv},RB)\)
    which is the information required to finalize the first exchange and be authenticated
    as Alice. This illustrates a common problem with authentication schemes when the
    same information can be used for different purposes. The problem comes from the
    fact that Alice agrees to compute her signature on a nonce chosen by Bob (and
    relayed by Mallory). This problem occurs if the nonce is a simple integer without
    any structure. If the nonce includes some structure such as some information about
    Alice and Bob’s identities or even a single bit indicating whether the nonce was
    chosen by a user acting as a client (i.e. starting the authentication) or as a
    server, then the protocol is not vulnerable anymore.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Mallory迫使Alice计算\(E_p(Alice_{priv},RB)\)，这是完成第一次交换并验证为Alice所需的信息。这说明了当相同信息可用于不同目的时，认证方案中存在的一个常见问题。这个问题源于Alice同意在Bob选择的随机数（由Mallory中继）上计算她的签名。如果随机数是一个没有结构的简单整数，则会出现这个问题。如果随机数包含一些结构，例如关于Alice和Bob身份的信息，甚至是一个表示随机数是否由作为客户端的用户（即启动认证）或作为服务器选择的一个比特位，那么该协议就不再容易受到攻击。
- en: 'To cope with some of the above mentioned problems, public-key cryptography
    is usually combined with certificates. A certificate is a data structure that
    includes a signature from a trusted third party. A simple explanation of the utilization
    of certificates is to consider that Alice and Bob both know Ted. Ted is trusted
    by these two users and both have stored Ted’s public key : \(Ted_{pub}\). Since
    they both know Ted’s key, he can issue certificates. A certificate is mainly a
    cryptographic link between the identity of a user and his/her public key. Such
    a certificate can be computed in different ways. A simple solution is for Ted
    to generate a file that contains the following information for each certified
    user :'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决上述提到的一些问题，通常将公钥密码学与证书结合使用。证书是一个包含来自可信第三方签名的数据结构。关于证书利用的简单解释是，Alice和Bob都知道Ted。这两个用户都信任Ted，并且都存储了Ted的公钥：\(Ted_{pub}\)。由于他们都知道Ted的密钥，他可以颁发证书。证书主要是用户身份与其公钥之间的加密链接。此类证书可以以不同的方式计算。一个简单的解决方案是Ted生成一个包含以下信息的文件，为每个认证用户：
- en: his/her identity
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他的/她的身份
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: his/her public key
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他的/她的公钥
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a hash of the entire file signed with Ted’s private key
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ted的私钥签名的整个文件的散列
- en: Then, knowing Ted’s public key, anyone can verify the validity of a certificate.
    When a user sends his/her public key, he/she must also attach the certificate
    to prove the link between his/her identity and the public key. In practice, certificates
    are more complex than this. Certificates will often be used to authenticate the
    server and sometimes to authenticate the client.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，知道Ted的公钥，任何人都可以验证证书的有效性。当用户发送他的/她的公钥时，他/她必须也附加证书以证明其身份与公钥之间的联系。在实践中，证书比这更复杂。证书通常用于验证服务器，有时也用于验证客户端。
- en: A possible protocol could then be the following. Alice sends \(Cert(Alice_{pub},Ted)\).
    Bob replies with a random nonce.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的协议可以是以下这样。Alice发送\(Cert(Alice_{pub},Ted)\)。Bob回复一个随机随机数。
- en: '![msc {'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "Cert(Alice_{pub},Ted)", arcskip="1"];
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Cert(Alice_{pub},Ted)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "R", arcskip="1"];
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "R", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = ""] ,
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = ""] ,
- en: b>>c [ label = "E_p(Alice_{priv},R)", arcskip="1"];
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/64eccedf6350698b6491b83ea9b24e73.png)<map id="3b6facf99117568ccbf6aa8408c70dddc156d855"
    name="3b6facf99117568ccbf6aa8408c70dddc156d855"></map>'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/64eccedf6350698b6491b83ea9b24e73.png)<map id="3b6facf99117568ccbf6aa8408c70dddc156d855"
    name="3b6facf99117568ccbf6aa8408c70dddc156d855"></map>'
- en: 'Until now, we have only discussed the authentication problem. This is an important
    but not sufficient step to have a secure communication between two users through
    an insecure network. To securely exchange information, Alice and Bob need to both
    :'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了认证问题。这是在不可靠的网络中两个用户之间进行安全通信的重要但不是充分的一步。为了安全地交换信息，爱丽丝和鲍勃都需要：
- en: mutually authenticate each other
  id: totrans-346
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互相验证对方的身份。
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-348
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: agree on a way to encrypt the messages that they will exchange
  id: totrans-349
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定一种加密他们将要交换的消息的方式。
- en: 'Let us first explore how this could be realized by using public-key cryptography.
    We assume that Alice and Bob have both a public-private key pair and the corresponding
    certificates signed by a trusted third party : Ted.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探讨如何通过使用公钥密码学来实现这一点。我们假设爱丽丝和鲍勃都有由可信第三方泰德签名的公私钥对和相应的证书。
- en: 'A possible protocol would be the following. Alice sends \(Cert(Alice_{pub},Ted)\).
    This certificate provides Alice’s identity and her public key. Bob replies with
    the certificate containing his own public key : \(Cert(Bob_{pub},Ted)\). At this
    point, they both know the other public key and could use it to send encrypted
    messages. Alice would send \(E_p(Bob_{pub},M1)\) and Bob would send \(E_p(Alice_{pub},M2)\).
    In practice, using public key encryption techniques to encrypt a large number
    of messages is inefficient because these cryptosystems require a large number
    of computations. It is more efficient to use secret key cryptosystems for most
    of the data and only use a public key cryptosystem to encrypt the random secret
    keys that will be used by the secret key encryption scheme.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的协议如下。爱丽丝发送 \(Cert(Alice_{pub},Ted)\)。这个证书提供了爱丽丝的身份和她的公钥。鲍勃回复包含他自己的公钥的证书：\(Cert(Bob_{pub},Ted)\)。在这个时候，他们都知道对方的公钥，可以使用它来发送加密消息。爱丽丝会发送
    \(E_p(Bob_{pub},M1)\)，鲍勃会发送 \(E_p(Alice_{pub},M2)\)。在实践中，使用公钥加密技术加密大量消息是不高效的，因为这些密码系统需要大量的计算。更有效的方法是使用对称密钥密码系统来加密大部分数据，仅使用公钥密码系统来加密将用于对称密钥加密方案的随机密钥。
- en: Key exchange[#](#key-exchange "Link to this heading")
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥交换[#](#key-exchange "链接到这个标题")
- en: 'When users want to communicate securely through a network, they need to exchange
    information such as the keys that will be used by an encryption algorithm even
    in the presence of an eavesdropper. The most widely used algorithm that allows
    two users to safely exchange an integer in the presence of an eavesdropper is
    the one proposed by Diffie and Hellman [[DH1976]](../bibliography.html#dh1976).
    It operates with (large) integers. Two of them are public, the modulus, p, which
    is prime and the base, g, which must be a primitive root of p. The communicating
    users select a random integer, \(a\) for Alice and \(b\) for Bob. The exchange
    starts as :'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要通过网络安全地通信时，即使在窃听者的存在下，他们也需要交换信息，例如将要使用的加密算法的密钥。最广泛使用的算法是迪菲和赫尔曼提出的算法 [[DH1976]](../bibliography.html#dh1976)，它使用（大）整数。其中两个是公开的，模数
    \(p\) 是一个质数，基数 \(g\) 必须是 \(p\) 的原根。通信用户选择一个随机整数 \(a\) 给爱丽丝和 \(b\) 给鲍勃。交换开始如下：
- en: Alice selects a random integer, \(a\) and sends \(A=g^{a} \mod p\) to Bob
  id: totrans-354
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爱丽丝选择一个随机整数 \(a\) 并将其发送给鲍勃。
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-356
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob selects a random integer, \(b\) and sends \(B=g^{b} \mod p\) to Alice
  id: totrans-357
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃选择一个随机整数 \(b\) 并将其发送给爱丽丝。
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: From her knowledge of \(a\) and \(B\), Alice can compute \(Secret=B^{a} \mod
    p= (g^{b} \mod p) ^{a} \mod p=g^{a \times b} \mod p\)
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 \(a\) 和 \(B\) 的知识中，爱丽丝可以计算出 \(Secret=B^{a} \mod p= (g^{b} \mod p) ^{a} \mod
    p=g^{a \times b} \mod p\)。
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: From is knowledge of \(b\) and \(A\), Bob can compute \(Secret=A^{b} \mod p=(g^{a}
    \mod p) ^{b} \mod p=g^{a \times b} \mod p\)
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 \(b\) 和 \(A\) 的知识中，鲍勃可以计算出 \(Secret=A^{b} \mod p=(g^{a} \mod p) ^{b} \mod
    p=g^{a \times b} \mod p\)。
- en: The security of this protocol relies on the difficulty of computing discrete
    logarithms, i.e. from the knowledge of \(A\) (resp. \(B\)), it is very difficult
    to extract \(\log(A)=\log(g^{a} \mod p)=a\) (resp. \(\log(B)=\log(g^{b} \mod p)=b\)).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议的安全性依赖于计算离散对数的难度，即已知 \(A\)（分别 \(B\)），很难提取 \(\log(A)=\log(g^{a} \mod p)=a\)（分别
    \(\log(B)=\log(g^{b} \mod p)=b\))。
- en: An example of the utilization of the Diffie-Hellman key exchange is shown below.
    Before starting the exchange, Alice and Bob agree on a modulus (\(p=23\)) and
    a base (\(g=5\)). These two numbers are public. They are typically part of the
    standard that defines the protocol that uses the key exchange.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了Diffie-Hellman密钥交换的利用示例。在开始交换之前，Alice和Bob同意一个模数（\(p=23\)）和一个基数（\(g=5\)）。这两个数字是公开的。它们通常是定义使用密钥交换的协议的标准的一部分。
- en: 'Alice chooses a secret integer : \(a=8\) and sends \(A= g^{a} \mod p= 5^{8}
    \mod 23=16\) to Bob'
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个秘密整数：\(a=8\)，并将\(A= g^{a} \mod p= 5^{8} \mod 23=16\)发送给Bob
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob chooses a secret integer : \(b=13\) and sends \(B= g^{b} \mod p=5^{13}
    \mod 23=21\) to Alice'
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob选择一个秘密整数：\(b=13\)，并将\(B= g^{b} \mod p=5^{13} \mod 23=21\)发送给Alice
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Alice computes \(S_{A}=B^{a} \mod p= 21^{8} \mod 23=3\)
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice计算\(S_{A}=B^{a} \mod p= 21^{8} \mod 23=3\)
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob computes \(S_{B}=A^{b} \mod p= 16^{13} \mod 23=3\)
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob计算\(S_{B}=A^{b} \mod p= 16^{13} \mod 23=3\)
- en: Alice and Bob have agreed on the secret information \(3\) without having sent
    it explicitly through the network. If the integers used are large enough and have
    good properties, then even Eve who can capture all the messages sent by Alice
    and Bob cannot recover the secret key that they have exchanged. There is no formal
    proof of the security of the algorithm, but mathematicians have tried to solve
    similar problems with integers during centuries without finding an efficient algorithm.
    As long as the integers that are used are random and large enough, the only possible
    attack for Eve is to test all possible integers that could have been chosen by
    Alice and Bob. This is computationally very expensive. This algorithm is widely
    used in security protocols to agree on a secret key.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob已经同意了秘密信息\(3\)，而没有通过网络明确发送。如果使用的整数足够大并且具有良好的属性，那么即使Eve能够捕获Alice和Bob发送的所有消息，也无法恢复他们交换的秘密密钥。没有关于算法安全性的正式证明，但数学家们已经尝试了几个世纪，用整数解决类似的问题，但没有找到有效的算法。只要使用的整数是随机的并且足够大，Eve唯一可能的攻击就是测试Alice和Bob可能选择的所有可能的整数。这是计算上非常昂贵的。这个算法在安全协议中被广泛使用，以达成一个秘密密钥。
- en: 'Unfortunately, the Diffie-Hellman key exchange alone cannot cope with man-in-the
    middle attacks. Consider Mallory who sits in the middle between Alice and Bob
    and can easily capture and modify their messages. The modulus and the base are
    public. They are thus known by Mallory as well. He could then operate as follows
    :'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Diffie-Hellman密钥交换本身无法应对中间人攻击。考虑Mallory，他坐在Alice和Bob之间，可以轻易地捕获和修改他们的消息。模数和基数是公开的。因此，Mallory也知道它们。他可以如下操作：
- en: Alice chooses a secret integer and sends \(A= g^{a} \mod p\) to Mallory
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个秘密整数，并将\(A= g^{a} \mod p\)发送给Mallory
- en: ''
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Mallory generates a secret integer, \(m\) and sends \(M=g^{m} \mod p\) to Bob
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mallory生成一个秘密整数，\(m\)，并将\(M=g^{m} \mod p\)发送给Bob
- en: ''
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob chooses a secret integer and sends \(B=g^{b} \mod p\) to Mallory
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob选择一个秘密整数，并将\(B=g^{b} \mod p\)发送给Mallory
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Mallory computes \(S_{A}=A^{m} \mod p\) and \(S_{B}=B^{m} \mod p\)
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mallory计算\(S_{A}=A^{m} \mod p\)和\(S_{B}=B^{m} \mod p\)
- en: ''
  id: totrans-388
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Alice computes \(S_{A}=M^{a} \mod p\) and uses this key to communicate with
    Mallory (acting as Bob)
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice计算\(S_{A}=M^{a} \mod p\)并使用这个密钥与Mallory（充当Bob）通信
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob computes \(S_{B}=M^{b} \mod p\) and uses this key to communicate with Mallory
    (acting as Alice)
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob计算\(S_{B}=M^{b} \mod p\)并使用这个密钥与Mallory（充当Alice）通信
- en: When Alice sends a message, she encrypts it with \(S_{A}\). Mallory decrypts
    it with \(S_{A}\) and encrypts the plaintext with \(S_{B}\). When Bob receives
    the message, he can decrypt it by using \(S_{B}\).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当Alice发送消息时，她使用\(S_{A}\)对其进行加密。Mallory使用\(S_{A}\)解密它，并用\(S_{B}\)加密明文。当Bob收到消息时，他可以使用\(S_{B}\)进行解密。
- en: To safely use the Diffie-Hellman key exchange, Alice and Bob must use an authenticated
    exchange. Some of the information sent by Alice or Bob must be signed with a public
    key known by the other user. In practice, it is often important for Alice to authenticate
    Bob. If Bob has a certificate signed by Ted, the authenticated key exchange could
    be organized as follows.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地使用Diffie-Hellman密钥交换，Alice和Bob必须使用一个经过身份验证的交换。Alice或Bob发送的一些信息必须使用另一个用户已知的公钥进行签名。在实践中，Alice验证Bob的身份通常很重要。如果Bob有一个由Ted签发的证书，经过身份验证的密钥交换可以组织如下。
- en: 'Alice chooses a secret integer : \(a\) and sends \(A= g^{a} \mod p\) to Bob'
  id: totrans-396
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个秘密整数：\(a\)，并将\(A= g^{a} \mod p\)发送给Bob
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-398
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob chooses a secret integer : \(b\), computes \(B= g^{b} \mod p\) and sends
    \(Cert(Bob,Bob_{pub},Ted), E_p(Bob_{priv},B)\) to Alice'
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob选择一个秘密整数：\(b\)，计算\(B= g^{b} \mod p\)并将\(Cert(Bob,Bob_{pub},Ted), E_p(Bob_{priv},B)\)发送给Alice
- en: ''
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Alice checks the signature (with \(Bob_{pub}\)) and the certificate and computes
    \(S_{A}=B^{a} \mod p\)
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice检查签名（使用\(Bob_{pub}\)）和证书，并计算\(S_{A}=B^{a} \mod p\)
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob computes \(S_{B}=A^{b} \mod p\)
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob计算\(S_{B}=A^{b} \mod p\)
- en: This prevents the attack mentioned above since Mallory cannot create a fake
    certificate and cannot sign a value by using Bob’s private key. Given the risk
    of man-in-the-middle attacks, the Diffie-Hellman key exchange mechanism should
    never be used without authentication.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了上述攻击，因为Mallory无法创建伪造的证书，也无法使用Bob的私钥签名一个值。鉴于中间人攻击的风险，Diffie-Hellman密钥交换机制在没有身份验证的情况下不应使用。
- en: '## The secure shell (ssh)[#](#the-secure-shell-ssh "Link to this heading")'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '## 安全壳（ssh）[#](#the-secure-shell-ssh "链接到本标题")'
- en: One of the initial motivations for building computer networks was to allow users
    to access remote computers over the networks. In the 1960s and 1970s, the mainframes
    and the emerging minicomputers were composed of a central unit and a set of terminals
    connected through serial lines or modems. The simplest protocol that was designed
    to access remote computers over a network is probably [telnet](../glossary.html#term-telnet)
    [**RFC 854**](https://datatracker.ietf.org/doc/html/rfc854.html). [telnet](../glossary.html#term-telnet)
    runs over TCP and a telnet server listens on port 23 by default. The TCP connection
    used by telnet is bidirectional, both the client and the server can send data
    over it. The data exchanged over such a connection is essentially the characters
    that are typed by the user on the client machine and the text output of the processes
    running on the server machine with a few exceptions (e.g. control characters,
    characters to control the terminal like VT-100, …) . The default character set
    for telnet is the ASCII character set, but the extensions specified in [**RFC
    5198**](https://datatracker.ietf.org/doc/html/rfc5198.html) support the utilization
    of Unicode characters.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 建立计算机网络最初的动机之一是允许用户通过网络访问远程计算机。在20世纪60年代和70年代，大型机和新兴的小型机由一个中央单元和通过串行线路或调制解调器连接的一组终端组成。设计用于通过网络访问远程计算机的最简单协议可能是[telnet](../glossary.html#term-telnet)
    [**RFC 854**](https://datatracker.ietf.org/doc/html/rfc854.html)。[telnet](../glossary.html#term-telnet)通过TCP运行，默认情况下，telnet服务器监听端口23。telnet使用的TCP连接是双向的，客户端和服务器都可以通过它发送数据。在这种连接上交换的数据基本上是用户在客户端机器上键入的字符以及服务器机器上运行的进程的文本输出，有一些例外（例如控制字符，用于控制终端的字符如VT-100等）……telnet的默认字符集是ASCII字符集，但[**RFC
    5198**](https://datatracker.ietf.org/doc/html/rfc5198.html)中指定的扩展支持Unicode字符的使用。
- en: From a security viewpoint, the main drawback of [telnet](../glossary.html#term-telnet)
    is that all the information, including the usernames, passwords and commands,
    is sent in cleartext over a TCP connection. This implies that an eavesdropper
    could easily capture the passwords used by anyone on an unprotected network. Various
    software tools exist to automate this collection of information. For this reason,
    [telnet](../glossary.html#term-telnet) is rarely used today to access remote computers.
    It is usually replaced by [ssh](../glossary.html#term-ssh) or similar protocols.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，[telnet](../glossary.html#term-telnet)的主要缺点是所有信息，包括用户名、密码和命令，都在TCP连接中以明文形式发送。这意味着窃听者可以轻易地捕获在未受保护的网络上的任何人使用的密码。存在各种软件工具来自动收集这些信息。因此，[telnet](../glossary.html#term-telnet)今天很少用于访问远程计算机。它通常被[ssh](../glossary.html#term-ssh)或类似协议所取代。
- en: The secure shell protocol was designed in the mid 1990s by T. Ylonen to counter
    the eavesdropping attacks against [telnet](../glossary.html#term-telnet) and similar
    protocols [[Ylonen1996]](../bibliography.html#ylonen1996). [ssh](../glossary.html#term-ssh)
    became quickly popular and system administrators encouraged its usage. The original
    version of [ssh](../glossary.html#term-ssh) was freely available. After a few
    years, his author created a company to distribute it commercially, but other programmers
    continued to develop an open-source version of [ssh](../glossary.html#term-ssh)
    called [OpenSSH](http://www.openssh.com). Over the years, [ssh](../glossary.html#term-ssh)
    evolved and became a flexible applicable whose usage extends beyond remote login
    to support features such as file transfers, protocol tunneling, … In this section,
    we only discuss the basic features of [ssh](../glossary.html#term-ssh) and explain
    how it differs from [telnet](../glossary.html#term-telnet). Entire books have
    been written to describe [ssh](../glossary.html#term-ssh) in details [[BS2005]](../bibliography.html#bs2005).
    An overview of the protocol appeared in [[Stallings2009]](../bibliography.html#stallings2009).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 安全壳协议是在 1990 年代中期由 T. Ylonen 设计的，旨在对抗针对 [telnet](../glossary.html#term-telnet)
    和类似协议的窃听攻击 [[Ylonen1996]](../bibliography.html#ylonen1996)。`[ssh](../glossary.html#term-ssh)`
    迅速变得流行，系统管理员鼓励使用它。`[ssh](../glossary.html#term-ssh)` 的原始版本是免费提供的。几年后，其作者创建了一家公司来商业分销它，但其他程序员继续开发了一个开源版本的
    `[ssh](../glossary.html#term-ssh)`，称为 `[OpenSSH](http://www.openssh.com)`。多年来，`[ssh](../glossary.html#term-ssh)`
    不断发展，并成为一个灵活适用的协议，其使用范围不仅限于远程登录，还支持文件传输、协议隧道等功能。在本节中，我们只讨论 `[ssh](../glossary.html#term-ssh)`
    的基本功能，并解释它与 `[telnet](../glossary.html#term-telnet)` 的区别。关于 `[ssh](../glossary.html#term-ssh)`
    的详细描述已有整本书籍出版 [[BS2005]](../bibliography.html#bs2005)。该协议的概述出现在 [[Stallings2009]](../bibliography.html#stallings2009)。
- en: The [ssh](../glossary.html#term-ssh) protocol runs directly above the TCP protocol.
    Once the TCP bytestream has been established, the client and the server exchange
    messages. The first message exchanged is an ASCII line that announces the version
    of the protocol and the version of the software implementation used by the client
    and the server. These two lines are useful when debugging interoperability problems
    and other issues.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ssh](../glossary.html#term-ssh)` 协议直接运行在 TCP 协议之上。一旦 TCP 字节流建立，客户端和服务器交换消息。交换的第一条消息是一个
    ASCII 行，宣布了协议版本和客户端及服务器使用的软件实现版本。这两行在调试互操作性问题和其它问题时非常有用。'
- en: The next message is the `SSH_MSG_KEX_INIT` message that is used to negotiate
    the cryptographic algorithms that will be used for the `ssh` session. It is very
    important for security protocols to include mechanisms that enable a negotiation
    of the cryptographic algorithms that are used. First, these algorithms provide
    different levels of security. Some algorithms might be considered totally secure
    and are recommended today while they could become deprecated a few years later
    after the publication of some attacks. Second, these algorithms provide different
    levels of performance and have different CPU and memory impacts.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条消息是用于协商 `ssh` 会话中将使用的加密算法的 `SSH_MSG_KEX_INIT` 消息。对于安全协议来说，包括允许协商所使用的加密算法的机制非常重要。首先，这些算法提供不同的安全级别。一些算法可能被认为是完全安全的，并且目前被推荐使用，但几年后，在发布了一些攻击之后可能会被弃用。其次，这些算法提供不同的性能级别，并且对
    CPU 和内存有不同的影响。
- en: 'In practice, an `ssh` implementation supports four types of cryptographic algorithms
    :'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，一个 `ssh` 实现支持四种类型的加密算法：
- en: key exchange
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥交换
- en: ''
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: encryption
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Message Authentication Code (MAC)
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息认证码 (MAC)
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: compression
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: The [IANA](https://www.iana.org) maintains a [list of the cryptographic algorithms](http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml#ssh-parameters-16)
    that can be used by `ssh` implementations. For each type of algorithm, the client
    provides an ordered list of the algorithms that it supports and agrees to use.
    The server compares the received list with its own list. The outcome of the negotiation
    is a set of four algorithms [[4]](#fnull) that will be combined for this session.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`[IANA](https://www.iana.org)` 维护一个 `[加密算法列表](http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml#ssh-parameters-16)`，该列表可以被
    `ssh` 实现使用。对于每种类型的算法，客户端提供一个按顺序排列的算法列表，并同意使用这些算法。服务器将收到的列表与其自己的列表进行比较。协商的结果是一组四个算法
    [[4]](#fnull)，这些算法将用于本次会话。'
- en: '![msc {'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Client",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "SSH-clientP-clientS comments", arcskip="1"];
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "SSH客户端P-clientS注释", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "SSH-serverP-serverS comments", arcskip="1"];
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "SSH服务器P-serverS注释", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/6c5012af9e2d96b7ddb2c31a55acbaec.png)<map id="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"
    name="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"></map>'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/6c5012af9e2d96b7ddb2c31a55acbaec.png)<map id="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"
    name="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"></map>'
- en: This negotiation of the cryptographic algorithms allows the implementations
    to evolve when new algorithms are proposed. If a client is upgraded, it can announce
    a new algorithm as its preferred one even if the server is not yet upgraded.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对加密算法的协商允许在提出新算法时实现进化。如果客户端进行了升级，即使服务器尚未升级，它也可以宣布一个新的算法作为其首选算法。
- en: Once the cryptographic algorithms have been negotiated, the key exchange algorithm
    is used to negotiate a secret key that will be shared by the client and the server.
    These key exchange algorithms include some variations over the basic algorithms.
    As an example, let us analyze how the Diffie-Hellman key exchange algorithm is
    used within the `ssh` protocol. In this case, each host has both a private and
    a public key. (Note that \(g\) is a generator for the subgroup of the Galois field
    of order \(p\), where \(p\) is a prime number, and || is the concatenation operator.
    For additional background information, see [[Schneier1996]](../bibliography.html#schneier1996).)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦协商了加密算法，就使用密钥交换算法协商一个将由客户端和服务器共享的秘密密钥。这些密钥交换算法在基本算法上有所变化。例如，让我们分析Diffie-Hellman密钥交换算法如何在`ssh`协议中使用。在这种情况下，每个主机都有一个私钥和一个公钥。（注意，\(g\)
    是阶为 \(p\) 的伽罗瓦域子群的生成元，其中 \(p\) 是一个素数，而 || 是连接运算符。有关更多信息，请参阅 [[Schneier1996]](../bibliography.html#schneier1996)。)
- en: the client generates the random number \(a\) and sends \(A=g^{a} \mod p\) to
    the server
  id: totrans-450
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端生成随机数 \(a\) 并将 \(A=g^{a} \mod p\) 发送给服务器
- en: ''
  id: totrans-451
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the server generates the random number \(b\). It then computes \(B=g^{b} \mod
    p\), \(K=B^{a} \mod p\) and signs with its private key \(hash(V_{Client} || V_{Server}
    || KEX\_INIT_{Client} || KEX\_INIT_{Server} || Server_{pub} || A || B || K )\)
    where \(V_{Server}\) (resp. \(V_{Client}\)) is the initial messages sent by the
    client (resp. server), \(KEX\_INIT_{Client}\) (resp. \(KEX\_INIT_{Server}\)) is
    the key exchange message sent by the client (resp. server) and \(A\), \(B\) and
    \(K\) are the messages of the Diffie-Hellman key exchange
  id: totrans-453
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器生成随机数 \(b\)。然后计算 \(B=g^{b} \mod p\)、\(K=B^{a} \mod p\) 并使用其私钥对 \(hash(V_{Client}
    || V_{Server} || KEX\_INIT_{Client} || KEX\_INIT_{Server} || Server_{pub} || A
    || B || K )\) 进行签名，其中 \(V_{Server}\)（分别）是客户端（分别）发送的初始消息，\(KEX\_INIT_{Client}\)（分别）是客户端（分别）发送的密钥交换消息，\(A\)、\(B\)
    和 \(K\) 是Diffie-Hellman密钥交换的消息
- en: ''
  id: totrans-454
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-455
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the client can recompute \(K=A^{b} \mod p\) and verify the signature provided
    by the server
  id: totrans-456
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以重新计算 \(K=A^{b} \mod p\) 并验证服务器提供的签名
- en: This is a slightly modified authenticated Diffie-Hellman key exchange with two
    interesting points. The first point is that when the server authenticates the
    key exchange it does not provide a certificate. This is because `ssh` assumes
    that the client will store inside its cache the public key of the servers that
    it uses on a regular basis. This assumption is valid for a protocol like `ssh`
    because users typically use it to interact with a small number of servers, typically
    a few or a few tens. Storing this information does not require a lot of storage.
    In practice, most `ssh` clients will accept to connect to remote servers without
    knowing their public key before the connection. In this case, the client issues
    a warning to the user who can decide to accept or reject the key. This warning
    can be associated with a fingerprint of the key, either as a sequence of letters
    or as an ASCII art which can be posted on the web or elsewhere [[5]](#fdnsssh)
    by the system administrator of the server. If a client connects to a server whose
    public key does not match the stored one, a stronger warning is issued because
    this could indicate a man-in-the-middle attack or that the remote server has been
    compromised. It can also indicate that the server has been upgraded and that a
    new key has been generated during this upgrade.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个略微修改过的认证Diffie-Hellman密钥交换，有两个有趣的观点。第一个观点是，当服务器验证密钥交换时，它不提供证书。这是因为`ssh`假设客户端会将其经常使用的服务器公钥存储在其缓存中。对于像`ssh`这样的协议，这个假设是有效的，因为用户通常用它与少量服务器交互，通常是几个或几十个。存储这些信息不需要太多的存储空间。在实践中，大多数`ssh`客户端都会接受在连接之前不知道远程服务器公钥的情况下连接到远程服务器。在这种情况下，客户端会向用户发出警告，用户可以决定接受或拒绝密钥。这个警告可以与密钥的指纹相关联，可以是字母序列或ASCII艺术，可以由服务器管理员在网络上或其他地方发布
    [[5]](#fdnsssh)。如果一个客户端连接到一个公钥与存储的不匹配的服务器，会发出更强的警告，因为这可能表明中间人攻击或远程服务器已被入侵。它也可能表明服务器已升级，并且在升级过程中生成了新的密钥。
- en: The second point is that the server authenticates not only the result of the
    Diffie-Hellman exchange but also a hash of all the information sent and received
    during the exchange. This is important to prevent downgrade attacks. A downgrade
    attack is an attack where an active attacker modifies the messages sent by the
    communicating hosts (typically the client) to request the utilization of weaker
    encryption algorithms. Consider a client that supports two encryption schemes.
    The preferred one uses 128 bits secret keys and the second one is an old encryption
    scheme that uses 48 bits keys. This second algorithm is kept for backward compatibility
    with older implementations. If an attacker can remove the preferred algorithm
    from the list of encryption algorithms supported by the client, he can force the
    server to use a weaker encryption scheme that will be easier to break. Thanks
    to the hash that covers all the messages exchanged by the server, the downgrade
    attack cannot occur against `ssh`. Algorithm agility is a key requirement for
    security protocols that need to evolve when encryption algorithms are broken by
    researchers. This agility cannot be used without care and signing a hash of all
    the messages exchanged is a technique that is frequently used to prevent downgrade
    attacks.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是服务器不仅验证Diffie-Hellman交换的结果，还验证交换过程中发送和接收的所有信息的哈希值。这很重要，可以防止降级攻击。降级攻击是一种主动攻击者修改通信主机（通常是客户端）发送的消息，以请求使用较弱加密算法的攻击。考虑一个支持两种加密方案的客户端。首选方案使用128位密钥，第二个方案是一个旧的加密方案，使用48位密钥。这个第二个算法保留以与旧实现保持向后兼容。如果攻击者可以从客户端支持的加密算法列表中删除首选算法，他可以迫使服务器使用一个较弱的加密方案，这将更容易被破解。多亏了覆盖服务器交换的所有消息的哈希值，降级攻击无法针对`ssh`发生。算法敏捷性是安全协议的关键要求，当加密算法被研究人员破解时，这些协议需要进化。这种敏捷性不能不加考虑地使用，签署所有交换消息的哈希值是一种常用于防止降级攻击的技术。
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Single use keys
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 单次使用密钥
- en: 'Thanks to the Diffie-Hellman key exchange, the client and the servers share
    key \(K\). A naive implementation would probably directly use this key for all
    the cryptographic algorithms that have been negotiated for this session. Like
    most security protocols, `ssh` does not directly use key \(K\). Instead, it uses
    the negotiated hash function with different parameters [[6]](#fsshkeys) to allow
    the client and the servers to compute six keys from \(K\) :'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了迪菲-赫尔曼密钥交换，客户端和服务器共享密钥 \(K\)。一个简单的实现可能会直接使用这个密钥来为这个会话中协商的所有加密算法。像大多数安全协议一样，`ssh`
    并不会直接使用密钥 \(K\)。相反，它使用协商的哈希函数和不同的参数 [[6]](#fsshkeys) 来允许客户端和服务器从 \(K\) 计算出六个密钥：
- en: a key used by the client (resp. server) to encrypt the data that it sends
  id: totrans-462
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（或服务器）用于加密发送数据的密钥
- en: ''
  id: totrans-463
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a key used by the client (resp. server) to authenticate the data that it sends
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（或服务器）用于认证发送数据的密钥
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-467
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a key used by the client (resp. server) to initialize the negotiated encryption
    scheme (if required by this scheme)
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（或服务器）用于初始化协商加密方案（如果该方案需要）的密钥
- en: It is common practice among designers of security protocols to never use the
    same key for different purposes. For example, allowing the client and the server
    to use the same key to encrypt data could enable an attacker to launch a replay
    attack by sending to the client data that it has itself encrypted.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全协议的设计者中，通常的做法是永远不要为不同的目的使用相同的密钥。例如，允许客户端和服务器使用相同的密钥来加密数据可能会使攻击者能够通过向客户端发送它自己加密的数据来发起重放攻击。
- en: 'At this point, all the messages sent over the TCP connection will be encrypted
    with the negotiated keys. The `ssh` protocol uses messages that are encoded according
    to the Binary Packet Protocol defined in [**RFC 4253**](https://datatracker.ietf.org/doc/html/rfc4253.html).
    Each of these messages contains the following information :'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，通过 TCP 连接发送的所有消息都将使用协商的密钥进行加密。`ssh` 协议使用根据 [**RFC 4253**](https://datatracker.ietf.org/doc/html/rfc4253.html)
    中定义的二进制数据包协议编码的消息。这些消息中的每一个都包含以下信息：
- en: '`length` : this is the length of the message in bytes, excluding the MAC and
    length fields'
  id: totrans-471
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这是消息的字节数，不包括 MAC 和长度字段'
- en: ''
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`padding length` : this is the number of random bytes that have been added
    at the end of the message.'
  id: totrans-474
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding length`：这是添加到消息末尾的随机字节数。'
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`payload` : the data (after optional compression) passed by the user'
  id: totrans-477
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payload`：用户传递的数据（在可选压缩之后）'
- en: ''
  id: totrans-478
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`padding` : random bytes added in each message (at least four) to ensure that
    the message length is a multiple of the block size used by the negotiated encryption
    algorithm'
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding`：在每条消息中添加的随机字节（至少四个），以确保消息长度是协商加密算法使用的块大小的倍数'
- en: ''
  id: totrans-481
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-482
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MAC` : this field is present if a Message Authentication Code has been negotiated
    for the session (in practice, using `ssh` without authentication is risky and
    this field should always be present). Note that to compute the MAC, an `ssh` implementation
    must maintain a message counter. This counter is incremented by one every time
    a message is sent and the MAC is computed with the negotiated authentication algorithm
    using the MAC key over the concatenation of the message counter and the cleartext
    message. The message counter is not transmitted, but the recipient can easily
    recover its value. The `MAC` is computed as \(mac = MAC(key, sequence\_number
    || unencrypted\_message)\) where the key is the negotiated authentication key.'
  id: totrans-483
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC`：如果会话中协商了消息认证码，则此字段存在（在实践中，使用未经身份验证的 `ssh` 风险很大，并且此字段应始终存在）。请注意，为了计算 MAC，`ssh`
    实现必须维护一个消息计数器。每次发送消息并计算 MAC 时，计数器都会增加一，并且使用协商的认证算法和 MAC 密钥通过消息计数器和明文消息的连接来计算 MAC。消息计数器不会传输，但接收方可以轻松恢复其值。`MAC`
    的计算方式为 \(mac = MAC(key, sequence\_number || unencrypted\_message)\)，其中密钥是协商的认证密钥。'
- en: Note
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Authenticating messages with HMAC
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HMAC 认证消息
- en: ssh is one example of a protocol that uses Message Authentication Codes (MAC)
    to authenticates the messages that are sent. A naive implementation of such a
    MAC would be to simply use a hash function like SHA-1\. However, such a construction
    would not be safe from a security viewpoint. Internet protocols usually rely on
    the HMAC construction defined in [**RFC 2104**](https://datatracker.ietf.org/doc/html/rfc2104.html).
    It works with any hash function (H) and a key (K). As an example, let us consider
    HMAC with the SHA-1 hash function. SHA-1 uses 20 bytes blocks and the block size
    will play an important role in the operation of HMAC. We first require the key
    to be as long as the block size. Since this key is the output of the key generation
    algorithm, this is one parameter of this algorithm.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh`是使用消息认证码（MAC）来认证发送消息的协议的一个例子。这样一个MAC的简单实现可能是简单地使用一个像SHA-1这样的散列函数。然而，从安全角度来看，这种结构并不安全。互联网协议通常依赖于在[**RFC
    2104**](https://datatracker.ietf.org/doc/html/rfc2104.html)中定义的HMAC构造。它适用于任何散列函数（H）和密钥（K）。作为一个例子，让我们考虑使用SHA-1散列函数的HMAC。SHA-1使用20字节块，块大小将在HMAC的操作中扮演重要角色。我们首先需要密钥的长度与块大小相同。由于这个密钥是密钥生成算法的输出，这是该算法的一个参数。'
- en: 'HMAC uses two padding strings : ipad (resp. opad) which is a string containing
    20 times byte `0x36` (resp. byte `0x5C`). The HMAC is then computed as \(H[K \oplus
    opad, H(K \oplus ipad, data) ]\) where \(\oplus\) denotes the bitwise XOR operation.
    This computation has been shown to be stronger than the naive \(H(K,data)\) against
    some types of cryptographic attacks.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC使用两个填充字符串：ipad（resp. opad），它是一个包含20次字节`0x36`（resp. 字节`0x5C`）的字符串。然后计算HMAC为
    \(H[K \oplus opad, H(K \oplus ipad, data) ]\) 其中 \(\oplus\) 表示位运算的异或操作。这种计算已被证明比简单的
    \(H(K,data)\) 对抗某些类型的密码学攻击更强大。
- en: Among the various features of the `ssh` protocol, it is interesting to mention
    how users are authenticated by the server. The `ssh` protocol supports the classical
    username/password authentication (but both the username and the password are transmitted
    over the secure encrypted channel). In addition, `ssh` supports two authentication
    mechanisms that rely on public keys. To use the first one, each user needs to
    generate his/her own public/private key pair and store the public key on the server.
    To be authenticated, the user needs to sign a message containing his/her public
    key by using his/her private key. The server can easily verify the validity of
    the signature since it already knows the user’s public key. The second authentication
    scheme is designed for hosts that trust each other. Each host has a public/private
    key pair and stores the public keys of the other hosts that it trusts. This is
    typically used in environments such as university labs where each user could access
    any of the available computers. If Alice has logged on `computer1` and wants to
    execute a command on `computer2`, she can create an `ssh` session on this computer
    and type (again) her password. With the host-based authentication scheme, `computer1`
    signs a message with its private key to confirm that it has already authenticated
    Alice. `computer2` would then accept Alice’s session without asking for her credentials.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ssh`协议的众多特性中，提及服务器如何对用户进行认证是非常有趣的。`ssh`协议支持经典的用户名/密码认证（但用户名和密码都是通过安全的加密通道传输的）。此外，`ssh`还支持两种基于公钥的认证机制。要使用第一种机制，每个用户都需要生成自己的公钥/私钥对，并将公钥存储在服务器上。为了进行认证，用户需要使用自己的私钥对包含其公钥的消息进行签名。由于服务器已经知道用户的公钥，它可以轻松地验证签名的有效性。第二种认证方案是为相互信任的主机设计的。每个主机都有一个公钥/私钥对，并存储它所信任的其他主机的公钥。这通常用于像大学实验室这样的环境，在那里每个用户都可以访问任何可用的计算机。如果Alice已经登录到`computer1`并想在`computer2`上执行命令，她可以在这个计算机上创建一个`ssh`会话，并再次输入她的密码。基于主机的认证方案中，`computer1`使用其私钥对消息进行签名，以确认它已经认证了Alice。然后`computer2`将接受Alice的会话，而无需要求她的凭据。
- en: 'The `ssh` protocol includes other features that are beyond the scope of this
    book. Additional details may be found in [[BS2005]](../bibliography.html#bs2005).  ##
    Transport Layer Security[#](#transport-layer-security "Link to this heading")'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh`协议包括本书范围之外的其他特性。更多详细信息可以在[[BS2005]](../bibliography.html#bs2005)中找到。  ##
    传输层安全性[#](#transport-layer-security "链接到这个标题")'
- en: 'The Transport Layer Security family of protocols were initially proposed under
    the name Secure Socket Layer (SSL). The first deployments used this name and many
    researchers still refer to this security protocol as SSL [[FKC1996]](../bibliography.html#fkc1996).
    In this chapter, we use the official name that was standardized by the IETF: TLS
    for Transport Layer Security.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层安全（TLS）协议族最初以安全套接字层（SSL）的名义提出。最初的部署使用了这个名称，许多研究人员仍然将这个安全协议称为SSL [[FKC1996]](../bibliography.html#fkc1996)。在本章中，我们使用由IETF标准化的官方名称：传输层安全（TLS）。
- en: The TLS protocol was designed to be usable by a wide range of applications that
    use the transport layer to reliably exchange information. TLS is mainly used over
    the TCP protocol. There are variants of TLS that operate over SCTP [**RFC 3436**](https://datatracker.ietf.org/doc/html/rfc3436.html)
    or UDP [**RFC 6347**](https://datatracker.ietf.org/doc/html/rfc6347.html), but
    these are outside the scope of this chapter.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: TLS协议被设计成可以被广泛的应用程序使用，这些应用程序使用传输层来可靠地交换信息。TLS主要在TCP协议上使用。TLS有在SCTP [**RFC 3436**](https://datatracker.ietf.org/doc/html/rfc3436.html)
    或UDP [**RFC 6347**](https://datatracker.ietf.org/doc/html/rfc6347.html) 上运行的变体，但这些超出了本章的范围。
- en: A TLS session operates over a TCP connection. TLS is responsible for the encryption
    and the authentication of the SDUs exchanged by the application layer protocol
    while TCP provides the reliable delivery of this encrypted and authenticated bytestream.
    TLS is used by many different application layer protocols. The most frequent ones
    are HTTP (HTTP over TLS is called HTTPS), SMTP [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)
    or POP and IMAP [**RFC 2595**](https://datatracker.ietf.org/doc/html/rfc2595.html),
    but proprietary application-layer protocols also use TLS [[AM2019]](../bibliography.html#am2019).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: TLS会话在TCP连接上运行。TLS负责对应用层协议交换的SDUs进行加密和认证，而TCP则提供加密和认证的字节流的可靠传输。TLS被许多不同的应用层协议使用。最常见的是HTTP（HTTP
    over TLS称为HTTPS），SMTP [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)
    或 POP和IMAP [**RFC 2595**](https://datatracker.ietf.org/doc/html/rfc2595.html)，但专有应用层协议也使用TLS
    [[AM2019]](../bibliography.html#am2019)。
- en: 'A TLS session can be initiated in two different ways. First, the application
    can use a dedicated TCP port number for application layer protocol x-over-TLS.
    This is the solution used by many HTTP servers that reserve port \(443\) for HTTP
    over TLS. This solution works, but it requires to reserve two ports for each application
    : one where the application-layer protocol is used directly over TCP and another
    one where the application-layer protocol is used over TLS. Given the limited number
    of TCP ports that are available, this is not a scalable solution. The table below
    provides some of the reserved port numbers for application layer protocols on
    top of TLS.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: TLS会话可以通过两种不同的方式启动。首先，应用程序可以使用为应用层协议x-over-TLS保留的专用TCP端口号。这是许多HTTP服务器使用的解决方案，它们为HTTP
    over TLS保留了端口\(443\)。这个解决方案是可行的，但它要求为每个应用程序保留两个端口：一个用于直接在TCP上使用应用层协议，另一个用于在TLS上使用应用层协议。鉴于可用的TCP端口数量有限，这不是一个可扩展的解决方案。下表提供了在TLS之上应用层协议的一些保留端口号。
- en: '| Application | TCP port | TLS port |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | TCP端口 | TLS端口 |'
- en: '| --- | --- | --- |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| POP3 | 110 | 995 |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| POP3 | 110 | 995 |'
- en: '| IMAP | 143 | 993 |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| IMAP | 143 | 993 |'
- en: '| NNTP | 119 | 563 |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| NNTP | 119 | 563 |'
- en: '| HTTP | 80 | 443 |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | 80 | 443 |'
- en: '| FTP | 21 | 990 |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| FTP | 21 | 990 |'
- en: A second approach to initiate a TLS session is to use the standard TCP port
    number for the application layer protocol and define a special message in this
    protocol to trigger the start of the TLS session. This is the solution used for
    SMTP with the `STARTTLS` message. This extension to SMTP [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)
    defines the new STARTTLS command. The client can issue this command to indicate
    to the server that it wants to start a TLS session as shown in the example below
    captured during a session on port 25.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 启动TLS会话的第二种方法是使用应用层协议的标准TCP端口号，并在该协议中定义一个特殊消息来触发TLS会话的开始。这是用于SMTP的`STARTTLS`消息的解决方案。这个对SMTP的扩展
    [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html) 定义了新的STARTTLS命令。客户端可以发出此命令，向服务器指示它想要启动一个TLS会话，如下面在端口25上的会话中捕获的示例所示。
- en: '[PRE0]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the remaining parts of this chapter, we assume that the TLS session starts
    immediately after the establishment of the TCP connection. This corresponds to
    the deployments on web servers. We focus our presentation of TLS on this very
    popular use case. TLS is a complex protocol that supports other features than
    the one used by web servers. A more detailed presentation of TLS may be found
    in [[KPS2002]](../bibliography.html#kps2002) and [[Ristic2015]](../bibliography.html#ristic2015).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们假设TLS会话在TCP连接建立后立即开始。这对应于Web服务器的部署。我们专注于TLS的这种非常流行的用例。TLS是一个复杂的协议，支持Web服务器使用的其他功能。更详细的TLS介绍可以在[[KPS2002]](../bibliography.html#kps2002)和[[Ristic2015]](../bibliography.html#ristic2015)中找到。
- en: 'A TLS session is divided in two phases: the handshake and the data transfer.
    During the handshake, the client and the server negotiate the security parameters
    and the keys that will be used to secure the data transfer. During the second
    phase, all the messages exchanged are encrypted and authenticated with the negotiated
    algorithms and keys.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: TLS会话分为两个阶段：握手和数据传输。在握手阶段，客户端和服务器协商用于保护数据传输的安全参数和密钥。在第二阶段，所有交换的消息都使用协商的算法和密钥进行加密和认证。
- en: The TLS handshake[#](#the-tls-handshake "Link to this heading")
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS握手[#](#the-tls-handshake "链接到本标题")
- en: 'When used to interact with a regular web server, the TLS handshake has three
    important objectives:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于与常规Web服务器交互时，TLS握手有三个重要目标：
- en: Securely negotiate the cryptographic algorithms that will be used by the client
    and the server over the TLS session
  id: totrans-507
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TLS会话中安全协商客户端和服务器将使用的加密算法
- en: ''
  id: totrans-508
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-509
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that the client interacts with a valid server
  id: totrans-510
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证客户端与有效的服务器交互
- en: ''
  id: totrans-511
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-512
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Securely agree on the keys that will be used to encrypt and authenticate the
    messages exchanged over the TLS session
  id: totrans-513
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TLS会话中安全地商定用于加密和认证交换消息的密钥
- en: The TLS handshake is a four-way handshake illustrated in the figure below.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: TLS握手是一个四路握手，如图所示。
- en: '![msc {'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random]", arcskip="2"];
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[随机数]", arcskip="2"];
- en: '|||;'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random], Certificate", arcskip="2"];
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[随机数], 证书", arcskip="2"];
- en: '|||;'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
- en: '|||;'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
- en: '|||;'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", linecolour="red", textcolour="red"];
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "加密记录", linecolour="red", textcolour="red"];
- en: b>>c [ label = "Encrypted Record", linecolour="red", textcolour="red"];
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "加密记录", linecolour="red", textcolour="red"];
- en: '}](../Images/300581e55a5559d21fa138b6759650ca.png)<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3"
    name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"></map>'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/300581e55a5559d21fa138b6759650ca.png)<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3"
    name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"></map>'
- en: In a nutshell, the client starts the TLS handshake by proposing a random nonce.
    The server replies with its random nonce and a certificate that binds its name
    to a public key. The client generates a MasterSecret that will be used later to
    derive the session keys and encrypts it with the public key of the server. It
    also generates a Finished message that contains a MAC of all the messages exchanged
    to allow the server to detect any modification of the messages sent by the client.
    The server also sends its own Finished message. At that point, the client and
    the server sent encrypted records thanks to the keys derived from the MasterSecret.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，客户端通过提出一个随机数来启动TLS握手。服务器回复其随机数和一个将名称绑定到公钥的证书。客户端生成一个MasterSecret，稍后将用于派生会话密钥，并用服务器的公钥对其进行加密。它还生成一个包含所有交换消息的MAC的Finished消息，以便服务器检测客户端发送的消息的任何修改。服务器也发送其自己的Finished消息。在此阶段，客户端和服务器通过从MasterSecret派生的密钥发送加密记录。
- en: 'Let us first discuss the negotiation of the cryptographic algorithms and parameters.
    Like all security protocols, TLS includes some agility in its design since new
    cryptographic algorithms appear over the years and some older algorithms become
    deprecated once cryptanalysts find flaws. The TLS handshakes starts with the `ClientHello`
    message that is sent by the client. This message carries the following information
    :'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论加密算法和参数的协商。像所有安全协议一样，TLS 在其设计中包含了一些灵活性，因为随着时间的推移，新的加密算法出现，一些较旧的算法一旦密码分析学家发现缺陷，就会变得过时。TLS
    握手过程从客户端发送的 `ClientHello` 消息开始。此消息包含以下信息：
- en: 'Protocol version number: this is the version of the TLS protocol supported
    by the client. The server should use the same version of the TLS protocol as the
    client, but may opt for an older version. Both versions 1.2 and 1.3 of TLS are
    deployed today. Older versions are being deprecated.'
  id: totrans-539
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议版本号：这是客户端支持的 TLS 协议版本。服务器应使用与客户端相同的 TLS 协议版本，但可以选择较旧的版本。目前部署了 TLS 的 1.2 和
    1.3 两个版本。旧版本正在被弃用。
- en: ''
  id: totrans-540
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Random number: security protocols rely on random numbers. The client sends
    a 32 bytes long random number where usually four of these bytes correspond to
    the client’s clock. This random number is used, together with the server’s random
    number, as a seed to generate the security keys.'
  id: totrans-542
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数：安全协议依赖于随机数。客户端发送一个 32 字节长的随机数，其中通常有四个字节对应于客户端的时钟。这个随机数与服务器端的随机数一起用作生成安全密钥的种子。
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-544
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Cipher suites : this ordered list contains the set of cryptographic algorithms
    that are supported by the client, with the most preferred one listed first. In
    contrast with `ssh` that allows negotiating independent algorithms for encryption,
    key exchange and authentication, TLS relies on suites that combine these algorithms
    together. Many cryptographic suites have been defined for TLS. Various recommendations
    have been published on the security of some of these suites [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html).'
  id: totrans-545
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码套件：这个有序列表包含客户端支持的加密算法集合，最优先的算法列在第一位。与允许协商独立加密、密钥交换和认证算法的 `ssh` 不同，TLS 依赖于将这些算法组合在一起的套件。为
    TLS 定义了许多密码套件。关于这些套件中的一些套件的安全性已经发布了各种建议 [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html)。
- en: ''
  id: totrans-546
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compression algorithm : the client may propose the utilization of a specific
    compression algorithm (e.g. zlib). In theory, compressing the data before encrypting
    it is an intelligent way to reduce the amount of data exchanged. Unfortunately,
    its implementation in TLS has caused several security problems [[PHG2013]](../bibliography.html#phg2013).
    For this reason, compression is usually disabled in TLS [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html).'
  id: totrans-548
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩算法：客户端可能提议使用特定的压缩算法（例如 zlib）。理论上，在加密数据之前压缩数据是一种减少交换数据量的智能方式。不幸的是，TLS 中的实现引发了几个安全问题
    [[PHG2013]](../bibliography.html#phg2013)。因此，压缩通常在 TLS 中被禁用 [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html)。
- en: ''
  id: totrans-549
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extensions : TLS supports various extensions in the `ClientHello` message.
    These extensions [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    are important to allow the protocol to evolve, but many of them go beyond the
    scope of this chapter.'
  id: totrans-551
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：TLS 支持在 `ClientHello` 消息中的各种扩展。这些扩展 [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    对于协议的演进至关重要，但其中许多超出了本章的范围。
- en: Note
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Server Name Indication (SNI)`
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server Name Indication (SNI)`'
- en: The `Server Name Indication (SNI)` extension defined in [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    is an important TLS extension for web servers. It is used by the client to indicate
    the name of the server that it wishes to contact. The IP address associated to
    this name has been queried from the DNS and used to establish the TCP connection.
    Why should the client indicate the server name in the TLS `ClientHello` ? The
    motivation is the same as for the `Host` header line in HTTP/1.0\. With the SNI
    extension, a single TLS server can support several web sites that use different
    domain names. Thanks to the SNI extension, the server knows the concerned domain
    name at the start of the TLS session. Without this extension, hosting providers
    would have been forced use one IP address per TLS-enabled server.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在[**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)中定义的`Server
    Name Indication (SNI)`扩展是用于Web服务器的重要TLS扩展。客户端使用它来指示它希望联系的服务器名称。与该名称关联的IP地址已从DNS查询并用于建立TCP连接。为什么客户端需要在TLS的`ClientHello`中指示服务器名称呢？动机与HTTP/1.0中的`Host`头行相同。有了SNI扩展，单个TLS服务器可以支持使用不同域名的好几个网站。多亏了SNI扩展，服务器在TLS会话开始时就知道相关的域名。如果没有这个扩展，托管提供商将不得不为每个启用了TLS的服务器使用一个IP地址。
- en: 'The server replies to the `ClientHello` with several messages:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器用几条消息回复`ClientHello`：
- en: the `ServerHello` message that contains the protocol version chosen by the server
    (assumed to be the same as the client version in this chapter), the 32 random
    bytes chosen by the server, the Cipher Suite selected by the server from the list
    advertised by the client and a Session Id. This Session Id is an identifier which
    is chosen by the server. It identifies the TLS session and the security parameters
    (algorithms and keys) negotiated for this session. It is used to support session
    resumption.
  id: totrans-556
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerHello`消息包含服务器选择的协议版本（在本章中假设与客户端版本相同）、服务器选择的32个随机字节、从客户端广告的列表中选择的加密套件以及一个会话ID。这个会话ID是一个由服务器选择的标识符。它标识TLS会话以及为此会话协商的安全参数（算法和密钥）。它用于支持会话恢复。'
- en: ''
  id: totrans-557
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-558
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `Certificate` message provides the certificate (or usually a chain of certificates)
    that binds a domain name to the public key used by the server. TLS uses the server
    certificates to authenticate the server. It relies on a Public Key Infrastructure
    that is composed of a set of root certification authorities that issue certificates
    to certification authorities that in the end issue certificates to servers. TLS
    clients are usually configured with the public keys of several root certification
    authorities and use this information to validate the certificates that they receive
    from servers. For historical reasons, the TLS certificates are encoded in ASN.1
    format. The details of the ASN.1 syntax [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    are outside the scope of this book.
  id: totrans-559
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Certificate`消息提供了将域名绑定到服务器使用的公钥的证书（或通常是一系列证书）。TLS使用服务器证书来验证服务器。它依赖于由一组根证书颁发机构组成的公钥基础设施，这些根证书颁发机构向证书颁发机构颁发证书，最终向服务器颁发证书。TLS客户端通常配置有多个根证书颁发机构的公钥，并使用这些信息来验证从服务器收到的证书。由于历史原因，TLS证书是以ASN.1格式编码的。ASN.1语法的详细信息[[Dubuisson2000]](../bibliography.html#dubuisson2000)超出了本书的范围。'
- en: ''
  id: totrans-560
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-561
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `ServerKeyExchange` message is used by the server to transmit the information
    that is required to perform the key exchange. The content of this message is function
    of the selected key exchange algorithm.
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerKeyExchange`消息用于服务器传输执行密钥交换所需的信息。此消息的内容取决于所选的密钥交换算法。'
- en: ''
  id: totrans-563
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `ServerHelloDone` indicates that the server has sent all the messages for
    the first phase of the handshake.
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerHelloDone`指示服务器已发送握手第一阶段的所有消息。'
- en: 'At this point, it is time to describe the TLS key exchange. TLS supports different
    key exchange mechanisms that can be negotiated as part of the selection of the
    cipher suite. We focus on two of them to highlight their differences:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，是时候描述TLS密钥交换了。TLS支持不同的密钥交换机制，这些机制可以作为选择加密套件的一部分进行协商。我们关注其中的两个，以突出它们之间的差异：
- en: '`RSA`. This key exchange algorithm uses the encryption capabilities of the
    RSA public-key algorithm. The client has validated the server’s public key thanks
    to the `Certificate` message. It then generates a (48 bytes) random number, encrypts
    it with the server public key and sends the encrypted number to the server in
    the `ClientKeyExchange` message. The server uses its private key to decrypt the
    random number. At this point, the client and the server share the same (48 bytes
    long) secret and use it to derive the secret keys required to encrypt and authenticate
    data in the second phase. With this key exchange algorithm, the server does not
    need to send a `ServerKeyExchange` message.'
  id: totrans-567
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSA`。这个密钥交换算法使用了RSA公钥算法的加密能力。客户端通过`Certificate`消息验证了服务器的公钥。然后它生成一个（48字节）的随机数，用服务器公钥加密它，并在`ClientKeyExchange`消息中将加密后的数字发送到服务器。服务器使用其私钥解密随机数。此时，客户端和服务器共享相同的（48字节长）秘密，并使用它来推导出在第二阶段加密和验证数据所需的密钥。使用这个密钥交换算法，服务器不需要发送`ServerKeyExchange`消息。'
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-569
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DHE_RSA`. This key exchange algorithm is the Ephemeral Diffie Hellman key
    exchange with RSA signatures to authenticate the key exchange. It operates as
    a classical authenticated Diffie Hellman key exchange. If this key exchange has
    been selected by the server, it sends its Diffie Hellman parameters in the `ServerKeyExchange`
    message and signs them with its private key. The client then continues the key
    exchange and sends the results of its own computation in the `ClientKeyExchange`
    message. `DHE_RSA` is thus an authenticated Diffie Hellman key exchange where
    the initial message is sent by the server (instead of the client as in our first
    example but since the protocol is symmetric, this does not matter).'
  id: totrans-570
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DHE_RSA`。这个密钥交换算法是带有RSA签名的临时Diffie-Hellman密钥交换。它作为一个经典的认证Diffie-Hellman密钥交换操作。如果服务器选择了这个密钥交换，它将在`ServerKeyExchange`消息中发送其Diffie-Hellman参数，并用其私钥签名它们。然后客户端继续密钥交换，并在`ClientKeyExchange`消息中发送其计算结果。因此，`DHE_RSA`是一个认证的Diffie-Hellman密钥交换，其中初始消息是由服务器发送的（而不是像我们的第一个例子中的客户端，但由于协议是对称的，这并不重要）。'
- en: An important difference between `DHE_RSA` and `RSA` is their reaction against
    attacks. `DHE_RSA` is considered by many to be stronger than `RSA` because it
    supports Perfect Forward Secrecy. This property is important against attackers
    that are able to eavesdrop all the (encrypted) data sent and received by a server.
    Consider that Terrence is such an attacker that has stored all the packets exchanged
    by Bob’s server during the last six months. If he manages, by any means, to obtain
    Bob’s private key, he will be able to decrypt all the keys used to secure the
    TLS sessions with Bob’s server during this period. With `DHE_RSA`, a similar attack
    is less devastating. If Terrence knows Bob’s private key, he will be able to launch
    a man-in-the-middle attack against future TLS sessions with Bob’s server. However,
    he will not be able to recover the keys used for all the past sessions that he
    captured.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`DHE_RSA`和`RSA`之间的重要区别在于它们对攻击的反应。许多人认为`DHE_RSA`比`RSA`更强大，因为它支持完美前向安全性。这个特性对于能够监听服务器发送和接收的所有（加密）数据的攻击者来说非常重要。假设特伦斯是这样的一个攻击者，他在过去六个月里存储了鲍勃服务器交换的所有数据包。如果他通过任何手段获得了鲍勃的私钥，他将能够解密在此期间用于保护与鲍勃服务器TLS会话的所有密钥。使用`DHE_RSA`，类似的攻击破坏性较小。如果特伦斯知道鲍勃的私钥，他可以发起针对鲍勃服务器未来TLS会话的中间人攻击。然而，他无法恢复他捕获的所有过去会话中使用的密钥。'
- en: Note
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Perfect Forward Secrecy
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 完美前向安全性
- en: Perfect Forward Secrecy (PFS) is an important property for key exchange protocols.
    A protocol provides PFS if its design guarantees that the keys used for former
    sessions will not be compromised even if the private key of the server is compromised.
    This is a very important property. `DHE_RSA` provides Perfect Forward Secrecy,
    but the `RSA` key exchange does not provide this property. In practice, `DHE_RSA`
    is costly from a computational viewpoint. Recent implementations of TLS thus prefer
    `ECDHE_RSA` or `ECDHE_ECDSA` when Perfect Forward Secrecy is required.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 完美前向安全性（PFS）是密钥交换协议的一个重要特性。如果一个协议的设计保证即使服务器的私钥被泄露，之前会话使用的密钥也不会受到损害，那么它就提供了PFS。这是一个非常重要的特性。`DHE_RSA`提供了完美前向安全性，但`RSA`密钥交换不提供这个特性。在实践中，`DHE_RSA`在计算上成本较高。因此，最新的TLS实现当需要完美前向安全性时，更倾向于使用`ECDHE_RSA`或`ECDHE_ECDSA`。
- en: All the information required for the key exchange has now been transmitted.
    There are two important messages that will be sent by the client and the server
    to conclude the handshake and start the data transfer phase.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于密钥交换所需的信息现在都已传输。客户端和服务器将发送两条重要消息，以完成握手并开始数据传输阶段。
- en: The client sends the `ChangeCipherSpec` message followed by the `Finished` message.
    The `ChangeCipherSpec` message indicates that the client has received all the
    information required to generate the security keys for this TLS session. This
    messages can also appear later in the session to indicate a change in the encryption
    algorithms that are used, but this usage is outside the scope of this book. The
    `Finished` message is more important. It confirms to the server that the TLS handshake
    has been performed correctly and that no attacker has been able to modify the
    data sent by the client or the server. This is the first message that is encrypted
    with the selected security keys. It contains a hash of all the messages that were
    exchanged during the handshake.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送`ChangeCipherSpec`消息，随后是`Finished`消息。`ChangeCipherSpec`消息表示客户端已接收到生成此TLS会话安全密钥所需的所有信息。此消息也可以在会话的后期出现，以指示加密算法的变化，但这种用法超出了本书的范畴。`Finished`消息更为重要。它向服务器确认TLS握手已正确执行，且没有攻击者能够修改客户端或服务器发送的数据。这是第一个使用所选安全密钥加密的消息。它包含握手期间交换的所有消息的哈希值。
- en: The server also sends a `ChangeCipherSpec` message followed by a `Finished`
    message.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也会发送一个`ChangeCipherSpec`消息，随后是一个`Finished`消息。
- en: Note
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: TLS Cipher suites
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: TLS加密套件
- en: A TLS cipher suite is usually represented as an ASCII string that starts with
    TLS and contains the acronym of the key exchange algorithm, the encryption scheme
    with the key size and its mode of operation and the authentication algorithm.
    For example, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256` is a TLS cipher suite that
    uses the `DHE_RSA` key exchange algorithm with 128 bits AES in GCM mode for encryption
    and SHA-256 for authentication. The official list of TLS cipher suites is maintained
    by IANA [[7]](#fianatls). The NULL acronym indicates that no algorithm has been
    specified. For example, `TLS_ECDH_RSA_WITH_NULL_SHA` is a cipher suite that does
    not use any encryption but still uses the `ECDH_RSA` key exchange and `SHA` for
    authentication.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: TLS加密套件通常表示为一个以TLS开头并包含密钥交换算法缩写、密钥大小和其操作模式的加密方案以及身份验证算法的ASCII字符串。例如，`TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`是一个使用`DHE_RSA`密钥交换算法、128位AES在GCM模式下加密和SHA-256进行身份验证的TLS加密套件。TLS加密套件的官方列表由IANA维护
    [[7]](#fianatls)。NULL缩写表示未指定任何算法。例如，`TLS_ECDH_RSA_WITH_NULL_SHA`是一个不使用任何加密但仍然使用`ECDH_RSA`密钥交换和`SHA`进行身份验证的加密套件。
- en: The TLS record protocol[#](#the-tls-record-protocol "Link to this heading")
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS记录协议[#](#the-tls-record-protocol "链接到本标题")
- en: The handshake is now finished. The client and the server will exchange authenticated
    and encrypted records. TLS defines different formats for the records depending
    on the cryptographic algorithms that have been negotiated for the session. A detailed
    discussion of these different types of records is outside the scope of this introduction.
    For illustration, we briefly describe one record format.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 握手现在已完成。客户端和服务器将交换经过身份验证和加密的记录。TLS根据会话中协商的加密算法定义了不同的记录格式。这些不同类型记录的详细讨论超出了本介绍的范畴。为了说明，我们简要描述一种记录格式。
- en: As other security protocols, TLS uses different keys to encrypt and authenticate
    records. These keys are derived from the MasterSecret that is either randomly
    generated by the client after the `RSA` key exchange or derived from the Diffie
    Hellman parameters after the `DH_RSA` key exchange. The exact algorithm used to
    derive the keys is defined in [**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他安全协议一样，TLS使用不同的密钥来加密和验证记录。这些密钥是从MasterSecret派生的，MasterSecret是在`RSA`密钥交换之后由客户端随机生成的，或者在`DH_RSA`密钥交换之后从Diffie
    Hellman参数派生的。用于派生密钥的确切算法在[**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)中定义。
- en: 'A TLS record is always composed of four different fields :'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: TLS记录始终由四个不同的字段组成：
- en: a Type that indicates the type of record. The most frequent type is application
    data which corresponds to a record containing encrypted data. The other types
    are handshake, change_cipher_spec and alert.
  id: totrans-585
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示记录类型的类型。最常见类型是应用数据，对应于包含加密数据的记录。其他类型是握手、更改密钥规范和警报。
- en: ''
  id: totrans-586
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a Protocol Version field that indicates the version of the TLS protocol used.
    This version is composed of two sub fields : a major and a minor version number.'
  id: totrans-588
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个协议版本字段，表示所使用的TLS协议版本。这个版本由两个子字段组成：主版本号和次版本号。
- en: ''
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-590
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Length field. A TLS record cannot be longer than 16,384 bytes.
  id: totrans-591
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个长度字段。TLS记录的长度不能超过16,384字节。
- en: ''
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-593
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a TLSPlainText that contains the encrypted data
  id: totrans-594
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含加密数据的TLSPlainText
- en: 'TLS supports several methods to encrypted records. The selected method depends
    on the cryptographic algorithms that have been negotiated for the TLS session.
    A detailed presentation of the different methods that can be used to produce the
    TLSPlainText from the user data is outside the scope of this book. As an example,
    we study one method: Stream Encryption. This method is used with cryptographic
    algorithms which can operate on a stream of bytes. The method starts with a sequence
    of bytes provided by the user application: the plain text. The first step is to
    compute the authentication code to verify the integrity of the data. For this,
    TLS computes \(MAC(SeqNum, Header, PlainText)\) using HMAC where SeqNum is a sequence
    number which is incremented by one for each new TLS record transmitted. The Header
    is the header of the TLS record described above and PlainText is the information
    that needs to be encrypted. Note that the sequence number is maintained at the
    two endpoints of the TLS session, but it is not transmitted inside the TLS record.
    This sequence number is used to prevent replay attacks.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: TLS支持多种加密记录的方法。选择的方法取决于TLS会话中协商的加密算法。关于如何从用户数据生成TLSPlainText的不同方法的详细说明超出了本书的范围。作为一个例子，我们研究了一种方法：流加密。这种方法与可以操作字节流的加密算法一起使用。该方法从用户应用程序提供的字节序列开始：明文。第一步是计算认证码以验证数据的完整性。为此，TLS使用HMAC计算
    \(MAC(SeqNum, Header, PlainText)\)，其中SeqNum是一个序列号，每次传输新的TLS记录时增加一。Header是上述TLS记录的头部，PlainText是需要加密的信息。请注意，序列号在TLS会话的两个端点维护，但不会在TLS记录中传输。这个序列号用于防止重放攻击。
- en: Note
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MAC-then-encrypt or Encrypt-then-MAC
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: MAC后加密或先加密后MAC
- en: When secure protocols use Message Authentication and Encryption, they need to
    specify how these two algorithms are combined. A first solution, which is used
    by the current version of TLS, is to compute the authentication code and then
    encrypt both the data and the authentication code. A drawback of this approach
    is that the receiver of an encrypted TLS record must first attempt to decrypt
    data that has potentially been modified by an attacker before being able to verify
    the authenticity of the record. A better approach is for the sender to first encrypt
    the data and then compute the authentication code over the encrypted data. This
    is the encrypt-then-MAC approach proposed in [**RFC 7366**](https://datatracker.ietf.org/doc/html/rfc7366.html).
    With encrypt-then-MAC, the receiver first checks the authentication code before
    attempting to decrypt the record.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全协议使用消息认证和加密时，它们需要指定这两种算法如何结合。一个解决方案是当前TLS版本所使用的，即先计算认证码，然后加密数据和认证码。这种方法的一个缺点是，加密的TLS记录的接收者必须首先尝试解密可能被攻击者修改过的数据，然后才能验证记录的真实性。一个更好的方法是发送者首先加密数据，然后对加密数据计算认证码。这就是在[**RFC
    7366**](https://datatracker.ietf.org/doc/html/rfc7366.html)中提出的“先加密后MAC”方法。使用先加密后MAC，接收者首先检查认证码，然后再尝试解密记录。
- en: Improving TLS[#](#improving-tls "Link to this heading")
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进TLS[#](#improving-tls "链接到本标题")
- en: During the last two decades, the deployment of TLS has continued to grow. The
    early TLS servers were only used for critical services such as e-commerce websites
    or online banks. As CPU performance improved, it became much more cost-effective
    to use TLS to secure non-critical parts of web servers, including the delivery
    of HTML pages and even video services. There is now a growing number of applications
    that rely on TLS [[AM2019]](../bibliography.html#am2019).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，TLS的部署持续增长。早期的TLS服务器仅用于关键服务，如电子商务网站或在线银行。随着CPU性能的提高，使用TLS来保护Web服务器上的非关键部分（包括HTML页面的交付甚至视频服务）变得更加经济高效。现在，越来越多的应用程序依赖于TLS
    [[AM2019]](../bibliography.html#am2019)。
- en: In 2013, the statistics collected by the Firefox Telemetry project [[9]](#ftelemetry)
    revealed that 30% of the web pages loaded by Firefox users were done over HTTPS.
    In October 2019, 80% of the web pages are loaded over HTTPS. In six years, HTTPS
    became the dominant protocol to access web services. Another look at the deployment
    of HTTPS on web sites may be found in [[Helme2019]](../bibliography.html#helme2019).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在2013年，Firefox遥测项目 [[9]](#ftelemetry) 收集的统计数据显示，Firefox用户加载的网页中有30%是通过HTTPS完成的。到2019年10月，80%的网页是通过HTTPS加载的。在六年的时间里，HTTPS已成为访问网络服务的占主导地位的协议。有关网站HTTPS部署的更多信息，请参阅
    [[Helme2019]](../bibliography.html#helme2019)。
- en: Measurement studies that analyzed the evolution of TLS over the years have identified
    several important changes in the TLS ecosystem [[KRA2018]](../bibliography.html#kra2018).
    First, the preferred cryptographic algorithms have changed. While RC4 was used
    by 60% of the connections in 2012, its usage has dropped since 2015\. AES started
    to be deployed in 2013 and is now used for more than 90% of the connections. The
    deployed versions of TLS have also changed. TLS 1.0 and TLS 1.1 are now rarely
    used. The deployment of TLS 1.2 started in 2013 and reached 70% of the connections
    in 2015\. Version 1.3 of TLS, that is described below, is also widely deployed.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 对TLS多年来演变进行分析的测量研究已经确定了TLS生态系统中的一些重要变化 [[KRA2018]](../bibliography.html#kra2018)。首先，首选的加密算法已经改变。虽然2012年60%的连接使用了RC4，但自2015年以来其使用率已经下降。AES自2013年开始部署，现在被用于超过90%的连接。TLS的部署版本也已经改变。TLS
    1.0和TLS 1.1现在很少使用。TLS 1.2的部署始于2013年，到2015年达到了70%的连接。下面描述的TLS 1.3版本也得到了广泛部署。
- en: Another interesting fact is the key exchange schemes. In 2012, RSA was the dominant
    solution, used by more than 80% of the observed connections [[KRA2018]](../bibliography.html#kra2018).
    In 2013, Edward Snowden revealed the surveillance activities of several governments.
    These revelations had a huge impact on the Internet community. The IETF, which
    standardizes Internet protocols, considered in [**RFC 7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)
    that such pervasive monitoring was an attack. Since then, several IETF working
    groups have developed solutions to counter pervasive monitoring. One of these
    solutions is to encourage Perfect Forward Security. Within TLS, this implies replacing
    RSA by an authenticated Diffie Hellman key exchange such as ECDHE. Measurements
    indicate that since summer 2014, ECDHE is more popular than RSA. In 2018, more
    than 90% of the observed TLS connections used ECDHE.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事实是密钥交换方案。在2012年，RSA是主导解决方案，被观察到的超过80%的连接使用 [[KRA2018]](../bibliography.html#kra2018)。在2013年，爱德华·斯诺登揭露了几个政府的监控活动。这些揭露对互联网社区产生了巨大影响。负责互联网协议标准化的IETF在[**RFC
    7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)中认为这种普遍监控是一种攻击。从那时起，几个IETF工作组开发了对抗普遍监控的解决方案。其中一种解决方案是鼓励完美前向安全性。在TLS中，这意味着用认证的Diffie-Hellman密钥交换（如ECDHE）来替换RSA。测量表明，自2014年夏季以来，ECDHE比RSA更受欢迎。到2018年，观察到的超过90%的TLS连接使用了ECDHE。
- en: The last point is the difficulty of deploying TLS servers [[KMS2017]](../bibliography.html#kms2017).
    When TLS servers are installed, the system administrator needs to obtain certificates
    and configure a range of servers. Initially, getting certificates was complex
    and costly, but initiatives such as [https://letsencrypt.org](https://letsencrypt.org)
    have simplified this workflow.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是部署TLS服务器的难度 [[KMS2017]](../bibliography.html#kms2017)。当TLS服务器安装时，系统管理员需要获取证书并配置一系列服务器。最初，获取证书是复杂且昂贵的，但像[https://letsencrypt.org](https://letsencrypt.org)这样的倡议简化了这一工作流程。
- en: 'In 2014, the IETF TLS working started to work on the development of version
    1.3 of the TLS protocol. Their main objectives [[Rescorla2015]](../bibliography.html#rescorla2015)
    for this new version were:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，IETF的TLS工作组开始着手开发TLS协议的1.3版本。他们为此新版本的主要目标 [[Rescorla2015]](../bibliography.html#rescorla2015)
    是：
- en: simplify the design by removing unused or unsafe protocol features
  id: totrans-606
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移除未使用或不安全的协议功能来简化设计
- en: ''
  id: totrans-607
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-608
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: improve the security of TLS by leveraging the lessons learned from TLS 1.2 and
    some documented attacks
  id: totrans-609
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用从TLS 1.2和某些已记录的攻击中学到的经验来提高TLS的安全性
- en: ''
  id: totrans-610
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-611
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: improve the privacy of the protocol
  id: totrans-612
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高协议的隐私性
- en: ''
  id: totrans-613
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-614
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: reduce the latency of TLS
  id: totrans-615
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低TLS的延迟
- en: Since 2014, latency has become an important concern for web services. As access
    networks bandwidth continue to grow, latency is becoming a key factor that affects
    the performance of interactive web services. With TLS 1.2, the download of a web
    page requires a minimum of four round-trip-times, one to create the underlying
    TCP connection, one to exchange the ClientHello/ServerHello, one to exchange the
    keys and then one to send the HTTP GET and retrieve the response. This can be
    very long when the server is not near the client. TLS 1.3 aimed at reducing this
    handshake to one round-trip-time and even zero by placing some of the cryptographic
    handshake in the TCP handshake. This part will be discussed in the TCP chapter.
    We focus here on the reducing the TLS handshake to a single round-trip-time.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2014 年以来，延迟已成为网络服务的一个重要关注点。随着接入网络的带宽持续增长，延迟正成为影响交互式网络服务性能的关键因素。TLS 1.2 要求下载一个网页至少需要四个往返时间，一个用于创建底层
    TCP 连接，一个用于交换客户端问候/服务器问候，一个用于交换密钥，然后一个用于发送 HTTP GET 并检索响应。当服务器不在客户端附近时，这可能非常耗时。TLS
    1.3 旨在通过将部分加密握手放在 TCP 握手中来将此握手减少到一个往返时间，甚至为零。这部分将在 TCP 章节中讨论。我们在这里关注的是将 TLS 握手减少到一个往返时间。
- en: To simplify both the design and the implementations, TLS 1.3 uses only a small
    number of cipher suites. Five of them are specified in [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)
    and `TLS_AES_128_GCM_SHA256` must be supported by all implementations. To ensure
    privacy, all cipher suites that did not provide Perfect Forward Secrecy have been
    removed. Compression has also been removed from TLS since several attacks on TLS
    1.2 exploited its compression capability [**RFC 7457**](https://datatracker.ietf.org/doc/html/rfc7457.html).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设计和实现，TLS 1.3 仅使用少量密钥套件。其中五个在 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)
    中指定，并且所有实现都必须支持 `TLS_AES_128_GCM_SHA256`。为了确保隐私，所有不提供完美前向安全的密钥套件都已移除。自 TLS 1.2
    被发现其压缩功能易受攻击以来，压缩也已被从 TLS 中移除 [**RFC 7457**](https://datatracker.ietf.org/doc/html/rfc7457.html)。
- en: Note
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Enterprises, privacy and TLS
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 企业、隐私和 TLS
- en: By supporting only cipher suites that provide Perfect Forward Secrecy in TLS
    1.3, the IETF aims at protecting the privacy of users against a wide range of
    attacks. However, this choice has resulted in intense debates in some enterprises.
    Some enterprises, notably in financial organizations, have deployed TLS, but wish
    to be able to decrypt TLS traffic for various security-related activities. These
    enterprises tried to lobby within the IETF to maintain RSA-based cipher suites
    that do not provide Perfect Forward Secrecy. Their arguments did not convince
    the IETF. Eventually, these enterprises moved to ETSI, another standardization
    body, and convinced them to adopt entreprise TLS, a variant of TLS 1.3 that does
    not provide Perfect Forward Secrecy [[eTLS2018]](../bibliography.html#etls2018).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅支持在 TLS 1.3 中提供完美前向安全的密钥套件，IETF 旨在保护用户免受各种攻击的隐私。然而，这一选择在一些企业中引发了激烈的争论。一些企业，特别是在金融机构中，已经部署了
    TLS，但希望能够解密 TLS 流量以进行各种安全相关活动。这些企业试图在 IETF 内进行游说，以维持不提供完美前向安全的基于 RSA 的密钥套件。他们的论点并没有说服
    IETF。最终，这些企业转向了 ETSI，另一个标准化机构，并说服他们采用企业 TLS，这是一种不提供完美前向安全的 TLS 1.3 变体 [[eTLS2018]](../bibliography.html#etls2018)。
- en: The TLS 1.3 handshake differs from the TLS 1.2 handshake in several ways. First,
    the TLS 1.3 handshake requires a single round-trip-time when the client connects
    for the first time to a server. To achieve this, the TLS designers look at the
    TLS 1.2 handshake in details and found that the first round-trip-time is mainly
    used to select the set of cryptographic algorithms and the cryptographic exchange
    scheme that will be used over the TLS session. TLS 1.3 drastically simplifies
    this negotiation by requiring to use the Diffie Hellman exchange with a small
    set of possible parameters. This means that the client can guess the parameters
    used by the server (i.e. the modulus, p and the base g) and immediately start
    the Diffie Hellman exchange. A simplified version of the TLS 1.3 handshake is
    shown in the figure below.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 握手与 TLS 1.2 握手在几个方面有所不同。首先，当客户端首次连接到服务器时，TLS 1.3 握手需要单次往返时间。为了实现这一点，TLS
    设计者详细研究了 TLS 1.2 握手，并发现第一次往返时间主要用于选择将在 TLS 会话中使用的加密算法和加密交换方案。TLS 1.3 通过要求使用具有小参数集的
    Diffie-Hellman 交换来极大地简化了这种协商。这意味着客户端可以猜测服务器使用的参数（即模数 p 和底数 g），并立即开始 Diffie-Hellman
    交换。下面图示展示了简化版的 TLS 1.3 握手。
- en: '![msc {'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Client",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c]", arcskip="2"];
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c]", arcskip="2"];
- en: '|||;'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/e5ae4c8c184c7b414c018f2972f772de.png)<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"
    name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"></map>'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e5ae4c8c184c7b414c018f2972f772de.png)<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"
    name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"></map>'
- en: There are several important differences with the TLS 1.2 handshake. First, the
    Diffie Hellman key exchange is required in TLS 1.3 and this exchange is initiated
    by the client (before having validated the server identity). To initiate the Diffie
    Hellman key exchange, the client needs to guess the modulus and the base that
    can be accepted by the server. Either the client uses standard parameters that
    most server supports or the client remembers the last modulus/base that it used
    with this particular server. If the client guessed incorrectly, the server replies
    with the parameters that it expects and one round-trip-time is lost. When the
    server sends its ServerHello, it already knows the session key. This implies that
    the server can encrypt all subsequent messages. After one round-trip-time, all
    data exchanged over the TLS 1.3 session is encrypted and authenticated. In TLS
    1.3, the server certificate is encrypted with the session key, as well as the
    Finished message. The server signs the handshake to confirm that it owns the public
    key of its certificate. If the server wants to send application data, it can already
    encrypt it and send it to the client. Upon reception of the server Certificate,
    the client verifies it and checks the signature of the handshake and the Finished
    message. The client confirms the end of the handshake by sending its own Finished
    message. At that time, the client can send encrypted data. This means that the
    client only had to wait one round-trip-time before sending encrypted data. This
    is much faster than with TLS 1.2.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TLS 1.2 握手相比，有几个重要的不同之处。首先，TLS 1.3 需要Diffie Hellman 密钥交换，并且这个交换是由客户端发起的（在验证服务器身份之前）。为了发起
    Diffie Hellman 密钥交换，客户端需要猜测服务器可以接受的模数和基数。客户端要么使用大多数服务器支持的标准参数，要么记住与该特定服务器上次使用的最后一个模数/基数。如果客户端猜测错误，服务器将回复它期望的参数，这将导致丢失一个往返时间。当服务器发送其
    ServerHello 时，它已经知道了会话密钥。这意味着服务器可以加密所有后续的消息。经过一个往返时间后，TLS 1.3 会话中交换的所有数据都是加密和认证的。在
    TLS 1.3 中，服务器证书是用会话密钥加密的，以及Finished消息。服务器签署握手以确认它拥有其证书的公钥。如果服务器想要发送应用程序数据，它已经可以加密并发送给客户端。在接收到服务器证书后，客户端验证它并检查握手和Finished消息的签名。客户端通过发送自己的Finished消息来确认握手的结束。这时，客户端可以发送加密数据。这意味着客户端在发送加密数据之前只需等待一个往返时间。这比
    TLS 1.2 快得多。
- en: For some applications, waiting one round-trip-time before being able to send
    data is too long. TLS 1.3 allows the client to send encrypted data immediately
    after the ClientHello, without having to wait for the ServerHello message. At
    this point in the handshake, the client cannot know the key that will be derived
    by the Diffie Hellman key exchange. The trick is that the server and the client
    need to have previously agreed on a pre-shared-key. This key could be negotiated
    out of band, but usually it was exchanged over a previous TLS session between
    the client and the server. Both the client and the server can store this key in
    their cache. When the client creates a new TLS session to a server, it checks
    whether it already knows a pre-shared key for this server. If so, the client announces
    the identifier of this key in its ClientHello message. Thanks to this identifier,
    the server can recover the key and use it to decrypt the 0-rtt Encrypted record.
    A simplified version of the 0-rtt TLS 1.3 handshake [[8]](#fhandshake) is shown
    in the figure below.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，在能够发送数据之前等待一个往返时间太长了。TLS 1.3 允许客户端在 ClientHello 之后立即发送加密数据，无需等待 ServerHello
    消息。在这个握手阶段，客户端无法知道通过 Diffie Hellman 密钥交换将导出的密钥。技巧是服务器和客户端需要事先就预共享密钥达成一致。这个密钥可以通过非绑定方式协商，但通常是在客户端和服务器之间的先前
    TLS 会话中交换。客户端和服务器都可以将此密钥存储在它们的缓存中。当客户端创建到服务器的新的 TLS 会话时，它会检查是否已经知道该服务器的预共享密钥。如果是这样，客户端将在其
    ClientHello 消息中宣布此密钥的标识符。多亏了这个标识符，服务器可以恢复密钥并使用它来解密 0-rtt 加密记录。下面展示了简化版的 0-rtt
    TLS 1.3 握手 [[8]](#fhandshake)。
- en: '![msc {'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Client",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
- en: '|||;'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
- en: '|||;'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "证书，签名(K,握手), 完成, 加密记录", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "完成", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "加密记录", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "加密记录", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/37315cb85580d2a0a41ccf2aa6b695ae.png)<map id="04ec071344c2fae0632e2d690c2782c9017b631e"
    name="04ec071344c2fae0632e2d690c2782c9017b631e"></map>'
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/37315cb85580d2a0a41ccf2aa6b695ae.png)<map id="04ec071344c2fae0632e2d690c2782c9017b631e"
    name="04ec071344c2fae0632e2d690c2782c9017b631e"></map>'
- en: 'On the web, TLS clients use certificates to authenticate servers but the clients
    are not authenticated. However, there are environments such as enterprise networks
    where servers may need to authenticate clients as well. A popular deployment is
    to authenticate remote clients who wish to access the enterprise network through
    a Virtual Private Network service. Some of these services run above TLS (or more
    precisely a variant of TLS named DTLS that runs above UDP [[MoR2004]](../bibliography.html#mor2004)
    but is outside the scope of this chapter). In such services, each client is authenticated
    thanks to a public key and a certificate that is trusted by the servers. To establish
    a TLS session, such a client needs to prove that it owns the public key associated
    with the certificate. This is done by the server thanks to the CertificateRequest
    message. The TLS handshake becomes the following one:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，TLS客户端使用证书来验证服务器，但客户端没有被验证。然而，在企业网络等环境中，服务器可能还需要验证客户端。一种流行的部署是为希望通过虚拟专用网络服务访问企业网络的远程客户端进行验证。其中一些服务在TLS之上运行（或更精确地说，在UDP之上运行的TLS变体DTLS，但超出了本章的范围[[MoR2004]](../bibliography.html#mor2004)）。在这些服务中，每个客户端都通过一个公钥和服务器信任的证书进行验证。为了建立TLS会话，这样的客户端需要证明它拥有与证书关联的公钥。这是通过服务器发送的证书请求消息来完成的。TLS握手变为以下形式：
- en: '![msc {'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
- en: '|||;'
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0-rtt 加密记录", textcolour="洋红色", arcskip="2"];
- en: '|||;'
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: ''
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "CertificateRequest, Certificate, Sign(K,Handshake), Finished,
    Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "证书请求，证书，签名(K,握手), 完成, 加密记录", textcolour="红色", linecolour="红色",
    arcskip="2"];
- en: '|||;'
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Certificate, Sign(Kc, Handshake), Finished", textcolour="red",
    linecolour="red", arcskip="2"];
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "证书，签名(Kc, 握手), 完成", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "加密记录", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-695
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "加密记录", textcolour="红色", linecolour="红色", arcskip="2"];
- en: '|||;'
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/6b610706117d1538fe4793f16be928b1.png)<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82"
    name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"></map>'
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/6b610706117d1538fe4793f16be928b1.png)<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82"
    name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"></map>'
- en: The server sends a CertificatRequest message. The client returns its certificate
    and signs the Handshake with is private key. This confirms to the server that
    the client owns the public key indicated in its certificate.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送一个证书请求消息。客户端返回其证书并使用其私钥签名握手。这向服务器确认客户端拥有其证书中指示的公钥。
- en: 'There are many more differences between TLS 1.2 and TLS 1.3\. Additional details
    may be found in their respective specifications, [**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)
    and [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).  ## Securing
    the Domain Name System[#](#securing-the-domain-name-system "Link to this heading")'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 'TLS 1.2和TLS 1.3之间有许多更多差异。更多详细信息可以在它们各自的规范中找到，分别是[**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)和[**RFC
    8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。  # 保护域名系统[#](#securing-the-domain-name-system
    "链接到本标题")'
- en: The Domain Name System provides a critical service in the Internet infrastructure
    since it maps the domain names that are used by end users onto IP addresses. Since
    end users rely on names to identify the servers that they connect to, any incorrect
    information distributed by the DNS would direct end users’ connections to invalid
    destinations. Unfortunately, several attacks of this kind occurred in the past.
    A detailed analysis of the security threats against the DNS appeared in [**RFC
    3833**](https://datatracker.ietf.org/doc/html/rfc3833.html). We consider three
    of these threats in this section and leave the others to [**RFC 3833**](https://datatracker.ietf.org/doc/html/rfc3833.html).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统在互联网基础设施中提供一项关键服务，因为它将终端用户使用的域名映射到IP地址。由于终端用户依赖于名称来识别他们要连接的服务器，DNS分发的任何错误信息都会将终端用户的连接引导到无效的目的地。不幸的是，过去发生了几起此类攻击。关于DNS的安全威胁的详细分析出现在[**RFC
    3833**](https://datatracker.ietf.org/doc/html/rfc3833.html)。我们在这部分考虑了其中的三个威胁，并将其他威胁留给[**RFC
    3833**](https://datatracker.ietf.org/doc/html/rfc3833.html)。
- en: The first type of attack is eavesdropping. An attacker who can capture packets
    sent to a DNS resolver or a DNS server can gain valuable information about the
    DNS names that are used by a given end user. If the attacker can capture all the
    packets sent to a DNS resolver, he/she can collect a lot of meta data about the
    domain names used by the end user. Preventing this type of attack has not been
    an objective of the initial design of the DNS. There are currently discussions
    with the IETF to carry DNS messages over TLS sessions to protect against such
    attacks. However, these solutions are not yet widely deployed.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种攻击类型是窃听。能够捕获发送到DNS解析器或DNS服务器的数据包的攻击者可以获取有关特定终端用户使用的DNS名称的有价值信息。如果攻击者可以捕获发送到DNS解析器的所有数据包，他/她可以收集大量关于终端用户使用的域名元数据。防止这种类型的攻击并不是DNS初始设计的目标。目前，正在与IETF讨论通过TLS会话传输DNS消息以保护此类攻击。然而，这些解决方案尚未得到广泛部署。
- en: The second type of attack is the man-in-the-middle attack. Consider that Alice
    is sending DNS requests to her DNS resolver. Unfortunately, Mallory sits in front
    of this resolver and can capture and modify all the packets sent by Alice to her
    resolver. In this case, Mallory can easily modify the DNS responses sent by the
    resolver to redirect Alice’s packets to a different IP address controlled by Mallory.
    This enables Mallory to observe (and possibly modify) all the packets sent and
    received by Alice. In practice, executing this attack is not simple since DNS
    resolvers are usually installed in protected datacenters. However, if Mallory
    controls the WiFi access point that Alice uses to access the Internet, he could
    easily modify the packets on this access point and some software packages automate
    this type of attacks.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种攻击类型是中间人攻击。假设爱丽丝正在向她的DNS解析器发送DNS请求。不幸的是，Mallory坐在解析器的前面，可以捕获和修改爱丽丝发送给解析器的所有数据包。在这种情况下，Mallory可以轻松修改解析器发送的DNS响应，将爱丽丝的数据包重定向到Mallory控制的不同的IP地址。这使得Mallory能够观察（并可能修改）爱丽丝发送和接收的所有数据包。实际上，执行这种攻击并不简单，因为DNS解析器通常安装在受保护的数据中心中。然而，如果Mallory控制爱丽丝用来访问互联网的WiFi接入点，他可以轻松修改这个接入点上的数据包，并且一些软件包会自动化这种攻击类型。
- en: If Mallory cannot control a router on the path between Alice and her resolver,
    she could still launch a different attack. To understand this attack, it is important
    to correctly understand how the DNS protocol operates and the roles of the different
    fields of the DNS header which is reproduced in [Fig. 46](#fig-dns-header2).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Mallory无法控制爱丽丝和她的解析器之间的路由器，她仍然可以发起不同的攻击。要理解这种攻击，正确理解DNS协议的工作方式和DNS头部不同字段的角色非常重要，这些内容在[图46](#fig-dns-header2)中重现。
- en: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '![DNS头部](../Images/21a7bad41190434264bf8afe39a2de6a.png)'
- en: Fig. 46 DNS header[#](#id39 "Link to this image")
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 图46 DNS头部[#](#id39 "链接到此图像")
- en: The first field of the header is the Identification field. When Alice sends
    a DNS request, she places a 16-bits integer in this field and remembers it. When
    she receives a response, she uses this Identification field to locate the initial
    DNS request that she sent. The response is only used if its Identification matches
    a pending DNS request (containing the same question).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 报头的第一字段是标识符字段。当Alice发送DNS请求时，她将一个16位的整数放入这个字段，并记住它。当她收到响应时，她使用这个标识符字段来定位她发送的初始DNS请求。只有当响应的标识符与挂起的DNS请求（包含相同的问题）匹配时，才使用该响应。
- en: Mallory has studied the DNS protocol and understands how it works. If he can
    predict a popular domain for which Alice will regularly send DNS requests, then
    he can prepare a set of DNS responses that map the name requested by Alice to
    an IP address controlled by Mallory instead of the legitimate DNS response. Each
    DNS response has a different Identification. Since there are only 65,536 values
    for the Identification field, it is possible for Mallory to send them to Alice
    hoping that one of them will be received while Alice is waiting for a DNS response
    with the same identifier. In the past, it was difficult to send 65,536 DNS responses
    quickly enough. However, with the high speed links that are available today, this
    is not an issue anymore. A second concern for Mallory is that he must be able
    to send the DNS responses as if they were coming directly from the DNS resolver.
    This implies that Mallory must be able to send IP packets that appear to originate
    from a different address. Although networks should be configured to prevent this
    type of attack, this is not always the case and there are networks where it is
    possible for a host to send packets with a different source IP address [[10]](#fspoof).
    If the attack targets a single end user, e.g. Alice, this is annoying for this
    user. However, if the attacker can target a DNS resolver that serves an entire
    company or an entire ISP, the impact of the attack can be much larger in particular
    if the injected DNS response carries a long TTL and thus resides in the resolver’s
    cache for a long period of time.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 马洛里研究了DNS协议，并理解了它是如何工作的。如果他能够预测Alice将定期发送DNS请求的流行域名，那么他可以准备一组DNS响应，将Alice请求的域名映射到马洛里控制的IP地址，而不是合法的DNS响应。每个DNS响应都有一个不同的标识符。由于标识符字段只有65,536个值，马洛里可以向Alice发送这些值，希望其中之一在Alice等待具有相同标识符的DNS响应时被接收。在过去，快速发送65,536个DNS响应是困难的。然而，随着今天可用的高速链路，这不再是问题。马洛里的第二个担忧是，他必须能够发送DNS响应，就像它们直接来自DNS解析器一样。这意味着马洛里必须能够发送看起来来自不同地址的IP数据包。尽管网络应该配置为防止此类攻击，但这并不总是如此，有些网络允许主机发送具有不同源IP地址的数据包
    [[10]](#fspoof)。如果攻击目标是单个最终用户，例如Alice，这对该用户来说很烦人。然而，如果攻击者可以针对为整个公司或整个ISP提供服务的DNS解析器，攻击的影响可能会更大，特别是如果注入的DNS响应携带了长的TTL，从而在解析器的缓存中保留较长时间。
- en: Fortunately, designers of DNS servers and resolvers have found solutions to
    mitigate this type of attack. The easiest approach would have been to update the
    format of the DNS requests and responses to include a larger Identifier field.
    Unfortunately, this elegant solution was not possible with the DNS because the
    DNS messages do not include any version number that would have enabled such a
    change. Since the DNS messages are exchanged inside UDP segments, the DNS developers
    found an alternate solution to counter this attack. There are two ways for the
    DNS library used by Alice to send her DNS requests. A first solution is to bind
    one UDP source port and always send the DNS requests from this source port (the
    destination port is always port `53`). The advantage of this solution is that
    Alice’s DNS library can easily receive the DNS responses by listening to her chosen
    port. Unfortunately, once the attacker has found the source port used by Alice,
    he only needs to send 65,536 DNS responses to inject an invalid response. Fortunately,
    Alice can send her DNS requests in a different way. Instead of using the same
    source port for all DNS requests, she can use a different source port for each
    request. In practice, each DNS request will be sent from a different source port.
    From an implementation viewpoint, this implies that Alice’s DNS library will need
    to listen to one different port number for each pending DNS request. This increases
    the complexity of her implementation. From a security viewpoint there is a clear
    benefit since the attacker needs to guess both the 16 bits Identifier and the
    16 bits UDP source port to inject a fake DNS response. To generate all possible
    DNS responses, the attacker would need to generate almost \(2^{32}\) different
    messages, which is excessive in today’s networks. Most DNS implementations use
    this second approach to prevent these cache poisoning attacks.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，DNS服务器和解析器的设计者已经找到了缓解这种攻击的解决方案。最简单的方法是更新DNS请求和响应的格式，以包括一个更大的标识符字段。不幸的是，由于DNS消息不包含任何版本号，这种优雅的解决方案在DNS中是不可能的。由于DNS消息是在UDP段内交换的，DNS开发者找到了一种替代方案来对抗这种攻击。Alice使用的DNS库发送DNS请求有两种方式。第一种解决方案是绑定一个UDP源端口，并始终从这个源端口发送DNS请求（目标端口始终是端口`53`）。这种解决方案的优点是Alice的DNS库可以很容易地通过监听所选端口来接收DNS响应。不幸的是，一旦攻击者找到了Alice使用的源端口，他只需要发送65,536个DNS响应来注入一个无效的响应。幸运的是，Alice可以通过不同的方式发送她的DNS请求。她不必为所有DNS请求使用相同的源端口，可以为每个请求使用不同的源端口。在实践中，每个DNS请求都会从一个不同的源端口发送。从实现的角度来看，这意味着Alice的DNS库需要为每个挂起的DNS请求监听一个不同的端口号。这增加了她实现的复杂性。从安全的角度来看，这有一个明显的优势，因为攻击者需要猜测16位的标识符和16位的UDP源端口来注入一个伪造的DNS响应。为了生成所有可能的DNS响应，攻击者需要生成几乎\(2^{32}\)个不同的消息，这在今天的网络中是过度的。大多数DNS实现使用第二种方法来防止这些缓存中毒攻击。
- en: These attacks affect the DNS messages that are exchanged between a client and
    its resolver or between a resolver and name servers. Another type of attack exploits
    the possibility of providing several resource records inside one DNS response.
    A frequent optimization used by DNS servers and resolvers is to include several
    related resource records in each response. For example, if a client sends a DNS
    query for an NS record, it usually receives in the response both the queried record,
    i.e. the name of the DNS server that serves the queried domain, and the IP addresses
    of this server. Some DNS servers return several NS records and the associated
    IP addresses. The cache poisoning attack exploits this DNS optimization.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击影响客户端与其解析器之间或解析器与域名服务器之间交换的DNS消息。另一种攻击利用了在一个DNS响应中提供多个资源记录的可能性。DNS服务器和解析器常用的一个优化方法是，在每次响应中包含多个相关的资源记录。例如，如果客户端发送一个DNS查询请求NS记录，它通常会在响应中接收到查询的记录，即提供查询域名的DNS服务器的名称，以及该服务器的IP地址。一些DNS服务器返回多个NS记录及其相关的IP地址。缓存中毒攻击就是利用这种DNS优化。
- en: Let us illustrate it on an example. Assume that Alice frequently uses the example.net
    domain and in particular the web server whose name is www.example.net. Mallory
    would like to redirect the TCP connections established by Alice towards www.example.net
    to one IP address that he controls. Assume that Mallory controls the mallory.net
    domain. Mallory can tune the DNS server of his domain and add special DNS records
    to the responses that it sends. An attack could go roughly as follows. Mallory
    forces Alice to visit the www.mallory.net web site. He can achieve this by sending
    a spam message to Alice or buying advertisements on a web site visited by Alice
    and redirect one of these advertisements to www.mallory.net. When visiting the
    advertisement, Alice’s DNS resolver will send a DNS request for www.mallory.net.
    Since Mallory control the DNS server, he can easily add in the response a AAAA
    record that associates www.example.net to the IP address controlled by Mallory.
    If Alice’s DNS library does not check the returned response, the cache entry for
    www.example.net will be replaced by the AAAA record sent by Mallory.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明。假设Alice经常使用example.net域名，特别是名为www.example.net的Web服务器。Mallory希望将Alice建立的指向www.example.net的TCP连接重定向到他控制的某个IP地址。假设Mallory控制mallory.net域名。Mallory可以调整他域名的DNS服务器，并向发送的响应中添加特殊的DNS记录。攻击可能大致如下。Mallory迫使Alice访问www.mallory.net网站。他可以通过向Alice发送垃圾邮件或购买Alice访问的网站上的广告，并将其中一条广告重定向到www.mallory.net来实现。当访问广告时，Alice的DNS解析器将发送一个针对www.mallory.net的DNS请求。由于Mallory控制DNS服务器，他可以在响应中轻松添加一个AAAA记录，将www.example.net关联到Mallory控制的IP地址。如果Alice的DNS库没有检查返回的响应，则www.example.net的缓存条目将被Mallory发送的AAAA记录替换。
- en: To cope with these security threats and improve the security of the DNS, the
    IETF has defined several extensions that are known as DNSSEC. DNSSEC exploits
    public-key cryptography to authenticate the content of the DNS records that are
    sent by DNS servers and resolvers. DNSEC is defined in three main documents [**RFC
    4033**](https://datatracker.ietf.org/doc/html/rfc4033.html), [**RFC 4034**](https://datatracker.ietf.org/doc/html/rfc4034.html),
    [**RFC 4035**](https://datatracker.ietf.org/doc/html/rfc4035.html). With DNSSEC,
    each DNS zone uses one public-private key pair. This key pair is only used to
    sign and authenticate DNS records. The DNS records are not encrypted and DNSSEC
    does not provide any confidentiality. Other DNS extensions are being developed
    to ensure the confidentiality of the information exchanged between a client and
    its resolvers [**RFC 7626**](https://datatracker.ietf.org/doc/html/rfc7626.html).
    Some of these extensions exchange DNS records over a TLS session which provides
    the required confidentiality, but they are not yet deployed and outside the scope
    of this chapter.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些安全威胁并提高DNS的安全性，IETF定义了几个被称为DNSSEC的扩展。DNSSEC利用公钥加密来验证DNS服务器和解析器发送的DNS记录内容。DNSEC定义在三个主要文档中[**RFC
    4033**](https://datatracker.ietf.org/doc/html/rfc4033.html)、[**RFC 4034**](https://datatracker.ietf.org/doc/html/rfc4034.html)、[**RFC
    4035**](https://datatracker.ietf.org/doc/html/rfc4035.html)。使用DNSSEC，每个DNS区域使用一个公钥私钥对。这个密钥对仅用于签署和验证DNS记录。DNS记录不会被加密，DNSSEC也不提供任何机密性。其他DNS扩展正在开发中，以确保客户端与其解析器之间交换信息的机密性[**RFC
    7626**](https://datatracker.ietf.org/doc/html/rfc7626.html)。其中一些扩展通过TLS会话交换DNS记录，这提供了所需的机密性，但它们尚未部署，也不在本章的范围内。
- en: DNSSEC defines four new types of DNS records that are used together to authenticate
    the information distributed by the DNS.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC定义了四种新的DNS记录类型，这些记录类型一起用于验证DNS分发的信息。
- en: the DNSKEY record allows storing the public key associated with a zone. This
    record is encoded as a TLV and includes a Base64 representation of the key and
    the identification of the public key algorithm. This allows the DNSKEY record
    to support different public key algorithms.
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNSKEY记录允许存储与区域关联的公钥。此记录以TLV编码，包括密钥的Base64表示形式和公钥算法的标识。这允许DNSKEY记录支持不同的公钥算法。
- en: ''
  id: totrans-716
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-717
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the RRSIG record is used to encode the signature of a DNS record. This record
    contains several sub-fields. The most important ones are the algorithm used to
    generate the signature, the identifier of the public key used to sign the record,
    the original TTL of the signed record and the validity period for the signature.
  id: totrans-718
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RRSIG记录用于编码DNS记录的签名。此记录包含几个子字段。其中最重要的包括生成签名的算法、用于签署记录的公钥标识符、签署记录的原始TTL以及签名的有效期。
- en: ''
  id: totrans-719
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the DS record contains a hash of a public key. It is used by a parent zone to
    certify the public key used by one of its child zones.
  id: totrans-721
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: DS记录包含一个公钥的哈希值。它被父区域用来认证其子区域使用的公钥。
- en: ''
  id: totrans-722
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the NSEC record is used when non-existent domain names are queried. Its usage
    will be explained later
  id: totrans-724
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查询不存在的域名时，使用NSEC记录。它的用法将在后面解释。
- en: The simplest way to understand the operation of DNSSEC is to rely on a simple
    example. Let us consider the example.org domain and assume that Alice wants to
    retrieve the AAAA record for www.example.org using DNSSEC.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 理解DNSSEC操作的最简单方法是通过一个简单的例子。让我们考虑example.org域名，并假设Alice想使用DNSSEC检索www.example.org的AAAA记录。
- en: The security of DNSSEC relies on anchored keys. An anchored key is a public
    key that is considered as trusted by a resolver. In our example, we assume that
    Alice’s resolver has obtained the public key of the servers that manage the root
    zone in a secure way. This key has been distributed outside of the DNS, e.g. it
    has been published in a newspaper or has been received in a sealed letter.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC的安全性依赖于锚定密钥。锚定密钥是一个被认为由解析器信任的公钥。在我们的例子中，我们假设Alice的解析器已经以安全的方式获得了管理根区域的服务器的公钥。这个密钥是在DNS之外分发的，例如，它已经在报纸上发布或通过密封信件接收。
- en: To obtain an authenticated record for www.example.org, Alice’s resolver first
    needs to retrieve the NS which is responsible for the .org Top-Level Domain (TLD).
    This record is served by the DNS root server and Alice’s resolver can retrieve
    the signature (RRSIG record) for this NS record. Since Alice knows the DNSKEY
    of the root, she can verify the validity of this signature.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取www.example.org的认证记录，Alice的解析器首先需要检索负责.org顶级域名(TLD)的NS记录。这个记录由DNS根服务器提供，Alice的解析器可以检索这个NS记录的签名（RRSIG记录）。由于Alice知道根的DNSKEY，她可以验证这个签名的有效性。
- en: The next step is to contact ns.org, the NS responsible for the .org TLD to retrieve
    the NS record for the example.org domain. This record is accompanied by a RRSIG
    record that authenticates it. This RRSIG record is signed with the key of the
    .org domain. Alice’s resolver can retrieve this public key as the DNSKEY record
    for the .org, but how can it trust this key since it is distributed by using the
    DNS and could have been modified by attackers ? DNSSEC solves this problem by
    using the DS record that is stored in the parent zone (in this case, the root
    zone). This record contains a hash of a public key that is signed with a RRSIG
    signature. Since Alice’s resolver’s trusts the root key, it can validate the signature
    of the DS record for the .org domain. It can then retrieve the DNSKEY record for
    this domain from the DNS and compare the hash of this key with the DS record.
    If they match, the public key of the .org domain can be trusted. The same technique
    is used to obtain and validate the key of the example.org domain. Once this key
    is trusted, Alice’s resolver can request the AAAA record for www.example.org and
    validate its signature.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是与ns.org联系，这是负责.org TLD的NS记录，以检索example.org域的NS记录。这个记录附带了认证它的RRSIG记录。这个RRSIG记录是用.org域的密钥签名的。Alice的解析器可以检索这个公钥作为.org的DNSKEY记录，但如何信任这个密钥，因为它是通过DNS分发的，可能被攻击者修改过？DNSSEC通过使用存储在父区域（在这种情况下，是根区域）中的DS记录来解决此问题。这个记录包含一个用RRSIG签名签名的公钥的哈希值。由于Alice的解析器信任根密钥，它可以验证.org域的DS记录的签名。然后，它可以从DNS中检索这个域的DNSKEY记录，并将这个密钥的哈希值与DS记录进行比较。如果它们匹配，可以信任.org域的公钥。相同的技巧用于获取和验证example.org域的密钥。一旦这个密钥被信任，Alice的解析器就可以请求www.example.org的AAAA记录并验证其签名。
- en: Thanks to the DS record, a resolver can validate the public keys of client zones
    as long as their is a chain of DS -> DNSKEY records from an anchored key. If the
    resolver trusts the public key of the root zone, it can validate all DNS replies
    for which this chain exists.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了DS记录，解析器可以在存在从锚定密钥的DS -> DNSKEY记录链的情况下验证客户端区域的公钥。如果解析器信任根区域的公钥，它可以验证所有存在此链的DNS回复。
- en: There are several details of the operation of DNSSEC that are worth being discussed.
    First, a server that supports DNSSEC must have a public-private key pair. The
    public key is distributed with the DNSKEY record. The private key is never distributed
    and it does not even need to be stored on the server that uses the public key.
    DNSSEC does not require the DNSSEC servers to perform any operation that requires
    a private key in real time. All the RRSIG records can be computed offline, possibly
    on a different server than the server that returns the DNSSEC replies. The initial
    motivation for this design choice was the CPU complexity of computing the RRSIG
    signatures for zones that contain millions of records. In the early days of DNSSEC,
    this was an operational constraint. Today, this is less an issue, but avoiding
    costly signature operations in real time has two important benefits. First, this
    reduces the risk of denial of service attacks since an attacker cannot force a
    DNSSEC server to perform computationally intensive signing operations. Second,
    the private key can be stored offline, which means that even if an attacker gains
    access to the DNSSEC server, it cannot retrieve its private key. Using offline
    signatures for the RRSIG records has some practical implications that are reflected
    in the content of this record. First, each RRSIG record contains the original
    TTL of the signed record. When DNS resolvers cache records, they change the value
    of the TTL of these cached records and then return the modified records to their
    clients. When a resolver receives a signed DNS record, it must replace the received
    TTL of the record with the original TTL (and check that the received TTL is smaller
    than the original one) before checking the signature. Second, the RRSIG records
    contain a validity period, i.e. a starting time and an ending time for the validity
    of the signature. This period is specified as two timestamps. This period is only
    the validity of the signature. It does not affect the TTL of the signed record
    and is independent from the TTL. In practice, the validity period is important
    to allow DNS server operators to update their public/private keys. When such a
    key is changed, e.g. because the private could have been compromised, there is
    some period of time during which records signed with the two keys coexist in the
    network. The validity period allows ensuring that old signatures do not remain
    in DNS caches for ever.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC 运作中有几个细节值得讨论。首先，支持 DNSSEC 的服务器必须拥有一对公钥和私钥。公钥与 DNSKEY 记录一起分发。私钥永远不会分发，甚至不需要存储在使用公钥的服务器上。DNSSEC
    不要求 DNSSEC 服务器实时执行任何需要私钥的操作。所有 RRSIG 记录都可以离线计算，可能是在返回 DNSSEC 响应的服务器之外的其他服务器上。这种设计选择的初始动机是计算包含数百万条记录的区域
    RRSIG 签名的 CPU 复杂性。在 DNSSEC 的早期，这是一个操作限制。如今，这已不再是问题，但避免实时进行昂贵的签名操作有两个重要好处。首先，这降低了拒绝服务攻击的风险，因为攻击者无法迫使
    DNSSEC 服务器执行计算密集型的签名操作。其次，私钥可以离线存储，这意味着即使攻击者获得了对 DNSSEC 服务器的访问权限，也无法检索其私钥。对于 RRSIG
    记录使用离线签名有一些实际影响，这些影响反映在本记录的内容中。首先，每个 RRSIG 记录都包含所签记录的原始 TTL。当 DNS 解析器缓存记录时，它们会更改这些缓存记录的
    TTL 值，然后将修改后的记录返回给客户端。当解析器收到一个签名的 DNS 记录时，它必须在检查签名之前用原始 TTL 替换收到的 TTL（并检查收到的 TTL
    是否小于原始值）。其次，RRSIG 记录包含一个有效期，即签名的起始时间和结束时间。这个时间段仅指签名的有效期。它不影响所签记录的 TTL，并且独立于 TTL。在实践中，有效期对于允许
    DNS 服务器操作员更新他们的公钥/私钥非常重要。当这样的密钥更改时，例如，因为私钥可能已被泄露，网络中存在两个密钥签名的记录共存的一段时间。有效期确保旧签名不会永远留在
    DNS 缓存中。
- en: The last record introduced by DNSSEC is the NSEC record. It is used to authenticate
    a negative response returned by a DNS server. If a resolver requests a domain
    name that is not defined in the zone, the server replies with an error message.
    The designers of the original version of the DNS thought that these errors would
    not be very frequent and resolvers were not required to cache those negative responses.
    However, operational experience showed that queries for invalid domain names are
    more frequent than initially expected and a large fraction of the load on some
    servers is caused by repeated queries for invalid names. Typical examples include
    queries for invalid TLDs to the root DNS servers or queries caused by configuration
    errors [[WF2003]](../bibliography.html#wf2003). Current DNS deployments allow
    resolvers to cache those negative answers to reduce the load on the entire DNS
    [**RFC 2308**](https://datatracker.ietf.org/doc/html/rfc2308.html).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC 引入的最后一条记录是 NSEC 记录。它用于验证 DNS 服务器返回的负响应。如果解析器请求的区域中未定义的域名，服务器将回复错误信息。DNS
    的原始版本的设计者认为这些错误不会非常频繁，解析器不需要缓存这些负响应。然而，运营经验表明，对无效域名的查询比最初预期的更频繁，一些服务器上的大量负载是由对无效名称的重复查询造成的。典型的例子包括对根
    DNS 服务器无效顶级域名的查询或由配置错误引起的查询 [[WF2003]](../bibliography.html#wf2003)。当前的 DNS 部署允许解析器缓存这些负答案以减少整个
    DNS 的负载 [**RFC 2308**](https://datatracker.ietf.org/doc/html/rfc2308.html)。
- en: The simplest way to allow a DNSSEC server to return signed negative responses
    would be for the server to return a signed response that contains the received
    query and some information indicating the error. The client could then easily
    check the validity of the negative response. Unfortunately, this would force the
    DNSSEC server to generate signatures in real time. This implies that the private
    key must be stored in the server memory, which leads to risks if an attacker can
    take control of the server. Furthermore, those signatures are computationally
    complex and a simple denial of service attack would be to send invalid queries
    to a DNSSEC server.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 DNSSEC 服务器返回签名负响应的最简单方法是为服务器返回一个包含接收到的查询和一些指示错误的信息的签名响应。然后客户端可以轻松地检查负响应的有效性。不幸的是，这将迫使
    DNSSEC 服务器实时生成签名。这意味着私钥必须存储在服务器内存中，如果攻击者可以控制服务器，这将导致风险。此外，这些签名计算复杂，简单的拒绝服务攻击就是向
    DNSSEC 服务器发送无效查询。
- en: 'Given the above security risks, DNSSEC opted for a different approach that
    allows the negative replies to be authenticated by using offline signatures. The
    NSEC record exploits the lexicographical ordering of all the domain names. To
    understand its usage, consider a simple domain that contains three names (the
    associated AAAA and other records that are not shown) :'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述安全风险，DNSSEC 选择了不同的方法，允许使用离线签名对负回复进行验证。NSEC 记录利用了所有域名的字典顺序。为了理解其用法，考虑一个包含三个名称（未显示的关联
    AAAA 记录和其他记录）的简单域：
- en: '[PRE1]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this domain, the DNSSEC server adds three NSEC records. A RRSIG signature
    is also computed for each of these records.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在此域中，DNSSEC 服务器添加了三个 NSEC 记录。还为这些记录中的每一个计算了 RRSIG 签名。
- en: '[PRE2]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If a resolver queries delta.example.org, the server will parse its zone. If
    this name were present, it would have been placed, in lexicographical order, between
    the beta.example.org and the gamma.example.org names. To confirm that the delta.example.org
    name does not exist, the server returns the NSEC record for beta.example.org that
    indicates that the next valid name after beta.example.org is gamma.example.org.
    If the server receives a query for pi.example.org, this is the NSEC record for
    gamma.example.org that will be returned. Since this record contains a name that
    is before pi.example.org in lexicographical order, this indicates that pi.example.org
    does not exist.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析器查询 delta.example.org，服务器将解析其区域。如果该名称存在，它将在字典顺序中位于 beta.example.org 和 gamma.example.org
    名称之间。为了确认 delta.example.org 名称不存在，服务器返回 beta.example.org 的 NSEC 记录，该记录表明 beta.example.org
    之后的有效名称是 gamma.example.org。如果服务器收到对 pi.example.org 的查询，这将返回 gamma.example.org
    的 NSEC 记录。由于此记录包含一个在字典顺序中位于 pi.example.org 之前的名称，这表明 pi.example.org 不存在。
- en: Footnotes
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: Security threats[#](#security-threats "Link to this heading")
  id: totrans-739
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全威胁[#](#security-threats "链接到这个标题")
- en: When analyzing security issues in computer networks, it is useful to reason
    about the capabilities of the attacker who wants to exploit some breach in the
    security of the network. There are different types of attackers. Some have generic
    capabilities, others are specific to a given technology or network protocol. In
    this section, we discuss some important threats that a network architect must
    take into account.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析计算机网络中的安全问题，考虑想要利用网络安全漏洞的攻击者的能力是有用的。攻击者有多种类型。一些具有通用能力，而另一些则特定于某种技术或网络协议。在本节中，我们将讨论网络架构师必须考虑的一些重要威胁。
- en: The first type of attacker is called the passive attacker. A passive attacker
    is someone able to observe and usually store the information (e.g. the packets)
    exchanged in a given network or subset of it (e.g. a specific link). This attacker
    has access to all the data passing through this specific link. This is the most
    basic type of attacker and many network technologies are vulnerable to such attacks.
    In the above example, a passive attacker could easily capture the password sent
    by Alice and reuse it later to be authenticated as Alice on the remote computer.
    This is illustrated in the figure below where we do not show anymore the `DATA.req`
    and `DATA.ind` primitives but only the messages exchanged. Throughout this chapter,
    we will always use Eve as a user who is able to eavesdrop the data passing in
    front of her.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种攻击者被称为被动攻击者。被动攻击者是指能够观察并通常存储在给定网络或其子集（例如，特定链路）中交换的信息（例如，数据包）的人。此攻击者可以访问通过此特定链路的所有数据。这是最基本的攻击类型，许多网络技术都容易受到此类攻击。在上面的示例中，被动攻击者可以轻易捕获Alice发送的密码，并在稍后将其重用来在远程计算机上以Alice的身份进行身份验证。这在下图中得到了说明，我们不再显示`DATA.req`和`DATA.ind`原语，而只显示交换的消息。在本章的整个过程中，我们始终使用Eve作为能够窃听她面前通过的数据的用户。
- en: '![msc {'
  id: totrans-742
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-743
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Eve", linecolour=red],
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Eve", linecolour=red],
- en: d [label="", linecolour=white],
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: e [label="Bob", linecolour=black],
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e [label="Bob", linecolour=black],
- en: f [label="", linecolour=white];
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f [label="", linecolour=white];
- en: ''
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>e [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>e [ label = "I'm Alice\n\n", arcskip="1"];
- en: e=>f [ label = "" ];
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ];
- en: ''
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: e=>f [ label = "" ] ,
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ] ,
- en: e>>b [ label = "Password:\n\n", arcskip="1"];
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e>>b [ label = "密码:\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>e [ label = "1234xyz$\n\n", arcskip="1"];
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>e [ label = "1234xyz$\n\n", arcskip="1"];
- en: e=>f [ label = "" ];
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ];
- en: ''
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: e=>f [ label = "" ] ,
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e=>f [ label = "" ] ,
- en: e>>b [ label = "Access\n\n", arcskip="1"];
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: e>>b [ label = "访问\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/f4b5846cad3728586ed1ef7e20d24afb.png)<map id="17921862b047d560c7fe7db8be3c8ccaa1e34782"
    name="17921862b047d560c7fe7db8be3c8ccaa1e34782"></map>'
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f4b5846cad3728586ed1ef7e20d24afb.png)<map id="17921862b047d560c7fe7db8be3c8ccaa1e34782"
    name="17921862b047d560c7fe7db8be3c8ccaa1e34782"></map>'
- en: In the above example, Eve can capture all the packets exchanged by Bob and Alice.
    This implies that Eve can discover Alice’s username and Alice’s password. With
    this information, Eve can then authenticate as Alice on Bob’s computer and do
    whatever Alice is authorized to do. This is a major problem from a security point
    of view. To prevent this attack, Alice should never send her password in clear
    over a network where someone could eavesdrop the information. In some networks,
    such as an open wireless network, an attacker can easily collect all the data
    sent by a particular user. In other networks, this is a bit more complex depending
    on the network technology used, but various software packages exist to automate
    this process. As will be described later, the best approach to prevent this type
    of attack is to rely on cryptographic techniques to ensure that passwords are
    never sent in clear.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，Eve可以捕获Bob和Alice之间交换的所有数据包。这意味着Eve可以发现Alice的用户名和密码。有了这些信息，Eve可以随后在Bob的计算机上以Alice的身份进行身份验证，并执行Alice被授权执行的所有操作。这是一个重大的安全问题。为了防止这种攻击，Alice永远不应该在网络中发送她的密码，因为有人可能会窃听信息。在一些网络中，例如开放的无线网络，攻击者可以轻易收集特定用户发送的所有数据。在其他网络中，这要复杂一些，具体取决于所使用的网络技术，但存在各种软件包来自动化此过程。正如稍后所述，防止此类攻击的最佳方法是依靠加密技术，以确保密码永远不会以明文形式发送。
- en: Note
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Pervasive monitoring
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍监控
- en: In the previous example, we have explained how Eve could capture data from a
    particular user. This is not the only attack of this type. In 2013, based on documents
    collected by Edward Snowden, the press revealed that several governmental agencies
    were collecting lots of data on various links that compose the global Internet
    [[Greenwald2014]](../bibliography.html#greenwald2014). Thanks to this massive
    amount of data, these governmental agencies have been able to extract lots of
    information about the behavior of Internet users. Like Eve, they are in a position
    to extract passwords, usernames and other privacy sensitive data from all the
    packets that they have captured. However, it seems that these agencies were often
    more interested in various meta data, e.g. information showing with whom a given
    user communicates than the actual data exchanged. These revelations have shocked
    the Internet community and the [Internet Engineering Task Force](https://www.ietf.org)
    that manages the standardization of Internet protocols has declared in [**RFC
    7258**](https://datatracker.ietf.org/doc/html/rfc7258.html) that such pervasive
    monitoring is an attack that need to be countered in the development of new protocols.
    Several new protocols and extensions to existing ones are being developed to counter
    these attacks.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们解释了Eve如何捕获特定用户的数据。这并不是这种类型攻击的唯一例子。2013年，基于爱德华·斯诺登收集的文件，媒体揭露了几家政府机构正在收集全球互联网构成的各种链接的大量数据
    [[Greenwald2014]](../bibliography.html#greenwald2014)。得益于这大量数据，这些政府机构能够提取大量关于互联网用户行为的信息。像Eve一样，他们处于从他们捕获的所有数据包中提取密码、用户名和其他隐私敏感数据的位置。然而，似乎这些机构对各种元数据更感兴趣，例如显示特定用户与谁交流的信息，而不是实际交换的数据。这些揭露震惊了互联网社区，负责管理互联网协议标准化的[互联网工程任务组](https://www.ietf.org)在[**RFC
    7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)中宣布，这种普遍监控是一种需要在新协议开发中反击的攻击。正在开发几种新的协议和对现有协议的扩展来反击这些攻击。
- en: Eavesdropping and pervasive monitoring are not the only possible attacks against
    a network. Another type of attacker is the active attacker. In the literature,
    these attacks are often called Man in the middle or MITM attacks. Such attacks
    occur when one user, let us call him Mallory, has managed to configure the network
    so that he can both capture and modify the packets exchanged by two users. The
    simplest scenario is when Mallory controls a router that is on the path used by
    both Alice and Bob. For example, Alice could be connected to a WiFi access router
    controlled by Mallory and Bob would be a regular server on the Internet.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 窃听和普遍监控并不是针对网络的唯一可能攻击。另一种攻击者是主动攻击者。在文献中，这些攻击通常被称为中间人攻击或MITM攻击。这种攻击发生在一位用户，让我们称他为Mallory，成功配置了网络，使他能够捕获和修改两个用户之间交换的数据包。最简单的场景是当Mallory控制了一个Alice和Bob都使用的路由器。例如，Alice可能连接到由Mallory控制的WiFi接入路由器，而Bob则是一个互联网上的普通服务器。
- en: '![Figure made with TikZ](../Images/c7ceeff3d8a02de071eac1377ed85bc7.png)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c7ceeff3d8a02de071eac1377ed85bc7.png)'
- en: As Mallory receives all the packets sent by both Bob and Alice, he can modify
    them at will. For example, he could modify the commands sent by Alice to the server
    managed by Bob and change the responses sent by the server. This type of attack
    is very powerful and sometimes difficult to counter without relying on advanced
    cryptographic techniques.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Mallory接收了Bob和Alice发送的所有数据包，他可以随意修改它们。例如，他可以修改Alice发送给Bob管理的服务器的命令，并更改服务器发送的响应。这种攻击非常强大，有时在没有依赖高级加密技术的情况下很难反击。
- en: The last type of attack that we consider in this introduction are the Denial
    of Service or DoS attacks. During such an attack, the attacker generates enough
    packets to saturate a given service and prevent it from operating correctly. The
    simplest Denial of Service attack is to send more packets that the bandwidth of
    the link that attaches the target to the network. The target could be a single
    server, a company or even an entire country. If these packets all come from the
    same source, then the victim can identify the attacker and contact the law enforcement
    authorities. In practice, such denial of service attacks do not originate from
    a single source. The attacker usually compromises a (possibly very large) set
    of sources and forces them to send packets to saturate a given target. Since the
    attacking traffic comes from a wide range of sources, it is difficult for the
    victim to locate the culprit and also to counter the attack. Saturating a link
    is the simplest example of Distributed Denial of Service (DDoS) attacks.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍中，我们考虑的最后一种攻击类型是拒绝服务或DoS攻击。在此类攻击期间，攻击者生成足够的数据包来饱和特定服务并阻止其正确运行。最简单的拒绝服务攻击是发送比连接到网络的目标的链路带宽更多的数据包。目标可能是一台服务器、一家公司，甚至是一个整个国家。如果这些数据包都来自同一个来源，那么受害者可以识别攻击者并联系执法机构。实际上，这种拒绝服务攻击并非来自单一来源。攻击者通常破坏（可能非常大）的一组来源，并迫使它们向特定目标发送数据包以饱和。由于攻击流量来自广泛的来源，受害者很难定位肇事者，也难以对抗攻击。饱和链路是分布式拒绝服务（DDoS）攻击的最简单例子。
- en: In practice, there is a possibility of denial of service attacks as soon as
    there is a limited resource somewhere in the network. This resource can be the
    bandwidth of a link, but it could also be the computational power of a server,
    its memory or even the size of tables used by a given protocol implementation.
    Defending against real DoS attacks can be difficult, especially if the attacker
    controls a large number of sources that are used to launch the attacks. In terms
    of bandwidth, DoS attacks composed of a few Gbps to a few tens of Gbps of traffic
    are frequent on the Internet. In 2015, [github.com](http://www.github.com) suffered
    from a distributed DoS that reached a top bandwidth of 400 Gbps according to some
    [reports](http://www.techworld.com/news/security/worlds-largest-ddos-attack-reached-400gbps-says-arbor-networks-3595715/).
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，一旦网络中某个地方资源有限，就可能出现拒绝服务攻击。这种资源可以是链路的带宽，但也可能是服务器的计算能力、内存，甚至是特定协议实现所使用的表的大小。防御真正的DoS攻击可能很困难，尤其是如果攻击者控制了用于发起攻击的大量来源。从带宽的角度来看，由几Gbps到几十Gbps流量组成的DoS攻击在互联网上很常见。2015年，[github.com](http://www.github.com)据一些[报道](http://www.techworld.com/news/security/worlds-largest-ddos-attack-reached-400gbps-says-arbor-networks-3595715/)遭受了一次分布式DoS攻击，峰值带宽达到了400
    Gbps。
- en: When designing network protocols and applications that will be deployed on a
    large scale, it is important to take those DDoS attacks into account. Attackers
    use different strategies to launch DDoS attacks. Some have managed to gain control
    of a large number of sources by injecting malware on them. Others, and this is
    where protocol designers have an important role to play, simply exploit design
    flaws in some protocols. Consider a simple request-response protocol where the
    client sends a request and the server replies with a response. Often the response
    is larger or much larger than the request sent by the client. Consider that such
    a simple protocol is used over a datagram network. When Alice sends a datagram
    to Bob containing her request, Bob extracts both the request and Alice’s address
    from the packet. He then sends his response in a single packet destined to Alice.
    Mallory would like to create a DoS attack against Alice without being identified.
    Since he has studied the specification of this protocol, he can send a request
    to Bob inside a packet having Alice’s address as its source address. Bob will
    process the request and send his (large) response to Alice. If the response has
    the same size as the request, Mallory is producing a reflection attack since his
    packets are reflected by Bob. Alice would think that she is attacked by Bob. If
    there are many servers that operate the same service as Bob, Mallory could hide
    behind a large number of such reflectors. Unfortunately, the reflection attack
    can also become an amplification attack. This happens when the response sent by
    Bob is larger than the request that it has received. If the response is \(k\)
    times larger than the request, then when Mallory consumes 1 Gbps of bandwidth
    to send requests, his victim receives \(k\) Gbps of attack traffic. Such amplification
    attacks are a very important problem and protocol designers should ensure that
    they never send a large response before having received the proof that the request
    that they have received originated from the source indicated in the request.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计将在大规模上部署的网络协议和应用时，考虑那些DDoS攻击是很重要的。攻击者使用不同的策略来发起DDoS攻击。有些人通过在这些源上注入恶意软件，成功控制了大量源。其他人，这也是协议设计者扮演重要角色的地方，只是利用某些协议的设计缺陷。考虑一个简单的请求-响应协议，其中客户端发送请求，服务器用响应来回复。通常，响应的大小大于或远大于客户端发送的请求。考虑这样一个简单的协议是在数据报网络中使用的。当Alice向Bob发送包含她的请求的数据报时，Bob从数据包中提取出请求和Alice的地址。然后他发送一个单独的数据包，这个数据包的目的地是Alice，以发送他的响应。Mallory想要对Alice发起DoS攻击而不被识别。由于他已经研究了该协议的规范，他可以在一个数据包中向Bob发送一个请求，这个数据包的源地址是Alice的地址。Bob将处理这个请求，并将他的（大）响应发送给Alice。如果响应的大小与请求相同，Mallory正在产生一个反射攻击，因为他的数据包被Bob反射。Alice会认为她被Bob攻击了。如果有许多服务器运行与Bob相同的服务，Mallory可以隐藏在大量这样的反射器后面。不幸的是，反射攻击也可以变成放大攻击。这种情况发生在Bob发送的响应比它接收到的请求更大的情况下。如果响应是请求的\(k\)倍大，那么当Mallory消耗1
    Gbps的带宽来发送请求时，他的受害者会接收到\(k\) Gbps的攻击流量。这种放大攻击是一个非常重要的问题，协议设计者应该确保在收到请求的来源证明之前，他们永远不会发送一个大的响应。
- en: Cryptographic primitives[#](#cryptographic-primitives "Link to this heading")
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码学原语[#](#cryptographic-primitives "链接到这个标题")
- en: Cryptography techniques have initially been defined and used by spies and armies
    to exchange secret information in manner that ensures that adversaries cannot
    decode the information even if they capture the message or the person carrying
    the message. A wide range of techniques have been defined. The first techniques
    relied on their secrecy to operate. One of the first encryption schemes is attributed
    to Julius Caesar. When he sent confidential information to his generals, he would
    encode each message by replacing each letter with another letter that is \(n\)
    positions after this letter in the alphabet. For example, the message SECRET becomes
    VHFUHW when encoded using Caesar’s cipher. This technique could have puzzled some
    soldiers during Caesar’s wars, but today even young kids can recover the original
    message from the ciphered one.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 密码技术最初是由间谍和军队定义和使用的，以交换确保对手无法解码信息的方式。已经定义了广泛的技术。最初的技术依赖于它们的保密性来运行。最早的加密方案之一归功于尤利乌斯·凯撒。当他向他的将军们发送机密信息时，他会通过将每个字母替换为字母表中该字母后面的
    \(n\) 个位置的字母来编码每条消息。例如，使用凯撒密码编码的消息 SECRET 变成 VHFUHW。这种技术在凯撒的战争中可能会让一些士兵感到困惑，但今天即使是小孩子也能从加密的消息中恢复原始信息。
- en: 'The security of the Caesar cipher depends on the confidentiality of the algorithm,
    but experience has shown that it is impossible to assume that an algorithm will
    remain secret, even for military applications. Instead, cryptographic techniques
    must be designed by assuming that the algorithm will be public and known to anyone.
    However, its behavior must be controlled by a small parameter, known as the key,
    that will only be known by the users who need to communicate secretly. This principle
    is attributed to Auguste Kerckhoff, a French cryptographer who first documented
    it :'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码的安全性依赖于算法的保密性，但经验表明，即使对于军事应用，也不可能假设一个算法会保持秘密。相反，必须设计加密技术，假设算法将是公开的，并且任何人都能知道。然而，其行为必须由一个称为密钥的小参数控制，只有需要秘密通信的用户才知道。这一原则归功于法国密码学家奥古斯特·Kerckhoff，他首次记录了这一原则：
- en: A cryptographic algorithm should be secure even if the attacker knows everything
    about the system, except one parameter known as the secret key.
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使攻击者知道系统的一切，除了称为密钥的一个参数外，密码算法也应该是安全的。
- en: This principle is important because it remains the basic assumption of all cryptographers.
    Any system that relies on the secrecy of its algorithm to be considered secure
    is doomed to fail and be broken one day.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则很重要，因为它仍然是所有密码学家的基本假设。任何依赖于其算法保密性来被认为是安全的系统注定会失败，并最终被破解。
- en: With the Kerckhoff principle, we can now discuss a simple but powerful encryption
    scheme that relies on the XOR logic operation. This operation is easily implemented
    in hardware and is supported by all microprocessors. Given a secret, \(K\), it
    is possible to encode a message M by computing \(C_M = K \oplus M\). The receiver
    of this messages can recover the original message as since \(M = K \oplus (K \oplus
    M)\). This XOR operation is the key operation of the perfect cipher that is also
    called the Vernam cipher or the one-time pad. This cipher relies on a key that
    contains purely random bits. The encrypted message is then produced by XORing
    all the bits of the message with all the bits of the key. Since the key is random,
    it is impossible for an attacker to recover the original text (or plain text)
    from the encrypted one. From a security viewpoint, the one-time-pad is the best
    solution provided that the key is as long as the message.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Kerckhoff 原则，我们现在可以讨论一个简单但强大的加密方案，该方案依赖于 XOR 逻辑运算。这种运算在硬件中很容易实现，并且所有微处理器都支持它。给定一个密钥
    \(K\)，可以通过计算 \(C_M = K \oplus M\) 来编码消息 M。接收者可以通过 \(M = K \oplus (K \oplus M)\)
    恢复原始消息。这种 XOR 运算是完美密码（也称为 Vernam 密码或一次性密码）的关键操作。这种密码依赖于一个只包含纯随机位的密钥。加密消息是通过将消息的所有位与密钥的所有位进行
    XOR 运算产生的。由于密钥是随机的，攻击者无法从加密的消息中恢复原始文本（或明文）。从安全角度来看，只要密钥的长度与消息相同，一次性密码就是最佳解决方案。
- en: Unfortunately, it is difficult to use this cipher in practice since the key
    must be as long as the message that needs to be transmitted. If the key is smaller
    than the message and the message is divided into blocks that have the same length
    as the key, then the scheme becomes less secure since the same key is used to
    decrypt different parts of the message. In practice, XOR is often one of the basic
    operations used by encryption schemes. To be usable, the deployed encryption schemes
    use keys that are composed of a small number of bits, typically 56, 64, 128, 256,
    …
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在实际中很难使用这种密码，因为密钥必须与需要传输的消息一样长。如果密钥小于消息，并且消息被分成与密钥长度相同的块，那么该方案的安全性会降低，因为相同的密钥用于解密消息的不同部分。在实践中，XOR通常是加密方案中使用的基本操作之一。为了可用，部署的加密方案使用由少量位组成的密钥，通常是56位、64位、128位、256位……
- en: 'A secret key encryption scheme is a perfectly reversible functions, i.e. given
    an encryption function E, there is an associated decryption function D such that
    \(\forall K, \forall M : D(K, E(K,M))=M\).'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '秘密密钥加密方案是一个完全可逆的函数，即给定一个加密函数E，存在一个相关的解密函数D，使得\(\forall K, \forall M : D(K,
    E(K,M))=M\)。'
- en: 'Various secret key cryptographic functions have been proposed, implemented
    and deployed. The most popular ones are :'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了各种秘密密钥密码函数，并已实施和部署。其中最流行的是：
- en: DES, the Data Encryption Standard that became a standard in 1977 and has been
    widely used by industry. It uses 56 bits keys that are not considered sufficiently
    secure nowadays since attackers can launch brute-force attacks by testing all
    possible keys. Triple DES combines three 56 bits keys, making the brute force
    attacks more difficult.
  id: totrans-786
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES，即数据加密标准，于1977年成为标准，并被工业界广泛使用。它使用56位密钥，现在被认为不够安全，因为攻击者可以通过测试所有可能的密钥来发起暴力攻击。三重DES结合了三个56位密钥，使得暴力攻击更加困难。
- en: ''
  id: totrans-787
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-788
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RC4 is an encryption scheme defined in the late 1980s by Ron Rivest for RSA
    Security. Given the speed of its software implementation, it has been included
    in various protocols and implementations. However, cryptographers have identified
    several weaknesses in this algorithm. It is now deprecated and should not be used
    anymore [**RFC 7465**](https://datatracker.ietf.org/doc/html/rfc7465.html).
  id: totrans-789
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC4是一种在20世纪80年代末由Ron Rivest为RSA安全公司定义的加密方案。鉴于其软件实现的快速性，它已被包含在各种协议和实现中。然而，密码学家已经发现了该算法的几个弱点。现在它已被弃用，不应再使用[**RFC
    7465**](https://datatracker.ietf.org/doc/html/rfc7465.html)。
- en: ''
  id: totrans-790
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-791
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: AES or the Advanced Encryption Standard is an encryption scheme that was designed
    by the Belgian cryptographers Joan Daemen and Vincent Rijmen in 2001 [[DR2002]](../bibliography.html#dr2002).
    This algorithm has been standardized by the U.S. National Institute of Standards
    and Technology (NIST). It is now used by a wide range of applications and various
    hardware and software implementations exist. Many microprocessors include special
    instructions that ease the implementation of AES. AES divides the message to be
    encrypted in blocks of 128 bits and uses keys of length 128, 192 or 256 bits.
    The block size and the key length are important parameters of an encryption scheme.
    The block size indicates the smallest message that can be encrypted and forces
    the sender to divide each message in blocks of the supported size. If the message
    is larger than an integer number of blocks, then the message must be padded before
    being encrypted and this padding must be removed after decryption. The key size
    indicates the resistance of the encryption scheme against brute force attacks,
    i.e. attacks where the attacker tries all possible keys to find the correct one.
  id: totrans-792
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES或高级加密标准是由比利时密码学家Joan Daemen和Vincent Rijmen于2001年设计的加密方案[[DR2002]](../bibliography.html#dr2002)。该算法已被美国国家标准与技术研究院（NIST）标准化。现在它被广泛应用于各种应用和硬件及软件实现中。许多微处理器包括专门的指令，以简化AES的实现。AES将待加密的消息分成128位的块，并使用长度为128位、192位或256位的密钥。块大小和密钥长度是加密方案的重要参数。块大小表示可以加密的最小消息，并迫使发送者将每条消息分成支持大小的块。如果消息大于整数个块，则必须在加密之前对消息进行填充，并且在解密后必须移除此填充。密钥大小表示加密方案对暴力攻击的抵抗力，即攻击者尝试所有可能的密钥以找到正确密钥的攻击。
- en: AES is widely used as of this writing, but other secret key encryption schemes
    continue to appear. ChaCha20, proposed by D. Bernstein is now used by several
    internet protocols [**RFC 7539**](https://datatracker.ietf.org/doc/html/rfc7539.html).
    A detailed discussion of encryption schemes is outside the scope of this book.
    We will consider encryption schemes as black boxes whose operation depends on
    a single key. A detailed overview of several of these schemes may be found in
    [[MVV2011]](../bibliography.html#mvv2011).
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，AES被广泛使用，但其他对称密钥加密方案仍在出现。ChaCha20，由D.伯恩斯坦提出，现在被几个互联网协议使用[**RFC 7539**](https://datatracker.ietf.org/doc/html/rfc7539.html)。关于加密方案的详细讨论超出了本书的范围。我们将考虑加密方案作为黑盒，其操作依赖于单个密钥。关于这些方案中的几个的详细概述可以在[[MVV2011]](../bibliography.html#mvv2011)中找到。
- en: 'In the 1970s, Diffie and Hellman proposed in their seminal paper [[DH1976]](../bibliography.html#dh1976),
    a different type of encryption : public key cryptography. In public key cryptography,
    each user has two different keys :'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代，迪菲和赫尔曼在他们开创性的论文[[DH1976]](../bibliography.html#dh1976)中提出了一种不同类型的加密：公钥密码学。在公钥密码学中，每个用户都有两个不同的密钥：
- en: a public key (\(K_{pub}\)) that he can distribute to everyone
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥（\(K_{pub}\)），他可以向每个人分发
- en: ''
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a private key (\(K_{priv}\)) that he needs to store in a secure manner and never
    reveal to anyone
  id: totrans-798
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私钥（\(K_{priv}\)），他需要以安全的方式存储，并且永远不向任何人透露
- en: These two keys are generated together and they are linked by a complex mathematical
    relationship that is such that it is computationally difficult to compute \(K_{priv}\)
    from \(K_{pub}\).
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个密钥一起生成，并且它们通过一个复杂的数学关系相互关联，这种关系使得从 \(K_{pub}\) 计算出 \(K_{priv}\) 是计算上困难的。
- en: 'A public key cryptographic scheme is a combination of two functions :'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学方案是两个函数的组合：
- en: an encryption function, \(E_{p}\), that takes a key and a message as parameters
  id: totrans-801
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个加密函数，\(E_{p}\)，它接受密钥和消息作为参数
- en: ''
  id: totrans-802
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a decryption function, \(D_{p}\), that takes a key and a message as parameters
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解密函数，\(D_{p}\)，它接受密钥和消息作为参数
- en: 'The public key is used to encrypt a message so that it can only be read by
    the intended recipient. For example, let us consider two users : Alice and Bob.
    Alice (resp. Bob) uses the keys \(A_{priv}\) and \(A_{pub}\) (resp. \(B_{priv}\)
    and \(B_{pub}\)). To send a secure message M to Alice, Bob computes \(CM=E_p(A_{pub},M)\)
    and Alice can decrypt it by using \(D_p(A_{priv},CM)=D_p(A_{priv},E_p(A_{pub},M))=M\).'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥用于加密消息，以便只有预期的接收者才能阅读。例如，让我们考虑两个用户：爱丽丝和鲍勃。爱丽丝（分别鲍勃）使用密钥 \(A_{priv}\) 和 \(A_{pub}\)（分别
    \(B_{priv}\) 和 \(B_{pub}\)）。为了向爱丽丝发送安全消息M，鲍勃计算 \(CM=E_p(A_{pub},M)\)，而爱丽丝可以通过使用
    \(D_p(A_{priv},CM)=D_p(A_{priv},E_p(A_{pub},M))=M\) 来解密它。
- en: 'Several public key encryption schemes have been proposed. Two of them have
    reached wide deployment :'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了几种公钥加密方案。其中两种已经得到广泛部署：
- en: The Rivest Shamir Adleman (RSA) algorithm [[2]](#frsa) proposed in [[RSA1978]](../bibliography.html#rsa1978)
    that relies on modular exponentiation with large integers.
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rivest Shamir Adleman (RSA) 算法[[2]](#frsa)在[[RSA1978]](../bibliography.html#rsa1978)中提出，该算法依赖于大整数的模幂运算。
- en: ''
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-809
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The Elliptic Curve Cryptography techniques [[3]](#fecc) that rely on special
    properties of elliptic curves.
  id: totrans-810
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于椭圆曲线特殊性质的椭圆曲线密码学技术[[3]](#fecc)。
- en: Another interesting property of public key cryptography is its ability to compute
    signatures that can be used to authenticate a message. This capability comes from
    the utilization of two different keys that are linked together. If Alice wants
    to sign a message M, she can compute \(SM=E_p(A_{priv},M)\). Anyone who receives
    this signed messaged can extract its content as \(D_p(A_{pub},SM)=D_p(A_{pub},E_p(A_{priv},M))=M\).
    Everyone can use \(A_{pub}\) to check that the message was signed by using Alice’s
    private key (\(A_{priv}\)). Since this key is only known by Alice, the ability
    to decrypt SM is a proof that the message was signed by Alice herself.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学另一个有趣的特性是其能够计算用于验证消息的签名。这种能力来自于使用两个相互关联的不同密钥。如果爱丽丝想要对消息M进行签名，她可以计算 \(SM=E_p(A_{priv},M)\)。任何收到这个已签名消息的人都可以提取其内容，即
    \(D_p(A_{pub},SM)=D_p(A_{pub},E_p(A_{priv},M))=M\)。每个人都可以使用 \(A_{pub}\) 来检查消息是否由爱丽丝的私钥（\(A_{priv}\)）签名。由于这个密钥只有爱丽丝知道，能够解密SM的能力就是消息由爱丽丝本人签名的证明。
- en: In practice, encrypting a message to sign it can be computationally costly,
    in particular if the message is a large file. A faster solution would be to summarize
    the document and only sign the summary of the document. A naive approach could
    be based on a checksum or CRC computed over the message. Alice would then compute
    \(C=Checksum(M)\) and \(SC=E_p(A_{priv},C)\). She would then send both M and SC
    to the recipient of the message who can easily compute C from SC and verify the
    authenticity of the message. Unfortunately, this solution does not protect Alice
    and the message’s recipient against a man-in-the-middle attack. If Mallory can
    intercept the message sent by Alice, he can easily modify Alice’s message and
    tweak it so that it has the same checksum as the original one. The CRCs, although
    more complex to compute, suffer from the same problem.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，为了签名而加密一条消息可能会造成计算上的开销，尤其是如果消息是一个大文件。一个更快的解决方案是对文档进行总结，并仅对文档的总结进行签名。一个简单的方法可能是基于对消息计算校验和或
    CRC。Alice 会计算 \(C=Checksum(M)\) 和 \(SC=E_p(A_{priv},C)\)。然后她会将 M 和 SC 发送给消息的接收者，接收者可以轻松地从
    SC 计算出 C 并验证消息的真实性。不幸的是，这个解决方案并不能保护 Alice 和消息接收者免受中间人攻击。如果 Mallory 可以拦截 Alice
    发送的消息，他可以轻松地修改 Alice 的消息，并调整它使其具有与原始消息相同的校验和。CRC 虽然计算起来更复杂，但存在同样的问题。
- en: 'To efficiently sign messages, Alice needs to be able to compute a summary of
    her message in a way that makes prohibits an attacker from generating a different
    message that has the same summary. Cryptographic hash functions were designed
    to solve this problem. The ideal hash function is a function that returns a different
    number for every possible input. In practice, it is impossible to find such a
    function. Cryptographic hash functions are an approximation of this perfect summarization
    function. They compute a summary of a given message in 128, 160, 256 bits or more.
    They also exhibit the avalanche effect. This effect indicates that a small change
    in the message causes a large change in the hash value. Finally hash functions
    are very difficult to invert. Knowing a hash value, it is computationally very
    difficult to find the corresponding input message. Several hash functions have
    been proposed by cryptographers. The most popular ones are :'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地签名消息，Alice 需要能够以阻止攻击者生成具有相同摘要的不同消息的方式计算她消息的摘要。加密哈希函数被设计来解决这个问题。理想的哈希函数是对于每个可能的输入都返回不同数字的函数。在实践中，找到这样的函数是不可能的。加密哈希函数是这个完美摘要函数的近似。它们以
    128 位、160 位、256 位或更多位计算给定消息的摘要。它们还表现出雪崩效应。这种效应表明，消息中的微小变化会导致哈希值的大幅变化。最后，哈希函数非常难以逆向。知道哈希值，在计算上很难找到相应的输入消息。密码学家们提出了几种哈希函数。最受欢迎的包括：
- en: MD5, originally proposed in [**RFC 1321**](https://datatracker.ietf.org/doc/html/rfc1321.html).
    It has been used in a wide range of applications. In 2010, attacks against MD5
    were published and this hash function is now deprecated.
  id: totrans-814
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: MD5 是最初在 [**RFC 1321**](https://datatracker.ietf.org/doc/html/rfc1321.html)
    中提出的。它被广泛应用于各种应用中。2010 年，针对 MD5 的攻击被公布，这个哈希函数现在已被弃用。
- en: ''
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-816
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SHA-1 is a cryptographic hash function that was standardized by the NIST in
    1995\. It outputs 160 bits results. It is now used in a variety of network protocols.
  id: totrans-817
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA-1 是一种由 NIST 在 1995 年标准化的加密哈希函数。它输出 160 位的结果。它现在被用于各种网络协议中。
- en: ''
  id: totrans-818
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: SHA-2 is another family of cryptographic hash functions designed by the NIST.
    Different variants of SHA-2 can produce has values of 224, 256, 384 or 512 bits.
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: SHA-2 是由 NIST 设计的另一系列加密哈希函数。SHA-2 的不同变体可以生成 224 位、256 位、384 位或 512 位的哈希值。
- en: Another important point about cryptographic algorithms is that often these algorithms
    require random numbers to operate correctly (e.g. to generate keys). Generating
    good random numbers is difficult and any implementation of cryptographic algorithms
    should also include a secure random number generator. [**RFC 4086**](https://datatracker.ietf.org/doc/html/rfc4086.html)
    provides useful recommendations.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加密算法的另一个重要点是，这些算法通常需要随机数来正确运行（例如，生成密钥）。生成好的随机数是困难的，任何加密算法的实现都应该包括一个安全的随机数生成器。[**RFC
    4086**](https://datatracker.ietf.org/doc/html/rfc4086.html) 提供了有用的建议。
- en: Cryptographic protocols[#](#cryptographic-protocols "Link to this heading")
  id: totrans-822
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密协议[#](#cryptographic-protocols "链接到这个标题")
- en: We can now combine the cryptographic operations described in the previous section
    to build some protocols to securely exchange information. Let us first go back
    to the problem of authenticating Alice on Bob’s computer. We have shown earlier
    that using a simple password for this purpose is insecure in the presence of attackers.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将上一节中描述的加密操作组合起来，构建一些安全交换信息的协议。让我们首先回到在鲍勃的计算机上验证爱丽丝身份的问题。我们之前已经表明，在攻击者存在的情况下，使用简单的密码进行此目的是不安全的。
- en: A naive approach would be to rely on hash functions. Since hash functions are
    non-invertible, Alice and Bob could decide to use them to exchange Alice’s password
    in a secure manner. Then, Alice could be authenticated by using the following
    exchange.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是依赖于哈希函数。由于哈希函数是不可逆的，爱丽丝和鲍勃可以决定使用它们以安全的方式交换爱丽丝的密码。然后，爱丽丝可以通过以下交换进行身份验证。
- en: '![msc {'
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="爱丽丝", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="鲍勃", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "我是爱丽丝\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Prove it\n\n", arcskip="1"];
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "证明它\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "Hash(passwd)\n\n", arcskip="1"];
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Hash(passwd)\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Access granted\n\n", arcskip="1"];
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "访问允许\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/8ce774d886954a61fe3332c085b81a4f.png)<map id="e9d4cd4a36e66a6415dde6e83ecc95535122af78"
    name="e9d4cd4a36e66a6415dde6e83ecc95535122af78"></map>'
  id: totrans-847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/8ce774d886954a61fe3332c085b81a4f.png)<map id="e9d4cd4a36e66a6415dde6e83ecc95535122af78"
    name="e9d4cd4a36e66a6415dde6e83ecc95535122af78"></map>'
- en: Since the hash function cannot be inverted, an eavesdropper cannot extract Alice’s
    password by simply observing the data exchanged. However, Alice’s real password
    is not the objective of an attacker. The main objective for Mallory is to be authenticated
    as Alice. If Mallory can capture Hash(passwd), he can simply replay this data,
    without being able to invert the hash function. This is called a replay attack.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希函数不可逆，窃听者不能仅通过观察交换的数据来提取爱丽丝的密码。然而，攻击者的主要目标并不是爱丽丝的真实密码。马洛里（Mallory）的主要目标是验证自己为爱丽丝。如果马洛里能够捕获Hash(passwd)，他可以简单地重放这些数据，而无需能够逆推哈希函数。这被称为重放攻击。
- en: To counter this replay attack, we need to ensure that Alice never sends the
    same information twice to Bob. A possible mode of operation is shown below.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗这种重放攻击，我们需要确保爱丽丝永远不会向鲍勃发送相同的信息两次。下面是一种可能的操作模式。
- en: '![msc {'
  id: totrans-850
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="爱丽丝", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="鲍勃", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ，
- en: c>>b [ label = "Challenge:764192\n\n", arcskip="1"];
  id: totrans-862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "挑战:764192\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "Hash(764192||passwd)\n\n", arcskip="1"];
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Hash(764192||passwd)\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-867
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-868
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-869
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Access\n\n", arcskip="1"];
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "访问\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/d68b2f1363c49e52d5bce558f315b1ad.png)<map id="20f577439fc03098f4163306e3e3d06fd0e01a3f"
    name="20f577439fc03098f4163306e3e3d06fd0e01a3f"></map>'
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d68b2f1363c49e52d5bce558f315b1ad.png)<map id="20f577439fc03098f4163306e3e3d06fd0e01a3f"
    name="20f577439fc03098f4163306e3e3d06fd0e01a3f"></map>'
- en: To authenticate herself, Alice sends her user identifier to Bob. Bob replies
    with a random number as a challenge to verify that Alice knows the shared secret
    (i.e. her password). Alice replies with the result of the computation of a hash
    function (e.g. SHA-1) over a string that is the concatenation between the random
    number chosen by Bob and Alice’s password. The random number chosen by Bob is
    often called a nonce since this is a number that should only be used once. Bob
    performs the same computation locally and can check the message returned by Alice.
    This type of authentication scheme has been used in various protocols. It prevents
    replay attacks. If Eve captures the messages exchanged by Alice and Bob, she cannot
    recover Alice’s password from the messages exchanged since hash functions are
    non-invertible. Furthermore, she cannot replay the hashed value since Bob will
    always send a different nonce.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证自己的身份，爱丽丝将她的用户标识发送给鲍勃。鲍勃回复一个随机数作为挑战，以验证爱丽丝知道共享的秘密（即她的密码）。爱丽丝回复一个哈希函数（例如SHA-1）的计算结果，该计算结果是对一个字符串的哈希，该字符串是鲍勃选择的随机数和爱丽丝的密码的连接。鲍勃选择的随机数通常被称为nonce，因为这个数字应该只使用一次。鲍勃在本地执行相同的计算并可以检查爱丽丝返回的消息。这种认证方案已在各种协议中使用。它防止重放攻击。如果伊芙捕获了爱丽丝和鲍勃之间交换的消息，由于哈希函数是不可逆的，她不能从交换的消息中恢复爱丽丝的密码。此外，她不能重放哈希值，因为鲍勃总是会发送一个不同的nonce。
- en: Unfortunately, this solution forces Bob to store Alice’s password in clear.
    Any breach in the security of Bob’s computer would reveal Alice’s password. Such
    breaches unfortunately occur and some of them have led to the dissemination of
    millions of passwords.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个解决方案迫使鲍勃以明文形式存储爱丽丝的密码。鲍勃电脑的安全遭到任何破坏都会泄露爱丽丝的密码。不幸的是，这种情况确实发生了，其中一些事件导致了数百万个密码的泄露。
- en: 'A better approach would be to authenticate Alice without storing her password
    in clear on Bob’s computer. For this, Alice computes a hash chain as proposed
    by Lamport in [[Lamport1981]](../bibliography.html#lamport1981). A hash chain
    is a sequence of applications of a hash function (H) on an input string. If Alice’s
    password is P, then her 10 steps hash chain is : \(H(H(H(H(H(H(H(H(H(H(P))))))))))\).
    The result of this hash chain will be stored on Bob’s computer together with the
    value 10. This number is the maximum number of remaining authentications for Alice
    on Bob’s computer. To authenticate Alice, Bob sends the remaining number of authentications,
    i.e. 10 in this example. Since Alice knows her password, P, she can compute \(H^9(P)=H(H(H(H(H(H(H(H(H(P)))))))))\)
    and send this information to Bob. Bob computes the hash of the value received
    from Alice (\(H(H^9(P))\)) and verifies that this value is equal to the value
    stored in his database. It then decrements the number of authorized authentications
    and stores \(H^9(P)\) in his database. Bob is now ready for the next authentication
    of Alice. When the number of authorized authentications reaches zero, the hash
    chain needs to be reinitialized. If Eve captures \((H^n(P))\), she cannot use
    it to authenticate herself as Alice on Bob’s computer because Bob will have decremented
    its number of authorized authentications. Furthermore, given that hash functions
    are not invertible, Eve cannot compute \(H^{n-1}(P)\) from \(H^{n}(P)\).'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是在不将爱丽丝的密码以明文形式存储在鲍勃的电脑上的情况下验证爱丽丝的身份。为此，爱丽丝计算了一个哈希链，这是Lamport在[[Lamport1981]](../bibliography.html#lamport1981)中提出的。哈希链是对输入字符串应用哈希函数（H）的序列。如果爱丽丝的密码是P，那么她的10步哈希链是：\(H(H(H(H(H(H(H(H(H(H(P))))))))))\)。这个哈希链的结果将存储在鲍勃的电脑上，同时存储的值是10。这个数字是爱丽丝在鲍勃电脑上剩余的最大认证次数。为了验证爱丽丝的身份，鲍勃发送剩余的认证次数，即在这个例子中是10。由于爱丽丝知道她的密码P，她可以计算\(H^9(P)=H(H(H(H(H(H(H(H(H(P)))))))))\)并将这个信息发送给鲍勃。鲍勃计算从爱丽丝那里收到的值的哈希（\(H(H^9(P))\)）并验证这个值是否等于他数据库中存储的值。然后，他减少授权认证次数并将\(H^9(P)\)存储在他的数据库中。现在鲍勃已经准备好进行爱丽丝的下一个认证。当授权认证次数达到零时，需要重新初始化哈希链。如果伊芙捕获了\((H^n(P))\)，她不能用它来在鲍勃的电脑上以爱丽丝的身份进行认证，因为鲍勃会减少其授权认证次数。此外，由于哈希函数是不可逆的，伊芙不能从\(H^{n}(P)\)计算出\(H^{n-1}(P)\)。
- en: The two protocols above prevent eavesdropping attacks, but not man-in-the-middle
    attacks. If Mallory can intercept the messages sent by Alice, he could force her
    to reveal \(H^n(P)\) and then use this information to authenticate as Alice on
    Bob’s computer. In practice, hash chains should only be used when the communicating
    users know that there cannot be any man-in-the-middle on their communication.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两种协议可以防止窃听攻击，但不能防止中间人攻击。如果Mallory可以拦截爱丽丝发送的消息，他可以迫使她透露\(H^n(P)\)，然后使用这些信息在鲍勃的计算机上冒充爱丽丝。在实践中，只有在通信用户知道他们的通信中不可能有中间人时，才应使用哈希链。
- en: 'Public key cryptography provides another possibility to allow Alice to authenticate
    herself on Bob’s computer. Assume again that Alice and Bob know each other from
    previous encounters. Alice knows Bob’s public key (\(Bob_{pub}\)) and Bob also
    knows Alice’s key (\(Alice_{pub}\)). To authenticate herself, Alice could send
    her user identifier. Bob would reply with a random number encrypted with Alice’s
    public key : \(E_p(Alice_{pub},R)\). Alice can decrypt this message to recover
    R and sends \(E_p(Bob_{pub},R)\). Bob decrypts the nonce and confirms that Alice
    knows \(Alice_{priv}\). If an eavesdropper captures the messages exchanged, he
    cannot recover the value R which could be used as a key to encrypt the information
    with a secret key algorithm. This is illustrated in the time sequence diagram
    below.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学为爱丽丝在鲍勃的计算机上验证自己的身份提供了另一种可能性。再次假设爱丽丝和鲍勃从之前的接触中认识彼此。爱丽丝知道鲍勃的公钥（\(Bob_{pub}\)），而鲍勃也知道爱丽丝的密钥（\(Alice_{pub}\)）。为了验证自己的身份，爱丽丝可以发送她的用户标识符。鲍勃会回复一个用爱丽丝的公钥加密的随机数：\(E_p(Alice_{pub},R)\)。爱丽丝可以解密这条消息以恢复R，并发送\(E_p(Bob_{pub},R)\)。鲍勃解密这个随机数并确认爱丽丝知道\(Alice_{priv}\)。如果窃听者捕获了交换的消息，他无法恢复值R，这个值可以用作使用秘密密钥算法加密信息的密钥。这在下方的时序图中进行了说明。
- en: '![msc {'
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="爱丽丝", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="鲍勃", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "我是爱丽丝\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "E_p(Alice_{pub},R)", arcskip="1"];
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "E_p(Alice_{pub},R)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Bob_{pub},R)", arcskip="1"];
  id: totrans-894
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Bob_{pub},R)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/f7eeac697813279f3277f20eb023de49.png)<map id="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"
    name="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"></map>'
  id: totrans-896
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/f7eeac697813279f3277f20eb023de49.png)<map id="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"
    name="6027ccdd0a4dba418aa8843c8ac153fd6a422bd7"></map>'
- en: 'A drawback of this approach is that Bob is forced to perform two public key
    computations : one encryption to send the random nonce to Alice and one decryption
    to recover the nonce encrypted by Alice. If these computations are costly from
    a CPU viewpoint, this creates a risk of Denial of Service Attacks were attackers
    could try to access Bob’s computer and force it to perform such costly computations.
    Bob is more at risk than Alice in this situation and he should not perform complex
    operations before being sure that he is talking with Alice. An alternative is
    shown in the time sequence diagram below.'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是鲍勃被迫执行两次公钥计算：一次加密将随机数发送给爱丽丝，一次解密恢复爱丽丝加密的随机数。如果这些计算从CPU的角度来看成本高昂，这就会产生拒绝服务攻击的风险，攻击者可能会尝试访问鲍勃的计算机并迫使其执行这种昂贵的计算。在这种情况下，鲍勃比爱丽丝风险更大，他应该在确定自己正在与爱丽丝交谈之前不执行复杂的操作。下方的时序图中展示了另一种方法。
- en: '![msc {'
  id: totrans-898
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="爱丽丝", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="鲍勃", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice\n\n", arcskip="1"];
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "我是爱丽丝\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "R\n\n", arcskip="1"];
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "R\n\n", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Alice_{priv},R)\n\n", arcskip="1"];
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R)\n\n", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/5d0252030a1e74f0aa10edc4572b381d.png)<map id="26127d2d1ccdbf50c7d1c6d967ea621292da9631"
    name="26127d2d1ccdbf50c7d1c6d967ea621292da9631"></map>'
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/5d0252030a1e74f0aa10edc4572b381d.png)<map id="26127d2d1ccdbf50c7d1c6d967ea621292da9631"
    name="26127d2d1ccdbf50c7d1c6d967ea621292da9631"></map>'
- en: Here, Bob simply sends a random nonce to Alice and verifies her signature. Since
    the random nonce and the signature could be captured by an eavesdropper, they
    cannot be used as a secret key to encrypt further data. However Bob could propose
    a secret key and send it encrypted with Alice’s public key in response to the
    signed nonce that he received.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Bob只是简单地向Alice发送一个随机数，并验证她的签名。由于随机数和签名可能被窃听者捕获，因此它们不能用作加密进一步数据的密钥。然而，Bob可以提出一个密钥，并将其与Alice的公钥一起加密，作为对已签名的随机数的响应。
- en: The solution described above works provided that Bob and Alice know their respective
    public keys before communicating. Otherwise, the protocol is not secure against
    man-in-the-middle attackers. Consider Mallory sitting in the middle between Alice
    and Bob and assume that neither Alice nor Bob knows the other’s public key.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述的解决方案在Bob和Alice在通信之前知道他们各自的公钥的情况下是有效的。否则，该协议不能抵御中间人攻击者。考虑Mallory坐在Alice和Bob之间，假设Alice和Bob都不知道对方的公钥。
- en: '![msc {'
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: x [label="", linecolour=white],
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x [label="", linecolour=white],
- en: y [label="Mallory", textcolour="red", linecolour=red],
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y [label="Mallory", textcolour="red", linecolour=red],
- en: z [label="", linecolour=white],
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = " " ] ,
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = " " ] ,
- en: b>>y [ label = "I'm Alice key=Alice_{pub}", arcskip="1" ];
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>y [ label = "I'm Alice key=Alice_{pub}", arcskip="1" ];
- en: y>>c [ label = "I'm Alice key=Mallory_{pub}", textcolour="red", arcskip="1"
    ];
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y>>c [ label = "I'm Alice key=Mallory_{pub}", textcolour="red", arcskip="1"
    ];
- en: c=>d [ label = "" ];
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "R", arcskip="1"];
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "R", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>y [ label = "E_p(Alice_{priv},R)", arcskip="1"];
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>y [ label = "E_p(Alice_{priv},R)", arcskip="1"];
- en: y>>c [ label = "E_p(Mallory_{priv},R)", textcolour="red",  arcskip="1"];
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y>>c [ label = "E_p(Mallory_{priv},R)", textcolour="red",  arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-940
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-941
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-942
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Access", arcskip="1"];
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Access", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/0638f4c9db9fea46091250d1fe48d4c9.png)<map id="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"
    name="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"></map>'
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/0638f4c9db9fea46091250d1fe48d4c9.png)<map id="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"
    name="1ee9ab4ade7fb05cf8774418033d3c5fb2944924"></map>'
- en: In the above example, Alice sends her public key, (\(Alice_{pub}\)), in her
    first message together with her identity. Mallory intercepts the message and replaces
    Alice’s key with his own key, (\(Mallory_{pub}\)). Bob replies with a nonce, R.
    Alice then signs the random nonce to prove that she knows \(Alice_{priv}\). Mallory
    discards the information and instead computes \(E_p(Mallory_{priv},R)\). Bob now
    thinks that he is discussing with Alice while Mallory sits in the middle.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，Alice在她的第一条消息中发送她的公钥（\(Alice_{pub}\)），以及她的身份。Mallory拦截了消息，并用他自己的密钥（\(Mallory_{pub}\)）替换了Alice的密钥。Bob回复一个随机数R。然后Alice签署随机数以证明她知道\(Alice_{priv}\)。Mallory丢弃了信息，而是计算\(E_p(Mallory_{priv},R)\)。现在Bob认为他正在与Alice交谈，而Mallory坐在中间。
- en: There are situations where symmetric authentication is required. In this case,
    each user must perform some computation with his/her private key. A possible exchange
    is the following. Alice sends her certificate to Bob. Bob replies with a nonce,
    \(R1\), and provides his certificate. Alice encrypts \(R1\) with her private key
    and generates a nonce, \(R2\). Bob verifies Alice’s computation and encrypts \(R2\)
    with his private key. Alice verifies the computation and both have been authenticated.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要对称认证。在这种情况下，每个用户必须使用他的/她的私钥进行一些计算。一个可能的交换如下。Alice将她的证书发送给Bob。Bob回复一个随机数，\(R1\)，并提供他的证书。Alice使用她的私钥加密\(R1\)并生成一个随机数，\(R2\)。Bob验证Alice的计算，并使用他的私钥加密\(R2\)。Alice验证计算，双方都完成了认证。
- en: '![msc {'
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice", arcskip="1"];
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:R1", arcskip="1"];
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:R1", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Alice_{priv},R1),R2", arcskip="1"];
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R1),R2", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "E_p(Bob_{priv},R2)", arcskip="1"];
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "E_p(Bob_{priv},R2)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/682391126620ce67dffa1f33ee972f1b.png)<map id="dc928c892b0c31362bbfde7cc4e2025e18374729"
    name="dc928c892b0c31362bbfde7cc4e2025e18374729"></map>'
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/682391126620ce67dffa1f33ee972f1b.png)<map id="dc928c892b0c31362bbfde7cc4e2025e18374729"
    name="dc928c892b0c31362bbfde7cc4e2025e18374729"></map>'
- en: The protocol described above works, but it takes a long time for Bob to authenticate
    Alice and for Alice to authenticate Bob. A faster authentication could be the
    following.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 上述协议是可行的，但Bob认证Alice和Alice认证Bob都需要很长时间。更快的认证方式可以是以下这样。
- en: '![msc {'
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice, R2", arcskip="1"];
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice, R2", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:R1,E_p(Bob_{priv},R2)", arcskip="1"];
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:R1,E_p(Bob_{priv},R2)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "E_p(Alice_{priv},R1)", arcskip="1"];
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R1)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/d9c1e952550357ddf872d47493c46bd4.png)<map id="b006024cf4bbd5812ac6af177e9c613098b52e42"
    name="b006024cf4bbd5812ac6af177e9c613098b52e42"></map>'
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d9c1e952550357ddf872d47493c46bd4.png)<map id="b006024cf4bbd5812ac6af177e9c613098b52e42"
    name="b006024cf4bbd5812ac6af177e9c613098b52e42"></map>'
- en: 'Alice sends her random nonce, \(R2\). Bob signs \(R2\) and sends his nonce
    : \(R1\). Alice signs \(R1\) and both are authenticated.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: Alice发送她的随机非确定数，\(R2\)。Bob签署\(R2\)并发送他的非确定数：\(R1\)。Alice签署\(R1\)，双方都完成了认证。
- en: Now consider that Mallory wants to be authenticated as Alice. The above protocol
    has a subtle flaw that could be exploited by Mallory. This flaw can be exploited
    if Alice and Bob can act as both client and server. Knowing this, Mallory could
    operate as follows. Mallory starts an authentication with Bob faking himself as
    Alice. He sends a first message to Bob including Alice’s identity.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑Mallory想要作为Alice进行认证。上述协议存在一个细微的漏洞，Mallory可以利用这个漏洞。如果Alice和Bob可以同时作为客户端和服务器，这个漏洞就可以被利用。了解到这一点后，Mallory可以按照以下方式操作。Mallory开始与Bob进行认证，假装自己是Alice。他向Bob发送第一条消息，包括Alice的身份。
- en: '![msc {'
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Mallory", textcolour="red", linecolour=black],
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Mallory", textcolour="red", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Alice,RA", arcskip="1"];
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Alice,RA", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:RB,E_p(Bob_{priv},RA)", arcskip="1"];
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:RB,E_p(Bob_{priv},RA)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/0129748f31a23c4c1ec10d426878fd81.png)<map id="b30892ea80e85d5226bffe1067bd495dabafda9e"
    name="b30892ea80e85d5226bffe1067bd495dabafda9e"></map>'
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/0129748f31a23c4c1ec10d426878fd81.png)<map id="b30892ea80e85d5226bffe1067bd495dabafda9e"
    name="b30892ea80e85d5226bffe1067bd495dabafda9e"></map>'
- en: In this exchange, Bob authenticates himself by signing the \(RA\) nonce that
    was sent by Mallory. Now, to authenticate as Alice, Mallory needs to compute the
    signature of nonce \(RB\) with Alice’s private key. Mallory does not know Alice’s
    key, but he could exploit the protocol to force Alice to perform the required
    computation. For this, Mallory can start an authentication to Alice as shown below.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次交换中，Bob通过签署Mallory发送的\(RA\)非确定数来认证自己。现在，为了作为Alice进行认证，Mallory需要使用Alice的私钥计算非确定数\(RB\)的签名。Mallory不知道Alice的密钥，但他可以利用协议强制Alice执行所需的计算。为此，Mallory可以像下面这样开始对Alice进行认证。
- en: '![msc {'
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Mallory", textcolour="red",linecolour=black],
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Mallory", textcolour="red",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Alice", linecolour=black],
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Alice", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "I'm Mallory,RB", arcskip="1"];
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "I'm Mallory,RB", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-1020
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "Challenge:RX,E_p(Alice_{priv},RB)", arcskip="1"];
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Challenge:RX,E_p(Alice_{priv},RB)", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/cd66745b390b62a38dfe355eb3a5cc12.png)<map id="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"
    name="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"></map>'
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/cd66745b390b62a38dfe355eb3a5cc12.png)<map id="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"
    name="48be047a9645ab6feb54e3f2716ac4f1e148d8e7"></map>'
- en: In this example, Mallory has forced Alice to compute \(E_p(Alice_{priv},RB)\)
    which is the information required to finalize the first exchange and be authenticated
    as Alice. This illustrates a common problem with authentication schemes when the
    same information can be used for different purposes. The problem comes from the
    fact that Alice agrees to compute her signature on a nonce chosen by Bob (and
    relayed by Mallory). This problem occurs if the nonce is a simple integer without
    any structure. If the nonce includes some structure such as some information about
    Alice and Bob’s identities or even a single bit indicating whether the nonce was
    chosen by a user acting as a client (i.e. starting the authentication) or as a
    server, then the protocol is not vulnerable anymore.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Mallory迫使Alice计算\(E_p(Alice_{priv},RB)\)，这是完成第一次交换并验证为Alice所需的信息。这说明了当相同信息可用于不同目的时，认证方案中存在的一个常见问题。问题源于Alice同意在Bob选择的（并由Mallory转发的）随机数上计算她的签名。如果随机数是一个没有结构的简单整数，则会出现这个问题。如果随机数包含一些结构，例如关于Alice和Bob身份的信息，甚至是一个表示随机数是否由作为客户端的用户（即启动认证）或作为服务器选择的单个比特，那么协议就不再容易受到攻击。
- en: 'To cope with some of the above mentioned problems, public-key cryptography
    is usually combined with certificates. A certificate is a data structure that
    includes a signature from a trusted third party. A simple explanation of the utilization
    of certificates is to consider that Alice and Bob both know Ted. Ted is trusted
    by these two users and both have stored Ted’s public key : \(Ted_{pub}\). Since
    they both know Ted’s key, he can issue certificates. A certificate is mainly a
    cryptographic link between the identity of a user and his/her public key. Such
    a certificate can be computed in different ways. A simple solution is for Ted
    to generate a file that contains the following information for each certified
    user :'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对上述提到的一些问题，通常将公钥密码学与证书结合使用。证书是一个包含来自可信第三方签名的数据结构。对证书利用的简单解释是考虑Alice和Bob都知道Ted。这两个用户都信任Ted，并且都存储了Ted的公钥：\(Ted_{pub}\)。由于他们都知道Ted的密钥，他可以颁发证书。证书主要是用户身份与其公钥之间的加密链接。此类证书可以以不同的方式计算。一个简单的解决方案是Ted为每个认证用户生成一个包含以下信息的文件：
- en: his/her identity
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他的/她的身份
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: his/her public key
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他的/她的公钥
- en: ''
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a hash of the entire file signed with Ted’s private key
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ted的私钥签名的整个文件的哈希
- en: Then, knowing Ted’s public key, anyone can verify the validity of a certificate.
    When a user sends his/her public key, he/she must also attach the certificate
    to prove the link between his/her identity and the public key. In practice, certificates
    are more complex than this. Certificates will often be used to authenticate the
    server and sometimes to authenticate the client.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，知道Ted的公钥，任何人都可以验证证书的有效性。当用户发送他的/她的公钥时，他/她必须也附加证书以证明他/她的身份与公钥之间的联系。在实践中，证书比这更复杂。证书通常用于验证服务器，有时也用于验证客户端。
- en: A possible protocol could then be the following. Alice sends \(Cert(Alice_{pub},Ted)\).
    Bob replies with a random nonce.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的协议可以是以下。Alice发送\(Cert(Alice_{pub},Ted)\)。Bob回复一个随机数。
- en: '![msc {'
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Alice", linecolour=black],
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Alice", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Bob", linecolour=black],
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Bob", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "Cert(Alice_{pub},Ted)", arcskip="1"];
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Cert(Alice_{pub},Ted)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "R", arcskip="1"];
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "R", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = ""] ,
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = ""] ,
- en: b>>c [ label = "E_p(Alice_{priv},R)", arcskip="1"];
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E_p(Alice_{priv},R)", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: '}](../Images/64eccedf6350698b6491b83ea9b24e73.png)<map id="3b6facf99117568ccbf6aa8408c70dddc156d855"
    name="3b6facf99117568ccbf6aa8408c70dddc156d855"></map>'
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/64eccedf6350698b6491b83ea9b24e73.png)<map id="3b6facf99117568ccbf6aa8408c70dddc156d855"
    name="3b6facf99117568ccbf6aa8408c70dddc156d855"></map>'
- en: 'Until now, we have only discussed the authentication problem. This is an important
    but not sufficient step to have a secure communication between two users through
    an insecure network. To securely exchange information, Alice and Bob need to both
    :'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了认证问题。这是在通过不安全的网络在两个用户之间建立安全通信的重要但不是充分的一步。为了安全地交换信息，爱丽丝和鲍勃都需要：
- en: mutually authenticate each other
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互相验证对方的身份
- en: ''
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1057
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: agree on a way to encrypt the messages that they will exchange
  id: totrans-1058
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定一种加密他们将要交换的消息的方式
- en: 'Let us first explore how this could be realized by using public-key cryptography.
    We assume that Alice and Bob have both a public-private key pair and the corresponding
    certificates signed by a trusted third party : Ted.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探讨如何通过使用公钥密码学来实现这一点。我们假设爱丽丝和鲍勃都有一对公钥私钥和由受信任的第三方泰德签署的相应证书。
- en: 'A possible protocol would be the following. Alice sends \(Cert(Alice_{pub},Ted)\).
    This certificate provides Alice’s identity and her public key. Bob replies with
    the certificate containing his own public key : \(Cert(Bob_{pub},Ted)\). At this
    point, they both know the other public key and could use it to send encrypted
    messages. Alice would send \(E_p(Bob_{pub},M1)\) and Bob would send \(E_p(Alice_{pub},M2)\).
    In practice, using public key encryption techniques to encrypt a large number
    of messages is inefficient because these cryptosystems require a large number
    of computations. It is more efficient to use secret key cryptosystems for most
    of the data and only use a public key cryptosystem to encrypt the random secret
    keys that will be used by the secret key encryption scheme.'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的协议如下。爱丽丝发送 \(Cert(Alice_{pub},Ted)\)。这个证书提供了爱丽丝的身份和她的公钥。鲍勃回复包含他自己的公钥的证书：\(Cert(Bob_{pub},Ted)\)。在这个时候，他们都知道对方的公钥，可以使用它来发送加密消息。爱丽丝会发送
    \(E_p(Bob_{pub},M1)\) 和鲍勃会发送 \(E_p(Alice_{pub},M2)\)。在实践中，使用公钥加密技术加密大量消息是不高效的，因为这些密码系统需要大量的计算。更有效的方法是使用对称密钥密码系统来加密大部分数据，而只使用公钥密码系统来加密将用于对称密钥加密方案的随机密钥。
- en: Key exchange[#](#key-exchange "Link to this heading")
  id: totrans-1061
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥交换[#](#key-exchange "链接到这个标题")
- en: 'When users want to communicate securely through a network, they need to exchange
    information such as the keys that will be used by an encryption algorithm even
    in the presence of an eavesdropper. The most widely used algorithm that allows
    two users to safely exchange an integer in the presence of an eavesdropper is
    the one proposed by Diffie and Hellman [[DH1976]](../bibliography.html#dh1976).
    It operates with (large) integers. Two of them are public, the modulus, p, which
    is prime and the base, g, which must be a primitive root of p. The communicating
    users select a random integer, \(a\) for Alice and \(b\) for Bob. The exchange
    starts as :'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要通过网络安全地通信时，即使在窃听者的存在下，他们也需要交换信息，例如将要使用的加密算法的密钥。在窃听者存在的情况下，允许两个用户安全交换整数的最广泛使用的算法是迪菲和赫尔曼提出的算法
    [[DH1976]](../bibliography.html#dh1976)。它使用（大）整数。其中两个是公开的，一个是模数，\(p\)，它必须是 \(p\)
    的原根，另一个是基数，\(g\)。通信用户选择一个随机整数，\(a\) 给爱丽丝，\(b\) 给鲍勃。交换开始如下：
- en: Alice selects a random integer, \(a\) and sends \(A=g^{a} \mod p\) to Bob
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爱丽丝选择一个随机整数，\(a\) 并将 \(A=g^{a} \mod p\) 发送给鲍勃
- en: ''
  id: totrans-1064
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1065
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob selects a random integer, \(b\) and sends \(B=g^{b} \mod p\) to Alice
  id: totrans-1066
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃选择一个随机整数，\(b\) 并将 \(B=g^{b} \mod p\) 发送给爱丽丝
- en: ''
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1068
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: From her knowledge of \(a\) and \(B\), Alice can compute \(Secret=B^{a} \mod
    p= (g^{b} \mod p) ^{a} \mod p=g^{a \times b} \mod p\)
  id: totrans-1069
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从她对 \(a\) 和 \(B\) 的知识出发，爱丽丝可以计算出 \(Secret=B^{a} \mod p= (g^{b} \mod p) ^{a}
    \mod p=g^{a \times b} \mod p\)
- en: ''
  id: totrans-1070
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1071
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: From is knowledge of \(b\) and \(A\), Bob can compute \(Secret=A^{b} \mod p=(g^{a}
    \mod p) ^{b} \mod p=g^{a \times b} \mod p\)
  id: totrans-1072
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对 \(b\) 和 \(A\) 的知识出发，鲍勃可以计算出 \(Secret=A^{b} \mod p=(g^{a} \mod p) ^{b} \mod
    p=g^{a \times b} \mod p\)
- en: The security of this protocol relies on the difficulty of computing discrete
    logarithms, i.e. from the knowledge of \(A\) (resp. \(B\)), it is very difficult
    to extract \(\log(A)=\log(g^{a} \mod p)=a\) (resp. \(\log(B)=\log(g^{b} \mod p)=b\)).
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议的安全性依赖于计算离散对数的难度，即从 \(A\)（分别）的知识中，很难提取 \(\log(A)=\log(g^{a} \mod p)=a\)（分别）\(\log(B)=\log(g^{b}
    \mod p)=b\)。
- en: An example of the utilization of the Diffie-Hellman key exchange is shown below.
    Before starting the exchange, Alice and Bob agree on a modulus (\(p=23\)) and
    a base (\(g=5\)). These two numbers are public. They are typically part of the
    standard that defines the protocol that uses the key exchange.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了Diffie-Hellman密钥交换的应用示例。在开始交换之前，Alice和Bob就模数(\(p=23\))和底数(\(g=5\))达成一致。这两个数字是公开的。它们通常是定义使用密钥交换的协议的标准的一部分。
- en: 'Alice chooses a secret integer : \(a=8\) and sends \(A= g^{a} \mod p= 5^{8}
    \mod 23=16\) to Bob'
  id: totrans-1075
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个秘密整数：\(a=8\)，并将\(A= g^{a} \mod p= 5^{8} \mod 23=16\)发送给Bob
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1077
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob chooses a secret integer : \(b=13\) and sends \(B= g^{b} \mod p=5^{13}
    \mod 23=21\) to Alice'
  id: totrans-1078
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob选择一个秘密整数：\(b=13\)，并将\(B= g^{b} \mod p=5^{13} \mod 23=21\)发送给Alice
- en: ''
  id: totrans-1079
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1080
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Alice computes \(S_{A}=B^{a} \mod p= 21^{8} \mod 23=3\)
  id: totrans-1081
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice计算\(S_{A}=B^{a} \mod p= 21^{8} \mod 23=3\)
- en: ''
  id: totrans-1082
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1083
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob computes \(S_{B}=A^{b} \mod p= 16^{13} \mod 23=3\)
  id: totrans-1084
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob计算\(S_{B}=A^{b} \mod p= 16^{13} \mod 23=3\)
- en: Alice and Bob have agreed on the secret information \(3\) without having sent
    it explicitly through the network. If the integers used are large enough and have
    good properties, then even Eve who can capture all the messages sent by Alice
    and Bob cannot recover the secret key that they have exchanged. There is no formal
    proof of the security of the algorithm, but mathematicians have tried to solve
    similar problems with integers during centuries without finding an efficient algorithm.
    As long as the integers that are used are random and large enough, the only possible
    attack for Eve is to test all possible integers that could have been chosen by
    Alice and Bob. This is computationally very expensive. This algorithm is widely
    used in security protocols to agree on a secret key.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob已经就秘密信息\(3\)达成一致，而没有通过网络明确发送。如果使用的整数足够大且具有良好的属性，那么即使能够捕获Alice和Bob发送的所有消息的Eve也无法恢复他们交换的秘密密钥。该算法的安全性没有正式的证明，但数学家们已经尝试了几个世纪，试图用整数解决类似的问题，但没有找到有效的算法。只要使用的整数是随机的且足够大，Eve唯一可能的攻击就是测试Alice和Bob可能选择的所有可能的整数。这在计算上非常昂贵。该算法在安全协议中被广泛用于达成秘密密钥。
- en: 'Unfortunately, the Diffie-Hellman key exchange alone cannot cope with man-in-the
    middle attacks. Consider Mallory who sits in the middle between Alice and Bob
    and can easily capture and modify their messages. The modulus and the base are
    public. They are thus known by Mallory as well. He could then operate as follows
    :'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，仅凭Diffie-Hellman密钥交换无法应对中间人攻击。考虑一下Mallory，他坐在Alice和Bob之间，可以轻易地捕获并修改他们的消息。模数和底数是公开的。因此，Mallory也知道它们。他可以这样做：
- en: Alice chooses a secret integer and sends \(A= g^{a} \mod p\) to Mallory
  id: totrans-1087
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个秘密整数，并将\(A= g^{a} \mod p\)发送给Mallory
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1089
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Mallory generates a secret integer, \(m\) and sends \(M=g^{m} \mod p\) to Bob
  id: totrans-1090
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mallory生成一个秘密整数\(m\)，并将\(M=g^{m} \mod p\)发送给Bob
- en: ''
  id: totrans-1091
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1092
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob chooses a secret integer and sends \(B=g^{b} \mod p\) to Mallory
  id: totrans-1093
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob选择一个秘密整数，并将\(B=g^{b} \mod p\)发送给Mallory
- en: ''
  id: totrans-1094
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1095
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Mallory computes \(S_{A}=A^{m} \mod p\) and \(S_{B}=B^{m} \mod p\)
  id: totrans-1096
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mallory计算\(S_{A}=A^{m} \mod p\)和\(S_{B}=B^{m} \mod p\)
- en: ''
  id: totrans-1097
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1098
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Alice computes \(S_{A}=M^{a} \mod p\) and uses this key to communicate with
    Mallory (acting as Bob)
  id: totrans-1099
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice计算\(S_{A}=M^{a} \mod p\)，并使用这个密钥与Mallory（充当Bob）通信
- en: ''
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1101
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob computes \(S_{B}=M^{b} \mod p\) and uses this key to communicate with Mallory
    (acting as Alice)
  id: totrans-1102
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob计算\(S_{B}=M^{b} \mod p\)，并使用这个密钥与Mallory（充当Alice）通信
- en: When Alice sends a message, she encrypts it with \(S_{A}\). Mallory decrypts
    it with \(S_{A}\) and encrypts the plaintext with \(S_{B}\). When Bob receives
    the message, he can decrypt it by using \(S_{B}\).
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 当Alice发送消息时，她用\(S_{A}\)加密它。Mallory用\(S_{A}\)解密它，并用\(S_{B}\)加密明文。当Bob收到消息时，他可以使用\(S_{B}\)解密它。
- en: To safely use the Diffie-Hellman key exchange, Alice and Bob must use an authenticated
    exchange. Some of the information sent by Alice or Bob must be signed with a public
    key known by the other user. In practice, it is often important for Alice to authenticate
    Bob. If Bob has a certificate signed by Ted, the authenticated key exchange could
    be organized as follows.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地使用Diffie-Hellman密钥交换，Alice和Bob必须使用认证交换。Alice或Bob发送的一些信息必须使用其他用户已知的公钥进行签名。在实践中，Alice认证Bob通常很重要。如果Bob有一个由Ted签名的证书，认证密钥交换可以组织如下。
- en: 'Alice chooses a secret integer : \(a\) and sends \(A= g^{a} \mod p\) to Bob'
  id: totrans-1105
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个秘密整数：\(a\)，并将\(A= g^{a} \mod p\)发送给Bob
- en: ''
  id: totrans-1106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob chooses a secret integer : \(b\), computes \(B= g^{b} \mod p\) and sends
    \(Cert(Bob,Bob_{pub},Ted), E_p(Bob_{priv},B)\) to Alice'
  id: totrans-1108
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob选择一个秘密整数：\(b\)，计算\(B= g^{b} \mod p\)，并将\(Cert(Bob,Bob_{pub},Ted), E_p(Bob_{priv},B)\)发送给Alice
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Alice checks the signature (with \(Bob_{pub}\)) and the certificate and computes
    \(S_{A}=B^{a} \mod p\)
  id: totrans-1111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice检查签名（使用\(Bob_{pub}\)）和证书，并计算\(S_{A}=B^{a} \mod p\)
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bob computes \(S_{B}=A^{b} \mod p\)
  id: totrans-1114
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob计算\(S_{B}=A^{b} \mod p\)
- en: This prevents the attack mentioned above since Mallory cannot create a fake
    certificate and cannot sign a value by using Bob’s private key. Given the risk
    of man-in-the-middle attacks, the Diffie-Hellman key exchange mechanism should
    never be used without authentication.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了上述提到的攻击，因为Mallory无法创建一个假的证书，也无法使用Bob的私钥来签名一个值。鉴于中间人攻击的风险，Diffie-Hellman密钥交换机制在没有认证的情况下不应使用。
- en: '## The secure shell (ssh)[#](#the-secure-shell-ssh "Link to this heading")'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '## 安全壳（ssh）[#](#the-secure-shell-ssh "链接到这个标题")'
- en: One of the initial motivations for building computer networks was to allow users
    to access remote computers over the networks. In the 1960s and 1970s, the mainframes
    and the emerging minicomputers were composed of a central unit and a set of terminals
    connected through serial lines or modems. The simplest protocol that was designed
    to access remote computers over a network is probably [telnet](../glossary.html#term-telnet)
    [**RFC 854**](https://datatracker.ietf.org/doc/html/rfc854.html). [telnet](../glossary.html#term-telnet)
    runs over TCP and a telnet server listens on port 23 by default. The TCP connection
    used by telnet is bidirectional, both the client and the server can send data
    over it. The data exchanged over such a connection is essentially the characters
    that are typed by the user on the client machine and the text output of the processes
    running on the server machine with a few exceptions (e.g. control characters,
    characters to control the terminal like VT-100, …) . The default character set
    for telnet is the ASCII character set, but the extensions specified in [**RFC
    5198**](https://datatracker.ietf.org/doc/html/rfc5198.html) support the utilization
    of Unicode characters.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 建立计算机网络的一个初始动机是允许用户通过网络访问远程计算机。在20世纪60年代和70年代，大型机和新兴的小型机由一个中央单元和通过串行线路或调制解调器连接的一组终端组成。设计用来通过网络访问远程计算机的最简单协议可能是[telnet](../glossary.html#term-telnet)
    [**RFC 854**](https://datatracker.ietf.org/doc/html/rfc854.html)。telnet在TCP上运行，默认情况下，telnet服务器监听23号端口。telnet使用的TCP连接是双向的，客户端和服务器都可以通过它发送数据。在这种连接上交换的数据基本上是用户在客户端机器上键入的字符以及服务器机器上运行的进程的文本输出，有一些例外（例如控制字符、控制VT-100等终端的字符……）。telnet的默认字符集是ASCII字符集，但[**RFC
    5198**](https://datatracker.ietf.org/doc/html/rfc5198.html)中指定的扩展支持Unicode字符的使用。
- en: From a security viewpoint, the main drawback of [telnet](../glossary.html#term-telnet)
    is that all the information, including the usernames, passwords and commands,
    is sent in cleartext over a TCP connection. This implies that an eavesdropper
    could easily capture the passwords used by anyone on an unprotected network. Various
    software tools exist to automate this collection of information. For this reason,
    [telnet](../glossary.html#term-telnet) is rarely used today to access remote computers.
    It is usually replaced by [ssh](../glossary.html#term-ssh) or similar protocols.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，[telnet](../glossary.html#term-telnet)的主要缺点是所有信息，包括用户名、密码和命令，都在TCP连接中以明文形式发送。这意味着窃听者可以轻易地捕获在未受保护的网络中任何人使用的密码。存在各种软件工具来自动收集这些信息。因此，[telnet](../glossary.html#term-telnet)今天很少用于访问远程计算机。它通常被[ssh](../glossary.html#term-ssh)或类似协议所取代。
- en: The secure shell protocol was designed in the mid 1990s by T. Ylonen to counter
    the eavesdropping attacks against [telnet](../glossary.html#term-telnet) and similar
    protocols [[Ylonen1996]](../bibliography.html#ylonen1996). [ssh](../glossary.html#term-ssh)
    became quickly popular and system administrators encouraged its usage. The original
    version of [ssh](../glossary.html#term-ssh) was freely available. After a few
    years, his author created a company to distribute it commercially, but other programmers
    continued to develop an open-source version of [ssh](../glossary.html#term-ssh)
    called [OpenSSH](http://www.openssh.com). Over the years, [ssh](../glossary.html#term-ssh)
    evolved and became a flexible applicable whose usage extends beyond remote login
    to support features such as file transfers, protocol tunneling, … In this section,
    we only discuss the basic features of [ssh](../glossary.html#term-ssh) and explain
    how it differs from [telnet](../glossary.html#term-telnet). Entire books have
    been written to describe [ssh](../glossary.html#term-ssh) in details [[BS2005]](../bibliography.html#bs2005).
    An overview of the protocol appeared in [[Stallings2009]](../bibliography.html#stallings2009).
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 安全壳协议是在 1990 年代中期由 T. Ylonen 设计的，旨在对抗针对 [telnet](../glossary.html#term-telnet)
    和类似协议的窃听攻击 [[Ylonen1996]](../bibliography.html#ylonen1996)。[ssh](../glossary.html#term-ssh)
    迅速变得流行，系统管理员鼓励使用它。最初的 [ssh](../glossary.html#term-ssh) 版本是免费提供的。几年后，其作者创建了一家公司来商业分销它，但其他程序员继续开发了一个开源版本的
    [ssh](../glossary.html#term-ssh)，称为 [OpenSSH](http://www.openssh.com)。多年来，[ssh](../glossary.html#term-ssh)
    不断发展，成为了一个灵活适用的协议，其使用范围不仅限于远程登录，还包括文件传输、协议隧道等功能……在本节中，我们只讨论 [ssh](../glossary.html#term-ssh)
    的基本功能，并解释它与 [telnet](../glossary.html#term-telnet) 的不同。关于 [ssh](../glossary.html#term-ssh)
    的详细描述已有整本书籍出版 [[BS2005]](../bibliography.html#bs2005)。该协议的概述出现在 [[Stallings2009]](../bibliography.html#stallings2009)。
- en: The [ssh](../glossary.html#term-ssh) protocol runs directly above the TCP protocol.
    Once the TCP bytestream has been established, the client and the server exchange
    messages. The first message exchanged is an ASCII line that announces the version
    of the protocol and the version of the software implementation used by the client
    and the server. These two lines are useful when debugging interoperability problems
    and other issues.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '[ssh](../glossary.html#term-ssh) 协议直接运行在 TCP 协议之上。一旦 TCP 字节流建立，客户端和服务器交换消息。交换的第一个消息是一条
    ASCII 行，宣布了协议版本以及客户端和服务器使用的软件实现版本。这两行在调试互操作性问题和其它问题时非常有用。'
- en: The next message is the `SSH_MSG_KEX_INIT` message that is used to negotiate
    the cryptographic algorithms that will be used for the `ssh` session. It is very
    important for security protocols to include mechanisms that enable a negotiation
    of the cryptographic algorithms that are used. First, these algorithms provide
    different levels of security. Some algorithms might be considered totally secure
    and are recommended today while they could become deprecated a few years later
    after the publication of some attacks. Second, these algorithms provide different
    levels of performance and have different CPU and memory impacts.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个消息是 `SSH_MSG_KEX_INIT` 消息，用于协商 `ssh` 会话将使用的加密算法。对于安全协议来说，包含允许协商所使用的加密算法的机制非常重要。首先，这些算法提供了不同级别的安全性。一些算法可能被认为是完全安全的，并且目前被推荐使用，但几年后，在发布了一些攻击之后可能会被弃用。其次，这些算法提供了不同级别的性能，并且对
    CPU 和内存有不同的影响。
- en: 'In practice, an `ssh` implementation supports four types of cryptographic algorithms
    :'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，一个 `ssh` 实现支持四种类型的加密算法：
- en: key exchange
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥交换
- en: ''
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: encryption
  id: totrans-1126
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: ''
  id: totrans-1127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Message Authentication Code (MAC)
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息认证码 (MAC)
- en: ''
  id: totrans-1130
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: compression
  id: totrans-1132
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: The [IANA](https://www.iana.org) maintains a [list of the cryptographic algorithms](http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml#ssh-parameters-16)
    that can be used by `ssh` implementations. For each type of algorithm, the client
    provides an ordered list of the algorithms that it supports and agrees to use.
    The server compares the received list with its own list. The outcome of the negotiation
    is a set of four algorithms [[4]](#fnull) that will be combined for this session.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '[IANA](https://www.iana.org) 维护了一个 [加密算法列表](http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml#ssh-parameters-16)，该列表可以被
    `ssh` 实现使用。对于每种算法类型，客户端提供一个它支持的算法的有序列表，并同意使用这些算法。服务器将收到的列表与自己的列表进行比较。协商的结果是一组四个算法
    [[4]](#fnull)，这些算法将用于本次会话。'
- en: '![msc {'
  id: totrans-1134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Client",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-1141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "SSH-clientP-clientS comments", arcskip="1"];
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "SSH-clientP-clientS comments", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-1143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-1144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "SSH-serverP-serverS comments", arcskip="1"];
  id: totrans-1146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "SSH-serverP-serverS comments", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: ''
  id: totrans-1148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "" ] ,
  id: totrans-1149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "" ] ,
- en: b>>c [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
  id: totrans-1150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
- en: c=>d [ label = "" ];
  id: totrans-1151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "" ];
- en: ''
  id: totrans-1152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "" ] ,
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "" ] ,
- en: c>>b [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "SSH_MSG_KEX_INIT", arcskip="1"];
- en: b=>a [ label = "" ];
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "" ];
- en: '}](../Images/6c5012af9e2d96b7ddb2c31a55acbaec.png)<map id="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"
    name="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"></map>'
  id: totrans-1156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/6c5012af9e2d96b7ddb2c31a55acbaec.png)<map id="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"
    name="6ae6d4bce6070be0fd3cb65a88d797c93f775d1d"></map>'
- en: This negotiation of the cryptographic algorithms allows the implementations
    to evolve when new algorithms are proposed. If a client is upgraded, it can announce
    a new algorithm as its preferred one even if the server is not yet upgraded.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加密算法的协商允许在提出新算法时实现进化。如果客户端进行了升级，即使服务器尚未升级，它也可以宣布一个新的算法作为其首选算法。
- en: Once the cryptographic algorithms have been negotiated, the key exchange algorithm
    is used to negotiate a secret key that will be shared by the client and the server.
    These key exchange algorithms include some variations over the basic algorithms.
    As an example, let us analyze how the Diffie-Hellman key exchange algorithm is
    used within the `ssh` protocol. In this case, each host has both a private and
    a public key. (Note that \(g\) is a generator for the subgroup of the Galois field
    of order \(p\), where \(p\) is a prime number, and || is the concatenation operator.
    For additional background information, see [[Schneier1996]](../bibliography.html#schneier1996).)
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦协商了加密算法，密钥交换算法就被用来协商一个客户端和服务器将共享的秘密密钥。这些密钥交换算法在基本算法的基础上有一些变体。例如，让我们分析Diffie-Hellman密钥交换算法如何在`ssh`协议中使用。在这种情况下，每个主机都有一个私钥和一个公钥。（注意，\(g\)是阶为\(p\)的伽罗瓦域子群的生成元，其中\(p\)是一个素数，而||是连接运算符。有关更多信息，请参阅[[Schneier1996]](../bibliography.html#schneier1996)。)
- en: the client generates the random number \(a\) and sends \(A=g^{a} \mod p\) to
    the server
  id: totrans-1159
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端生成随机数\(a\)并将\(A=g^{a} \mod p\)发送到服务器
- en: ''
  id: totrans-1160
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1161
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the server generates the random number \(b\). It then computes \(B=g^{b} \mod
    p\), \(K=B^{a} \mod p\) and signs with its private key \(hash(V_{Client} || V_{Server}
    || KEX\_INIT_{Client} || KEX\_INIT_{Server} || Server_{pub} || A || B || K )\)
    where \(V_{Server}\) (resp. \(V_{Client}\)) is the initial messages sent by the
    client (resp. server), \(KEX\_INIT_{Client}\) (resp. \(KEX\_INIT_{Server}\)) is
    the key exchange message sent by the client (resp. server) and \(A\), \(B\) and
    \(K\) are the messages of the Diffie-Hellman key exchange
  id: totrans-1162
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器生成随机数\(b\)。然后计算\(B=g^{b} \mod p\)，\(K=B^{a} \mod p\)，并使用其私钥对\(hash(V_{Client}
    || V_{Server} || KEX\_INIT_{Client} || KEX\_INIT_{Server} || Server_{pub} || A
    || B || K )\)进行签名，其中\(V_{Server}\)（分别对应\(V_{Client}\)）是客户端（分别对应服务器）发送的初始消息，\(KEX\_INIT_{Client}\)（分别对应\(KEX\_INIT_{Server}\)）是客户端（分别对应服务器）发送的密钥交换消息，\(A\)，\(B\)和\(K\)是Diffie-Hellman密钥交换的消息
- en: ''
  id: totrans-1163
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the client can recompute \(K=A^{b} \mod p\) and verify the signature provided
    by the server
  id: totrans-1165
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以重新计算\(K=A^{b} \mod p\)并验证服务器提供的签名
- en: This is a slightly modified authenticated Diffie-Hellman key exchange with two
    interesting points. The first point is that when the server authenticates the
    key exchange it does not provide a certificate. This is because `ssh` assumes
    that the client will store inside its cache the public key of the servers that
    it uses on a regular basis. This assumption is valid for a protocol like `ssh`
    because users typically use it to interact with a small number of servers, typically
    a few or a few tens. Storing this information does not require a lot of storage.
    In practice, most `ssh` clients will accept to connect to remote servers without
    knowing their public key before the connection. In this case, the client issues
    a warning to the user who can decide to accept or reject the key. This warning
    can be associated with a fingerprint of the key, either as a sequence of letters
    or as an ASCII art which can be posted on the web or elsewhere [[5]](#fdnsssh)
    by the system administrator of the server. If a client connects to a server whose
    public key does not match the stored one, a stronger warning is issued because
    this could indicate a man-in-the-middle attack or that the remote server has been
    compromised. It can also indicate that the server has been upgraded and that a
    new key has been generated during this upgrade.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个略微修改过的认证Diffie-Hellman密钥交换，有两个有趣的观点。第一个观点是，当服务器验证密钥交换时，它不提供证书。这是因为`ssh`假设客户端会将其经常使用的服务器公钥存储在其缓存中。对于像`ssh`这样的协议，这个假设是有效的，因为用户通常用它与少量服务器交互，通常是几个或几十个。存储这些信息不需要大量的存储空间。在实践中，大多数`ssh`客户端都会接受在连接之前不知道远程服务器公钥的情况下连接到远程服务器。在这种情况下，客户端会向用户发出警告，用户可以决定接受或拒绝密钥。这个警告可以与密钥的指纹相关联，可以是字母序列，也可以是ASCII艺术，可以由服务器管理员在网络上或其他地方发布
    [[5]](#fdnsssh)。如果一个客户端连接到一个公钥与存储的不匹配的服务器，会发出更强的警告，因为这可能表明中间人攻击或远程服务器已被入侵。它也可能表明服务器已升级，并且在升级过程中生成了新的密钥。
- en: The second point is that the server authenticates not only the result of the
    Diffie-Hellman exchange but also a hash of all the information sent and received
    during the exchange. This is important to prevent downgrade attacks. A downgrade
    attack is an attack where an active attacker modifies the messages sent by the
    communicating hosts (typically the client) to request the utilization of weaker
    encryption algorithms. Consider a client that supports two encryption schemes.
    The preferred one uses 128 bits secret keys and the second one is an old encryption
    scheme that uses 48 bits keys. This second algorithm is kept for backward compatibility
    with older implementations. If an attacker can remove the preferred algorithm
    from the list of encryption algorithms supported by the client, he can force the
    server to use a weaker encryption scheme that will be easier to break. Thanks
    to the hash that covers all the messages exchanged by the server, the downgrade
    attack cannot occur against `ssh`. Algorithm agility is a key requirement for
    security protocols that need to evolve when encryption algorithms are broken by
    researchers. This agility cannot be used without care and signing a hash of all
    the messages exchanged is a technique that is frequently used to prevent downgrade
    attacks.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是服务器不仅验证Diffie-Hellman交换的结果，还验证交换过程中发送和接收的所有信息的哈希值。这很重要，可以防止降级攻击。降级攻击是一种攻击，其中主动攻击者修改通信主机（通常是客户端）发送的消息，以请求使用较弱的加密算法。考虑一个支持两种加密方案的客户端。首选方案使用128位密钥，第二个方案是一个旧的加密方案，使用48位密钥。这个第二个算法保留以与较老的实施方案保持向后兼容。如果攻击者可以从客户端支持的加密算法列表中删除首选算法，他可以迫使服务器使用一个较弱的加密方案，这将更容易被破解。多亏了覆盖服务器交换的所有消息的哈希值，降级攻击无法针对`ssh`发生。算法敏捷性是安全协议的关键要求，当加密算法被研究人员破解时，这些协议需要进化。这种敏捷性不能不加考虑地使用，签署所有交换消息的哈希值是一种常用于防止降级攻击的技术。
- en: Note
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Single use keys
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 单次使用密钥
- en: 'Thanks to the Diffie-Hellman key exchange, the client and the servers share
    key \(K\). A naive implementation would probably directly use this key for all
    the cryptographic algorithms that have been negotiated for this session. Like
    most security protocols, `ssh` does not directly use key \(K\). Instead, it uses
    the negotiated hash function with different parameters [[6]](#fsshkeys) to allow
    the client and the servers to compute six keys from \(K\) :'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Diffie-Hellman密钥交换，客户端和服务器共享密钥 \(K\)。一个简单的实现可能会直接使用这个密钥来执行会话中协商的所有加密算法。像大多数安全协议一样，`ssh`不会直接使用密钥
    \(K\)。相反，它使用协商的哈希函数和不同的参数 [[6]](#fsshkeys) 来允许客户端和服务器从 \(K\) 计算出六个密钥：
- en: a key used by the client (resp. server) to encrypt the data that it sends
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（或服务器）用于加密其发送数据的密钥
- en: ''
  id: totrans-1172
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a key used by the client (resp. server) to authenticate the data that it sends
  id: totrans-1174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（或服务器）用于验证其发送数据的密钥
- en: ''
  id: totrans-1175
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1176
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a key used by the client (resp. server) to initialize the negotiated encryption
    scheme (if required by this scheme)
  id: totrans-1177
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端（或服务器）用于初始化协商的加密方案（如果该方案需要）
- en: It is common practice among designers of security protocols to never use the
    same key for different purposes. For example, allowing the client and the server
    to use the same key to encrypt data could enable an attacker to launch a replay
    attack by sending to the client data that it has itself encrypted.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全协议的设计者中，通常的做法是不要为不同的目的使用相同的密钥。例如，允许客户端和服务器使用相同的密钥来加密数据可能会使攻击者能够通过向客户端发送它自己加密的数据来发起重放攻击。
- en: 'At this point, all the messages sent over the TCP connection will be encrypted
    with the negotiated keys. The `ssh` protocol uses messages that are encoded according
    to the Binary Packet Protocol defined in [**RFC 4253**](https://datatracker.ietf.org/doc/html/rfc4253.html).
    Each of these messages contains the following information :'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，通过TCP连接发送的所有消息都将使用协商的密钥进行加密。`ssh`协议使用根据[**RFC 4253**](https://datatracker.ietf.org/doc/html/rfc4253.html)中定义的二进制数据包协议编码的消息。这些消息中的每个都包含以下信息：
- en: '`length` : this is the length of the message in bytes, excluding the MAC and
    length fields'
  id: totrans-1180
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这是消息的字节数，不包括MAC和长度字段'
- en: ''
  id: totrans-1181
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1182
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`padding length` : this is the number of random bytes that have been added
    at the end of the message.'
  id: totrans-1183
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding length`：这是添加到消息末尾的随机字节数。'
- en: ''
  id: totrans-1184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1185
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`payload` : the data (after optional compression) passed by the user'
  id: totrans-1186
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payload`：用户传递的数据（在可选压缩之后）'
- en: ''
  id: totrans-1187
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1188
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`padding` : random bytes added in each message (at least four) to ensure that
    the message length is a multiple of the block size used by the negotiated encryption
    algorithm'
  id: totrans-1189
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding`：在每个消息中添加的随机字节（至少四个），以确保消息长度是协商的加密算法使用的块大小的倍数'
- en: ''
  id: totrans-1190
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1191
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MAC` : this field is present if a Message Authentication Code has been negotiated
    for the session (in practice, using `ssh` without authentication is risky and
    this field should always be present). Note that to compute the MAC, an `ssh` implementation
    must maintain a message counter. This counter is incremented by one every time
    a message is sent and the MAC is computed with the negotiated authentication algorithm
    using the MAC key over the concatenation of the message counter and the cleartext
    message. The message counter is not transmitted, but the recipient can easily
    recover its value. The `MAC` is computed as \(mac = MAC(key, sequence\_number
    || unencrypted\_message)\) where the key is the negotiated authentication key.'
  id: totrans-1192
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC`：如果会话已协商消息认证码，则此字段存在（在实践中，使用未经身份验证的`ssh`是危险的，并且此字段应始终存在）。请注意，为了计算MAC，`ssh`实现必须维护一个消息计数器。每次发送消息并计算MAC时，计数器都会增加一，使用协商的认证算法和MAC密钥通过消息计数器和明文消息的连接来计算MAC。消息计数器不传输，但接收方可以轻松恢复其值。`MAC`的计算方式为
    \(mac = MAC(key, sequence\_number || unencrypted\_message)\)，其中密钥是协商的认证密钥。'
- en: Note
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Authenticating messages with HMAC
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HMAC验证消息
- en: ssh is one example of a protocol that uses Message Authentication Codes (MAC)
    to authenticates the messages that are sent. A naive implementation of such a
    MAC would be to simply use a hash function like SHA-1\. However, such a construction
    would not be safe from a security viewpoint. Internet protocols usually rely on
    the HMAC construction defined in [**RFC 2104**](https://datatracker.ietf.org/doc/html/rfc2104.html).
    It works with any hash function (H) and a key (K). As an example, let us consider
    HMAC with the SHA-1 hash function. SHA-1 uses 20 bytes blocks and the block size
    will play an important role in the operation of HMAC. We first require the key
    to be as long as the block size. Since this key is the output of the key generation
    algorithm, this is one parameter of this algorithm.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: ssh 是一种使用消息认证码（MAC）来认证发送消息的协议的例子。这种 MAC 的一个简单实现可能是简单地使用像 SHA-1 这样的散列函数。然而，从安全角度来看，这种结构并不安全。互联网协议通常依赖于在
    [**RFC 2104**](https://datatracker.ietf.org/doc/html/rfc2104.html) 中定义的 HMAC 构造。它可以使用任何散列函数（H）和密钥（K）。作为一个例子，让我们考虑使用
    SHA-1 散列函数的 HMAC。SHA-1 使用 20 字节块，块大小将在 HMAC 的操作中扮演重要角色。我们首先需要密钥的长度与块大小相同。由于这个密钥是密钥生成算法的输出，这是该算法的一个参数。
- en: 'HMAC uses two padding strings : ipad (resp. opad) which is a string containing
    20 times byte `0x36` (resp. byte `0x5C`). The HMAC is then computed as \(H[K \oplus
    opad, H(K \oplus ipad, data) ]\) where \(\oplus\) denotes the bitwise XOR operation.
    This computation has been shown to be stronger than the naive \(H(K,data)\) against
    some types of cryptographic attacks.'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC 使用两个填充字符串：ipad（resp. opad），它是一个包含 20 个字节 `0x36`（resp. 字节 `0x5C`）的字符串。然后计算
    HMAC 为 \(H[K \oplus opad, H(K \oplus ipad, data) ]\)，其中 \(\oplus\) 表示位异或操作。这种计算已被证明比简单的
    \(H(K,data)\) 对抗某些类型的密码学攻击更强大。
- en: Among the various features of the `ssh` protocol, it is interesting to mention
    how users are authenticated by the server. The `ssh` protocol supports the classical
    username/password authentication (but both the username and the password are transmitted
    over the secure encrypted channel). In addition, `ssh` supports two authentication
    mechanisms that rely on public keys. To use the first one, each user needs to
    generate his/her own public/private key pair and store the public key on the server.
    To be authenticated, the user needs to sign a message containing his/her public
    key by using his/her private key. The server can easily verify the validity of
    the signature since it already knows the user’s public key. The second authentication
    scheme is designed for hosts that trust each other. Each host has a public/private
    key pair and stores the public keys of the other hosts that it trusts. This is
    typically used in environments such as university labs where each user could access
    any of the available computers. If Alice has logged on `computer1` and wants to
    execute a command on `computer2`, she can create an `ssh` session on this computer
    and type (again) her password. With the host-based authentication scheme, `computer1`
    signs a message with its private key to confirm that it has already authenticated
    Alice. `computer2` would then accept Alice’s session without asking for her credentials.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ssh` 协议的众多特性中，值得一提的是用户是如何被服务器认证的。`ssh` 协议支持经典的用户名/密码认证（但用户名和密码都是通过安全的加密通道传输的）。此外，`ssh`
    支持两种依赖于公钥的认证机制。要使用第一种，每个用户都需要生成自己的公钥/私钥对，并将公钥存储在服务器上。为了进行认证，用户需要使用自己的私钥签署包含其公钥的消息。由于服务器已经知道用户的公钥，它可以轻松地验证签名的有效性。第二种认证方案是为相互信任的主机设计的。每个主机都有一个公钥/私钥对，并存储它信任的其他主机的公钥。这通常用于像大学实验室这样的环境，其中每个用户都可以访问任何可用的计算机。如果
    Alice 已经登录到 `computer1` 并想在 `computer2` 上执行命令，她可以在这个计算机上创建一个 `ssh` 会话并再次输入她的密码。使用基于主机的认证方案，`computer1`
    使用其私钥签署一条消息以确认它已经认证了 Alice。然后 `computer2` 将接受 Alice 的会话而无需要求她的凭据。
- en: The `ssh` protocol includes other features that are beyond the scope of this
    book. Additional details may be found in [[BS2005]](../bibliography.html#bs2005).
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh` 协议包括其他一些超出了本书范围的功能。更多详细信息可以在 [[BS2005]](../bibliography.html#bs2005)
    中找到。'
- en: '## Transport Layer Security[#](#transport-layer-security "Link to this heading")'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '## 传输层安全性[#](#transport-layer-security "链接到这个标题")'
- en: 'The Transport Layer Security family of protocols were initially proposed under
    the name Secure Socket Layer (SSL). The first deployments used this name and many
    researchers still refer to this security protocol as SSL [[FKC1996]](../bibliography.html#fkc1996).
    In this chapter, we use the official name that was standardized by the IETF: TLS
    for Transport Layer Security.'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层安全性（TLS）协议族最初以安全套接字层（SSL）的名义提出。最初的部署使用了这个名称，许多研究人员仍然将这个安全协议称为SSL [[FKC1996](../bibliography.html#fkc1996)]。在本章中，我们使用由IETF标准化的官方名称：传输层安全性（TLS）。
- en: The TLS protocol was designed to be usable by a wide range of applications that
    use the transport layer to reliably exchange information. TLS is mainly used over
    the TCP protocol. There are variants of TLS that operate over SCTP [**RFC 3436**](https://datatracker.ietf.org/doc/html/rfc3436.html)
    or UDP [**RFC 6347**](https://datatracker.ietf.org/doc/html/rfc6347.html), but
    these are outside the scope of this chapter.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: TLS协议被设计成可以被广泛使用传输层以可靠交换信息的各种应用程序使用。TLS主要在TCP协议上使用。存在TLS的变体，它们在SCTP [**RFC 3436**](https://datatracker.ietf.org/doc/html/rfc3436.html)或UDP
    [**RFC 6347**](https://datatracker.ietf.org/doc/html/rfc6347.html)上运行，但这些超出了本章的范围。
- en: A TLS session operates over a TCP connection. TLS is responsible for the encryption
    and the authentication of the SDUs exchanged by the application layer protocol
    while TCP provides the reliable delivery of this encrypted and authenticated bytestream.
    TLS is used by many different application layer protocols. The most frequent ones
    are HTTP (HTTP over TLS is called HTTPS), SMTP [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)
    or POP and IMAP [**RFC 2595**](https://datatracker.ietf.org/doc/html/rfc2595.html),
    but proprietary application-layer protocols also use TLS [[AM2019]](../bibliography.html#am2019).
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: TLS会话在TCP连接上运行。TLS负责加密和验证应用层协议交换的SDU，而TCP提供加密和验证的字节流的可靠交付。TLS被许多不同的应用层协议使用。最常见的是HTTP（HTTP
    over TLS称为HTTPS）、SMTP [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)或POP和IMAP
    [**RFC 2595**](https://datatracker.ietf.org/doc/html/rfc2595.html)，但专有应用层协议也使用TLS
    [[AM2019](../bibliography.html#am2019)]。
- en: 'A TLS session can be initiated in two different ways. First, the application
    can use a dedicated TCP port number for application layer protocol x-over-TLS.
    This is the solution used by many HTTP servers that reserve port \(443\) for HTTP
    over TLS. This solution works, but it requires to reserve two ports for each application
    : one where the application-layer protocol is used directly over TCP and another
    one where the application-layer protocol is used over TLS. Given the limited number
    of TCP ports that are available, this is not a scalable solution. The table below
    provides some of the reserved port numbers for application layer protocols on
    top of TLS.'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: TLS会话可以通过两种不同的方式启动。首先，应用程序可以使用为应用层协议x-over-TLS保留的专用TCP端口号。这是许多HTTP服务器使用的解决方案，它们为TLS上的HTTP保留了端口号\(443\)。这个解决方案是可行的，但它需要为每个应用程序保留两个端口号：一个用于直接在TCP上使用应用层协议，另一个用于在TLS上使用应用层协议。鉴于可用的TCP端口号数量有限，这不是一个可扩展的解决方案。下表提供了TLS之上应用层协议的一些保留端口号。
- en: '| Application | TCP port | TLS port |'
  id: totrans-1204
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | TCP端口号 | TLS端口号 |'
- en: '| --- | --- | --- |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| POP3 | 110 | 995 |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '| POP3 | 110 | 995 |'
- en: '| IMAP | 143 | 993 |'
  id: totrans-1207
  prefs: []
  type: TYPE_TB
  zh: '| IMAP | 143 | 993 |'
- en: '| NNTP | 119 | 563 |'
  id: totrans-1208
  prefs: []
  type: TYPE_TB
  zh: '| NNTP | 119 | 563 |'
- en: '| HTTP | 80 | 443 |'
  id: totrans-1209
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | 80 | 443 |'
- en: '| FTP | 21 | 990 |'
  id: totrans-1210
  prefs: []
  type: TYPE_TB
  zh: '| FTP | 21 | 990 |'
- en: A second approach to initiate a TLS session is to use the standard TCP port
    number for the application layer protocol and define a special message in this
    protocol to trigger the start of the TLS session. This is the solution used for
    SMTP with the `STARTTLS` message. This extension to SMTP [**RFC 3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)
    defines the new STARTTLS command. The client can issue this command to indicate
    to the server that it wants to start a TLS session as shown in the example below
    captured during a session on port 25.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 启动TLS会话的第二种方法是使用应用层协议的标准TCP端口号，并在该协议中定义一个特殊消息来触发TLS会话的开始。这是用于SMTP的`STARTTLS`消息的解决方案。SMTP的这种扩展[**RFC
    3207**](https://datatracker.ietf.org/doc/html/rfc3207.html)定义了新的STARTTLS命令。客户端可以发出此命令，向服务器指示它想要启动一个TLS会话，如下面在端口25上的会话期间捕获的示例所示。
- en: '[PRE3]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the remaining parts of this chapter, we assume that the TLS session starts
    immediately after the establishment of the TCP connection. This corresponds to
    the deployments on web servers. We focus our presentation of TLS on this very
    popular use case. TLS is a complex protocol that supports other features than
    the one used by web servers. A more detailed presentation of TLS may be found
    in [[KPS2002]](../bibliography.html#kps2002) and [[Ristic2015]](../bibliography.html#ristic2015).
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们假设TLS会话在TCP连接建立后立即开始。这对应于Web服务器的部署。我们专注于介绍TLS的非常流行的用例。TLS是一个复杂的协议，支持除了Web服务器使用的功能之外的其他功能。更详细的TLS介绍可以在[[KPS2002]](../bibliography.html#kps2002)和[[Ristic2015]](../bibliography.html#ristic2015)中找到。
- en: 'A TLS session is divided in two phases: the handshake and the data transfer.
    During the handshake, the client and the server negotiate the security parameters
    and the keys that will be used to secure the data transfer. During the second
    phase, all the messages exchanged are encrypted and authenticated with the negotiated
    algorithms and keys.'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: TLS会话分为两个阶段：握手和数据传输。在握手阶段，客户端和服务器协商用于保护数据传输的安全参数和密钥。在第二阶段，所有交换的消息都使用协商的算法和密钥进行加密和验证。
- en: The TLS handshake[#](#the-tls-handshake "Link to this heading")
  id: totrans-1215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS握手[#](#the-tls-handshake "链接到本标题")
- en: 'When used to interact with a regular web server, the TLS handshake has three
    important objectives:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于与常规Web服务器交互时，TLS握手有三个重要目标：
- en: Securely negotiate the cryptographic algorithms that will be used by the client
    and the server over the TLS session
  id: totrans-1217
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全协商客户端和服务器在TLS会话中将使用的加密算法
- en: ''
  id: totrans-1218
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1219
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that the client interacts with a valid server
  id: totrans-1220
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证客户端与有效的服务器交互
- en: ''
  id: totrans-1221
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1222
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Securely agree on the keys that will be used to encrypt and authenticate the
    messages exchanged over the TLS session
  id: totrans-1223
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全地协商用于加密和验证TLS会话中交换的消息的密钥
- en: The TLS handshake is a four-way handshake illustrated in the figure below.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: TLS握手是一个四路握手，如图所示。
- en: '![msc {'
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Client",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random]", arcskip="2"];
  id: totrans-1232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random]", arcskip="2"];
- en: '|||;'
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random], Certificate", arcskip="2"];
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random], Certificate", arcskip="2"];
- en: '|||;'
  id: totrans-1236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
- en: '|||;'
  id: totrans-1239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
  id: totrans-1241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
- en: '|||;'
  id: totrans-1242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", linecolour="red", textcolour="red"];
  id: totrans-1244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Encrypted Record", linecolour="red", textcolour="red"];
- en: b>>c [ label = "Encrypted Record", linecolour="red", textcolour="red"];
  id: totrans-1245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Encrypted Record", linecolour="red", textcolour="red"];
- en: '}](../Images/300581e55a5559d21fa138b6759650ca.png)<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3"
    name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"></map>'
  id: totrans-1246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/300581e55a5559d21fa138b6759650ca.png)<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3"
    name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"></map>'
- en: In a nutshell, the client starts the TLS handshake by proposing a random nonce.
    The server replies with its random nonce and a certificate that binds its name
    to a public key. The client generates a MasterSecret that will be used later to
    derive the session keys and encrypts it with the public key of the server. It
    also generates a Finished message that contains a MAC of all the messages exchanged
    to allow the server to detect any modification of the messages sent by the client.
    The server also sends its own Finished message. At that point, the client and
    the server sent encrypted records thanks to the keys derived from the MasterSecret.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，客户端通过提出一个随机数来启动TLS握手。服务器回复其随机数和一个将名称绑定到公钥的证书。客户端生成一个MasterSecret，稍后将用于派生会话密钥，并用服务器的公钥加密它。它还生成一个包含所有交换消息的MAC的Finished消息，以便服务器能够检测客户端发送的消息的任何修改。服务器也发送其自己的Finished消息。此时，客户端和服务器通过从MasterSecret派生的密钥发送加密记录。
- en: 'Let us first discuss the negotiation of the cryptographic algorithms and parameters.
    Like all security protocols, TLS includes some agility in its design since new
    cryptographic algorithms appear over the years and some older algorithms become
    deprecated once cryptanalysts find flaws. The TLS handshakes starts with the `ClientHello`
    message that is sent by the client. This message carries the following information
    :'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论加密算法和参数的协商。像所有安全协议一样，TLS 在其设计中包含了一些灵活性，因为随着时间的推移，新的加密算法出现，而一些较老的算法一旦密码分析员发现漏洞，就会变得过时。TLS
    握手过程从客户端发送的 `ClientHello` 消息开始。此消息包含以下信息：
- en: 'Protocol version number: this is the version of the TLS protocol supported
    by the client. The server should use the same version of the TLS protocol as the
    client, but may opt for an older version. Both versions 1.2 and 1.3 of TLS are
    deployed today. Older versions are being deprecated.'
  id: totrans-1249
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议版本号：这是客户端支持的 TLS 协议版本。服务器应使用与客户端相同的 TLS 协议版本，但可以选择较旧的版本。目前部署了 TLS 的 1.2 和
    1.3 两个版本。较旧的版本正在被弃用。
- en: ''
  id: totrans-1250
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1251
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Random number: security protocols rely on random numbers. The client sends
    a 32 bytes long random number where usually four of these bytes correspond to
    the client’s clock. This random number is used, together with the server’s random
    number, as a seed to generate the security keys.'
  id: totrans-1252
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数：安全协议依赖于随机数。客户端发送一个 32 字节长的随机数，其中通常有四个字节对应于客户端的时钟。这个随机数与服务器端的随机数一起用作生成安全密钥的种子。
- en: ''
  id: totrans-1253
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1254
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Cipher suites : this ordered list contains the set of cryptographic algorithms
    that are supported by the client, with the most preferred one listed first. In
    contrast with `ssh` that allows negotiating independent algorithms for encryption,
    key exchange and authentication, TLS relies on suites that combine these algorithms
    together. Many cryptographic suites have been defined for TLS. Various recommendations
    have been published on the security of some of these suites [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html).'
  id: totrans-1255
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码套件：这个有序列表包含客户端支持的加密算法集合，最优先的算法列在首位。与允许协商独立加密、密钥交换和认证算法的 `ssh` 相比，TLS 依赖于将这些算法组合在一起的套件。为
    TLS 定义了许多密码套件。关于这些套件中的一些套件的安全性已经发布了各种建议 [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html)。
- en: ''
  id: totrans-1256
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1257
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compression algorithm : the client may propose the utilization of a specific
    compression algorithm (e.g. zlib). In theory, compressing the data before encrypting
    it is an intelligent way to reduce the amount of data exchanged. Unfortunately,
    its implementation in TLS has caused several security problems [[PHG2013]](../bibliography.html#phg2013).
    For this reason, compression is usually disabled in TLS [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html).'
  id: totrans-1258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩算法：客户端可以提议使用特定的压缩算法（例如 zlib）。理论上，在加密之前压缩数据是一种智能的方法来减少交换的数据量。不幸的是，TLS 中的实现导致了几个安全问题
    [[PHG2013]](../bibliography.html#phg2013)。因此，压缩通常在 TLS 中被禁用 [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html)。
- en: ''
  id: totrans-1259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extensions : TLS supports various extensions in the `ClientHello` message.
    These extensions [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    are important to allow the protocol to evolve, but many of them go beyond the
    scope of this chapter.'
  id: totrans-1261
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：TLS 支持在 `ClientHello` 消息中的各种扩展。这些扩展 [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    对于协议的演变很重要，但其中许多超出了本章的范围。
- en: Note
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Server Name Indication (SNI)`
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server Name Indication (SNI)`'
- en: The `Server Name Indication (SNI)` extension defined in [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    is an important TLS extension for web servers. It is used by the client to indicate
    the name of the server that it wishes to contact. The IP address associated to
    this name has been queried from the DNS and used to establish the TCP connection.
    Why should the client indicate the server name in the TLS `ClientHello` ? The
    motivation is the same as for the `Host` header line in HTTP/1.0\. With the SNI
    extension, a single TLS server can support several web sites that use different
    domain names. Thanks to the SNI extension, the server knows the concerned domain
    name at the start of the TLS session. Without this extension, hosting providers
    would have been forced use one IP address per TLS-enabled server.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html) 中定义的 `Server
    Name Indication (SNI)` 扩展是针对 Web 服务器的关键 TLS 扩展。客户端使用它来指示它希望联系的服务器名称。与该名称关联的 IP
    地址已从 DNS 中查询并用于建立 TCP 连接。为什么客户端需要在 TLS `ClientHello` 中指示服务器名称？动机与 HTTP/1.0 中的
    `Host` 报头行相同。有了 SNI 扩展，单个 TLS 服务器可以支持使用不同域名的大量网站。多亏了 SNI 扩展，服务器在 TLS 会话开始时就知道相关的域名。如果没有这个扩展，托管提供商将被迫为每个启用了
    TLS 的服务器使用一个 IP 地址。
- en: 'The server replies to the `ClientHello` with several messages:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通过几条消息回复 `ClientHello`：
- en: the `ServerHello` message that contains the protocol version chosen by the server
    (assumed to be the same as the client version in this chapter), the 32 random
    bytes chosen by the server, the Cipher Suite selected by the server from the list
    advertised by the client and a Session Id. This Session Id is an identifier which
    is chosen by the server. It identifies the TLS session and the security parameters
    (algorithms and keys) negotiated for this session. It is used to support session
    resumption.
  id: totrans-1266
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含服务器选择的协议版本（在本章中假设与客户端版本相同）、服务器选择的 32 个随机字节、从客户端广告的列表中选择的 Cipher Suite 以及会话
    ID 的 `ServerHello` 消息。此会话 ID 是由服务器选择的标识符。它标识 TLS 会话以及为此会话协商的安全参数（算法和密钥）。它用于支持会话恢复。
- en: ''
  id: totrans-1267
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1268
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `Certificate` message provides the certificate (or usually a chain of certificates)
    that binds a domain name to the public key used by the server. TLS uses the server
    certificates to authenticate the server. It relies on a Public Key Infrastructure
    that is composed of a set of root certification authorities that issue certificates
    to certification authorities that in the end issue certificates to servers. TLS
    clients are usually configured with the public keys of several root certification
    authorities and use this information to validate the certificates that they receive
    from servers. For historical reasons, the TLS certificates are encoded in ASN.1
    format. The details of the ASN.1 syntax [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    are outside the scope of this book.
  id: totrans-1269
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Certificate` 消息提供了将域名绑定到服务器使用的公钥的证书（或通常是一系列证书）。TLS 使用服务器证书来验证服务器。它依赖于一个由一组根证书颁发机构组成的公钥基础设施，这些根证书颁发机构向证书颁发机构颁发证书，最终向服务器颁发证书。TLS
    客户端通常配置有多个根证书颁发机构的公钥，并使用这些信息来验证从服务器收到的证书。由于历史原因，TLS 证书以 ASN.1 格式编码。ASN.1 语法的详细信息
    [[Dubuisson2000]](../bibliography.html#dubuisson2000) 不在本书的范围之内。'
- en: ''
  id: totrans-1270
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1271
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `ServerKeyExchange` message is used by the server to transmit the information
    that is required to perform the key exchange. The content of this message is function
    of the selected key exchange algorithm.
  id: totrans-1272
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerKeyExchange` 消息由服务器用来传输执行密钥交换所需的信息。此消息的内容是所选密钥交换算法的函数。'
- en: ''
  id: totrans-1273
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1274
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `ServerHelloDone` indicates that the server has sent all the messages for
    the first phase of the handshake.
  id: totrans-1275
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerHelloDone` 表示服务器已发送握手第一阶段的所有消息。'
- en: 'At this point, it is time to describe the TLS key exchange. TLS supports different
    key exchange mechanisms that can be negotiated as part of the selection of the
    cipher suite. We focus on two of them to highlight their differences:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，是时候描述 TLS 密钥交换了。TLS 支持不同的密钥交换机制，这些机制可以作为选择加密套件的一部分进行协商。我们关注其中的两个，以突出它们之间的差异：
- en: '`RSA`. This key exchange algorithm uses the encryption capabilities of the
    RSA public-key algorithm. The client has validated the server’s public key thanks
    to the `Certificate` message. It then generates a (48 bytes) random number, encrypts
    it with the server public key and sends the encrypted number to the server in
    the `ClientKeyExchange` message. The server uses its private key to decrypt the
    random number. At this point, the client and the server share the same (48 bytes
    long) secret and use it to derive the secret keys required to encrypt and authenticate
    data in the second phase. With this key exchange algorithm, the server does not
    need to send a `ServerKeyExchange` message.'
  id: totrans-1277
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSA`. 这种密钥交换算法使用了RSA公钥算法的加密能力。客户端通过`Certificate`消息验证了服务器的公钥。然后它生成一个（48字节）的随机数，使用服务器公钥对其进行加密，并在`ClientKeyExchange`消息中将加密后的数字发送到服务器。服务器使用其私钥解密随机数。此时，客户端和服务器共享相同的（48字节长）密钥，并使用它来生成第二阶段加密和验证数据所需的密钥。使用这种密钥交换算法，服务器不需要发送`ServerKeyExchange`消息。'
- en: ''
  id: totrans-1278
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1279
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DHE_RSA`. This key exchange algorithm is the Ephemeral Diffie Hellman key
    exchange with RSA signatures to authenticate the key exchange. It operates as
    a classical authenticated Diffie Hellman key exchange. If this key exchange has
    been selected by the server, it sends its Diffie Hellman parameters in the `ServerKeyExchange`
    message and signs them with its private key. The client then continues the key
    exchange and sends the results of its own computation in the `ClientKeyExchange`
    message. `DHE_RSA` is thus an authenticated Diffie Hellman key exchange where
    the initial message is sent by the server (instead of the client as in our first
    example but since the protocol is symmetric, this does not matter).'
  id: totrans-1280
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DHE_RSA`。这种密钥交换算法是带有RSA签名的临时Diffie-Hellman密钥交换，用于验证密钥交换。它作为一个经典的认证Diffie-Hellman密钥交换操作。如果服务器选择了这种密钥交换，它将在`ServerKeyExchange`消息中发送其Diffie-Hellman参数，并使用其私钥对其进行签名。然后客户端继续密钥交换，并在`ClientKeyExchange`消息中发送其计算结果。因此，`DHE_RSA`是一个认证的Diffie-Hellman密钥交换，其中初始消息是由服务器发送的（而不是像我们的第一个示例中的客户端，但由于协议是对称的，这并不重要）。'
- en: An important difference between `DHE_RSA` and `RSA` is their reaction against
    attacks. `DHE_RSA` is considered by many to be stronger than `RSA` because it
    supports Perfect Forward Secrecy. This property is important against attackers
    that are able to eavesdrop all the (encrypted) data sent and received by a server.
    Consider that Terrence is such an attacker that has stored all the packets exchanged
    by Bob’s server during the last six months. If he manages, by any means, to obtain
    Bob’s private key, he will be able to decrypt all the keys used to secure the
    TLS sessions with Bob’s server during this period. With `DHE_RSA`, a similar attack
    is less devastating. If Terrence knows Bob’s private key, he will be able to launch
    a man-in-the-middle attack against future TLS sessions with Bob’s server. However,
    he will not be able to recover the keys used for all the past sessions that he
    captured.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '`DHE_RSA`和`RSA`之间的重要区别在于它们对攻击的反应。许多人认为`DHE_RSA`比`RSA`更强大，因为它支持完美前向安全性。这种特性对于能够监听服务器发送和接收的所有（加密）数据的攻击者来说非常重要。假设特伦斯是这样的攻击者，他在过去六个月内存储了鲍勃服务器交换的所有数据包。如果他设法以任何方式获得鲍勃的私钥，他将能够解密在此期间用于保护与鲍勃服务器TLS会话的所有密钥。使用`DHE_RSA`，类似的攻击破坏性较小。如果特伦斯知道鲍勃的私钥，他将对鲍勃服务器的未来TLS会话发起中间人攻击。然而，他无法恢复他捕获的所有过去会话中使用的密钥。'
- en: Note
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Perfect Forward Secrecy
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 完美前向安全性
- en: Perfect Forward Secrecy (PFS) is an important property for key exchange protocols.
    A protocol provides PFS if its design guarantees that the keys used for former
    sessions will not be compromised even if the private key of the server is compromised.
    This is a very important property. `DHE_RSA` provides Perfect Forward Secrecy,
    but the `RSA` key exchange does not provide this property. In practice, `DHE_RSA`
    is costly from a computational viewpoint. Recent implementations of TLS thus prefer
    `ECDHE_RSA` or `ECDHE_ECDSA` when Perfect Forward Secrecy is required.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 完美前向安全性（PFS）是密钥交换协议的重要特性。如果协议的设计保证即使服务器的私钥被泄露，以前会话使用的密钥也不会受到损害，则该协议提供PFS。这是一个非常重要的特性。`DHE_RSA`提供完美前向安全性，但`RSA`密钥交换不提供此特性。在实践中，`DHE_RSA`在计算上成本较高。因此，最新的TLS实现当需要完美前向安全性时，更倾向于使用`ECDHE_RSA`或`ECDHE_ECDSA`。
- en: All the information required for the key exchange has now been transmitted.
    There are two important messages that will be sent by the client and the server
    to conclude the handshake and start the data transfer phase.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于密钥交换所需的信息现在都已传输。客户端和服务器将发送两个重要消息来结束握手并开始数据传输阶段。
- en: The client sends the `ChangeCipherSpec` message followed by the `Finished` message.
    The `ChangeCipherSpec` message indicates that the client has received all the
    information required to generate the security keys for this TLS session. This
    messages can also appear later in the session to indicate a change in the encryption
    algorithms that are used, but this usage is outside the scope of this book. The
    `Finished` message is more important. It confirms to the server that the TLS handshake
    has been performed correctly and that no attacker has been able to modify the
    data sent by the client or the server. This is the first message that is encrypted
    with the selected security keys. It contains a hash of all the messages that were
    exchanged during the handshake.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送`ChangeCipherSpec`消息，随后是`Finished`消息。`ChangeCipherSpec`消息表示客户端已接收到生成此TLS会话安全密钥所需的所有信息。此消息也可以在会话的后期出现，以指示加密算法的改变，但这种用法超出了本书的范围。`Finished`消息更为重要。它向服务器确认TLS握手已正确执行，且没有攻击者能够修改客户端或服务器发送的数据。这是第一个使用所选安全密钥加密的消息。它包含握手期间交换的所有消息的散列值。
- en: The server also sends a `ChangeCipherSpec` message followed by a `Finished`
    message.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还会发送一个`ChangeCipherSpec`消息，随后是一个`Finished`消息。
- en: Note
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: TLS Cipher suites
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: TLS加密套件
- en: A TLS cipher suite is usually represented as an ASCII string that starts with
    TLS and contains the acronym of the key exchange algorithm, the encryption scheme
    with the key size and its mode of operation and the authentication algorithm.
    For example, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256` is a TLS cipher suite that
    uses the `DHE_RSA` key exchange algorithm with 128 bits AES in GCM mode for encryption
    and SHA-256 for authentication. The official list of TLS cipher suites is maintained
    by IANA [[7]](#fianatls). The NULL acronym indicates that no algorithm has been
    specified. For example, `TLS_ECDH_RSA_WITH_NULL_SHA` is a cipher suite that does
    not use any encryption but still uses the `ECDH_RSA` key exchange and `SHA` for
    authentication.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: TLS加密套件通常表示为一个以TLS开头并包含密钥交换算法缩写、密钥大小的加密方案及其操作模式和认证算法的ASCII字符串。例如，`TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`是一个使用`DHE_RSA`密钥交换算法，以128位AES在GCM模式下加密，并使用SHA-256进行认证的TLS加密套件。TLS加密套件的官方列表由IANA维护[[7]](#fianatls)。NULL缩写表示未指定任何算法。例如，`TLS_ECDH_RSA_WITH_NULL_SHA`是一个不使用任何加密但仍然使用`ECDH_RSA`密钥交换和`SHA`进行认证的加密套件。
- en: The TLS record protocol[#](#the-tls-record-protocol "Link to this heading")
  id: totrans-1291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS记录协议[#](#the-tls-record-protocol "链接到本标题")
- en: The handshake is now finished. The client and the server will exchange authenticated
    and encrypted records. TLS defines different formats for the records depending
    on the cryptographic algorithms that have been negotiated for the session. A detailed
    discussion of these different types of records is outside the scope of this introduction.
    For illustration, we briefly describe one record format.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在握手已经完成。客户端和服务器将交换经过验证和加密的记录。TLS根据会话中协商的加密算法定义了记录的不同格式。这些不同类型记录的详细讨论超出了本介绍的范畴。为了说明，我们简要描述一种记录格式。
- en: As other security protocols, TLS uses different keys to encrypt and authenticate
    records. These keys are derived from the MasterSecret that is either randomly
    generated by the client after the `RSA` key exchange or derived from the Diffie
    Hellman parameters after the `DH_RSA` key exchange. The exact algorithm used to
    derive the keys is defined in [**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html).
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他安全协议一样，TLS使用不同的密钥来加密和验证记录。这些密钥是从MasterSecret派生出来的，MasterSecret是在`RSA`密钥交换后由客户端随机生成的，或者在`DH_RSA`密钥交换后从Diffie
    Hellman参数派生出来的。用于派生密钥的确切算法在[**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)中定义。
- en: 'A TLS record is always composed of four different fields :'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: TLS记录始终由四个不同的字段组成：
- en: a Type that indicates the type of record. The most frequent type is application
    data which corresponds to a record containing encrypted data. The other types
    are handshake, change_cipher_spec and alert.
  id: totrans-1295
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型，表示记录的类型。最常见的是应用数据，对应于包含加密数据的记录。其他类型包括握手、更改密钥规范和警报。
- en: ''
  id: totrans-1296
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1297
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a Protocol Version field that indicates the version of the TLS protocol used.
    This version is composed of two sub fields : a major and a minor version number.'
  id: totrans-1298
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示TLS协议版本的协议版本字段。这个版本由两个子字段组成：主版本号和次版本号。
- en: ''
  id: totrans-1299
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1300
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Length field. A TLS record cannot be longer than 16,384 bytes.
  id: totrans-1301
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个长度字段。TLS记录的长度不能超过16,384字节。
- en: ''
  id: totrans-1302
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1303
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a TLSPlainText that contains the encrypted data
  id: totrans-1304
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含加密数据的TLSPlainText
- en: 'TLS supports several methods to encrypted records. The selected method depends
    on the cryptographic algorithms that have been negotiated for the TLS session.
    A detailed presentation of the different methods that can be used to produce the
    TLSPlainText from the user data is outside the scope of this book. As an example,
    we study one method: Stream Encryption. This method is used with cryptographic
    algorithms which can operate on a stream of bytes. The method starts with a sequence
    of bytes provided by the user application: the plain text. The first step is to
    compute the authentication code to verify the integrity of the data. For this,
    TLS computes \(MAC(SeqNum, Header, PlainText)\) using HMAC where SeqNum is a sequence
    number which is incremented by one for each new TLS record transmitted. The Header
    is the header of the TLS record described above and PlainText is the information
    that needs to be encrypted. Note that the sequence number is maintained at the
    two endpoints of the TLS session, but it is not transmitted inside the TLS record.
    This sequence number is used to prevent replay attacks.'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: TLS支持多种加密记录的方法。选择的方法取决于TLS会话中协商的加密算法。关于如何从用户数据生成TLSPlainText的不同方法的详细说明超出了本书的范围。作为一个例子，我们研究了一种方法：流加密。这种方法与可以操作字节流的加密算法一起使用。该方法从用户应用程序提供的字节序列开始：明文。第一步是计算认证码以验证数据的完整性。为此，TLS使用HMAC计算
    \(MAC(SeqNum, Header, PlainText)\)，其中SeqNum是一个序列号，每次传输一个新的TLS记录时增加一。Header是上述TLS记录的头部，PlainText是需要加密的信息。请注意，序列号在TLS会话的两个端点维护，但不会在TLS记录中传输。这个序列号用于防止重放攻击。
- en: Note
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MAC-then-encrypt or Encrypt-then-MAC
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: MAC-then-encrypt 或 Encrypt-then-MAC
- en: When secure protocols use Message Authentication and Encryption, they need to
    specify how these two algorithms are combined. A first solution, which is used
    by the current version of TLS, is to compute the authentication code and then
    encrypt both the data and the authentication code. A drawback of this approach
    is that the receiver of an encrypted TLS record must first attempt to decrypt
    data that has potentially been modified by an attacker before being able to verify
    the authenticity of the record. A better approach is for the sender to first encrypt
    the data and then compute the authentication code over the encrypted data. This
    is the encrypt-then-MAC approach proposed in [**RFC 7366**](https://datatracker.ietf.org/doc/html/rfc7366.html).
    With encrypt-then-MAC, the receiver first checks the authentication code before
    attempting to decrypt the record.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全协议使用消息认证和加密时，它们需要指定这两个算法如何结合。一个解决方案，即当前TLS版本所使用的，是先计算认证码，然后加密数据和认证码。这种方法的一个缺点是，接收加密TLS记录的接收者必须首先尝试解密可能被攻击者修改过的数据，然后才能验证记录的真实性。一个更好的方法是发送者首先加密数据，然后对加密数据计算认证码。这就是在[**RFC
    7366**](https://datatracker.ietf.org/doc/html/rfc7366.html)中提出的encrypt-then-MAC方法。使用encrypt-then-MAC，接收者首先检查认证码，然后再尝试解密记录。
- en: Improving TLS[#](#improving-tls "Link to this heading")
  id: totrans-1309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进TLS[#](#improving-tls "链接到这个标题")
- en: During the last two decades, the deployment of TLS has continued to grow. The
    early TLS servers were only used for critical services such as e-commerce websites
    or online banks. As CPU performance improved, it became much more cost-effective
    to use TLS to secure non-critical parts of web servers, including the delivery
    of HTML pages and even video services. There is now a growing number of applications
    that rely on TLS [[AM2019]](../bibliography.html#am2019).
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，TLS的部署持续增长。早期的TLS服务器仅用于关键服务，如电子商务网站或在线银行。随着CPU性能的提高，使用TLS来保护Web服务器上的非关键部分，包括HTML页面的交付甚至视频服务，变得更加经济高效。现在有越来越多的应用程序依赖于TLS
    [[AM2019]](../bibliography.html#am2019)。
- en: In 2013, the statistics collected by the Firefox Telemetry project [[9]](#ftelemetry)
    revealed that 30% of the web pages loaded by Firefox users were done over HTTPS.
    In October 2019, 80% of the web pages are loaded over HTTPS. In six years, HTTPS
    became the dominant protocol to access web services. Another look at the deployment
    of HTTPS on web sites may be found in [[Helme2019]](../bibliography.html#helme2019).
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Firefox遥测项目 [[9]](#ftelemetry) 收集的统计数据显示，Firefox用户加载的网页中有30%是通过HTTPS完成的。到2019年10月，80%的网页是通过HTTPS加载的。在六年的时间里，HTTPS已成为访问网络服务的占主导地位的协议。有关网站HTTPS部署的另一个看法可以在
    [[Helme2019]](../bibliography.html#helme2019) 中找到。
- en: Measurement studies that analyzed the evolution of TLS over the years have identified
    several important changes in the TLS ecosystem [[KRA2018]](../bibliography.html#kra2018).
    First, the preferred cryptographic algorithms have changed. While RC4 was used
    by 60% of the connections in 2012, its usage has dropped since 2015\. AES started
    to be deployed in 2013 and is now used for more than 90% of the connections. The
    deployed versions of TLS have also changed. TLS 1.0 and TLS 1.1 are now rarely
    used. The deployment of TLS 1.2 started in 2013 and reached 70% of the connections
    in 2015\. Version 1.3 of TLS, that is described below, is also widely deployed.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 分析了多年来TLS演变的测量研究已经确定了TLS生态系统中的一些重要变化 [[KRA2018]](../bibliography.html#kra2018)。首先，首选的加密算法已经改变。虽然2012年60%的连接使用了RC4，但自2015年以来其使用率已经下降。AES自2013年开始部署，现在被用于超过90%的连接。部署的TLS版本也有所改变。TLS
    1.0和TLS 1.1现在很少使用。TLS 1.2的部署始于2013年，到2015年达到了70%的连接。下面描述的TLS 1.3版本也得到了广泛部署。
- en: Another interesting fact is the key exchange schemes. In 2012, RSA was the dominant
    solution, used by more than 80% of the observed connections [[KRA2018]](../bibliography.html#kra2018).
    In 2013, Edward Snowden revealed the surveillance activities of several governments.
    These revelations had a huge impact on the Internet community. The IETF, which
    standardizes Internet protocols, considered in [**RFC 7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)
    that such pervasive monitoring was an attack. Since then, several IETF working
    groups have developed solutions to counter pervasive monitoring. One of these
    solutions is to encourage Perfect Forward Security. Within TLS, this implies replacing
    RSA by an authenticated Diffie Hellman key exchange such as ECDHE. Measurements
    indicate that since summer 2014, ECDHE is more popular than RSA. In 2018, more
    than 90% of the observed TLS connections used ECDHE.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事实是密钥交换方案。2012年，RSA是主导解决方案，被观察到的超过80%的连接使用 [[KRA2018]](../bibliography.html#kra2018)。2013年，爱德华·斯诺登揭露了几个政府的监控活动。这些揭露对互联网社区产生了巨大影响。作为互联网协议标准化的机构，IETF在
    [**RFC 7258**](https://datatracker.ietf.org/doc/html/rfc7258.html) 中认为这种普遍的监控是一种攻击。从那时起，几个IETF工作组开发了对抗普遍监控的解决方案。其中一种解决方案是鼓励完美前向安全性。在TLS中，这意味着用经过身份验证的Diffie-Hellman密钥交换（如ECDHE）来替换RSA。测量表明，自2014年夏季以来，ECDHE比RSA更受欢迎。到2018年，观察到的超过90%的TLS连接使用了ECDHE。
- en: The last point is the difficulty of deploying TLS servers [[KMS2017]](../bibliography.html#kms2017).
    When TLS servers are installed, the system administrator needs to obtain certificates
    and configure a range of servers. Initially, getting certificates was complex
    and costly, but initiatives such as [https://letsencrypt.org](https://letsencrypt.org)
    have simplified this workflow.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是部署TLS服务器的难度 [[KMS2017]](../bibliography.html#kms2017)。当TLS服务器安装后，系统管理员需要获取证书并配置一系列服务器。最初，获取证书是复杂且昂贵的，但诸如[https://letsencrypt.org](https://letsencrypt.org)这样的倡议简化了这一工作流程。
- en: 'In 2014, the IETF TLS working started to work on the development of version
    1.3 of the TLS protocol. Their main objectives [[Rescorla2015]](../bibliography.html#rescorla2015)
    for this new version were:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，IETF TLS工作组开始致力于开发TLS协议的1.3版本。他们为此新版本的主要目标 [[Rescorla2015]](../bibliography.html#rescorla2015)
    是：
- en: simplify the design by removing unused or unsafe protocol features
  id: totrans-1316
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过删除未使用或不安全的协议功能来简化设计
- en: ''
  id: totrans-1317
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1318
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: improve the security of TLS by leveraging the lessons learned from TLS 1.2 and
    some documented attacks
  id: totrans-1319
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用从TLS 1.2和某些已记录的攻击中学到的经验来提高TLS的安全性
- en: ''
  id: totrans-1320
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1321
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: improve the privacy of the protocol
  id: totrans-1322
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高协议的隐私性
- en: ''
  id: totrans-1323
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1324
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: reduce the latency of TLS
  id: totrans-1325
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少TLS的延迟
- en: Since 2014, latency has become an important concern for web services. As access
    networks bandwidth continue to grow, latency is becoming a key factor that affects
    the performance of interactive web services. With TLS 1.2, the download of a web
    page requires a minimum of four round-trip-times, one to create the underlying
    TCP connection, one to exchange the ClientHello/ServerHello, one to exchange the
    keys and then one to send the HTTP GET and retrieve the response. This can be
    very long when the server is not near the client. TLS 1.3 aimed at reducing this
    handshake to one round-trip-time and even zero by placing some of the cryptographic
    handshake in the TCP handshake. This part will be discussed in the TCP chapter.
    We focus here on the reducing the TLS handshake to a single round-trip-time.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 自2014年以来，延迟已成为网络服务的一个重要关注点。随着接入网络的带宽持续增长，延迟正成为影响交互式网络服务性能的关键因素。使用TLS 1.2时，下载一个网页至少需要四次往返时间，一次用于创建底层TCP连接，一次用于交换ClientHello/ServerHello，一次用于交换密钥，然后一次用于发送HTTP
    GET请求并检索响应。当服务器不在客户端附近时，这可能非常耗时。TLS 1.3旨在通过将部分加密握手操作放在TCP握手中来将此握手减少到一次往返时间甚至零。这部分内容将在TCP章节中讨论。我们在这里关注的是将TLS握手减少到单次往返时间。
- en: To simplify both the design and the implementations, TLS 1.3 uses only a small
    number of cipher suites. Five of them are specified in [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)
    and `TLS_AES_128_GCM_SHA256` must be supported by all implementations. To ensure
    privacy, all cipher suites that did not provide Perfect Forward Secrecy have been
    removed. Compression has also been removed from TLS since several attacks on TLS
    1.2 exploited its compression capability [**RFC 7457**](https://datatracker.ietf.org/doc/html/rfc7457.html).
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设计和实现，TLS 1.3仅使用少量加密套件。其中五个在[**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)中指定，并且所有实现都必须支持`TLS_AES_128_GCM_SHA256`。为了确保隐私，所有未提供完美前向安全的加密套件都已移除。自TLS
    1.2的压缩功能被多次攻击利用以来，压缩也已被从TLS中移除[**RFC 7457**](https://datatracker.ietf.org/doc/html/rfc7457.html)。
- en: Note
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Enterprises, privacy and TLS
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 企业、隐私和TLS
- en: By supporting only cipher suites that provide Perfect Forward Secrecy in TLS
    1.3, the IETF aims at protecting the privacy of users against a wide range of
    attacks. However, this choice has resulted in intense debates in some enterprises.
    Some enterprises, notably in financial organizations, have deployed TLS, but wish
    to be able to decrypt TLS traffic for various security-related activities. These
    enterprises tried to lobby within the IETF to maintain RSA-based cipher suites
    that do not provide Perfect Forward Secrecy. Their arguments did not convince
    the IETF. Eventually, these enterprises moved to ETSI, another standardization
    body, and convinced them to adopt entreprise TLS, a variant of TLS 1.3 that does
    not provide Perfect Forward Secrecy [[eTLS2018]](../bibliography.html#etls2018).
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅支持在TLS 1.3中提供完美前向安全的加密套件，IETF旨在保护用户免受各种攻击的隐私。然而，这种选择在一些企业中引发了激烈的辩论。一些企业，特别是在金融机构中，已经部署了TLS，但希望能够解密TLS流量以进行各种安全相关活动。这些企业试图在IETF内部游说，以维持不提供完美前向安全的基于RSA的加密套件。他们的论点没有说服IETF。最终，这些企业转向了ETSI，另一个标准化机构，并说服他们采用企业TLS，这是一种不提供完美前向安全的TLS
    1.3变体[[eTLS2018]](../bibliography.html#etls2018)。
- en: The TLS 1.3 handshake differs from the TLS 1.2 handshake in several ways. First,
    the TLS 1.3 handshake requires a single round-trip-time when the client connects
    for the first time to a server. To achieve this, the TLS designers look at the
    TLS 1.2 handshake in details and found that the first round-trip-time is mainly
    used to select the set of cryptographic algorithms and the cryptographic exchange
    scheme that will be used over the TLS session. TLS 1.3 drastically simplifies
    this negotiation by requiring to use the Diffie Hellman exchange with a small
    set of possible parameters. This means that the client can guess the parameters
    used by the server (i.e. the modulus, p and the base g) and immediately start
    the Diffie Hellman exchange. A simplified version of the TLS 1.3 handshake is
    shown in the figure below.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3握手与TLS 1.2握手在几个方面有所不同。首先，当客户端首次连接到服务器时，TLS 1.3握手需要单次往返时间。为了实现这一点，TLS设计者详细研究了TLS
    1.2握手，并发现第一次往返时间主要用于选择将在TLS会话中使用的加密算法和加密交换方案。TLS 1.3通过要求使用具有小参数集的Diffie-Hellman交换来极大地简化了这一协商过程。这意味着客户端可以猜测服务器使用的参数（即模数p和基数g），并立即开始Diffie-Hellman交换。下面图示展示了简化版的TLS
    1.3握手。
- en: '![msc {'
  id: totrans-1332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Client",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c]", arcskip="2"];
  id: totrans-1339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c]", arcskip="2"];
- en: '|||;'
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-1342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-1343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/e5ae4c8c184c7b414c018f2972f772de.png)<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"
    name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"></map>'
  id: totrans-1357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e5ae4c8c184c7b414c018f2972f772de.png)<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"
    name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"></map>'
- en: There are several important differences with the TLS 1.2 handshake. First, the
    Diffie Hellman key exchange is required in TLS 1.3 and this exchange is initiated
    by the client (before having validated the server identity). To initiate the Diffie
    Hellman key exchange, the client needs to guess the modulus and the base that
    can be accepted by the server. Either the client uses standard parameters that
    most server supports or the client remembers the last modulus/base that it used
    with this particular server. If the client guessed incorrectly, the server replies
    with the parameters that it expects and one round-trip-time is lost. When the
    server sends its ServerHello, it already knows the session key. This implies that
    the server can encrypt all subsequent messages. After one round-trip-time, all
    data exchanged over the TLS 1.3 session is encrypted and authenticated. In TLS
    1.3, the server certificate is encrypted with the session key, as well as the
    Finished message. The server signs the handshake to confirm that it owns the public
    key of its certificate. If the server wants to send application data, it can already
    encrypt it and send it to the client. Upon reception of the server Certificate,
    the client verifies it and checks the signature of the handshake and the Finished
    message. The client confirms the end of the handshake by sending its own Finished
    message. At that time, the client can send encrypted data. This means that the
    client only had to wait one round-trip-time before sending encrypted data. This
    is much faster than with TLS 1.2.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TLS 1.2 握手相比，有几个重要的区别。首先，TLS 1.3 需要Diffie Hellman 密钥交换，并且这个交换是由客户端发起的（在验证服务器身份之前）。为了发起
    Diffie Hellman 密钥交换，客户端需要猜测服务器可以接受的模数和基数。客户端要么使用大多数服务器支持的标准参数，要么记住与该特定服务器上次使用的最后一个模数/基数。如果客户端猜测错误，服务器将回复它期望的参数，并且会丢失一个往返时间。当服务器发送其
    ServerHello 时，它已经知道了会话密钥。这意味着服务器可以加密所有后续的消息。经过一个往返时间后，TLS 1.3 会话中交换的所有数据都是加密和认证的。在
    TLS 1.3 中，服务器证书是用会话密钥加密的，以及Finished消息。服务器签署握手以确认它拥有其证书的公钥。如果服务器想要发送应用程序数据，它已经可以加密并发送给客户端。在接收到服务器证书后，客户端验证它并检查握手和Finished消息的签名。客户端通过发送自己的Finished消息来确认握手的结束。这时，客户端可以发送加密数据。这意味着客户端在发送加密数据之前只需等待一个往返时间。这比
    TLS 1.2 快得多。
- en: For some applications, waiting one round-trip-time before being able to send
    data is too long. TLS 1.3 allows the client to send encrypted data immediately
    after the ClientHello, without having to wait for the ServerHello message. At
    this point in the handshake, the client cannot know the key that will be derived
    by the Diffie Hellman key exchange. The trick is that the server and the client
    need to have previously agreed on a pre-shared-key. This key could be negotiated
    out of band, but usually it was exchanged over a previous TLS session between
    the client and the server. Both the client and the server can store this key in
    their cache. When the client creates a new TLS session to a server, it checks
    whether it already knows a pre-shared key for this server. If so, the client announces
    the identifier of this key in its ClientHello message. Thanks to this identifier,
    the server can recover the key and use it to decrypt the 0-rtt Encrypted record.
    A simplified version of the 0-rtt TLS 1.3 handshake [[8]](#fhandshake) is shown
    in the figure below.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，在能够发送数据之前等待一个往返时间太长了。TLS 1.3 允许客户端在 ClientHello 之后立即发送加密数据，而无需等待 ServerHello
    消息。在这个握手阶段，客户端无法知道通过 Diffie Hellman 密钥交换将导出的密钥。技巧是服务器和客户端需要事先商定一个预共享密钥。这个密钥可以通过非绑定方式协商，但通常是在客户端和服务器之间的先前
    TLS 会话中交换。客户端和服务器都可以将此密钥存储在它们的缓存中。当客户端创建到服务器的新的 TLS 会话时，它会检查是否已经知道该服务器的预共享密钥。如果是这样，客户端将在其
    ClientHello 消息中宣布此密钥的标识符。多亏了这个标识符，服务器可以恢复密钥并使用它来解密 0-rtt 加密记录。下面展示了简化版的 0-rtt
    TLS 1.3 握手 [[8]](#fhandshake)。
- en: '![msc {'
  id: totrans-1360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
  id: totrans-1367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
- en: '|||;'
  id: totrans-1368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
  id: totrans-1369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
- en: '|||;'
  id: totrans-1370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-1371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-1372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/37315cb85580d2a0a41ccf2aa6b695ae.png)<map id="04ec071344c2fae0632e2d690c2782c9017b631e"
    name="04ec071344c2fae0632e2d690c2782c9017b631e"></map>'
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/37315cb85580d2a0a41ccf2aa6b695ae.png)<map id="04ec071344c2fae0632e2d690c2782c9017b631e"
    name="04ec071344c2fae0632e2d690c2782c9017b631e"></map>'
- en: 'On the web, TLS clients use certificates to authenticate servers but the clients
    are not authenticated. However, there are environments such as enterprise networks
    where servers may need to authenticate clients as well. A popular deployment is
    to authenticate remote clients who wish to access the enterprise network through
    a Virtual Private Network service. Some of these services run above TLS (or more
    precisely a variant of TLS named DTLS that runs above UDP [[MoR2004]](../bibliography.html#mor2004)
    but is outside the scope of this chapter). In such services, each client is authenticated
    thanks to a public key and a certificate that is trusted by the servers. To establish
    a TLS session, such a client needs to prove that it owns the public key associated
    with the certificate. This is done by the server thanks to the CertificateRequest
    message. The TLS handshake becomes the following one:'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，TLS客户端使用证书来验证服务器，但客户端没有被验证。然而，在企业网络等环境中，服务器可能还需要验证客户端。一种常见的部署是为那些希望通过虚拟专用网络服务访问企业网络的远程客户端进行验证。其中一些服务运行在TLS之上（或更精确地说，是在UDP之上的TLS变体DTLS
    [[MoR2004]](../bibliography.html#mor2004)，但超出了本章的范围）。在这些服务中，每个客户端都通过一个由服务器信任的公钥和证书进行验证。为了建立TLS会话，这样的客户端需要证明它拥有与证书关联的公钥。这是通过服务器发送的CertificateRequest消息来完成的。TLS握手变为以下形式：
- en: '![msc {'
  id: totrans-1385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
- en: '|||;'
  id: totrans-1393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
  id: totrans-1394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
- en: '|||;'
  id: totrans-1395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: ''
  id: totrans-1396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-1397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-1398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "CertificateRequest, Certificate, Sign(K,Handshake), Finished,
    Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "CertificateRequest, Certificate, Sign(K,Handshake), Finished,
    Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Certificate, Sign(Kc, Handshake), Finished", textcolour="red",
    linecolour="red", arcskip="2"];
  id: totrans-1402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Certificate, Sign(Kc, Handshake), Finished", textcolour="red",
    linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/6b610706117d1538fe4793f16be928b1.png)<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82"
    name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"></map>'
  id: totrans-1409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/6b610706117d1538fe4793f16be928b1.png)<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82"
    name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"></map>'
- en: The server sends a CertificatRequest message. The client returns its certificate
    and signs the Handshake with is private key. This confirms to the server that
    the client owns the public key indicated in its certificate.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送一个CertificateRequest消息。客户端返回其证书并使用其私钥对握手进行签名。这向服务器确认客户端拥有其证书中指示的公钥。
- en: There are many more differences between TLS 1.2 and TLS 1.3\. Additional details
    may be found in their respective specifications, [**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)
    and [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2 和 TLS 1.3 之间有许多更多差异。更多详细信息可以在它们各自的规范中找到，[**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)
    和 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。
- en: The TLS handshake[#](#the-tls-handshake "Link to this heading")
  id: totrans-1412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS 握手[#](#the-tls-handshake "链接到本标题")
- en: 'When used to interact with a regular web server, the TLS handshake has three
    important objectives:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于与常规 Web 服务器交互时，TLS 握手有三个重要目标：
- en: Securely negotiate the cryptographic algorithms that will be used by the client
    and the server over the TLS session
  id: totrans-1414
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全地协商客户端和服务器在 TLS 会话中将使用的加密算法
- en: ''
  id: totrans-1415
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1416
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that the client interacts with a valid server
  id: totrans-1417
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证客户端与有效服务器交互
- en: ''
  id: totrans-1418
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1419
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Securely agree on the keys that will be used to encrypt and authenticate the
    messages exchanged over the TLS session
  id: totrans-1420
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全地协商用于加密和验证 TLS 会话中交换的消息的密钥
- en: The TLS handshake is a four-way handshake illustrated in the figure below.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 握手是一个四步握手，如图所示。
- en: '![msc {'
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [标签="", 线颜色=白色],
- en: b [label="Client",linecolour=black],
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [标签="客户端",linecolour=黑色],
- en: z [label="", linecolour=white],
  id: totrans-1425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [标签="", 线颜色=白色],
- en: c [label="Server", linecolour=black],
  id: totrans-1426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [标签="服务器", 线颜色=黑色],
- en: d [label="", linecolour=white];
  id: totrans-1427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [标签="", 线颜色=白色];
- en: ''
  id: totrans-1428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random]", arcskip="2"];
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [标签 = "ClientHello[随机]", arcskip="2"];
- en: '|||;'
  id: totrans-1430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random], Certificate", arcskip="2"];
  id: totrans-1432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [标签 = "ServerHello[随机], 证书", arcskip="2"];
- en: '|||;'
  id: totrans-1433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
  id: totrans-1435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [标签 = "E(K,MasterSecret), Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
- en: '|||;'
  id: totrans-1436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
  id: totrans-1438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [标签 = "Finished=MAC(MasterSecret||Handshake)", arcskip="2"];
- en: '|||;'
  id: totrans-1439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", linecolour="red", textcolour="red"];
  id: totrans-1441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [标签 = "加密记录", 线颜色="红色", 文字颜色="红色"];
- en: b>>c [ label = "Encrypted Record", linecolour="red", textcolour="red"];
  id: totrans-1442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [标签 = "加密记录", 线颜色="红色", 文字颜色="红色"];
- en: '}](../Images/300581e55a5559d21fa138b6759650ca.png)<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3"
    name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"></map>'
  id: totrans-1443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/300581e55a5559d21fa138b6759650ca.png)<map id="6851383dfd7cb6f84e42dde9992fdd9303de35d3"
    name="6851383dfd7cb6f84e42dde9992fdd9303de35d3"></map>'
- en: In a nutshell, the client starts the TLS handshake by proposing a random nonce.
    The server replies with its random nonce and a certificate that binds its name
    to a public key. The client generates a MasterSecret that will be used later to
    derive the session keys and encrypts it with the public key of the server. It
    also generates a Finished message that contains a MAC of all the messages exchanged
    to allow the server to detect any modification of the messages sent by the client.
    The server also sends its own Finished message. At that point, the client and
    the server sent encrypted records thanks to the keys derived from the MasterSecret.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，客户端通过提出一个随机数来启动 TLS 握手。服务器回复其随机数和一个证书，该证书将其名称绑定到一个公钥。客户端生成一个 MasterSecret，稍后将用于派生会话密钥，并用服务器的公钥加密它。它还生成一个包含所有交换消息的
    MAC 的 Finished 消息，以便服务器能够检测客户端发送的消息的任何修改。服务器也发送它自己的 Finished 消息。此时，客户端和服务器通过从
    MasterSecret 派生的密钥发送加密记录。
- en: 'Let us first discuss the negotiation of the cryptographic algorithms and parameters.
    Like all security protocols, TLS includes some agility in its design since new
    cryptographic algorithms appear over the years and some older algorithms become
    deprecated once cryptanalysts find flaws. The TLS handshakes starts with the `ClientHello`
    message that is sent by the client. This message carries the following information
    :'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论加密算法和参数的协商。像所有安全协议一样，TLS 在其设计中包含了一些灵活性，因为随着时间的推移，新的加密算法出现，一些较旧的算法一旦密码分析学家发现缺陷，就会变得过时。TLS
    握手从客户端发送的 `ClientHello` 消息开始。此消息包含以下信息：
- en: 'Protocol version number: this is the version of the TLS protocol supported
    by the client. The server should use the same version of the TLS protocol as the
    client, but may opt for an older version. Both versions 1.2 and 1.3 of TLS are
    deployed today. Older versions are being deprecated.'
  id: totrans-1446
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议版本号：这是客户端支持的 TLS 协议版本。服务器应使用与客户端相同的 TLS 协议版本，但可以选择较旧版本。目前部署了 TLS 1.2 和 1.3
    两个版本。较旧版本正在被弃用。
- en: ''
  id: totrans-1447
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1448
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Random number: security protocols rely on random numbers. The client sends
    a 32 bytes long random number where usually four of these bytes correspond to
    the client’s clock. This random number is used, together with the server’s random
    number, as a seed to generate the security keys.'
  id: totrans-1449
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数：安全协议依赖于随机数。客户端发送一个32字节长的随机数，其中通常有四个字节对应于客户端的时钟。这个随机数与服务器随机数一起用作生成安全密钥的种子。
- en: ''
  id: totrans-1450
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1451
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Cipher suites : this ordered list contains the set of cryptographic algorithms
    that are supported by the client, with the most preferred one listed first. In
    contrast with `ssh` that allows negotiating independent algorithms for encryption,
    key exchange and authentication, TLS relies on suites that combine these algorithms
    together. Many cryptographic suites have been defined for TLS. Various recommendations
    have been published on the security of some of these suites [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html).'
  id: totrans-1452
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cipher suites：这个有序列表包含客户端支持的加密算法集合，最优先的算法列在第一位。与允许独立协商加密、密钥交换和认证算法的`ssh`不同，TLS依赖于将这些算法组合在一起的套件。为TLS定义了许多加密套件。关于这些套件中的一些套件的安全性已经发布了各种建议
    [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html)。
- en: ''
  id: totrans-1453
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1454
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compression algorithm : the client may propose the utilization of a specific
    compression algorithm (e.g. zlib). In theory, compressing the data before encrypting
    it is an intelligent way to reduce the amount of data exchanged. Unfortunately,
    its implementation in TLS has caused several security problems [[PHG2013]](../bibliography.html#phg2013).
    For this reason, compression is usually disabled in TLS [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html).'
  id: totrans-1455
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩算法：客户端可以提议使用特定的压缩算法（例如zlib）。理论上，在加密之前压缩数据是一种减少交换数据量的智能方式。不幸的是，TLS中的实现导致了几个安全问题
    [[PHG2013]](../bibliography.html#phg2013)。因此，压缩通常在TLS中是禁用的 [**RFC 7525**](https://datatracker.ietf.org/doc/html/rfc7525.html)。
- en: ''
  id: totrans-1456
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1457
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extensions : TLS supports various extensions in the `ClientHello` message.
    These extensions [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    are important to allow the protocol to evolve, but many of them go beyond the
    scope of this chapter.'
  id: totrans-1458
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：TLS在`ClientHello`消息中支持各种扩展。这些扩展 [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    对于允许协议发展很重要，但其中许多超出了本章的范围。
- en: Note
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Server Name Indication (SNI)`
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server Name Indication (SNI)`'
- en: The `Server Name Indication (SNI)` extension defined in [**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)
    is an important TLS extension for web servers. It is used by the client to indicate
    the name of the server that it wishes to contact. The IP address associated to
    this name has been queried from the DNS and used to establish the TCP connection.
    Why should the client indicate the server name in the TLS `ClientHello` ? The
    motivation is the same as for the `Host` header line in HTTP/1.0\. With the SNI
    extension, a single TLS server can support several web sites that use different
    domain names. Thanks to the SNI extension, the server knows the concerned domain
    name at the start of the TLS session. Without this extension, hosting providers
    would have been forced use one IP address per TLS-enabled server.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 在[**RFC 6066**](https://datatracker.ietf.org/doc/html/rfc6066.html)中定义的`Server
    Name Indication (SNI)`扩展是用于Web服务器的重要TLS扩展。客户端使用它来指示它希望联系的服务器名称。与该名称关联的IP地址已从DNS查询并用于建立TCP连接。为什么客户端需要在TLS的`ClientHello`中指示服务器名称呢？动机与HTTP/1.0中的`Host`头行相同。有了SNI扩展，单个TLS服务器可以支持使用不同域名的好几个网站。多亏了SNI扩展，服务器在TLS会话开始时就知道相关的域名。如果没有这个扩展，托管提供商将不得不为每个启用了TLS的服务器使用一个IP地址。
- en: 'The server replies to the `ClientHello` with several messages:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器用几条消息回复`ClientHello`：
- en: the `ServerHello` message that contains the protocol version chosen by the server
    (assumed to be the same as the client version in this chapter), the 32 random
    bytes chosen by the server, the Cipher Suite selected by the server from the list
    advertised by the client and a Session Id. This Session Id is an identifier which
    is chosen by the server. It identifies the TLS session and the security parameters
    (algorithms and keys) negotiated for this session. It is used to support session
    resumption.
  id: totrans-1463
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含服务器选择的协议版本（在本章中假设与客户端版本相同）、服务器选择的32个随机字节、从客户端广告的列表中选择的Cipher Suite以及一个Session
    Id的`ServerHello`消息。这个Session Id是一个由服务器选择的标识符。它标识TLS会话以及为该会话协商的安全参数（算法和密钥）。它用于支持会话恢复。
- en: ''
  id: totrans-1464
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1465
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `Certificate` message provides the certificate (or usually a chain of certificates)
    that binds a domain name to the public key used by the server. TLS uses the server
    certificates to authenticate the server. It relies on a Public Key Infrastructure
    that is composed of a set of root certification authorities that issue certificates
    to certification authorities that in the end issue certificates to servers. TLS
    clients are usually configured with the public keys of several root certification
    authorities and use this information to validate the certificates that they receive
    from servers. For historical reasons, the TLS certificates are encoded in ASN.1
    format. The details of the ASN.1 syntax [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    are outside the scope of this book.
  id: totrans-1466
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Certificate`消息提供了将域名绑定到服务器使用的公钥的证书（或通常是一系列证书）。TLS使用服务器证书来验证服务器。它依赖于一个由一组根证书颁发机构组成的公钥基础设施，这些根证书颁发机构向证书颁发机构颁发证书，最终向服务器颁发证书。TLS客户端通常配置有多个根证书颁发机构的公钥，并使用这些信息来验证他们从服务器收到的证书。由于历史原因，TLS证书是以ASN.1格式编码的。ASN.1语法的详细信息[[Dubuisson2000]](../bibliography.html#dubuisson2000)超出了本书的范围。'
- en: ''
  id: totrans-1467
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1468
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `ServerKeyExchange` message is used by the server to transmit the information
    that is required to perform the key exchange. The content of this message is function
    of the selected key exchange algorithm.
  id: totrans-1469
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerKeyExchange`消息用于服务器传输执行密钥交换所需的信息。此消息的内容取决于所选的密钥交换算法。'
- en: ''
  id: totrans-1470
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1471
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the `ServerHelloDone` indicates that the server has sent all the messages for
    the first phase of the handshake.
  id: totrans-1472
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerHelloDone`表示服务器已发送握手第一阶段的所有消息。'
- en: 'At this point, it is time to describe the TLS key exchange. TLS supports different
    key exchange mechanisms that can be negotiated as part of the selection of the
    cipher suite. We focus on two of them to highlight their differences:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，是时候描述TLS密钥交换了。TLS支持不同的密钥交换机制，这些机制可以作为选择加密套件的一部分进行协商。我们关注其中的两个，以突出它们之间的差异：
- en: '`RSA`. This key exchange algorithm uses the encryption capabilities of the
    RSA public-key algorithm. The client has validated the server’s public key thanks
    to the `Certificate` message. It then generates a (48 bytes) random number, encrypts
    it with the server public key and sends the encrypted number to the server in
    the `ClientKeyExchange` message. The server uses its private key to decrypt the
    random number. At this point, the client and the server share the same (48 bytes
    long) secret and use it to derive the secret keys required to encrypt and authenticate
    data in the second phase. With this key exchange algorithm, the server does not
    need to send a `ServerKeyExchange` message.'
  id: totrans-1474
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RSA`。这个密钥交换算法使用了RSA公钥算法的加密能力。客户端通过`Certificate`消息验证了服务器的公钥。然后它生成一个（48字节）的随机数，使用服务器公钥加密它，并在`ClientKeyExchange`消息中将加密后的数字发送到服务器。服务器使用其私钥解密随机数。在这个时候，客户端和服务器共享相同的（48字节长）秘密，并使用它来生成第二阶段加密和验证数据所需的密钥。'
- en: ''
  id: totrans-1475
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1476
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`DHE_RSA`. This key exchange algorithm is the Ephemeral Diffie Hellman key
    exchange with RSA signatures to authenticate the key exchange. It operates as
    a classical authenticated Diffie Hellman key exchange. If this key exchange has
    been selected by the server, it sends its Diffie Hellman parameters in the `ServerKeyExchange`
    message and signs them with its private key. The client then continues the key
    exchange and sends the results of its own computation in the `ClientKeyExchange`
    message. `DHE_RSA` is thus an authenticated Diffie Hellman key exchange where
    the initial message is sent by the server (instead of the client as in our first
    example but since the protocol is symmetric, this does not matter).'
  id: totrans-1477
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DHE_RSA`。这个密钥交换算法是带有RSA签名的临时Diffie-Hellman密钥交换，用于验证密钥交换。它作为一个经典的认证Diffie-Hellman密钥交换操作。如果服务器选择了这个密钥交换，它将在`ServerKeyExchange`消息中发送其Diffie-Hellman参数，并使用其私钥对它们进行签名。然后客户端继续密钥交换，并在`ClientKeyExchange`消息中发送其自己计算的结果。因此，`DHE_RSA`是一个认证的Diffie-Hellman密钥交换，其中初始消息是由服务器发送的（而不是客户端，如我们的第一个示例，但由于协议是对称的，这并不重要）。'
- en: An important difference between `DHE_RSA` and `RSA` is their reaction against
    attacks. `DHE_RSA` is considered by many to be stronger than `RSA` because it
    supports Perfect Forward Secrecy. This property is important against attackers
    that are able to eavesdrop all the (encrypted) data sent and received by a server.
    Consider that Terrence is such an attacker that has stored all the packets exchanged
    by Bob’s server during the last six months. If he manages, by any means, to obtain
    Bob’s private key, he will be able to decrypt all the keys used to secure the
    TLS sessions with Bob’s server during this period. With `DHE_RSA`, a similar attack
    is less devastating. If Terrence knows Bob’s private key, he will be able to launch
    a man-in-the-middle attack against future TLS sessions with Bob’s server. However,
    he will not be able to recover the keys used for all the past sessions that he
    captured.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '`DHE_RSA` 和 `RSA` 之间的重要区别在于它们对攻击的反应。许多人认为 `DHE_RSA` 比较于 `RSA` 更强，因为它支持完美前向安全性。这一特性对于能够监听服务器发送和接收的所有（加密）数据的攻击者来说非常重要。假设特伦斯是这样的攻击者，他在过去六个月内存储了鲍勃服务器交换的所有数据包。如果他设法以任何方式获得鲍勃的私钥，他将能够解密在此期间用于保护与鲍勃服务器TLS会话的所有密钥。使用
    `DHE_RSA`，类似的攻击破坏性较小。如果特伦斯知道鲍勃的私钥，他将能够对鲍勃服务器的未来TLS会话发起中间人攻击。然而，他无法恢复他捕获的所有过去会话中使用的密钥。'
- en: Note
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Perfect Forward Secrecy
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 完美前向安全性
- en: Perfect Forward Secrecy (PFS) is an important property for key exchange protocols.
    A protocol provides PFS if its design guarantees that the keys used for former
    sessions will not be compromised even if the private key of the server is compromised.
    This is a very important property. `DHE_RSA` provides Perfect Forward Secrecy,
    but the `RSA` key exchange does not provide this property. In practice, `DHE_RSA`
    is costly from a computational viewpoint. Recent implementations of TLS thus prefer
    `ECDHE_RSA` or `ECDHE_ECDSA` when Perfect Forward Secrecy is required.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 完美前向安全性（PFS）是密钥交换协议的一个重要特性。如果协议的设计保证即使服务器的私钥被泄露，以前会话使用的密钥也不会受到损害，则该协议提供PFS。这是一个非常重要的特性。`DHE_RSA`
    提供完美前向安全性，但 `RSA` 密钥交换不提供这一特性。在实践中，`DHE_RSA` 从计算角度来看成本较高。因此，TLS的最新实现当需要完美前向安全性时，更倾向于使用
    `ECDHE_RSA` 或 `ECDHE_ECDSA`。
- en: All the information required for the key exchange has now been transmitted.
    There are two important messages that will be sent by the client and the server
    to conclude the handshake and start the data transfer phase.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于密钥交换所需的信息现已传输。客户端和服务器将发送两条重要消息，以完成握手并开始数据传输阶段。
- en: The client sends the `ChangeCipherSpec` message followed by the `Finished` message.
    The `ChangeCipherSpec` message indicates that the client has received all the
    information required to generate the security keys for this TLS session. This
    messages can also appear later in the session to indicate a change in the encryption
    algorithms that are used, but this usage is outside the scope of this book. The
    `Finished` message is more important. It confirms to the server that the TLS handshake
    has been performed correctly and that no attacker has been able to modify the
    data sent by the client or the server. This is the first message that is encrypted
    with the selected security keys. It contains a hash of all the messages that were
    exchanged during the handshake.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送 `ChangeCipherSpec` 消息，随后是 `Finished` 消息。`ChangeCipherSpec` 消息表示客户端已收到生成此TLS会话安全密钥所需的所有信息。此消息也可以在会话的后期出现，以指示加密算法的改变，但这种用法超出了本书的范围。`Finished`
    消息更为重要。它向服务器确认TLS握手已正确执行，并且没有攻击者能够修改客户端或服务器发送的数据。这是第一个使用所选安全密钥加密的消息。它包含握手期间交换的所有消息的散列值。
- en: The server also sends a `ChangeCipherSpec` message followed by a `Finished`
    message.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还会发送一个 `ChangeCipherSpec` 消息，随后是一个 `Finished` 消息。
- en: Note
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: TLS Cipher suites
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 加密套件
- en: A TLS cipher suite is usually represented as an ASCII string that starts with
    TLS and contains the acronym of the key exchange algorithm, the encryption scheme
    with the key size and its mode of operation and the authentication algorithm.
    For example, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256` is a TLS cipher suite that
    uses the `DHE_RSA` key exchange algorithm with 128 bits AES in GCM mode for encryption
    and SHA-256 for authentication. The official list of TLS cipher suites is maintained
    by IANA [[7]](#fianatls). The NULL acronym indicates that no algorithm has been
    specified. For example, `TLS_ECDH_RSA_WITH_NULL_SHA` is a cipher suite that does
    not use any encryption but still uses the `ECDH_RSA` key exchange and `SHA` for
    authentication.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: TLS加密套件通常表示为一个以TLS开头并包含密钥交换算法缩写、密钥大小和其操作模式的加密方案以及认证算法的ASCII字符串。例如，`TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`是一个使用`DHE_RSA`密钥交换算法，以128位AES在GCM模式下加密，并使用SHA-256进行认证的TLS加密套件。TLS加密套件的官方列表由IANA维护[[7]](#fianatls)。NULL缩写表示未指定任何算法。例如，`TLS_ECDH_RSA_WITH_NULL_SHA`是一个不使用任何加密但仍然使用`ECDH_RSA`密钥交换和`SHA`进行认证的加密套件。
- en: The TLS record protocol[#](#the-tls-record-protocol "Link to this heading")
  id: totrans-1488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS记录协议[#](#the-tls-record-protocol "链接到这个标题")
- en: The handshake is now finished. The client and the server will exchange authenticated
    and encrypted records. TLS defines different formats for the records depending
    on the cryptographic algorithms that have been negotiated for the session. A detailed
    discussion of these different types of records is outside the scope of this introduction.
    For illustration, we briefly describe one record format.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 握手现在已完成。客户端和服务器将交换经过认证和加密的记录。TLS根据会话中协商的加密算法定义了记录的不同格式。这些不同类型记录的详细讨论超出了本介绍的范畴。为了说明，我们简要描述一种记录格式。
- en: As other security protocols, TLS uses different keys to encrypt and authenticate
    records. These keys are derived from the MasterSecret that is either randomly
    generated by the client after the `RSA` key exchange or derived from the Diffie
    Hellman parameters after the `DH_RSA` key exchange. The exact algorithm used to
    derive the keys is defined in [**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html).
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他安全协议一样，TLS使用不同的密钥来加密和验证记录。这些密钥是从MasterSecret派生出来的，MasterSecret要么是在`RSA`密钥交换后由客户端随机生成的，要么是在`DH_RSA`密钥交换后从Diffie
    Hellman参数派生出来的。用于派生密钥的确切算法在[**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)中定义。
- en: 'A TLS record is always composed of four different fields :'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: TLS记录始终由四个不同的字段组成：
- en: a Type that indicates the type of record. The most frequent type is application
    data which corresponds to a record containing encrypted data. The other types
    are handshake, change_cipher_spec and alert.
  id: totrans-1492
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型字段，表示记录的类型。最常见类型是应用程序数据，对应包含加密数据的记录。其他类型是握手、更改密钥规范和警报。
- en: ''
  id: totrans-1493
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1494
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a Protocol Version field that indicates the version of the TLS protocol used.
    This version is composed of two sub fields : a major and a minor version number.'
  id: totrans-1495
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个协议版本字段，表示使用的TLS协议版本。这个版本由两个子字段组成：主版本号和次版本号。
- en: ''
  id: totrans-1496
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1497
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Length field. A TLS record cannot be longer than 16,384 bytes.
  id: totrans-1498
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个长度字段。TLS记录的长度不能超过16,384字节。
- en: ''
  id: totrans-1499
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1500
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a TLSPlainText that contains the encrypted data
  id: totrans-1501
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含加密数据的TLSPlainText
- en: 'TLS supports several methods to encrypted records. The selected method depends
    on the cryptographic algorithms that have been negotiated for the TLS session.
    A detailed presentation of the different methods that can be used to produce the
    TLSPlainText from the user data is outside the scope of this book. As an example,
    we study one method: Stream Encryption. This method is used with cryptographic
    algorithms which can operate on a stream of bytes. The method starts with a sequence
    of bytes provided by the user application: the plain text. The first step is to
    compute the authentication code to verify the integrity of the data. For this,
    TLS computes \(MAC(SeqNum, Header, PlainText)\) using HMAC where SeqNum is a sequence
    number which is incremented by one for each new TLS record transmitted. The Header
    is the header of the TLS record described above and PlainText is the information
    that needs to be encrypted. Note that the sequence number is maintained at the
    two endpoints of the TLS session, but it is not transmitted inside the TLS record.
    This sequence number is used to prevent replay attacks.'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: TLS支持多种加密记录的方法。选择的方法取决于TLS会话中协商的加密算法。本书不涉及如何从用户数据生成TLSPlainText的不同方法的详细说明。作为一个例子，我们研究了一种方法：流加密。这种方法与可以操作字节流的加密算法一起使用。该方法从用户应用程序提供的字节序列开始：明文。第一步是计算认证码以验证数据的完整性。为此，TLS使用HMAC计算
    \(MAC(SeqNum, Header, PlainText)\)，其中SeqNum是一个序列号，每次传输新的TLS记录时都会增加一。Header是上述TLS记录的头部，PlainText是需要加密的信息。请注意，序列号在TLS会话的两个端点维护，但它不会在TLS记录中传输。这个序列号用于防止重放攻击。
- en: Note
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MAC-then-encrypt or Encrypt-then-MAC
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: MAC-then-encrypt 或 Encrypt-then-MAC
- en: When secure protocols use Message Authentication and Encryption, they need to
    specify how these two algorithms are combined. A first solution, which is used
    by the current version of TLS, is to compute the authentication code and then
    encrypt both the data and the authentication code. A drawback of this approach
    is that the receiver of an encrypted TLS record must first attempt to decrypt
    data that has potentially been modified by an attacker before being able to verify
    the authenticity of the record. A better approach is for the sender to first encrypt
    the data and then compute the authentication code over the encrypted data. This
    is the encrypt-then-MAC approach proposed in [**RFC 7366**](https://datatracker.ietf.org/doc/html/rfc7366.html).
    With encrypt-then-MAC, the receiver first checks the authentication code before
    attempting to decrypt the record.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全协议使用消息认证和加密时，它们需要指定这两个算法如何结合。一个初步的解决方案，即当前TLS版本所使用的方案，是先计算认证码，然后对数据和认证码进行加密。这种方法的一个缺点是，加密的TLS记录的接收者必须首先尝试解密可能被攻击者修改过的数据，然后才能验证记录的真实性。一个更好的方法是发送者首先对数据进行加密，然后对加密数据计算认证码。这就是在[**RFC
    7366**](https://datatracker.ietf.org/doc/html/rfc7366.html)中提出的encrypt-then-MAC方法。使用encrypt-then-MAC时，接收者首先检查认证码，然后再尝试解密记录。
- en: Improving TLS[#](#improving-tls "Link to this heading")
  id: totrans-1506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进TLS[#](#improving-tls "链接到本标题")
- en: During the last two decades, the deployment of TLS has continued to grow. The
    early TLS servers were only used for critical services such as e-commerce websites
    or online banks. As CPU performance improved, it became much more cost-effective
    to use TLS to secure non-critical parts of web servers, including the delivery
    of HTML pages and even video services. There is now a growing number of applications
    that rely on TLS [[AM2019]](../bibliography.html#am2019).
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去二十年里，TLS的部署持续增长。早期的TLS服务器仅用于关键服务，如电子商务网站或在线银行。随着CPU性能的提高，使用TLS来保护非关键部分的Web服务器（包括HTML页面的交付甚至视频服务）变得更加经济高效。现在有越来越多的应用程序依赖于TLS
    [[AM2019]](../bibliography.html#am2019)。
- en: In 2013, the statistics collected by the Firefox Telemetry project [[9]](#ftelemetry)
    revealed that 30% of the web pages loaded by Firefox users were done over HTTPS.
    In October 2019, 80% of the web pages are loaded over HTTPS. In six years, HTTPS
    became the dominant protocol to access web services. Another look at the deployment
    of HTTPS on web sites may be found in [[Helme2019]](../bibliography.html#helme2019).
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Firefox遥测项目收集的统计数据显示，Firefox用户加载的网页中有30%是通过HTTPS完成的。到2019年10月，80%的网页是通过HTTPS加载的。在六年里，HTTPS已成为访问网络服务的占主导地位的协议。有关HTTPS在网站上的部署情况的更多信息，可以在[[Helme2019]](../bibliography.html#helme2019)中找到。
- en: Measurement studies that analyzed the evolution of TLS over the years have identified
    several important changes in the TLS ecosystem [[KRA2018]](../bibliography.html#kra2018).
    First, the preferred cryptographic algorithms have changed. While RC4 was used
    by 60% of the connections in 2012, its usage has dropped since 2015\. AES started
    to be deployed in 2013 and is now used for more than 90% of the connections. The
    deployed versions of TLS have also changed. TLS 1.0 and TLS 1.1 are now rarely
    used. The deployment of TLS 1.2 started in 2013 and reached 70% of the connections
    in 2015\. Version 1.3 of TLS, that is described below, is also widely deployed.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 对TLS多年演变进行分析的测量研究已经确定了TLS生态系统中的一些重要变化 [[KRA2018]](../bibliography.html#kra2018)。首先，首选的加密算法已经改变。虽然2012年有60%的连接使用了RC4，但自2015年以来其使用率已经下降。AES自2013年开始部署，现在被用于超过90%的连接。部署的TLS版本也发生了变化。TLS
    1.0和TLS 1.1现在很少使用。TLS 1.2的部署始于2013年，到2015年达到了70%的连接。下面描述的TLS 1.3版本也得到了广泛部署。
- en: Another interesting fact is the key exchange schemes. In 2012, RSA was the dominant
    solution, used by more than 80% of the observed connections [[KRA2018]](../bibliography.html#kra2018).
    In 2013, Edward Snowden revealed the surveillance activities of several governments.
    These revelations had a huge impact on the Internet community. The IETF, which
    standardizes Internet protocols, considered in [**RFC 7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)
    that such pervasive monitoring was an attack. Since then, several IETF working
    groups have developed solutions to counter pervasive monitoring. One of these
    solutions is to encourage Perfect Forward Security. Within TLS, this implies replacing
    RSA by an authenticated Diffie Hellman key exchange such as ECDHE. Measurements
    indicate that since summer 2014, ECDHE is more popular than RSA. In 2018, more
    than 90% of the observed TLS connections used ECDHE.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事实是密钥交换方案。2012年，RSA是主导解决方案，被观察到的超过80%的连接使用 [[KRA2018]](../bibliography.html#kra2018)。2013年，爱德华·斯诺登揭露了几个政府的监控活动。这些揭露对互联网社区产生了巨大影响。作为互联网协议标准化的机构，IETF在[**RFC
    7258**](https://datatracker.ietf.org/doc/html/rfc7258.html)中认为这种普遍监控是一种攻击。从那时起，几个IETF工作组开发了应对普遍监控的解决方案。其中一种解决方案是鼓励完美前向安全性。在TLS中，这意味着用认证的Diffie-Hellman密钥交换（如ECDHE）来替换RSA。测量表明，自2014年夏季以来，ECDHE比RSA更受欢迎。到2018年，观察到的超过90%的TLS连接使用了ECDHE。
- en: The last point is the difficulty of deploying TLS servers [[KMS2017]](../bibliography.html#kms2017).
    When TLS servers are installed, the system administrator needs to obtain certificates
    and configure a range of servers. Initially, getting certificates was complex
    and costly, but initiatives such as [https://letsencrypt.org](https://letsencrypt.org)
    have simplified this workflow.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是部署TLS服务器的难度 [[KMS2017]](../bibliography.html#kms2017)。当TLS服务器安装时，系统管理员需要获取证书并配置一系列服务器。最初，获取证书既复杂又昂贵，但诸如[https://letsencrypt.org](https://letsencrypt.org)之类的倡议简化了这一工作流程。
- en: 'In 2014, the IETF TLS working started to work on the development of version
    1.3 of the TLS protocol. Their main objectives [[Rescorla2015]](../bibliography.html#rescorla2015)
    for this new version were:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，IETF的TLS工作组开始着手开发TLS协议的1.3版本。他们为此新版本的主要目标 [[Rescorla2015]](../bibliography.html#rescorla2015)
    是：
- en: simplify the design by removing unused or unsafe protocol features
  id: totrans-1513
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过删除未使用或不安全的协议功能来简化设计
- en: ''
  id: totrans-1514
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1515
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: improve the security of TLS by leveraging the lessons learned from TLS 1.2 and
    some documented attacks
  id: totrans-1516
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用从TLS 1.2和某些已记录的攻击中学到的经验来提高TLS的安全性
- en: ''
  id: totrans-1517
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1518
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: improve the privacy of the protocol
  id: totrans-1519
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高协议的隐私性
- en: ''
  id: totrans-1520
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1521
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: reduce the latency of TLS
  id: totrans-1522
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少TLS的延迟
- en: Since 2014, latency has become an important concern for web services. As access
    networks bandwidth continue to grow, latency is becoming a key factor that affects
    the performance of interactive web services. With TLS 1.2, the download of a web
    page requires a minimum of four round-trip-times, one to create the underlying
    TCP connection, one to exchange the ClientHello/ServerHello, one to exchange the
    keys and then one to send the HTTP GET and retrieve the response. This can be
    very long when the server is not near the client. TLS 1.3 aimed at reducing this
    handshake to one round-trip-time and even zero by placing some of the cryptographic
    handshake in the TCP handshake. This part will be discussed in the TCP chapter.
    We focus here on the reducing the TLS handshake to a single round-trip-time.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2014 年以来，延迟已成为网络服务的一个重要关注点。随着接入网络带宽的持续增长，延迟正成为影响交互式网络服务性能的关键因素。TLS 1.2 要求下载一个网页至少需要四个往返时间，一个用于创建底层
    TCP 连接，一个用于交换客户端问候/服务器问候，一个用于交换密钥，然后一个用于发送 HTTP GET 并检索响应。当服务器不在客户端附近时，这可能非常耗时。TLS
    1.3 旨在将这个握手过程减少到一个往返时间，甚至通过在 TCP 握手过程中放置一些加密握手来达到零往返时间。这部分将在 TCP 章节中讨论。我们在这里关注的是将
    TLS 握手减少到单个往返时间。
- en: To simplify both the design and the implementations, TLS 1.3 uses only a small
    number of cipher suites. Five of them are specified in [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)
    and `TLS_AES_128_GCM_SHA256` must be supported by all implementations. To ensure
    privacy, all cipher suites that did not provide Perfect Forward Secrecy have been
    removed. Compression has also been removed from TLS since several attacks on TLS
    1.2 exploited its compression capability [**RFC 7457**](https://datatracker.ietf.org/doc/html/rfc7457.html).
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化设计和实现，TLS 1.3 只使用了少量加密套件。其中五个在 [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)
    中指定，并且所有实现都必须支持 `TLS_AES_128_GCM_SHA256`。为了确保隐私，所有未提供完美前向安全的加密套件都已移除。压缩也已被从 TLS
    中移除，因为几个针对 TLS 1.2 的攻击利用了其压缩功能 [**RFC 7457**](https://datatracker.ietf.org/doc/html/rfc7457.html)。
- en: Note
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Enterprises, privacy and TLS
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 企业、隐私和 TLS
- en: By supporting only cipher suites that provide Perfect Forward Secrecy in TLS
    1.3, the IETF aims at protecting the privacy of users against a wide range of
    attacks. However, this choice has resulted in intense debates in some enterprises.
    Some enterprises, notably in financial organizations, have deployed TLS, but wish
    to be able to decrypt TLS traffic for various security-related activities. These
    enterprises tried to lobby within the IETF to maintain RSA-based cipher suites
    that do not provide Perfect Forward Secrecy. Their arguments did not convince
    the IETF. Eventually, these enterprises moved to ETSI, another standardization
    body, and convinced them to adopt entreprise TLS, a variant of TLS 1.3 that does
    not provide Perfect Forward Secrecy [[eTLS2018]](../bibliography.html#etls2018).
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅支持在 TLS 1.3 中提供完美前向安全的加密套件，IETF 旨在保护用户免受各种攻击的隐私。然而，这一选择在一些企业中引发了激烈的辩论。一些企业，特别是在金融机构中，已经部署了
    TLS，但希望能够解密 TLS 流量以进行各种安全相关活动。这些企业试图在 IETF 内进行游说，以维持不提供完美前向安全的基于 RSA 的加密套件。他们的论点并没有说服
    IETF。最终，这些企业转向了 ETSI，另一个标准化机构，并说服他们采用企业 TLS，这是一种不提供完美前向安全的 TLS 1.3 变体 [[eTLS2018]](../bibliography.html#etls2018)。
- en: The TLS 1.3 handshake differs from the TLS 1.2 handshake in several ways. First,
    the TLS 1.3 handshake requires a single round-trip-time when the client connects
    for the first time to a server. To achieve this, the TLS designers look at the
    TLS 1.2 handshake in details and found that the first round-trip-time is mainly
    used to select the set of cryptographic algorithms and the cryptographic exchange
    scheme that will be used over the TLS session. TLS 1.3 drastically simplifies
    this negotiation by requiring to use the Diffie Hellman exchange with a small
    set of possible parameters. This means that the client can guess the parameters
    used by the server (i.e. the modulus, p and the base g) and immediately start
    the Diffie Hellman exchange. A simplified version of the TLS 1.3 handshake is
    shown in the figure below.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 握手与 TLS 1.2 握手在几个方面有所不同。首先，当客户端首次连接到服务器时，TLS 1.3 握手需要单次往返时间。为了实现这一点，TLS
    设计者详细研究了 TLS 1.2 握手，并发现第一次往返时间主要用于选择将在 TLS 会话中使用的加密算法和加密交换方案。TLS 1.3 通过要求使用具有小参数集的
    Diffie-Hellman 交换来极大地简化了这种协商。这意味着客户端可以猜测服务器使用的参数（即模数 p 和底数 g），并立即开始 Diffie-Hellman
    交换。下面图示展示了简化版的 TLS 1.3 握手过程。
- en: '![msc {'
  id: totrans-1529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c]", arcskip="2"];
  id: totrans-1536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "客户端Hello[随机, g^c]", arcskip="2"];
- en: '|||;'
  id: totrans-1537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-1539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[随机, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-1540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "证书，签名(K, 握手), 完成, 加密记录", textcolour="red", linecolour="red",
    arcskip="2"];
- en: '|||;'
  id: totrans-1543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "完成", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/e5ae4c8c184c7b414c018f2972f772de.png)<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"
    name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"></map>'
  id: totrans-1554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e5ae4c8c184c7b414c018f2972f772de.png)<map id="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"
    name="7c40afa8b5d3bc7ec147430dbd78098f688a7eb0"></map>'
- en: There are several important differences with the TLS 1.2 handshake. First, the
    Diffie Hellman key exchange is required in TLS 1.3 and this exchange is initiated
    by the client (before having validated the server identity). To initiate the Diffie
    Hellman key exchange, the client needs to guess the modulus and the base that
    can be accepted by the server. Either the client uses standard parameters that
    most server supports or the client remembers the last modulus/base that it used
    with this particular server. If the client guessed incorrectly, the server replies
    with the parameters that it expects and one round-trip-time is lost. When the
    server sends its ServerHello, it already knows the session key. This implies that
    the server can encrypt all subsequent messages. After one round-trip-time, all
    data exchanged over the TLS 1.3 session is encrypted and authenticated. In TLS
    1.3, the server certificate is encrypted with the session key, as well as the
    Finished message. The server signs the handshake to confirm that it owns the public
    key of its certificate. If the server wants to send application data, it can already
    encrypt it and send it to the client. Upon reception of the server Certificate,
    the client verifies it and checks the signature of the handshake and the Finished
    message. The client confirms the end of the handshake by sending its own Finished
    message. At that time, the client can send encrypted data. This means that the
    client only had to wait one round-trip-time before sending encrypted data. This
    is much faster than with TLS 1.2.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 与TLS 1.2握手相比，有几个重要的区别。首先，TLS 1.3要求进行Diffie Hellman密钥交换，并且这个交换是由客户端发起的（在验证服务器身份之前）。为了发起Diffie
    Hellman密钥交换，客户端需要猜测服务器可以接受的模数和基数。客户端可以使用大多数服务器支持的标准参数，或者客户端记得与该特定服务器上次使用的最后一个模数/基数。如果客户端猜测错误，服务器会回复它期望的参数，并且会丢失一个往返时间。当服务器发送其ServerHello时，它已经知道了会话密钥。这意味着服务器可以加密所有后续的消息。经过一个往返时间后，TLS
    1.3会话中交换的所有数据都是加密和认证的。在TLS 1.3中，服务器证书是用会话密钥加密的，以及Finished消息。服务器签署握手以确认它拥有其证书的公钥。如果服务器想要发送应用程序数据，它已经可以加密并发送给客户端。在接收到服务器证书后，客户端会验证它并检查握手和Finished消息的签名。客户端通过发送自己的Finished消息来确认握手的结束。这时，客户端可以发送加密数据。这意味着客户端在发送加密数据之前只需要等待一个往返时间。这比TLS
    1.2要快得多。
- en: For some applications, waiting one round-trip-time before being able to send
    data is too long. TLS 1.3 allows the client to send encrypted data immediately
    after the ClientHello, without having to wait for the ServerHello message. At
    this point in the handshake, the client cannot know the key that will be derived
    by the Diffie Hellman key exchange. The trick is that the server and the client
    need to have previously agreed on a pre-shared-key. This key could be negotiated
    out of band, but usually it was exchanged over a previous TLS session between
    the client and the server. Both the client and the server can store this key in
    their cache. When the client creates a new TLS session to a server, it checks
    whether it already knows a pre-shared key for this server. If so, the client announces
    the identifier of this key in its ClientHello message. Thanks to this identifier,
    the server can recover the key and use it to decrypt the 0-rtt Encrypted record.
    A simplified version of the 0-rtt TLS 1.3 handshake [[8]](#fhandshake) is shown
    in the figure below.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，在能够发送数据之前等待一个往返时间太长了。TLS 1.3允许客户端在ClientHello之后立即发送加密数据，而无需等待ServerHello消息。在这个握手阶段，客户端无法知道Diffie
    Hellman密钥交换将导出的密钥。技巧是服务器和客户端需要事先就预共享密钥达成一致。这个密钥可以通过带外协商，但通常是在客户端和服务器之间的先前TLS会话中交换的。客户端和服务器都可以将其存储在缓存中。当客户端创建到服务器的新的TLS会话时，它会检查是否已经知道该服务器的预共享密钥。如果是这样，客户端会在其ClientHello消息中宣布这个密钥的标识符。多亏了这个标识符，服务器可以恢复密钥并使用它来解密0-rtt
    Encrypted记录。下面展示了简化版的0-rtt TLS 1.3握手[[8]](#fhandshake)。
- en: '![msc {'
  id: totrans-1557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
  id: totrans-1564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
- en: '|||;'
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
  id: totrans-1566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
- en: '|||;'
  id: totrans-1567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-1568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-1569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, Encrypted Record",
    textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "Certificate, Sign(K,Handshake), Finished, 加密记录", textcolour="red",
    linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Finished", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/37315cb85580d2a0a41ccf2aa6b695ae.png)<map id="04ec071344c2fae0632e2d690c2782c9017b631e"
    name="04ec071344c2fae0632e2d690c2782c9017b631e"></map>'
  id: totrans-1580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/37315cb85580d2a0a41ccf2aa6b695ae.png)<map id="04ec071344c2fae0632e2d690c2782c9017b631e"
    name="04ec071344c2fae0632e2d690c2782c9017b631e"></map>'
- en: 'On the web, TLS clients use certificates to authenticate servers but the clients
    are not authenticated. However, there are environments such as enterprise networks
    where servers may need to authenticate clients as well. A popular deployment is
    to authenticate remote clients who wish to access the enterprise network through
    a Virtual Private Network service. Some of these services run above TLS (or more
    precisely a variant of TLS named DTLS that runs above UDP [[MoR2004]](../bibliography.html#mor2004)
    but is outside the scope of this chapter). In such services, each client is authenticated
    thanks to a public key and a certificate that is trusted by the servers. To establish
    a TLS session, such a client needs to prove that it owns the public key associated
    with the certificate. This is done by the server thanks to the CertificateRequest
    message. The TLS handshake becomes the following one:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，TLS客户端使用证书来验证服务器，但客户端本身不被验证。然而，在企业网络等环境中，服务器可能还需要验证客户端。一种常见的部署方式是验证通过虚拟专用网络服务访问企业网络的远程客户端。其中一些服务运行在TLS之上（或更精确地说，是在UDP之上运行的TLS变体DTLS
    [[MoR2004]](../bibliography.html#mor2004)，但不在本章的范围内）。在这些服务中，每个客户端都通过一个由服务器信任的公钥和证书进行验证。为了建立TLS会话，这样的客户端需要证明它拥有与证书关联的公钥。这是通过服务器发送的CertificateRequest消息来完成的。TLS握手变为以下形式：
- en: '![msc {'
  id: totrans-1582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client",linecolour=black],
  id: totrans-1584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="客户端",linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
  id: totrans-1589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "ClientHello[Random, g^c,server_conf=abcd]", arcskip="2"];
- en: '|||;'
  id: totrans-1590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "0-rtt Encrypted record", textcolour="magenta", arcskip="2"];
  id: totrans-1591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0-rtt 加密记录", textcolour="magenta", arcskip="2"];
- en: '|||;'
  id: totrans-1592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: ''
  id: totrans-1593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
  id: totrans-1594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "ServerHello[Random, g^s]", arcskip="2"];
- en: '|||;'
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "CertificateRequest, Certificate, Sign(K,Handshake), Finished,
    Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "CertificateRequest, Certificate, Sign(K,Handshake), Finished,
    加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Certificate, Sign(Kc, Handshake), Finished", textcolour="red",
    linecolour="red", arcskip="2"];
  id: totrans-1599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "Certificate, Sign(Kc, Handshake), Finished", textcolour="red",
    linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: c>>b [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ label = "加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: b>>c [ label = "Encrypted Record", textcolour="red", linecolour="red", arcskip="2"];
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "加密记录", textcolour="red", linecolour="red", arcskip="2"];
- en: '|||;'
  id: totrans-1604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '|||;'
  id: totrans-1605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|||;'
- en: '}](../Images/6b610706117d1538fe4793f16be928b1.png)<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82"
    name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"></map>'
  id: totrans-1606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/6b610706117d1538fe4793f16be928b1.png)<map id="36d37bda46d72f2f438e0e029b02b9c54e69fa82"
    name="36d37bda46d72f2f438e0e029b02b9c54e69fa82"></map>'
- en: The server sends a CertificatRequest message. The client returns its certificate
    and signs the Handshake with is private key. This confirms to the server that
    the client owns the public key indicated in its certificate.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送一个CertificateRequest消息。客户端返回其证书并使用其私钥对握手进行签名。这向服务器确认客户端拥有其证书中指示的公钥。
- en: There are many more differences between TLS 1.2 and TLS 1.3\. Additional details
    may be found in their respective specifications, [**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)
    and [**RFC 8446**](https://datatracker.ietf.org/doc/html/rfc8446.html).
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2和TLS 1.3之间还有许多其他差异。更多详细信息可以在它们各自的规范中找到，分别是[**RFC 5246**](https://datatracker.ietf.org/doc/html/rfc5246.html)和[**RFC
    8446**](https://datatracker.ietf.org/doc/html/rfc8446.html)。
- en: '## Securing the Domain Name System[#](#securing-the-domain-name-system "Link
    to this heading")'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '## 保护域名系统[#](#securing-the-domain-name-system "链接到此标题")'
- en: The Domain Name System provides a critical service in the Internet infrastructure
    since it maps the domain names that are used by end users onto IP addresses. Since
    end users rely on names to identify the servers that they connect to, any incorrect
    information distributed by the DNS would direct end users’ connections to invalid
    destinations. Unfortunately, several attacks of this kind occurred in the past.
    A detailed analysis of the security threats against the DNS appeared in [**RFC
    3833**](https://datatracker.ietf.org/doc/html/rfc3833.html). We consider three
    of these threats in this section and leave the others to [**RFC 3833**](https://datatracker.ietf.org/doc/html/rfc3833.html).
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统在互联网基础设施中提供一项关键服务，因为它将终端用户使用的域名映射到IP地址。由于终端用户依赖于名称来识别他们连接的服务器，DNS分发的任何错误信息都会将终端用户的连接引导到无效的目的地。不幸的是，过去发生了几起这类攻击。关于DNS的安全威胁的详细分析出现在[**RFC
    3833**](https://datatracker.ietf.org/doc/html/rfc3833.html)中。在本节中，我们讨论了其中三种威胁，并将其他威胁留给[**RFC
    3833**](https://datatracker.ietf.org/doc/html/rfc3833.html)。
- en: The first type of attack is eavesdropping. An attacker who can capture packets
    sent to a DNS resolver or a DNS server can gain valuable information about the
    DNS names that are used by a given end user. If the attacker can capture all the
    packets sent to a DNS resolver, he/she can collect a lot of meta data about the
    domain names used by the end user. Preventing this type of attack has not been
    an objective of the initial design of the DNS. There are currently discussions
    with the IETF to carry DNS messages over TLS sessions to protect against such
    attacks. However, these solutions are not yet widely deployed.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种攻击类型是窃听。能够捕获发送到DNS解析器或DNS服务器的数据包的攻击者可以获取有关特定终端用户使用的DNS名称的宝贵信息。如果攻击者可以捕获发送到DNS解析器的所有数据包，他/她可以收集大量关于终端用户使用的域名的元数据。防止此类攻击并非DNS初始设计的目标。目前，正在与IETF进行讨论，以在TLS会话中传输DNS消息，以防止此类攻击。然而，这些解决方案尚未得到广泛部署。
- en: The second type of attack is the man-in-the-middle attack. Consider that Alice
    is sending DNS requests to her DNS resolver. Unfortunately, Mallory sits in front
    of this resolver and can capture and modify all the packets sent by Alice to her
    resolver. In this case, Mallory can easily modify the DNS responses sent by the
    resolver to redirect Alice’s packets to a different IP address controlled by Mallory.
    This enables Mallory to observe (and possibly modify) all the packets sent and
    received by Alice. In practice, executing this attack is not simple since DNS
    resolvers are usually installed in protected datacenters. However, if Mallory
    controls the WiFi access point that Alice uses to access the Internet, he could
    easily modify the packets on this access point and some software packages automate
    this type of attacks.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种攻击类型是中间人攻击。假设Alice正在向她的DNS解析器发送DNS请求。不幸的是，Mallory坐在该解析器的前面，可以捕获和修改Alice发送给解析器的所有数据包。在这种情况下，Mallory可以轻松修改解析器发送的DNS响应，将Alice的数据包重定向到Mallory控制的另一个IP地址。这使得Mallory能够观察（并可能修改）Alice发送和接收的所有数据包。在实践中，执行这种攻击并不简单，因为DNS解析器通常安装在受保护的数据中心中。然而，如果Mallory控制Alice用来访问互联网的WiFi接入点，他可以轻松修改该接入点上的数据包，并且一些软件包会自动化这种攻击。
- en: If Mallory cannot control a router on the path between Alice and her resolver,
    she could still launch a different attack. To understand this attack, it is important
    to correctly understand how the DNS protocol operates and the roles of the different
    fields of the DNS header which is reproduced in [Fig. 46](#fig-dns-header2).
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Mallory无法控制Alice和她的解析器之间的路由器，她仍然可以发起不同的攻击。要理解这种攻击，正确理解DNS协议的工作方式和DNS头部不同字段的角色非常重要，这些内容在[图46](#fig-dns-header2)中重现。
- en: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
- en: Fig. 46 DNS header[#](#id39 "Link to this image")
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 图46 DNS头部[#](#id39 "链接到此图像")
- en: The first field of the header is the Identification field. When Alice sends
    a DNS request, she places a 16-bits integer in this field and remembers it. When
    she receives a response, she uses this Identification field to locate the initial
    DNS request that she sent. The response is only used if its Identification matches
    a pending DNS request (containing the same question).
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 标题字段的第一字段是标识字段。当爱丽丝发送一个DNS请求时，她将一个16位的整数放入这个字段并记住它。当她收到响应时，她使用这个标识字段来定位她发送的初始DNS请求。只有当其标识与待处理的DNS请求（包含相同的问题）匹配时，响应才会被使用。
- en: Mallory has studied the DNS protocol and understands how it works. If he can
    predict a popular domain for which Alice will regularly send DNS requests, then
    he can prepare a set of DNS responses that map the name requested by Alice to
    an IP address controlled by Mallory instead of the legitimate DNS response. Each
    DNS response has a different Identification. Since there are only 65,536 values
    for the Identification field, it is possible for Mallory to send them to Alice
    hoping that one of them will be received while Alice is waiting for a DNS response
    with the same identifier. In the past, it was difficult to send 65,536 DNS responses
    quickly enough. However, with the high speed links that are available today, this
    is not an issue anymore. A second concern for Mallory is that he must be able
    to send the DNS responses as if they were coming directly from the DNS resolver.
    This implies that Mallory must be able to send IP packets that appear to originate
    from a different address. Although networks should be configured to prevent this
    type of attack, this is not always the case and there are networks where it is
    possible for a host to send packets with a different source IP address [[10]](#fspoof).
    If the attack targets a single end user, e.g. Alice, this is annoying for this
    user. However, if the attacker can target a DNS resolver that serves an entire
    company or an entire ISP, the impact of the attack can be much larger in particular
    if the injected DNS response carries a long TTL and thus resides in the resolver’s
    cache for a long period of time.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 马洛里研究了DNS协议，并理解它是如何工作的。如果他能够预测一个爱丽丝会定期发送DNS请求的流行域名，那么他可以准备一组DNS响应，将爱丽丝请求的名称映射到马洛里控制的IP地址，而不是合法的DNS响应。每个DNS响应都有一个不同的标识。由于标识字段只有65,536个值，马洛里可以向爱丽丝发送它们，希望其中之一会在爱丽丝等待具有相同标识的DNS响应时被接收。在过去，快速发送65,536个DNS响应是困难的。然而，随着今天可用的高速链路，这不再是问题。马洛里的第二个担忧是，他必须能够发送DNS响应，就像它们直接来自DNS解析器一样。这意味着马洛里必须能够发送看起来来自不同地址的IP数据包。尽管网络应该配置为防止此类攻击，但这并不总是如此，有些网络允许主机发送具有不同源IP地址的数据包
    [[10]](#fspoof)。如果攻击目标是单个最终用户，例如爱丽丝，这对该用户来说很烦人。然而，如果攻击者可以针对为整个公司或整个ISP提供服务的DNS解析器，攻击的影响可能会更大，特别是如果注入的DNS响应携带一个长的TTL，从而在解析器的缓存中保留很长时间。
- en: Fortunately, designers of DNS servers and resolvers have found solutions to
    mitigate this type of attack. The easiest approach would have been to update the
    format of the DNS requests and responses to include a larger Identifier field.
    Unfortunately, this elegant solution was not possible with the DNS because the
    DNS messages do not include any version number that would have enabled such a
    change. Since the DNS messages are exchanged inside UDP segments, the DNS developers
    found an alternate solution to counter this attack. There are two ways for the
    DNS library used by Alice to send her DNS requests. A first solution is to bind
    one UDP source port and always send the DNS requests from this source port (the
    destination port is always port `53`). The advantage of this solution is that
    Alice’s DNS library can easily receive the DNS responses by listening to her chosen
    port. Unfortunately, once the attacker has found the source port used by Alice,
    he only needs to send 65,536 DNS responses to inject an invalid response. Fortunately,
    Alice can send her DNS requests in a different way. Instead of using the same
    source port for all DNS requests, she can use a different source port for each
    request. In practice, each DNS request will be sent from a different source port.
    From an implementation viewpoint, this implies that Alice’s DNS library will need
    to listen to one different port number for each pending DNS request. This increases
    the complexity of her implementation. From a security viewpoint there is a clear
    benefit since the attacker needs to guess both the 16 bits Identifier and the
    16 bits UDP source port to inject a fake DNS response. To generate all possible
    DNS responses, the attacker would need to generate almost \(2^{32}\) different
    messages, which is excessive in today’s networks. Most DNS implementations use
    this second approach to prevent these cache poisoning attacks.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，DNS服务器和解析器的开发者已经找到了缓解此类攻击的解决方案。最简单的方法可能是更新DNS请求和响应的格式，以包括一个更大的标识符字段。不幸的是，由于DNS消息不包含任何版本号，这种优雅的解决方案在DNS中是不可能的。因为DNS消息是在UDP段内交换的，DNS开发者找到了一种替代方案来对抗这种攻击。Alice使用的DNS库发送DNS请求有两种方式。第一种解决方案是绑定一个UDP源端口，并始终从这个源端口发送DNS请求（目标端口始终是端口`53`）。这种解决方案的优势在于Alice的DNS库可以轻松地通过监听所选端口来接收DNS响应。不幸的是，一旦攻击者发现了Alice使用的源端口，他只需要发送65,536个DNS响应来注入一个无效的响应。幸运的是，Alice可以通过不同的方式发送她的DNS请求。她不必为所有DNS请求使用相同的源端口，可以为每个请求使用不同的源端口。在实践中，每个DNS请求都将从一个不同的源端口发送。从实现的角度来看，这意味着Alice的DNS库需要为每个挂起的DNS请求监听一个不同的端口号。这增加了她实现的复杂性。从安全的角度来看，这有一个明显的优势，因为攻击者需要猜测16位的标识符和16位的UDP源端口来注入一个伪造的DNS响应。为了生成所有可能的DNS响应，攻击者需要生成几乎\(2^{32}\)个不同的消息，这在今天的网络中是过度的。大多数DNS实现都使用第二种方法来防止这些缓存中毒攻击。
- en: These attacks affect the DNS messages that are exchanged between a client and
    its resolver or between a resolver and name servers. Another type of attack exploits
    the possibility of providing several resource records inside one DNS response.
    A frequent optimization used by DNS servers and resolvers is to include several
    related resource records in each response. For example, if a client sends a DNS
    query for an NS record, it usually receives in the response both the queried record,
    i.e. the name of the DNS server that serves the queried domain, and the IP addresses
    of this server. Some DNS servers return several NS records and the associated
    IP addresses. The cache poisoning attack exploits this DNS optimization.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击影响客户端与其解析器或解析器与名称服务器之间交换的DNS消息。另一种攻击类型利用了在一个DNS响应中提供多个资源记录的可能性。DNS服务器和解析器常用的一个常见优化是在每个响应中包含多个相关的资源记录。例如，如果客户端发送一个DNS查询请求NS记录，它通常会在响应中接收到查询记录，即服务于查询域的DNS服务器的名称，以及该服务器的IP地址。一些DNS服务器返回多个NS记录及其相关的IP地址。缓存中毒攻击利用了这种DNS优化。
- en: Let us illustrate it on an example. Assume that Alice frequently uses the example.net
    domain and in particular the web server whose name is www.example.net. Mallory
    would like to redirect the TCP connections established by Alice towards www.example.net
    to one IP address that he controls. Assume that Mallory controls the mallory.net
    domain. Mallory can tune the DNS server of his domain and add special DNS records
    to the responses that it sends. An attack could go roughly as follows. Mallory
    forces Alice to visit the www.mallory.net web site. He can achieve this by sending
    a spam message to Alice or buying advertisements on a web site visited by Alice
    and redirect one of these advertisements to www.mallory.net. When visiting the
    advertisement, Alice’s DNS resolver will send a DNS request for www.mallory.net.
    Since Mallory control the DNS server, he can easily add in the response a AAAA
    record that associates www.example.net to the IP address controlled by Mallory.
    If Alice’s DNS library does not check the returned response, the cache entry for
    www.example.net will be replaced by the AAAA record sent by Mallory.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明。假设Alice经常使用example.net域名，特别是名为www.example.net的Web服务器。Mallory希望将Alice建立的指向www.example.net的TCP连接重定向到他控制的某个IP地址。假设Mallory控制mallory.net域名。Mallory可以调整他域名的DNS服务器，并向发送的响应中添加特殊的DNS记录。攻击可能大致如下。Mallory迫使Alice访问www.mallory.net网站。他可以通过向Alice发送垃圾邮件或购买Alice访问的网站上的广告，并将其中一条广告重定向到www.mallory.net来实现。当访问广告时，Alice的DNS解析器将发送一个针对www.mallory.net的DNS请求。由于Mallory控制DNS服务器，他可以轻松地在响应中添加一个AAAA记录，将www.example.net关联到Mallory控制的IP地址。如果Alice的DNS库没有检查返回的响应，则www.example.net的缓存条目将被Mallory发送的AAAA记录替换。
- en: To cope with these security threats and improve the security of the DNS, the
    IETF has defined several extensions that are known as DNSSEC. DNSSEC exploits
    public-key cryptography to authenticate the content of the DNS records that are
    sent by DNS servers and resolvers. DNSEC is defined in three main documents [**RFC
    4033**](https://datatracker.ietf.org/doc/html/rfc4033.html), [**RFC 4034**](https://datatracker.ietf.org/doc/html/rfc4034.html),
    [**RFC 4035**](https://datatracker.ietf.org/doc/html/rfc4035.html). With DNSSEC,
    each DNS zone uses one public-private key pair. This key pair is only used to
    sign and authenticate DNS records. The DNS records are not encrypted and DNSSEC
    does not provide any confidentiality. Other DNS extensions are being developed
    to ensure the confidentiality of the information exchanged between a client and
    its resolvers [**RFC 7626**](https://datatracker.ietf.org/doc/html/rfc7626.html).
    Some of these extensions exchange DNS records over a TLS session which provides
    the required confidentiality, but they are not yet deployed and outside the scope
    of this chapter.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些安全威胁并提高DNS的安全性，IETF定义了几个被称为DNSSEC的扩展。DNSSEC利用公钥密码学来验证DNS服务器和解析器发送的DNS记录的内容。DNSSEC定义在三个主要文档中：[**RFC
    4033**](https://datatracker.ietf.org/doc/html/rfc4033.html)、[**RFC 4034**](https://datatracker.ietf.org/doc/html/rfc4034.html)、[**RFC
    4035**](https://datatracker.ietf.org/doc/html/rfc4035.html)。使用DNSSEC，每个DNS区域使用一个公钥私钥对。这个密钥对仅用于签名和验证DNS记录。DNS记录不会被加密，DNSSEC也不提供任何机密性。其他DNS扩展正在开发中，以确保客户端与其解析器之间交换信息的机密性[**RFC
    7626**](https://datatracker.ietf.org/doc/html/rfc7626.html)。其中一些扩展通过TLS会话交换DNS记录，这提供了所需的机密性，但它们尚未部署，也不在本章的范围内。
- en: DNSSEC defines four new types of DNS records that are used together to authenticate
    the information distributed by the DNS.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC定义了四种新的DNS记录类型，这些记录类型一起使用以验证DNS分发的信息。
- en: the DNSKEY record allows storing the public key associated with a zone. This
    record is encoded as a TLV and includes a Base64 representation of the key and
    the identification of the public key algorithm. This allows the DNSKEY record
    to support different public key algorithms.
  id: totrans-1623
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNSKEY记录允许存储与区域关联的公钥。此记录以TLV编码，包括密钥的Base64表示和公钥算法的标识。这允许DNSKEY记录支持不同的公钥算法。
- en: ''
  id: totrans-1624
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1625
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the RRSIG record is used to encode the signature of a DNS record. This record
    contains several sub-fields. The most important ones are the algorithm used to
    generate the signature, the identifier of the public key used to sign the record,
    the original TTL of the signed record and the validity period for the signature.
  id: totrans-1626
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RRSIG记录用于编码DNS记录的签名。此记录包含几个子字段。其中最重要的包括生成签名的算法、用于签名的公钥的标识符、签名的原始TTL以及签名的有效期。
- en: ''
  id: totrans-1627
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1628
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the DS record contains a hash of a public key. It is used by a parent zone to
    certify the public key used by one of its child zones.
  id: totrans-1629
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: DS记录包含一个公钥的哈希值。它被父区域用来证明其子区域使用的公钥。
- en: ''
  id: totrans-1630
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1631
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the NSEC record is used when non-existent domain names are queried. Its usage
    will be explained later
  id: totrans-1632
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查询不存在的域名时，会使用NSEC记录。其用法将在后面解释。
- en: The simplest way to understand the operation of DNSSEC is to rely on a simple
    example. Let us consider the example.org domain and assume that Alice wants to
    retrieve the AAAA record for www.example.org using DNSSEC.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解DNSSEC的操作，最简单的方法是依靠一个简单的例子。让我们考虑example.org域，并假设Alice想使用DNSSEC检索www.example.org的AAAA记录。
- en: The security of DNSSEC relies on anchored keys. An anchored key is a public
    key that is considered as trusted by a resolver. In our example, we assume that
    Alice’s resolver has obtained the public key of the servers that manage the root
    zone in a secure way. This key has been distributed outside of the DNS, e.g. it
    has been published in a newspaper or has been received in a sealed letter.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC的安全性依赖于锚定密钥。锚定密钥是一个被认为由解析器信任的公钥。在我们的例子中，我们假设Alice的解析器已经以安全的方式获得了管理根区域的服务器的公钥。这个密钥是在DNS之外分发的，例如，它已经在报纸上发布过，或者通过密封的信件接收过。
- en: To obtain an authenticated record for www.example.org, Alice’s resolver first
    needs to retrieve the NS which is responsible for the .org Top-Level Domain (TLD).
    This record is served by the DNS root server and Alice’s resolver can retrieve
    the signature (RRSIG record) for this NS record. Since Alice knows the DNSKEY
    of the root, she can verify the validity of this signature.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取www.example.org的认证记录，Alice的解析器首先需要检索负责.org顶级域名(TLD)的NS记录。这个记录由DNS根服务器提供，Alice的解析器可以检索这个NS记录的签名（RRSIG记录）。由于Alice知道根的DNSKEY，她可以验证这个签名的有效性。
- en: The next step is to contact ns.org, the NS responsible for the .org TLD to retrieve
    the NS record for the example.org domain. This record is accompanied by a RRSIG
    record that authenticates it. This RRSIG record is signed with the key of the
    .org domain. Alice’s resolver can retrieve this public key as the DNSKEY record
    for the .org, but how can it trust this key since it is distributed by using the
    DNS and could have been modified by attackers ? DNSSEC solves this problem by
    using the DS record that is stored in the parent zone (in this case, the root
    zone). This record contains a hash of a public key that is signed with a RRSIG
    signature. Since Alice’s resolver’s trusts the root key, it can validate the signature
    of the DS record for the .org domain. It can then retrieve the DNSKEY record for
    this domain from the DNS and compare the hash of this key with the DS record.
    If they match, the public key of the .org domain can be trusted. The same technique
    is used to obtain and validate the key of the example.org domain. Once this key
    is trusted, Alice’s resolver can request the AAAA record for www.example.org and
    validate its signature.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是联系ns.org，负责.org TLD的NS记录，以检索example.org域的NS记录。这个记录附带有验证其有效性的RRSIG记录。这个RRSIG记录是用.org域的密钥签名的。Alice的解析器可以检索这个公钥作为.org的DNSKEY记录，但如何信任这个密钥，因为它是通过DNS分发的，可能已经被攻击者修改过？DNSSEC通过使用存储在父区域（在这种情况下，是根区域）中的DS记录来解决此问题。这个记录包含一个用RRSIG签名签名的公钥哈希值。由于Alice的解析器信任根密钥，它可以验证.org域的DS记录的签名。然后，它可以从DNS中检索这个域的DNSKEY记录，并将这个密钥的哈希值与DS记录进行比较。如果它们匹配，可以信任.org域的公钥。相同的技巧用于获取和验证example.org域的密钥。一旦这个密钥被信任，Alice的解析器可以请求www.example.org的AAAA记录并验证其签名。
- en: Thanks to the DS record, a resolver can validate the public keys of client zones
    as long as their is a chain of DS -> DNSKEY records from an anchored key. If the
    resolver trusts the public key of the root zone, it can validate all DNS replies
    for which this chain exists.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了DS记录，解析器可以在存在从锚定密钥的DS -> DNSKEY记录链的情况下验证客户端区域的公钥。如果解析器信任根区域的公钥，它可以验证所有存在此链的DNS回复。
- en: There are several details of the operation of DNSSEC that are worth being discussed.
    First, a server that supports DNSSEC must have a public-private key pair. The
    public key is distributed with the DNSKEY record. The private key is never distributed
    and it does not even need to be stored on the server that uses the public key.
    DNSSEC does not require the DNSSEC servers to perform any operation that requires
    a private key in real time. All the RRSIG records can be computed offline, possibly
    on a different server than the server that returns the DNSSEC replies. The initial
    motivation for this design choice was the CPU complexity of computing the RRSIG
    signatures for zones that contain millions of records. In the early days of DNSSEC,
    this was an operational constraint. Today, this is less an issue, but avoiding
    costly signature operations in real time has two important benefits. First, this
    reduces the risk of denial of service attacks since an attacker cannot force a
    DNSSEC server to perform computationally intensive signing operations. Second,
    the private key can be stored offline, which means that even if an attacker gains
    access to the DNSSEC server, it cannot retrieve its private key. Using offline
    signatures for the RRSIG records has some practical implications that are reflected
    in the content of this record. First, each RRSIG record contains the original
    TTL of the signed record. When DNS resolvers cache records, they change the value
    of the TTL of these cached records and then return the modified records to their
    clients. When a resolver receives a signed DNS record, it must replace the received
    TTL of the record with the original TTL (and check that the received TTL is smaller
    than the original one) before checking the signature. Second, the RRSIG records
    contain a validity period, i.e. a starting time and an ending time for the validity
    of the signature. This period is specified as two timestamps. This period is only
    the validity of the signature. It does not affect the TTL of the signed record
    and is independent from the TTL. In practice, the validity period is important
    to allow DNS server operators to update their public/private keys. When such a
    key is changed, e.g. because the private could have been compromised, there is
    some period of time during which records signed with the two keys coexist in the
    network. The validity period allows ensuring that old signatures do not remain
    in DNS caches for ever.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC 运作中有几个细节值得讨论。首先，支持 DNSSEC 的服务器必须拥有一对公钥和私钥。公钥与 DNSKEY 记录一起分发。私钥永远不会分发，甚至不需要存储在使用公钥的服务器上。DNSSEC
    不要求 DNSSEC 服务器实时执行任何需要私钥的操作。所有 RRSIG 记录都可以离线计算，可能是在返回 DNSSEC 响应的服务器之外的其他服务器上。这种设计选择的初始动机是计算包含数百万条记录的区域
    RRSIG 签名的 CPU 复杂性。在 DNSSEC 的早期，这是一个操作限制。如今，这已不再是问题，但避免实时进行昂贵的签名操作有两个重要好处。首先，这降低了拒绝服务攻击的风险，因为攻击者无法迫使
    DNSSEC 服务器执行计算密集型的签名操作。其次，私钥可以离线存储，这意味着即使攻击者获得了对 DNSSEC 服务器的访问权限，也无法检索其私钥。对于 RRSIG
    记录使用离线签名有一些实际影响，这些影响反映在本记录的内容中。首先，每个 RRSIG 记录都包含所签记录的原始 TTL。当 DNS 解析器缓存记录时，它们会更改这些缓存记录的
    TTL 值，然后将修改后的记录返回给客户端。当解析器收到一个签名的 DNS 记录时，它必须在检查签名之前用原始 TTL 替换收到的 TTL（并检查收到的 TTL
    是否小于原始值）。其次，RRSIG 记录包含一个有效期，即签名的起始时间和结束时间。这个时间段仅指签名的有效期。它不影响所签记录的 TTL，并且独立于 TTL。在实践中，有效期对于允许
    DNS 服务器操作员更新他们的公钥/私钥非常重要。当这样的密钥更改时，例如，因为私钥可能已被泄露，网络中存在两个密钥签名的记录共存的一段时间。有效期确保旧签名不会永远留在
    DNS 缓存中。
- en: The last record introduced by DNSSEC is the NSEC record. It is used to authenticate
    a negative response returned by a DNS server. If a resolver requests a domain
    name that is not defined in the zone, the server replies with an error message.
    The designers of the original version of the DNS thought that these errors would
    not be very frequent and resolvers were not required to cache those negative responses.
    However, operational experience showed that queries for invalid domain names are
    more frequent than initially expected and a large fraction of the load on some
    servers is caused by repeated queries for invalid names. Typical examples include
    queries for invalid TLDs to the root DNS servers or queries caused by configuration
    errors [[WF2003]](../bibliography.html#wf2003). Current DNS deployments allow
    resolvers to cache those negative answers to reduce the load on the entire DNS
    [**RFC 2308**](https://datatracker.ietf.org/doc/html/rfc2308.html).
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC引入的最后一条记录是NSEC记录。它用于验证DNS服务器返回的负响应。如果解析器请求一个在区域中未定义的域名，服务器会回复一个错误信息。DNS原始版本的设计者认为这些错误不会非常频繁，解析器不需要缓存这些负响应。然而，运营经验表明，对无效域名的查询比最初预期的更频繁，一些服务器上的大量负载是由对无效名称的重复查询造成的。典型的例子包括对根DNS服务器无效顶级域名的查询或由配置错误引起的查询
    [[WF2003]](../bibliography.html#wf2003)。当前的DNS部署允许解析器缓存这些负答案以减少整个DNS的负载 [**RFC
    2308**](https://datatracker.ietf.org/doc/html/rfc2308.html)。
- en: The simplest way to allow a DNSSEC server to return signed negative responses
    would be for the server to return a signed response that contains the received
    query and some information indicating the error. The client could then easily
    check the validity of the negative response. Unfortunately, this would force the
    DNSSEC server to generate signatures in real time. This implies that the private
    key must be stored in the server memory, which leads to risks if an attacker can
    take control of the server. Furthermore, those signatures are computationally
    complex and a simple denial of service attack would be to send invalid queries
    to a DNSSEC server.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 允许DNSSEC服务器返回签名负响应的最简单方法可能是服务器返回一个包含接收到的查询和一些指示错误的信息的签名响应。然后客户端可以轻松地检查负响应的有效性。不幸的是，这将迫使DNSSEC服务器实时生成签名。这意味着私钥必须存储在服务器内存中，如果攻击者可以控制服务器，这将导致风险。此外，这些签名计算复杂，一个简单的拒绝服务攻击可能是向DNSSEC服务器发送无效查询。
- en: 'Given the above security risks, DNSSEC opted for a different approach that
    allows the negative replies to be authenticated by using offline signatures. The
    NSEC record exploits the lexicographical ordering of all the domain names. To
    understand its usage, consider a simple domain that contains three names (the
    associated AAAA and other records that are not shown) :'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述安全风险，DNSSEC选择了一种不同的方法，允许使用离线签名来验证负回复。NSEC记录利用了所有域名的字典顺序。为了理解其用法，考虑一个包含三个名称（未显示的关联AAAA和其他记录）的简单域：
- en: '[PRE4]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this domain, the DNSSEC server adds three NSEC records. A RRSIG signature
    is also computed for each of these records.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个域中，DNSSEC服务器添加了三个NSEC记录。还为这些记录中的每一个计算了一个RRSIG签名。
- en: '[PRE5]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If a resolver queries delta.example.org, the server will parse its zone. If
    this name were present, it would have been placed, in lexicographical order, between
    the beta.example.org and the gamma.example.org names. To confirm that the delta.example.org
    name does not exist, the server returns the NSEC record for beta.example.org that
    indicates that the next valid name after beta.example.org is gamma.example.org.
    If the server receives a query for pi.example.org, this is the NSEC record for
    gamma.example.org that will be returned. Since this record contains a name that
    is before pi.example.org in lexicographical order, this indicates that pi.example.org
    does not exist.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解析器查询delta.example.org，服务器将解析其区域。如果这个名称存在，它将按照字典顺序放置在beta.example.org和gamma.example.org名称之间。为了确认delta.example.org名称不存在，服务器返回beta.example.org的NSEC记录，该记录表明beta.example.org之后的下一个有效名称是gamma.example.org。如果服务器收到对pi.example.org的查询，这将返回gamma.example.org的NSEC记录。由于这个记录包含一个在字典顺序上位于pi.example.org之前的名称，这表明pi.example.org不存在。
- en: Footnotes
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
