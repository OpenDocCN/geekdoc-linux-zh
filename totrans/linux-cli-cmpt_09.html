<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>File Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>File Properties</h1>
<blockquote>原文：<a href="https://learnbyexample.github.io/cli-computing/file-properties.html">https://learnbyexample.github.io/cli-computing/file-properties.html</a></blockquote><p>In this chapter, you'll learn how to view file details like line and word counts, file and disk sizes, file types, extract parts of a file path, etc. You'll also learn how to change file properties like timestamps and permissions.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files">example_files</a> directory has the scripts and sample input files used in this chapter.</p></blockquote><h2 id="wc"><a class="header" href="#wc">wc</a></h2><p>The <code>wc</code> command is typically used to count the number of lines, words and characters for the given inputs. Here are some basic examples:</p><pre><code class="language-bash"># change to the 'example_files/text_files' directory
$ cat greeting.txt
Hi there
Have a nice day

# by default, wc gives the newline/word/byte count (in that order)
$ wc greeting.txt
 2  6 25 greeting.txt

# get only the specified counts
$ wc -l greeting.txt
2 greeting.txt
$ wc -w greeting.txt
6 greeting.txt
$ wc -c greeting.txt
25 greeting.txt
$ wc -wc greeting.txt
 6 25 greeting.txt
</code></pre><p>Filename won't be printed for stdin data. This is helpful to save the results in a variable for scripting purposes.</p><pre><code class="language-bash">$ wc -l &amp;LTgreeting.txt
2
</code></pre><p>Word count is based on whitespace separation. You can pre-process the input to prevent certain non-whitespace characters to influence the results. <code>tr</code> can be used to remove a particular set of characters (this command will be discussed in the <a href="./assorted-text-processing-tools.html">Assorted Text Processing Tools</a> chapter).</p><pre><code class="language-bash">$ echo 'apple ; banana ; cherry' | wc -w
5

# remove characters other than alphabets and whitespace
# -d option is for deleting, -c option complements the given set
$ echo 'apple ; banana ; cherry' | tr -cd 'a-zA-Z[:space:]'
apple  banana  cherry
$ echo 'apple ; banana ; cherry' | tr -cd 'a-zA-Z[:space:]' | wc -w
3
</code></pre><p>If you pass multiple files to the <code>wc</code> command, the count values will be displayed separately for each file. You'll also get a summary at the end, which sums the respective count of all the input files.</p><pre><code class="language-bash">$ wc greeting.txt fruits.txt sample.txt
  2   6  25 greeting.txt
  3   3  20 fruits.txt
 15  38 183 sample.txt
 20  47 228 total
</code></pre><p>You can use the <code>-L</code> option to report the length of the longest line in the input (excluding the newline character of a line). Note that <code>-L</code> won't count non-printable characters and tabs are converted to equivalent spaces. Multibyte characters and <a href="https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">grapheme clusters</a> will each be counted as <code>1</code> (depending on the locale, they might become non-printable too).</p><pre><code class="language-bash">$ echo 'apple' | wc -L
5

$ echo 'αλεπού cag̈e' | wc -L
11

$ wc -L &amp;LTgreeting.txt
15
</code></pre><p>Use the <code>-m</code> option instead of <code>-c</code> if the input has multibyte characters.</p><pre><code class="language-bash">$ printf 'αλεπού' | wc -c
12

$ printf 'αλεπού' | wc -m
6
</code></pre><h2 id="du"><a class="header" href="#du">du</a></h2><p>The <code>du</code> command helps you estimate the size of files and directories.</p><p>By default, size is given in terms of 1024 bytes. All directories and sub-directories are recursively reported, but files are ignored. You can use the <code>-a</code> option if files should also be reported. <code>du</code> is one of the commands that require an explicit option (<code>-L</code> in this case) if you want symbolic links to be followed.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'du.sh' script
$ source du.sh

# n * 1024 bytes
$ du
28      ./projects/scripts
48      ./projects
8       ./todos
7536    .
</code></pre><p>Use the <code>-s</code> option to show the total directory size without descending into sub-directories. Add the <code>-c</code> option to also show the total size at the end.</p><pre><code class="language-bash">$ du -s projects report.log
48      projects
7476    report.log

$ du -sc projects report.log
48      projects
7476    report.log
7524    total
</code></pre><p>Here are some examples to illustrate the size formatting options:</p><pre><code class="language-bash"># number of bytes
$ du -b report.log
7654321 report.log

# n * 1024 bytes
$ du -k report.log
7476    report.log

# n * 1024 * 1024 bytes
$ du -m report.log
8       report.log
</code></pre><p>The <code>-h</code> option reports size in human readable format (uses power of 1024). Use the <code>--si</code> option to get results in powers of 1000 instead. If you use <code>du -h</code>, you can pipe the output to <code>sort -h</code> for sorting purposes.</p><pre><code class="language-bash">$ du -sh *
48K     projects
7.4M    report.log
8.0K    todos

$ du -sh * | sort -h
8.0K    todos
48K     projects
7.4M    report.log
</code></pre><h2 id="df"><a class="header" href="#df">df</a></h2><p>The <code>df</code> command gives you the space usage of file systems. <code>df</code> without path arguments will give information about all the currently mounted file systems.</p><pre><code class="language-bash">$ df .
Filesystem     1K-blocks     Used Available Use% Mounted on
/dev/sda1       98298500 58563816  34734748  63% /
</code></pre><p>Use the <code>-h</code> option for human readable sizes. The <code>-B</code> option allows you to scale sizes by the specified amount. Use <code>--si</code> for size in powers of 1000 instead of 1024.</p><pre><code class="language-bash">$ df -h .
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        94G   56G   34G  63% /
</code></pre><p>Use the <code>--output</code> option to report only the specific fields of interest:</p><pre><code class="language-bash">$ df -h --output=size,used,file / /media/learnbyexample/projs
 Size  Used File
  94G   56G /
  92G   35G /media/learnbyexample/projs

# 'awk' here excludes first line and matches lines with first field &gt;= 30
$ df -h --output=pcent,fstype,target | awk 'NR&gt;1 &amp;&amp; $1&gt;=30'
 63% ext3     /
 38% ext4     /media/learnbyexample/projs
 51% ext4     /media/learnbyexample/backups
</code></pre><h2 id="stat"><a class="header" href="#stat">stat</a></h2><p>The <code>stat</code> command is useful to get details like file type, size, inode, permissions, last accessed and modified timestamps, etc. You'll get all of these details by default. The <code>-c</code> and <code>--printf</code> options can be used to display only the required details in a particular format.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'stat.sh' script
$ source stat.sh

# %x gives the last accessed timestamp
$ stat -c '%x' ip.txt
2022-06-01 13:25:18.693823117 +0530

# %y gives the last modified timestamp
$ stat -c '%y' ip.txt
2022-05-24 14:39:41.285714934 +0530

# %s gives the file size in bytes
# \n is used to insert a newline
# %i gives the inode value
# same as: stat --printf='%s\n%i\n' ip.txt
$ stat -c $'%s\n%i' ip.txt
10
787224

# %N gives quoted filenames
# if the input is a link, the path it points to is also displayed
$ stat -c '%N' words.txt
'words.txt' -&gt; '/usr/share/dict/words'
</code></pre><p>You can also pass multiple file arguments:</p><pre><code class="language-bash"># %s gives the file size in bytes
# %n gives filenames
$ stat -c '%s %n' ip.txt hi.sh
10 ip.txt
21 hi.sh
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> <img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> The <code>stat</code> command should be preferred instead of parsing the <code>ls -l</code> output for file details. See <a href="https://mywiki.wooledge.org/ParsingLs">mywiki.wooledge: avoid parsing output of ls</a> and <a href="https://unix.stackexchange.com/q/128985/109046">unix.stackexchange: why not parse ls?</a> for explanation and other alternatives.</p></blockquote><h2 id="touch"><a class="header" href="#touch">touch</a></h2><p>As mentioned earlier, the <code>touch</code> command helps you change the timestamps of files. You can do so based on the current timestamp, passing an argument, copying the value from another file and so on.</p><p>By default, <code>touch</code> updates both the access and modification timestamps to the current time. You can use the <code>-a</code> option to change only the access timestamp and <code>-m</code> to change only the modification timestamp.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'touch.sh' script
$ source touch.sh

# last access and modification timestamps
$ stat -c $'%x\n%y' fruits.txt
2017-07-19 17:06:01.523308599 +0530
2017-07-13 13:54:03.576055933 +0530

# update the access and modification values to the current time
$ touch fruits.txt
$ stat -c $'%x\n%y' fruits.txt
2024-05-14 13:01:25.921205889 +0530
2024-05-14 13:01:25.921205889 +0530
</code></pre><p>You can use the <code>-r</code> option to copy timestamp information from one file to another. The <code>-d</code> and <code>-t</code> options will allow you to specify timestamps directly as part of the command.</p><pre><code class="language-bash">$ stat -c '%y' hi.sh
2022-06-14 13:00:46.170416890 +0530

# copy the modified timestamp from 'ip.txt' to 'hi.sh'
$ touch -m -r ip.txt hi.sh
$ stat -c '%y' hi.sh
2022-05-24 14:39:41.285714934 +0530

# pass timestamp as an argument
$ touch -m -d '2000-01-01 00:00:01' hi.sh
$ stat -c '%y' hi.sh
2000-01-01 00:00:01.000000000 +0530
</code></pre><p>As seen in the <a href="./managing-files-directories.html">Managing Files and Directories</a> chapter, <code>touch</code> creates a new file if the target file doesn't exist yet. You can use the <code>-c</code> option to prevent this behavior.</p><pre><code class="language-bash">$ ls report.txt
ls: cannot access 'report.txt': No such file or directory
$ touch report.txt
$ ls report.txt
report.txt

$ touch -c xyz.txt
$ ls xyz.txt
ls: cannot access 'xyz.txt': No such file or directory
</code></pre><h2 id="file"><a class="header" href="#file">file</a></h2><p>The <code>file</code> command helps you identify text encoding (ASCII, UTF-8, etc), whether the file is executable and so on.</p><p>Here are some examples to show how the <code>file</code> command behaves for different types:</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'file.sh' script
$ source file.sh
$ ls -F
hi.sh*  ip.txt  moon.png  sunrise.jpg

$ file ip.txt hi.sh
ip.txt: ASCII text
hi.sh: Bourne-Again shell script, ASCII text executable

$ printf 'αλεπού\n' | file -
/dev/stdin: UTF-8 Unicode text

$ printf 'hi\r\n' | file -
/dev/stdin: ASCII text, with CRLF line terminators
</code></pre><p>Here's an example for image files:</p><pre><code class="language-bash"># output of 'sunrise.jpg' wrapped for illustration purposes
$ file sunrise.jpg moon.png
sunrise.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density
    96x96, segment length 16, baseline, precision 8, 76x76, components 3
moon.png:    PNG image data, 76 x 76, 8-bit colormap, non-interlaced
</code></pre><p>You can use the <code>-b</code> option to avoid filenames in the output:</p><pre><code class="language-bash">$ file -b ip.txt
ASCII text
</code></pre><p>Here's how you can find particular type of files, images for example.</p><pre><code class="language-bash"># assuming filenames do not contain ':' or newline characters
# awk here helps to print the first field of lines containing 'image data'
$ find -type f -exec file {} + | awk -F: '/\&amp;LTimage data\&gt;/{print $1}'
./sunset.jpg
./moon.png
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> See also the <code>identify</code> command which "describes the format and characteristics of one or more image files".</p></blockquote><h2 id="basename"><a class="header" href="#basename">basename</a></h2><p>By default, the <code>basename</code> command will remove the leading directory component from the given path argument. Any trailing slashes will be removed before determining the portion to be extracted.</p><pre><code class="language-bash">$ basename /home/learnbyexample/example_files/scores.csv
scores.csv

# quote the arguments as needed
$ basename 'path with spaces/report.log'
report.log
</code></pre><p>You can use the <code>-s</code> option to remove a suffix from the filename. Usually used to remove the file extension.</p><pre><code class="language-bash">$ basename -s'.csv' /home/learnbyexample/example_files/scores.csv
scores

# suffix will be removed only once
$ basename -s'.txt' purchases.txt.txt
purchases.txt
</code></pre><p>The <code>basename</code> command requires <code>-a</code> or <code>-s</code> (which implies <code>-a</code>) to work with multiple arguments.</p><pre><code class="language-bash">$ basename -a /backups/jan_2021.tar.gz /home/learnbyexample/report.log
jan_2021.tar.gz
report.log

# -a is implied when -s is used
$ basename -s'.txt' logs/purchases.txt logs/report.txt
purchases
report
</code></pre><h2 id="dirname"><a class="header" href="#dirname">dirname</a></h2><p>By default, the <code>dirname</code> command removes the trailing path component (after removing any trailing slashes).</p><pre><code class="language-bash">$ dirname /home/learnbyexample/example_files/scores.csv
/home/learnbyexample/example_files

# one or more trailing slashes will not affect the output
$ dirname /home/learnbyexample/example_files/
/home/learnbyexample

# unlike basename, multiple arguments are accepted by default
$ dirname /home/learnbyexample/example_files/scores.csv ../report/backups/
/home/learnbyexample/example_files
../report
</code></pre><p>You can use shell features like command substitution to combine the effects of the <code>basename</code> and <code>dirname</code> commands.</p><pre><code class="language-bash"># extract the second last path component
$ basename $(dirname /home/learnbyexample/example_files/scores.csv)
example_files
</code></pre><h2 id="chmod"><a class="header" href="#chmod">chmod</a></h2><p>You can use the <code>chmod</code> command to change permissions. Consider this example:</p><pre><code class="language-bash">$ mkdir practice_chmod
$ cd practice_chmod
$ echo 'learnbyexample' &gt; ip.txt

# this info can also be seen in the first column of the 'ls -l' output
$ stat -c '%A' ip.txt
-rw-rw-r--
</code></pre><p>In the above output, the 10 characters displayed in the last line are related to file type and permissions. First character indicates the <strong>file type</strong>. The most common ones are shown below:</p><ul><li><code>-</code> regular file</li><li><code>d</code> directory</li><li><code>l</code> symbolic link</li></ul><p>The other nine characters represent three sets of <strong>file permissions</strong> for <em>user</em> (<code>u</code>), <em>group</em> (<code>g</code>) and <em>others</em> (<code>o</code>), in that order.</p><ul><li><em>user</em> — file owner</li><li><em>group</em> — users having file access as part of a group</li><li><em>others</em> — everyone else</li></ul><p>Only <code>rwx</code> file properties will be discussed in this section. For other types of properties, refer to the <a href="https://www.gnu.org/software/coreutils/manual/coreutils.html#File-permissions">coreutils manual: File permissions</a>.</p><p><strong>Permission reference table for files:</strong></p><div class="table-wrapper"><table><thead><tr><th>Character</th><th>Meaning</th><th>Value</th></tr></thead><tbody><tr><td><code>r</code></td><td>read</td><td><code>4</code></td></tr><tr><td><code>w</code></td><td>write</td><td><code>2</code></td></tr><tr><td><code>x</code></td><td>execute</td><td><code>1</code></td></tr><tr><td><code>-</code></td><td>no permission</td><td><code>0</code></td></tr></tbody></table></div><p>Here's an example showing both <code>rwx</code> and numerical representations of a file's permissions:</p><pre><code class="language-bash">$ stat -c '%A' ip.txt
-rw-rw-r--

# r(4) + w(2) + 0 = 6
# r(4) + 0 + 0 = 4
$ stat -c '%a' ip.txt
664
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Note that the permissions are not straightforward to understand for directories. If a directory only has the <code>x</code> permission, you can <code>cd</code> into it but you cannot read the contents (using <code>ls</code> for example). If a directory only has the <code>r</code> permission, you cannot <code>cd</code> into it, but you'll be able to read the contents (along with "cannot access" error). For this reason, the <code>rx</code> permissions are almost always enabled/disabled together. The <code>w</code> permission allows you to add or remove contents, provided <code>x</code> is active.</p></blockquote><p><strong>Changing permissions for all three categories</strong></p><p>You can provide numbers for <code>ugo</code> (in that order) to change permissions. This is best understood with examples:</p><pre><code class="language-bash">$ printf '#!/bin/bash\n\necho hi\n' &gt; hi.sh
$ stat -c '%a %A' hi.sh
664 -rw-rw-r--

# r(4) + w(2) + x(1) = 7
# r(4) + 0 + x(1) = 5
$ chmod 755 hi.sh
$ stat -c '%a %A' hi.sh
755 -rwxr-xr-x
</code></pre><p>Here's an example for a directory:</p><pre><code class="language-bash">$ mkdir dot_files
$ stat -c '%a %A' dot_files
775 drwxrwxr-x

$ chmod 700 dot_files
$ stat -c '%a %A' dot_files
700 drwx------
</code></pre><p>You can also use <code>mkdir -m</code> instead of the <code>mkdir+chmod</code> combination seen above. The argument to the <code>-m</code> option accepts the same syntax as <code>chmod</code> (including the format that'll be discussed next).</p><pre><code class="language-bash">$ mkdir -m 750 backups
$ stat -c '%a %A' backups
750 drwxr-x---
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> You can use <code>chmod -R</code> to recursively change permissions. Use <code>find+exec</code> if you want to apply changes only for files filtered by some criteria.</p></blockquote><p><strong>Changing permissions for specific categories</strong></p><p>You can assign (<code>=</code>), add (<code>+</code>) or remove (<code>-</code>) permissions by using those symbols followed by one or more <code>rwx</code> permissions. This depends on the <code>umask</code> value:</p><pre><code class="language-bash">$ umask
0002
</code></pre><p><code>umask</code> value of <code>0002</code> means:</p><ul><li>read and execute permissions without <code>ugo</code> prefix affects all the three categories</li><li>write permissions without <code>ugo</code> prefix affects only the <code>user</code> and <code>group</code> categories</li></ul><p>Here are some examples without <code>ugo</code> prefixes:</p><pre><code class="language-bash"># remove execute permission for all three categories
$ chmod -x hi.sh

# add write permission only for 'user' and 'group'
$ chmod +w ip.txt

$ touch sample.txt
$ chmod 702 sample.txt
# give only read permission for all three categories
# write/execute permissions, if any, will be removed
$ chmod =r sample.txt
$ stat -c '%a %A' sample.txt
444 -r--r--r--

# give read and write permissions for 'user' and 'group'
# and read permission for 'others'
# execute permissions, if any, will be removed
$ chmod =rw hi.sh
</code></pre><p>Here are some examples with <code>ugo</code> prefixes. You can use <code>a</code> to refer to all the three categories. For example, <code>a+w</code> is same as <code>ugo+w</code>.</p><pre><code class="language-bash"># remove read and write permissions only for 'others'
$ chmod o-rw sample.txt

# add execute permission for 'group' and 'others'
$ chmod go+x hi.sh

# give read and write permissions for all three categories
# execute permissions, if any, will be removed
$ chmod a=rw hi.sh
</code></pre><p>You can use <code>,</code> to separate multiple permissions:</p><pre><code class="language-bash"># remove execute permission for 'group' and 'others'
# remove write permission for 'others'
$ chmod go-x,o-w hi.sh
</code></pre><p><strong>Further Reading</strong></p><ul><li><a href="https://web.archive.org/web/20220930214830/https://danielmiessler.com/study/unixlinux_permissions/">Linux Permissions Primer</a></li><li><a href="https://unix.stackexchange.com/q/429421/109046">unix.stackexchange: why chmod +w filename not giving write permission to other</a></li></ul><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Use the <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files/text_files">example_files/text_files</a> directory for input files used in the following exercises, unless otherwise specified.</p></blockquote><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Create a temporary directory for exercises that may require you to create some files and directories. You can delete such practice directories afterwards.</p></blockquote><p><strong>1)</strong> Save the number of lines in the <code>greeting.txt</code> input file to the <code>lines</code> shell variable.</p><pre><code class="language-bash"># ???
$ echo "$lines"
2
</code></pre><p><strong>2)</strong> What do you think will be the output of the following command?</p><pre><code class="language-bash">$ echo 'dragons:2 ; unicorns:10' | wc -w
</code></pre><p><strong>3)</strong> Use appropriate options and arguments to get the output shown below.</p><pre><code class="language-bash">$ printf 'apple\nbanana\ncherry' | wc # ???
     15     183 sample.txt
      2      19 -
     17     202 total
</code></pre><p><strong>4)</strong> Go through the <code>wc</code> manual and use appropriate options and arguments to get the output shown below.</p><pre><code class="language-bash">$ printf 'greeting.txt\0scores.csv' | wc # ???
2 6 25 greeting.txt
4 4 70 scores.csv
6 10 95 total
</code></pre><p><strong>5)</strong> What is the difference between the <code>wc -c</code> and <code>wc -m</code> options? And which option would you use to get the longest line length?</p><p><strong>6)</strong> Find filenames ending with <code>.log</code> and report their sizes in human readable format. Use the <code>find+du</code> combination for the first case and the <code>ls</code> command (with appropriate shell features) for the second case.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'du.sh' script
$ source du.sh

# ??? find+du
16K     ./projects/errors.log
7.4M    ./report.log

# ??? ls and shell features
 16K projects/errors.log
7.4M report.log
</code></pre><p><strong>7)</strong> Report sizes of files/directories in the current path in powers of <code>1000</code> without descending into sub-directories. Also, show a total at the end.</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'du.sh' script
$ source du.sh

# ???
50k     projects
7.7M    report.log
8.2k    todos
7.8M    total
</code></pre><p><strong>8)</strong> What does the <code>du --apparent-size</code> option do?</p><p><strong>9)</strong> When will you use the <code>df</code> command instead of <code>du</code>? Which <code>df</code> command option will help you to report only the specific fields of interest?</p><p><strong>10)</strong> Display the size of <code>scores.csv</code> and <code>timings.txt</code> files in the format shown below.</p><pre><code class="language-bash">$ stat # ???
scores.csv: 70
timings.txt: 49
</code></pre><p><strong>11)</strong> Which <code>touch</code> option will help you prevent file creation if it doesn't exist yet?</p><p><strong>12)</strong> Assume <code>new_file.txt</code> doesn't exist in the current working directory. What would be the output of the <code>stat</code> command shown below?</p><pre><code class="language-bash">$ touch -t '202010052010.05' new_file.txt
$ stat -c '%y' new_file.txt
# ???
</code></pre><p><strong>13)</strong> Is the following <code>touch</code> command valid? If so, what would be the output of the <code>stat</code> command that follows?</p><pre><code class="language-bash"># change to the 'scripts' directory and source the 'touch.sh' script
$ source touch.sh

$ stat -c '%n: %y' fruits.txt
fruits.txt: 2017-07-13 13:54:03.576055933 +0530

$ touch -r fruits.txt f{1..3}.txt
$ stat -c '%n: %y' f*.txt
# ???
</code></pre><p><strong>14)</strong> Use appropriate option(s) to get the output shown below.</p><pre><code class="language-bash">$ printf 'αλεπού\n' | file -
/dev/stdin: UTF-8 Unicode text

$ printf 'αλεπού\n' | file # ???
UTF-8 Unicode text
</code></pre><p><strong>15)</strong> Is the following command valid? If so, what would be the output?</p><pre><code class="language-bash">$ basename -s.txt ~///test.txt///
# ???
</code></pre><p><strong>16)</strong> Given the file path in the shell variable <code>p</code>, how'd you obtain the output shown below?</p><pre><code class="language-bash">$ p='~/projects/square_tictactoe/python/game.py'
$ dirname # ???
~/projects/square_tictactoe
</code></pre><p><strong>17)</strong> Explain what each of the characters mean in the following <code>stat</code> command's output.</p><pre><code class="language-bash">$ stat -c '%A' ../scripts/
drwxrwxr-x
</code></pre><p><strong>18)</strong> What would be the output of the second <code>stat</code> command shown below?</p><pre><code class="language-bash">$ touch new_file.txt
$ stat -c '%a %A' new_file.txt
664 -rw-rw-r--

$ chmod 546 new_file.txt
$ stat -c '%a %A' new_file.txt
# ???
</code></pre><p><strong>19)</strong> How would you specify directory permissions using the <code>mkdir</code> command?</p><pre><code class="language-bash"># instead of this
$ mkdir back_up
$ chmod 750 back_up
$ stat -c '%a %A' back_up
750 drwxr-x---
$ rm -r back_up

# do this
$ mkdir # ???
$ stat -c '%a %A' back_up
750 drwxr-x---
</code></pre><p><strong>20)</strong> Change the file permission of <code>book_list.txt</code> to match the output of the second <code>stat</code> command shown below. Don't use the number <code>220</code>, specify the changes in terms of <code>rwx</code> characters.</p><pre><code class="language-bash">$ touch book_list.txt
$ stat -c '%a %A' book_list.txt
664 -rw-rw-r--

# ???
$ stat -c '%a %A' book_list.txt
220 --w--w----
</code></pre><p><strong>21)</strong> Change the permissions of <code>test_dir</code> to match the output of the second <code>stat</code> command shown below. Don't use the number <code>757</code>, specify the changes in terms of <code>rwx</code> characters.</p><pre><code class="language-bash">$ mkdir test_dir
$ stat -c '%a %A' test_dir
775 drwxrwxr-x

# ???
$ stat -c '%a %A' test_dir
757 drwxr-xrwx
</code></pre>    
</body>
</html>