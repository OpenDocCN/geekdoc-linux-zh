- en: Networked applications#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/applications.html](https://4ed.computer-networking.info/syllabus/default/hosts/applications.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://4ed.computer-networking.info/syllabus/default/hosts/applications.html](https://4ed.computer-networking.info/syllabus/default/hosts/applications.html)'
- en: 'There are two important models used to organize a networked application. The
    first and oldest model is the client-server model. In this model, a server provides
    services to clients that exchange information with it. This model is highly asymmetrical:
    clients send requests and servers perform actions and return responses. It is
    illustrated in the [Fig. 20](#fig-client-server).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序中有两种重要的模型用于组织。第一个也是最古老的模型是客户端-服务器模型。在这个模型中，服务器为与它交换信息的客户端提供服务。这个模型高度不对称：客户端发送请求，服务器执行操作并返回响应。这可以通过[图20](#fig-client-server)来说明。
- en: '![Figure made with TikZ](../Images/35b8e8bfa62002005d31831c316d5073.png)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/35b8e8bfa62002005d31831c316d5073.png)'
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 20 The client-server model
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图20 客户端-服务器模型
- en: The client-server model was the first model to be used to develop networked
    applications. This model comes naturally from the mainframes and minicomputers
    that were the only networked computers used until the 1980s. A [minicomputer](https://en.wikipedia.org/wiki/Minicomputer)
    is a multi-user system that is used by tens or more users at the same time. Each
    user interacts with the minicomputer by using a terminal. Such a terminal was
    mainly a screen, a keyboard and a cable directly connected to the minicomputer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器模型是第一个用于开发网络应用程序的模型。这个模型自然来源于20世纪80年代之前唯一使用的网络计算机——大型机和小型机。小型机是一个多用户系统，同时被数十个或更多的用户使用。每个用户通过终端与小型机交互。这样的终端主要是一个屏幕、一个键盘和直接连接到小型机的电缆。
- en: There are various types of servers as well as various types of clients. A web
    server provides information in response to the query sent by its clients. A print
    server prints documents sent as queries by the client. An email server forwards
    towards their recipient the email messages sent as queries while a music server
    delivers the music requested by the client. From the viewpoint of the application
    developer, the client and the server applications directly exchange messages (the
    horizontal arrows labeled Queries and Responses in the above figure), but in practice
    these messages are exchanged thanks to the underlying layers (the vertical arrows
    in the above figure). In this chapter, we focus on these horizontal exchanges
    of messages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端都有各种类型。一个Web服务器对其客户端发送的查询提供信息。一个打印服务器打印客户端发送的查询文档。一个电子邮件服务器将作为查询发送的电子邮件消息转发给其收件人。一个音乐服务器提供客户端请求的音乐。从应用开发者的角度来看，客户端和服务器应用程序直接交换消息（如图中标记为查询和响应的水平箭头），但在实践中，这些消息是通过底层（如图中垂直箭头所示）交换的。在本章中，我们关注这些水平消息交换。
- en: Networked applications do not exchange random messages. In order to ensure that
    the server is able to understand the queries sent by a client, and also that the
    client is able to understand the responses sent by the server, they must both
    agree on a set of syntactical and semantic rules. These rules define the format
    of the messages exchanged as well as their ordering. This set of rules is called
    an application-level protocol.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序不会交换随机消息。为了确保服务器能够理解客户端发送的查询，并且客户端能够理解服务器发送的响应，它们必须就一套句法和语义规则达成一致。这些规则定义了交换消息的格式以及它们的顺序。这套规则被称为应用层协议。
- en: 'An application-level protocol is similar to a structured conversation between
    humans. Assume that Alice wants to know the current time but does not have a watch.
    If Bob passes close by, the following conversation could take place :'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层协议类似于人类之间的结构化对话。假设Alice想知道当前时间，但没有手表。如果Bob经过，可能会发生以下对话：
- en: 'Alice : Hello'
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Alice : 你好'
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob : Hello'
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bob : 你好'
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alice : What time is it ?'
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Alice : 现在几点了？'
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob : 11:55'
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bob : 11:55'
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alice : Thank you'
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Alice : 谢谢'
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob : You’re welcome'
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bob : 不客气'
- en: 'Such a conversation succeeds if both Alice and Bob speak the same language.
    If Alice meets Tchang who only speaks Chinese, she won’t be able to ask him the
    current time. A conversation between humans can be more complex. For example,
    assume that Bob is a security guard whose duty is to only allow trusted secret
    agents to enter a meeting room. If all agents know a secret password, the conversation
    between Bob and Trudy could be as follows :'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的对话如果Alice和Bob说的是同一种语言就会成功。如果Alice遇到只会说中文的Tchang，她将无法询问他当前时间。人类之间的对话可能更复杂。例如，假设Bob是一名保安，他的职责是只允许信任的秘密特工进入会议室。如果所有特工都知道一个秘密密码，Bob和Trudy之间的对话可能如下：
- en: 'Bob : What is the secret password ?'
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob：什么才是秘密密码？
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Trudy : 1234'
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trudy：1234
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob : This is the correct password, you’re welcome'
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob：这是正确的密码，不客气
- en: 'If Alice wants to enter the meeting room but does not know the password, her
    conversation could be as follows :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Alice想进入会议室但不知道密码，她的对话可能如下：
- en: 'Bob : What is the secret password ?'
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob：什么才是秘密密码？
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alice : 3.1415'
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice：3.1415
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bob : This is not the correct password.'
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob：这不是正确的密码。
- en: 'Human conversations can be very formal, e.g. when soldiers communicate with
    their hierarchy, or informal such as when friends discuss. Computers that communicate
    are more akin to soldiers and require well-defined rules to ensure a successful
    exchange of information. There are two types of rules that define how information
    can be exchanged between computers :'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 人类对话可以是非常正式的，例如当士兵与他们的指挥层沟通时，或者非正式的，例如当朋友讨论时。通信的计算机更类似于士兵，需要明确的规定来确保信息交换的成功。定义信息如何在计算机之间交换的规则有两种：
- en: Syntactical rules that precisely define the format of the messages that are
    exchanged. As computers only process bits, the syntactical rules specify how information
    is encoded as bit strings.
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确定义交换消息格式的句法规则。由于计算机只处理比特，句法规则指定了信息如何编码为比特串。
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Organization of the information flow. For many applications, the flow of information
    must be structured and there are precedence relationships between the different
    types of information. In the time example above, Alice must greet Bob before asking
    for the current time. Alice would not ask for the current time first and greet
    Bob afterwards. Such precedence relationships exist in networked applications
    as well. For example, a server must receive a username and a valid password before
    accepting more complex commands from its clients.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息流的组织。对于许多应用，信息流必须是有结构的，并且不同类型的信息之间存在优先级关系。在上面的时间例子中，Alice必须在询问当前时间之前问候Bob。Alice不会先询问当前时间，然后才问候Bob。网络应用中也存在这样的优先级关系。例如，服务器必须在接收用户名和有效密码之后，才能接受来自其客户端的更复杂的命令。
- en: Let us first discuss the syntactical rules. We will later explain how the information
    flow can be organized by analyzing real networked applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论句法规则。我们将在分析真实网络应用后解释如何组织信息流。
- en: 'Application-layer protocols exchange two types of messages. Some protocols
    such as those used to support electronic mail exchange messages expressed as strings
    or lines of characters. As the transport layer allows hosts to exchange bytes,
    they need to agree on a common representation of the characters. The first and
    simplest method to encode characters is to use the [ASCII](../glossary.html#term-ASCII)
    table. [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html) provides
    the ASCII table that is used by many protocols on the Internet. For example, the
    table defines the following binary representations :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层协议交换两种类型的消息。一些协议，如用于支持电子邮件交换的协议，将消息表示为字符串或字符行。由于传输层允许主机交换字节，它们需要就字符的通用表示达成一致。编码字符的第一种和最简单的方法是使用[ASCII](../glossary.html#term-ASCII)表。[**RFC
    20**](https://datatracker.ietf.org/doc/html/rfc20.html)提供了许多互联网协议使用的ASCII表。例如，该表定义了以下二进制表示：
- en: 'A : 1000011b'
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A：1000011b
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0 : 0110000b'
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：0110000b
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'z : 1111010b'
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: z：1111010b
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '@ : 1000000b'
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@：1000000b'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'space : 0100000b'
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间：0100000b
- en: In addition, the [ASCII](../glossary.html#term-ASCII) table also defines several
    non-printable or control characters. These characters were designed to allow an
    application to control a printer or a terminal. These control characters include
    CR and LF, that are used to terminate a line, and the Bell character which causes
    the terminal to emit a sound.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[ASCII](../glossary.html#term-ASCII) 表还定义了几个不可打印或控制字符。这些字符被设计用来允许一个应用程序控制打印机或终端。这些控制字符包括用于结束行的回车符
    (CR) 和换行符 (LF)，以及引起终端发出声音的铃声字符。
- en: 'carriage return (CR) : 0001101b'
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '回车符 (CR) : 0001101b'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'line feed (LF) : 0001010b'
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '换行符 (LF) : 0001010b'
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bell: 0000111b'
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '铃声: 0000111b'
- en: The [ASCII](../glossary.html#term-ASCII) characters are encoded as a seven bits
    field, but transmitted as an eight-bits byte whose high order bit is usually set
    to 0. Bytes are always transmitted starting from the high order or most significant
    bit.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[ASCII](../glossary.html#term-ASCII) 字符被编码为七位字段，但以八位字节的形式传输，其最高位通常设置为 0。字节总是从最高位或最显著位开始传输。'
- en: Most applications exchange strings that are composed of fixed or variable numbers
    of characters. A common solution to define the character strings that are acceptable
    is to define them as a grammar using a Backus-Naur Form ([BNF](../glossary.html#term-BNF))
    such as the Augmented BNF defined in [**RFC 5234**](https://datatracker.ietf.org/doc/html/rfc5234.html).
    A BNF is a set of production rules that generate all valid character strings.
    For example, consider a networked application that uses two commands, where the
    user can supply a username and a password. The BNF for this application could
    be defined as shown in [Fig. 21](#fig-bnf).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序交换由固定或可变数量的字符组成的字符串。定义可接受的字符字符串的常见解决方案是使用 Backus-Naur 形式 ([BNF](../glossary.html#term-BNF))
    定义语法，例如在 [**RFC 5234**](https://datatracker.ietf.org/doc/html/rfc5234.html) 中定义的增强
    BNF。BNF 是一组生成所有有效字符字符串的生产规则。例如，考虑一个使用两个命令的联网应用程序，用户可以提供用户名和密码。该应用程序的 BNF 可以定义如图
    21 所示。
- en: '[![../_images/bnf.svg](../Images/c52c85ae5fb49120fd6b41bb42c81402.png)](../_images/bnf.svg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/bnf.svg](../Images/c52c85ae5fb49120fd6b41bb42c81402.png)'
- en: Fig. 21 A simple BNF specification[#](#id49 "Link to this image")
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21 简单的 BNF 规范[#](#id49 "链接到这张图片")
- en: 'The example above defines several terminals and two commands : usercommand
    and passwordcommand. The ALPHA terminal contains all letters in upper and lower
    case. In the ALPHA rule, %x41 corresponds to ASCII character code 41 in hexadecimal,
    i.e. capital A. The CR and LF terminals correspond to the carriage return and
    linefeed control characters. The CRLF rule concatenates these two terminals to
    match the standard end of line termination. The DIGIT terminal contains all digits.
    The SP terminal corresponds to the white space characters. The usercommand is
    composed of two strings separated by white space. In the ABNF rules that define
    the messages used by Internet applications, the commands are case-insensitive.
    The rule “user” corresponds to all possible cases of the letters that compose
    the word between brackets, e.g. user, uSeR, USER, usER, … A username contains
    at least one letter and up to 8 letters. User names are case-sensitive as they
    are not defined as a string between brackets. The password rule indicates that
    a password starts with a letter and can contain any number of letters or digits.
    The white space and the control characters cannot appear in a password defined
    by the above rule.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例定义了几个终端和两个命令：usercommand 和 passwordcommand。ALPHA 终端包含所有大写和小写字母。在 ALPHAR
    规则中，%x41 对应于十六进制的 ASCII 字符代码 41，即大写字母 A。CR 和 LF 终端对应于回车和换行控制字符。CRLF 规则将这两个终端连接起来以匹配标准的行结束终止符。DIGIT
    终端包含所有数字。SP 终端对应于空白字符。usercommand 由两个由空格分隔的字符串组成。在定义互联网应用程序使用的消息的 ABNF 规则中，命令是不区分大小写的。规则“user”对应于构成方括号内单词的所有可能字母的大小写，例如
    user, uSeR, USER, usER，…… 用户名至少包含一个字母，最多8个字母。用户名是区分大小写的，因为它们没有被定义为括号内的字符串。密码规则表示密码以字母开头，可以包含任意数量的字母或数字。根据上述规则定义的密码中不允许出现空白字符和控制字符。
- en: 'Besides character strings, some applications also need to exchange 16 bits
    and 32 bits fields such as integers. A naive solution would have been to send
    the 16- or 32-bits field as it is encoded in the host’s memory. Unfortunately,
    there are different methods to store 16- or 32-bits fields in memory. Some CPUs
    store the most significant byte of a 16-bits field in the first address of the
    field while others store the least significant byte at this location. When networked
    applications running on different CPUs exchange 16 bits fields, there are two
    possibilities to transfer them over the transport service :'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串之外，一些应用还需要交换 16 位和 32 位字段，如整数。一个简单的解决方案是将 16 位或 32 位字段按其在主机内存中的编码方式发送。不幸的是，在内存中存储
    16 位或 32 位字段的方法有很多。一些 CPU 将 16 位字段的最显著字节存储在字段的第一地址，而其他 CPU 则将最低有效字节存储在这个位置。当运行在不同
    CPU 上的网络应用交换 16 位字段时，有两种可能性将它们通过传输服务传输：
- en: send the most significant byte followed by the least significant byte
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先发送最高有效字节，然后是最低有效字节
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: send the least significant byte followed by the most significant byte
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先发送最低有效字节，然后是最高有效字节
- en: The first possibility was named big-endian in a note written by Cohen [[Cohen1980]](../bibliography.html#cohen1980)
    while the second was named little-endian. Vendors of CPUs that used big-endian
    in memory insisted on using big-endian encoding in networked applications while
    vendors of CPUs that used little-endian recommended the opposite. Several studies
    were written on the relative merits of each type of encoding, but the discussion
    became almost a religious issue [[Cohen1980]](../bibliography.html#cohen1980).
    Eventually, the Internet chose the big-endian encoding, i.e. multi-byte fields
    are always transmitted by sending the most significant byte first, [**RFC 791**](https://datatracker.ietf.org/doc/html/rfc791.html)
    refers to this encoding as the [network-byte order](../glossary.html#term-network-byte-order).
    Most libraries [[9]](#fhtonl) used to write networked applications contain functions
    to convert multi-byte fields from memory to the network byte order and the reverse.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种可能性在科恩（Cohen）的笔记中被命名为大端序，而第二种被命名为小端序。使用大端序内存的 CPU 供应商坚持在网络应用中使用大端序编码，而使用小端序的
    CPU 供应商则推荐相反的做法。关于每种编码相对优缺点的几项研究被撰写出来，但讨论几乎变成了一个宗教问题 [[Cohen1980]](../bibliography.html#cohen1980)。最终，互联网选择了大端序编码，即多字节字段总是通过先发送最高有效字节来传输，[**RFC
    791**](https://datatracker.ietf.org/doc/html/rfc791.html) 将这种编码称为 [网络字节序](../glossary.html#term-network-byte-order)。大多数用于编写网络应用的库
    [[9]](#fhtonl) 都包含将多字节字段从内存转换为网络字节序以及反向转换的函数。
- en: Besides 16 and 32 bit words, some applications need to exchange data structures
    containing bit fields of various lengths. For example, a message may be composed
    of a 16 bits field followed by eight, one bit flags, a 24 bits field and two 8
    bits bytes. Internet protocol specifications will define such a message by using
    a representation such as [Fig. 22](#fig-internet-packet). In this representation,
    each line corresponds to 32 bits and the vertical lines are used to delineate
    fields. The numbers above the lines indicate the bit positions in the 32-bits
    word, with the high order bit at position 0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 16 位和 32 位字之外，一些应用还需要交换包含各种长度位字段的复杂数据结构。例如，一个消息可能由一个 16 位字段、八个一位标志、一个 24
    位字段和两个 8 位字节组成。互联网协议规范将使用如图 22 所示的表示法来定义此类消息。在这个表示法中，每一行对应 32 位，垂直线用于划分字段。线条上方的数字表示
    32 位字中的位位置，最高位在位置 0。
- en: '[![../_images/message.svg](../Images/1e419bbcd4d8ea7928e96e2cb5aacb0b.png)](../_images/message.svg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/message.svg](../Images/1e419bbcd4d8ea7928e96e2cb5aacb0b.png)](../_images/message.svg)'
- en: Fig. 22 Message format[#](#id50 "Link to this image")
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22 消息格式[#](#id50 "链接到这张图片")
- en: The message mentioned above will be transmitted starting from the upper 32-bits
    word in network byte order. The first field is encoded in 16 bits. It is followed
    by eight one bit flags (A-H), a 24 bits field whose high order byte is shown in
    the first line and the two low order bytes appear in the second line followed
    by two one byte fields. This ASCII representation is frequently used when defining
    binary protocols. We will use it for all the binary protocols that are discussed
    in this book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提到的消息将按照网络字节序从最高 32 位字开始传输。第一个字段以 16 位编码。其后是八个一位标志（A-H），一个 24 位字段，其高位字节显示在第一行，两个低位字节显示在第二行，接着是两个单字节字段。这种
    ASCII 表示法在定义二进制协议时经常被使用。我们将用它来讨论本书中所有讨论的二进制协议。
- en: The peer-to-peer model emerged during the last ten years as another possible
    architecture for networked applications. In the traditional client-server model,
    hosts act either as servers or as clients and a server serves a large number of
    clients. In the peer-to-peer model, all hosts act as both servers and clients
    and they play both roles. The peer-to-peer model has been used to develop various
    networked applications, ranging from Internet telephony to file sharing or Internet-wide
    filesystems. A detailed description of peer-to-peer applications may be found
    in [[BYL2008]](../bibliography.html#byl2008). Surveys of peer-to-peer protocols
    and applications may be found in [[AS2004]](../bibliography.html#as2004) and [[LCP2005]](../bibliography.html#lcp2005).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，对等模型作为网络应用程序的另一种可能架构出现。在传统的客户端-服务器模型中，主机要么充当服务器，要么充当客户端，服务器为大量客户端提供服务。在对等模型中，所有主机都既是服务器又是客户端，并扮演这两个角色。对等模型已被用于开发各种网络应用程序，从互联网电话到文件共享或互联网级文件系统。有关对等应用的详细描述，请参阅[[BYL2008]](../bibliography.html#byl2008)。有关对等协议和应用的调查，请参阅[[AS2004]](../bibliography.html#as2004)和[[LCP2005]](../bibliography.html#lcp2005)。
- en: '## Naming and addressing[#](#naming-and-addressing "Link to this heading")'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '## 命名和寻址[#](#naming-and-addressing "链接到本标题")'
- en: The network and the transport layers rely on addresses that are encoded as fixed-size
    bit strings. A network layer address uniquely identifies a host. Several transport
    layer entities can use the service of the same network layer. For example, a reliable
    transport protocol and a connectionless transport protocol can coexist on the
    same host. In this case, the network layer multiplexes the segments produced by
    these two protocols. This multiplexing is usually achieved by placing in the network
    packet header a field that indicates which transport protocol should process the
    segment. Given that there are few different transport protocols, this field does
    not need to be long. The port numbers play a similar role in the transport layer
    since they enable it to multiplex data from several application processes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和传输层依赖于编码为固定大小位字符串的地址。网络层地址唯一标识一个主机。多个传输层实体可以使用同一网络层的服务。例如，可靠的传输协议和无连接的传输协议可以在同一主机上共存。在这种情况下，网络层将这两个协议产生的段进行多路复用。这种多路复用通常是通过在网络数据包头部放置一个字段来实现的，该字段指示哪个传输协议应该处理该段。鉴于不同的传输协议很少，这个字段不需要很长。端口号在传输层中也扮演着类似的角色，因为它们使传输层能够多路复用来自多个应用程序进程的数据。
- en: While addresses are natural for the network and transport layer entities, humans
    prefer to use names when interacting with network services. Names can be encoded
    as a character string, and a mapping service allows applications to map a name
    into the corresponding address. Using names is friendlier for humans, but it also
    provides a level of indirection which is very useful in many situations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然地址对于网络和传输层实体来说是自然的，但人类在与网络服务交互时更喜欢使用名称。名称可以编码为字符串，映射服务允许应用程序将名称映射到相应的地址。使用名称对人类来说更加友好，但它也提供了一种间接性，这在许多情况下非常有用。
- en: In the early days of the Internet, only a few hosts (mainly minicomputers) were
    connected to the network. The most popular applications were [remote login](../glossary.html#term-remote-login)
    and file transfer. By 1983, there were already five hundred hosts attached to
    the Internet [[Zakon]](../bibliography.html#zakon). Each of these hosts was identified
    by a unique address. Forcing human users to remember the addresses of the hosts
    that they wanted to use was not user-friendly. Humans prefer to remember names
    and use them when needed. Using names as aliases for addresses is a common technique
    in Computer Science. It simplifies the development of applications and allows
    the developer to ignore the low-level details. For example, by using a programming
    language instead of writing machine code, a developer can write software without
    knowing whether the variables that it uses are stored in memory or inside registers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网的早期，只有少数主机（主要是小型计算机）连接到网络。最受欢迎的应用程序是[远程登录](../glossary.html#term-remote-login)和文件传输。到1983年，已有五百台主机连接到互联网[[Zakon]](../bibliography.html#zakon)。这些主机中的每一台都有一个唯一的地址。强迫用户记住他们想要使用的宿主机的地址并不友好。人类更喜欢记住名称并在需要时使用它们。将名称用作地址的别名是计算机科学中的一种常见技术。它简化了应用程序的开发，并允许开发者忽略低级细节。例如，通过使用编程语言而不是编写机器代码，开发者可以编写软件而无需知道它所使用的变量是存储在内存中还是寄存器内。
- en: Because names are at a higher level than addresses, they allow (both in the
    example of programming above and on the Internet) to treat addresses as mere technical
    identifiers, which can change at will. Only the names are stable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称位于地址之上，它们允许（在上述编程示例和互联网上）将地址视为仅是技术标识符，可以随意更改。只有名称是稳定的。
- en: The first solution that allowed applications to use names was the [hosts.txt](../glossary.html#term-hosts.txt)
    file. This file is similar to the symbol table found in compiled code. It contains
    the mapping between the name of each Internet host and its associated address
    [[1]](#fhosts). It was maintained by the SRI International Network Information
    Center (NIC). When a new host was connected to the network, the system administrator
    had to register its name and address at the NIC. The NIC updated the [hosts.txt](../glossary.html#term-hosts.txt)
    file on its server. All Internet hosts regularly retrieved the updated [hosts.txt](../glossary.html#term-hosts.txt)
    file from the [SRI](https://www.sri.com) server. This file was stored at a well-known
    location on each Internet host (see [**RFC 952**](https://datatracker.ietf.org/doc/html/rfc952.html))
    and networked applications could use it to find the address corresponding to a
    name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首个允许应用程序使用名称的解决方案是[hosts.txt](../glossary.html#term-hosts.txt)文件。此文件类似于编译代码中找到的符号表。它包含每个互联网主机名称与其相关地址之间的映射
    [[1]](#fhosts)。该文件由SRI国际网络信息中心（NIC）维护。当新的主机连接到网络时，系统管理员必须在NIC上注册其名称和地址。NIC会更新其服务器上的[hosts.txt](../glossary.html#term-hosts.txt)文件。所有互联网主机定期从[SRI](https://www.sri.com)服务器检索更新的[hosts.txt](../glossary.html#term-hosts.txt)文件。此文件存储在每个互联网主机的一个知名位置（见[**RFC
    952**](https://datatracker.ietf.org/doc/html/rfc952.html)），网络应用程序可以使用它来查找与名称对应的地址。
- en: A [hosts.txt](../glossary.html#term-hosts.txt) file can be used when there are
    up to a few hundred hosts on the network. However, it is clearly not suitable
    for a network containing thousands or millions of hosts. A key issue in a large
    network is to define a suitable naming scheme. The ARPANet initially used a flat
    naming space, i.e. each host was assigned a unique name. To limit collisions between
    names, these names usually contained the name of the institution and a suffix
    to identify the host inside the institution (a kind of poor man’s hierarchical
    naming scheme). On the ARPANet, few institutions had several hosts connected to
    the network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络上有数百个主机时，可以使用[hosts.txt](../glossary.html#term-hosts.txt)文件。然而，显然它不适用于包含数千或数百万主机的网络。大型网络中的一个关键问题是定义一个合适的命名方案。ARPANet最初使用平面命名空间，即每个主机都被分配了一个唯一的名称。为了限制名称之间的冲突，这些名称通常包含机构的名称以及一个后缀来识别机构内的主机（一种简陋的分层命名方案）。在ARPANet上，很少有机构有多个主机连接到网络。
- en: However, the limitations of a flat naming scheme became clear before the end
    of the ARPANet, and [**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)
    proposed a hierarchical naming scheme. While [**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)
    discussed the possibility of organizing the names as a directed graph, the Internet
    opted for a tree structure capable of containing all names. In this tree, the
    top-level domains are those that are directly attached to the root. The first
    top-level domain was .arpa [[2]](#fdnstimeline). This top-level name was initially
    added as a suffix to the names of the hosts attached to the ARPANet and listed
    in the hosts.txt file. In 1984, the .gov, .edu, .com, .mil, and .org generic top-level
    domain names were added. [**RFC 1032**](https://datatracker.ietf.org/doc/html/rfc1032.html)
    proposed the utilization of the two-letter [ISO-3166](../glossary.html#term-ISO-3166)
    country codes as top-level domain names. Since [ISO-3166](../glossary.html#term-ISO-3166)
    defines a two-letter code for each country recognized by the United Nations, this
    allowed all countries to automatically have a top-level domain. These domains
    include .be for Belgium, .fr for France, .us for the USA, .ie for Ireland, or
    .tv for Tuvalu, a group of small islands in the Pacific, or .tm for Turkmenistan.
    The set of top-level domain names is managed by the Internet Corporation for Assigned
    Names and Numbers ([ICANN](../glossary.html#term-ICANN)). [ICANN](../glossary.html#term-ICANN)
    adds generic top-level domains that are not related to a country, and the .cat
    top-level domain has been registered for the Catalan language. There are ongoing
    discussions within [ICANN](../glossary.html#term-ICANN) to increase the number
    of top-level domains.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在ARPANet结束之前，扁平命名方案的局限性变得明显，[**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)提出了分层命名方案。虽然[**RFC
    819**](https://datatracker.ietf.org/doc/html/rfc819.html)讨论了将名称组织为有向图的可能性，但互联网选择了能够包含所有名称的树状结构。在这个树中，顶级域名是直接连接到根的。第一个顶级域名是.arpa
    [[2]](#fdnstimeline)。这个顶级名称最初被添加为ARPANet上连接的主机名称的后缀，并在hosts.txt文件中列出。1984年，添加了.gov、.edu、.com、.mil和.org等通用顶级域名。[**RFC
    1032**](https://datatracker.ietf.org/doc/html/rfc1032.html)提出了使用两字母[ISO-3166](../glossary.html#term-ISO-3166)国家代码作为顶级域名的建议。由于[ISO-3166](../glossary.html#term-ISO-3166)为联合国认可的每个国家定义了一个两字母代码，这允许所有国家自动拥有顶级域名。这些域名包括比利时为.be，法国为.fr，美国为.us，爱尔兰为.ie，或图瓦卢为.tv，这是一个太平洋上的小岛群，或土库曼斯坦为.tm。顶级域名集合由互联网名称与数字地址分配机构([ICANN](../glossary.html#term-ICANN))管理。[ICANN](../glossary.html#term-ICANN)添加了与国家无关的通用顶级域名，并为加泰罗尼亚语注册了.cat顶级域名。在[ICANN](../glossary.html#term-ICANN)内部正在进行增加顶级域名数量的讨论。
- en: Each top-level domain is managed by an organization that decides how subdomain
    names can be registered. Most top-level domain names use a first-come, first-served
    system and allow anyone to register domain names, but there are some exceptions.
    For example, .gov is reserved for the US government, .int is reserved for international
    organizations, and names in the .ca are mainly [reserved](http://en.wikipedia.org/wiki/.ca)
    for companies or users that are present in Canada.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶级域名由一个组织管理，该组织决定子域名名称的注册方式。大多数顶级域名使用先到先得系统，允许任何人注册域名，但也有例外。例如，.gov是为美国政府保留的，.int是为国际组织保留的，而.ca中的名称主要[保留](http://en.wikipedia.org/wiki/.ca)给在加拿大存在的公司或用户。
- en: '![Figure made with TikZ](../Images/28e49f48398377711717aaa96d6ec501.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/28e49f48398377711717aaa96d6ec501.png)'
- en: Fig. 23 The tree of domain names
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图23 域名树
- en: The syntax of the domain names has been defined more precisely in [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html).
    This document recommends the following [BNF](../glossary.html#term-BNF) for fully
    qualified domain names (the domain names themselves have a much richer syntax).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 域名语法在[**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html)中被定义得更加精确。本文件推荐以下[BNF](../glossary.html#term-BNF)用于完全限定的域名（域名本身具有更丰富的语法）。
- en: Listing 1 BNF of the fully qualified host names[#](#id52 "Link to this code")
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1 完全限定主机名的BNF[#](#id52 "链接到这段代码")
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This grammar specifies that a host name is an ordered list of labels separated
    by the dot (.) character. Each label can contain letters, numbers, and the hyphen
    character (-) [[3]](#fidn). Fully qualified domain names are read from left to
    right. The first label is a hostname or a domain name followed by the hierarchy
    of domains and ending with the root implicitly at the right. The top-level domain
    name must be one of the registered TLDs [[4]](#ftld). For example, in the above
    figure, www.computer-networking.info corresponds to a host named www inside the
    computer-networking domain that belongs to the info top-level domain.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法指定主机名是由点（.）字符分隔的标签有序列表。每个标签可以包含字母、数字和连字符字符 (-) [[3]](#fidn)。完全限定的域名从左到右读取。第一个标签是主机名或域名，后面跟着域的层次结构，并以右侧隐含的根结束。顶级域名必须是已注册的
    TLD 之一 [[4]](#ftld)。例如，在上面的图中，www.computer-networking.info 对应于 info 顶级域中 computer-networking
    域内的一个名为 www 的主机。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some visually similar characters have different character codes
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一些视觉上相似的字符有不同的字符代码
- en: The Domain Name System was created at a time when the Internet was mainly used
    in North America. The initial design assumed that all domain names would be composed
    of letters and digits [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html).
    As Internet usage grew in other parts of the world, it became important to support
    non-ASCII characters. For this, extensions have been proposed to the Domain Name
    System [**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html). In
    a nutshell, the solution that is used to support Internationalized Domain Names
    works as follows. First, it is possible to use most of the Unicode characters
    to encode domain names and hostnames, with a few exceptions (for example, the
    dot character cannot be part of a name since it is used as a separator). Once
    a domain name has been encoded as a series of Unicode characters, it is then converted
    into a string that contains the `xn--` prefix and a sequence of ASCII characters.
    More details on these algorithms can be found in [**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html)
    and [**RFC 3492**](https://datatracker.ietf.org/doc/html/rfc3492.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统是在互联网主要在北美使用的时候创建的。最初的设计假设所有域名都由字母和数字组成 [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html)。随着互联网在其他地区的使用增长，支持非
    ASCII 字符变得很重要。为此，对域名系统提出了扩展 [**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html)。简而言之，用于支持国际化域名的解决方案工作原理如下。首先，可以使用大多数
    Unicode 字符来编码域名和主机名，但有少数例外（例如，点字符不能是名称的一部分，因为它用作分隔符）。一旦域名被编码为一系列 Unicode 字符，它就会被转换成一个包含
    `xn--` 前缀和一系列 ASCII 字符的字符串。有关这些算法的更多详细信息，请参阅[**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html)和[**RFC
    3492**](https://datatracker.ietf.org/doc/html/rfc3492.html)。
- en: The possibility of using all Unicode characters to create domain names opened
    a new form of attack called the [homograph attack](https://en.wikipedia.org/wiki/IDN_homograph_attack).
    This attack occurs when two character strings or domain names are visually similar
    but do not correspond to the same server. A simple example is [https://G00GLE.COM](https://G00GLE.COM)
    and [https://GOOGLE.COM](https://GOOGLE.COM). These two URLs are visually close
    but they correspond to different names (the first one does not point to a valid
    server [[5]](#fg00gle)). With other Unicode characters, it is possible to construct
    domain names that are visually equivalent to existing ones. See [[Zhe2017]](../bibliography.html#zhe2017)
    for additional details on this attack.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有 Unicode 字符创建域名的新形式攻击被称为[同音攻击](https://en.wikipedia.org/wiki/IDN_homograph_attack)。这种攻击发生在两个字符串或域名在视觉上相似，但并不对应同一服务器时。一个简单的例子是[https://G00GLE.COM](https://G00GLE.COM)和[https://GOOGLE.COM](https://GOOGLE.COM)。这两个
    URL 在视觉上非常接近，但它们对应不同的名称（第一个不指向有效的服务器 [[5]](#fg00gle)）。使用其他 Unicode 字符，可以构建与现有域名在视觉上等效的域名。有关此攻击的更多详细信息，请参阅[[Zhe2017]](../bibliography.html#zhe2017)。
- en: This hierarchical naming scheme is a key component of the Domain Name System
    (DNS). The DNS is a distributed database that contains mappings between fully
    qualified domain names and addresses. The DNS uses the client-server model. The
    clients are hosts or applications that need to retrieve the mapping for a given
    name. Each [nameserver](../glossary.html#term-nameserver) stores part of the distributed
    database and answers the queries sent by clients. There is at least one [nameserver](../glossary.html#term-nameserver)
    that is responsible for each domain. In the figure below, domains are represented
    by circles and there are three hosts inside domain dom (h1, h2, and h3) and three
    hosts inside domain a.sdom1.dom. As shown in the figure below, a sub-domain may
    contain both host names and sub-domains.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层命名方案是域名系统（DNS）的关键组成部分。DNS是一个分布式数据库，包含完全合格域名与地址之间的映射。DNS使用客户端-服务器模型。客户端是需要检索给定名称映射的主机或应用程序。每个
    [域名服务器](../glossary.html#term-nameserver) 存储分布式数据库的一部分，并回答客户端发送的查询。每个域名至少有一个 [域名服务器](../glossary.html#term-nameserver)
    负责处理。如图所示，域名用圆圈表示，在域名 dom 内有三个主机（h1、h2 和 h3），在域名 a.sdom1.dom 内有三个主机。如图所示，子域名可能包含主机名和子域名。
- en: '![Figure made with TikZ](../Images/7989bbb8be7d75c8e85246fc80c86c13.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/7989bbb8be7d75c8e85246fc80c86c13.png)'
- en: Fig. 24 A simple tree of domain names
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 24 域名简单树
- en: 'A [nameserver](../glossary.html#term-nameserver) that is responsible for domain
    dom can directly answer the following queries :'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 负责域名 dom 的 [域名服务器](../glossary.html#term-nameserver) 可以直接回答以下查询：
- en: the address of any host residing directly inside domain dom (e.g. h2.dom in
    the figure above)
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接位于域名 dom 内的任何主机的地址（例如，图中的 h2.dom）
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the nameserver(s) that are responsible for any direct sub-domain of domain dom
    (i.e. sdom1.dom and sdom2.dom in the figure above, but not z.sdom1.dom)
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责域名 dom 任何直接子域的域名服务器（即图中的 sdom1.dom 和 sdom2.dom，但不包括 z.sdom1.dom）
- en: To retrieve the mapping for host h2.dom, a client sends its query to the name
    server that is responsible for the domain .dom. The name server directly answers
    the query. To retrieve a mapping for h3.a.sdom1.dom, a DNS client first sends
    a query to the name server that is responsible for the .dom domain. This nameserver
    returns the nameserver that is responsible for the sdom1.dom domain. This nameserver
    can now be contacted to obtain the nameserver that is responsible for the a.sdom1.dom
    domain. This nameserver can be contacted to retrieve the mapping for the h3.a.sdom1.dom
    name. Thanks to this structure, it is possible for a DNS client to obtain the
    mapping of any host inside the .dom domain or any of its subdomains. To ensure
    that any DNS client will be able to resolve any fully qualified domain name, there
    are special nameservers that are responsible for the root of the domain name hierarchy.
    These nameservers are called [root nameserver](../glossary.html#term-root-nameserver).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索主机 h2.dom 的映射，客户端将查询发送到负责 .dom 域的域名服务器。域名服务器直接回答查询。要检索 h3.a.sdom1.dom 的映射，DNS客户端首先向负责
    .dom 域的域名服务器发送查询。此域名服务器返回负责 sdom1.dom 域域的域名服务器。现在可以通过联系此域名服务器来获取负责 a.sdom1.dom
    域域的域名服务器。此域名服务器可以用来检索 h3.a.sdom1.dom 名称的映射。多亏了这种结构，DNS客户端可以获取 .dom 域及其子域名中任何主机的映射。为了确保任何DNS客户端都能解析任何完全合格域名，存在专门负责域名名称层次结构根部的域名服务器。这些域名服务器被称为
    [根域名服务器](../glossary.html#term-root-nameserver)。
- en: Each root nameserver maintains the list [[6]](#froot) of all the nameservers
    that are responsible for each of the top-level domain names and their addresses
    [[7]](#frootv6). All root nameservers cooperate and provide the same answers.
    By querying any of the root nameservers, a DNS client can obtain the nameserver
    that is responsible for any top-level-domain name. From this nameserver, it is
    possible to resolve any domain name.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个根域名服务器维护着所有负责每个顶级域名及其地址的域名服务器的列表 [[6]](#froot)。所有根域名服务器协同工作并提供相同的答案。通过查询任何一个根域名服务器，DNS客户端可以获取负责任何顶级域名名称的域名服务器。从这个域名服务器，可以解析任何域名。
- en: 'To be able to contact the root nameservers, each DNS client must know their
    addresses. This implies that DNS clients must maintain an up-to-date list of the
    addresses of the root nameservers. Without this list, it is impossible to contact
    the root nameservers. Forcing all Internet hosts to maintain the most recent version
    of this list would be difficult from an operational point of view. To solve this
    problem, the designers of the DNS introduced a special type of DNS server : the
    DNS resolvers. A [resolver](../glossary.html#term-resolver) is a server that provides
    the name resolution service for a set of clients. A network usually contains a
    few resolvers. Each host in these networks is configured to send all its DNS queries
    via one of its local resolvers. These queries are called recursive queries as
    the [resolver](../glossary.html#term-resolver) must recursively send requests
    through the hierarchy of nameservers to obtain the answer.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够联系根名称服务器，每个DNS客户端都必须知道它们的地址。这意味着DNS客户端必须维护根名称服务器地址的最新列表。没有这个列表，就无法联系根名称服务器。强制所有互联网主机维护这个列表的最新版本在操作上会很困难。为了解决这个问题，DNS的设计者引入了一种特殊的DNS服务器类型：DNS解析器。一个[解析器](../glossary.html#term-resolver)是为一组客户端提供名称解析服务的服务器。一个网络通常包含几个解析器。这些网络中的每个主机都被配置为通过其本地解析器发送所有的DNS查询。这些查询被称为递归查询，因为[解析器](../glossary.html#term-resolver)必须递归地向名称服务器层次结构发送请求以获得答案。
- en: DNS resolvers have several advantages over letting each Internet host query
    directly nameservers. Firstly, regular Internet hosts do not need to maintain
    the up-to-date list of the addresses of the root servers. Secondly, regular Internet
    hosts do not need to send queries to nameservers all over the Internet. Furthermore,
    as a DNS resolver serves a large number of hosts, it can cache the received answers.
    This allows the resolver to quickly return answers for popular DNS queries and
    reduces the load on all DNS servers [[JSBM2002]](../bibliography.html#jsbm2002).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: DNS解析器相对于让每个互联网主机直接查询名称服务器有几个优势。首先，常规互联网主机不需要维护根服务器的地址列表。其次，常规互联网主机不需要向互联网上的所有名称服务器发送查询。此外，由于DNS解析器为大量主机提供服务，它可以缓存收到的答案。这使得解析器能够快速返回常见DNS查询的答案，并减少所有DNS服务器的负载
    [[JSBM2002]](../bibliography.html#jsbm2002)。
- en: Benefits of names[#](#benefits-of-names "Link to this heading")
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称的好处[#](#benefits-of-names "链接到这个标题")
- en: 'In addition to being more human-friendly, using names instead of addresses
    inside applications has several important benefits. To understand them, let us
    consider a popular application that provides information stored on servers. This
    application involves clients and servers. The server provides information upon
    requests from client processes. A first deployment of this application would be
    to rely only on addresses. In this case, the server process would be installed
    on one host, and the clients would connect to this server to retrieve information.
    Such a deployment has several drawbacks :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更符合人性化的设计外，在应用程序中使用名称而不是地址还有几个重要的好处。为了理解这些好处，让我们考虑一个提供存储在服务器上信息的流行应用程序。这个应用程序涉及客户端和服务器。服务器根据客户端进程的请求提供信息。这个应用程序的第一个部署方案是仅依赖于地址。在这种情况下，服务器进程将安装在一台主机上，客户端将连接到这台服务器以检索信息。这种部署方案有几个缺点：
- en: if the server process moves to another physical server, all clients must be
    informed about the new server address.
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器进程转移到另一台物理服务器，所有客户端都必须被告知新的服务器地址。
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: if there are many concurrent clients, the load of the server will increase without
    any possibility of adding another server without changing the server addresses
    used by the clients.
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有大量并发客户端，服务器负载会增加，而没有任何可能在不更改客户端使用的服务器地址的情况下添加另一个服务器。
- en: Using names solves these problems and provides additional benefits. If the clients
    are configured with the name of the server, they will query the name service before
    contacting the server. The name service will resolve the name into the corresponding
    address. If a server process needs to move from one physical server to another,
    it suffices to update the name-to-address mapping on the name service to allow
    all clients to connect to the new server. The name service also enables the servers
    to better sustain the load. Assume a very popular server which is accessed by
    millions of users. This service cannot be provided by a single physical server
    due to performance limitations. Thanks to the utilization of names, it is possible
    to scale this service by mapping a given name to a set of addresses. When a client
    queries the name service for the server’s name, the name service returns one of
    the addresses in the set. Various strategies can be used to select one particular
    address inside the set of addresses. A first strategy is to select a random address
    in the set. A second strategy is to maintain information about the load on the
    servers and return the address of the less loaded server. Note that the list of
    server addresses does not need to remain fixed. It is possible to add and remove
    addresses from the list to cope with load fluctuations. Another strategy is to
    infer the location of the client from the name request and return the address
    of the closest server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称解决了这些问题，并提供了额外的优势。如果客户端配置了服务器的名称，它们将在联系服务器之前查询名称服务。名称服务将解析名称为相应的地址。如果一个服务器进程需要从一个物理服务器移动到另一个物理服务器，只需更新名称服务上的名称到地址映射，就可以允许所有客户端连接到新的服务器。名称服务还使服务器能够更好地承受负载。假设一个非常受欢迎的服务器，被数百万用户访问。由于性能限制，这项服务不能由单个物理服务器提供。多亏了名称的使用，可以通过将给定的名称映射到一组地址来扩展这项服务。当客户端查询名称服务以获取服务器的名称时，名称服务返回该组中的一个地址。可以使用各种策略来选择地址集中的特定地址。第一种策略是在集合中随机选择一个地址。第二种策略是维护有关服务器负载的信息，并返回负载较轻的服务器的地址。请注意，服务器地址列表不需要保持固定。可以添加和删除地址以应对负载波动。另一种策略是从名称请求中推断客户端的位置，并返回最近的服务器地址。
- en: Mapping a single name onto a set of addresses allows popular servers to dynamically
    scale. There are also benefits in mapping multiple names, possibly a large number
    of them, onto a single address. Consider the case of information servers run by
    individuals or SMEs. Some of these servers attract only a few clients per day.
    Using a single physical server for each of these services would be a waste of
    resources. A better approach is to use a single server for a set of services that
    are all identified by different names. This enables service providers to support
    a large number of server processes, identified by different names, onto a single
    physical server. If one of these server processes becomes very popular, it will
    be possible to map its name onto a set of addresses to be able to sustain the
    load. There are some deployments where this mapping is done dynamically in function
    of the load.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个名称映射到一组地址允许流行的服务器动态扩展。将多个名称，可能是一大批名称，映射到单个地址也有好处。考虑个人或中小企业运行的信息服务器的情况。其中一些服务器每天只吸引少数客户。为每个这样的服务使用单个物理服务器将是资源的浪费。更好的方法是使用单个服务器为多个服务提供服务，这些服务都由不同的名称标识。这使得服务提供商能够在单个物理服务器上支持大量由不同名称标识的服务进程。如果这些服务进程中的一个变得非常受欢迎，就有可能将其名称映射到一组地址，以便能够承受负载。有些部署中，这种映射是动态地在负载函数下进行的。
- en: Names provide a lot of flexibility compared to addresses. For the network, they
    play a similar role as variables in programming languages. No programmer using
    a high-level programming language would consider using hardcoded values instead
    of variables. For the same reasons, all networked applications should depend on
    names and avoid dealing with addresses as much as possible.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与地址相比，名称提供了很多灵活性。对于网络来说，它们在编程语言中的作用类似于变量。没有使用高级编程语言的程序员会考虑使用硬编码的值而不是变量。出于同样的原因，所有网络应用程序都应依赖于名称，并尽可能避免处理地址。
- en: '### The Domain Name System[#](#the-domain-name-system "Link to this heading")'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '### 域名系统[#](#the-domain-name-system "链接到这个标题")'
- en: The last component of the Domain Name System is the DNS protocol. The original
    DNS protocol runs above both the datagram and the bytestream services. In practice,
    the datagram service is used when short queries and responses are exchanged, and
    the bytestream service is used when longer responses are expected. In this section,
    we first focus on the utilization of the DNS protocol above the datagram service.
    We will discuss later other recently proposed protocols to carry DNS information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统（DNS）的最后一部分是 DNS 协议。原始 DNS 协议在数据报和字节流服务之上运行。在实践中，当交换短查询和响应时使用数据报服务，当期望更长的响应时使用字节流服务。在本节中，我们首先关注在数据报服务之上
    DNS 协议的利用。我们将在后面讨论其他最近提出的用于携带 DNS 信息的协议。
- en: DNS messages are composed of five parts that are named sections in RFC :1035.
    The first three sections are mandatory, and the last two sections are optional.
    The first section of a DNS message is its Header. It contains information about
    the message type and the content of the other sections. The second section contains
    the Question sent to the nameserver or resolver. The third section contains the
    Answer to the Question. When a client sends a DNS query, the Answer section is
    empty. The fourth section, named Authority, contains information about the servers
    that can provide an authoritative answer if required. The last section contains
    additional information that is supplied by the resolver or nameserver but was
    not requested in the question.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 消息由五个部分组成，这些部分在 RFC 1035 中被称为节：第一、二、三节是必需的，最后两节是可选的。DNS 消息的第一节是其头部。它包含有关消息类型和其他节内容的信息。第二节包含发送给名称服务器或解析器的查询。第三节包含对查询的答案。当客户端发送
    DNS 查询时，答案节为空。第四节，称为授权，包含有关可以提供权威答案的服务器信息。最后一节包含由解析器或名称服务器提供但未在问题中请求的附加信息。
- en: The header of DNS messages is composed of 12 bytes. The figure below presents
    its structure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 消息的头部由 12 个字节组成。下面的图展示了其结构。
- en: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)(../_images/dnsheader.svg)'
- en: Fig. 25 The DNS header[#](#id54 "Link to this image")
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25 DNS 头部[#](#id54 "链接到这张图片")
- en: The Transaction ID (transaction identifier) is a 16-bit random value chosen
    by the client. When a client sends a question to a DNS server, it remembers the
    question and its identifier. When a server returns an answer, it returns in the
    Transaction ID field the identifier chosen by the client. Thanks to this identifier,
    the client can match the received answer with the question that it sent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事务 ID（事务标识符）是客户端选择的一个 16 位随机值。当客户端向 DNS 服务器发送一个问题时，它会记住该问题和其标识符。当服务器返回一个答案时，它会在事务
    ID 字段返回客户端选择的标识符。多亏了这个标识符，客户端可以将收到的答案与其发送的问题匹配起来。
- en: The DNS header contains a series of flags. The QR flag is used to distinguish
    between queries and responses. It is set to 0 in DNS queries and 1 in DNS answers.
    The Opcode is used to specify the query type. For instance, a [standard query](../glossary.html#term-standard-query)
    is used when a client sends a name and the server returns the corresponding data.
    An update request is used when the client sends a name and new data, and the server
    then updates its database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 头部包含一系列标志。QR 标志用于区分查询和响应。在 DNS 查询中设置为 0，在 DNS 响应中设置为 1。操作码用于指定查询类型。例如，当客户端发送一个名称并且服务器返回对应的数据时，使用标准查询（../glossary.html#term-standard-query）。当客户端发送名称和新数据时，使用更新请求，然后服务器更新其数据库。
- en: 'The AA bit is set when the server that sent the response has authority for
    the domain name found in the question section. In the original DNS deployments,
    two types of servers were considered : authoritative servers and non-authoritative
    servers. The authoritative servers are managed by the system administrators responsible
    for a given domain. They always store the most recent information about a domain.
    Non-authoritative servers are servers or resolvers that store DNS information
    about external domains without being managed by the owners of a domain. They may
    thus provide answers that are out of date. From a security point of view, the
    authoritative bit is not an absolute indication about the validity of an answer.
    Securing the Domain Name System is a complex problem that was only addressed satisfactorily
    recently by the utilization of cryptographic signatures in the DNSSEC extensions
    to DNS described in : RFC:4033.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送响应的服务器对问题部分中找到的域名具有权威性时，AA位被设置。在原始DNS部署中，考虑了两种类型的服务器：权威服务器和非权威服务器。权威服务器由负责特定域的系统管理员管理。它们始终存储有关域的最新信息。非权威服务器是存储关于外部域的DNS信息但不由域所有者管理的服务器或解析器。因此，它们可能提供过时的答案。从安全角度来看，权威位并不是关于答案有效性的绝对指示。确保域名系统的安全是一个复杂的问题，直到最近才通过在DNSSEC扩展中使用加密签名得到满意的解决，这些扩展在：RFC:4033中描述。
- en: 'The RD (recursion desired) bit is set by a client when it sends a query to
    a resolver. Such a query is said to be recursive because the resolver will recursively
    traverse the DNS hierarchy to retrieve the answer on behalf of the client. In
    the past, all resolvers were configured to perform recursive queries on behalf
    of any Internet host. However, this exposes the resolvers to several security
    risks. The simplest one is that the resolver could become overloaded by having
    too many recursive queries to process. Most resolvers [[8]](#f8888) only allow
    recursive queries from clients belonging to their company or network and discard
    all other recursive queries. The RA bit indicates whether the server supports
    recursion. The RCODE is used to distinguish between different types of errors.
    See : RFC:1035 for additional details. The last four fields indicate the size
    of the Question, Answer, Authority, and Additional sections of the DNS message.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向解析器发送查询时，RD（递归所需）位被设置。这种查询被称为递归查询，因为解析器将递归遍历DNS层次结构以代表客户端检索答案。在过去，所有解析器都被配置为代表任何互联网主机执行递归查询。然而，这使解析器面临多个安全风险。最简单的一个是解析器可能会因为处理过多的递归查询而超载。大多数解析器[8](#f8888)只允许来自其公司或网络的客户端进行递归查询，并丢弃所有其他递归查询。RA位指示服务器是否支持递归。RCODE用于区分不同类型的错误。有关详细信息，请参阅：RFC:1035。最后四个字段指示DNS消息中问题、答案、授权和附加部分的尺寸。
- en: The last four sections of the DNS message contain Resource Records (RR). All
    RRs have the same top-level format shown in the figure below.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DNS消息的最后四个部分包含资源记录（RR）。所有RR都具有以下图中所示的同级格式。
- en: '[![../_images/dnsrr.svg](../Images/a838af70f19f03e6cc3645b1c9e8591e.png)](../_images/dnsrr.svg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/dnsrr.svg](../Images/a838af70f19f03e6cc3645b1c9e8591e.png)'
- en: Fig. 26 DNS Resource Records[#](#id55 "Link to this image")
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图26 DNS资源记录[#](#id55 "链接到此图像")
- en: In a Resource Record (RR), the Name indicates the name of the node to which
    this resource record pertains. The two-byte Type field indicates the type of resource
    record. The Class field was used to support the utilization of the DNS in other
    environments than the Internet. The IN Class refers to Internet names.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源记录（RR）中，名称字段指示此资源记录所属节点的名称。两字节的类型字段指示资源记录的类型。类字段用于支持在除互联网以外的环境中使用DNS。IN类指的是互联网名称。
- en: The TTL field indicates the lifetime of the Resource Record in seconds. This
    field is set by the server that returns an answer and indicates for how long a
    client or a resolver can store the Resource Record inside its cache. A long TTL
    indicates a stable RR. Some companies use short TTL values for mobile hosts and
    also for popular servers. For example, a web hosting company that wants to spread
    the load over a pool of hundred servers can configure its nameservers to return
    different answers to different clients. If each answer has a small TTL, the clients
    will be forced to send DNS queries regularly. The nameserver will reply to these
    queries by supplying the address of the less loaded server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: TTL 字段表示资源记录的生命周期（以秒为单位）。该字段由返回答案的服务器设置，并指示客户端或解析器可以在其缓存中存储资源记录的时间长度。较长的 TTL
    表示稳定的 RR。一些公司为移动主机和流行的服务器使用较短的 TTL 值。例如，一家希望将负载分散在一百台服务器池中的网络托管公司可以配置其名称服务器向不同的客户端返回不同的答案。如果每个答案都有一个小的
    TTL，客户端将被迫定期发送 DNS 查询。名称服务器将通过提供较不繁忙服务器的地址来回复这些查询。
- en: The RDLength field is the length of the RData field that contains the information
    of the type specified in the Type field.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: RDLength 字段是包含在 Type 字段中指定类型信息的 RData 字段的长度。
- en: 'Several types of DNS RR are used in practice. The A type encodes the IPv4 address
    that corresponds to the specified name. The AAAA type encodes the IPv6 address
    that corresponds to the specified name. A NS record contains the name of the DNS
    server that is responsible for a given domain. For example, a query for the AAAA
    record associated with the www.ietf.org name returned the following answer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用中使用了多种类型的 DNS RR。A 类型编码与指定名称相对应的 IPv4 地址。AAAA 类型编码与指定名称相对应的 IPv6 地址。NS 记录包含负责特定域的
    DNS 服务器的名称。例如，查询与 www.ietf.org 名称关联的 AAAA 记录返回了以下答案：
- en: '![../_images/dns6-www-ietf-org.svg](../Images/2a132b4acb2d03e996f683289606e16b.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/dns6-www-ietf-org.svg](../Images/2a132b4acb2d03e996f683289606e16b.png)'
- en: Fig. 27 Query for the AAAA record of www.ietf.org[#](#id56 "Link to this image")
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 27 查询 www.ietf.org 的 AAAA 记录[#](#id56 "链接到这张图片")
- en: This answer contains several pieces of information. First, the name www.ietf.org
    is associated with the IP address 2001:1890:123a::1:1e. Second, the ietf.org domain
    is managed by six different nameservers. Five of these nameservers are reachable
    via IPv4 and IPv6.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个答案包含了几条信息。首先，域名 www.ietf.org 与 IP 地址 2001:1890:123a::1:1e 相关联。其次，ietf.org
    域由六个不同的名称服务器管理。其中五个名称服务器可以通过 IPv4 和 IPv6 访达。
- en: CNAME (or canonical names) are used to define aliases. For example, www.example.com
    could be a CNAME for pc12.example.com, which is the actual name of the server
    on which the web server for www.example.com runs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CNAME（或规范名称）用于定义别名。例如，www.example.com 可以是 pc12.example.com 的 CNAME，而 pc12.example.com
    是运行 www.example.com 网站的实际服务器名称。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reverse DNS
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 DNS
- en: 'The DNS is mainly used to find the address that corresponds to a given name.
    However, it is sometimes useful to obtain the name that corresponds to an IP address.
    This is done by using the PTR (pointer) RR. The RData part of a PTR RR contains
    the name while the Name part of the RR contains the IP address encoded in the
    in-addr.arpa domain. IPv4 addresses are encoded in the in-addr.arpa by reversing
    the four digits that compose the dotted decimal representation of the address.
    For example, consider IPv4 address 192.0.2.11. The hostname associated to this
    address can be found by requesting the PTR RR that corresponds to 11.2.0.192.in-addr.arpa.
    A similar solution is used to support IPv6 addresses : RFC:3596, but slightly
    more complex given the length of the IPv6 addresses. For example, consider IPv6
    address 2001:1890:123a::1:1e. To obtain the name that corresponds to this address,
    we need first to convert it in a reverse dotted decimal notation : e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.
    In this notation, each character between dots corresponds to one nibble, i.e.
    four bits. The low-order byte (e) appears first and the high order (2) last. To
    obtain the name that corresponds to this address, one needs to append the ip6.arpa
    domain name and query for e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa.
    In practice, tools and libraries do the conversion automatically and the user
    does not need to worry about it.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: DNS主要用于查找与给定名称相对应的地址。然而，有时获取与IP地址相对应的名称也是有用的。这可以通过使用PTR（指针）RR来实现。PTR RR的RData部分包含名称，而RR的Name部分包含编码在in-addr.arpa域中的IP地址。IPv4地址通过反转组成地址点分十进制表示的四个数字来编码在in-addr.arpa中。例如，考虑IPv4地址192.0.2.11。与该地址关联的主机名可以通过请求对应于11.2.0.192.in-addr.arpa的PTR
    RR来找到。类似的解决方案用于支持IPv6地址：RFC:3596，但由于IPv6地址的长度，这稍微复杂一些。例如，考虑IPv6地址2001:1890:123a::1:1e。要获取与该地址相对应的名称，首先需要将其转换为反向点分十进制表示：e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2。在这个表示法中，每个点之间的每个字符对应一个四位的十六进制数，即四个比特。最低有效字节（e）首先出现，最高有效字节（2）最后出现。要获取与该地址相对应的名称，需要将ip6.arpa域名添加到后面，并查询e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa。在实际应用中，工具和库会自动进行转换，用户无需担心这一点。
- en: 'An important point to note regarding the Domain Name System is that it is extensible.
    Thanks to the Type and RDLength fields, the format of the Resource Records can
    easily be extended. Furthermore, a DNS implementation that receives a new Resource
    Record that it does not understand can ignore the record while still being able
    to process the other parts of the message. This allows, for example, a DNS server
    that only supports IPv6 to safely ignore the IPv4 addresses listed in the DNS
    reply for www.ietf.org while still being able to correctly parse the Resource
    Records that it understands. This allowed the Domain Name System to evolve over
    the years while still preserving the backward compatibility with already deployed
    DNS implementations.  ## Electronic mail[#](#electronic-mail "Link to this heading")'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于域名系统的一个重要注意事项是它具有可扩展性。多亏了类型和RDLength字段，资源记录的格式可以轻松扩展。此外，一个接收到它不理解的新资源记录的DNS实现可以忽略该记录，同时仍然能够处理消息的其他部分。例如，一个仅支持IPv6的DNS服务器可以安全地忽略DNS回复中列出的www.ietf.org的IPv4地址，同时仍然能够正确解析它理解的资源记录。这使得域名系统在多年间得以演变，同时仍然与已经部署的DNS实现保持向后兼容。##
    电子邮件[#](#electronic-mail "链接到本标题")
- en: Electronic mail, or email, is a very popular application in computer networks
    such as the Internet. Email [appeared](http://openmap.bbn.com/~tomlinso/ray/firstemailframe.html)
    in the early 1970s and allows users to exchange text based messages. Initially,
    it was mainly used to exchange short messages, but over the years its usage has
    grown. It is now not only used to exchange small, but also long messages that
    can be composed of several parts as we will see later.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件，或称电子邮件，是互联网等计算机网络中非常流行的应用。电子邮件在20世纪70年代初出现，允许用户交换基于文本的消息。最初，它主要用于交换简短的消息，但经过多年的发展，其用途已经增长。现在，它不仅用于交换小消息，还可以交换由多个部分组成的长消息，正如我们稍后将要看到的。
- en: Before looking at the details of Internet email, let us consider a simple scenario
    illustrated in [Fig. 28](#fig-email-arch), where Alice sends an email to Bob.
    Alice prepares her email by using an [email clients](https://en.wikipedia.org/wiki/Comparison_of_email_clients)
    and sends it to her email server. Alice’s [email server](http://en.wikipedia.org/wiki/Comparison_of_mail_servers)
    extracts Bob’s address from the email and delivers the message to Bob’s server.
    Bob retrieves Alice’s message on his server and reads it by using his favorite
    email client or through his webmail interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看互联网电子邮件的细节之前，让我们考虑一个简单场景，如图28所示，其中Alice向Bob发送电子邮件。Alice通过使用[电子邮件客户端](https://en.wikipedia.org/wiki/Comparison_of_email_clients)准备她的电子邮件并将其发送到她的电子邮件服务器。Alice的[电子邮件服务器](http://en.wikipedia.org/wiki/Comparison_of_mail_servers)从电子邮件中提取Bob的地址并将消息发送到Bob的服务器。Bob在他的服务器上检索Alice的消息并通过他最喜欢的电子邮件客户端或通过他的网络邮件界面阅读它。
- en: '![Figure made with TikZ](../Images/1de029c587cbf6cfd571cb993682463a.png)'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/1de029c587cbf6cfd571cb993682463a.png)'
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 28 Simplified architecture of the Internet email
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图28 互联网电子邮件的简化架构
- en: 'The email system that we consider in this book is composed of four components
    :'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中考虑的电子邮件系统由四个组件组成：
- en: a message format, that defines how valid email messages are encoded
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个消息格式，它定义了有效电子邮件消息的编码方式
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: protocols, that allow hosts and servers to exchange email messages
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议，允许主机和服务器交换电子邮件消息
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: client software, that allows users to easily create and read email messages
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端软件，允许用户轻松创建和阅读电子邮件消息
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: software, that allows servers to efficiently exchange email messages
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件，允许服务器高效地交换电子邮件消息
- en: We first discuss the format of email messages followed by the protocols that
    are used on today’s Internet to exchange and retrieve emails. Other email systems
    have been developed in the past [[Bush1993]](../bibliography.html#bush1993) [[Genilloud1990]](../bibliography.html#genilloud1990)
    [[GC2000]](../bibliography.html#gc2000), but today most email solutions have migrated
    to the Internet email. Information about the software that is used to compose
    and deliver emails may be found on [wikipedia](https://en.wikipedia.org) among
    others, for both [email clients](https://en.wikipedia.org/wiki/Comparison_of_email_clients)
    and [email servers](http://en.wikipedia.org/wiki/Comparison_of_mail_servers).
    More detailed information about the full Internet Mail Architecture may be found
    in [**RFC 5598**](https://datatracker.ietf.org/doc/html/rfc5598.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论电子邮件的格式，然后讨论今天互联网上用于交换和检索电子邮件的协议。过去已经开发了其他电子邮件系统 [[Bush1993]](../bibliography.html#bush1993)
    [[Genilloud1990]](../bibliography.html#genilloud1990) [[GC2000]](../bibliography.html#gc2000)，但今天大多数电子邮件解决方案都已迁移到互联网电子邮件。有关用于编写和发送电子邮件的软件的信息，可以在[维基百科](https://en.wikipedia.org)等地方找到，包括[电子邮件客户端](https://en.wikipedia.org/wiki/Comparison_of_email_clients)和[电子邮件服务器](http://en.wikipedia.org/wiki/Comparison_of_mail_servers)。有关完整互联网邮件架构的更详细信息，可以在[**RFC
    5598**](https://datatracker.ietf.org/doc/html/rfc5598.html)中找到。
- en: 'Email messages, like postal mail, are composed of two parts :'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件消息，像邮政邮件一样，由两部分组成：
- en: a header that plays the same role as the letterhead in regular mail. It contains
    metadata about the message.
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，它在常规邮件中扮演信头的作用。它包含有关消息的元数据。
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the body that contains the message itself.
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含消息本身的正文。
- en: Email messages are entirely composed of lines of ASCII characters. Each line
    can contain up to 998 characters and is terminated by the CR and LF control characters
    [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html). The lines
    that compose the header appear before the message body. An empty line, containing
    only the CR and LF characters, marks the end of the header. This is illustrated
    in [Fig. 29](#fig-email-msg).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件消息完全由ASCII字符的行组成。每行可以包含多达998个字符，并以CR和LF控制字符终止 [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)。组成标题的行出现在消息正文之前。一个只包含CR和LF字符的空行标志着标题的结束。这如图29所示。
- en: '![Figure made with TikZ](../Images/8a178944414537a08bc98dae0cf87286.png)'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8a178944414537a08bc98dae0cf87286.png)'
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 29 The structure of email messages
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图29 电子邮件的结构
- en: 'The email header contains several lines that all begin with a keyword followed
    by a colon and additional information. The format of email messages and the different
    types of header lines are defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html).
    Two of these header lines are mandatory and must appear in all email messages
    :'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件标题包含几行，都以一个关键字开头，后跟一个冒号和附加信息。电子邮件消息的格式和不同类型的标题行在[**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)中定义。其中两行是强制性的，必须出现在所有电子邮件消息中：
- en: The sender address. This header line starts with From:. This contains the (optional)
    name of the sender followed by its email address between < and >. Email addresses
    are always composed of a username followed by the @ sign and a domain name.
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发件人地址。这个标题行以From:开头。它包含发件人的（可选）姓名，后跟其电子邮件地址，地址在<和>之间。电子邮件地址总是由用户名后跟@符号和域名组成。
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The date. This header line starts with Date:. [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    precisely defines the format used to encode a date.
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期。这个标题行以Date:开头。[**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)精确地定义了编码日期所使用的格式。
- en: 'Other header lines appear in most email messages. The Subject: header line
    allows the sender to indicate the topic discussed in the email. Three types of
    header lines can be used to specify the recipients of a message :'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标题行出现在大多数电子邮件消息中。Subject:标题行允许发件人指明电子邮件中讨论的主题。可以使用三种类型的标题行来指定消息的收件人：
- en: 'the To: header line contains the email addresses of the primary recipients
    of the message [[10]](#fto). Several addresses can be separated by using commas.'
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: “To：”标题行包含消息的主要收件人的电子邮件地址[[10]](#fto)。可以使用逗号分隔多个地址。
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the cc: header line is used by the sender to provide a list of email addresses
    that must receive a carbon copy of the message. Several addresses can be listed
    in this header line, separated by commas. All recipients of the email message
    receive the To: and cc: header lines.'
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: “cc：”标题行由发件人使用，以提供必须接收邮件副本的电子邮件地址列表。此标题行中可以列出多个地址，用逗号分隔。所有电子邮件消息的收件人都收到To:和cc:标题行。
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the bcc: header line is used by the sender to provide a list of comma separated
    email addresses that must receive a blind carbon copy of the message. The bcc:
    header line is not delivered to the recipients of the email message.'
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: “bcc：”标题行由发件人使用，以提供必须接收邮件盲副本的逗号分隔的电子邮件地址列表。“bcc：”标题行不会发送给电子邮件消息的收件人。
- en: 'A simple email message containing the From:, To:, Subject: and Date: header
    lines and two lines of body is shown below.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的电子邮件消息示例，包含From:、To:、Subject:和Date:标题行以及两行正文。
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the empty line after the Date: header line; this empty line contains only
    the CR and LF characters, and marks the boundary between the header and the body
    of the message.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在“日期：”标题行之后有一个空行；这个空行只包含CR和LF字符，标志着标题和消息主体的分界。
- en: 'Several other optional header lines are defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    and elsewhere [[11]](#femailheaders). Furthermore, many email clients and servers
    define their own header lines starting from X-. Several of the optional header
    lines defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    are worth being discussed here :'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)和其他地方定义了几个其他可选标题行。此外，许多电子邮件客户端和服务器定义了从X-开始的自己的标题行。以下讨论[**RFC
    5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)中定义的几个可选标题行：
- en: 'the Message-Id: header line is used to associate a “unique” identifier to each
    email. Email identifiers are usually structured like string@domain where string
    is a unique character string or sequence number chosen by the sender of the email
    and domain the domain name of the sender. Since domain names are unique, a host
    can generate globally unique message identifiers concatenating a locally unique
    identifier with its domain name.'
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Message-Id：”标题行用于将一个“唯一”标识符关联到每个电子邮件。电子邮件标识符通常结构为string@domain，其中string是发件人选择的唯一字符字符串或序列号，domain是发件人的域名。由于域名是唯一的，主机可以通过将本地唯一标识符与其域名连接起来生成全局唯一的消息标识符。
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the In-reply-to: header line is used when a message was created in reply to
    a previous message. In this case, the end of the In-reply-to: line contains the
    identifier of the original message.'
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: “In-reply-to：”标题行在创建回复先前的消息时使用。在这种情况下，“In-reply-to：”行的末尾包含原始消息的标识符。
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Received: header line is used when an email message is processed by several
    servers before reaching its destination. Each intermediate email server adds a
    Received: header line. These header lines are useful to debug problems in delivering
    email messages.'
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一封电子邮件在到达目的地之前由多个服务器处理时，会使用Received:标题行。每个中间电子邮件服务器都会添加一个Received:标题行。这些标题行对于调试电子邮件投递问题非常有用。
- en: 'The figure below shows the header lines of one email message. The message originated
    at a host named wira.firstpr.com.au and was received by smtp3.sgsi.ucl.ac.be.
    The Received: lines have been wrapped for readability.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了某封电子邮件的标题行。该邮件起源于名为wira.firstpr.com.au的主机，并由smtp3.sgsi.ucl.ac.be接收。为了便于阅读，Received:行已被换行。
- en: '[PRE2]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initially, email was used to exchange small messages of ASCII text between computer
    scientists. However, with the growth of the Internet, supporting only ASCII text
    became a severe limitation for two reasons. First of all, non-English speakers
    wanted to write emails in their native language that often required more characters
    than those of the ASCII character table. Second, many users wanted to send other
    content than just ASCII text by email such as binary files, images or sound.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，电子邮件被用于在计算机科学家之间交换ASCII文本的小型消息。然而，随着互联网的发展，仅支持ASCII文本变得严重限制了两个原因。首先，非英语使用者希望用他们的母语写电子邮件，这通常需要比ASCII字符表更多的字符。其次，许多用户希望通过电子邮件发送除了ASCII文本之外的内容，例如二进制文件、图像或声音。
- en: To solve this problem, the [IETF](https://www.ietf.org) developed the Multipurpose
    Internet Mail Extensions ([MIME](../glossary.html#term-MIME)). These extensions
    were carefully designed to allow Internet email to carry non-ASCII characters
    and binary files without breaking the email servers that were deployed at that
    time. This requirement for backward compatibility forced the MIME designers to
    develop extensions to the existing email message format [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    instead of defining a completely new format that would have been better suited
    to support the new types of emails.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，[IETF](https://www.ietf.org)开发了多用途互联网邮件扩展([MIME](../glossary.html#term-MIME))。这些扩展被精心设计，以便互联网电子邮件能够携带非ASCII字符和二进制文件，而不会破坏当时部署的电子邮件服务器。这种向后兼容性的要求迫使MIME设计者开发了对现有电子邮件消息格式[**RFC
    822**](https://datatracker.ietf.org/doc/html/rfc822.html)的扩展，而不是定义一个更适合支持新类型电子邮件的全新格式。
- en: '[**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html) defines
    three new types of header lines to support MIME :'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**[RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)定义了三种新的标题行类型以支持MIME：'
- en: 'The MIME-Version: header line indicates the version of the MIME specification
    that was used to encode the email message. The current version of MIME is 1.0\.
    Other versions of MIME may be defined in the future. Thanks to this header line,
    the software that processes email messages will be able to adapt to the MIME version
    used to encode the message. Messages that do not contain this header are supposed
    to be formatted according to the original [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    specification.'
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIME-Version:标题行指示用于编码电子邮件消息的MIME规范的版本。当前MIME的版本是1.0。未来可能会定义MIME的其他版本。多亏了这个标题行，处理电子邮件消息的软件将能够适应用于编码消息的MIME版本。不包含此标题的消息应按照原始的[**RFC
    822**](https://datatracker.ietf.org/doc/html/rfc822.html)规范进行格式化。
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Content-Type: header line indicates the type of data that is carried inside
    the message (see below).'
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Content-Type:标题行指示消息内部携带的数据类型（见下文）。
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Content-Transfer-Encoding: header line is used to specify how the message
    has been encoded. When MIME was designed, some email servers were only able to
    process messages containing characters encoded using the 7 bits ASCII character
    set. MIME allows the utilization of other character encodings.'
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Content-Transfer-Encoding:标题行用于指定消息的编码方式。当MIME被设计时，一些电子邮件服务器只能处理包含使用7位ASCII字符集编码的字符的消息。MIME允许使用其他字符编码。
- en: 'Inside the email header, the Content-Type: header line indicates how the MIME
    email message is structured. [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    defines the utilization of this header line. The two most common structures for
    MIME messages are :'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件标题内部，Content-Type:标题行指示MIME电子邮件消息的结构。**[RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)定义了此标题行的使用。MIME消息的两种最常见结构是：
- en: 'Content-Type: multipart/mixed. This header line indicates that the MIME message
    contains several independent parts. For example, such a message may contain a
    part in plain text and a binary file.'
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Type: multipart/mixed. 这个头部行表示 MIME 消息包含几个独立的部分。例如，这样的消息可能包含纯文本部分和二进制文件。'
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Content-Type: multipart/alternative. This header line indicates that the MIME
    message contains several representations of the same information. For example,
    a multipart/alternative message may contain both a plain text and an HTML version
    of the same text.'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Type: multipart/alternative. 这个头部行表示 MIME 消息包含相同信息的几个表示。例如，multipart/alternative
    消息可能包含相同文本的纯文本和 HTML 版本。'
- en: 'To support these two types of MIME messages, the recipient of a message must
    be able to extract the different parts from the message. In [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html),
    an empty line was used to separate the header lines from the body. Using an empty
    line to separate the different parts of an email body would be difficult as the
    body of email messages often contains one or more empty lines. Another possible
    option would be to define a special line, e.g. *-LAST_LINE-* to mark the boundary
    between two parts of a MIME message. Unfortunately, this is not possible as some
    emails may contain this string in their body (e.g. emails sent to students to
    explain the format of MIME messages). To solve this problem, the Content-Type:
    header line contains a second parameter that specifies the string that has been
    used by the sender of the MIME message to delineate the different parts. In practice,
    this string is often chosen randomly by the mail client.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '为了支持这两种类型的 MIME 消息，消息的接收者必须能够从消息中提取不同的部分。在 [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    中，使用空行来分隔头部行和正文。使用空行来分隔电子邮件正文的各个部分将很困难，因为电子邮件的正文通常包含一个或多个空行。另一个可能的选项是定义一个特殊的行，例如
    *-LAST_LINE-* 来标记 MIME 消息两个部分之间的边界。不幸的是，这是不可能的，因为一些电子邮件可能在它们的正文中包含这个字符串（例如，发送给学生解释
    MIME 消息格式的电子邮件）。为了解决这个问题，Content-Type: 头部行包含一个第二个参数，该参数指定了 MIME 消息的发送者用来分隔不同部分的字符串。实际上，这个字符串通常由邮件客户端随机选择。'
- en: 'The email message below, copied from [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    shows a MIME message containing two parts that are both in plain text and encoded
    using the ASCII character set. The string simple boundary is defined in the Content-Type:
    header as the marker for the boundary between two successive parts. Another example
    of MIME messages may be found in [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '以下电子邮件消息，复制自 [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)，显示了一个包含两个部分的
    MIME 消息，这两个部分都是纯文本，并使用 ASCII 字符集编码。字符串 simple boundary 在 Content-Type: 头部中定义为两个连续部分之间的边界标记。MIME
    消息的另一个例子可以在 [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    中找到。'
- en: '[PRE3]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Content-Type: header can also be used inside a MIME part. In this case,
    it indicates the type of data placed in this part. Each data type is specified
    as a type followed by a subtype. A detailed description may be found in [**RFC
    2046**](https://datatracker.ietf.org/doc/html/rfc2046.html). Some of the most
    popular Content-Type: header lines are :'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: 头部也可以在 MIME 部分内部使用。在这种情况下，它表示放置在此部分中的数据类型。每种数据类型都指定为一个类型后跟一个子类型。更详细的描述可以在
    [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html) 中找到。一些最受欢迎的
    Content-Type: 头部行如下：'
- en: 'text. The message part contains information in textual format. There are several
    subtypes : text/plain for regular ASCII text, text/html defined in [**RFC 2854**](https://datatracker.ietf.org/doc/html/rfc2854.html)
    for documents in [HTML](../glossary.html#term-HTML) format or the text/enriched
    format defined in [**RFC 1896**](https://datatracker.ietf.org/doc/html/rfc1896.html).
    The Content-Type: header line may contain a second parameter that specifies the
    character set used to encode the text. charset=us-ascii is the standard ASCII
    character table. Other frequent character sets include charset=UTF8 or charset=iso-8859-1.
    The [list of standard character sets](http://www.iana.org/assignments/character-sets)
    is maintained by [IANA](../glossary.html#term-IANA).'
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'text. 消息部分包含文本格式的信息。有几种子类型：text/plain 用于常规 ASCII 文本，text/html 定义在 [**RFC 2854**](https://datatracker.ietf.org/doc/html/rfc2854.html)
    中，用于 [HTML](../glossary.html#term-HTML) 格式的文档或 text/enriched 格式，该格式定义在 [**RFC
    1896**](https://datatracker.ietf.org/doc/html/rfc1896.html) 中。Content-Type: 头行可能包含一个第二个参数，用于指定编码文本所使用的字符集。charset=us-ascii
    是标准的 ASCII 字符表。其他常见的字符集包括 charset=UTF8 或 charset=iso-8859-1。标准字符集的 [列表](http://www.iana.org/assignments/character-sets)
    由 [IANA](../glossary.html#term-IANA) 维护。'
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: image. The message part contains a binary representation of an image. The subtype
    indicates the format of the image such as [gif](http://en.wikipedia.org/wiki/Graphics_Interchange_Format),
    [jpg](http://en.wikipedia.org/wiki/Jpeg) or [png](http://en.wikipedia.org/wiki/Portable_Network_Graphics).
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: image. 消息部分包含图像的二进制表示。子类型指示图像的格式，如 [gif](http://en.wikipedia.org/wiki/Graphics_Interchange_Format)，[jpg](http://en.wikipedia.org/wiki/Jpeg)
    或 [png](http://en.wikipedia.org/wiki/Portable_Network_Graphics)。
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: audio. The message part contains an audio clip. The subtype indicates the format
    of the audio clip like [wav](http://en.wikipedia.org/wiki/Wav) or [mp3](http://en.wikipedia.org/wiki/Mp3).
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: audio. 消息部分包含音频剪辑。子类型指示音频剪辑的格式，如 [wav](http://en.wikipedia.org/wiki/Wav) 或 [mp3](http://en.wikipedia.org/wiki/Mp3)。
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: video. The message part contains a video clip. The subtype indicates the format
    of the video clip like [avi](http://en.wikipedia.org/wiki/Audio_Video_Interleave)
    or [mp4](http://en.wikipedia.org/wiki/Mp4).
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: video. 消息部分包含视频剪辑。子类型指示视频剪辑的格式，如 [avi](http://en.wikipedia.org/wiki/Audio_Video_Interleave)
    或 [mp4](http://en.wikipedia.org/wiki/Mp4)。
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: application. The message part contains binary information that was produced
    by the particular application listed as the subtype. Email clients use the subtype
    to launch the application that is able to decode the received binary information.
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: application. 消息部分包含由子类型中列出的特定应用程序产生的二进制信息。电子邮件客户端使用子类型来启动能够解码接收到的二进制信息的应用程序。
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From ASCII to Unicode
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ASCII 到 Unicode
- en: The first computers used different techniques to represent characters in memory
    and on disk. During the 1960s, computers began to exchange information via tape
    or telephone lines. Unfortunately, each vendor had its own proprietary character
    set and exchanging data between computers from different vendors was often difficult.
    The 7 bits ASCII character table [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html)
    was adopted by several vendors and by many Internet protocols. However, ASCII
    became a problem with the internationalization of the Internet and the desire
    of more and more users to use character sets that support their own written language.
    A first attempt at solving this problem was the definition of the [ISO-8859](https://en.wikipedia.org/wiki/ISO_8859)
    character sets by [ISO](../glossary.html#term-ISO). This family of standards specified
    various character sets that allowed the representation of many European written
    languages by using 8 bits characters. Unfortunately, an 8-bits character set is
    not sufficient to support some widely used languages, such as those used in Asian
    countries. Fortunately, at the end of the 1980s, several computer scientists proposed
    to develop a standard that supports all written languages used on Earth today.
    The Unicode standard [[Unicode]](../bibliography.html#unicode) has now been adopted
    by most computer and software vendors. For example, Java always uses Unicode to
    manipulate characters, Python can handle both ASCII and Unicode characters. Internet
    applications are slowly moving towards complete support for the Unicode character
    sets, but moving from ASCII to Unicode is an important change that can have a
    huge impact on current deployed implementations. See, for example, the work to
    completely internationalize email [**RFC 4952**](https://datatracker.ietf.org/doc/html/rfc4952.html)
    and domain names [**RFC 5890**](https://datatracker.ietf.org/doc/html/rfc5890.html).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的计算机使用不同的技术来表示内存和磁盘上的字符。在 1960 年代，计算机开始通过磁带或电话线路交换信息。不幸的是，每个供应商都有自己的专有字符集，不同供应商的计算机之间的数据交换往往很困难。7
    位 ASCII 字符表 [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html) 被几家供应商和许多互联网协议采用。然而，随着互联网的国际化以及越来越多的用户希望使用支持他们自己书写语言的字符集，ASCII
    变成了一个问题。解决这个问题的第一个尝试是 ISO [ISO-8859](https://en.wikipedia.org/wiki/ISO_8859) 字符集的定义。这个标准系列指定了各种字符集，通过使用
    8 位字符可以表示许多欧洲书写语言。不幸的是，8 位字符集不足以支持一些广泛使用的语言，例如亚洲国家使用的语言。幸运的是，在 1980 年代末，几位计算机科学家提出了开发一个支持地球上今天使用的所有书写语言的标准。Unicode
    标准现在已被大多数计算机和软件供应商采用。例如，Java 总是使用 Unicode 来操作字符，Python 可以处理 ASCII 和 Unicode 字符。互联网应用程序正逐渐转向对
    Unicode 字符集的完全支持，但从 ASCII 到 Unicode 的转变是一个重要的变化，可能会对当前部署的实施产生巨大影响。例如，查看完全国际化电子邮件
    [**RFC 4952**](https://datatracker.ietf.org/doc/html/rfc4952.html) 和域名 [**RFC
    5890**](https://datatracker.ietf.org/doc/html/rfc5890.html) 的工作。
- en: 'The last MIME header line is Content-Transfer-Encoding:. This header line is
    used after the Content-Type: header line, within a message part, and specifies
    how the message part has been encoded. The default encoding is to use 7 bits ASCII.
    The most frequent encodings are quoted-printable and Base64. Both support encoding
    a sequence of bytes into a set of ASCII lines that can be safely transmitted by
    email servers. quoted-printable is defined in [**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html).
    We briefly describe base64 which is defined in [**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)
    and [**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一个 MIME 头行是 Content-Transfer-Encoding:. 这个头行在 Content-Type: 头行之后，在消息部分内使用，并指定了消息部分是如何被编码的。默认编码是使用
    7 位 ASCII。最常用的编码是 quoted-printable 和 Base64。两者都支持将一系列字节编码成一组 ASCII 行，这些行可以通过电子邮件服务器安全传输。quoted-printable
    定义在 [**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)。我们简要描述
    base64，它定义在 [**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)
    和 [**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html)。'
- en: Base64 divides the sequence of bytes to be encoded into groups of three bytes
    (with the last group possibly being partially filled). Each group of three bytes
    is then divided into four six-bit fields and each six bit field is encoded as
    a character from the table below.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 将要编码的字节序列分成三字节的组（最后一个组可能是不完整的）。然后，每个三字节的组被分成四个六位字段，每个六位字段被编码为下表中的一个字符。
- en: '| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 编码 | 值 | 编码 | 值 | 编码 | 值 | 编码 |'
- en: '| 0 | A | 17 | R | 34 | i | 51 | z |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 0 | A | 17 | R | 34 | i | 51 | z |'
- en: '| 1 | B | 18 | S | 35 | j | 52 | 0 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B | 18 | S | 35 | j | 52 | 0 |'
- en: '| 2 | C | 19 | T | 36 | k | 53 | 1 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 2 | C | 19 | T | 36 | k | 53 | 1 |'
- en: '| 3 | D | 20 | U | 37 | l | 54 | 2 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 3 | D | 20 | U | 37 | l | 54 | 2 |'
- en: '| 4 | E | 21 | V | 38 | m | 55 | 3 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 4 | E | 21 | V | 38 | m | 55 | 3 |'
- en: '| 5 | F | 22 | W | 39 | n | 56 | 4 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 5 | F | 22 | W | 39 | n | 56 | 4 |'
- en: '| 6 | G | 23 | X | 40 | o | 57 | 5 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 6 | G | 23 | X | 40 | o | 57 | 5 |'
- en: '| 7 | H | 24 | Y | 41 | p | 58 | 6 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 7 | H | 24 | Y | 41 | p | 58 | 6 |'
- en: '| 8 | I | 25 | Z | 42 | q | 59 | 7 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 8 | I | 25 | Z | 42 | q | 59 | 7 |'
- en: '| 9 | J | 26 | a | 43 | r | 60 | 8 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 9 | J | 26 | a | 43 | r | 60 | 8 |'
- en: '| 10 | K | 27 | b | 44 | s | 61 | 9 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 10 | K | 27 | b | 44 | s | 61 | 9 |'
- en: '| 11 | L | 28 | c | 45 | t | 62 | + |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 11 | L | 28 | c | 45 | t | 62 | + |'
- en: '| 12 | M | 29 | d | 46 | u | 63 | / |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 12 | M | 29 | d | 46 | u | 63 | / |'
- en: '| 13 | N | 30 | e | 47 | v |  |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 13 | N | 30 | e | 47 | v |  |  |'
- en: '| 14 | O | 31 | f | 48 | w |  |  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 14 | O | 31 | f | 48 | w |  |  |'
- en: '| 15 | P | 32 | g | 49 | x |  |  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 15 | P | 32 | g | 49 | x |  |  |'
- en: '| 16 | Q | 33 | h | 50 | y |  |  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 16 | Q | 33 | h | 50 | y |  |  |'
- en: The example below, from [**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html),
    illustrates the Base64 encoding.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例，来自[**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html)，说明了Base64编码。
- en: '| Input data | 0x14fb9c03d97e |'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入数据 | 0x14fb9c03d97e |'
- en: '| 8-bit | 00010100 11111011 10011100 00000011 11011001 01111110 |'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8-bit | 00010100 11111011 10011100 00000011 11011001 01111110 |'
- en: '| 6-bit | 000101 001111 101110 011100 000000 111101 100101 111110 |'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6-bit | 000101 001111 101110 011100 000000 111101 100101 111110 |'
- en: '| Decimal | 5 15 46 28 0 61 37 62 |'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 十进制 | 5 15 46 28 0 61 37 62 |'
- en: '| Encoding | F P u c A 9 l + |'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | F P u c A 9 l + |'
- en: The last point to be discussed about base64 is what happens when the length
    of the sequence of bytes to be encoded is not a multiple of three. In this case,
    the last group of bytes may contain one or two bytes instead of three. Base64
    reserves the = character as a padding character. This character is used once when
    the last group contains two bytes and twice when it contains one byte as illustrated
    by the two examples below.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Base64的最后一点要讨论的是，当要编码的字节序列长度不是3的倍数时会发生什么。在这种情况下，最后一组字节可能包含一个或两个字节而不是三个。Base64将等号（=）字符保留为填充字符。当最后一组包含两个字节时，该字符使用一次；当它包含一个字节时，该字符使用两次，如下面的两个示例所示。
- en: '| Input data | 0x14 |'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入数据 | 0x14 |'
- en: '| 8-bit | 00010100 |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8-bit | 00010100 |'
- en: '| 6-bit | 000101 000000 |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6-bit | 000101 000000 |'
- en: '| Decimal | 5 0 |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 十进制 | 5 0 |'
- en: '| Encoding | F A = = |'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | F A = = |'
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Input data | 0x14b9 |'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入数据 | 0x14b9 |'
- en: '| 8-bit | 00010100 11111011 |'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8-bit | 00010100 11111011 |'
- en: '| 6-bit | 000101 001111 101100 |'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6-bit | 000101 001111 101100 |'
- en: '| Decimal | 5 15 44 |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 十进制 | 5 15 44 |'
- en: '| Encoding | F P s = |'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | F P s = |'
- en: Now that we have explained the format of the email messages, we can discuss
    how these messages can be exchanged through the Internet. [Fig. 30](#fig-email-protocols)
    illustrates the protocols that are used when Alice sends an email message to Bob.
    Alice prepares her email with an email client or on a webmail interface. To send
    her email to Bob, Alice’s client will use the Simple Mail Transfer Protocol ([SMTP](../glossary.html#term-SMTP))
    to deliver her message to her SMTP server. Alice’s email client is configured
    with the name of the default SMTP server for her domain. There is usually at least
    one SMTP server per domain. To deliver the message, Alice’s SMTP server must find
    the SMTP server that contains Bob’s mailbox. This can be done by using the Mail
    eXchange (MX) records of the DNS. A set of MX records can be associated to each
    domain. Each MX record contains a numerical preference and the fully qualified
    domain name of a SMTP server that is able to deliver email messages destined to
    all valid email addresses of this domain. The DNS can return several MX records
    for a given domain. In this case, the server with the lowest numerical preference
    is used first [**RFC 2821**](https://datatracker.ietf.org/doc/html/rfc2821.html).
    If this server is not reachable, the second most preferred server is used etc.
    Bob’s SMTP server will store the message sent by Alice until Bob retrieves it
    using a webmail interface or protocols such as the Post Office Protocol ([POP](../glossary.html#term-POP))
    or the Internet Message Access Protocol ([IMAP](../glossary.html#term-IMAP)).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了电子邮件消息的格式，我们可以讨论这些消息如何通过互联网进行交换。[图 30](#fig-email-protocols) 展示了当爱丽丝向鲍勃发送电子邮件消息时使用的协议。爱丽丝使用电子邮件客户端或网页邮件界面准备她的电子邮件。为了将她的电子邮件发送给鲍勃，爱丽丝的客户端将使用简单邮件传输协议
    ([SMTP](../glossary.html#term-SMTP)) 将她的消息发送到她的 SMTP 服务器。爱丽丝的电子邮件客户端配置了她的域的默认
    SMTP 服务器名称。通常每个域至少有一个 SMTP 服务器。为了投递消息，爱丽丝的 SMTP 服务器必须找到包含鲍勃邮箱的 SMTP 服务器。这可以通过使用
    DNS 的邮件交换 (MX) 记录来完成。一组 MX 记录可以与每个域相关联。每个 MX 记录包含一个数值优先级和一个能够投递发送到该域所有有效电子邮件地址的电子邮件消息的
    SMTP 服务器的完全限定域名。DNS 可以为给定域返回多个 MX 记录。在这种情况下，数值优先级最低的服务器首先使用 [**RFC 2821**](https://datatracker.ietf.org/doc/html/rfc2821.html)。如果此服务器不可达，则使用次优先的服务器等。鲍勃的
    SMTP 服务器将存储爱丽丝发送的消息，直到鲍勃使用网页邮件界面或邮局协议 ([POP](../glossary.html#term-POP)) 或互联网消息访问协议
    ([IMAP](../glossary.html#term-IMAP)) 获取它。
- en: '![Figure made with TikZ](../Images/1016e46afc46c3c3a2098ab7047067a3.png)'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/1016e46afc46c3c3a2098ab7047067a3.png)'
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 30 Email delivery protocols
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 30 电子邮件投递协议
- en: '### The Simple Mail Transfer Protocol[#](#the-simple-mail-transfer-protocol
    "Link to this heading")'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '### 简单邮件传输协议[#](#the-simple-mail-transfer-protocol "链接到本标题")'
- en: The Simple Mail Transfer Protocol ([SMTP](../glossary.html#term-SMTP)) defined
    in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html) is a client-server
    protocol. The SMTP specification distinguishes between five types of processes
    involved in the delivery of email messages. Email messages are composed on a Mail
    User Agent (MUA). The MUA is usually either an email client or a webmail. The
    MUA sends the email message to a Mail Submission Agent (MSA). The MSA processes
    the received email and forwards it to the Mail Transmission Agent (MTA). The MTA
    is responsible for the transmission of the email, directly or via intermediate
    MTAs to the MTA of the destination domain. This destination MTA will then forward
    the message to the Mail Delivery Agent (MDA) where it will be accessed by the
    recipient’s MUA. SMTP is used for the interactions between MUA and MSA [[12]](#fsmtpauth),
    MSA-MTA and MTA-MTA.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html) 中定义的简单邮件传输协议
    ([SMTP](../glossary.html#term-SMTP)) 是一种客户端-服务器协议。SMTP 规范区分了在电子邮件消息投递中涉及的五种类型的过程。电子邮件消息是在邮件用户代理
    (MUA) 上编写的。MUA 通常是一个电子邮件客户端或网页邮件。MUA 将电子邮件消息发送到邮件提交代理 (MSA)。MSA 处理接收到的电子邮件并将其转发到邮件传输代理
    (MTA)。MTA 负责电子邮件的传输，直接或通过中间 MTA 传输到目标域的 MTA。然后，目标 MTA 将消息转发到邮件投递代理 (MDA)，在那里它将被收件人的
    MUA 访问。SMTP 用于 MUA 和 MSA [[12]](#fsmtpauth)，MSA-MTA 和 MTA-MTA 之间的交互。
- en: SMTP is a text-based protocol like many other application-layer protocols on
    the Internet. It relies on the byte-stream service. Servers listen on port 25.
    Clients send commands that are each composed of one line of ASCII text terminated
    by CR+LF. Servers reply by sending ASCII lines that contain a three digit numerical
    error/success code and optional comments.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 是一种基于文本的协议，类似于互联网上许多其他应用层协议。它依赖于字节流服务。服务器监听端口 25。客户端发送由一行 ASCII 文本组成并终止于
    CR+LF 的命令。服务器通过发送包含三位数字错误/成功代码和可选注释的 ASCII 行进行回复。
- en: The SMTP protocol, like most text-based protocols, is specified as a [BNF](../glossary.html#term-BNF).
    The full BNF is defined in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html).
    The main SMTP commands are defined by the BNF rules shown in [Fig. 31](#fig-smtp-bnf).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 协议，类似于大多数基于文本的协议，被指定为 [BNF](../glossary.html#term-BNF)。完整的 BNF 定义在 [**RFC
    5321**](https://datatracker.ietf.org/doc/html/rfc5321.html) 中。主要的 SMTP 命令由 [图
    31](#fig-smtp-bnf) 中显示的 BNF 规则定义。
- en: '[![../_images/smtp-bnf.svg](../Images/c14bdccb9a063300e7e5dc0d244b52c9.png)](../_images/smtp-bnf.svg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/smtp-bnf.svg](../Images/c14bdccb9a063300e7e5dc0d244b52c9.png)](../_images/smtp-bnf.svg)'
- en: Fig. 31 BNF specification of the SMTP commands[#](#id60 "Link to this image")
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 31 SMTP 命令的 BNF 规范[#](#id60 "链接到这张图片")
- en: In this BNF, atext corresponds to printable ASCII characters. This BNF rule
    is defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html).
    The five main commands are EHLO [[13]](#fehlo), MAIL FROM:, RCPT TO:, DATA and
    QUIT. Postmaster is the alias of the system administrator who is responsible for
    a given domain or SMTP server. All domains must have a Postmaster alias. The SMTP
    responses are defined by the BNF shown in [Fig. 32](#fig-smtp-responses).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 BNF 中，atext 对应于可打印的 ASCII 字符。这个 BNF 规则定义在 [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    中。五个主要命令是 EHLO [[13]](#fehlo)，MAIL FROM:，RCPT TO:，DATA 和 QUIT。Postmaster 是负责特定域名或
    SMTP 服务器的系统管理员的别名。所有域名都必须有一个 Postmaster 别名。SMTP 响应由 [图 32](#fig-smtp-responses)
    中显示的 BNF 定义。
- en: '![../_images/smtp-response.svg](../Images/699468c24e349ef194f6c3fcb1101a01.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/smtp-response.svg](../Images/699468c24e349ef194f6c3fcb1101a01.png)'
- en: Fig. 32 BNF specification of the SMTP responses[#](#id61 "Link to this image")
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 32 SMTP 响应的 BNF 规范[#](#id61 "链接到这张图片")
- en: SMTP servers use structured reply codes containing three digits and an optional
    comment. The first digit of the reply code indicates whether the command was successful
    or not. A reply code of 2xy indicates that the command has been accepted. A reply
    code of 3xy indicates that the command has been accepted, but additional information
    from the client is expected. A reply code of 4xy indicates a transient negative
    reply. This means that for some reason, which is indicated by either the other
    digits or the comment, the command cannot be processed immediately, but there
    is some hope that the problem will only be transient. This is basically telling
    the client to try the same command again later. In contrast, a reply code of 5xy
    indicates a permanent failure or error. In this case, it is useless for the client
    to retry the same command later. Other application layer protocols such as FTP
    [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html) or HTTP [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) use a similar structure
    for their reply codes. Additional details about the other reply codes may be found
    in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 服务器使用包含三位数字和可选注释的结构化响应代码。响应代码的第一位数字表示命令是否成功。2xy 的响应代码表示命令已被接受。3xy 的响应代码表示命令已被接受，但需要客户端提供更多信息。4xy
    的响应代码表示暂时性负面响应。这意味着由于某种原因（由其他数字或注释指示），命令不能立即处理，但仍有希望问题只是暂时的。这基本上是在告诉客户端稍后再尝试相同的命令。相比之下，5xy
    的响应代码表示永久性失败或错误。在这种情况下，客户端稍后重试相同的命令是无用的。其他应用层协议，如 FTP [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html)
    或 HTTP [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)，它们的响应代码使用类似的结构。有关其他响应代码的更多详细信息，请参阅
    [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html)。
- en: 'Examples of SMTP reply codes include the following :'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 响应代码的示例包括以下内容：
- en: '[PRE4]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Reply code 220 is used by the server as the first message when it agrees to
    interact with the client. Reply code 221 is sent by the server before closing
    the underlying transport connection. Reply code 250 is the standard positive reply
    that indicates the success of the previous command. Reply code 354 indicates that
    the client can start transmitting its email message. Reply code 421 is returned
    when there is a problem (e.g. lack of memory/disk resources) that prevents the
    server from accepting the transport connection. Reply codes 450 and 452 indicate
    that the destination mailbox is temporarily unavailable, for various reasons,
    while reply code 550 indicates that the mailbox does not exist or cannot be used
    for policy reasons. The 500 to 503 reply codes correspond to errors in the commands
    sent by the client. The 503 reply code would be sent by the server when the client
    sends commands in an incorrect order (e.g. the client tries to send an email before
    providing the destination address of the message).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在同意与客户端交互时，会使用回复代码 220 作为第一条消息。在关闭底层传输连接之前，服务器会发送回复代码 221。回复代码 250 是标准的积极回复，表示前一个命令的成功执行。回复代码
    354 表示客户端可以开始传输其电子邮件消息。当存在阻止服务器接受传输连接的问题（例如内存/磁盘资源不足）时，会返回回复代码 421。回复代码 450 和
    452 表示目标邮箱因各种原因暂时不可用，而回复代码 550 表示邮箱不存在或因策略原因无法使用。500 到 503 的回复代码对应于客户端发送的命令错误。当客户端以错误的顺序发送命令时（例如，客户端在提供消息的目标地址之前尝试发送电子邮件），服务器会发送
    503 回复代码。
- en: 'The transfer of an email message is performed in three phases. During the first
    phase, the client opens a transport connection with the server. Once the connection
    has been established, the client and the server exchange greetings messages (EHLO
    command). Most servers insist on receiving valid greeting messages and some of
    them drop the underlying transport connection if they do not receive a valid greeting.
    Once the greetings have been exchanged, the email transfer phase can start. During
    this phase, the client transfers one or more email messages by indicating the
    email address of the sender (MAIL FROM: command), the email address of the recipient
    (RCPT TO: command) followed by the headers and the body of the email message (DATA
    command). Once the client has finished sending all its queued email messages to
    the SMTP server, it terminates the SMTP association (QUIT command).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '电子邮件消息的传输分为三个阶段。在第一阶段，客户端与服务器建立传输连接。一旦连接建立，客户端和服务器交换问候消息（EHLO 命令）。大多数服务器坚持要求接收有效的问候消息，如果它们没有收到有效的问候消息，其中一些服务器会丢弃底层的传输连接。问候交换完成后，电子邮件传输阶段可以开始。在这个阶段，客户端通过指示发送者的电子邮件地址（MAIL
    FROM: 命令）、收件人的电子邮件地址（RCPT TO: 命令）以及电子邮件消息的头部和正文（DATA 命令）来传输一个或多个电子邮件消息。一旦客户端将其所有排队电子邮件消息发送到
    SMTP 服务器，它将终止 SMTP 协议（QUIT 命令）。'
- en: A successful transfer of an email message is shown below
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个成功的电子邮件传输示例
- en: '[PRE5]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the example above, the MTA running on mta.example.org opens a TCP connection
    to the SMTP server on host smtp.example.com. The lines prefixed with S: (resp.
    C:) are the responses sent by the server (resp. the commands sent by the client).
    The server sends its greetings as soon as the TCP connection has been established.
    The client then sends the EHLO command with its fully qualified domain name. The
    server replies with reply-code 250 and sends its greetings. The SMTP association
    can now be used to exchange an email.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，运行在 mta.example.org 上的 MTA 打开到主机 smtp.example.com 上 SMTP 服务器的 TCP 连接。带有
    S:（分别对应 C:）前缀的行是服务器（分别对应客户端）发送的响应。服务器在 TCP 连接建立后立即发送其问候。然后客户端发送带有其完全限定域名（FQDN）的
    EHLO 命令。服务器以回复代码 250 响应并发送其问候。现在可以使用 SMTP 协议交换电子邮件。
- en: 'To send an email, the client must first provide the address of the recipient
    with RCPT TO:. Then it uses the MAIL FROM: with the address of the sender. Both
    the recipient and the sender are accepted by the server. The client can now issue
    the DATA command to start the transfer of the email message. After having received
    the 354 reply code, the client sends the headers and the body of its email message.
    The client indicates the end of the message by sending a line containing only
    the . (dot) character [[14]](#fdot). The server confirms that the email message
    has been queued for delivery or transmission with a reply code of 250. The client
    issues the QUIT command to close the session and the server confirms with reply-code
    221, before closing the TCP connection.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，客户端必须首先使用RCPT TO:提供收件人的地址。然后它使用MAIL FROM:发送发送者的地址。服务器接受收件人和发送者。现在客户端可以发出DATA命令以开始电子邮件消息的传输。在收到354回复代码后，客户端发送其电子邮件消息的标题和正文。客户端通过发送只包含.（点）字符的行来指示消息的结束[[14]](#fdot)。服务器通过回复代码250确认电子邮件消息已被排队等待发送或传输。客户端发出QUIT命令来关闭会话，服务器在关闭TCP连接之前以回复代码221进行确认。
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Open SMTP relays and spam
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 开放SMTP中继和垃圾邮件
- en: Since its creation in 1971, email has been a very useful tool that is used by
    many users to exchange lots of information. In the early days, all SMTP servers
    were open and anyone could use them to forward emails towards their final destination.
    Unfortunately, over the years, some unscrupulous users have found ways to use
    email for marketing purposes or to send malware. The first documented abuse of
    email for marketing purposes occurred in 1978 when a marketer who worked for a
    computer vendor sent a [marketing email](http://www.templetons.com/brad/spamreact.html#msg)
    to many ARPANET users. At that time, the ARPANET could only be used for research
    purposes and this was an abuse of the acceptable use policy. Unfortunately, given
    the extremely low cost of sending emails, the problem of unsolicited emails has
    not stopped. Unsolicited emails are now called spam and a [study](http://www.enisa.europa.eu/act/res/other-areas/anti-spam-measures)
    carried out by [ENISA](https://www.enisa.europa.eu/) in 2009 reveals that 95%
    of email was spam and this number seems to continue to grow. This places a burden
    on the email infrastructure of Internet Service Providers and large companies
    that need to process many useless messages.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 自1971年创建以来，电子邮件已经成为一个非常有用的工具，许多用户用它来交换大量信息。在早期，所有的SMTP服务器都是开放的，任何人都可以使用它们将电子邮件转发到最终目的地。不幸的是，多年来，一些不择手段的用户找到了利用电子邮件进行营销或发送恶意软件的方法。第一个有记录的将电子邮件用于营销目的的滥用发生在1978年，当时一位为计算机供应商工作的营销人员向许多ARPANET用户发送了一封[营销电子邮件](http://www.templetons.com/brad/spamreact.html#msg)。当时，ARPANET只能用于研究目的，这违反了可接受的使用政策。遗憾的是，由于发送电子邮件的成本极低，未经请求的电子邮件问题并未停止。未经请求的电子邮件现在被称为垃圾邮件，[ENISA](https://www.enisa.europa.eu/)在2009年进行的一项[研究](http://www.enisa.europa.eu/act/res/other-areas/anti-spam-measures)显示，95%的电子邮件都是垃圾邮件，并且这个数字似乎还在继续增长。这给互联网服务提供商和需要处理大量无用信息的公司带来了负担。
- en: 'Given the amount of spam messages, SMTP servers are no longer open [**RFC 5068**](https://datatracker.ietf.org/doc/html/rfc5068.html).
    Several extensions to SMTP have been developed in recent years to deal with this
    problem. For example, the SMTP authentication scheme defined in [**RFC 4954**](https://datatracker.ietf.org/doc/html/rfc4954.html)
    can be used by an SMTP server to authenticate a client. Several techniques have
    also been proposed to allow SMTP servers to authenticate the messages sent by
    their users [**RFC 4870**](https://datatracker.ietf.org/doc/html/rfc4870.html)
    [**RFC 4871**](https://datatracker.ietf.org/doc/html/rfc4871.html) .  ### The
    Post Office Protocol[#](#the-post-office-protocol "Link to this heading")'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于垃圾邮件的数量，SMTP服务器现在不再开放[**RFC 5068**](https://datatracker.ietf.org/doc/html/rfc5068.html)。近年来已经开发了几种SMTP的扩展来解决这个问题。例如，[**RFC
    4954**](https://datatracker.ietf.org/doc/html/rfc4954.html)中定义的SMTP身份验证方案可以被SMTP服务器用来验证客户端。还提出了几种技术，允许SMTP服务器验证用户发送的消息[**RFC
    4870**](https://datatracker.ietf.org/doc/html/rfc4870.html) [**RFC 4871**](https://datatracker.ietf.org/doc/html/rfc4871.html)。###
    邮政协议[#](#the-post-office-protocol "链接到这个标题")
- en: When the first versions of SMTP were designed, the Internet was composed of
    minicomputers that were used by an entire university department or research lab.
    These minicomputers were used by many users at the same time. Email was mainly
    used to send messages from a user on a given host to another user on a remote
    host. At that time, SMTP was the only protocol involved in the delivery of the
    emails as all hosts attached to the network were running an SMTP server. On such
    hosts, an email destined to local users was delivered by placing the email in
    a special directory or file owned by the user. However, the introduction of personal
    computers in the 1980s changed this environment. Initially, users of these personal
    computers used applications such as [telnet](../glossary.html#term-telnet) to
    open a remote session on the local [minicomputer](../glossary.html#term-minicomputer)
    to read their email. This was not user-friendly. A better solution appeared with
    the development of user friendly email client applications on personal computers.
    Several protocols were designed to allow these client applications to retrieve
    the email messages destined to a user from his/her server. Two of these protocols
    became popular and are still used today. The Post Office Protocol (POP), defined
    in [**RFC 1939**](https://datatracker.ietf.org/doc/html/rfc1939.html), is the
    simplest one. It allows a client to download all the messages destined to a given
    user from his/her email server. We describe POP briefly in this section. The second
    protocol is the Internet Message Access Protocol (IMAP), defined in [**RFC 3501**](https://datatracker.ietf.org/doc/html/rfc3501.html).
    IMAP is more powerful, but also more complex than POP. IMAP was designed to allow
    client applications to efficiently access, in real-time, to messages stored in
    various folders on servers. IMAP assumes that all the messages of a given user
    are stored on a server and provides the functions that are necessary to search,
    download, delete or filter messages.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计SMTP的第一个版本时，互联网由被整个大学系或研究实验室使用的迷你计算机组成。这些迷你计算机被许多用户同时使用。电子邮件主要用于从一个主机上的用户发送消息到远程主机上的另一个用户。当时，SMTP是唯一涉及电子邮件投递的协议，因为所有连接到网络的宿主都在运行SMTP服务器。在这些主机上，发往本地用户的电子邮件通过将电子邮件放入用户拥有的特殊目录或文件中来进行投递。然而，20世纪80年代个人电脑的引入改变了这一环境。最初，这些个人电脑的用户使用诸如[telnet](../glossary.html#term-telnet)之类的应用程序在本地[迷你计算机](../glossary.html#term-minicomputer)上打开远程会话以阅读他们的电子邮件。这并不友好。随着在个人电脑上开发用户友好的电子邮件客户端应用程序，出现了一个更好的解决方案。设计了几种协议，允许这些客户端应用程序从用户的邮件服务器检索发往用户的电子邮件消息。其中两种协议变得流行，并且至今仍在使用。定义在[**RFC
    1939**](https://datatracker.ietf.org/doc/html/rfc1939.html)中的邮局协议（POP）是最简单的一个。它允许客户端从其电子邮件服务器下载所有发往特定用户的邮件。我们在此节中简要描述POP。第二种协议是互联网消息访问协议（IMAP），定义在[**RFC
    3501**](https://datatracker.ietf.org/doc/html/rfc3501.html)。IMAP比POP更强大，但也更复杂。IMAP旨在允许客户端高效地实时访问服务器上存储在各个文件夹中的消息。IMAP假设特定用户的全部消息都存储在服务器上，并提供搜索、下载、删除或过滤消息所需的函数。
- en: 'POP is another example of a simple line-based protocol. POP runs above the
    bytestream service. A POP server usually listens to port 110\. A POP session is
    composed of three parts : an authorisation phase during which the server verifies
    the client’s credential, a transaction phase during which the client downloads
    messages and an update phase that concludes the session. The client sends commands
    and the server replies are prefixed by +OK to indicate a successful command or
    by -ERR to indicate errors.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: POP是另一种简单的基于行的协议示例。POP在字节流服务之上运行。一个POP服务器通常监听110端口。一个POP会话由三个部分组成：一个授权阶段，在此期间服务器验证客户端的凭证；一个事务阶段，在此期间客户端下载消息；以及一个更新阶段，它结束了会话。客户端发送命令，服务器的回复以+OK为前缀表示命令成功，以-ERR为前缀表示错误。
- en: When a client opens a transport connection with the POP server, the latter sends
    as banner an ASCII-line starting with +OK. The POP session is at that time in
    the authorisation phase. In this phase, the client can send its username (resp.
    password) with the USER (resp. PASS) command. The server replies with +OK if the
    username (resp. password) is valid and -ERR otherwise.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端与POP服务器建立传输连接时，服务器会发送一个以+OK开头的ASCII行作为横幅。此时，POP会话处于授权阶段。在这个阶段，客户端可以使用USER（或PASS）命令发送其用户名（或密码）。如果用户名（或密码）有效，服务器会回复+OK，否则回复-ERR。
- en: Once the username and password have been validated, the POP session enters in
    the transaction phase. In this phase, the client can issue several commands. The
    STAT command is used to retrieve the status of the server. Upon reception of this
    command, the server replies with a line that contains +OK followed by the number
    of messages in the mailbox and the total size of the mailbox in bytes. The RETR
    command, followed by a space and an integer, is used to retrieve the nth message
    of the mailbox. The DELE command is used to mark for deletion the nth message
    of the mailbox.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户名和密码得到验证，POP会话进入事务阶段。在此阶段，客户端可以发出多个命令。STAT命令用于检索服务器的状态。在接收到此命令后，服务器会回复一行，其中包含+OK，后面跟着邮箱中的消息数量和邮箱的总字节数。RETR命令后跟一个空格和一个整数，用于检索邮箱中的第n条消息。DELE命令用于标记邮箱中的第n条消息以供删除。
- en: Once the client has retrieved and possibly deleted the emails contained in the
    mailbox, it must issue the QUIT command. This command terminates the POP session
    and allows the server to delete all the messages that have been marked for deletion
    by using the DELE command.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端检索并可能删除邮箱中的电子邮件，它必须发出QUIT命令。此命令终止POP会话，并允许服务器删除所有已通过DELE命令标记为删除的消息。
- en: 'The figure below provides a simple POP session. All lines prefixed with C:
    (resp. S:) are sent by the client (resp. server).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下图提供了一个简单的POP会话。所有以C:（分别对应S:）为前缀的行都是由客户端（分别对应服务器）发送的。
- en: '[PRE6]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, a POP client contacts a POP server on behalf of the user named
    alice. Note that in this example, Alice’s password is sent in clear by the client.
    This implies that if someone is able to capture the packets sent by Alice, he
    will know Alice’s password [[15]](#fapop). Then Alice’s client issues the STAT
    command to know the number of messages that are stored in her mailbox. It then
    retrieves and deletes the first message of the mailbox.  ## The world wide web[#](#the-world-wide-web
    "Link to this heading")'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '在此示例中，一个名为alice的POP客户端代表该用户联系POP服务器。请注意，在此示例中，Alice的密码由客户端明文发送。这意味着如果有人能够捕获Alice发送的包，他将知道Alice的密码
    [[15]](#fapop)。然后Alice的客户端发出STAT命令以了解其邮箱中存储的消息数量。然后检索并删除邮箱中的第一条消息。  ## 互联网世界[#](#the-world-wide-web
    "链接到本标题")'
- en: In the early days, the Internet was mainly used for remote terminal access with
    [telnet](https://en.wikipedia.org/wiki/Telnet), email and file transfer. The default
    file transfer protocol, FTP, defined in [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html)
    was widely used. FTP clients and servers are still included in some operating
    systems.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，互联网主要用于远程终端访问，如[telnet](https://en.wikipedia.org/wiki/Telnet)、电子邮件和文件传输。默认的文件传输协议FTP，定义在[**RFC
    959**](https://datatracker.ietf.org/doc/html/rfc959.html)，被广泛使用。FTP客户端和服务器仍包含在一些操作系统中。
- en: 'Many FTP clients offered a user interface similar to a Unix shell and allowed
    clients to browse the file system on the server and to send and retrieve files.
    FTP servers can be configured in two modes :'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 许多FTP客户端提供了类似于Unix shell的用户界面，并允许客户端浏览服务器上的文件系统，发送和检索文件。FTP服务器可以配置为两种模式：
- en: 'authenticated : in this mode, the ftp server only accepts users with a valid
    user name and password. Once authenticated, they can access the files and directories
    according to their permissions'
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证：在此模式下，FTP服务器仅接受具有有效用户名和密码的用户。一旦认证，他们可以按照其权限访问文件和目录。
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'anonymous : in this mode, clients supply the anonymous user identifier and
    their email address as password. These clients are granted access to a special
    zone of the file system that only contains public files.'
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名：在此模式下，客户端提供匿名用户标识和电子邮件地址作为密码。这些客户端被授予访问文件系统特殊区域的权限，该区域仅包含公共文件。
- en: FTP was very popular in the 1990s and early 2000s, but today it has mostly been
    superseded by more recent protocols. Authenticated access to files is mainly done
    by using the Secure Shell ([ssh](https://en.wikipedia.org/wiki/Secure_Shell))
    protocol defined in [**RFC 4251**](https://datatracker.ietf.org/doc/html/rfc4251.html)
    and supported by clients such as [scp](https://www.openssh.org) or [sftp](https://www.openssh.org).
    Nowadays, anonymous access is mainly provided by web protocols.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: FTP在20世纪90年代和21世纪初非常流行，但如今它已被更近期的协议所取代。文件的安全访问主要通过定义在[**RFC 4251**](https://datatracker.ietf.org/doc/html/rfc4251.html)并得到如[scp](https://www.openssh.org)或[sftp](https://www.openssh.org)等客户端支持的Secure
    Shell ([ssh](https://en.wikipedia.org/wiki/Secure_Shell))协议来实现。如今，匿名访问主要由Web协议提供。
- en: In the late 1980s, high energy physicists working at [CERN](https://www.cern.ch)
    had to efficiently exchange documents about their ongoing and planned experiments.
    [Tim Berners-Lee](https://www.w3.org/People/Berners-Lee/) evaluated several of
    the documents sharing techniques that were available at that time [[B1989]](../bibliography.html#b1989).
    As none of the existing solutions met CERN’s requirements, they chose to develop
    a completely new document sharing system. This system was initially called the
    mesh. It was quickly renamed the world wide web. The starting point for the world
    wide web are hypertext documents. An hypertext document is a document that contains
    references (hyperlinks) to other documents that the reader can immediately access.
    Hypertext was not invented for the world wide web. The idea of hypertext documents
    was proposed in 1945 [[Bush1945]](../bibliography.html#bush1945) and the first
    experiments were done during the 1960s [[Nelson1965]](../bibliography.html#nelson1965)
    [[Myers1998]](../bibliography.html#myers1998) . Compared to the hypertext documents
    that were used in the late 1980s, the main innovation introduced by the world
    wide web was to allow hyperlinks to reference documents stored on different remote
    machines. This is illustrated in [Fig. 33](#fig-web).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代末，在[欧洲核子研究中心](https://www.cern.ch)工作的粒子物理学家需要高效地交换关于他们正在进行和计划中的实验的文档。[蒂姆·伯纳斯-李](https://www.w3.org/People/Berners-Lee/)评估了当时可用的几种文档共享技术[[B1989]](../bibliography.html#b1989)。由于现有的解决方案都不符合欧洲核子研究中心的要求，他们决定开发一个全新的文档共享系统。这个系统最初被称为网状系统。它很快被更名为万维网。万维网的起点是超文本文档。超文本文档是一种包含对其他文档的引用（超链接）的文档，读者可以立即访问这些文档。超文本不是为了万维网而发明的。超文本文档的想法是在1945年提出的[[Bush1945]](../bibliography.html#bush1945)，而第一次实验是在20世纪60年代进行的[[Nelson1965]](../bibliography.html#nelson1965)
    [[Myers1998]](../bibliography.html#myers1998)。与20世纪80年代末使用的超文本文档相比，万维网引入的主要创新是允许超链接引用存储在不同远程机器上的文档。这如图33所示。
- en: '![Figure made with TikZ](../Images/203e09d617f034ce3c963e378c622093.png)'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/203e09d617f034ce3c963e378c622093.png)'
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 33 World-wide web clients and servers
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图33 万维网客户端和服务器
- en: A document sharing system such as the world wide web is composed of three important
    parts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于万维网的文档共享系统由三个重要部分组成。
- en: A standardized addressing scheme that unambiguously identifies documents
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种标准化的寻址方案，可以明确地识别文档
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A standard document format : the [HyperText Markup Language](http://www.w3.org/MarkUp)'
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种标准文档格式：[超文本标记语言](http://www.w3.org/MarkUp)
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A standardized protocol to efficiently retrieve the documents stored on a server
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种标准化的协议，用于高效检索服务器上存储的文档
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Open standards and open implementations
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 开放标准和开放实现
- en: Open standards play a key role in the success of the world wide web as we know
    it today. Without open standards, the world wide web would have never reached
    its current size. In addition to open standards, another important factor for
    the success of the web was the availability of open and efficient implementations
    of these standards. When CERN started to work on the web, their objective was
    to build a running system that could be used by physicists. They developed open-source
    implementations of the [first web servers](http://www.w3.org/Daemon/) and [web
    clients](http://www.w3.org/Library/Activity.html). These open-source implementations
    were powerful and could be used as is, by institutions willing to share information.
    They were also extended by other developers who contributed to new features. For
    example, the [NCSA](https://www.ncsa.illinois.edu) added support for images in
    their [Mosaic browser](http://en.wikipedia.org/wiki/Mosaic_(web_browser)) that
    was eventually used to create [Netscape Communications](http://en.wikipedia.org/wiki/Netscape)
    and the first commercial browsers and servers.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 开放标准在我们今天所知道的万维网的成功中扮演着关键角色。没有开放标准，万维网永远不会达到现在的规模。除了开放标准之外，另一个对网络成功至关重要的因素是这些标准的开放和高效实现。当欧洲核子研究中心开始研究网络时，他们的目标是构建一个可以由物理学家使用的运行系统。他们开发了[第一个网络服务器](http://www.w3.org/Daemon/)和[网络客户端](http://www.w3.org/Library/Activity.html)的开源实现。这些开源实现功能强大，可以被愿意共享信息的机构直接使用。它们也被其他开发者扩展，以贡献新的功能。例如，[NCSA](https://www.ncsa.illinois.edu)在其[Mosaic浏览器](http://en.wikipedia.org/wiki/Mosaic_(web_browser))中增加了对图像的支持，该浏览器最终被用来创建[Netscape
    Communications](http://en.wikipedia.org/wiki/Netscape)和第一个商业浏览器和服务器。
- en: The first components of the world wide web are the Uniform Resource Identifiers
    (URI), defined in [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html).
    A URI is a character string that unambiguously identifies a resource on the world
    wide web. Here is a subset of the BNF for URIs
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网的第一个组成部分是统一资源标识符（URI），由 [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html)
    定义。URI 是一个字符字符串，明确地标识了万维网上的资源。以下是 URI 的 BNF 子集。
- en: '[PRE7]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first component of a URI is its scheme. A scheme can be seen as a selector,
    indicating the meaning of the fields after it. In practice, the scheme often identifies
    the application-layer protocol that must be used by the client to retrieve the
    document, but it is not always the case. Some schemes do not imply a protocol
    at all and some do not indicate a retrievable document [[16]](#furiretrieve).
    The most frequent schemes are http and https. We focus on http in this section.
    A URI scheme can be defined for almost any application layer protocol [[17]](#furilist).
    The characters : and // follow the scheme of any URI.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: URI 的第一个组成部分是其方案。方案可以看作是一个选择器，指示其后字段的含义。在实践中，方案通常标识客户端必须使用的应用层协议来检索文档，但这并不总是如此。一些方案根本不暗示任何协议，而另一些则不指示可检索的文档
    [[16]](#furiretrieve)。最常见的方案是 http 和 https。本节我们重点关注 http。可以为几乎任何应用层协议定义 URI 方案
    [[17]](#furilist)。冒号（:）和双斜杠（//）跟在 URI 的方案之后。
- en: The second part of the URI is the authority. With retrievable URIs, this includes
    the DNS name or the IP address of the server where the document can be retrieved
    using the protocol specified via the scheme. This name can be preceded by some
    information about the user (e.g. a user name) who is requesting the information.
    Earlier definitions of the URI allowed the specification of a user name and a
    password before the @ character ([**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html)),
    but this is now deprecated as placing a password inside a URI is insecure. The
    host name can be followed by the semicolon character and a port number. A default
    port number is defined for some protocols and the port number should only be included
    in the URI if a non-default port number is used (for other protocols, techniques
    like service DNS records can used).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: URI 的第二部分是权限。对于可检索的 URI，这包括可以检索文档的服务器的主机名或 IP 地址，该文档可以通过方案中指定的协议来检索。这个名称可以由请求信息（例如用户名）的一些信息
    precede。早期的 URI 定义允许在 @ 字符之前指定用户名和密码 ([**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html))，但现在这已被弃用，因为将密码放在
    URI 中是不安全的。主机名后面可以跟分号字符和端口号。某些协议定义了默认端口号，并且只有在使用非默认端口号时才应在 URI 中包含端口号（对于其他协议，可以使用服务
    DNS 记录等技术）。
- en: The third part of the URI is the path to the document. This path is structured
    as filenames on a Unix host (but it does not imply that the files are indeed stored
    this way on the server). If the path is not specified, the server will return
    a default document. The last two optional parts of the URI are used to provide
    a query parameter and indicate a specific part (e.g. a section in an article)
    of the requested document. Sample URIs are shown below.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: URI 的第三部分是文档的路径。这个路径的结构类似于 Unix 主机上的文件名（但这并不暗示文件确实以这种方式存储在服务器上）。如果未指定路径，服务器将返回默认文档。URI
    的最后两个可选部分用于提供查询参数并指示请求文档的特定部分（例如文章中的某个部分）。以下是一些示例 URI。
- en: '[PRE8]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first URI corresponds to a document named rfc3986.html that is stored on
    the server named tools.ietf.org and can be accessed by using the http protocol
    on its default port. The second URI corresponds to an email message, with subject
    current-issue, that will be sent to user infobot in domain example.com. The mailto:
    URI scheme is defined in [**RFC 2368**](https://datatracker.ietf.org/doc/html/rfc2368.html).
    The third URI references the portion BaseHTTPServer.BaseHTTPRequestHandler of
    the document basehttpserver.html that is stored in the library directory on the
    docs.python.org server. This document can be retrieved by using the http protocol.
    The query parameter highlight=http is associated to this URI. The fourth example
    is a server that operates the [telnet](https://en.wikipedia.org/wiki/Telnet) protocol,
    uses IPv6 address 2001:db8:3080:3::2 and is reachable on port 2323\. The last
    URI is somewhat special. Most users will assume that it corresponds to a document
    stored on the cnn.example.com server. However, to parse this URI, it is important
    to remember that the @ character is used to separate the user name from the host
    name in the authorization part of a URI. This implies that the URI points to a
    document named top_story.htm on the host having IPv4 address 10.0.0.1. The document
    will be retrieved by using the ftp protocol with the user name set to cnn.example.com&story=breaking_news.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个URI对应于一个名为rfc3986.html的文档，该文档存储在名为tools.ietf.org的服务器上，可以通过使用默认端口上的http协议来访问。第二个URI对应于一个主题为current-issue的电子邮件消息，该消息将被发送到example.com域中的用户infobot。mailto:
    URI方案在[**RFC 2368**](https://datatracker.ietf.org/doc/html/rfc2368.html)中定义。第三个URI引用的是存储在docs.python.org服务器上的库目录中的文档basehttpserver.html的部分BaseHTTPServer.BaseHTTPRequestHandler。该文档可以通过使用http协议检索。查询参数highlight=http与该URI相关联。第四个例子是一个运行[telnet](https://en.wikipedia.org/wiki/Telnet)协议的服务器，使用IPv6地址2001:db8:3080:3::2，并在2323端口上可达。最后一个URI有些特殊。大多数用户会认为它对应于存储在cnn.example.com服务器上的文档。然而，为了解析这个URI，重要的是要记住，在URI的授权部分中，@字符用于将用户名与主机名分开。这意味着URI指向一个名为top_story.htm的文档，该文档存储在具有IPv4地址10.0.0.1的主机上。该文档将通过使用ftp协议并设置用户名为cnn.example.com&story=breaking_news来检索。'
- en: The second component of the word wide web is the HyperText Markup Language (HTML).
    HTML defines the format of the documents that are exchanged on the web. The [first
    version of HTML](http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html)
    was derived from the Standard Generalized Markup Language (SGML) that was standardized
    in 1986 by [ISO](../glossary.html#term-ISO). [SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)
    was designed to support large documents maintained by government, law firms or
    aerospace companies that must be shared efficiently in a machine-readable manner.
    These industries require documents to remain readable and editable for tens of
    years and insisted on a standardized format supported by multiple vendors. Today,
    [SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language) is
    no longer widely used beyond specific applications, but its descendants including
    [HTML](../glossary.html#term-HTML) and [XML](../glossary.html#term-XML) are now
    widespread.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网的第二个组成部分是超文本标记语言（HTML）。HTML定义了在网络上交换的文档的格式。[HTML的第一个版本](http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html)是从1986年由[ISO](../glossary.html#term-ISO)标准化的通用标记语言（SGML）派生出来的。[SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)是为了支持政府、律师事务所或航空航天公司维护的大型文档而设计的，这些文档必须以机器可读的方式高效共享。这些行业要求文档在十年甚至更长时间内保持可读和可编辑，并坚持使用由多个供应商支持的标准化格式。如今，[SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)已不再在特定应用之外广泛使用，但其后裔包括[HTML](../glossary.html#term-HTML)和[XML](../glossary.html#term-XML)现在却非常普遍。
- en: 'A markup language is a structured way of adding annotations about the formatting
    of the document within the document itself. Example markup languages include [troff](https://en.wikipedia.org/wiki/Troff),
    which is used to write the Unix man pages or [Latex](https://en.wikipedia.org/wiki/Latex).
    HTML uses markers to annotate text and a document is composed of HTML elements.
    Each element is usually composed of three parts: a start tag that potentially
    includes some specific attributes, some text (often including other elements),
    and an end tag. A HTML tag is a keyword enclosed in angle brackets. The generic
    form of an HTML element is'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 标记语言是一种在文档内部添加关于文档格式化注释的结构化方式。示例标记语言包括 [troff](https://en.wikipedia.org/wiki/Troff)，它用于编写
    Unix man 页面或 [Latex](https://en.wikipedia.org/wiki/Latex)。HTML 使用标记来注释文本，一个文档由
    HTML 元素组成。每个元素通常由三部分组成：一个可能包含一些特定属性的起始标签，一些文本（通常包括其他元素），以及一个结束标签。HTML 标签是括号内的关键字。HTML
    元素的通用形式是
- en: '[PRE9]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: More complex HTML elements can also include optional attributes in the start
    tag
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的 HTML 元素也可以在起始标签中包含可选属性
- en: '[PRE10]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The HTML document shown in [Fig. 34](#fig-html-page) is composed of two parts:
    a header, delineated by the <head> and </head> markers, and a body (between the
    <body> and </body> markers). In the example below, the header only contains a
    title, but other types of information can be included in the header. The body
    contains an image, some text and a list with three hyperlinks. The image is included
    in the web page by indicating its URI between brackets inside the <img src=”…”>
    marker. It is important to note that the image can reside on any server. The client
    will automatically download it when rendering the web page. The <h1>…</h1> marker
    is used to specify the first level of headings. The <ul> marker indicates an unnumbered
    list while the <li> marker indicates a list item. The <a href=”URI”>text</a> indicates
    a hyperlink. The text will be underlined in the rendered web page and the client
    will fetch the specified URI when the user clicks on the link.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 34](#fig-html-page) 所示的 HTML 文档由两部分组成：一个由 <head> 和 </head> 标记界定的标题，以及一个位于
    <body> 和 </body> 标记之间的主体。在下面的示例中，标题只包含一个标题，但标题中可以包含其他类型的信息。主体包含一个图片、一些文本和一个包含三个超链接的列表。图片通过在
    <img src=”…”> 标记内的括号中指定其 URI 来包含在网页中。需要注意的是，图片可以存储在任何服务器上。当客户端渲染网页时，会自动下载它。<h1>…</h1>
    标记用于指定第一级标题。<ul> 标记表示无序列表，而 <li> 标记表示列表项。《<a href=”URI”>text</a>》表示超链接。在渲染的网页中，文本会被下划线，当用户点击链接时，客户端会获取指定的
    URI。
- en: '[![../_images/html-page.png](../Images/44780516838bc54a13c36a8fe2321d96.png)](../_images/html-page.png)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/html-page.png](../Images/44780516838bc54a13c36a8fe2321d96.png)](../_images/html-page.png)'
- en: Fig. 34 A simple HTML page[#](#id63 "Link to this image")
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 34 一个简单的 HTML 页面[#](#id63 "链接到这个图片")
- en: Over the years, various extensions to HTML have been proposed and implemented.
    These include the specification of style sheets that adjust the layout of the
    document and the possibility of adding or referencing javascript code. Additional
    details about the various extensions to HTML may be found in the [official specifications](http://www.w3.org/MarkUp/)
    maintained by [W3C](https://www.w3.org).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，已经提出了各种 HTML 扩展并得到了实施。这些包括指定样式表以调整文档布局以及添加或引用 JavaScript 代码的可能性。有关 HTML
    各类扩展的详细信息，可以在 [官方规范](http://www.w3.org/MarkUp/) 中找到，这些规范由 [W3C](https://www.w3.org)
    维护。
- en: The HyperText Transfer Protocol[#](#the-hypertext-transfer-protocol "Link to
    this heading")
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超文本传输协议[#](#the-hypertext-transfer-protocol "链接到这个标题")
- en: 'The third component of the world wide web is the HyperText Transfer Protocol
    (HTTP). HTTP is a text-based protocol like SMTP. The client sends a request and
    the server returns a response. HTTP runs above the bytestream service and HTTP
    servers listen by default on port 80. The design of HTTP has largely been inspired
    by the Internet email protocols. Each HTTP request contains three parts :'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的第三个组成部分是超文本传输协议 (HTTP)。HTTP 是一种基于文本的协议，类似于 SMTP。客户端发送请求，服务器返回响应。HTTP 在字节流服务之上运行，默认情况下
    HTTP 服务器监听端口 80。HTTP 的设计在很大程度上受到了互联网电子邮件协议的启发。每个 HTTP 请求包含三个部分：
- en: a method, that indicates the type of request, a URI, and the version of the
    HTTP protocol used by the client
  id: totrans-350
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法，指示请求的类型、URI 以及客户端使用的 HTTP 协议版本
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a header, that is used by the client to specify optional parameters for the
    request. An empty line is used to mark the end of the header
  id: totrans-353
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，客户端用它来指定请求的可选参数。一个空行用于标记标题的结束
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an optional MIME document attached to the request
  id: totrans-356
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到请求的可选MIME文档
- en: 'The response sent by the server also contains three parts :'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的响应还包含三个部分：
- en: a status line , that indicates whether the request was successful or not
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态行，表示请求是否成功
- en: ''
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a header, that contains additional information about the response. The response
    header ends with an empty line.
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，包含有关响应的附加信息。响应标题以空行结束。
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a MIME document
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIME文档
- en: Figure [Fig. 35](#fig-http-req-resp) provides sample HTTP request and response.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图[图35](#fig-http-req-resp)提供了示例HTTP请求和响应。
- en: '![Figure made with TikZ](../Images/64fd856539fab465e6b2fadde6a8bd15.png)'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/64fd856539fab465e6b2fadde6a8bd15.png)'
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 35 HTTP requests and responses
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图35 HTTP请求和响应
- en: 'Several types of method can be used in HTTP requests. The three most important
    ones are :'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在HTTP请求中使用多种类型的方法。最重要的三种是：
- en: 'the GET method is the most popular one. It is used to retrieve a document from
    a server. The GET method is encoded as GET followed by the path of the URI of
    the requested document and the version of HTTP used by the client. For example,
    to retrieve the [http://www.w3.org/MarkUp/](http://www.w3.org/MarkUp/) URI, a
    client must open a TCP connection on port 80 with host www.w3.org and send a HTTP
    request containing the following line:'
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET方法是最受欢迎的方法之一。它用于从服务器检索文档。GET方法编码为GET，后跟请求文档的URI路径和客户端使用的HTTP版本。例如，要检索[http://www.w3.org/MarkUp/](http://www.w3.org/MarkUp/)
    URI，客户端必须在端口80上与主机www.w3.org建立TCP连接，并发送包含以下行的HTTP请求：
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the HEAD method is a variant of the GET method that allows the retrieval of
    the header lines for a given URI without retrieving the entire document. It can
    be used by a client to verify if a document exists, for instance.
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: HEAD方法是GET方法的变体，允许检索给定URI的标题行，而不检索整个文档。它可以由客户端用于验证文档是否存在，例如。
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the POST method can be used by a client to send a document to a server. The
    document is attached to the HTTP request as a MIME document.
  id: totrans-379
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST方法可以由客户端用于向服务器发送文档。文档作为MIME文档附加到HTTP请求中。
- en: HTTP clients and servers can include different HTTP headers in HTTP requests
    and responses. Each HTTP header is encoded as a single ASCII-line terminated by
    CR and LF. Several of these headers are briefly described below. A detailed discussion
    of the standard headers may be found in [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html).
    The MIME headers can appear in both HTTP requests and HTTP responses.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端和服务器可以在HTTP请求和响应中包含不同的HTTP标题。每个HTTP标题都编码为单个ASCII行，以CR和LF结尾。以下简要描述了其中一些标题。有关标准标题的详细讨论，请参阅[**RFC
    1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)。MIME标题可以出现在HTTP请求和HTTP响应中。
- en: 'the Content-Length: header is the [MIME](../glossary.html#term-MIME) header
    that indicates the length of the MIME document in bytes.'
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容长度：标题是[MIME](../glossary.html#term-MIME)标题，表示MIME文档的字节长度。
- en: ''
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Content-Type: header is the [MIME](../glossary.html#term-MIME) header that
    indicates the type of the attached MIME document. HTML pages use the text/html
    type.'
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型：标题是[MIME](../glossary.html#term-MIME)标题，表示附加MIME文档的类型。HTML页面使用text/html类型。
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Content-Encoding: header indicates how the [MIME document](../glossary.html#term-MIME-document)
    has been encoded. For example, this header would be set to x-gzip for a document
    compressed using the [gzip](https://www.gzip.org) software.'
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容编码：标题表示[MIME文档](../glossary.html#term-MIME-document)的编码方式。例如，此标题将设置为x-gzip，用于使用[gzip](https://www.gzip.org)软件压缩的文档。
- en: '[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html) and [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) define headers that
    are specific to HTTP responses. These server headers include:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)和[**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)定义了特定于HTTP响应的标题。这些服务器标题包括：'
- en: 'the Server: header indicates the version of the web server that has generated
    the HTTP response. Some servers provide information about their software release
    and optional modules that they use. For security reasons, some system administrators
    disable these headers to avoid revealing too much information about their server
    to potential attackers.'
  id: totrans-389
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器：标题表示生成HTTP响应的Web服务器的版本。一些服务器提供有关它们的软件版本和它们使用的可选模块的信息。出于安全原因，一些系统管理员禁用这些标题，以避免向潜在的攻击者透露太多关于其服务器的信息。
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Date: header indicates when the HTTP response has been produced by the
    server.'
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期：标题表示服务器何时生成了HTTP响应。
- en: ''
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Last-Modified: header indicates the date and time of the last modification
    of the document attached to the HTTP response.'
  id: totrans-395
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Last-Modified: 头部指示附加到HTTP响应的文档的最后修改日期和时间。'
- en: 'Similarly, the following header lines can only appear inside HTTP requests
    sent by a client:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下头部行只能出现在客户端发送的HTTP请求中：
- en: 'the User-Agent: header provides information about the client that has generated
    the HTTP request. Some servers analyze this header line and return different headers
    and sometimes different documents for different user agents.'
  id: totrans-397
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'User-Agent: 头部提供了有关生成HTTP请求的客户端的信息。一些服务器分析这一行头部并针对不同的用户代理返回不同的头部和有时不同的文档。'
- en: ''
  id: totrans-398
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the If-Modified-Since: header is followed by a date. It enables clients to
    cache in memory or on disk recent or most frequently used documents. When a client
    needs to request a URI from a server, it first checks whether the document is
    already in its cache. If it is, the client sends an HTTP request with the If-Modified-Since:
    header indicating the date of the cached document. The server will only return
    the document attached to the HTTP response if it is newer than the version stored
    in the client’s cache.'
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'If-Modified-Since: 头部后面跟着一个日期。它使客户端能够将最近或最常使用的文档缓存到内存或磁盘上。当客户端需要从服务器请求一个URI时，它首先检查文档是否已经在其缓存中。如果是，客户端会发送一个包含If-Modified-Since:
    头部的HTTP请求，指示缓存文档的日期。如果服务器缓存中的版本较新，它将只返回附加到HTTP响应中的文档。'
- en: ''
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Referrer: header is followed by a URI. It indicates the URI of the document
    that the client visited before sending this HTTP request. Thanks to this header,
    the server can know the URI of the document containing the hyperlink followed
    by the client, if any. This information is very useful to measure the impact of
    advertisements containing hyperlinks placed on websites.'
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Referrer: 头部后面跟着一个URI。它指示客户端在发送此HTTP请求之前访问的文档的URI。多亏了这个头部，服务器可以知道客户端跟随的超链接所包含的文档的URI，如果有的话。这些信息对于衡量在网站上放置的广告的影响非常有用。'
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Host: header contains the fully qualified domain name of the URI being
    requested.'
  id: totrans-406
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Host: 头部包含正在请求的URI的完全限定域名。'
- en: Note
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The importance of the Host: header line'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'Host: 头部行的重要性'
- en: 'The first version of HTTP did not include the Host: header line. This was a
    severe limitation for web hosting companies. For example consider a web hosting
    company that wants to serve both web.example.com and www.example.net on the same
    physical server. Both web sites contain a /index.html document. When a client
    sends a request for either http://web.example.com/index.html or http://www.example.net/index.html,
    the HTTP 1.0 request contains the following line :'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP的第一个版本没有包括Host: 头部行。这对网络托管公司来说是一个严重的限制。例如，考虑一个想要在同一个物理服务器上为web.example.com和www.example.net提供服务的网络托管公司。这两个网站都包含一个/index.html文档。当客户端发送对http://web.example.com/index.html或http://www.example.net/index.html的请求时，HTTP
    1.0请求包含以下行：'
- en: '[PRE12]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By parsing this line, a server cannot determine which index.html file is requested.
    Thanks to the Host: header line, the server knows whether the request is for http://web.example.com/index.html
    or http://www.dummy.net/index.html. Without the Host: header, this is impossible.
    The Host: header line allowed web hosting companies to develop their business
    by supporting a large number of independent web servers on the same physical server.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '通过解析这一行，服务器无法确定请求的是哪个index.html文件。多亏了Host: 头部行，服务器知道请求的是http://web.example.com/index.html还是http://www.dummy.net/index.html。没有Host:
    头部，这是不可能的。Host: 头部行允许网络托管公司通过在同一个物理服务器上支持大量的独立Web服务器来发展他们的业务。'
- en: 'The status line of the HTTP response begins with the version of HTTP used by
    the server (usually HTTP/1.0 defined in [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)
    or HTTP/1.1 defined in [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html))
    followed by a three digit status code and additional information in English. HTTP
    status codes have a similar structure as the reply codes used by SMTP:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应的状态行以服务器使用的HTTP版本（通常是定义在[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)中的HTTP/1.0或定义在[**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)中的HTTP/1.1）开头，后面跟着一个三位状态码和附加的英文信息。HTTP状态码的结构与SMTP使用的回复码类似：
- en: All status codes starting with digit 2 indicate a valid response. 200 Ok indicates
    that the HTTP request was successfully processed by the server and that the response
    is valid.
  id: totrans-413
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字2开头的状态码表示有效的响应。200 Ok 表示服务器成功处理了HTTP请求，并且响应是有效的。
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All status codes starting with digit 3 indicate that the requested document
    is no longer available on the server. 301 Moved Permanently indicates that the
    requested document is no longer available on this server. A Location: header containing
    the new URI of the requested document is inserted in the HTTP response. 304 Not
    Modified is used in response to an HTTP request containing the If-Modified-Since:
    header. This status line is used by the server if the document stored on the server
    is not more recent than the date indicated in the If-Modified-Since: header.'
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '所有以数字3开头的状态码表示请求的文档在服务器上不再可用。301 永久移动表示请求的文档不再在此服务器上可用。在 HTTP 响应中插入一个包含请求文档新
    URI 的 Location: 标头。304 未修改用于响应包含 If-Modified-Since: 标头的 HTTP 请求。如果服务器上存储的文档的日期不晚于
    If-Modified-Since: 标头中指示的日期，则服务器使用此状态行。'
- en: ''
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All status codes starting with digit 4 indicate that the server has detected
    an error in the HTTP request sent by the client. 400 Bad Request indicates a syntax
    error in the HTTP request. 404 Not Found indicates that the requested document
    does not exist on the server.
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字4开头的状态码表示服务器检测到客户端发送的 HTTP 请求中存在错误。400 错误请求表示 HTTP 请求中存在语法错误。404 未找到表示请求的文档在服务器上不存在。
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All status codes starting with digit 5 indicate an error on the server. 500
    Internal Server Error indicates that the server could not process the request
    due to an error on the server itself.
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字5开头的状态码表示服务器上发生错误。500 内部服务器错误表示服务器由于自身错误无法处理请求。
- en: In both HTTP requests and responses, the MIME document refers to a representation
    of the document with the MIME headers indicating the type of document and its
    size.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求和响应中，MIME 文档指的是文档的表示，MIME 标头指示文档的类型和大小。
- en: 'As an illustration of HTTP/1.0, the transcript below shows a HTTP request for
    [http://www.ietf.org](http://www.ietf.org) and the corresponding HTTP response.
    The HTTP request was sent using the [curl](https://curl.haxx.se/) command line
    tool. The User-Agent: header line contains more information about this client
    software. There is no MIME document attached to this HTTP request, and it ends
    with a blank line.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '下面是 HTTP/1.0 的一个示例，显示了针对 [http://www.ietf.org](http://www.ietf.org) 的 HTTP
    请求及其相应的 HTTP 响应。HTTP 请求是通过 [curl](https://curl.haxx.se/) 命令行工具发送的。User-Agent:
    标头行包含有关此客户端软件的更多信息。此 HTTP 请求未附加 MIME 文档，并以一个空白行结束。'
- en: '[PRE13]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The HTTP response indicates the version of the server software used with the
    modules included. The Last-Modified: header indicates that the requested document
    was modified about one week before the request. A HTML document (not shown) is
    attached to the response. Note the blank line between the header of the HTTP response
    and the attached MIME document. The Server: header line has been truncated in
    this output.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP 响应指示所使用的服务器软件版本以及包含的模块。Last-Modified: 标头指示请求的文档在大约一周前被修改。响应中附加了一个 HTML
    文档（未显示）。注意 HTTP 响应标头和附加的 MIME 文档之间的空白行。在此输出中，Server: 标头行已被截断。'
- en: '[PRE14]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: HTTP was initially designed to share text documents. For this reason, and to
    ease the implementation of clients and servers, the designers of HTTP chose to
    open a TCP connection for each HTTP request. This implies that a client must open
    one TCP connection for each URI that it wants to retrieve from a server as illustrated
    on the figure below, showing HTTP 1.0 and the underlying TCP connection. For a
    web page containing only text documents this was a reasonable design choice as
    the client usually remains idle while the (human) user is reading the retrieved
    document.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 最初被设计用于共享文本文档。因此，为了简化客户端和服务器端的实现，HTTP 的设计者选择为每个 HTTP 请求打开一个 TCP 连接。这意味着客户端必须为它想要从服务器检索的每个
    URI 打开一个 TCP 连接，如图所示，显示了 HTTP 1.0 和其下层的 TCP 连接。对于一个只包含文本文档的网页来说，这是一个合理的设计选择，因为当（人类）用户阅读检索到的文档时，客户端通常处于空闲状态。
- en: '![msc {'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [标签="", 线条颜色=白色],
- en: a [label="", linecolour=white],
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: a [标签="", 线条颜色=白色],
- en: b [label="Client", linecolour=black],
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: b [标签="客户端", 线条颜色=黑色],
- en: z [label="", linecolour=white],
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: z [标签="", 线条颜色=白色],
- en: c [label="Server", linecolour=black],
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: c [标签="服务器", 线条颜色=黑色],
- en: d [label="", linecolour=white],
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: d [标签="", 线条颜色=白色],
- en: d1 [label="", linecolour=white];
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [标签="", 线条颜色=白色];
- en: a1=>b [ label = "CONNECT.request" ] ,
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [标签 = "CONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [标签 = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.indication" ];
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [标签 = "CONNECT.indication" ];
- en: d1=>c [ label = "CONNECT.response" ] ,
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [标签 = "CONNECT.response" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 标签 = "", 弧跳过="1" ];
- en: b=>a1 [ label = "CONNECT.confirm" ];
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "CONNECT.confirm" ];
- en: a1=>b [ label = "DATA.request(Request)", linecolour=red, textcolour=red],
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "DATA.request(Request)", 线颜色=红色, 文字颜色=红色],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 线颜色=红色, 弧跳过="1" ];
- en: c==d1 [ label = "DATA.indication(Request)", linecolour=red, textcolour=red];
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: c==d1 [ 标签 = "DATA.indication(Request)", 线颜色=红色, 文字颜色=红色];
- en: d1=>c [ label = "DATA.request(Response)", linecolour=blue, textcolour=blue]
    ,
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "DATA.request(Response)", 线颜色=蓝色, 文字颜色=蓝色] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 线颜色=蓝色, 弧跳过="1" ];
- en: b=>a1 [ label = "DATA.indication(Response)", linecolour=blue, textcolour=blue],
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "DATA.indication(Response)", 线颜色=蓝色, 文字颜色=蓝色],
- en: d1=>c [ label = "DISCONNECT.request"],
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "DISCONNECT.request" ];
- en: c>>b [ arcskip="1"];
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 弧跳过="1" ];
- en: b=>a1 [ label = "DISCONNECT.indication" ];
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "DISCONNECT.indication" ];
- en: a1=>b [ label = "DISCONNECT.request" ] ,
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "DISCONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 标签 = "", 弧跳过="1" ];
- en: c=>d1 [ label = "DISCONNECT.indication" ];
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "DISCONNECT.indication" ];
- en: '}](../Images/15f6359ba4c5a3cfe439a837a247edb5.png)<map id="d49bedba389123d38d35a1fef746a30e5445ef03"
    name="d49bedba389123d38d35a1fef746a30e5445ef03"></map>'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/15f6359ba4c5a3cfe439a837a247edb5.png)<map id="d49bedba389123d38d35a1fef746a30e5445ef03"
    name="d49bedba389123d38d35a1fef746a30e5445ef03"></map>'
- en: However, as the web evolved to support richer documents containing images, opening
    a TCP connection for each URI became a performance problem [[Mogul1995]](../bibliography.html#mogul1995).
    Indeed, besides its HTML part, a web page may include dozens of images or more.
    Forcing the client to open a TCP connection for each component of a web page has
    two important drawbacks. First, the client and the server must exchange packets
    to open and close a TCP connection as we will see later. This increases the network
    overhead and the total delay of completely retrieving all the components of a
    web page. Second, a large number of established TCP connections may be a performance
    bottleneck on servers.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着网络的发展以支持包含图像等更丰富的文档，为每个URI打开TCP连接成为了一个性能问题[[Mogul1995]](../bibliography.html#mogul1995)。实际上，除了其HTML部分外，一个网页可能包含数十个或更多的图像。强迫客户端为网页的每个组件打开TCP连接有两个重要的缺点。首先，客户端和服务器必须交换数据包以打开和关闭TCP连接，正如我们稍后将要看到的。这增加了网络开销和完全检索网页所有组件的总延迟。其次，大量建立的TCP连接可能在服务器上成为性能瓶颈。
- en: This problem was solved by extending HTTP to support persistent TCP connections
    [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html). A persistent
    connection is a TCP connection over which a client may send several HTTP requests.
    This is illustrated in the figure below showing the persistent connection of HTTP
    1.1.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题通过扩展HTTP以支持持久TCP连接[**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)得到解决。持久连接是一个客户端可能发送多个HTTP请求的TCP连接。这在下图中说明了HTTP
    1.1的持久连接。
- en: '![msc {'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [标签="", 线颜色=白色],
- en: a [label="", linecolour=white],
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: a [标签="", 线颜色=白色],
- en: b [label="Client", linecolour=black],
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: b [标签="客户端", 线颜色=黑色],
- en: z [label="", linecolour=white],
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: z [标签="", 线颜色=白色],
- en: c [label="Server", linecolour=black],
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: c [标签="服务器", 线颜色=黑色],
- en: d [label="", linecolour=white],
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: d [标签="", 线颜色=白色],
- en: d1 [label="", linecolour=white];
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [标签="", 线颜色=白色];
- en: a1=>b [ label = "CONNECT.request" ] ,
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "CONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 标签 = "", 弧跳过="1" ];
- en: c=>d1 [ label = "CONNECT.indication" ];
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "CONNECT.indication" ];
- en: d1=>c [ label = "CONNECT.response" ] ,
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "CONNECT.response" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 标签 = "", 弧跳过="1" ];
- en: b=>a1 [ label = "CONNECT.confirm" ];
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "CONNECT.confirm" ];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "", 线颜色=红色, 文字颜色=红色],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 线颜色=红色, 弧跳过="1" ];
- en: 'a1=>b [ label = "GET / HTTP1.1\nConnection: Keep-Alive\n...", linecolour=white,
    textcolour=red],'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ 标签 = "GET / HTTP1.1\nConnection: Keep-Alive\n...", 线颜色=白色, 文字颜色=红色],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "", 线颜色=红色, 文字颜色=红色];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "", 线颜色=蓝色, 文字颜色=蓝色] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 线颜色=蓝色, 弧跳过="1" ];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=100\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ 标签 = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=100\nConnection:
    Keep-Alive\n...", 线颜色=白色, 文字颜色=蓝色],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "", 线颜色=蓝色, 文字颜色=蓝色 ];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "", 线颜色=红色, 文字颜色=红色],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 线颜色=红色, 弧跳过="1" ];
- en: 'a1=>b [ label = "GET /images/logo.gif HTTP1.1\nConnection: Keep-Alive\n...",
    linecolour=white, textcolour=red],'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /images/logo.gif HTTP1.1\nConnection: Keep-Alive\n...",
    linecolour=white, textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=99\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=99\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: '|||;'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: d1=>c [ label = "DISCONNECT.request"],
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.request"];
- en: c>>b [ arcskip="1"];
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.indication" ];
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.indication" ];
- en: a1=>b [ label = "DISCONNECT.request" ] ,
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DISCONNECT.indication" ];
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.indication" ];
- en: '}](../Images/1dd234f6259caa842e7721e4f7b6857e.png)<map id="e3a7f46f483e3da6d68605217fa3410d14c6e31b"
    name="e3a7f46f483e3da6d68605217fa3410d14c6e31b"></map>'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/1dd234f6259caa842e7721e4f7b6857e.png)<map id="e3a7f46f483e3da6d68605217fa3410d14c6e31b"
    name="e3a7f46f483e3da6d68605217fa3410d14c6e31b"></map>'
- en: 'To allow the clients and servers to control the utilization of these persistent
    TCP connections, HTTP 1.1 [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)
    defines several new HTTP headers:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许客户端和服务器控制这些持久TCP连接的利用率，HTTP 1.1 [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)
    定义了几个新的HTTP头部：
- en: 'The Connection: header is used with the Keep-Alive argument by the client to
    indicate that it expects the underlying TCP connection to be persistent. When
    this header is used with the Close argument, it indicates that the entity that
    sent it will close the underlying TCP connection at the end of the HTTP response.'
  id: totrans-497
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Connection: 头部与Keep-Alive参数一起由客户端使用，以指示它期望底层TCP连接是持久的。当此头部与Close参数一起使用时，它表示发送此头部的实体将在HTTP响应结束时关闭底层TCP连接。'
- en: ''
  id: totrans-498
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-499
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Keep-Alive: header is used by the server to inform the client about how
    it agrees to use the persistent connection. A typical Keep-Alive: contains two
    parameters: the maximum number of requests that the server agrees to serve on
    the underlying TCP connection and the timeout (in seconds) after which the server
    will close an idle connection'
  id: totrans-500
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Keep-Alive: 头部由服务器用于通知客户端它如何同意使用持久连接。一个典型的Keep-Alive: 包含两个参数：服务器同意在底层TCP连接上服务的最大请求数量以及服务器将在多少秒后关闭一个空闲连接的超时时间'
- en: 'The example below shows the operation of HTTP/1.1 over a persistent TCP connection
    to retrieve three URIs stored on the same server. Once the connection has been
    established, the client sends its first request with the Connection: Keep-Alive
    header to request a persistent connection.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的示例显示了HTTP/1.1在持久TCP连接上操作以检索同一服务器上存储的三个URI。一旦建立连接，客户端就发送带有Connection: Keep-Alive头部的第一个请求，以请求持久连接。'
- en: '[PRE15]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The server replies with the Connection: Keep-Alive header and indicates that
    it accepts a maximum of 100 HTTP requests over this connection and that it will
    close the connection if it remains idle for 15 seconds.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '服务器回复带有Connection: Keep-Alive头部的响应，并指示它接受通过此连接的最大100个HTTP请求，并且如果连接空闲15秒，它将关闭连接。'
- en: '[PRE16]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The client sends a second request for the style sheet of the retrieved web page.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送第二个请求以获取检索到的网页的样式表。
- en: '[PRE17]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The server replies with the requested style sheet and maintains the persistent
    connection. Note that the server only accepts 99 remaining HTTP requests over
    this persistent connection.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器回复请求的样式表并保持持久连接。请注意，服务器只接受通过此持久连接的99个剩余HTTP请求。
- en: '[PRE18]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then the client requested the web server’s icon [[18]](#ffavicon). This server
    does not contain such an icon and thus replies with a 404 HTTP status. However,
    the underlying TCP connection is not closed immediately.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 然后客户端请求网页服务器的图标 [[18]](#ffavicon)。此服务器不包含此类图标，因此回复404 HTTP状态。然而，底层TCP连接不会立即关闭。
- en: '[PRE19]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As illustrated above, a client can send several HTTP requests over the same
    persistent TCP connection. However, it is important to note that all of these
    HTTP requests are considered to be independent by the server. Each HTTP request
    must be self-contained. This implies that each request must include all the header
    lines that are required by the server to understand the request. The independence
    of these requests is one of the key design choices of HTTP. As a consequence of
    this design choice, when a server processes a HTTP request, it does not use any
    other information than what is contained in the request itself. This explains
    why the client adds its User-Agent: header in all of the HTTP requests that it
    sends over the persistent TCP connection.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，客户端可以在同一个持久的TCP连接上发送多个HTTP请求。然而，需要注意的是，服务器将这些HTTP请求视为相互独立的。每个HTTP请求都必须是自包含的。这意味着每个请求必须包含服务器理解请求所需的所有头部行。这些请求的独立性是HTTP的关键设计选择之一。由于这个设计选择，当服务器处理一个HTTP请求时，它不会使用请求本身之外的其他任何信息。这也解释了为什么客户端会在它通过持久TCP连接发送的所有HTTP请求中添加其User-Agent:头部。
- en: However, in practice, some servers want to provide content tuned for each user.
    For example, some servers can provide information in several languages. Other
    servers want to provide advertisements that are targeted to different types of
    users. To do this, servers need to maintain some information about the preferences
    of each user and use this information to produce content matching the user’s preferences.
    HTTP contains several mechanisms to solve this problem. We discuss three of them
    below.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，一些服务器希望为每个用户提供定制的服务内容。例如，一些服务器可以提供多种语言的信息。其他服务器希望提供针对不同类型用户的定向广告。为了做到这一点，服务器需要维护有关每个用户偏好的某些信息，并使用这些信息来生成符合用户偏好的内容。HTTP包含几个机制来解决此问题。我们下面讨论其中三个。
- en: A first solution is to force the users to be authenticated. This was the solution
    used by FTP to control the files that each user could access. Initially, user
    names and passwords could be included inside URIs [**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html).
    However, placing passwords in the clear in a potentially publicly visible URI
    is completely insecure and this usage has now been deprecated [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html).
    HTTP supports several extension headers [**RFC 2617**](https://datatracker.ietf.org/doc/html/rfc2617.html)
    that can be used by a server to request the authentication of the client by providing
    his/her credentials. However, user names and passwords have not been popular on
    web servers as they force human users to remember one user name and one password
    per server. Remembering a password is acceptable when a user needs to access protected
    content, but users will not accept to remember a unique user name and password
    for each web sites that they visit.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案是强制用户进行身份验证。这是FTP用来控制每个用户可以访问的文件所采用的解决方案。最初，用户名和密码可以包含在URI中[**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html)。然而，将密码明文放在可能公开可见的URI中是完全不安全的，并且这种用法现在已经过时[**RFC
    3986**](https://datatracker.ietf.org/doc/html/rfc3986.html)。HTTP支持几个扩展头部[**RFC
    2617**](https://datatracker.ietf.org/doc/html/rfc2617.html)，服务器可以通过提供其凭据来请求客户端进行身份验证。然而，用户名和密码在Web服务器上并不受欢迎，因为它们强迫人类用户为每个服务器记住一个用户名和一个密码。当用户需要访问受保护的内容时，记住密码是可以接受的，但用户不会接受为每个访问的网站记住一个唯一的用户名和密码。
- en: 'A second solution to allow servers to tune that content to the needs and capabilities
    of the user is to rely on the different types of Accept-* HTTP headers. For example,
    the Accept-Language: header can be used by the client to indicate its preferred
    languages. Unfortunately, in practice this header is usually set based on the
    default language of the browser and it is difficult for a user to indicate the
    language it prefers by selecting options for each visited web server.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 允许服务器根据用户的需求和能力调整内容的第二个解决方案是依赖于不同类型的Accept-* HTTP头部。例如，Accept-Language:头部可以被客户端用来表示其首选的语言。不幸的是，在实践中，这个头部通常基于浏览器的默认语言来设置，用户很难通过为每个访问的Web服务器选择选项来表示其偏好的语言。
- en: 'The third and widely adopted solution are HTTP cookies. HTTP cookies were initially
    developed as a private extension by [Netscape](https://en.wikipedia.org/wiki/Netscape).
    They are now part of the standard [**RFC 6265**](https://datatracker.ietf.org/doc/html/rfc6265.html).
    In a nutshell, a cookie is a short string that is chosen by a server to represent
    a given client. Two HTTP headers are used : Cookie: and Set-Cookie:. When a server
    receives an HTTP request from a new client (i.e. an HTTP request that does not
    contain the Cookie: header), it generates a cookie for the client and includes
    it in the Set-Cookie: header of the returned HTTP response. The Set-Cookie: header
    contains several additional parameters including the domain names for which the
    cookie is valid. The client stores all received cookies on disk and every time
    it sends an HTTP request, it verifies whether it already knows a cookie for this
    domain. If so, it attaches the Cookie: header to the HTTP request. This is illustrated
    in the figure below with HTTP 1.1, but cookies also work with HTTP 1.0.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '第三种广泛采用的方法是HTTP cookie。HTTP cookie最初是由[Netscape](https://en.wikipedia.org/wiki/Netscape)作为一个私有扩展开发的。现在它是标准[**RFC
    6265**](https://datatracker.ietf.org/doc/html/rfc6265.html)的一部分。简而言之，cookie是一个由服务器选择的短字符串，用来代表一个特定的客户端。使用了两个HTTP头：Cookie:
    和 Set-Cookie:。当服务器收到一个来自新客户端的HTTP请求（即不包含Cookie:头的HTTP请求）时，它会为该客户端生成一个cookie，并将其包含在返回的HTTP响应的Set-Cookie:头中。Set-Cookie:头包含多个附加参数，包括cookie有效的域名。客户端将所有接收到的cookie存储在磁盘上，每次它发送HTTP请求时，它都会验证是否已经知道该域名的cookie。如果是这样，它会在HTTP请求中附加Cookie:头。这如图所示，使用HTTP
    1.1，但cookie也适用于HTTP 1.0。'
- en: '![msc {'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client", linecolour=black],
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="客户端", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: a1=>b [ label = "GET / HTTP1.1\n...", linecolour=white, textcolour=red],
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "GET / HTTP1.1\n...", linecolour=white, textcolour=red],
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nSet-Cookie: machin\n...", linecolour=white,
    textcolour=blue],'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ label = "HTTP/1.1 200 OK\nSet-Cookie: machin\n...", linecolour=white,
    textcolour=blue],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "Browser saves cookie", linecolour=white],
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "浏览器保存cookie", linecolour=white],
- en: c=>d1 [ label = "Normal response", linecolour=white];
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "正常响应", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /doc HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /doc HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: c=>d1 [ label = "Response is function\nof URL and cookie", linecolour=white];
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "响应是URL和cookie的函数", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /images/t.gif HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /images/t.gif HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "Browser sends cookie in\nall requests sent to server", linecolour=white];
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "浏览器在发送到服务器的所有请求中发送cookie", linecolour=white];
- en: '}](../Images/46342147d4ef4a386569e9a3c497ba69.png)<map id="577adf721a7a6a7a5af9beec3659eccef6881630"
    name="577adf721a7a6a7a5af9beec3659eccef6881630"></map>'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/46342147d4ef4a386569e9a3c497ba69.png)<map id="577adf721a7a6a7a5af9beec3659eccef6881630"
    name="577adf721a7a6a7a5af9beec3659eccef6881630"></map>'
- en: Note
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Privacy issues with HTTP cookies
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 饼干带来的隐私问题
- en: The HTTP cookies introduced by [Netscape](https://en.wikipedia.org/wiki/Netscape)
    are key for large e-commerce websites. However, they have also raised many discussions
    concerning their [potential misuses](http://www.nytimes.com/2001/09/04/technology/04COOK.html).
    Consider ad.com, a company that delivers lots of advertisements on web sites.
    A web site that wishes to include ad.com’s advertisements next to its content
    will add links to ad.com inside its HTML pages. If ad.com is used by many web
    sites, ad.com could be able to track the interests of all the users that visit
    its client websites and use this information to provide targeted advertisements.
    Privacy advocates have even [sued](http://epic.org/privacy/internet/cookies/)
    online advertisement companies to force them to comply with the privacy regulations.
    More recent related technologies also raise [privacy concerns](http://www.eff.org/deeplinks/2009/09/new-cookie-technologies-harder-see-and-remove-wide).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape [Netscape](https://en.wikipedia.org/wiki/Netscape) 引入的 HTTP 饼干对于大型电子商务网站至关重要。然而，它们也引发了关于其[潜在滥用](http://www.nytimes.com/2001/09/04/technology/04COOK.html)的许多讨论。考虑
    ad.com，这是一家在网站上投放大量广告的公司。一个希望在其内容旁边包含 ad.com 广告的网站将在其 HTML 页面中添加指向 ad.com 的链接。如果许多网站使用
    ad.com，ad.com 可能能够跟踪访问其客户网站的用户的兴趣，并利用这些信息提供定向广告。隐私倡导者甚至[起诉](http://epic.org/privacy/internet/cookies/)在线广告公司，迫使他们遵守隐私法规。最近的相关技术也引发了[隐私担忧](http://www.eff.org/deeplinks/2009/09/new-cookie-technologies-harder-see-and-remove-wide)。
- en: '### HTTP version 2.0[#](#http-version-2-0 "Link to this heading")'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '### HTTP 版本 2.0[#](#http-version-2-0 "链接到这个标题")'
- en: During the last decade, a growing number of services have been supported by
    world wide web servers. The web protocols are not only used to deliver static
    documents, they are also used to deliver streaming music or video. They also enable
    clients to use interactive applications including games or productivity applications.
    These services and applications have more stringent performance requirements than
    the delivery of static documents. Many researchers and companies have proposed
    solutions to improve the performance of web services and protocols during the
    last decade [[KR2001]](../bibliography.html#kr2001) [[WBK2014]](../bibliography.html#wbk2014).
    We discuss a subset of them in this section.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，越来越多的服务由万维网服务器支持。Web 协议不仅用于传输静态文档，还用于传输流媒体音乐或视频。它们还使客户端能够使用交互式应用程序，包括游戏或生产力应用程序。这些服务和应用程序的性能要求比静态文档的传输更为严格。在过去十年中，许多研究人员和公司提出了提高
    Web 服务和协议性能的解决方案 [[KR2001]](../bibliography.html#kr2001) [[WBK2014]](../bibliography.html#wbk2014)。在本节中，我们讨论了其中的一部分。
- en: 'A first way to improve the performance of the web protocols is to tune the
    servers that provide content. In the early days, documents were stored on a single
    server. Clients established TCP connections to this server to retrieve each document.
    This architecture evolved in several directions. A first way to speedup web services
    is to avoid unnecessary transmissions. Thanks to the HEAD method and the If-Modified-Since:
    header, web browsers can verify that they have the most recent version of a document
    in their cache.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '提高 Web 协议性能的第一种方法是调整提供内容的服务器。在早期，文档存储在单个服务器上。客户端通过建立 TCP 连接到该服务器以检索每个文档。这种架构演变出几个方向。加快
    Web 服务的一种方法是避免不必要的传输。多亏了 HEAD 方法以及 If-Modified-Since: 头部，Web 浏览器可以验证它们是否拥有缓存中最新版本的文档。'
- en: '![Figure made with TikZ](../Images/e9483f4f858b0589cf3d76890882a4d6.png)'
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/e9483f4f858b0589cf3d76890882a4d6.png)'
- en: ''
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 36 Proxies relay client requests to servers and return the received responses
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 36 代理将客户端请求转发到服务器，并返回接收到的响应
- en: Caches can also be used inside the network. To understand their benefits, let
    us consider an SME with a dozen of employees that are connected to the Internet
    through a low-speed link. These employees often access similar web sites. Consider
    that Alice and Bob want to browse today’s local newspaper. Their browsers will
    both retrieve the newspaper’s website through the low bandwidth link and store
    the main documents in their cache. Unfortunately, the same information passes
    twice over the low-speed link. Some companies have deployed web proxies to cope
    with this problem. A web proxy is a server that resides in the enterprise network.
    All the employee’s browsers are configured to send their HTTP requests to this
    proxy. When such a proxy receives a request, it checks whether the content is
    already stored inside its own cache. If so, it returns it directly. Otherwise,
    the request is sent to the remote server and the information is stored in the
    proxy cache. By reducing the number of web objects that are exchanged over low-speed
    links, such proxies can significantly improve performance. Some companies also
    use them to control the websites that are contacted by their employees and sometimes
    block illegitimate accesses.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存也可以在网络内部使用。为了了解它们的益处，让我们考虑一个有十几名员工的小型企业，这些员工通过低速链路连接到互联网。这些员工经常访问类似的网站。考虑Alice和Bob想浏览今天的当地报纸。他们的浏览器将通过低带宽链路检索报纸的网站并将主要文档存储在他们的缓存中。不幸的是，相同的信息在低速链路上通过了两次。一些公司已经部署了Web代理来解决这个问题。Web代理是一个位于企业网络中的服务器。所有员工的浏览器都被配置为将他们的HTTP请求发送到这个代理。当这样的代理收到请求时，它会检查内容是否已经存储在其自己的缓存中。如果是这样，它就直接返回。否则，请求被发送到远程服务器，信息被存储在代理缓存中。通过减少在低速链路上交换的Web对象数量，这样的代理可以显著提高性能。一些公司还使用它们来控制员工接触的网站，有时还会阻止非法访问。
- en: Proxies can also be located in front of servers. In this case, they are called
    reverse-proxies. Consider a dynamic web server that produces web pages by assembling
    information stored in different databases. When this server receives a request,
    it must send multiple queries to its databases and then create the HTML document.
    These queries and the creation of the HTML document take time and this limits
    the number of requests that our server can sustain. Many content providers would
    place a reverse proxy in front of such a server. The DNS servers are configured
    to point to the reverse proxy. Upon reception of a request, the reverse proxy
    first checks whether the response is already stored in its cache. If so, it can
    return it to the client without interacting with the official server. Otherwise,
    the reverse proxy contacts the server and then returns the response to the client.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也可以位于服务器之前。在这种情况下，它们被称为反向代理。考虑一个动态的Web服务器，它通过组装存储在不同数据库中的信息来生成网页。当这个服务器收到一个请求时，它必须向其数据库发送多个查询，然后创建HTML文档。这些查询和创建HTML文档需要时间，这限制了我们的服务器可以支持的请求数量。许多内容提供商会在这样的服务器前面放置一个反向代理。DNS服务器被配置为指向反向代理。在接收到请求后，反向代理首先检查响应是否已经存储在其缓存中。如果是这样，它可以将其返回给客户端，而不与官方服务器交互。否则，反向代理会联系服务器，然后将响应返回给客户端。
- en: These reverse proxies can also be used to spread the load among different servers.
    In the above example, consider that a server needs 10 milliseconds to process
    each request and that it must handle them sequentially. Such a server cannot support
    more than 100 requests per second. If the service becomes popular, then the content
    provider will need to deploy several servers. These servers could serve the same
    reverse proxy.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反向代理也可以用来在不同服务器之间分配负载。在上面的例子中，考虑一个服务器需要10毫秒来处理每个请求，并且必须按顺序处理它们。这样的服务器不能支持每秒超过100个请求。如果服务变得流行，那么内容提供商将需要部署多个服务器。这些服务器可以服务于同一个反向代理。
- en: Note
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Serving content from multiple servers
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 从多个服务器提供内容
- en: When a web user interacts with www.service.net, she expects that all the information
    comes from the www.service.net server. If the service is popular, there are probably
    tens, hundreds, thousands or more physical servers that support this service.
    Still, the user has the illusion that she is interacting with a single server.
    Several techniques have been deployed by content providers to scale web services.
    Consider a simple service that serves text documents from N different servers.
    There are different ways to architect such a service.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络用户与www.service.net互动时，她期望所有信息都来自www.service.net服务器。如果该服务很受欢迎，可能存在数十、数百、数千甚至更多的物理服务器支持此服务。尽管如此，用户仍然有一种错觉，认为她正在与单个服务器互动。内容提供商已经部署了多种技术来扩展网络服务。考虑一个简单的服务，该服务从N个不同的服务器中提供文本文档。构建此类服务有几种不同的方式。
- en: A first approach is to store all files on each physical server and rely on the
    DNS to distribute the load among them. Each physical server has its own IP address
    and when the DNS server receives a query for www.service.net, it returns the IP
    address of one of them. Some DNS servers use Round-Robin to return one of these
    IP addresses. Others measure the load of the physical servers and return the address
    of the less loaded one. Another possibility is to locate the physical servers
    in different regions and configure the DNS server to return the IP address of
    the server that is geographically closer to the client’s IP address.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将在每个物理服务器上存储所有文件，并依赖DNS在它们之间分配负载。每个物理服务器都有自己的IP地址，当DNS服务器收到对www.service.net的查询时，它会返回它们的IP地址之一。一些DNS服务器使用轮询（Round-Robin）来返回这些IP地址中的一个。其他DNS服务器会测量物理服务器的负载，并返回负载较轻的那个地址。另一种可能性是将物理服务器放置在不同的地区，并配置DNS服务器以返回地理位置上更靠近客户端IP地址的服务器。
- en: A second approach is to rely on k reverse proxies and N-k servers. The servers
    store the content and the proxies cache the most frequently used files. The proxies
    can be geographically close to the clients while the servers can reside in the
    datacenters of the content provider. The DNS server can also distribute the load
    among the different proxies or return the geographically closest proxy. An important
    point to note about reverse proxies is that they receive HTTP requests from clients
    and send HTTP requests to the original servers that host the content. Several
    companies, usually called Content Distribution Networks, have deployed such reverse
    proxies throughout the world to cache web content next to the end-users. A good
    description of such a CDN may be found in [[NSS2010]](../bibliography.html#nss2010).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是依赖k个反向代理和N-k个服务器。服务器存储内容，而代理缓存最常用的文件。代理可以地理位置上靠近客户端，而服务器可以位于内容提供商的数据中心。DNS服务器还可以在不同代理之间分配负载，或者返回地理位置上最近的代理。关于反向代理的一个重要观点是，它们从客户端接收HTTP请求，并将HTTP请求发送到托管内容的原始服务器。一些公司，通常被称为内容分发网络，已经在全球范围内部署了这样的反向代理，以在终端用户附近缓存网页内容。在[[NSS2010]](../bibliography.html#nss2010)中可以找到对这种CDN的良好描述。
- en: A second way to improve the web performance is to reduce the time required to
    retrieve web objects. While the first web servers returned an HTML documents with
    possibly a few images, today’s rich web servers return one HTML document with
    associated style sheets, javascript code, images, fonts, … Some of these web objects
    come from the original server while others are hosted on different servers. Today,
    a typical web page contains almost 2 MBytes of data on average. The size of the
    web pages continues to grow according to statistics collected by httparchive.org
    as shown in [Fig. 37](#fig-httparchive). Web pages targeted to mobile devices
    are slightly smaller.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 提高网页性能的第二种方法是减少检索网页对象所需的时间。虽然最初的网页服务器返回的是包含可能一些图片的HTML文档，但今天的丰富网页服务器返回的是一个包含相关样式表、JavaScript代码、图片、字体等的HTML文档。其中一些网页对象来自原始服务器，而其他则托管在不同的服务器上。如今，一个典型的网页平均包含大约2
    MBytes的数据。根据httparchive.org收集的统计数据，网页的大小持续增长，如图37所示。针对移动设备的网页略小一些。
- en: '[![../_images/httparchive-bytes.png](../Images/e512429b911bc1ff17df73d156e86ce1.png)](../_images/httparchive-bytes.png)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/httparchive-bytes.png](../Images/e512429b911bc1ff17df73d156e86ce1.png)(../_images/httparchive-bytes.png)'
- en: 'Fig. 37 Evolution of the size of the web pages (source: [https://httparchive.org/reports/page-weight](https://httparchive.org/reports/page-weight))[#](#id66
    "Link to this image")'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图37 网页大小的演变（来源：[https://httparchive.org/reports/page-weight](https://httparchive.org/reports/page-weight))[#](#id66
    "链接到这张图片")
- en: A closer look at the average web page shows that it contains, on average, 27
    KBytes of HTML, 120 KBytes of fonts, 60 KBytes of CSS information, almost 1 MBytes
    of images and more than 400 KBytes of javascript. Each of these web page requires
    about 70 different HTTP requests. In other words, a browser needs to send on average
    70 requests to retrieve a complete web page.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察平均网页，我们发现它平均包含27 KBytes的HTML，120 KBytes的字体，60 KBytes的CSS信息，几乎1 MBytes的图像和超过400
    KBytes的javascript。每个网页都需要大约70个不同的HTTP请求。换句话说，浏览器需要平均发送70个请求来检索一个完整的网页。
- en: Two directions have been explored to improve the delivery of these web pages.
    The first direction is to tune the HTTP protocol. The second approach is to change
    the entire network stack. This approach is discussed in the QUIC chapter.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这些网页的传输，已经探索了两个方向。第一个方向是调整HTTP协议。第二个方法是改变整个网络栈。这种方法在QUIC章节中讨论。
- en: One of the limitations of HTTP from a performance viewpoint is that the requests
    that are sent by a browser must be sequential. Typically, a browser requests the
    HTML page. Once the page has been retrieved, the browser parses it to identify
    all the objects that it references and requests them one after each other. The
    web page can only be displayed to the user once all the required web objects have
    been retrieved. This implies that the browser must wait until the reception of
    each response before sending the next request. Another possibility is to allow
    the browser to send multiple requests without waiting for their corresponding
    responses. This approach is called pipelining in [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，HTTP的一个局限性是浏览器发送的请求必须是顺序的。通常，浏览器请求HTML页面。一旦页面被检索，浏览器会解析它以识别所有引用的对象，并依次请求它们。只有当所有必需的网页对象都被检索后，网页才能显示给用户。这意味着浏览器必须在接收每个响应之前等待发送下一个请求。另一种可能性是允许浏览器在不等待相应响应的情况下发送多个请求。这种方法在[**RFC
    7230**](https://datatracker.ietf.org/doc/html/rfc7230.html)中被称为流水线。
- en: To understand the benefits of pipelining, let us consider a simple but illustrative
    example. A client needs to retrieve 5 web objects that are each 100 bytes. The
    underlying transport connection has a 1 Gbps bandwidth but a one-way delay of
    100 msec. A normal HTTP/1.x client would send the first request, wait 200 msec
    to receive the answer, then send another request… It would need one entire second
    to retrieve the five web objects. This is illustrated in [Fig. 38](#fig-http-nopipelining).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解流水线的优势，让我们考虑一个简单但具有说明性的例子。一个客户端需要检索5个各为100字节的网页对象。底层传输连接具有1 Gbps的带宽，但单向延迟为100毫秒。一个普通的HTTP/1.x客户端会发送第一个请求，等待200毫秒以接收答案，然后发送另一个请求……它需要整整一秒来检索五个网页对象。这如图[图38](#fig-http-nopipelining)所示。
- en: '![Figure made with TikZ](../Images/902ce8ac285bbf69a2f6e825e8e51419.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/902ce8ac285bbf69a2f6e825e8e51419.png)'
- en: Fig. 38 A sequence of HTTP requests to a given server
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 图38 向给定服务器发送的HTTP请求序列
- en: With pipelining, the client sends the five requests immediately and receives
    the five responses after 200 msec. [Fig. 39](#fig-http-pipelining) illustrates
    the benefits of pipelining.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流水线，客户端立即发送五个请求，并在200毫秒后收到五个响应。[图39](#fig-http-pipelining)说明了流水线的优势。
- en: '![Figure made with TikZ](../Images/d0394b043492534d50c59a67578ea778.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/d0394b043492534d50c59a67578ea778.png)'
- en: Fig. 39 A sequence of HTTP requests to a server with pipelining
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 图39 使用流水线向服务器发送的HTTP请求序列
- en: However, as explained in [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html),
    there is one important limitation to pipelining. It can only be used to serve
    HTTP requests that are idempotent, i.e. none of the requests must depend on any
    of the previous requests in the pipeline. It turned out that it was difficult
    for web browsers to correctly support this requirement and very few of them have
    implemented pipelining [[19]](#fpipelining).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如[**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html)中解释的那样，流水线有一个重要的限制。它只能用于服务幂等的HTTP请求，即管道中的任何请求都不能依赖于之前的任何请求。结果发现，对于网络浏览器来说，正确支持这一要求很困难，而且其中很少实现了流水线[[19]](#fpipelining)。
- en: Another limitation of HTTP/1.1 is that all commands and parameters are encoded
    as ASCII strings. Using ASCII strings makes it easy to write simple clients or
    debug problems by observing packets. Unfortunately, the burden is placed on servers
    that need to include complex parsers that accept a wide range of partially compliant
    implementations. Furthermore, the flexibility of the ASCII encoding has enabled
    some classes of security attacks on servers [[CWE444]](../bibliography.html#cwe444).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1的另一个限制是所有命令和参数都编码为ASCII字符串。使用ASCII字符串使得编写简单的客户端或通过观察数据包来调试问题变得容易。不幸的是，这种负担落在了需要包含复杂解析器以接受广泛部分兼容实现的服务器上。此外，ASCII编码的灵活性也使得一些针对服务器的安全攻击成为可能
    [[CWE444]](../bibliography.html#cwe444)。
- en: To cope with these two problems, the IETF HTTP working group developed version
    2.0 of HTTP. HTTP/2.0 diverges from HTTP/1.1 in two important ways. First, HTTP/2.0
    relies on binary encoding which is both more compact and easier to parse. Second,
    HTTP/2.0 supports multiple streams, which makes it possible to simultaneously
    transfer different web objects over a single transport connection. Furthermore,
    HTTP/2.0 also compresses the HTTP headers to reduce the amount of data transferred.
    This technique is described in [**RFC 7541**](https://datatracker.ietf.org/doc/html/rfc7541.html)
    but is not discussed in this chapter.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这两个问题，IETF HTTP工作组开发了HTTP的2.0版本。HTTP/2.0在两个重要方面与HTTP/1.1不同。首先，HTTP/2.0依赖于二进制编码，这种编码既更紧凑又更容易解析。其次，HTTP/2.0支持多个流，这使得在单个传输连接上同时传输不同的Web对象成为可能。此外，HTTP/2.0还压缩HTTP头部以减少传输的数据量。这种技术描述在[**RFC
    7541**](https://datatracker.ietf.org/doc/html/rfc7541.html)中，但本章没有讨论。
- en: Let us first examine how HTTP/2.0 structures the bytestream of the underlying
    connection.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看HTTP/2.0是如何结构化底层连接的字节流的。
- en: '[![../_images/http2-frame.svg](../Images/70ec7c103b170dfdecf10fd670dc9b85.png)](../_images/http2-frame.svg)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/http2-frame.svg](../Images/70ec7c103b170dfdecf10fd670dc9b85.png)'
- en: Fig. 40 The HTTP/2.0 Frame header[#](#id69 "Link to this image")
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 图40 HTTP/2.0帧头[#](#id69 "链接到这张图片")
- en: The information exchanged over an HTTP/2.0 session is composed of frames. A
    frame starts with a 9 bytes-long header that carries several types of information
    as shown in [Fig. 40](#fig-http2-frame). The HTTP/2.0 frames have a variable length.
    The Length field of the header contains the length of the frame payload in bytes.
    As this field is encoded as a 24 bits field, an HTTP/2.0 frame cannot be longer
    than \(2^{24} -1\) bytes. It should be noted that [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    assumes a maximum size of \(2^{14}\) bytes, i.e. 16,384 bytes for the HTTP/2.0
    frame payload unless a longer maximum frame length has been negotiated at the
    beginning of the session using the HTTP/2.0 Settings frame that will be described
    later. The next field of the frames header indicates the frame type. The first
    frame types are Data which contains data from web objects and Headers containing
    HTTP/2.0 headers. When a client retrieves a web object from a server, it always
    receives an HTTP/2.0 Headers frame followed by an HTTP/2.0 Data frame. The Headers
    frame information contains essentially the same HTTP headers as the ones supported
    by HTTP/1.1, but those are encoded by leveraging a data compression technique
    that minimizes the number of bytes required to transmit them.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP/2.0会话中交换的信息由帧组成。一个帧以一个9字节长的头部开始，它携带了多种类型的信息，如图40所示。[图40](#fig-http2-frame)。HTTP/2.0的帧长度是可变的。头部中的长度字段包含帧有效载荷的长度（以字节为单位）。由于该字段编码为24位字段，HTTP/2.0的帧长度不能超过\(2^{24}
    -1\)字节。需要注意的是，[**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)假设HTTP/2.0帧有效载荷的最大大小为\(2^{14}\)字节，即16,384字节，除非在会话开始时通过HTTP/2.0设置帧协商了一个更长的最大帧长度，该设置帧将在后面描述。帧头部的下一个字段指示帧类型。最初的帧类型是数据帧，它包含来自Web对象的数据，以及包含HTTP/2.0头部的头部帧。当客户端从服务器检索Web对象时，它总是接收到一个HTTP/2.0头部帧，然后是一个HTTP/2.0数据帧。头部帧信息基本上与HTTP/1.1支持的HTTP头部相同，但它们通过利用数据压缩技术进行编码，以最小化传输这些头部所需的字节数。
- en: Other frame types are described later. The Flags are used for some frame types
    and the R bit must be set to zero. The last important field of the HTTP/2.0 Frame
    header is the Stream Identifier. With HTTP/2.0, the bytestream of the underlying
    transport connection is divided in independent streams that are identified by
    an integer. The odd (resp. even) stream identifiers are managed by the client
    (resp. server). This enables the server (or the client) to multiplex data corresponding
    to different frames over a single bytestream.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 其他帧类型将在后面描述。标志用于某些帧类型，R位必须设置为0。HTTP/2.0帧头中最后一个重要的字段是流标识符。在HTTP/2.0中，底层传输连接的字节流被划分为独立的流，这些流由一个整数标识。奇数（或偶数）流标识符由客户端（或服务器）管理。这使得服务器（或客户端）能够在一个字节流上多路复用对应不同帧的数据。
- en: This multiplexing capability is probably the most important feature of HTTP/2.0
    from a performance viewpoint. To understand its benefits, let us consider a client
    that retrieves two web objects over a 1 Mbps connection. The two requests are
    sent together by the client. The first object is 125 bytes long, while the second
    is 12500 bytes long. In this case, the server will first return the first object
    as a single frame and the second will be sent in the subsequent frame.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，这种多路复用能力可能是HTTP/2.0最重要的特性。为了理解其好处，让我们考虑一个通过1 Mbps连接检索两个网页对象的客户端。客户端将这两个请求一起发送。第一个对象长度为125字节，而第二个对象长度为12500字节。在这种情况下，服务器将首先以单个帧的形式返回第一个对象，第二个对象将在后续帧中发送。
- en: Consider now that the first object is 12500 bytes long and the second 125 bytes
    long as shown in [Fig. 41](#fig-http-hol). With a 1 Mbps connection, this object
    will use the underlying connection during 100 milliseconds. The client will thus
    need to wait 100 milliseconds to retrieve the second object. This is the Head
    of Line (HoL) blocking problem that affects the performance of many web services.
    If the short web object is a javascript code that requests other web objects,
    its retrieval may be critical to display the retrieved web page.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第一个对象长度为12500字节，第二个对象长度为125字节，如图41所示。通过1 Mbps连接，这个对象将占用底层连接100毫秒。因此，客户端需要等待100毫秒才能检索第二个对象。这是首部阻塞（HoL）问题，它影响了许多网络服务的性能。如果短网页对象是请求其他网页对象的javascript代码，其检索可能对显示检索到的网页至关重要。
- en: '![Figure made with TikZ](../Images/7fc784e24d2a3dd0171363ba394ef8ba.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/7fc784e24d2a3dd0171363ba394ef8ba.png)'
- en: Fig. 41 Head-of-line blocking, a large response may deal a small one
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 图41 首部阻塞，大响应可能影响小响应
- en: With HTTP/2.0 frames, the server could send the first 1250 bytes of the long
    object during 10 milliseconds, then send a second frame that contains the short
    object during one millisecond and later send a longer frame that contains the
    remaining 11250 bytes of the long object. This is illustrated in [Fig. 42](#fig-http2-no-hol).
    In this case, the client has received the short object after 10 milliseconds.
    Given the HTTP/2.0 streams, the transmission of long web objects does not anymore
    blocks the transmission of shorter ones.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP/2.0帧，服务器可以在10毫秒内发送长对象的第一个1250字节，然后发送一个包含短对象的第二个帧，持续一毫秒，之后发送一个包含长对象剩余11250字节的更长帧。这如图42所示。在这种情况下，客户端在10毫秒后收到了短对象。考虑到HTTP/2.0流，长网页对象的传输不再阻塞短对象的传输。
- en: The length of the HTTP/2.0 frames obviously affects how different web objects
    can be multiplexed over the underlying transport connection. If HTTP/2.0 frames
    are long, the overhead of the frame header is minimal, but long frames can block
    short web objects. On the other hand, if the frame length is small, then the overhead
    due to the HTTP/2.0 frame header could become significant.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0帧的长度显然会影响不同网页对象如何在底层传输连接上多路复用。如果HTTP/2.0帧很长，帧头的开销最小，但长帧可能会阻塞短网页对象。另一方面，如果帧长度较小，那么HTTP/2.0帧头的开销可能会变得显著。
- en: '![Figure made with TikZ](../Images/8873fd6b2b8e1c27c72e08f4926f28fb.png)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8873fd6b2b8e1c27c72e08f4926f28fb.png)'
- en: Fig. 42 The data from HTTP/2 frames can be interleaved to prevent head-of-line
    blocking
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 图42 HTTP/2帧中的数据可以交错以防止首部阻塞
- en: The HTTP/2.0 streams can provide performance benefits, but they also increase
    the complexity of the implementations since an HTTP/2.0 receiver must be able
    to simultaneously process frames that correspond to different web objects. This
    complexity mainly resides on the client side. The HTTP/2.0 protocol includes several
    techniques that enable clients to manage the utilization of the HTTP/2.0 session.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 流可以提供性能优势，但它们也增加了实现的复杂性，因为 HTTP/2.0 接收器必须能够同时处理对应于不同网络对象的不同帧。这种复杂性主要存在于客户端。HTTP/2.0
    协议包括一些技术，使客户端能够管理 HTTP/2.0 会话的利用率。
- en: The first frame that a client sends over an HTTP/2.0 session is the Settings
    frame. This is a control frame that indicates some parameters that the client
    proposes for this session. Several of these parameters are defined in [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html).
    The most important ones are probably the SETTINGS_MAX_FRAME_SIZE that specifies
    the maximum length of the HTTP/2.0 frames that this implementation supports and
    the SETTINGS_MAX_CONCURRENT_STREAMS that specifies the maximum number of parallel
    streams that this implementation can manage. The SETTINGS_MAX_FRAME_SIZE must
    be at least \(2^{14}\) bytes but can go up to \(2^{24} -1\) bytes. There is no
    minimum value for SETTINGS_MAX_CONCURRENT_STREAMS, but [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    recommends to support at least 100 different stream identifiers.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在 HTTP/2.0 会话中发送的第一个帧是设置帧。这是一个控制帧，指示客户端为此次会话提出的某些参数。其中一些参数在 [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    中定义。其中最重要的可能是 `SETTINGS_MAX_FRAME_SIZE`，它指定了此实现支持的 HTTP/2.0 帧的最大长度，以及 `SETTINGS_MAX_CONCURRENT_STREAMS`，它指定了此实现可以管理的最大并行流数。`SETTINGS_MAX_FRAME_SIZE`
    必须至少为 \(2^{14}\) 字节，但可以高达 \(2^{24} -1\) 字节。`SETTINGS_MAX_CONCURRENT_STREAMS` 没有最小值，但
    [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html) 建议至少支持 100
    个不同的流标识符。
- en: By using multiple streams, the server can multiplex different web objects over
    the same underlying transport connection. However, these objects are only sent
    in response to requests from clients. There are some situations where the server
    might know in advance that the client will request a given object. It could speedup
    the transfer by sending it before having received a client request. This is the
    push feature of HTTP/2.0\. A server can independently push web objects to a client
    without having received any request. This feature can only be used by the server
    if the client has enabled it by sending SETTINGS_ENABLE_PUSH in its Settings frame.
    A classical use case for this push feature is to enable a server to automatically
    send an object which cannot be cached by the client, such as a dynamic javascript
    code, when another web object that references it is requested. However, measurement
    studies indicate that very few web servers seem to have adopted this feature [[ZWH2018]](../bibliography.html#zwh2018).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个流，服务器可以在相同的底层传输连接上多路复用不同的网络对象。然而，这些对象仅在客户端请求时发送。有些情况下，服务器可能提前知道客户端将请求某个特定对象。它可以在收到客户端请求之前发送该对象，从而加快传输速度。这是
    HTTP/2.0 的推送功能。服务器可以在没有收到任何请求的情况下独立地将网络对象推送到客户端。此功能只能在客户端通过在其设置帧中发送 `SETTINGS_ENABLE_PUSH`
    启用它的情况下由服务器使用。此推送功能的经典用例是允许服务器在请求引用它的另一个网络对象时自动发送一个客户端无法缓存的对象，例如动态 JavaScript
    代码。然而，测量研究表明，似乎很少有网络服务器采用了此功能 [[ZWH2018]](../bibliography.html#zwh2018)。
- en: Another feature of HTTP/2.0 is that it is possible to assign different priorities
    to different streams. A high priority stream should carry more Data frames than
    a lower priority ones. The HTTP/2.0 specification defines Priority frames which
    can be used for this purpose.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 的另一个特点是，可以为不同的流分配不同的优先级。高优先级的流应该携带比低优先级流更多的数据帧。HTTP/2.0 规范定义了用于此目的的优先级帧。
- en: As the server can send multiple objects at the same time, there is a risk of
    overloading the client buffers. To cope with this potential problem, HTTP/2.0
    includes its own flow control mechanism. When an HTTP/2.0 session starts, a receiver
    agrees to receive up to 65,535 bytes over this connection (unless it has indicated
    a different initial window in its Settings frame). This limits the amount of data
    that a sender can transmit over the HTTP/2.0 session. The receiver can advertise
    a large receive window by sending a Window_Update frame at any time. This flow
    control mechanism can be applied to the entire connection or to a specific stream.
    In practice, using a small HTTP/2.0 window could severely limit the throughput
    over an HTTP/2.0 session.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器可以同时发送多个对象，因此存在过载客户端缓冲区的风险。为了应对这个潜在问题，HTTP/2.0包括它自己的流量控制机制。当HTTP/2.0会话开始时，接收方同意通过此连接接收最多65,535字节（除非它在设置帧中指示了不同的初始窗口）。这限制了发送方在HTTP/2.0会话中可以传输的数据量。接收方可以通过在任何时候发送Window_Update帧来宣传一个大的接收窗口。这种流量控制机制可以应用于整个连接或特定的流。在实践中，使用小的HTTP/2.0窗口可能会严重限制HTTP/2.0会话的吞吐量。
- en: HTTP/2.0 includes much more than what we have covered in this short introduction.
    There is for example a Ping frame that allows measuring the round-trip-time between
    a client and a server or the GoAway frame that indicates the termination of an
    HTTP/2.0 session. This frame contains an error code that indicates why the session
    has been terminated. Several error codes are defined in [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html),
    including ENHANCE_YOUR_CALM that is used to indicate that the other endpoint exhibits
    an behavior that could cause excessive load.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0包含的内容远不止我们在本简短介绍中涵盖的内容。例如，有一个允许测量客户端和服务器之间往返时间的Ping帧，或者表示HTTP/2.0会话终止的GoAway帧。这个帧包含一个错误代码，指示会话终止的原因。在[**RFC
    7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)中定义了多个错误代码，包括用于指示其他端点表现出可能导致过度负载的行为的ENHANCE_YOUR_CALM。
- en: Note
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Detecting whether a server supports HTTP/2.0
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 检测服务器是否支持HTTP/2.0
- en: HTTP/2.0 is a new version of the HTTP protocol that still uses port 80\. When
    a client contacts an HTTP server, it must be able to determine whether it supports
    HTTP/1.x or HTTP/2.0\. If the client sends a binary encoded HTTP/2.0 request to
    a server that only supports the ASCII encoded HTTP/1.x, it could cause problems
    on the server and even crash it. To minimize the risk of crashing HTTP/1.x servers,
    an HTTP/2.0 session starts like an HTTP/1.1 session and the first request contains
    the Connection, Upgrade and HTTP2-Settings headers. An example of such a request
    to upgrade the version of HTTP is shown below.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0是HTTP协议的新版本，仍然使用端口80。当客户端联系HTTP服务器时，它必须能够确定它是否支持HTTP/1.x或HTTP/2.0。如果客户端向只支持ASCII编码的HTTP/1.x的服务器发送二进制编码的HTTP/2.0请求，可能会在服务器上引起问题，甚至导致其崩溃。为了最小化HTTP/1.x服务器崩溃的风险，HTTP/2.0会话的启动方式类似于HTTP/1.1会话，第一个请求包含连接、升级和HTTP2-Settings头。下面是一个升级HTTP版本请求的示例。
- en: '[PRE20]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The HTTP2-Settings line contains the HTTP/2.0 settings frame that the client
    would server over an HTTP/2.0 session encoded in Base64\. The server replies with
    a response that indicates that it has accepted to upgrade the connection to HTTP/2.0\.
    A sample response is shown below.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP2-Settings行包含客户端在HTTP/2.0会话中通过Base64编码发送的HTTP/2.0设置帧。服务器通过一个响应来表示它已接受升级连接到HTTP/2.0。下面是一个示例响应。
- en: '[PRE21]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, the client and the server need to confirm the utilization of HTTP/2.0\.
    A client confirms this by sending the following Magic string PRI * HTTP/2.0rnrnSMrnrn
    or 0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a in hex. This string is followed
    by a SETTINGS frame. The server must send a possibly empty SETTINGS frame.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端和服务器需要确认HTTP/2.0的使用。客户端通过发送以下魔幻字符串PRI * HTTP/2.0rnrnSMrnrn或0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a十六进制来确认。这个字符串后面跟着一个设置帧。服务器必须发送一个可能为空的设置帧。
- en: Remote Procedure Calls[#](#remote-procedure-calls "Link to this heading")
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程过程调用[#](#remote-procedure-calls "链接到这个标题")
- en: In the previous sections, we have described several protocols that enable humans
    to exchange messages and access to remote documents. This is not the only usage
    of computer networks and in many situations applications use the network to exchange
    information with other applications. When an application needs to perform a large
    computation on a host, it can sometimes be useful to request computations from
    other hosts. Many distributed systems have been built by distributing applications
    on different hosts and using Remote Procedure Calls as a basic building block.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了几个协议，这些协议使人类能够交换消息和访问远程文档。这并不是计算机网络的唯一用途，在许多情况下，应用程序使用网络与其他应用程序交换信息。当一个应用程序需要在主机上执行大量计算时，有时从其他主机请求计算可能是有用的。许多分布式系统是通过在不同主机上分布应用程序并使用远程过程调用作为基本构建块来构建的。
- en: 'In traditional programming languages, procedure calls allow programmers to
    better structure their code. Each procedure is identified by a name, a return
    type and a set of parameters. When a procedure is called, the current flow of
    program execution is diverted to execute the procedure. This procedure uses the
    provided parameters to perform its computation and returns one or more values.
    This programming model was designed with a single host in mind. In a nutshell,
    most programming languages support it as follows :'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的编程语言中，过程调用允许程序员更好地组织他们的代码。每个过程都有一个名称、一个返回类型和一组参数。当调用一个过程时，程序执行的当前流程会被转移到执行该过程。这个过程使用提供的参数来执行其计算，并返回一个或多个值。这个编程模型是针对单个主机设计的。简而言之，大多数编程语言都支持它如下：
- en: The caller places the values of the parameters at a location (register, stack,
    …) where the callee can access them
  id: totrans-614
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将参数的值放置在调用者可以访问的位置（寄存器、堆栈等）
- en: ''
  id: totrans-615
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-616
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The caller transfers the control of execution to the callee’s procedure
  id: totrans-617
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将执行控制权转移到被调用者的过程
- en: ''
  id: totrans-618
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-619
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The callee accesses the parameters and performs the requested computation
  id: totrans-620
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用者访问参数并执行所需的计算
- en: ''
  id: totrans-621
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-622
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The callee places the return value(s) at a location (register, stack, …) where
    the caller can access them
  id: totrans-623
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用者将返回值（们）放置在调用者可以访问的位置（寄存器、堆栈等）
- en: ''
  id: totrans-624
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-625
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The callee returns the control of execution to the caller’s
  id: totrans-626
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用者将执行控制权返回给调用者
- en: This model was developed with a single host in mind. How should it be modified
    if the caller and the callee are different hosts connected through a network ?
    Since the two hosts can be different, the two main problems are the fact they
    do not share the same memory and that they do not necessarily use the same representation
    for numbers, characters, … Let us examine how the five steps identified above
    can be supported through a network.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型是针对单个主机开发的。如果调用者和被调用者是通过网络连接的不同主机，应该如何修改？由于两个主机可能不同，两个主要问题就是它们不共享相同的内存，并且它们不一定使用相同的表示方式来表示数字、字符等。让我们来探讨如何通过网络支持上述确定的五个步骤。
- en: The first problem to be solved is how to transfer the information from the caller
    to the callee. This problem is not simple and includes two sub-problems. The first
    sub-problem is the encoding of the information. How to encode the values of the
    parameters so that they can be transferred correctly through the network ? The
    second problem is how to reach the callee through the network ? The callee is
    identified by a procedure name, but to use the transport service, we need to convert
    this name into an address and a port number.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的首要问题是如何将信息从调用者传输到被调用者。这个问题并不简单，包括两个子问题。第一个子问题是信息的编码。如何编码参数的值，以便它们可以通过网络正确传输？第二个问题是如何通过网络到达被调用者？被调用者通过一个过程名称来识别，但为了使用传输服务，我们需要将此名称转换为地址和端口号。
- en: '### Encoding data[#](#encoding-data "Link to this heading")'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '### 数据编码[#](#encoding-data "链接到本标题")'
- en: The encoding problem exists in a wide range of applications. In the previous
    sections, we have described how character-based encodings are used by email and
    HTTP. Although standard encoding techniques such as ASN.1 [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    have been defined to cover most application needs, many applications have defined
    their specific encoding. Remote Procedure Call are no exception to this rule.
    The three most popular encoding methods are probably XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    used by ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html),
    XML, used by XML-RPC and JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html).
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 编码问题存在于广泛的应用中。在前几节中，我们描述了基于字符的编码如何在电子邮件和HTTP中应用。尽管已经定义了标准编码技术，如ASN.1 [[Dubuisson2000]](../bibliography.html#dubuisson2000)，以覆盖大多数应用需求，但许多应用已经定义了它们自己的特定编码。远程过程调用也不例外。最流行的三种编码方法可能是ONC-RPC
    [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html) 使用的XDR，[**RFC
    1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)，以及XML-RPC使用的XML和JSON
    [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)。
- en: The eXternal Data Representation (XDR) Standard, defined in [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    is an early specification that describes how information exchanged during Remote
    Procedure Calls should be encoded before being transmitted through a network.
    Since the transport service enables transferring a block of bytes (with the connectionless
    service) or a stream of bytes (by using the connection-oriented service), XDR
    maps each datatype onto a sequence of bytes. The caller encodes each data in the
    appropriate sequence and the callee decodes the received information. Here are
    a few examples extracted from [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    to illustrate how this encoding/decoding can be performed.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数据表示（XDR）标准，在[**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)中定义，是一个早期规范，描述了在远程过程调用期间交换的信息在通过网络传输之前应该如何编码。由于传输服务允许传输一个字节块（通过无连接服务）或一个字节流（通过使用面向连接的服务），XDR将每个数据类型映射到一系列字节。调用方将每个数据编码到适当的序列中，而被调用方解码接收到的信息。以下是从[**RFC
    1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)中提取的一些示例，以说明这种编码/解码是如何执行的。
- en: For basic data types, [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    simply maps their representation into a sequence of bytes. For example a 32 bits
    integer is transmitted as shown in [Fig. 43](#fig-xdr-int32) (with the most significant
    byte first, which corresponds to big-endian encoding).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本数据类型，[**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    简单地将它们的表示映射到一系列字节。例如，一个32位整数按照[图43](#fig-xdr-int32)（字节顺序从最高位开始，对应大端编码）所示的方式传输。
- en: '![../_images/xdr-integer.svg](../Images/d52e7c6b6281eb132d460857ec233eff.png)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/xdr-integer.svg](../Images/d52e7c6b6281eb132d460857ec233eff.png)'
- en: Fig. 43 XDR representation of a 32 bits integer[#](#id72 "Link to this image")
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图43 XDR表示的32位整数[#](#id72 "链接到这张图片")
- en: 'XDR also supports 64 bits integers and booleans. The booleans are mapped onto
    integers (0 for false and 1 for true). For the floating point numbers, the encoding
    defined in the IEEE standard is used. In the representation, the first bit (S)
    is the sign (0 represents positive). The next 11 bits represent the exponent of
    the number (E), in base 2, and the remaining 52 bits are the fractional part of
    the number (F). The floating point number that corresponds to this representation
    is \((-1)^{S} \times 2^{E-1023} \times 1.F\). XDR also allows encoding complex
    data types. A first example is the string of bytes. A string of bytes is composed
    of two parts : a length (encoded as an integer) and a sequence of bytes. For performance
    reasons, the encoding of a string is aligned to 32 bits boundaries. This implies
    that some padding bytes may be inserted during the encoding operation is the length
    of the string is not a multiple of 4\. The structure of the string is shown below
    (source [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)).'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: XDR 还支持 64 位整数和布尔值。布尔值映射到整数（0 表示假，1 表示真）。对于浮点数，使用 IEEE 标准中定义的编码。在表示中，第一个位（S）是符号（0
    表示正）。接下来的 11 位表示数字的指数（E），以 2 为基数，剩余的 52 位是数字的小数部分（F）。与这种表示相对应的浮点数是 \((-1)^{S}
    \times 2^{E-1023} \times 1.F\)。XDR 还允许编码复杂的数据类型。第一个例子是字节数组。字节数组由两部分组成：一个长度（编码为一个整数）和一个字节序列。出于性能考虑，字符串的编码对齐到
    32 位边界。这意味着如果字符串的长度不是 4 的倍数，编码操作过程中可能会插入一些填充字节。字符串的结构如下所示（来源 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html))。
- en: '[![../_images/xdr-float.svg](../Images/b3e916ca81c68d2a4b58075d4bf0bb7c.png)](../_images/xdr-float.svg)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/xdr-float.svg](../Images/b3e916ca81c68d2a4b58075d4bf0bb7c.png)](../_images/xdr-float.svg)'
- en: Fig. 44 XDR representation of a floating point number[#](#id73 "Link to this
    image")
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 图 44 XDR 表示浮点数[#](#id73 "链接到这张图片")
- en: In some situations, it is necessary to encode fixed or variable length arrays.
    XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html) supports
    such arrays. For example, the encoding in [Fig. 45](#fig-xdr-narray) corresponds
    to an array containing n elements. The encoded representation starts with an integer
    that contains the number of elements and follows with all elements in sequence.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要编码固定长度或可变长度的数组。XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    支持此类数组。例如，[图 45](#fig-xdr-narray) 中的编码对应于包含 n 个元素的数组。编码表示从包含元素数量的整数开始，随后是所有元素按顺序排列。
- en: '[![../_images/xdr-array.svg](../Images/e1244da31b6e5cd69f0f51dd6cf774b8.png)](../_images/xdr-array.svg)'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/xdr-array.svg](../Images/e1244da31b6e5cd69f0f51dd6cf774b8.png)](../_images/xdr-array.svg)'
- en: Fig. 45 XDR representation of an array[#](#id74 "Link to this image")
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 图 45 XDR 表示数组[#](#id74 "链接到这张图片")
- en: XDR also supports the definition of unions, structures, … Additional details
    are provided in [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html).
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: XDR 还支持联合、结构体等的定义。更多详细信息请参阅 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)。
- en: A second popular method to encode data is the JavaScript Object Notation (JSON).
    This syntax was initially defined to allow applications written in JavaScript
    to exchange data, but it has now wider usages. JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    is a text-based representation. The simplest data type is the integer. It is represented
    as a sequence of digits in ASCII. Strings can also be encoding by using JSON.
    A JSON string always starts and ends with a quote character (”) as in the C language.
    As in the C language, some characters (like “ or \) must be escaped if they appear
    in a string. [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    describes this in details. Booleans are also supported by using the strings false
    and true. Like XDR, JSON supports more complex data types. A structure or object
    is defined as a comma separated list of elements enclosed in curly brackets. [**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) provides the following
    example as an illustration.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据的第二种流行方法是 JavaScript 对象表示法 (JSON)。这种语法最初是为了允许用 JavaScript 编写的应用程序交换数据而定义的，但现在它有更广泛的应用。JSON
    [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) 是一种基于文本的表示。最简单的数据类型是整数。它以
    ASCII 码中的数字序列表示。字符串也可以通过使用 JSON 进行编码。JSON 字符串始终以引号字符（”）开头和结尾，就像 C 语言一样。与 C 语言一样，如果某些字符（如
    “ 或 \）出现在字符串中，则必须进行转义。[**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    详细描述了这一点。布尔值也通过使用字符串 false 和 true 来支持。与 XDR 类似，JSON 支持更复杂的数据类型。结构或对象定义为用花括号括起来的元素列表，元素之间用逗号分隔。[**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) 提供了以下示例作为说明。
- en: '[PRE22]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This object has one field named Image. It has five attributes. The first one,
    Width, is an integer set to 800\. The third one is a string. The fourth attribute,
    Thumbnail is also an object composed of three different attributes, one string
    and two integers. JSON can also be used to encode arrays or lists. In this case,
    square brackets are used as delimiters. The snippet below shows an array which
    contains the prime integers that are smaller than ten.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象有一个名为 Image 的字段。它有五个属性。第一个属性，Width，是一个设置为 800 的整数。第三个属性是一个字符串。第四个属性，Thumbnail，也是一个由三个不同属性组成的对象，包括一个字符串和两个整数。JSON
    也可以用来编码数组或列表。在这种情况下，使用方括号作为分隔符。下面的代码片段显示了一个包含小于十的质数的数组。
- en: '[PRE23]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compared with XDR, the main advantage of JSON is that the transfer syntax is
    easily readable by a human. However, this comes at the expense of a less compact
    encoding. Some data encoded in JSON will usually take more space than when it
    is encoded with XDR. More compact encoding schemes have been defined, see e.g.
    [[BH2013]](../bibliography.html#bh2013) and the references therein.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 与 XDR 相比，JSON 的主要优势是传输语法易于人类阅读。然而，这是以牺牲更紧凑的编码为代价的。一些用 JSON 编码的数据通常比用 XDR 编码时占用更多空间。已经定义了更紧凑的编码方案，例如
    [[BH2013]](../bibliography.html#bh2013) 和其中的参考文献。
- en: Reaching the callee[#](#reaching-the-callee "Link to this heading")
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到达被调用方[#](#reaching-the-callee "链接到这个标题")
- en: 'The second sub-problem is how to reach the callee. A simple solution to this
    problem is to make sure that the callee listens on a specific port on the remote
    machine and then exchange information with this server process. This is the solution
    chosen for JSON-RPC [[JSON-RPC2]](../bibliography.html#json-rpc2). JSON-RPC can
    be used over the connectionless or the connection-oriented transport service.
    A JSON-RPC request contains the following fields:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子问题是如何到达被调用方。解决这个问题的简单方法是在远程机器上确保被调用方监听一个特定的端口，然后与这个服务器进程交换信息。这是 JSON-RPC
    [[JSON-RPC2]](../bibliography.html#json-rpc2) 所选择的解决方案。JSON-RPC 可以通过无连接或面向连接的传输服务使用。一个
    JSON-RPC 请求包含以下字段：
- en: 'jsonrpc: a string indicating the version of the protocol used. This is important
    to allow the protocol to evolve in the future.'
  id: totrans-649
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jsonrpc: 一个表示所使用的协议版本的字符串。这对于允许协议在未来进行演变非常重要。'
- en: ''
  id: totrans-650
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'method: a string that contains the name of the procedure which is invoked'
  id: totrans-652
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'method: 一个包含被调用过程名称的字符串'
- en: ''
  id: totrans-653
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-654
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'params: a structure that contains the values of the parameters that are passed
    to the method'
  id: totrans-655
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'params: 一个包含传递给方法的参数值的结构'
- en: ''
  id: totrans-656
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: an identifier chosen by the caller'
  id: totrans-658
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'id: 由调用者选择的标识符'
- en: The JSON-RPC is encoded as a JSON object. For example, the example below shows
    an invocation of a method called sum with 1 and 3 as parameters.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC 被编码为一个 JSON 对象。例如，下面的示例展示了调用一个名为 sum 的方法，其参数为 1 和 3。
- en: '[PRE24]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Upon reception of this JSON structure, the callee parses the object, locates
    the corresponding method and passes the parameters. This method returns a response
    which is also encoded as a JSON structure. This response contains the following
    fields:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到此JSON结构后，调用者解析对象，找到对应的方法，并传递参数。此方法返回一个响应，该响应也编码为JSON结构。此响应包含以下字段：
- en: 'jsonrpc: a string indicating the version of the protocol used to encode the
    response'
  id: totrans-662
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: jsonrpc：一个表示用于编码响应的协议版本的字符串
- en: ''
  id: totrans-663
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-664
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: the same identifier as the identifier chosen by the caller'
  id: totrans-665
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: id：与调用者选择的标识符相同的标识符
- en: ''
  id: totrans-666
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-667
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: if the request succeeded, this member contains the result of the request
    (in our example, value 4).'
  id: totrans-668
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果：如果请求成功，此成员包含请求的结果（在我们的例子中，值为4）。
- en: ''
  id: totrans-669
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-670
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'error: if the method called does not exist or its execution causes an error,
    the result element will be replaced by an error element which contains the following
    members :'
  id: totrans-671
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：如果调用不存在或其执行导致错误，结果元素将被错误元素替换，该错误元素包含以下成员：
- en: ''
  id: totrans-672
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-673
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-674
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'code: a number that indicates the type of error. Several error codes are defined
    in [[JSON-RPC2]](../bibliography.html#json-rpc2). For example, -32700 indicates
    an error in parsing the request, -32602 indicates invalid parameters and -32601
    indicates that the method could not be found on the server. Other error codes
    are listed in [[JSON-RPC2]](../bibliography.html#json-rpc2).'
  id: totrans-675
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: code：一个表示错误类型的数字。在[[JSON-RPC2]](../bibliography.html#json-rpc2)中定义了几个错误代码。例如，-32700表示请求解析错误，-32602表示参数无效，-32601表示服务器上找不到该方法。其他错误代码在[[JSON-RPC2]](../bibliography.html#json-rpc2)中列出。
- en: ''
  id: totrans-676
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-677
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message: a string (limited to one sentence) that provides a short description
    of the error.'
  id: totrans-678
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息：一个字符串（限于一句话），提供错误的简短描述。
- en: ''
  id: totrans-679
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-680
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'data: an optional field that provides additional information about the error.'
  id: totrans-681
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据：一个可选字段，提供有关错误的附加信息。
- en: Coming back to our example with the call for the sum procedure, it would return
    the following JSON structure.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们关于求和过程调用的例子，它将返回以下JSON结构。
- en: '[PRE25]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the sum method is not implemented on the server, it would reply with the
    following response.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器上未实现求和方法，它将回复以下响应。
- en: '[PRE26]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The id field, which is present in the request and the response plays the same
    role as the identifier field in the DNS message. It allows the caller to match
    the response with the request that it sent. This id is very important when JSON-RPC
    is used over the connectionless transport service which is unreliable. If a request
    is sent, it may need to be retransmitted and it is possible that a callee will
    receive twice the same request (e.g. if the response for the first request was
    lost). In the DNS, when a request is lost, it can be retransmitted without causing
    any difficulty. However with remote procedure calls in general, losses can cause
    some problems. Consider a method which is used to deposit money on a bank account.
    If the request is lost, it will be retransmitted and the deposit will be eventually
    performed. However, if the response is lost, the caller will also retransmit its
    request. This request will be received by the callee that will deposit the money
    again. To prevent this problem from affecting the application, either the programmer
    must ensure that the remote procedures that it calls can be safely called multiple
    times or the application must verify whether the request has been transmitted
    earlier. In most deployments, the programmers use remote methods that can be safely
    called multiple times without breaking the application logic.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: id字段，存在于请求和响应中，在DNS消息中的标识符字段中扮演相同的作用。它允许调用者将响应与其发送的请求匹配。当在不可靠的无连接传输服务上使用JSON-RPC时，此id非常重要。如果发送请求，它可能需要重新传输，并且可能调用者会收到两次相同的请求（例如，如果第一个请求的响应丢失）。在DNS中，当请求丢失时，可以重新传输而不会造成任何困难。然而，在一般远程过程调用中，丢失可能会引起一些问题。考虑一个用于在银行账户上存钱的函数。如果请求丢失，它将被重新传输，存款最终会完成。然而，如果响应丢失，调用者也会重新传输其请求。此请求将被调用者接收，并将再次存钱。为了防止这个问题影响应用程序，程序员必须确保它调用的远程过程可以安全地多次调用，或者应用程序必须验证请求是否已经传输。在大多数部署中，程序员使用可以安全多次调用而不破坏应用程序逻辑的远程方法。
- en: ONC-RPC uses a more complex method to allow a caller to reach the callee. On
    a host, server processes can run on different ports and given the limited number
    of port values (\(2^{16}\) per host on the Internet), it is impossible to reserve
    one port number for each method. The solution used in ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)
    is to use a special method which is called the portmapper [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html).
    The portmapper is a kind of directory that runs on a server that hosts methods.
    The portmapper runs on a standard port (111 for ONC-RPC [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)).
    A server process that implements a method registers its method on the local portmapper.
    When a caller needs to call a method on a remote server, it first contacts the
    portmapper to obtain the port number of the server process which implements the
    method. The response from the portmapper allows it to directly contact the server
    process which implements the method.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ONC-RPC使用一种更复杂的方法来允许调用者到达被调用者。在主机上，服务器进程可以运行在不同的端口上，鉴于端口号值的限制（因特网上的每个主机有 \(2^{16}\)
    个端口号），为每种方法预留一个端口号是不可能的。ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)
    中使用的解决方案是使用一种特殊的方法，称为端口号映射器 [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)。端口号映射器是一种在提供方法的服务器上运行的目录。端口号映射器运行在标准端口（ONC-RPC
    [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html) 的 111）上。实现方法的服务器进程在其本地端口号映射器上注册其方法。当调用者需要调用远程服务器上的方法时，它首先联系端口号映射器以获取实现该方法的服务器进程的端口号。端口号映射器的响应允许它直接联系实现该方法的服务器进程。
- en: Footnotes
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: '## Naming and addressing[#](#naming-and-addressing "Link to this heading")'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '## 命名和寻址[#](#naming-and-addressing "链接到本标题")'
- en: The network and the transport layers rely on addresses that are encoded as fixed-size
    bit strings. A network layer address uniquely identifies a host. Several transport
    layer entities can use the service of the same network layer. For example, a reliable
    transport protocol and a connectionless transport protocol can coexist on the
    same host. In this case, the network layer multiplexes the segments produced by
    these two protocols. This multiplexing is usually achieved by placing in the network
    packet header a field that indicates which transport protocol should process the
    segment. Given that there are few different transport protocols, this field does
    not need to be long. The port numbers play a similar role in the transport layer
    since they enable it to multiplex data from several application processes.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和传输层依赖于编码为固定大小位字符串的地址。网络层地址唯一标识一个主机。多个传输层实体可以使用同一网络层的服务。例如，可靠的传输协议和无连接的传输协议可以在同一主机上共存。在这种情况下，网络层会多路复用这两个协议产生的段。这种多路复用通常是通过在网络数据包头部放置一个字段来实现的，该字段指示哪个传输协议应该处理该段。鉴于不同的传输协议数量很少，这个字段不需要很长。端口号在传输层也扮演着类似的角色，因为它们使传输层能够多路复用来自多个应用程序进程的数据。
- en: While addresses are natural for the network and transport layer entities, humans
    prefer to use names when interacting with network services. Names can be encoded
    as a character string, and a mapping service allows applications to map a name
    into the corresponding address. Using names is friendlier for humans, but it also
    provides a level of indirection which is very useful in many situations.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然地址对于网络和传输层实体来说是自然的，但人类在与网络服务交互时更喜欢使用名称。名称可以被编码为字符串，并且映射服务允许应用程序将名称映射到相应的地址。使用名称对人类来说更加友好，但它也提供了一种间接性，这在许多情况下非常有用。
- en: In the early days of the Internet, only a few hosts (mainly minicomputers) were
    connected to the network. The most popular applications were [remote login](../glossary.html#term-remote-login)
    and file transfer. By 1983, there were already five hundred hosts attached to
    the Internet [[Zakon]](../bibliography.html#zakon). Each of these hosts was identified
    by a unique address. Forcing human users to remember the addresses of the hosts
    that they wanted to use was not user-friendly. Humans prefer to remember names
    and use them when needed. Using names as aliases for addresses is a common technique
    in Computer Science. It simplifies the development of applications and allows
    the developer to ignore the low-level details. For example, by using a programming
    language instead of writing machine code, a developer can write software without
    knowing whether the variables that it uses are stored in memory or inside registers.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网的早期，只有少数主机（主要是小型计算机）连接到网络。最受欢迎的应用程序是[远程登录](../glossary.html#term-remote-login)和文件传输。到1983年，已有五百台主机连接到互联网
    [[Zakon]](../bibliography.html#zakon)。这些主机中的每一台都有一个唯一的地址。强迫用户记住他们想要使用的宿主机的地址并不友好。人类更喜欢记住名称并在需要时使用它们。将名称用作地址的别名是计算机科学中的一种常见技术。它简化了应用程序的开发，并允许开发者忽略低级细节。例如，通过使用编程语言而不是编写机器代码，开发者可以编写软件而无需知道它所使用的变量是存储在内存中还是寄存器内。
- en: Because names are at a higher level than addresses, they allow (both in the
    example of programming above and on the Internet) to treat addresses as mere technical
    identifiers, which can change at will. Only the names are stable.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称比地址处于更高的层次，因此它们允许（在上述编程示例和互联网上）将地址视为仅是技术标识符，可以随意更改。只有名称是稳定的。
- en: The first solution that allowed applications to use names was the [hosts.txt](../glossary.html#term-hosts.txt)
    file. This file is similar to the symbol table found in compiled code. It contains
    the mapping between the name of each Internet host and its associated address
    [[1]](#fhosts). It was maintained by the SRI International Network Information
    Center (NIC). When a new host was connected to the network, the system administrator
    had to register its name and address at the NIC. The NIC updated the [hosts.txt](../glossary.html#term-hosts.txt)
    file on its server. All Internet hosts regularly retrieved the updated [hosts.txt](../glossary.html#term-hosts.txt)
    file from the [SRI](https://www.sri.com) server. This file was stored at a well-known
    location on each Internet host (see [**RFC 952**](https://datatracker.ietf.org/doc/html/rfc952.html))
    and networked applications could use it to find the address corresponding to a
    name.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 允许应用程序使用名称的第一个解决方案是[hosts.txt](../glossary.html#term-hosts.txt)文件。此文件类似于编译代码中找到的符号表。它包含每个互联网主机名称与其相关地址之间的映射
    [[1]](#fhosts)。该文件由SRI国际网络信息中心（NIC）维护。当一个新的主机连接到网络时，系统管理员必须在该NIC上注册其名称和地址。NIC会更新其服务器上的[hosts.txt](../glossary.html#term-hosts.txt)文件。所有互联网主机都会定期从[SRI](https://www.sri.com)服务器检索更新的[hosts.txt](../glossary.html#term-hosts.txt)文件。此文件存储在每个互联网主机的一个知名位置（见[**RFC
    952**](https://datatracker.ietf.org/doc/html/rfc952.html)），网络应用程序可以使用它来查找与名称对应的地址。
- en: A [hosts.txt](../glossary.html#term-hosts.txt) file can be used when there are
    up to a few hundred hosts on the network. However, it is clearly not suitable
    for a network containing thousands or millions of hosts. A key issue in a large
    network is to define a suitable naming scheme. The ARPANet initially used a flat
    naming space, i.e. each host was assigned a unique name. To limit collisions between
    names, these names usually contained the name of the institution and a suffix
    to identify the host inside the institution (a kind of poor man’s hierarchical
    naming scheme). On the ARPANet, few institutions had several hosts connected to
    the network.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络上有数百台主机时，可以使用[hosts.txt](../glossary.html#term-hosts.txt)文件。然而，显然它不适用于包含数千或数百万主机的网络。在大网络中的一个关键问题是定义一个合适的命名方案。ARPANet最初使用平面命名空间，即每个主机都被分配了一个唯一的名称。为了限制名称之间的冲突，这些名称通常包含机构的名称以及一个后缀来识别机构内的主机（一种简陋的分层命名方案）。在ARPANet上，很少有机构有多个主机连接到网络。
- en: However, the limitations of a flat naming scheme became clear before the end
    of the ARPANet, and [**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)
    proposed a hierarchical naming scheme. While [**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)
    discussed the possibility of organizing the names as a directed graph, the Internet
    opted for a tree structure capable of containing all names. In this tree, the
    top-level domains are those that are directly attached to the root. The first
    top-level domain was .arpa [[2]](#fdnstimeline). This top-level name was initially
    added as a suffix to the names of the hosts attached to the ARPANet and listed
    in the hosts.txt file. In 1984, the .gov, .edu, .com, .mil, and .org generic top-level
    domain names were added. [**RFC 1032**](https://datatracker.ietf.org/doc/html/rfc1032.html)
    proposed the utilization of the two-letter [ISO-3166](../glossary.html#term-ISO-3166)
    country codes as top-level domain names. Since [ISO-3166](../glossary.html#term-ISO-3166)
    defines a two-letter code for each country recognized by the United Nations, this
    allowed all countries to automatically have a top-level domain. These domains
    include .be for Belgium, .fr for France, .us for the USA, .ie for Ireland, or
    .tv for Tuvalu, a group of small islands in the Pacific, or .tm for Turkmenistan.
    The set of top-level domain names is managed by the Internet Corporation for Assigned
    Names and Numbers ([ICANN](../glossary.html#term-ICANN)). [ICANN](../glossary.html#term-ICANN)
    adds generic top-level domains that are not related to a country, and the .cat
    top-level domain has been registered for the Catalan language. There are ongoing
    discussions within [ICANN](../glossary.html#term-ICANN) to increase the number
    of top-level domains.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ARPANet 结束之前，扁平命名方案的局限性已经变得明显，[**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)
    提出了一个分层命名方案。虽然 [**RFC 819**](https://datatracker.ietf.org/doc/html/rfc819.html)
    讨论了将名称组织为有向图的可能性，但互联网选择了能够包含所有名称的树状结构。在这个树中，顶级域名是直接连接到根的。第一个顶级域名是 .arpa [[2]](#fdnstimeline)。这个顶级域名最初被添加到连接到
    ARPANet 的主机名称之后，并在 hosts.txt 文件中列出。1984 年，添加了 .gov、.edu、.com、.mil 和 .org 通用顶级域名。[**RFC
    1032**](https://datatracker.ietf.org/doc/html/rfc1032.html) 提出了使用两个字母的 [ISO-3166](../glossary.html#term-ISO-3166)
    国家代码作为顶级域名。由于 [ISO-3166](../glossary.html#term-ISO-3166) 为联合国认可的每个国家定义了一个两字母代码，这允许所有国家自动拥有顶级域名。这些域名包括
    .be（比利时）、.fr（法国）、.us（美国）、.ie（爱尔兰）或 .tv（图瓦卢），太平洋上的一组小岛屿，或 .tm（土库曼斯坦）。顶级域名集合由互联网名称与数字地址分配机构
    ([ICANN](../glossary.html#term-ICANN)) 管理。[ICANN](../glossary.html#term-ICANN)
    添加与国家无关的通用顶级域名，并为加泰罗尼亚语注册了 .cat 顶级域名。在 [ICANN](../glossary.html#term-ICANN) 内部正在进行增加顶级域名数量的讨论。
- en: Each top-level domain is managed by an organization that decides how subdomain
    names can be registered. Most top-level domain names use a first-come, first-served
    system and allow anyone to register domain names, but there are some exceptions.
    For example, .gov is reserved for the US government, .int is reserved for international
    organizations, and names in the .ca are mainly [reserved](http://en.wikipedia.org/wiki/.ca)
    for companies or users that are present in Canada.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶级域名都由一个组织管理，该组织决定子域名名的注册方式。大多数顶级域名采用先到先得系统，允许任何人注册域名，但也有例外。例如，.gov 保留给美国政府，.int
    保留给国际组织，而 .ca 域名主要 [保留](http://en.wikipedia.org/wiki/.ca) 给在加拿大存在的公司或用户。
- en: '![Figure made with TikZ](../Images/28e49f48398377711717aaa96d6ec501.png)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/28e49f48398377711717aaa96d6ec501.png)'
- en: Fig. 23 The tree of domain names
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23 域名树
- en: The syntax of the domain names has been defined more precisely in [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html).
    This document recommends the following [BNF](../glossary.html#term-BNF) for fully
    qualified domain names (the domain names themselves have a much richer syntax).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 域名语法已在 [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html) 中定义得更加精确。本文件推荐以下
    [BNF](../glossary.html#term-BNF) 用于完全限定域名（域名本身具有更丰富的语法）。
- en: Listing 1 BNF of the fully qualified host names[#](#id52 "Link to this code")
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1 完全限定主机名的 BNF 格式[#](#id52 "链接到这段代码")
- en: '[PRE27]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This grammar specifies that a host name is an ordered list of labels separated
    by the dot (.) character. Each label can contain letters, numbers, and the hyphen
    character (-) [[3]](#fidn). Fully qualified domain names are read from left to
    right. The first label is a hostname or a domain name followed by the hierarchy
    of domains and ending with the root implicitly at the right. The top-level domain
    name must be one of the registered TLDs [[4]](#ftld). For example, in the above
    figure, www.computer-networking.info corresponds to a host named www inside the
    computer-networking domain that belongs to the info top-level domain.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法指定主机名是由点（.）字符分隔的标签有序列表。每个标签可以包含字母、数字和连字符字符 (-) [[3]](#fidn)。完全限定的域名从左到右读取。第一个标签是主机名或域名，后面跟着域名的层次结构，并以右侧隐含的根结束。顶级域名必须是已注册的
    TLD 之一 [[4]](#ftld)。例如，在上面的图中，www.computer-networking.info 对应于 info 顶级域中 computer-networking
    域内的一个名为 www 的主机。
- en: Note
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some visually similar characters have different character codes
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 一些视觉上相似的字符有不同的字符编码
- en: The Domain Name System was created at a time when the Internet was mainly used
    in North America. The initial design assumed that all domain names would be composed
    of letters and digits [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html).
    As Internet usage grew in other parts of the world, it became important to support
    non-ASCII characters. For this, extensions have been proposed to the Domain Name
    System [**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html). In
    a nutshell, the solution that is used to support Internationalized Domain Names
    works as follows. First, it is possible to use most of the Unicode characters
    to encode domain names and hostnames, with a few exceptions (for example, the
    dot character cannot be part of a name since it is used as a separator). Once
    a domain name has been encoded as a series of Unicode characters, it is then converted
    into a string that contains the `xn--` prefix and a sequence of ASCII characters.
    More details on these algorithms can be found in [**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html)
    and [**RFC 3492**](https://datatracker.ietf.org/doc/html/rfc3492.html).
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统是在互联网主要在北美使用的时候创建的。最初的设计假设所有域名都由字母和数字组成 [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html)。随着互联网在其他地区的使用增长，支持非
    ASCII 字符变得很重要。为此，对域名系统提出了扩展 [**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html)。简而言之，用于支持国际化域名的解决方案工作原理如下。首先，可以使用大多数
    Unicode 字符来编码域名和主机名，但有少数例外（例如，点字符不能是名称的一部分，因为它用作分隔符）。一旦域名被编码为一系列 Unicode 字符，它就会被转换成一个包含
    `xn--` 前缀和一系列 ASCII 字符的字符串。有关这些算法的更多详细信息，请参阅[**RFC 3490**](https://datatracker.ietf.org/doc/html/rfc3490.html)和[**RFC
    3492**](https://datatracker.ietf.org/doc/html/rfc3492.html)。
- en: The possibility of using all Unicode characters to create domain names opened
    a new form of attack called the [homograph attack](https://en.wikipedia.org/wiki/IDN_homograph_attack).
    This attack occurs when two character strings or domain names are visually similar
    but do not correspond to the same server. A simple example is [https://G00GLE.COM](https://G00GLE.COM)
    and [https://GOOGLE.COM](https://GOOGLE.COM). These two URLs are visually close
    but they correspond to different names (the first one does not point to a valid
    server [[5]](#fg00gle)). With other Unicode characters, it is possible to construct
    domain names that are visually equivalent to existing ones. See [[Zhe2017]](../bibliography.html#zhe2017)
    for additional details on this attack.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有 Unicode 字符创建域名的可能性开启了一种新的攻击形式，称为[同音攻击](https://en.wikipedia.org/wiki/IDN_homograph_attack)。这种攻击发生在两个字符串或域名在视觉上相似，但并不对应同一服务器的情况下。一个简单的例子是[https://G00GLE.COM](https://G00GLE.COM)和[https://GOOGLE.COM](https://GOOGLE.COM)。这两个
    URL 在视觉上非常接近，但它们对应不同的名称（第一个不指向一个有效的服务器 [[5]](#fg00gle)）。使用其他 Unicode 字符，可以构建与现有域名视觉上等效的域名。有关此攻击的更多详细信息，请参阅[[Zhe2017]](../bibliography.html#zhe2017)。
- en: This hierarchical naming scheme is a key component of the Domain Name System
    (DNS). The DNS is a distributed database that contains mappings between fully
    qualified domain names and addresses. The DNS uses the client-server model. The
    clients are hosts or applications that need to retrieve the mapping for a given
    name. Each [nameserver](../glossary.html#term-nameserver) stores part of the distributed
    database and answers the queries sent by clients. There is at least one [nameserver](../glossary.html#term-nameserver)
    that is responsible for each domain. In the figure below, domains are represented
    by circles and there are three hosts inside domain dom (h1, h2, and h3) and three
    hosts inside domain a.sdom1.dom. As shown in the figure below, a sub-domain may
    contain both host names and sub-domains.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层命名方案是域名系统 (DNS) 的关键组成部分。DNS 是一个分布式数据库，包含完全限定域名和地址之间的映射。DNS 使用客户端-服务器模型。客户端是需要检索给定名称映射的主机或应用程序。每个
    [域名服务器](../glossary.html#term-nameserver) 存储分布式数据库的一部分，并回答客户端发送的查询。每个域至少有一个 [域名服务器](../glossary.html#term-nameserver)。在下图中，域由圆圈表示，域
    dom 内有三个主机（h1、h2 和 h3），域 a.sdom1.dom 内有三个主机。如图所示，子域可能包含主机名和子域。
- en: '![Figure made with TikZ](../Images/7989bbb8be7d75c8e85246fc80c86c13.png)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/7989bbb8be7d75c8e85246fc80c86c13.png)'
- en: Fig. 24 A simple tree of domain names
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 图 24 域名的一个简单树结构
- en: 'A [nameserver](../glossary.html#term-nameserver) that is responsible for domain
    dom can directly answer the following queries :'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 负责域 dom 的 [域名服务器](../glossary.html#term-nameserver) 可以直接回答以下查询：
- en: the address of any host residing directly inside domain dom (e.g. h2.dom in
    the figure above)
  id: totrans-712
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接位于域 dom 内的任何主机的地址（例如，上图中的 h2.dom）
- en: ''
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-714
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the nameserver(s) that are responsible for any direct sub-domain of domain dom
    (i.e. sdom1.dom and sdom2.dom in the figure above, but not z.sdom1.dom)
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责域 dom 任何直接子域的域名服务器（即上图中的 sdom1.dom 和 sdom2.dom，但不包括 z.sdom1.dom）
- en: To retrieve the mapping for host h2.dom, a client sends its query to the name
    server that is responsible for the domain .dom. The name server directly answers
    the query. To retrieve a mapping for h3.a.sdom1.dom, a DNS client first sends
    a query to the name server that is responsible for the .dom domain. This nameserver
    returns the nameserver that is responsible for the sdom1.dom domain. This nameserver
    can now be contacted to obtain the nameserver that is responsible for the a.sdom1.dom
    domain. This nameserver can be contacted to retrieve the mapping for the h3.a.sdom1.dom
    name. Thanks to this structure, it is possible for a DNS client to obtain the
    mapping of any host inside the .dom domain or any of its subdomains. To ensure
    that any DNS client will be able to resolve any fully qualified domain name, there
    are special nameservers that are responsible for the root of the domain name hierarchy.
    These nameservers are called [root nameserver](../glossary.html#term-root-nameserver).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索主机 h2.dom 的映射，客户端将其查询发送给负责 .dom 域的域名服务器。域名服务器直接回答查询。要检索 h3.a.sdom1.dom 的映射，DNS
    客户端首先向负责 .dom 域的域名服务器发送查询。此域名服务器返回负责 sdom1.dom 域域的域名服务器。现在可以通过联系此域名服务器来获取负责 a.sdom1.dom
    域域的域名服务器。可以通过联系此域名服务器来检索 h3.a.sdom1.dom 名称的映射。多亏了这种结构，DNS 客户端可以获取 .dom 域域内或其任何子域内的任何主机的映射。为确保任何
    DNS 客户端都能解析任何完全限定的域名，存在负责域名层次结构根部的特殊域名服务器。这些域名服务器被称为 [根域名服务器](../glossary.html#term-root-nameserver)。
- en: Each root nameserver maintains the list [[6]](#froot) of all the nameservers
    that are responsible for each of the top-level domain names and their addresses
    [[7]](#frootv6). All root nameservers cooperate and provide the same answers.
    By querying any of the root nameservers, a DNS client can obtain the nameserver
    that is responsible for any top-level-domain name. From this nameserver, it is
    possible to resolve any domain name.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 每个根域名服务器维护所有顶级域名及其地址的域名服务器列表 [[6]](#froot)。所有根域名服务器合作并提供相同的答案。通过查询任何根域名服务器，DNS
    客户端可以获取负责任何顶级域名的域名服务器。从这个域名服务器，可以解析任何域名。
- en: 'To be able to contact the root nameservers, each DNS client must know their
    addresses. This implies that DNS clients must maintain an up-to-date list of the
    addresses of the root nameservers. Without this list, it is impossible to contact
    the root nameservers. Forcing all Internet hosts to maintain the most recent version
    of this list would be difficult from an operational point of view. To solve this
    problem, the designers of the DNS introduced a special type of DNS server : the
    DNS resolvers. A [resolver](../glossary.html#term-resolver) is a server that provides
    the name resolution service for a set of clients. A network usually contains a
    few resolvers. Each host in these networks is configured to send all its DNS queries
    via one of its local resolvers. These queries are called recursive queries as
    the [resolver](../glossary.html#term-resolver) must recursively send requests
    through the hierarchy of nameservers to obtain the answer.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够联系根名称服务器，每个 DNS 客户端都必须知道它们的地址。这意味着 DNS 客户端必须维护根名称服务器地址的最新列表。没有这个列表，就无法联系根名称服务器。强制所有互联网主机维护这个列表的最新版本在操作上会很困难。为了解决这个问题，DNS
    的设计者引入了一种特殊的 DNS 服务器类型：DNS 解析器。一个 [解析器](../glossary.html#term-resolver) 是为客户端集提供名称解析服务的服务器。通常，网络中包含几个解析器。这些网络中的每个主机都被配置为通过其本地解析器发送所有其
    DNS 查询。这些查询被称为递归查询，因为 [解析器](../glossary.html#term-resolver) 必须递归地向名称服务器层次结构发送请求以获取答案。
- en: DNS resolvers have several advantages over letting each Internet host query
    directly nameservers. Firstly, regular Internet hosts do not need to maintain
    the up-to-date list of the addresses of the root servers. Secondly, regular Internet
    hosts do not need to send queries to nameservers all over the Internet. Furthermore,
    as a DNS resolver serves a large number of hosts, it can cache the received answers.
    This allows the resolver to quickly return answers for popular DNS queries and
    reduces the load on all DNS servers [[JSBM2002]](../bibliography.html#jsbm2002).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 解析器相较于让每个互联网主机直接查询名称服务器，具有几个优势。首先，常规互联网主机无需维护根服务器地址的最新列表。其次，常规互联网主机无需向互联网上的所有名称服务器发送查询。此外，由于
    DNS 解析器为大量主机提供服务，它可以缓存收到的答案。这使得解析器能够快速返回常见 DNS 查询的答案，并减少所有 DNS 服务器的负载 [[JSBM2002]](../bibliography.html#jsbm2002)。
- en: Benefits of names[#](#benefits-of-names "Link to this heading")
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称的好处[#](#benefits-of-names "链接到这个标题")
- en: 'In addition to being more human-friendly, using names instead of addresses
    inside applications has several important benefits. To understand them, let us
    consider a popular application that provides information stored on servers. This
    application involves clients and servers. The server provides information upon
    requests from client processes. A first deployment of this application would be
    to rely only on addresses. In this case, the server process would be installed
    on one host, and the clients would connect to this server to retrieve information.
    Such a deployment has several drawbacks :'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更符合人类习惯外，在应用程序中使用名称而不是地址还有几个重要的好处。为了理解这些好处，让我们考虑一个提供存储在服务器上的信息的流行应用程序。这个应用程序涉及客户端和服务器。服务器根据客户端进程的请求提供信息。该应用程序的第一个部署将仅依赖于地址。在这种情况下，服务器进程将安装在单个主机上，客户端将连接到该服务器以检索信息。这种部署存在几个缺点：
- en: if the server process moves to another physical server, all clients must be
    informed about the new server address.
  id: totrans-722
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器进程转移到另一个物理服务器，所有客户端都必须被告知新的服务器地址。
- en: ''
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-724
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: if there are many concurrent clients, the load of the server will increase without
    any possibility of adding another server without changing the server addresses
    used by the clients.
  id: totrans-725
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有大量并发客户端，服务器负载将增加，而没有任何可能添加另一个服务器而不改变客户端使用的服务器地址。
- en: Using names solves these problems and provides additional benefits. If the clients
    are configured with the name of the server, they will query the name service before
    contacting the server. The name service will resolve the name into the corresponding
    address. If a server process needs to move from one physical server to another,
    it suffices to update the name-to-address mapping on the name service to allow
    all clients to connect to the new server. The name service also enables the servers
    to better sustain the load. Assume a very popular server which is accessed by
    millions of users. This service cannot be provided by a single physical server
    due to performance limitations. Thanks to the utilization of names, it is possible
    to scale this service by mapping a given name to a set of addresses. When a client
    queries the name service for the server’s name, the name service returns one of
    the addresses in the set. Various strategies can be used to select one particular
    address inside the set of addresses. A first strategy is to select a random address
    in the set. A second strategy is to maintain information about the load on the
    servers and return the address of the less loaded server. Note that the list of
    server addresses does not need to remain fixed. It is possible to add and remove
    addresses from the list to cope with load fluctuations. Another strategy is to
    infer the location of the client from the name request and return the address
    of the closest server.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称解决了这些问题，并提供了额外的优势。如果客户端配置了服务器的名称，它们在联系服务器之前将查询名称服务。名称服务会将名称解析为相应的地址。如果一个服务器进程需要从一个物理服务器移动到另一个服务器，只需更新名称服务中的名称到地址映射，就可以允许所有客户端连接到新的服务器。名称服务还使服务器能够更好地承受负载。假设有一个非常受欢迎的服务器，被数百万用户访问。由于性能限制，单个物理服务器无法提供这项服务。得益于名称的使用，可以将给定的名称映射到一组地址，从而实现服务的扩展。当客户端查询名称服务以获取服务器的名称时，名称服务会返回该组地址中的一个。可以使用各种策略来选择地址集中的特定地址。第一种策略是在集合中随机选择一个地址。第二种策略是维护关于服务器负载的信息，并返回负载较轻的服务器的地址。请注意，服务器地址列表不需要保持固定。可以添加和删除地址以应对负载波动。另一种策略是从名称请求中推断客户端的位置，并返回最近的服务器地址。
- en: Mapping a single name onto a set of addresses allows popular servers to dynamically
    scale. There are also benefits in mapping multiple names, possibly a large number
    of them, onto a single address. Consider the case of information servers run by
    individuals or SMEs. Some of these servers attract only a few clients per day.
    Using a single physical server for each of these services would be a waste of
    resources. A better approach is to use a single server for a set of services that
    are all identified by different names. This enables service providers to support
    a large number of server processes, identified by different names, onto a single
    physical server. If one of these server processes becomes very popular, it will
    be possible to map its name onto a set of addresses to be able to sustain the
    load. There are some deployments where this mapping is done dynamically in function
    of the load.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个名称映射到一组地址允许热门服务器动态扩展。将多个名称，可能是一大批名称，映射到单个地址也有好处。考虑个人或中小企业运行的信息服务器的情况。其中一些服务器每天只吸引少量客户端。为每个这样的服务使用单个物理服务器将是资源的浪费。更好的方法是使用单个服务器为多个服务提供服务，这些服务都由不同的名称识别。这使得服务提供商能够在单个物理服务器上支持大量由不同名称识别的服务器进程。如果这些服务器进程中的任何一个变得非常受欢迎，就可以将其名称映射到一组地址，以承受负载。在某些部署中，这种映射是动态进行的，取决于负载。
- en: Names provide a lot of flexibility compared to addresses. For the network, they
    play a similar role as variables in programming languages. No programmer using
    a high-level programming language would consider using hardcoded values instead
    of variables. For the same reasons, all networked applications should depend on
    names and avoid dealing with addresses as much as possible.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于地址，名称提供了很多灵活性。对于网络来说，它们在编程语言中的角色类似于变量。没有程序员会考虑在高级编程语言中使用硬编码的值而不是变量。出于同样的原因，所有网络应用程序都应依赖于名称，并尽可能避免处理地址。
- en: '### The Domain Name System[#](#the-domain-name-system "Link to this heading")'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '### 域名系统[#](#the-domain-name-system "链接到这个标题")'
- en: The last component of the Domain Name System is the DNS protocol. The original
    DNS protocol runs above both the datagram and the bytestream services. In practice,
    the datagram service is used when short queries and responses are exchanged, and
    the bytestream service is used when longer responses are expected. In this section,
    we first focus on the utilization of the DNS protocol above the datagram service.
    We will discuss later other recently proposed protocols to carry DNS information.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统（DNS）的最后一部分是DNS协议。原始DNS协议在数据报和字节流服务之上运行。在实践中，当交换短查询和响应时使用数据报服务，当期望更长的响应时使用字节流服务。在本节中，我们首先关注在数据报服务之上DNS协议的利用。我们将在稍后讨论其他最近提出的用于携带DNS信息的协议。
- en: DNS messages are composed of five parts that are named sections in RFC :1035.
    The first three sections are mandatory, and the last two sections are optional.
    The first section of a DNS message is its Header. It contains information about
    the message type and the content of the other sections. The second section contains
    the Question sent to the nameserver or resolver. The third section contains the
    Answer to the Question. When a client sends a DNS query, the Answer section is
    empty. The fourth section, named Authority, contains information about the servers
    that can provide an authoritative answer if required. The last section contains
    additional information that is supplied by the resolver or nameserver but was
    not requested in the question.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: DNS消息由RFC 1035中命名的五个部分组成。前三个部分是必需的，最后两个部分是可选的。DNS消息的第一个部分是其头部。它包含有关消息类型和其他部分内容的信息。第二部分包含发送给名称服务器或解析器的查询。第三部分包含对查询的答案。当客户端发送DNS查询时，答案部分为空。第四部分，称为授权部分，包含有关可以提供权威答案的服务器信息。最后一部分包含由解析器或名称服务器提供但未在问题中请求的附加信息。
- en: The header of DNS messages is composed of 12 bytes. The figure below presents
    its structure.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: DNS消息的头部由12个字节组成。下面的图展示了其结构。
- en: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '![dnsheader](../Images/21a7bad41190434264bf8afe39a2de6a.png)'
- en: Fig. 25 The DNS header[#](#id54 "Link to this image")
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 图25 DNS头部[#](#id54 "链接到这张图片")
- en: The Transaction ID (transaction identifier) is a 16-bit random value chosen
    by the client. When a client sends a question to a DNS server, it remembers the
    question and its identifier. When a server returns an answer, it returns in the
    Transaction ID field the identifier chosen by the client. Thanks to this identifier,
    the client can match the received answer with the question that it sent.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 事务ID（事务标识符）是客户端选择的一个16位随机值。当客户端向DNS服务器发送一个问题，它会记住问题和其标识符。当服务器返回答案时，它在事务ID字段返回客户端选择的标识符。多亏了这个标识符，客户端可以将接收到的答案与其发送的问题匹配。
- en: The DNS header contains a series of flags. The QR flag is used to distinguish
    between queries and responses. It is set to 0 in DNS queries and 1 in DNS answers.
    The Opcode is used to specify the query type. For instance, a [standard query](../glossary.html#term-standard-query)
    is used when a client sends a name and the server returns the corresponding data.
    An update request is used when the client sends a name and new data, and the server
    then updates its database.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: DNS头部包含一系列标志。QR标志用于区分查询和响应。在DNS查询中，它被设置为0，在DNS响应中设置为1。操作码用于指定查询类型。例如，当客户端发送一个名称并且服务器返回相应的数据时，使用[标准查询](../glossary.html#term-standard-query)。当客户端发送名称和新数据时，使用更新请求，并且服务器随后更新其数据库。
- en: 'The AA bit is set when the server that sent the response has authority for
    the domain name found in the question section. In the original DNS deployments,
    two types of servers were considered : authoritative servers and non-authoritative
    servers. The authoritative servers are managed by the system administrators responsible
    for a given domain. They always store the most recent information about a domain.
    Non-authoritative servers are servers or resolvers that store DNS information
    about external domains without being managed by the owners of a domain. They may
    thus provide answers that are out of date. From a security point of view, the
    authoritative bit is not an absolute indication about the validity of an answer.
    Securing the Domain Name System is a complex problem that was only addressed satisfactorily
    recently by the utilization of cryptographic signatures in the DNSSEC extensions
    to DNS described in : RFC:4033.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送响应的服务器对问题部分中找到的域名具有权威性时，会设置AA位。在原始DNS部署中，考虑了两种类型的服务器：权威服务器和非权威服务器。权威服务器由负责特定域的系统管理员管理。它们始终存储有关域的最新信息。非权威服务器是存储关于外部域的DNS信息但不由域所有者管理的服务器或解析器。因此，它们可能提供过时的答案。从安全角度来看，权威位并不是关于答案有效性的绝对指示。确保域名系统的安全是一个复杂的问题，直到最近才通过在DNSSEC扩展中利用加密签名在RFC:4033中描述的DNS中得到了满意的解决。
- en: 'The RD (recursion desired) bit is set by a client when it sends a query to
    a resolver. Such a query is said to be recursive because the resolver will recursively
    traverse the DNS hierarchy to retrieve the answer on behalf of the client. In
    the past, all resolvers were configured to perform recursive queries on behalf
    of any Internet host. However, this exposes the resolvers to several security
    risks. The simplest one is that the resolver could become overloaded by having
    too many recursive queries to process. Most resolvers [[8]](#f8888) only allow
    recursive queries from clients belonging to their company or network and discard
    all other recursive queries. The RA bit indicates whether the server supports
    recursion. The RCODE is used to distinguish between different types of errors.
    See : RFC:1035 for additional details. The last four fields indicate the size
    of the Question, Answer, Authority, and Additional sections of the DNS message.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向解析器发送查询时，会设置RD（递归所需）位。这种查询被称为递归查询，因为解析器将递归遍历DNS层次结构以代表客户端检索答案。在过去，所有解析器都被配置为代表任何互联网主机执行递归查询。然而，这使解析器面临多个安全风险。最简单的一个是解析器可能会因为处理过多的递归查询而变得过载。大多数解析器[8](#f8888)只允许来自其公司或网络的客户端进行递归查询，并丢弃所有其他递归查询。RA位指示服务器是否支持递归。RCODE用于区分不同类型的错误。有关详细信息，请参阅：RFC:1035。最后四个字段表示DNS消息中问题、答案、授权和附加部分的尺寸。
- en: The last four sections of the DNS message contain Resource Records (RR). All
    RRs have the same top-level format shown in the figure below.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: DNS消息的最后四个部分包含资源记录（RR）。所有RR都具有以下图中所示的同级格式。
- en: '[![../_images/dnsrr.svg](../Images/a838af70f19f03e6cc3645b1c9e8591e.png)](../_images/dnsrr.svg)'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/dnsrr.svg](../Images/a838af70f19f03e6cc3645b1c9e8591e.png)'
- en: Fig. 26 DNS Resource Records[#](#id55 "Link to this image")
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 图26 DNS资源记录[#](#id55 "链接到此图像")
- en: In a Resource Record (RR), the Name indicates the name of the node to which
    this resource record pertains. The two-byte Type field indicates the type of resource
    record. The Class field was used to support the utilization of the DNS in other
    environments than the Internet. The IN Class refers to Internet names.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源记录（RR）中，名称指示与该资源记录相关的节点名称。两个字节的类型字段指示资源记录的类型。类字段用于支持在除互联网以外的环境中使用DNS。IN类指的是互联网名称。
- en: The TTL field indicates the lifetime of the Resource Record in seconds. This
    field is set by the server that returns an answer and indicates for how long a
    client or a resolver can store the Resource Record inside its cache. A long TTL
    indicates a stable RR. Some companies use short TTL values for mobile hosts and
    also for popular servers. For example, a web hosting company that wants to spread
    the load over a pool of hundred servers can configure its nameservers to return
    different answers to different clients. If each answer has a small TTL, the clients
    will be forced to send DNS queries regularly. The nameserver will reply to these
    queries by supplying the address of the less loaded server.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: TTL字段表示资源记录的生命周期（以秒为单位）。该字段由返回答案的服务器设置，并指示客户端或解析器可以在其缓存中存储资源记录多长时间。较长的TTL表示稳定的RR。一些公司为移动主机和流行的服务器使用较短的TTL值。例如，一家希望将负载分散在一百台服务器池中的网络托管公司可以配置其名称服务器向不同客户端返回不同的答案。如果每个答案都有一个小的TTL，客户端将被迫定期发送DNS查询。名称服务器将通过提供较轻负载服务器的地址来回复这些查询。
- en: The RDLength field is the length of the RData field that contains the information
    of the type specified in the Type field.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: RDLength字段是包含在Type字段中指定的类型信息的RData字段的长度。
- en: 'Several types of DNS RR are used in practice. The A type encodes the IPv4 address
    that corresponds to the specified name. The AAAA type encodes the IPv6 address
    that corresponds to the specified name. A NS record contains the name of the DNS
    server that is responsible for a given domain. For example, a query for the AAAA
    record associated with the www.ietf.org name returned the following answer:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用中使用了多种DNS RR类型。A类型编码与指定名称相对应的IPv4地址。AAAA类型编码与指定名称相对应的IPv6地址。NS记录包含负责给定域的DNS服务器的名称。例如，查询与www.ietf.org名称关联的AAAA记录返回以下答案：
- en: '![../_images/dns6-www-ietf-org.svg](../Images/2a132b4acb2d03e996f683289606e16b.png)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/dns6-www-ietf-org.svg](../Images/2a132b4acb2d03e996f683289606e16b.png)'
- en: Fig. 27 Query for the AAAA record of www.ietf.org[#](#id56 "Link to this image")
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 图27 查询www.ietf.org的AAAA记录[#](#id56 "链接到此图像")
- en: This answer contains several pieces of information. First, the name www.ietf.org
    is associated with the IP address 2001:1890:123a::1:1e. Second, the ietf.org domain
    is managed by six different nameservers. Five of these nameservers are reachable
    via IPv4 and IPv6.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 此答案包含多个信息片段。首先，名称www.ietf.org与IP地址2001:1890:123a::1:1e相关联。其次，ietf.org域名由六个不同的名称服务器管理。其中五个名称服务器可以通过IPv4和IPv6访问。
- en: CNAME (or canonical names) are used to define aliases. For example, www.example.com
    could be a CNAME for pc12.example.com, which is the actual name of the server
    on which the web server for www.example.com runs.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: CNAME（或规范名称）用于定义别名。例如，www.example.com可以是pc12.example.com的CNAME，后者是运行www.example.com的Web服务器的实际名称。
- en: Note
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reverse DNS
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 反向DNS
- en: 'The DNS is mainly used to find the address that corresponds to a given name.
    However, it is sometimes useful to obtain the name that corresponds to an IP address.
    This is done by using the PTR (pointer) RR. The RData part of a PTR RR contains
    the name while the Name part of the RR contains the IP address encoded in the
    in-addr.arpa domain. IPv4 addresses are encoded in the in-addr.arpa by reversing
    the four digits that compose the dotted decimal representation of the address.
    For example, consider IPv4 address 192.0.2.11. The hostname associated to this
    address can be found by requesting the PTR RR that corresponds to 11.2.0.192.in-addr.arpa.
    A similar solution is used to support IPv6 addresses : RFC:3596, but slightly
    more complex given the length of the IPv6 addresses. For example, consider IPv6
    address 2001:1890:123a::1:1e. To obtain the name that corresponds to this address,
    we need first to convert it in a reverse dotted decimal notation : e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.
    In this notation, each character between dots corresponds to one nibble, i.e.
    four bits. The low-order byte (e) appears first and the high order (2) last. To
    obtain the name that corresponds to this address, one needs to append the ip6.arpa
    domain name and query for e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa.
    In practice, tools and libraries do the conversion automatically and the user
    does not need to worry about it.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: DNS主要用于查找与给定名称相对应的地址。然而，有时获取与IP地址相对应的名称也是有用的。这是通过使用PTR（指针）RR来完成的。PTR RR的RData部分包含名称，而RR的Name部分包含编码在in-addr.arpa域中的IP地址。IPv4地址通过反转组成地址点分十进制表示的四个数字来编码在in-addr.arpa中。例如，考虑IPv4地址192.0.2.11。与该地址关联的主机名可以通过请求对应于11.2.0.192.in-addr.arpa的PTR
    RR来找到。类似的解决方案用于支持IPv6地址：RFC:3596，但考虑到IPv6地址的长度，这稍微复杂一些。例如，考虑IPv6地址2001:1890:123a::1:1e。为了获取与该地址相对应的名称，我们首先需要将其转换为反向点分十进制表示：e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2。在这个表示法中，每个点之间的每个字符对应一个四分位，即四个比特。最低有效字节（e）首先出现，最高有效字节（2）最后出现。为了获取与该地址相对应的名称，需要将ip6.arpa域名追加到后面，并查询e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa。在实际应用中，工具和库会自动进行转换，用户无需担心。
- en: An important point to note regarding the Domain Name System is that it is extensible.
    Thanks to the Type and RDLength fields, the format of the Resource Records can
    easily be extended. Furthermore, a DNS implementation that receives a new Resource
    Record that it does not understand can ignore the record while still being able
    to process the other parts of the message. This allows, for example, a DNS server
    that only supports IPv6 to safely ignore the IPv4 addresses listed in the DNS
    reply for www.ietf.org while still being able to correctly parse the Resource
    Records that it understands. This allowed the Domain Name System to evolve over
    the years while still preserving the backward compatibility with already deployed
    DNS implementations.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 关于域名系统的一个重要点是它是可扩展的。多亏了类型和RDLength字段，资源记录的格式可以很容易地扩展。此外，一个接收了它不理解的新资源记录的DNS实现可以忽略该记录，同时仍然能够处理消息的其他部分。例如，一个仅支持IPv6的DNS服务器可以安全地忽略DNS回复中列出的IPv4地址，同时仍然能够正确解析它理解的资源记录。这使得域名系统在多年间得以演变，同时仍然与已部署的DNS实现保持向后兼容。
- en: Benefits of names[#](#benefits-of-names "Link to this heading")
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用名称而不是地址的优点[#](#benefits-of-names "链接到这个标题")
- en: 'In addition to being more human-friendly, using names instead of addresses
    inside applications has several important benefits. To understand them, let us
    consider a popular application that provides information stored on servers. This
    application involves clients and servers. The server provides information upon
    requests from client processes. A first deployment of this application would be
    to rely only on addresses. In this case, the server process would be installed
    on one host, and the clients would connect to this server to retrieve information.
    Such a deployment has several drawbacks :'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更符合人类习惯之外，在应用程序中使用名称而不是地址还有几个重要的好处。为了理解这些好处，让我们考虑一个流行的应用程序，该应用程序提供存储在服务器上的信息。这个应用程序涉及客户端和服务器。服务器根据客户端进程的请求提供信息。这个应用程序的首次部署将仅依赖于地址。在这种情况下，服务器进程将安装在单个主机上，客户端将连接到该服务器以检索信息。这种部署有几个缺点：
- en: if the server process moves to another physical server, all clients must be
    informed about the new server address.
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器进程转移到另一个物理服务器，所有客户端都必须被告知新的服务器地址。
- en: ''
  id: totrans-757
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-758
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: if there are many concurrent clients, the load of the server will increase without
    any possibility of adding another server without changing the server addresses
    used by the clients.
  id: totrans-759
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有大量的并发客户端，服务器负载将增加，而没有任何可能在不更改客户端使用的服务器地址的情况下添加另一个服务器。
- en: Using names solves these problems and provides additional benefits. If the clients
    are configured with the name of the server, they will query the name service before
    contacting the server. The name service will resolve the name into the corresponding
    address. If a server process needs to move from one physical server to another,
    it suffices to update the name-to-address mapping on the name service to allow
    all clients to connect to the new server. The name service also enables the servers
    to better sustain the load. Assume a very popular server which is accessed by
    millions of users. This service cannot be provided by a single physical server
    due to performance limitations. Thanks to the utilization of names, it is possible
    to scale this service by mapping a given name to a set of addresses. When a client
    queries the name service for the server’s name, the name service returns one of
    the addresses in the set. Various strategies can be used to select one particular
    address inside the set of addresses. A first strategy is to select a random address
    in the set. A second strategy is to maintain information about the load on the
    servers and return the address of the less loaded server. Note that the list of
    server addresses does not need to remain fixed. It is possible to add and remove
    addresses from the list to cope with load fluctuations. Another strategy is to
    infer the location of the client from the name request and return the address
    of the closest server.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称解决了这些问题，并提供了额外的优势。如果客户端配置了服务器的名称，它们将在联系服务器之前查询名称服务。名称服务将解析名称为相应的地址。如果服务器进程需要从一个物理服务器移动到另一个物理服务器，只需更新名称服务上的名称到地址映射，就可以允许所有客户端连接到新的服务器。名称服务还使服务器能够更好地承受负载。假设有一个非常受欢迎的服务器，被数百万用户访问。由于性能限制，这项服务不能由单个物理服务器提供。得益于名称的使用，可以通过将给定的名称映射到一组地址来扩展这项服务。当客户端查询名称服务以获取服务器的名称时，名称服务返回该组中的一个地址。可以使用各种策略来选择地址集中的特定地址。第一种策略是在集合中随机选择一个地址。第二种策略是维护有关服务器负载的信息，并返回负载较轻的服务器的地址。请注意，服务器地址列表不需要保持固定。可以添加和删除地址以应对负载波动。另一种策略是从名称请求中推断客户端的位置，并返回最近的服务器地址。
- en: Mapping a single name onto a set of addresses allows popular servers to dynamically
    scale. There are also benefits in mapping multiple names, possibly a large number
    of them, onto a single address. Consider the case of information servers run by
    individuals or SMEs. Some of these servers attract only a few clients per day.
    Using a single physical server for each of these services would be a waste of
    resources. A better approach is to use a single server for a set of services that
    are all identified by different names. This enables service providers to support
    a large number of server processes, identified by different names, onto a single
    physical server. If one of these server processes becomes very popular, it will
    be possible to map its name onto a set of addresses to be able to sustain the
    load. There are some deployments where this mapping is done dynamically in function
    of the load.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个名称映射到一组地址允许流行的服务器动态扩展。将多个名称，可能是一大批名称，映射到单个地址也有好处。考虑个人或中小企业运行的信息服务器的情况。其中一些服务器每天只吸引少数客户端。为每个这样的服务使用单个物理服务器将是资源的浪费。更好的方法是使用单个服务器为一系列由不同名称标识的服务提供服务。这使得服务提供商能够在单个物理服务器上支持大量由不同名称标识的服务进程。如果这些服务进程中的任何一个变得非常受欢迎，就可以将其名称映射到一组地址，以能够承受负载。在一些部署中，这种映射是动态地在负载函数下进行的。
- en: Names provide a lot of flexibility compared to addresses. For the network, they
    play a similar role as variables in programming languages. No programmer using
    a high-level programming language would consider using hardcoded values instead
    of variables. For the same reasons, all networked applications should depend on
    names and avoid dealing with addresses as much as possible.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 与地址相比，名称提供了更多的灵活性。对于网络来说，它们在编程语言中的角色类似于变量。任何使用高级编程语言的程序员都不会考虑使用硬编码的值而不是变量。出于同样的原因，所有网络应用程序都应该依赖于名称，并尽可能避免处理地址。
- en: '### The Domain Name System[#](#the-domain-name-system "Link to this heading")'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '### 域名系统[#](#the-domain-name-system "链接到这个标题")'
- en: The last component of the Domain Name System is the DNS protocol. The original
    DNS protocol runs above both the datagram and the bytestream services. In practice,
    the datagram service is used when short queries and responses are exchanged, and
    the bytestream service is used when longer responses are expected. In this section,
    we first focus on the utilization of the DNS protocol above the datagram service.
    We will discuss later other recently proposed protocols to carry DNS information.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统（DNS）的最后一部分是 DNS 协议。原始的 DNS 协议运行在数据报和字节流服务之上。在实践中，当交换短查询和响应时使用数据报服务，而当期望更长的响应时使用字节流服务。在本节中，我们首先关注在数据报服务之上
    DNS 协议的利用。我们将在稍后讨论其他最近提出的用于携带 DNS 信息的协议。
- en: DNS messages are composed of five parts that are named sections in RFC :1035.
    The first three sections are mandatory, and the last two sections are optional.
    The first section of a DNS message is its Header. It contains information about
    the message type and the content of the other sections. The second section contains
    the Question sent to the nameserver or resolver. The third section contains the
    Answer to the Question. When a client sends a DNS query, the Answer section is
    empty. The fourth section, named Authority, contains information about the servers
    that can provide an authoritative answer if required. The last section contains
    additional information that is supplied by the resolver or nameserver but was
    not requested in the question.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 消息由五个部分组成，在 RFC 1035 中被称为部分：前三个部分是必需的，后两个部分是可选的。DNS 消息的第一个部分是其头部。它包含有关消息类型和其他部分内容的信息。第二个部分包含发送给名称服务器或解析器的查询。第三个部分包含对查询的答案。当客户端发送
    DNS 查询时，答案部分是空的。第四个部分，称为授权部分，包含有关可以提供权威答案的服务器的信息。最后一部分包含由解析器或名称服务器提供但未在问题中请求的附加信息。
- en: The header of DNS messages is composed of 12 bytes. The figure below presents
    its structure.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 消息的头部由 12 个字节组成。下面的图展示了其结构。
- en: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/dnsheader.svg](../Images/21a7bad41190434264bf8afe39a2de6a.png)](../_images/dnsheader.svg)'
- en: Fig. 25 The DNS header[#](#id54 "Link to this image")
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25 DNS 头部[#](#id54 "链接到这张图片")
- en: The Transaction ID (transaction identifier) is a 16-bit random value chosen
    by the client. When a client sends a question to a DNS server, it remembers the
    question and its identifier. When a server returns an answer, it returns in the
    Transaction ID field the identifier chosen by the client. Thanks to this identifier,
    the client can match the received answer with the question that it sent.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 事务 ID（事务标识符）是由客户端选择的 16 位随机值。当客户端向 DNS 服务器发送一个查询时，它会记住查询及其标识符。当服务器返回一个答案时，它会在事务
    ID 字段中返回客户端选择的标识符。多亏了这个标识符，客户端可以将其收到的答案与它发送的查询匹配。
- en: The DNS header contains a series of flags. The QR flag is used to distinguish
    between queries and responses. It is set to 0 in DNS queries and 1 in DNS answers.
    The Opcode is used to specify the query type. For instance, a [standard query](../glossary.html#term-standard-query)
    is used when a client sends a name and the server returns the corresponding data.
    An update request is used when the client sends a name and new data, and the server
    then updates its database.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 头部包含一系列标志。QR 标志用于区分查询和响应。在 DNS 查询中它被设置为 0，在 DNS 答案中设置为 1。操作码用于指定查询类型。例如，当客户端发送一个名称并且服务器返回相应的数据时，使用标准查询（[standard
    query](../glossary.html#term-standard-query)）。当客户端发送一个名称和新数据，并且服务器随后更新其数据库时，使用更新请求。
- en: 'The AA bit is set when the server that sent the response has authority for
    the domain name found in the question section. In the original DNS deployments,
    two types of servers were considered : authoritative servers and non-authoritative
    servers. The authoritative servers are managed by the system administrators responsible
    for a given domain. They always store the most recent information about a domain.
    Non-authoritative servers are servers or resolvers that store DNS information
    about external domains without being managed by the owners of a domain. They may
    thus provide answers that are out of date. From a security point of view, the
    authoritative bit is not an absolute indication about the validity of an answer.
    Securing the Domain Name System is a complex problem that was only addressed satisfactorily
    recently by the utilization of cryptographic signatures in the DNSSEC extensions
    to DNS described in : RFC:4033.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应服务器对问题部分中找到的域名具有权威性时，AA 位被设置。在原始 DNS 部署中，考虑了两种类型的服务器：权威服务器和非权威服务器。权威服务器由负责特定域的系统管理员管理。它们始终存储有关域的最新信息。非权威服务器是存储关于外部域的
    DNS 信息但不受域所有者管理的服务器或解析器。因此，它们可能提供过时的答案。从安全角度来看，权威位并不是关于答案有效性的绝对指示。保护域名系统是一个复杂的问题，直到最近才通过在
    DNSSEC 扩展中利用加密签名得到满意的解决，这些扩展在 RFC:4033 中描述。
- en: 'The RD (recursion desired) bit is set by a client when it sends a query to
    a resolver. Such a query is said to be recursive because the resolver will recursively
    traverse the DNS hierarchy to retrieve the answer on behalf of the client. In
    the past, all resolvers were configured to perform recursive queries on behalf
    of any Internet host. However, this exposes the resolvers to several security
    risks. The simplest one is that the resolver could become overloaded by having
    too many recursive queries to process. Most resolvers [[8]](#f8888) only allow
    recursive queries from clients belonging to their company or network and discard
    all other recursive queries. The RA bit indicates whether the server supports
    recursion. The RCODE is used to distinguish between different types of errors.
    See : RFC:1035 for additional details. The last four fields indicate the size
    of the Question, Answer, Authority, and Additional sections of the DNS message.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '当客户端向解析器发送查询时，RD（递归所需）位由客户端设置。这种查询被称为递归查询，因为解析器将递归遍历 DNS 层次结构以代表客户端检索答案。在过去，所有解析器都被配置为代表任何互联网主机执行递归查询。然而，这使解析器面临多种安全风险。最简单的一种是解析器可能会因为处理过多的递归查询而超载。大多数解析器
    [[8]](#f8888) 只允许来自其公司或网络客户端的递归查询，并丢弃所有其他递归查询。RA 位指示服务器是否支持递归。RCODE 用于区分不同类型的错误。有关详细信息，请参阅
    : RFC:1035。最后四个字段指示 DNS 消息的问题、答案、权威和附加部分的尺寸。'
- en: The last four sections of the DNS message contain Resource Records (RR). All
    RRs have the same top-level format shown in the figure below.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 消息的最后四个部分包含资源记录 (RR)。所有 RR 都具有以下图中所示的同级格式。
- en: '[![../_images/dnsrr.svg](../Images/a838af70f19f03e6cc3645b1c9e8591e.png)](../_images/dnsrr.svg)'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/dnsrr.svg](../Images/a838af70f19f03e6cc3645b1c9e8591e.png)'
- en: Fig. 26 DNS Resource Records[#](#id55 "Link to this image")
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26 DNS 资源记录[#](#id55 "链接到这张图片")
- en: In a Resource Record (RR), the Name indicates the name of the node to which
    this resource record pertains. The two-byte Type field indicates the type of resource
    record. The Class field was used to support the utilization of the DNS in other
    environments than the Internet. The IN Class refers to Internet names.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源记录 (RR) 中，名称字段指示与该资源记录相关的节点名称。两个字节的类型字段指示资源记录的类型。类字段用于支持在除互联网以外的环境中使用 DNS。IN
    类指的是互联网名称。
- en: The TTL field indicates the lifetime of the Resource Record in seconds. This
    field is set by the server that returns an answer and indicates for how long a
    client or a resolver can store the Resource Record inside its cache. A long TTL
    indicates a stable RR. Some companies use short TTL values for mobile hosts and
    also for popular servers. For example, a web hosting company that wants to spread
    the load over a pool of hundred servers can configure its nameservers to return
    different answers to different clients. If each answer has a small TTL, the clients
    will be forced to send DNS queries regularly. The nameserver will reply to these
    queries by supplying the address of the less loaded server.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: TTL字段表示资源记录的生命周期（以秒为单位）。此字段由返回答案的服务器设置，并指示客户端或解析器可以在其缓存中存储资源记录多长时间。较长的TTL表示稳定的RR。一些公司为移动主机和热门服务器使用较短的TTL值。例如，一家希望将负载分散在一百台服务器池中的网络托管公司可以配置其名称服务器以向不同客户端返回不同的答案。如果每个答案都有一个小的TTL，客户端将被迫定期发送DNS查询。名称服务器将通过提供较不繁忙服务器的地址来回复这些查询。
- en: The RDLength field is the length of the RData field that contains the information
    of the type specified in the Type field.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: RDLength字段是包含在Type字段中指定类型信息的RData字段长度。
- en: 'Several types of DNS RR are used in practice. The A type encodes the IPv4 address
    that corresponds to the specified name. The AAAA type encodes the IPv6 address
    that corresponds to the specified name. A NS record contains the name of the DNS
    server that is responsible for a given domain. For example, a query for the AAAA
    record associated with the www.ietf.org name returned the following answer:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用中使用了多种类型的DNS RR（资源记录）。A类型编码与指定名称相对应的IPv4地址。AAAA类型编码与指定名称相对应的IPv6地址。NS记录包含负责特定域的DNS服务器的名称。例如，查询与www.ietf.org名称关联的AAAA记录返回以下答案：
- en: '![../_images/dns6-www-ietf-org.svg](../Images/2a132b4acb2d03e996f683289606e16b.png)'
  id: totrans-780
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/dns6-www-ietf-org.svg](../Images/2a132b4acb2d03e996f683289606e16b.png)'
- en: Fig. 27 Query for the AAAA record of www.ietf.org[#](#id56 "Link to this image")
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 图27 查询www.ietf.org的AAAA记录[#](#id56 "链接到此图像")
- en: This answer contains several pieces of information. First, the name www.ietf.org
    is associated with the IP address 2001:1890:123a::1:1e. Second, the ietf.org domain
    is managed by six different nameservers. Five of these nameservers are reachable
    via IPv4 and IPv6.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 此答案包含多个信息片段。首先，名称www.ietf.org与IP地址2001:1890:123a::1:1e相关联。其次，ietf.org域由六个不同的名称服务器管理。其中五个名称服务器可以通过IPv4和IPv6访问。
- en: CNAME (or canonical names) are used to define aliases. For example, www.example.com
    could be a CNAME for pc12.example.com, which is the actual name of the server
    on which the web server for www.example.com runs.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: CNAME（或规范名称）用于定义别名。例如，www.example.com可以是pc12.example.com的CNAME，后者是运行www.example.com网站服务器的实际名称。
- en: Note
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reverse DNS
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 反向DNS
- en: 'The DNS is mainly used to find the address that corresponds to a given name.
    However, it is sometimes useful to obtain the name that corresponds to an IP address.
    This is done by using the PTR (pointer) RR. The RData part of a PTR RR contains
    the name while the Name part of the RR contains the IP address encoded in the
    in-addr.arpa domain. IPv4 addresses are encoded in the in-addr.arpa by reversing
    the four digits that compose the dotted decimal representation of the address.
    For example, consider IPv4 address 192.0.2.11. The hostname associated to this
    address can be found by requesting the PTR RR that corresponds to 11.2.0.192.in-addr.arpa.
    A similar solution is used to support IPv6 addresses : RFC:3596, but slightly
    more complex given the length of the IPv6 addresses. For example, consider IPv6
    address 2001:1890:123a::1:1e. To obtain the name that corresponds to this address,
    we need first to convert it in a reverse dotted decimal notation : e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.
    In this notation, each character between dots corresponds to one nibble, i.e.
    four bits. The low-order byte (e) appears first and the high order (2) last. To
    obtain the name that corresponds to this address, one needs to append the ip6.arpa
    domain name and query for e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa.
    In practice, tools and libraries do the conversion automatically and the user
    does not need to worry about it.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 主要用于查找与给定名称相对应的地址。然而，有时获取与 IP 地址相对应的名称也是有用的。这可以通过使用 PTR（指针）RR 来实现。PTR RR
    的 RData 部分包含名称，而 RR 的 Name 部分包含编码在 in-addr.arpa 域中的 IP 地址。IPv4 地址通过反转组成地址点分十进制表示的四个数字来编码在
    in-addr.arpa 中。例如，考虑 IPv4 地址 192.0.2.11。与该地址关联的主机名可以通过请求对应于 11.2.0.192.in-addr.arpa
    的 PTR RR 来找到。类似的方法用于支持 IPv6 地址：RFC:3596，但由于 IPv6 地址的长度，这稍微复杂一些。例如，考虑 IPv6 地址 2001:1890:123a::1:1e。为了获取与该地址相对应的名称，我们首先需要将其转换为反向点分十进制表示：e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.在这个表示法中，每个点之间的每个字符对应一个四位的十六进制数，即四个比特。最低有效字节（e）首先出现，最高有效字节（2）最后出现。为了获取与该地址相对应的名称，需要将
    ip6.arpa 域名附加到后面，并查询 e.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.3.2.1.0.9.8.1.1.0.0.2.ip6.arpa。在实际应用中，工具和库会自动进行转换，用户无需担心。
- en: An important point to note regarding the Domain Name System is that it is extensible.
    Thanks to the Type and RDLength fields, the format of the Resource Records can
    easily be extended. Furthermore, a DNS implementation that receives a new Resource
    Record that it does not understand can ignore the record while still being able
    to process the other parts of the message. This allows, for example, a DNS server
    that only supports IPv6 to safely ignore the IPv4 addresses listed in the DNS
    reply for www.ietf.org while still being able to correctly parse the Resource
    Records that it understands. This allowed the Domain Name System to evolve over
    the years while still preserving the backward compatibility with already deployed
    DNS implementations.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 关于域名系统的一个重要观点是它是可扩展的。多亏了类型和 RDLength 字段，资源记录的格式可以很容易地扩展。此外，一个接收了它不理解的新资源记录的
    DNS 实现可以忽略该记录，同时仍然能够处理消息的其他部分。例如，一个仅支持 IPv6 的 DNS 服务器可以安全地忽略 DNS 回复中列出的 IPv4 地址，同时仍然能够正确解析它理解的资源记录。这使得域名系统在多年中得以发展，同时仍然与已经部署的
    DNS 实现保持向后兼容。
- en: '## Electronic mail[#](#electronic-mail "Link to this heading")'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '## 电子邮件[#](#electronic-mail "链接到本标题")'
- en: Electronic mail, or email, is a very popular application in computer networks
    such as the Internet. Email [appeared](http://openmap.bbn.com/~tomlinso/ray/firstemailframe.html)
    in the early 1970s and allows users to exchange text based messages. Initially,
    it was mainly used to exchange short messages, but over the years its usage has
    grown. It is now not only used to exchange small, but also long messages that
    can be composed of several parts as we will see later.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件，或称电子邮件，是计算机网络（如互联网）中一个非常流行的应用。电子邮件在 20 世纪 70 年代初出现，允许用户交换基于文本的消息。最初，它主要用于交换简短的消息，但经过多年的发展，其用途已经增长。现在，它不仅用于交换小的消息，还可以交换由多个部分组成的较长的消息，正如我们稍后将要看到的。
- en: Before looking at the details of Internet email, let us consider a simple scenario
    illustrated in [Fig. 28](#fig-email-arch), where Alice sends an email to Bob.
    Alice prepares her email by using an [email clients](https://en.wikipedia.org/wiki/Comparison_of_email_clients)
    and sends it to her email server. Alice’s [email server](http://en.wikipedia.org/wiki/Comparison_of_mail_servers)
    extracts Bob’s address from the email and delivers the message to Bob’s server.
    Bob retrieves Alice’s message on his server and reads it by using his favorite
    email client or through his webmail interface.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看互联网电子邮件的细节之前，让我们考虑一个如图28（#fig-email-arch）所示的简单场景，其中Alice向Bob发送电子邮件。Alice通过使用[电子邮件客户端](https://en.wikipedia.org/wiki/Comparison_of_email_clients)准备她的电子邮件并将其发送到她的电子邮件服务器。Alice的[电子邮件服务器](http://en.wikipedia.org/wiki/Comparison_of_mail_servers)从电子邮件中提取Bob的地址并将消息发送到Bob的服务器。Bob在他的服务器上检索Alice的消息并通过他最喜欢的电子邮件客户端或通过他的网络邮件界面阅读它。
- en: '![Figure made with TikZ](../Images/1de029c587cbf6cfd571cb993682463a.png)'
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/1de029c587cbf6cfd571cb993682463a.png)'
- en: ''
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 28 Simplified architecture of the Internet email
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图28互联网电子邮件的简化架构。
- en: 'The email system that we consider in this book is composed of four components
    :'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所考虑的电子邮件系统由四个组件组成：
- en: a message format, that defines how valid email messages are encoded
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个消息格式，它定义了有效电子邮件消息的编码方式。
- en: ''
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: protocols, that allow hosts and servers to exchange email messages
  id: totrans-798
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许主机和服务器交换电子邮件消息的协议。
- en: ''
  id: totrans-799
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: client software, that allows users to easily create and read email messages
  id: totrans-801
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户轻松创建和阅读电子邮件消息的客户端软件。
- en: ''
  id: totrans-802
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: software, that allows servers to efficiently exchange email messages
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许服务器高效交换电子邮件消息的软件。
- en: We first discuss the format of email messages followed by the protocols that
    are used on today’s Internet to exchange and retrieve emails. Other email systems
    have been developed in the past [[Bush1993]](../bibliography.html#bush1993) [[Genilloud1990]](../bibliography.html#genilloud1990)
    [[GC2000]](../bibliography.html#gc2000), but today most email solutions have migrated
    to the Internet email. Information about the software that is used to compose
    and deliver emails may be found on [wikipedia](https://en.wikipedia.org) among
    others, for both [email clients](https://en.wikipedia.org/wiki/Comparison_of_email_clients)
    and [email servers](http://en.wikipedia.org/wiki/Comparison_of_mail_servers).
    More detailed information about the full Internet Mail Architecture may be found
    in [**RFC 5598**](https://datatracker.ietf.org/doc/html/rfc5598.html).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论电子邮件消息的格式，然后讨论今天互联网上用于交换和检索电子邮件的协议。过去已经开发了其他电子邮件系统 [[Bush1993]](../bibliography.html#bush1993)
    [[Genilloud1990]](../bibliography.html#genilloud1990) [[GC2000]](../bibliography.html#gc2000)，但如今大多数电子邮件解决方案都已迁移到互联网电子邮件。有关用于编写和发送电子邮件的软件的信息，可以在[维基百科](https://en.wikipedia.org)等地方找到，包括[电子邮件客户端](https://en.wikipedia.org/wiki/Comparison_of_email_clients)和[电子邮件服务器](http://en.wikipedia.org/wiki/Comparison_of_mail_servers)。有关完整互联网邮件架构的更详细信息，可以在[**RFC
    5598**](https://datatracker.ietf.org/doc/html/rfc5598.html)中找到。
- en: 'Email messages, like postal mail, are composed of two parts :'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件消息，就像邮政邮件一样，由两部分组成：
- en: a header that plays the same role as the letterhead in regular mail. It contains
    metadata about the message.
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与普通邮件信头具有相同作用的标题。它包含有关消息的元数据。
- en: ''
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-809
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the body that contains the message itself.
  id: totrans-810
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含消息本身的正文。
- en: Email messages are entirely composed of lines of ASCII characters. Each line
    can contain up to 998 characters and is terminated by the CR and LF control characters
    [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html). The lines
    that compose the header appear before the message body. An empty line, containing
    only the CR and LF characters, marks the end of the header. This is illustrated
    in [Fig. 29](#fig-email-msg).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件消息完全由ASCII字符的行组成。每行可以包含多达998个字符，并以CR和LF控制字符结束 [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)。构成标题的行出现在消息正文之前。一个只包含CR和LF字符的空行标志着标题的结束。这如图29（#fig-email-msg）所示。
- en: '![Figure made with TikZ](../Images/8a178944414537a08bc98dae0cf87286.png)'
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8a178944414537a08bc98dae0cf87286.png)'
- en: ''
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 29 The structure of email messages
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图29电子邮件消息的结构。
- en: 'The email header contains several lines that all begin with a keyword followed
    by a colon and additional information. The format of email messages and the different
    types of header lines are defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html).
    Two of these header lines are mandatory and must appear in all email messages
    :'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件头部包含几行，所有这些行都以一个关键字后跟一个冒号和附加信息开始。电子邮件消息的格式和不同类型的头部行在 [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    中定义。其中两行是强制性的，必须在所有电子邮件消息中出现：
- en: The sender address. This header line starts with From:. This contains the (optional)
    name of the sender followed by its email address between < and >. Email addresses
    are always composed of a username followed by the @ sign and a domain name.
  id: totrans-816
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '发件人地址。此头部行以 From: 开头。它包含发件人的（可选）名称，后面是其电子邮件地址，位于 < 和 > 之间。电子邮件地址始终由用户名后跟 @
    符号和域名组成。'
- en: ''
  id: totrans-817
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-818
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The date. This header line starts with Date:. [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    precisely defines the format used to encode a date.
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '日期。此头部行以 Date: 开头。[**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    精确定义了编码日期所使用的格式。'
- en: 'Other header lines appear in most email messages. The Subject: header line
    allows the sender to indicate the topic discussed in the email. Three types of
    header lines can be used to specify the recipients of a message :'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '其他头部行出现在大多数电子邮件消息中。Subject: 头部行允许发件人指明电子邮件中讨论的主题。可以使用三种类型的头部行来指定消息的收件人：'
- en: 'the To: header line contains the email addresses of the primary recipients
    of the message [[10]](#fto). Several addresses can be separated by using commas.'
  id: totrans-821
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'To: 头部行包含消息的主要收件人的电子邮件地址 [[10]](#fto)。可以使用逗号分隔来列出多个地址。'
- en: ''
  id: totrans-822
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-823
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the cc: header line is used by the sender to provide a list of email addresses
    that must receive a carbon copy of the message. Several addresses can be listed
    in this header line, separated by commas. All recipients of the email message
    receive the To: and cc: header lines.'
  id: totrans-824
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'cc: 头部行由发件人使用，以提供必须接收消息副本的电子邮件地址列表。此头部行中可以列出多个地址，用逗号分隔。所有电子邮件消息的收件人都收到 To:
    和 cc: 头部行。'
- en: ''
  id: totrans-825
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-826
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the bcc: header line is used by the sender to provide a list of comma separated
    email addresses that must receive a blind carbon copy of the message. The bcc:
    header line is not delivered to the recipients of the email message.'
  id: totrans-827
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'bcc: 头部行由发件人使用，以提供必须接收消息盲碳副本的逗号分隔的电子邮件地址列表。bcc: 头部行不会发送给电子邮件消息的收件人。'
- en: 'A simple email message containing the From:, To:, Subject: and Date: header
    lines and two lines of body is shown below.'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '下面是一个简单的电子邮件消息示例，包含 From:、To:、Subject: 和 Date: 头部行以及两行正文。'
- en: '[PRE28]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the empty line after the Date: header line; this empty line contains only
    the CR and LF characters, and marks the boundary between the header and the body
    of the message.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '注意 Date: 头部行之后的空行；这个空行只包含 CR 和 LF 字符，并标志着头部和消息主体的边界。'
- en: 'Several other optional header lines are defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    and elsewhere [[11]](#femailheaders). Furthermore, many email clients and servers
    define their own header lines starting from X-. Several of the optional header
    lines defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    are worth being discussed here :'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html) 和其他地方定义了几个其他可选的头部行
    [[11]](#femailheaders)。此外，许多电子邮件客户端和服务器定义了从 X- 开始的自己的头部行。以下讨论 [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)
    中定义的几个可选头部行：
- en: 'the Message-Id: header line is used to associate a “unique” identifier to each
    email. Email identifiers are usually structured like string@domain where string
    is a unique character string or sequence number chosen by the sender of the email
    and domain the domain name of the sender. Since domain names are unique, a host
    can generate globally unique message identifiers concatenating a locally unique
    identifier with its domain name.'
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Message-Id: 头部行用于将一个“唯一”的标识符关联到每个电子邮件。电子邮件标识符通常结构为 string@domain，其中 string
    是发件人选择的唯一字符字符串或序列号，domain 是发件人的域名。由于域名是唯一的，一个主机可以通过将本地唯一标识符与其域名连接起来生成全局唯一的消息标识符。'
- en: ''
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the In-reply-to: header line is used when a message was created in reply to
    a previous message. In this case, the end of the In-reply-to: line contains the
    identifier of the original message.'
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'In-reply-to: 头部行用于在回复先前的消息时创建消息。在这种情况下，In-reply-to: 行的末尾包含原始消息的标识符。'
- en: ''
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Received: header line is used when an email message is processed by several
    servers before reaching its destination. Each intermediate email server adds a
    Received: header line. These header lines are useful to debug problems in delivering
    email messages.'
  id: totrans-838
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当电子邮件消息在到达目的地之前由多个服务器处理时，会使用 `Received:` 头行。每个中间电子邮件服务器都会添加一个 `Received:` 头行。这些头行对于调试电子邮件消息传递中的问题很有用。
- en: 'The figure below shows the header lines of one email message. The message originated
    at a host named wira.firstpr.com.au and was received by smtp3.sgsi.ucl.ac.be.
    The Received: lines have been wrapped for readability.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了电子邮件消息的头行。该消息起源于名为 wira.firstpr.com.au 的主机，并由 smtp3.sgsi.ucl.ac.be 接收。为了便于阅读，`Received:`
    行已被换行。
- en: '[PRE29]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Initially, email was used to exchange small messages of ASCII text between computer
    scientists. However, with the growth of the Internet, supporting only ASCII text
    became a severe limitation for two reasons. First of all, non-English speakers
    wanted to write emails in their native language that often required more characters
    than those of the ASCII character table. Second, many users wanted to send other
    content than just ASCII text by email such as binary files, images or sound.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，电子邮件被用于在计算机科学家之间交换 ASCII 文本的简短消息。然而，随着互联网的发展，仅支持 ASCII 文本变得严重限制了两个原因。首先，非英语使用者希望用他们的母语写电子邮件，这通常需要比
    ASCII 字符表更多的字符。其次，许多用户希望通过电子邮件发送除了 ASCII 文本之外的内容，例如二进制文件、图像或声音。
- en: To solve this problem, the [IETF](https://www.ietf.org) developed the Multipurpose
    Internet Mail Extensions ([MIME](../glossary.html#term-MIME)). These extensions
    were carefully designed to allow Internet email to carry non-ASCII characters
    and binary files without breaking the email servers that were deployed at that
    time. This requirement for backward compatibility forced the MIME designers to
    develop extensions to the existing email message format [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    instead of defining a completely new format that would have been better suited
    to support the new types of emails.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，[IETF](https://www.ietf.org) 开发了多用途互联网邮件扩展 ([MIME](../glossary.html#term-MIME))。这些扩展被精心设计，以允许互联网电子邮件携带非
    ASCII 字符和二进制文件，而不会破坏当时部署的电子邮件服务器。这种向后兼容性的要求迫使 MIME 设计者开发了对现有电子邮件消息格式的扩展 [**RFC
    822**](https://datatracker.ietf.org/doc/html/rfc822.html)，而不是定义一个更适合支持新类型电子邮件的全新格式。
- en: '[**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html) defines
    three new types of header lines to support MIME :'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html) 定义了三种新的头行类型以支持
    MIME：'
- en: 'The MIME-Version: header line indicates the version of the MIME specification
    that was used to encode the email message. The current version of MIME is 1.0\.
    Other versions of MIME may be defined in the future. Thanks to this header line,
    the software that processes email messages will be able to adapt to the MIME version
    used to encode the message. Messages that do not contain this header are supposed
    to be formatted according to the original [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    specification.'
  id: totrans-844
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIME-Version:` 头行指示用于编码电子邮件消息的 MIME 规范版本。当前的 MIME 版本是 1.0。未来可能会定义 MIME 的其他版本。多亏了这个头行，处理电子邮件消息的软件将能够适应用于编码消息的
    MIME 版本。不包含此头行的消息应按照原始 [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    规范进行格式化。'
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Content-Type: header line indicates the type of data that is carried inside
    the message (see below).'
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type:` 头行指示消息内部携带的数据类型（见下文）。'
- en: ''
  id: totrans-848
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-849
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Content-Transfer-Encoding: header line is used to specify how the message
    has been encoded. When MIME was designed, some email servers were only able to
    process messages containing characters encoded using the 7 bits ASCII character
    set. MIME allows the utilization of other character encodings.'
  id: totrans-850
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Transfer-Encoding:` 头行用于指定消息的编码方式。当 MIME 被设计时，一些电子邮件服务器只能处理包含使用 7
    位 ASCII 字符集编码的字符的消息。MIME 允许使用其他字符编码。'
- en: 'Inside the email header, the Content-Type: header line indicates how the MIME
    email message is structured. [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    defines the utilization of this header line. The two most common structures for
    MIME messages are :'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件头信息中，`Content-Type:` 头行指示 MIME 电子邮件消息的结构。[**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    定义了此头行的使用。MIME 消息的两种最常见结构是：
- en: 'Content-Type: multipart/mixed. This header line indicates that the MIME message
    contains several independent parts. For example, such a message may contain a
    part in plain text and a binary file.'
  id: totrans-852
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Type: multipart/mixed. 这个头部行表示 MIME 消息包含几个独立的部分。例如，这样的消息可能包含一个纯文本部分和一个二进制文件。'
- en: ''
  id: totrans-853
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Content-Type: multipart/alternative. This header line indicates that the MIME
    message contains several representations of the same information. For example,
    a multipart/alternative message may contain both a plain text and an HTML version
    of the same text.'
  id: totrans-855
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Type: multipart/alternative. 这个头部行表示 MIME 消息包含相同信息的几个表示。例如，multipart/alternative
    消息可能包含相同文本的纯文本和 HTML 版本。'
- en: 'To support these two types of MIME messages, the recipient of a message must
    be able to extract the different parts from the message. In [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html),
    an empty line was used to separate the header lines from the body. Using an empty
    line to separate the different parts of an email body would be difficult as the
    body of email messages often contains one or more empty lines. Another possible
    option would be to define a special line, e.g. *-LAST_LINE-* to mark the boundary
    between two parts of a MIME message. Unfortunately, this is not possible as some
    emails may contain this string in their body (e.g. emails sent to students to
    explain the format of MIME messages). To solve this problem, the Content-Type:
    header line contains a second parameter that specifies the string that has been
    used by the sender of the MIME message to delineate the different parts. In practice,
    this string is often chosen randomly by the mail client.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '为了支持这两种类型的 MIME 消息，消息的接收者必须能够从消息中提取不同的部分。在 [**RFC 822**](https://datatracker.ietf.org/doc/html/rfc822.html)
    中，使用空行来分隔头部行和正文。使用空行来分隔电子邮件正文的各个部分将很困难，因为电子邮件消息的正文通常包含一个或多个空行。另一个可能的选项是定义一个特殊的行，例如
    *-LAST_LINE-* 来标记 MIME 消息两部分之间的边界。不幸的是，这是不可能的，因为一些电子邮件可能在它们的正文中包含这个字符串（例如，发送给学生解释
    MIME 消息格式的电子邮件）。为了解决这个问题，Content-Type: 头部行包含一个第二个参数，该参数指定 MIME 消息的发送者用来分隔不同部分的字符串。实际上，这个字符串通常由邮件客户端随机选择。'
- en: 'The email message below, copied from [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    shows a MIME message containing two parts that are both in plain text and encoded
    using the ASCII character set. The string simple boundary is defined in the Content-Type:
    header as the marker for the boundary between two successive parts. Another example
    of MIME messages may be found in [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html).'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '以下电子邮件消息，摘自 [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)，显示了一个包含两个部分的
    MIME 消息，这两个部分都是纯文本，并使用 ASCII 字符集进行编码。字符串 simple boundary 在 Content-Type: 头部中定义为两个连续部分之间的标记。另一个
    MIME 消息的例子可以在 [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html)
    中找到。'
- en: '[PRE30]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The Content-Type: header can also be used inside a MIME part. In this case,
    it indicates the type of data placed in this part. Each data type is specified
    as a type followed by a subtype. A detailed description may be found in [**RFC
    2046**](https://datatracker.ietf.org/doc/html/rfc2046.html). Some of the most
    popular Content-Type: header lines are :'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 'Content-Type: 头部也可以在 MIME 部分内部使用。在这种情况下，它表示放置在这个部分中的数据类型。每种数据类型都指定为一个类型后跟一个子类型。更详细的描述可以在
    [**RFC 2046**](https://datatracker.ietf.org/doc/html/rfc2046.html) 中找到。一些最受欢迎的
    Content-Type: 头部行如下：'
- en: 'text. The message part contains information in textual format. There are several
    subtypes : text/plain for regular ASCII text, text/html defined in [**RFC 2854**](https://datatracker.ietf.org/doc/html/rfc2854.html)
    for documents in [HTML](../glossary.html#term-HTML) format or the text/enriched
    format defined in [**RFC 1896**](https://datatracker.ietf.org/doc/html/rfc1896.html).
    The Content-Type: header line may contain a second parameter that specifies the
    character set used to encode the text. charset=us-ascii is the standard ASCII
    character table. Other frequent character sets include charset=UTF8 or charset=iso-8859-1.
    The [list of standard character sets](http://www.iana.org/assignments/character-sets)
    is maintained by [IANA](../glossary.html#term-IANA).'
  id: totrans-860
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本。消息部分包含以文本格式的信息。有几种子类型：text/plain用于常规ASCII文本，text/html由[**RFC 2854**](https://datatracker.ietf.org/doc/html/rfc2854.html)定义，用于[HTML](../glossary.html#term-HTML)格式的文档，或由[**RFC
    1896**](https://datatracker.ietf.org/doc/html/rfc1896.html)定义的text/enriched格式。Content-Type:头行可能包含一个第二个参数，用于指定编码文本所使用的字符集。charset=us-ascii是标准的ASCII字符表。其他常见的字符集包括charset=UTF8或charset=iso-8859-1。[标准字符集列表](http://www.iana.org/assignments/character-sets)由[IANA](../glossary.html#term-IANA)维护。
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: image. The message part contains a binary representation of an image. The subtype
    indicates the format of the image such as [gif](http://en.wikipedia.org/wiki/Graphics_Interchange_Format),
    [jpg](http://en.wikipedia.org/wiki/Jpeg) or [png](http://en.wikipedia.org/wiki/Portable_Network_Graphics).
  id: totrans-863
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片。消息部分包含图像的二进制表示。子类型表示图像的格式，如[gif](http://en.wikipedia.org/wiki/Graphics_Interchange_Format)、[jpg](http://en.wikipedia.org/wiki/Jpeg)或[png](http://en.wikipedia.org/wiki/Portable_Network_Graphics)。
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: audio. The message part contains an audio clip. The subtype indicates the format
    of the audio clip like [wav](http://en.wikipedia.org/wiki/Wav) or [mp3](http://en.wikipedia.org/wiki/Mp3).
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频。消息部分包含音频剪辑。子类型表示音频剪辑的格式，如[wav](http://en.wikipedia.org/wiki/Wav)或[mp3](http://en.wikipedia.org/wiki/Mp3)。
- en: ''
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-868
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: video. The message part contains a video clip. The subtype indicates the format
    of the video clip like [avi](http://en.wikipedia.org/wiki/Audio_Video_Interleave)
    or [mp4](http://en.wikipedia.org/wiki/Mp4).
  id: totrans-869
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频部分。消息部分包含一个视频剪辑。子类型表示视频剪辑的格式，如[avi](http://en.wikipedia.org/wiki/Audio_Video_Interleave)或[mp4](http://en.wikipedia.org/wiki/Mp4)。
- en: ''
  id: totrans-870
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-871
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: application. The message part contains binary information that was produced
    by the particular application listed as the subtype. Email clients use the subtype
    to launch the application that is able to decode the received binary information.
  id: totrans-872
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用。消息部分包含由特定子类型列出的应用程序产生的二进制信息。电子邮件客户端使用子类型来启动能够解码接收到的二进制信息的应用程序。
- en: Note
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From ASCII to Unicode
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 从ASCII到Unicode
- en: The first computers used different techniques to represent characters in memory
    and on disk. During the 1960s, computers began to exchange information via tape
    or telephone lines. Unfortunately, each vendor had its own proprietary character
    set and exchanging data between computers from different vendors was often difficult.
    The 7 bits ASCII character table [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html)
    was adopted by several vendors and by many Internet protocols. However, ASCII
    became a problem with the internationalization of the Internet and the desire
    of more and more users to use character sets that support their own written language.
    A first attempt at solving this problem was the definition of the [ISO-8859](https://en.wikipedia.org/wiki/ISO_8859)
    character sets by [ISO](../glossary.html#term-ISO). This family of standards specified
    various character sets that allowed the representation of many European written
    languages by using 8 bits characters. Unfortunately, an 8-bits character set is
    not sufficient to support some widely used languages, such as those used in Asian
    countries. Fortunately, at the end of the 1980s, several computer scientists proposed
    to develop a standard that supports all written languages used on Earth today.
    The Unicode standard [[Unicode]](../bibliography.html#unicode) has now been adopted
    by most computer and software vendors. For example, Java always uses Unicode to
    manipulate characters, Python can handle both ASCII and Unicode characters. Internet
    applications are slowly moving towards complete support for the Unicode character
    sets, but moving from ASCII to Unicode is an important change that can have a
    huge impact on current deployed implementations. See, for example, the work to
    completely internationalize email [**RFC 4952**](https://datatracker.ietf.org/doc/html/rfc4952.html)
    and domain names [**RFC 5890**](https://datatracker.ietf.org/doc/html/rfc5890.html).
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，计算机使用不同的技术来在内存和磁盘上表示字符。在20世纪60年代，计算机开始通过磁带或电话线路交换信息。不幸的是，每个供应商都有自己的专用字符集，不同供应商的计算机之间交换数据通常很困难。7位ASCII字符表[**RFC
    20**](https://datatracker.ietf.org/doc/html/rfc20.html)被多个供应商和许多互联网协议采用。然而，随着互联网的国际化以及越来越多的用户希望使用支持自己书写语言的字符集，ASCII成为了一个问题。解决这个问题的第一个尝试是[ISO](../glossary.html#term-ISO)定义的[ISO-8859](https://en.wikipedia.org/wiki/ISO_8859)字符集。这个标准系列指定了各种字符集，通过使用8位字符可以表示许多欧洲书写语言。不幸的是，8位字符集不足以支持一些广泛使用的语言，例如亚洲国家使用的语言。幸运的是，在20世纪80年代末，几位计算机科学家提出了开发一个支持地球上今天使用的所有书写语言的标准。Unicode标准[[Unicode]](../bibliography.html#unicode)现在已被大多数计算机和软件供应商采用。例如，Java始终使用Unicode来操作字符，Python可以处理ASCII和Unicode字符。互联网应用正在缓慢地向完全支持Unicode字符集的方向发展，但从ASCII到Unicode的转换是一个重要的变化，可能会对当前部署的实施产生巨大影响。例如，查看完全国际化电子邮件[**RFC
    4952**](https://datatracker.ietf.org/doc/html/rfc4952.html)和域名[**RFC 5890**](https://datatracker.ietf.org/doc/html/rfc5890.html)的工作。
- en: 'The last MIME header line is Content-Transfer-Encoding:. This header line is
    used after the Content-Type: header line, within a message part, and specifies
    how the message part has been encoded. The default encoding is to use 7 bits ASCII.
    The most frequent encodings are quoted-printable and Base64. Both support encoding
    a sequence of bytes into a set of ASCII lines that can be safely transmitted by
    email servers. quoted-printable is defined in [**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html).
    We briefly describe base64 which is defined in [**RFC 2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)
    and [**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html).'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个MIME头行是Content-Transfer-Encoding:. 这个头行在Content-Type:头行之后，在消息部分内使用，并指定了消息部分是如何编码的。默认编码是使用7位ASCII。最常用的编码是quoted-printable和Base64。两者都支持将一系列字节编码成一组ASCII行，这些行可以通过电子邮件服务器安全传输。quoted-printable在[**RFC
    2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)中定义。我们简要描述base64，它在[**RFC
    2045**](https://datatracker.ietf.org/doc/html/rfc2045.html)和[**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html)中定义。
- en: Base64 divides the sequence of bytes to be encoded into groups of three bytes
    (with the last group possibly being partially filled). Each group of three bytes
    is then divided into four six-bit fields and each six bit field is encoded as
    a character from the table below.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Base64将待编码的字节序列分成三字节的组（最后一个组可能是不完整的）。然后，每个三字节的组被分成四个六位字段，每个六位字段被编码为下表中对应的字符。
- en: '| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding
    |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 编码 | 值 | 编码 | 值 | 编码 | 值 | 编码 |'
- en: '| 0 | A | 17 | R | 34 | i | 51 | z |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '| 0 | A | 17 | R | 34 | i | 51 | z |'
- en: '| 1 | B | 18 | S | 35 | j | 52 | 0 |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B | 18 | S | 35 | j | 52 | 0 |'
- en: '| 2 | C | 19 | T | 36 | k | 53 | 1 |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '| 2 | C | 19 | T | 36 | k | 53 | 1 |'
- en: '| 3 | D | 20 | U | 37 | l | 54 | 2 |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
  zh: '| 3 | D | 20 | U | 37 | l | 54 | 2 |'
- en: '| 4 | E | 21 | V | 38 | m | 55 | 3 |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '| 4 | E | 21 | V | 38 | m | 55 | 3 |'
- en: '| 5 | F | 22 | W | 39 | n | 56 | 4 |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '| 5 | F | 22 | W | 39 | n | 56 | 4 |'
- en: '| 6 | G | 23 | X | 40 | o | 57 | 5 |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '| 6 | G | 23 | X | 40 | o | 57 | 5 |'
- en: '| 7 | H | 24 | Y | 41 | p | 58 | 6 |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '| 7 | H | 24 | Y | 41 | p | 58 | 6 |'
- en: '| 8 | I | 25 | Z | 42 | q | 59 | 7 |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| 8 | I | 25 | Z | 42 | q | 59 | 7 |'
- en: '| 9 | J | 26 | a | 43 | r | 60 | 8 |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: '| 9 | J | 26 | a | 43 | r | 60 | 8 |'
- en: '| 10 | K | 27 | b | 44 | s | 61 | 9 |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '| 10 | K | 27 | b | 44 | s | 61 | 9 |'
- en: '| 11 | L | 28 | c | 45 | t | 62 | + |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '| 11 | L | 28 | c | 45 | t | 62 | + |'
- en: '| 12 | M | 29 | d | 46 | u | 63 | / |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
  zh: '| 12 | M | 29 | d | 46 | u | 63 | / |'
- en: '| 13 | N | 30 | e | 47 | v |  |  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '| 13 | N | 30 | e | 47 | v |  |  |'
- en: '| 14 | O | 31 | f | 48 | w |  |  |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '| 14 | O | 31 | f | 48 | w |  |  |'
- en: '| 15 | P | 32 | g | 49 | x |  |  |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
  zh: '| 15 | P | 32 | g | 49 | x |  |  |'
- en: '| 16 | Q | 33 | h | 50 | y |  |  |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '| 16 | Q | 33 | h | 50 | y |  |  |'
- en: The example below, from [**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html),
    illustrates the Base64 encoding.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，来自[**RFC 4648**](https://datatracker.ietf.org/doc/html/rfc4648.html)，说明了Base64编码。
- en: '| Input data | 0x14fb9c03d97e |'
  id: totrans-897
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入数据 | 0x14fb9c03d97e |'
- en: '| 8-bit | 00010100 11111011 10011100 00000011 11011001 01111110 |'
  id: totrans-898
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8-bit | 00010100 11111011 10011100 00000011 11011001 01111110 |'
- en: '| 6-bit | 000101 001111 101110 011100 000000 111101 100101 111110 |'
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6-bit | 000101 001111 101110 011100 000000 111101 100101 111110 |'
- en: '| Decimal | 5 15 46 28 0 61 37 62 |'
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 十进制 | 5 15 46 28 0 61 37 62 |'
- en: '| Encoding | F P u c A 9 l + |'
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | F P u c A 9 l + |'
- en: The last point to be discussed about base64 is what happens when the length
    of the sequence of bytes to be encoded is not a multiple of three. In this case,
    the last group of bytes may contain one or two bytes instead of three. Base64
    reserves the = character as a padding character. This character is used once when
    the last group contains two bytes and twice when it contains one byte as illustrated
    by the two examples below.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 关于base64的最后一点要讨论的是，当要编码的字节序列长度不是三的倍数时会发生什么。在这种情况下，最后一组字节可能包含一个或两个字节而不是三个。Base64将=字符保留为填充字符。当最后一组包含两个字节时，该字符使用一次；当它包含一个字节时，使用两次，如下面的两个示例所示。
- en: '| Input data | 0x14 |'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入数据 | 0x14 |'
- en: '| 8-bit | 00010100 |'
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8-bit | 00010100 |'
- en: '| 6-bit | 000101 000000 |'
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6-bit | 000101 000000 |'
- en: '| Decimal | 5 0 |'
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 十进制 | 5 0 |'
- en: '| Encoding | F A = = |'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | F A = = |'
- en: ''
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Input data | 0x14b9 |'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入数据 | 0x14b9 |'
- en: '| 8-bit | 00010100 11111011 |'
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 8-bit | 00010100 11111011 |'
- en: '| 6-bit | 000101 001111 101100 |'
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 6-bit | 000101 001111 101100 |'
- en: '| Decimal | 5 15 44 |'
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 十进制 | 5 15 44 |'
- en: '| Encoding | F P s = |'
  id: totrans-913
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 编码 | F P s = |'
- en: Now that we have explained the format of the email messages, we can discuss
    how these messages can be exchanged through the Internet. [Fig. 30](#fig-email-protocols)
    illustrates the protocols that are used when Alice sends an email message to Bob.
    Alice prepares her email with an email client or on a webmail interface. To send
    her email to Bob, Alice’s client will use the Simple Mail Transfer Protocol ([SMTP](../glossary.html#term-SMTP))
    to deliver her message to her SMTP server. Alice’s email client is configured
    with the name of the default SMTP server for her domain. There is usually at least
    one SMTP server per domain. To deliver the message, Alice’s SMTP server must find
    the SMTP server that contains Bob’s mailbox. This can be done by using the Mail
    eXchange (MX) records of the DNS. A set of MX records can be associated to each
    domain. Each MX record contains a numerical preference and the fully qualified
    domain name of a SMTP server that is able to deliver email messages destined to
    all valid email addresses of this domain. The DNS can return several MX records
    for a given domain. In this case, the server with the lowest numerical preference
    is used first [**RFC 2821**](https://datatracker.ietf.org/doc/html/rfc2821.html).
    If this server is not reachable, the second most preferred server is used etc.
    Bob’s SMTP server will store the message sent by Alice until Bob retrieves it
    using a webmail interface or protocols such as the Post Office Protocol ([POP](../glossary.html#term-POP))
    or the Internet Message Access Protocol ([IMAP](../glossary.html#term-IMAP)).
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了电子邮件消息的格式，我们可以讨论这些消息如何通过互联网进行交换。[图 30](#fig-email-protocols) 展示了当 Alice
    向 Bob 发送电子邮件消息时使用的协议。Alice 使用电子邮件客户端或网页邮箱界面准备她的电子邮件。为了将她的电子邮件发送给 Bob，Alice 的客户端将使用简单邮件传输协议
    ([SMTP](../glossary.html#term-SMTP)) 将她的消息发送到她的 SMTP 服务器。Alice 的电子邮件客户端配置了她的域的默认
    SMTP 服务器名称。通常每个域至少有一个 SMTP 服务器。为了投递消息，Alice 的 SMTP 服务器必须找到包含 Bob 邮箱的 SMTP 服务器。这可以通过使用
    DNS 的邮件交换 (MX) 记录来完成。每个域可以关联一组 MX 记录。每个 MX 记录包含一个数值优先级和一个能够投递发送到该域所有有效电子邮件地址的电子邮件消息的
    SMTP 服务器的完全限定域名。DNS 可以为给定域返回多个 MX 记录。在这种情况下，使用数值优先级最低的服务器首先 [**RFC 2821**](https://datatracker.ietf.org/doc/html/rfc2821.html)。如果此服务器不可达，则使用次优服务器等。Bob
    的 SMTP 服务器将存储 Alice 发送的消息，直到 Bob 使用网页邮箱界面或如邮局协议 ([POP](../glossary.html#term-POP))
    或互联网消息访问协议 ([IMAP](../glossary.html#term-IMAP)) 获取它。
- en: '![Figure made with TikZ](../Images/1016e46afc46c3c3a2098ab7047067a3.png)'
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/1016e46afc46c3c3a2098ab7047067a3.png)'
- en: ''
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 30 Email delivery protocols
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 30 邮件投递协议
- en: '### The Simple Mail Transfer Protocol[#](#the-simple-mail-transfer-protocol
    "Link to this heading")'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '### 简单邮件传输协议[#](#the-simple-mail-transfer-protocol "链接到本标题")'
- en: The Simple Mail Transfer Protocol ([SMTP](../glossary.html#term-SMTP)) defined
    in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html) is a client-server
    protocol. The SMTP specification distinguishes between five types of processes
    involved in the delivery of email messages. Email messages are composed on a Mail
    User Agent (MUA). The MUA is usually either an email client or a webmail. The
    MUA sends the email message to a Mail Submission Agent (MSA). The MSA processes
    the received email and forwards it to the Mail Transmission Agent (MTA). The MTA
    is responsible for the transmission of the email, directly or via intermediate
    MTAs to the MTA of the destination domain. This destination MTA will then forward
    the message to the Mail Delivery Agent (MDA) where it will be accessed by the
    recipient’s MUA. SMTP is used for the interactions between MUA and MSA [[12]](#fsmtpauth),
    MSA-MTA and MTA-MTA.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html) 中定义的简单邮件传输协议
    ([SMTP](../glossary.html#term-SMTP)) 是一种客户端-服务器协议。SMTP 规范区分了在电子邮件消息投递过程中涉及的五种类型的过程。电子邮件消息是在邮件用户代理
    (MUA) 上编写的。MUA 通常是一个电子邮件客户端或网页邮箱。MUA 将电子邮件消息发送到邮件提交代理 (MSA)。MSA 处理接收到的电子邮件并将其转发到邮件传输代理
    (MTA)。MTA 负责电子邮件的传输，直接或通过中间 MTA 传输到目标域的 MTA。然后，目标 MTA 将消息转发到邮件投递代理 (MDA)，在那里收件人的
    MUA 将可以访问它。SMTP 用于 MUA 和 MSA 之间的交互 [[12]](#fsmtpauth)，MSA-MTA 和 MTA-MTA。
- en: SMTP is a text-based protocol like many other application-layer protocols on
    the Internet. It relies on the byte-stream service. Servers listen on port 25.
    Clients send commands that are each composed of one line of ASCII text terminated
    by CR+LF. Servers reply by sending ASCII lines that contain a three digit numerical
    error/success code and optional comments.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP是一种基于文本的协议，类似于互联网上许多其他应用层协议。它依赖于字节流服务。服务器监听25号端口。客户端发送由ASCII文本行组成、以CR+LF结尾的命令。服务器通过发送包含三位数字错误/成功代码和可选注释的ASCII行进行回复。
- en: The SMTP protocol, like most text-based protocols, is specified as a [BNF](../glossary.html#term-BNF).
    The full BNF is defined in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html).
    The main SMTP commands are defined by the BNF rules shown in [Fig. 31](#fig-smtp-bnf).
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP协议，像大多数基于文本的协议一样，被指定为[BNF](../glossary.html#term-BNF)。完整的BNF在[**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html)中定义。主要的SMTP命令由[图31](#fig-smtp-bnf)中显示的BNF规则定义。
- en: '[![../_images/smtp-bnf.svg](../Images/c14bdccb9a063300e7e5dc0d244b52c9.png)](../_images/smtp-bnf.svg)'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/smtp-bnf.svg](../Images/c14bdccb9a063300e7e5dc0d244b52c9.png)](../_images/smtp-bnf.svg)'
- en: Fig. 31 BNF specification of the SMTP commands[#](#id60 "Link to this image")
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 图31 SMTP命令的BNF规范[#](#id60 "链接到此图像")
- en: In this BNF, atext corresponds to printable ASCII characters. This BNF rule
    is defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html).
    The five main commands are EHLO [[13]](#fehlo), MAIL FROM:, RCPT TO:, DATA and
    QUIT. Postmaster is the alias of the system administrator who is responsible for
    a given domain or SMTP server. All domains must have a Postmaster alias. The SMTP
    responses are defined by the BNF shown in [Fig. 32](#fig-smtp-responses).
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 在此BNF中，atext对应于可打印的ASCII字符。此BNF规则在[**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)中定义。五个主要命令是EHLO
    [[13]](#fehlo)，MAIL FROM:，RCPT TO:，DATA和QUIT。Postmaster是负责特定域名或SMTP服务器的系统管理员的别名。所有域名都必须有Postmaster别名。SMTP响应由[图32](#fig-smtp-responses)中显示的BNF定义。
- en: '![../_images/smtp-response.svg](../Images/699468c24e349ef194f6c3fcb1101a01.png)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/smtp-response.svg](../Images/699468c24e349ef194f6c3fcb1101a01.png)'
- en: Fig. 32 BNF specification of the SMTP responses[#](#id61 "Link to this image")
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 图32 SMTP响应的BNF规范[#](#id61 "链接到此图像")
- en: SMTP servers use structured reply codes containing three digits and an optional
    comment. The first digit of the reply code indicates whether the command was successful
    or not. A reply code of 2xy indicates that the command has been accepted. A reply
    code of 3xy indicates that the command has been accepted, but additional information
    from the client is expected. A reply code of 4xy indicates a transient negative
    reply. This means that for some reason, which is indicated by either the other
    digits or the comment, the command cannot be processed immediately, but there
    is some hope that the problem will only be transient. This is basically telling
    the client to try the same command again later. In contrast, a reply code of 5xy
    indicates a permanent failure or error. In this case, it is useless for the client
    to retry the same command later. Other application layer protocols such as FTP
    [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html) or HTTP [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) use a similar structure
    for their reply codes. Additional details about the other reply codes may be found
    in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html).
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP服务器使用包含三位数字和可选注释的结构化回复代码。回复代码的第一位数字表示命令是否成功。回复代码2xy表示命令已被接受。回复代码3xy表示命令已被接受，但需要客户端提供更多信息。回复代码4xy表示暂时性负面回复。这意味着由于某种原因（由其他数字或注释指示），命令无法立即处理，但仍有希望问题只是暂时的。这基本上是在告诉客户端稍后再次尝试相同的命令。相比之下，回复代码5xy表示永久性失败或错误。在这种情况下，客户端稍后重试相同的命令是无用的。其他应用层协议，如FTP
    [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html) 或 HTTP [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)，它们的回复代码使用类似的结构。有关其他回复代码的详细信息，请参阅[**RFC
    5321**](https://datatracker.ietf.org/doc/html/rfc5321.html)。
- en: 'Examples of SMTP reply codes include the following :'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP回复代码的示例包括以下内容：
- en: '[PRE31]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Reply code 220 is used by the server as the first message when it agrees to
    interact with the client. Reply code 221 is sent by the server before closing
    the underlying transport connection. Reply code 250 is the standard positive reply
    that indicates the success of the previous command. Reply code 354 indicates that
    the client can start transmitting its email message. Reply code 421 is returned
    when there is a problem (e.g. lack of memory/disk resources) that prevents the
    server from accepting the transport connection. Reply codes 450 and 452 indicate
    that the destination mailbox is temporarily unavailable, for various reasons,
    while reply code 550 indicates that the mailbox does not exist or cannot be used
    for policy reasons. The 500 to 503 reply codes correspond to errors in the commands
    sent by the client. The 503 reply code would be sent by the server when the client
    sends commands in an incorrect order (e.g. the client tries to send an email before
    providing the destination address of the message).
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在同意与客户端交互时，将回复代码 220 作为第一条消息。在关闭底层传输连接之前，服务器会发送回复代码 221。回复代码 250 是标准的积极回复，表示前一个命令的成功执行。回复代码
    354 表示客户端可以开始传输其电子邮件消息。当存在阻止服务器接受传输连接的问题（例如内存/磁盘资源不足）时，会返回回复代码 421。回复代码 450 和
    452 表示目标邮箱因各种原因暂时不可用，而回复代码 550 表示邮箱不存在或因策略原因无法使用。500 到 503 的回复代码对应于客户端发送的命令错误。当客户端以错误的顺序发送命令时（例如，客户端在提供消息的目标地址之前尝试发送电子邮件），服务器会发送
    503 回复代码。
- en: 'The transfer of an email message is performed in three phases. During the first
    phase, the client opens a transport connection with the server. Once the connection
    has been established, the client and the server exchange greetings messages (EHLO
    command). Most servers insist on receiving valid greeting messages and some of
    them drop the underlying transport connection if they do not receive a valid greeting.
    Once the greetings have been exchanged, the email transfer phase can start. During
    this phase, the client transfers one or more email messages by indicating the
    email address of the sender (MAIL FROM: command), the email address of the recipient
    (RCPT TO: command) followed by the headers and the body of the email message (DATA
    command). Once the client has finished sending all its queued email messages to
    the SMTP server, it terminates the SMTP association (QUIT command).'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '电子邮件消息的传输分为三个阶段。在第一阶段，客户端与服务器建立传输连接。一旦连接建立，客户端和服务器会交换问候消息（EHLO 命令）。大多数服务器坚持要求接收有效的问候消息，如果它们没有收到有效的问候消息，其中一些服务器会丢弃底层的传输连接。一旦问候消息交换完毕，电子邮件传输阶段就可以开始。在这个阶段，客户端通过指示发送者的电子邮件地址（MAIL
    FROM: 命令）、收件人的电子邮件地址（RCPT TO: 命令）以及电子邮件消息的头部和正文（DATA 命令）来传输一个或多个电子邮件消息。一旦客户端将其所有排队电子邮件消息发送到
    SMTP 服务器，它将终止 SMTP 关联（QUIT 命令）。'
- en: A successful transfer of an email message is shown below
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个成功的电子邮件消息传输示例
- en: '[PRE32]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the example above, the MTA running on mta.example.org opens a TCP connection
    to the SMTP server on host smtp.example.com. The lines prefixed with S: (resp.
    C:) are the responses sent by the server (resp. the commands sent by the client).
    The server sends its greetings as soon as the TCP connection has been established.
    The client then sends the EHLO command with its fully qualified domain name. The
    server replies with reply-code 250 and sends its greetings. The SMTP association
    can now be used to exchange an email.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，运行在 mta.example.org 上的 MTA 打开到主机 smtp.example.com 上 SMTP 服务器的 TCP 连接。带有
    S:（分别对应 C:）前缀的行是服务器（分别对应客户端）发送的响应。服务器在 TCP 连接建立后立即发送其问候。然后客户端发送带有其完全限定域名（FQDN）的
    EHLO 命令。服务器以回复代码 250 回复并发送其问候。现在可以使用 SMTP 关联来交换电子邮件。
- en: 'To send an email, the client must first provide the address of the recipient
    with RCPT TO:. Then it uses the MAIL FROM: with the address of the sender. Both
    the recipient and the sender are accepted by the server. The client can now issue
    the DATA command to start the transfer of the email message. After having received
    the 354 reply code, the client sends the headers and the body of its email message.
    The client indicates the end of the message by sending a line containing only
    the . (dot) character [[14]](#fdot). The server confirms that the email message
    has been queued for delivery or transmission with a reply code of 250. The client
    issues the QUIT command to close the session and the server confirms with reply-code
    221, before closing the TCP connection.'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '要发送电子邮件，客户端必须首先使用 RCPT TO: 提供收件人的地址。然后它使用 MAIL FROM: 提供发送者的地址。服务器接受收件人和发送者。客户端现在可以发出
    DATA 命令以开始电子邮件消息的传输。在收到 354 回复代码后，客户端发送其电子邮件消息的标题和正文。客户端通过发送只包含 .（点）字符的行来指示消息的结束
    [[14]](#fdot)。服务器通过回复代码 250 确认电子邮件消息已被排队等待投递或传输。客户端发出 QUIT 命令以关闭会话，服务器在关闭 TCP
    连接前以回复代码 221 确认。'
- en: Note
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open SMTP relays and spam
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 开放 SMTP 中继和垃圾邮件
- en: Since its creation in 1971, email has been a very useful tool that is used by
    many users to exchange lots of information. In the early days, all SMTP servers
    were open and anyone could use them to forward emails towards their final destination.
    Unfortunately, over the years, some unscrupulous users have found ways to use
    email for marketing purposes or to send malware. The first documented abuse of
    email for marketing purposes occurred in 1978 when a marketer who worked for a
    computer vendor sent a [marketing email](http://www.templetons.com/brad/spamreact.html#msg)
    to many ARPANET users. At that time, the ARPANET could only be used for research
    purposes and this was an abuse of the acceptable use policy. Unfortunately, given
    the extremely low cost of sending emails, the problem of unsolicited emails has
    not stopped. Unsolicited emails are now called spam and a [study](http://www.enisa.europa.eu/act/res/other-areas/anti-spam-measures)
    carried out by [ENISA](https://www.enisa.europa.eu/) in 2009 reveals that 95%
    of email was spam and this number seems to continue to grow. This places a burden
    on the email infrastructure of Internet Service Providers and large companies
    that need to process many useless messages.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1971 年创建以来，电子邮件一直是一个非常有用的工具，许多用户用它来交换大量信息。在早期，所有 SMTP 服务器都是开放的，任何人都可以使用它们将电子邮件转发到最终目的地。不幸的是，多年来，一些不道德的用户找到了利用电子邮件进行营销或发送恶意软件的方法。1978
    年，一名为计算机供应商工作的营销人员向许多 ARPANET 用户发送了一封 [营销电子邮件](http://www.templetons.com/brad/spamreact.html#msg)，这是有记录的首次将电子邮件用于营销目的。当时，ARPANET
    只能用于研究目的，这违反了可接受的使用政策。不幸的是，由于发送电子邮件的成本极低，未经请求的电子邮件问题并未停止。未经请求的电子邮件现在被称为垃圾邮件，[ENISA](https://www.enisa.europa.eu/)
    在 2009 年进行的一项 [研究](http://www.enisa.europa.eu/act/res/other-areas/anti-spam-measures)
    显示，95% 的电子邮件是垃圾邮件，并且这个数字似乎还在继续增长。这给互联网服务提供商和需要处理大量无用消息的大公司的电子邮件基础设施带来了负担。
- en: 'Given the amount of spam messages, SMTP servers are no longer open [**RFC 5068**](https://datatracker.ietf.org/doc/html/rfc5068.html).
    Several extensions to SMTP have been developed in recent years to deal with this
    problem. For example, the SMTP authentication scheme defined in [**RFC 4954**](https://datatracker.ietf.org/doc/html/rfc4954.html)
    can be used by an SMTP server to authenticate a client. Several techniques have
    also been proposed to allow SMTP servers to authenticate the messages sent by
    their users [**RFC 4870**](https://datatracker.ietf.org/doc/html/rfc4870.html)
    [**RFC 4871**](https://datatracker.ietf.org/doc/html/rfc4871.html) .  ### The
    Post Office Protocol[#](#the-post-office-protocol "Link to this heading")'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '由于垃圾邮件的数量，SMTP 服务器现在不再开放 [**RFC 5068**](https://datatracker.ietf.org/doc/html/rfc5068.html)。近年来已经开发了几个
    SMTP 扩展来解决此问题。例如，[**RFC 4954**](https://datatracker.ietf.org/doc/html/rfc4954.html)
    中定义的 SMTP 认证方案可以被 SMTP 服务器用于验证客户端。还提出了几种技术，允许 SMTP 服务器验证其用户发送的消息 [**RFC 4870**](https://datatracker.ietf.org/doc/html/rfc4870.html)
    [**RFC 4871**](https://datatracker.ietf.org/doc/html/rfc4871.html) 。  ### 邮政协议[#](#the-post-office-protocol
    "链接到这个标题")'
- en: When the first versions of SMTP were designed, the Internet was composed of
    minicomputers that were used by an entire university department or research lab.
    These minicomputers were used by many users at the same time. Email was mainly
    used to send messages from a user on a given host to another user on a remote
    host. At that time, SMTP was the only protocol involved in the delivery of the
    emails as all hosts attached to the network were running an SMTP server. On such
    hosts, an email destined to local users was delivered by placing the email in
    a special directory or file owned by the user. However, the introduction of personal
    computers in the 1980s changed this environment. Initially, users of these personal
    computers used applications such as [telnet](../glossary.html#term-telnet) to
    open a remote session on the local [minicomputer](../glossary.html#term-minicomputer)
    to read their email. This was not user-friendly. A better solution appeared with
    the development of user friendly email client applications on personal computers.
    Several protocols were designed to allow these client applications to retrieve
    the email messages destined to a user from his/her server. Two of these protocols
    became popular and are still used today. The Post Office Protocol (POP), defined
    in [**RFC 1939**](https://datatracker.ietf.org/doc/html/rfc1939.html), is the
    simplest one. It allows a client to download all the messages destined to a given
    user from his/her email server. We describe POP briefly in this section. The second
    protocol is the Internet Message Access Protocol (IMAP), defined in [**RFC 3501**](https://datatracker.ietf.org/doc/html/rfc3501.html).
    IMAP is more powerful, but also more complex than POP. IMAP was designed to allow
    client applications to efficiently access, in real-time, to messages stored in
    various folders on servers. IMAP assumes that all the messages of a given user
    are stored on a server and provides the functions that are necessary to search,
    download, delete or filter messages.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计SMTP的第一个版本时，互联网由被整个大学系或研究实验室使用的迷你计算机组成。这些迷你计算机被许多用户同时使用。电子邮件主要用于从一个主机上的用户发送消息到远程主机上的另一个用户。当时，SMTP是唯一涉及电子邮件投递的协议，因为所有连接到网络的宿主都在运行SMTP服务器。在这些主机上，发往本地用户的电子邮件通过将电子邮件放入用户拥有的特殊目录或文件中来进行投递。然而，20世纪80年代个人电脑的引入改变了这一环境。最初，这些个人电脑的用户使用诸如[telnet](../glossary.html#term-telnet)之类的应用程序在本地[迷你计算机](../glossary.html#term-minicomputer)上打开远程会话以阅读他们的电子邮件。这并不友好。随着在个人电脑上开发用户友好的电子邮件客户端应用程序，出现了一个更好的解决方案。设计了几种协议，允许这些客户端应用程序从用户的邮件服务器检索发往用户的电子邮件消息。其中两种协议变得流行，并且至今仍在使用。定义在[**RFC
    1939**](https://datatracker.ietf.org/doc/html/rfc1939.html)中的邮局协议（POP）是最简单的一个。它允许客户端从其电子邮件服务器下载所有发往特定用户的邮件。我们在此节中简要描述POP。第二种协议是互联网消息访问协议（IMAP），定义在[**RFC
    3501**](https://datatracker.ietf.org/doc/html/rfc3501.html)。IMAP比POP更强大，但也更复杂。IMAP旨在允许客户端高效地实时访问服务器上存储在各个文件夹中的消息。IMAP假设特定用户的全部消息都存储在服务器上，并提供搜索、下载、删除或过滤消息所需的函数。
- en: 'POP is another example of a simple line-based protocol. POP runs above the
    bytestream service. A POP server usually listens to port 110\. A POP session is
    composed of three parts : an authorisation phase during which the server verifies
    the client’s credential, a transaction phase during which the client downloads
    messages and an update phase that concludes the session. The client sends commands
    and the server replies are prefixed by +OK to indicate a successful command or
    by -ERR to indicate errors.'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: POP是另一种简单的基于行的协议示例。POP在字节流服务之上运行。一个POP服务器通常监听110端口。一个POP会话由三个部分组成：一个授权阶段，在此期间服务器验证客户端的凭证；一个事务阶段，在此期间客户端下载消息；以及一个更新阶段，它结束了会话。客户端发送命令，服务器的回复以+OK为前缀表示命令成功，以-ERR为前缀表示错误。
- en: When a client opens a transport connection with the POP server, the latter sends
    as banner an ASCII-line starting with +OK. The POP session is at that time in
    the authorisation phase. In this phase, the client can send its username (resp.
    password) with the USER (resp. PASS) command. The server replies with +OK if the
    username (resp. password) is valid and -ERR otherwise.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端与POP服务器建立传输连接时，服务器会发送一个以+OK开头的ASCII行作为横幅。此时，POP会话处于授权阶段。在这个阶段，客户端可以使用USER（或PASS）命令发送其用户名（或密码）。如果用户名（或密码）有效，服务器会回复+OK，否则回复-ERR。
- en: Once the username and password have been validated, the POP session enters in
    the transaction phase. In this phase, the client can issue several commands. The
    STAT command is used to retrieve the status of the server. Upon reception of this
    command, the server replies with a line that contains +OK followed by the number
    of messages in the mailbox and the total size of the mailbox in bytes. The RETR
    command, followed by a space and an integer, is used to retrieve the nth message
    of the mailbox. The DELE command is used to mark for deletion the nth message
    of the mailbox.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户名和密码得到验证，POP会话进入事务阶段。在这个阶段，客户端可以发出多个命令。STAT命令用于检索服务器的状态。在接收到此命令后，服务器回复一行，其中包含+OK，后面跟着邮箱中的消息数量和邮箱的总字节数。RETR命令后跟一个空格和一个整数，用于检索邮箱中的第n条消息。DELE命令用于标记邮箱中的第n条消息为删除。
- en: Once the client has retrieved and possibly deleted the emails contained in the
    mailbox, it must issue the QUIT command. This command terminates the POP session
    and allows the server to delete all the messages that have been marked for deletion
    by using the DELE command.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端检索并可能删除了邮箱中的电子邮件，它必须发出QUIT命令。此命令终止POP会话，并允许服务器使用DELE命令删除所有已标记为删除的消息。
- en: 'The figure below provides a simple POP session. All lines prefixed with C:
    (resp. S:) are sent by the client (resp. server).'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 下图提供了一个简单的POP会话。所有以C:（分别对应S:）为前缀的行都是由客户端（分别对应服务器）发送的。
- en: '[PRE33]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, a POP client contacts a POP server on behalf of the user named
    alice. Note that in this example, Alice’s password is sent in clear by the client.
    This implies that if someone is able to capture the packets sent by Alice, he
    will know Alice’s password [[15]](#fapop). Then Alice’s client issues the STAT
    command to know the number of messages that are stored in her mailbox. It then
    retrieves and deletes the first message of the mailbox.  ### The Simple Mail Transfer
    Protocol[#](#the-simple-mail-transfer-protocol "Link to this heading")'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，一个POP客户端代表名为alice的用户联系了一个POP服务器。请注意，在这个例子中，Alice的密码由客户端明文发送。这意味着如果有人能够捕获Alice发送的包，他将知道Alice的密码
    [[15]](#fapop)。然后Alice的客户端发出STAT命令以了解其邮箱中存储的消息数量。然后它检索并删除邮箱中的第一条消息。  ### 简单邮件传输协议[#](#the-simple-mail-transfer-protocol
    "链接到这个标题")'
- en: The Simple Mail Transfer Protocol ([SMTP](../glossary.html#term-SMTP)) defined
    in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html) is a client-server
    protocol. The SMTP specification distinguishes between five types of processes
    involved in the delivery of email messages. Email messages are composed on a Mail
    User Agent (MUA). The MUA is usually either an email client or a webmail. The
    MUA sends the email message to a Mail Submission Agent (MSA). The MSA processes
    the received email and forwards it to the Mail Transmission Agent (MTA). The MTA
    is responsible for the transmission of the email, directly or via intermediate
    MTAs to the MTA of the destination domain. This destination MTA will then forward
    the message to the Mail Delivery Agent (MDA) where it will be accessed by the
    recipient’s MUA. SMTP is used for the interactions between MUA and MSA [[12]](#fsmtpauth),
    MSA-MTA and MTA-MTA.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 在[**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html)中定义的简单邮件传输协议([SMTP](../glossary.html#term-SMTP))是一个客户端-服务器协议。SMTP规范区分了参与电子邮件消息投递的五种类型的过程。电子邮件消息是在邮件用户代理（MUA）中编写的。MUA通常是电子邮件客户端或网页邮箱。MUA将电子邮件消息发送到邮件提交代理（MSA）。MSA处理接收到的电子邮件并将其转发到邮件传输代理（MTA）。MTA负责电子邮件的传输，直接或通过中间MTA传输到目标域的MTA。然后，目标MTA将消息转发到邮件投递代理（MDA），在那里它将被收件人的MUA访问。SMTP用于MUA和MSA
    [[12]](#fsmtpauth)，MSA-MTA和MTA-MTA之间的交互。
- en: SMTP is a text-based protocol like many other application-layer protocols on
    the Internet. It relies on the byte-stream service. Servers listen on port 25.
    Clients send commands that are each composed of one line of ASCII text terminated
    by CR+LF. Servers reply by sending ASCII lines that contain a three digit numerical
    error/success code and optional comments.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP类似于许多其他互联网应用层协议的基于文本的协议。它依赖于字节流服务。服务器监听端口25。客户端发送由一个ASCII文本行组成并终止于CR+LF的命令。服务器通过发送包含三位数字错误/成功代码和可选注释的ASCII行进行回复。
- en: The SMTP protocol, like most text-based protocols, is specified as a [BNF](../glossary.html#term-BNF).
    The full BNF is defined in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html).
    The main SMTP commands are defined by the BNF rules shown in [Fig. 31](#fig-smtp-bnf).
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP协议，像大多数基于文本的协议一样，被指定为[BNF](../glossary.html#term-BNF)。完整的BNF定义在[**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html)中。主要的SMTP命令由图31中显示的BNF规则定义。
- en: '[![../_images/smtp-bnf.svg](../Images/c14bdccb9a063300e7e5dc0d244b52c9.png)](../_images/smtp-bnf.svg)'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/smtp-bnf.svg](../Images/c14bdccb9a063300e7e5dc0d244b52c9.png)](../_images/smtp-bnf.svg)'
- en: Fig. 31 BNF specification of the SMTP commands[#](#id60 "Link to this image")
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 图31 SMTP命令的BNF规范[#](#id60 "链接到此图像")
- en: In this BNF, atext corresponds to printable ASCII characters. This BNF rule
    is defined in [**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html).
    The five main commands are EHLO [[13]](#fehlo), MAIL FROM:, RCPT TO:, DATA and
    QUIT. Postmaster is the alias of the system administrator who is responsible for
    a given domain or SMTP server. All domains must have a Postmaster alias. The SMTP
    responses are defined by the BNF shown in [Fig. 32](#fig-smtp-responses).
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在此BNF中，atext对应于可打印的ASCII字符。此BNF规则在[**RFC 5322**](https://datatracker.ietf.org/doc/html/rfc5322.html)中定义。五个主要命令是EHLO
    [[13]](#fehlo), MAIL FROM:, RCPT TO:, DATA和QUIT。Postmaster是负责特定域名或SMTP服务器的系统管理员的别名。所有域名都必须有一个Postmaster别名。SMTP响应由图32中显示的BNF定义。
- en: '![../_images/smtp-response.svg](../Images/699468c24e349ef194f6c3fcb1101a01.png)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/smtp-response.svg](../Images/699468c24e349ef194f6c3fcb1101a01.png)'
- en: Fig. 32 BNF specification of the SMTP responses[#](#id61 "Link to this image")
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 图32 SMTP响应的BNF规范[#](#id61 "链接到此图像")
- en: SMTP servers use structured reply codes containing three digits and an optional
    comment. The first digit of the reply code indicates whether the command was successful
    or not. A reply code of 2xy indicates that the command has been accepted. A reply
    code of 3xy indicates that the command has been accepted, but additional information
    from the client is expected. A reply code of 4xy indicates a transient negative
    reply. This means that for some reason, which is indicated by either the other
    digits or the comment, the command cannot be processed immediately, but there
    is some hope that the problem will only be transient. This is basically telling
    the client to try the same command again later. In contrast, a reply code of 5xy
    indicates a permanent failure or error. In this case, it is useless for the client
    to retry the same command later. Other application layer protocols such as FTP
    [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html) or HTTP [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) use a similar structure
    for their reply codes. Additional details about the other reply codes may be found
    in [**RFC 5321**](https://datatracker.ietf.org/doc/html/rfc5321.html).
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP服务器使用包含三位数字和可选注释的结构化回复代码。回复代码的第一位数字表示命令是否成功。回复代码为2xy表示命令已被接受。回复代码为3xy表示命令已被接受，但需要客户端提供更多信息。回复代码为4xy表示暂时性负面回复。这意味着由于某种原因（由其他数字或注释指示），命令无法立即处理，但仍有希望问题只是暂时的。这基本上是在告诉客户端稍后再次尝试相同的命令。相比之下，回复代码为5xy表示永久性失败或错误。在这种情况下，客户端稍后重试相同的命令是无用的。其他应用层协议，如FTP
    [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html) 或 HTTP [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)，它们的回复代码使用类似的结构。有关其他回复代码的详细信息，请参阅[**RFC
    5321**](https://datatracker.ietf.org/doc/html/rfc5321.html)。
- en: 'Examples of SMTP reply codes include the following :'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP回复代码的示例包括以下内容：
- en: '[PRE34]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Reply code 220 is used by the server as the first message when it agrees to
    interact with the client. Reply code 221 is sent by the server before closing
    the underlying transport connection. Reply code 250 is the standard positive reply
    that indicates the success of the previous command. Reply code 354 indicates that
    the client can start transmitting its email message. Reply code 421 is returned
    when there is a problem (e.g. lack of memory/disk resources) that prevents the
    server from accepting the transport connection. Reply codes 450 and 452 indicate
    that the destination mailbox is temporarily unavailable, for various reasons,
    while reply code 550 indicates that the mailbox does not exist or cannot be used
    for policy reasons. The 500 to 503 reply codes correspond to errors in the commands
    sent by the client. The 503 reply code would be sent by the server when the client
    sends commands in an incorrect order (e.g. the client tries to send an email before
    providing the destination address of the message).
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 回复码 220 是服务器在与客户端交互同意时作为第一条消息使用的。回复码 221 是在关闭底层传输连接之前由服务器发送的。回复码 250 是标准的积极回复，表示前一个命令的成功。回复码
    354 表示客户端可以开始传输其电子邮件消息。当存在阻止服务器接受传输连接的问题（例如内存/磁盘资源不足）时，返回回复码 421。回复码 450 和 452
    表示目标邮箱因各种原因暂时不可用，而回复码 550 表示邮箱不存在或无法使用，原因可能是策略问题。回复码 500 到 503 对应于客户端发送的命令中的错误。当客户端以错误的顺序发送命令时（例如，客户端在提供消息的目标地址之前尝试发送电子邮件），服务器会发送
    503 回复码。
- en: 'The transfer of an email message is performed in three phases. During the first
    phase, the client opens a transport connection with the server. Once the connection
    has been established, the client and the server exchange greetings messages (EHLO
    command). Most servers insist on receiving valid greeting messages and some of
    them drop the underlying transport connection if they do not receive a valid greeting.
    Once the greetings have been exchanged, the email transfer phase can start. During
    this phase, the client transfers one or more email messages by indicating the
    email address of the sender (MAIL FROM: command), the email address of the recipient
    (RCPT TO: command) followed by the headers and the body of the email message (DATA
    command). Once the client has finished sending all its queued email messages to
    the SMTP server, it terminates the SMTP association (QUIT command).'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '电子邮件消息的传输分为三个阶段。在第一阶段，客户端与服务器建立传输连接。一旦连接建立，客户端和服务器交换问候消息（EHLO 命令）。大多数服务器坚持要求接收有效的问候消息，如果它们没有收到有效的问候，其中一些服务器会丢弃底层的传输连接。一旦问候交换完成，电子邮件传输阶段就可以开始。在这个阶段，客户端通过指示发送者的电子邮件地址（MAIL
    FROM: 命令）、接收者的电子邮件地址（RCPT TO: 命令）以及电子邮件消息的头部和正文（DATA 命令）来传输一个或多个电子邮件消息。一旦客户端将其所有排队电子邮件消息发送到
    SMTP 服务器，它将终止 SMTP 协议（QUIT 命令）。'
- en: A successful transfer of an email message is shown below
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个成功的电子邮件消息传输示例
- en: '[PRE35]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the example above, the MTA running on mta.example.org opens a TCP connection
    to the SMTP server on host smtp.example.com. The lines prefixed with S: (resp.
    C:) are the responses sent by the server (resp. the commands sent by the client).
    The server sends its greetings as soon as the TCP connection has been established.
    The client then sends the EHLO command with its fully qualified domain name. The
    server replies with reply-code 250 and sends its greetings. The SMTP association
    can now be used to exchange an email.'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，运行在 mta.example.org 上的 MTA 打开到主机 smtp.example.com 上 SMTP 服务器的 TCP 连接。带有
    S:（分别对应 C:）前缀的行是服务器（分别对应客户端）发送的响应。服务器在 TCP 连接建立后立即发送其问候。客户端随后发送带有其完全限定域名（FQDN）的
    EHLO 命令。服务器以回复码 250 响应并发送其问候。现在可以使用 SMTP 协议交换电子邮件。
- en: 'To send an email, the client must first provide the address of the recipient
    with RCPT TO:. Then it uses the MAIL FROM: with the address of the sender. Both
    the recipient and the sender are accepted by the server. The client can now issue
    the DATA command to start the transfer of the email message. After having received
    the 354 reply code, the client sends the headers and the body of its email message.
    The client indicates the end of the message by sending a line containing only
    the . (dot) character [[14]](#fdot). The server confirms that the email message
    has been queued for delivery or transmission with a reply code of 250. The client
    issues the QUIT command to close the session and the server confirms with reply-code
    221, before closing the TCP connection.'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，客户端必须首先提供收件人的地址，使用RCPT TO:.然后它使用MAIL FROM:发送发送者的地址。服务器接受收件人和发送者。现在，客户端可以发出DATA命令以开始电子邮件消息的传输。在收到354回复代码后，客户端发送其电子邮件消息的标题和正文。客户端通过发送只包含.（点）字符的行来指示消息的结束[[14]](#fdot)。服务器通过回复代码250确认电子邮件消息已被排队等待发送或传输。客户端发出QUIT命令来关闭会话，服务器在关闭TCP连接之前以回复代码221进行确认。
- en: Note
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open SMTP relays and spam
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 开放SMTP中继和垃圾邮件
- en: Since its creation in 1971, email has been a very useful tool that is used by
    many users to exchange lots of information. In the early days, all SMTP servers
    were open and anyone could use them to forward emails towards their final destination.
    Unfortunately, over the years, some unscrupulous users have found ways to use
    email for marketing purposes or to send malware. The first documented abuse of
    email for marketing purposes occurred in 1978 when a marketer who worked for a
    computer vendor sent a [marketing email](http://www.templetons.com/brad/spamreact.html#msg)
    to many ARPANET users. At that time, the ARPANET could only be used for research
    purposes and this was an abuse of the acceptable use policy. Unfortunately, given
    the extremely low cost of sending emails, the problem of unsolicited emails has
    not stopped. Unsolicited emails are now called spam and a [study](http://www.enisa.europa.eu/act/res/other-areas/anti-spam-measures)
    carried out by [ENISA](https://www.enisa.europa.eu/) in 2009 reveals that 95%
    of email was spam and this number seems to continue to grow. This places a burden
    on the email infrastructure of Internet Service Providers and large companies
    that need to process many useless messages.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 自1971年创建以来，电子邮件已经成为一个非常有用的工具，许多用户用它来交换大量信息。在早期，所有的SMTP服务器都是开放的，任何人都可以使用它们将电子邮件转发到最终目的地。不幸的是，多年来，一些不道德的用户找到了利用电子邮件进行营销或发送恶意软件的方法。1978年，一名为计算机供应商工作的营销人员向许多ARPANET用户发送了一封[营销邮件](http://www.templetons.com/brad/spamreact.html#msg)，这是首次有记录的将电子邮件用于营销目的的滥用行为。当时，ARPANET只能用于研究目的，这违反了可接受的使用政策。遗憾的是，由于发送电子邮件的成本极低，未经请求的电子邮件问题并未停止。现在，未经请求的电子邮件被称为垃圾邮件，[ENISA](https://www.enisa.europa.eu/)在2009年进行的一项[研究](http://www.enisa.europa.eu/act/res/other-areas/anti-spam-measures)显示，95%的电子邮件是垃圾邮件，并且这个数字似乎还在继续增长。这给互联网服务提供商和需要处理大量无用信息的公司带来了负担。
- en: Given the amount of spam messages, SMTP servers are no longer open [**RFC 5068**](https://datatracker.ietf.org/doc/html/rfc5068.html).
    Several extensions to SMTP have been developed in recent years to deal with this
    problem. For example, the SMTP authentication scheme defined in [**RFC 4954**](https://datatracker.ietf.org/doc/html/rfc4954.html)
    can be used by an SMTP server to authenticate a client. Several techniques have
    also been proposed to allow SMTP servers to authenticate the messages sent by
    their users [**RFC 4870**](https://datatracker.ietf.org/doc/html/rfc4870.html)
    [**RFC 4871**](https://datatracker.ietf.org/doc/html/rfc4871.html) .
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 由于垃圾邮件的数量，SMTP服务器已不再开放[**RFC 5068**](https://datatracker.ietf.org/doc/html/rfc5068.html)。近年来，已经开发出几个SMTP扩展来处理这个问题。例如，[**RFC
    4954**](https://datatracker.ietf.org/doc/html/rfc4954.html)中定义的SMTP身份验证方案可以被SMTP服务器用来验证客户端。还提出了几种技术，允许SMTP服务器验证用户发送的邮件[**RFC
    4870**](https://datatracker.ietf.org/doc/html/rfc4870.html) [**RFC 4871**](https://datatracker.ietf.org/doc/html/rfc4871.html)。
- en: '### The Post Office Protocol[#](#the-post-office-protocol "Link to this heading")'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '### 邮局协议[#](#the-post-office-protocol "链接到本标题")'
- en: When the first versions of SMTP were designed, the Internet was composed of
    minicomputers that were used by an entire university department or research lab.
    These minicomputers were used by many users at the same time. Email was mainly
    used to send messages from a user on a given host to another user on a remote
    host. At that time, SMTP was the only protocol involved in the delivery of the
    emails as all hosts attached to the network were running an SMTP server. On such
    hosts, an email destined to local users was delivered by placing the email in
    a special directory or file owned by the user. However, the introduction of personal
    computers in the 1980s changed this environment. Initially, users of these personal
    computers used applications such as [telnet](../glossary.html#term-telnet) to
    open a remote session on the local [minicomputer](../glossary.html#term-minicomputer)
    to read their email. This was not user-friendly. A better solution appeared with
    the development of user friendly email client applications on personal computers.
    Several protocols were designed to allow these client applications to retrieve
    the email messages destined to a user from his/her server. Two of these protocols
    became popular and are still used today. The Post Office Protocol (POP), defined
    in [**RFC 1939**](https://datatracker.ietf.org/doc/html/rfc1939.html), is the
    simplest one. It allows a client to download all the messages destined to a given
    user from his/her email server. We describe POP briefly in this section. The second
    protocol is the Internet Message Access Protocol (IMAP), defined in [**RFC 3501**](https://datatracker.ietf.org/doc/html/rfc3501.html).
    IMAP is more powerful, but also more complex than POP. IMAP was designed to allow
    client applications to efficiently access, in real-time, to messages stored in
    various folders on servers. IMAP assumes that all the messages of a given user
    are stored on a server and provides the functions that are necessary to search,
    download, delete or filter messages.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 当SMTP的第一个版本被设计时，互联网由被整个大学部门或研究实验室使用的迷你计算机组成。这些迷你计算机被许多用户同时使用。电子邮件主要用于从一个主机上的用户向远程主机上的另一个用户发送消息。当时，SMTP是唯一涉及电子邮件投递的协议，因为所有连接到网络的宿主都在运行SMTP服务器。在这样的主机上，电子邮件通过将电子邮件放入用户拥有的特殊目录或文件中，以供本地用户接收。然而，20世纪80年代个人计算机的引入改变了这一环境。最初，这些个人计算机的用户使用诸如[telnet](../glossary.html#term-telnet)之类的应用程序在本地[迷你计算机](../glossary.html#term-minicomputer)上打开远程会话来阅读他们的电子邮件。这并不友好。随着在个人计算机上开发用户友好的电子邮件客户端应用程序，出现了更好的解决方案。设计了几种协议，允许这些客户端应用程序从用户的邮件服务器检索指向用户的电子邮件消息。其中两种协议变得流行，并且至今仍在使用。邮局协议（POP），在[**RFC
    1939**](https://datatracker.ietf.org/doc/html/rfc1939.html)中定义，是最简单的一个。它允许客户端从其电子邮件服务器下载所有指向特定用户的消息。我们在此节中简要描述POP。第二种协议是互联网消息访问协议（IMAP），在[**RFC
    3501**](https://datatracker.ietf.org/doc/html/rfc3501.html)中定义。IMAP比POP更强大，但也更复杂。IMAP被设计成允许客户端高效地实时访问服务器上存储在各个文件夹中的消息。IMAP假设特定用户的全部消息都存储在服务器上，并提供搜索、下载、删除或过滤消息所需的函数。
- en: 'POP is another example of a simple line-based protocol. POP runs above the
    bytestream service. A POP server usually listens to port 110\. A POP session is
    composed of three parts : an authorisation phase during which the server verifies
    the client’s credential, a transaction phase during which the client downloads
    messages and an update phase that concludes the session. The client sends commands
    and the server replies are prefixed by +OK to indicate a successful command or
    by -ERR to indicate errors.'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: POP是另一种简单的基于行的协议示例。POP在字节流服务之上运行。一个POP服务器通常监听110端口。一个POP会话由三个部分组成：一个授权阶段，在此期间服务器验证客户端的凭证；一个事务阶段，在此期间客户端下载消息；以及一个更新阶段，它结束了会话。客户端发送命令，服务器的回复以+OK开头，表示命令成功，或以-ERR开头，表示错误。
- en: When a client opens a transport connection with the POP server, the latter sends
    as banner an ASCII-line starting with +OK. The POP session is at that time in
    the authorisation phase. In this phase, the client can send its username (resp.
    password) with the USER (resp. PASS) command. The server replies with +OK if the
    username (resp. password) is valid and -ERR otherwise.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端与POP服务器建立传输连接时，服务器发送一个以+OK开始的ASCII行作为横幅。此时，POP会话处于授权阶段。在这个阶段，客户端可以使用USER（resp.
    PASS）命令发送其用户名（resp. 密码）。如果用户名（resp. 密码）有效，服务器会回复+OK，否则回复-ERR。
- en: Once the username and password have been validated, the POP session enters in
    the transaction phase. In this phase, the client can issue several commands. The
    STAT command is used to retrieve the status of the server. Upon reception of this
    command, the server replies with a line that contains +OK followed by the number
    of messages in the mailbox and the total size of the mailbox in bytes. The RETR
    command, followed by a space and an integer, is used to retrieve the nth message
    of the mailbox. The DELE command is used to mark for deletion the nth message
    of the mailbox.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户名和密码得到验证，POP会话进入事务阶段。在这个阶段，客户端可以发出多个命令。STAT命令用于检索服务器的状态。在接收到此命令后，服务器会回复一行，其中包含+OK，后面跟着邮箱中的消息数量和邮箱的总字节数。RETR命令后跟一个空格和一个整数，用于检索邮箱中的第n条消息。DELE命令用于标记邮箱中的第n条消息为删除。
- en: Once the client has retrieved and possibly deleted the emails contained in the
    mailbox, it must issue the QUIT command. This command terminates the POP session
    and allows the server to delete all the messages that have been marked for deletion
    by using the DELE command.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端检索并可能删除邮箱中的电子邮件，它必须发出QUIT命令。此命令终止POP会话，并允许服务器使用DELE命令删除所有已标记为删除的消息。
- en: 'The figure below provides a simple POP session. All lines prefixed with C:
    (resp. S:) are sent by the client (resp. server).'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 下图提供了一个简单的POP会话。所有以C:（分别对应S:）为前缀的行都是由客户端（分别对应服务器）发送的。
- en: '[PRE36]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, a POP client contacts a POP server on behalf of the user named
    alice. Note that in this example, Alice’s password is sent in clear by the client.
    This implies that if someone is able to capture the packets sent by Alice, he
    will know Alice’s password [[15]](#fapop). Then Alice’s client issues the STAT
    command to know the number of messages that are stored in her mailbox. It then
    retrieves and deletes the first message of the mailbox.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个名为alice的POP客户端代表该用户联系POP服务器。请注意，在这个例子中，Alice的密码是由客户端明文发送的。这意味着如果有人能够捕获Alice发送的包，他将知道Alice的密码
    [[15]](#fapop)。然后Alice的客户端发出STAT命令以了解其邮箱中存储的消息数量。然后它检索并删除邮箱中的第一条消息。
- en: '## The world wide web[#](#the-world-wide-web "Link to this heading")'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '## 全球万维网[#](#the-world-wide-web "链接到这个标题")'
- en: In the early days, the Internet was mainly used for remote terminal access with
    [telnet](https://en.wikipedia.org/wiki/Telnet), email and file transfer. The default
    file transfer protocol, FTP, defined in [**RFC 959**](https://datatracker.ietf.org/doc/html/rfc959.html)
    was widely used. FTP clients and servers are still included in some operating
    systems.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，互联网主要用于远程终端访问，如[telnet](https://en.wikipedia.org/wiki/Telnet)、电子邮件和文件传输。默认的文件传输协议FTP，定义在[**RFC
    959**](https://datatracker.ietf.org/doc/html/rfc959.html)，被广泛使用。FTP客户端和服务器仍包含在一些操作系统中。
- en: 'Many FTP clients offered a user interface similar to a Unix shell and allowed
    clients to browse the file system on the server and to send and retrieve files.
    FTP servers can be configured in two modes :'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 许多FTP客户端提供了类似于Unix shell的用户界面，并允许客户端浏览服务器上的文件系统，发送和检索文件。FTP服务器可以配置为两种模式：
- en: 'authenticated : in this mode, the ftp server only accepts users with a valid
    user name and password. Once authenticated, they can access the files and directories
    according to their permissions'
  id: totrans-981
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证模式：在此模式下，FTP服务器只接受具有有效用户名和密码的用户。一旦认证成功，他们可以按照其权限访问文件和目录。
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-983
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'anonymous : in this mode, clients supply the anonymous user identifier and
    their email address as password. These clients are granted access to a special
    zone of the file system that only contains public files.'
  id: totrans-984
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名模式：在此模式下，客户端提供匿名用户标识符和电子邮件地址作为密码。这些客户端被授予访问文件系统特定区域的权限，该区域仅包含公共文件。
- en: FTP was very popular in the 1990s and early 2000s, but today it has mostly been
    superseded by more recent protocols. Authenticated access to files is mainly done
    by using the Secure Shell ([ssh](https://en.wikipedia.org/wiki/Secure_Shell))
    protocol defined in [**RFC 4251**](https://datatracker.ietf.org/doc/html/rfc4251.html)
    and supported by clients such as [scp](https://www.openssh.org) or [sftp](https://www.openssh.org).
    Nowadays, anonymous access is mainly provided by web protocols.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: FTP在20世纪90年代和21世纪初非常流行，但如今它已被更近期的协议所取代。文件认证访问主要通过使用定义在[**RFC 4251**](https://datatracker.ietf.org/doc/html/rfc4251.html)并得到如[scp](https://www.openssh.org)或[sftp](https://www.openssh.org)等客户端支持的Secure
    Shell ([ssh](https://en.wikipedia.org/wiki/Secure_Shell))协议来实现。如今，匿名访问主要由Web协议提供。
- en: In the late 1980s, high energy physicists working at [CERN](https://www.cern.ch)
    had to efficiently exchange documents about their ongoing and planned experiments.
    [Tim Berners-Lee](https://www.w3.org/People/Berners-Lee/) evaluated several of
    the documents sharing techniques that were available at that time [[B1989]](../bibliography.html#b1989).
    As none of the existing solutions met CERN’s requirements, they chose to develop
    a completely new document sharing system. This system was initially called the
    mesh. It was quickly renamed the world wide web. The starting point for the world
    wide web are hypertext documents. An hypertext document is a document that contains
    references (hyperlinks) to other documents that the reader can immediately access.
    Hypertext was not invented for the world wide web. The idea of hypertext documents
    was proposed in 1945 [[Bush1945]](../bibliography.html#bush1945) and the first
    experiments were done during the 1960s [[Nelson1965]](../bibliography.html#nelson1965)
    [[Myers1998]](../bibliography.html#myers1998) . Compared to the hypertext documents
    that were used in the late 1980s, the main innovation introduced by the world
    wide web was to allow hyperlinks to reference documents stored on different remote
    machines. This is illustrated in [Fig. 33](#fig-web).
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代末，在[欧洲核子研究中心](https://www.cern.ch)工作的粒子物理学家必须有效地交换有关他们正在进行和计划中的实验的文档。[蒂姆·伯纳斯-李](https://www.w3.org/People/Berners-Lee/)评估了当时可用的几种文档共享技术[[B1989]](../bibliography.html#b1989)。由于现有的所有解决方案都不符合欧洲核子研究中心的要求，他们选择开发一个全新的文档共享系统。这个系统最初被称为网状系统。它很快被更名为万维网。万维网的起点是超文本文档。超文本文档是一种包含对其他文档的引用（超链接）的文档，读者可以立即访问。超文本不是为了万维网而发明的。超文本文档的想法是在1945年[[Bush1945]](../bibliography.html#bush1945)提出的，而第一个实验是在20世纪60年代[[Nelson1965]](../bibliography.html#nelson1965)
    [[Myers1998]](../bibliography.html#myers1998)进行的。与20世纪80年代末使用的超文本文档相比，万维网引入的主要创新是允许超链接引用存储在不同远程机器上的文档。这如图33所示。
- en: '![Figure made with TikZ](../Images/203e09d617f034ce3c963e378c622093.png)'
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/203e09d617f034ce3c963e378c622093.png)'
- en: ''
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 33 World-wide web clients and servers
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图33 万维网客户端和服务器
- en: A document sharing system such as the world wide web is composed of three important
    parts.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文档共享系统，如万维网，由三个重要部分组成。
- en: A standardized addressing scheme that unambiguously identifies documents
  id: totrans-991
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个标准化的寻址方案，可以明确地识别文档
- en: ''
  id: totrans-992
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A standard document format : the [HyperText Markup Language](http://www.w3.org/MarkUp)'
  id: totrans-994
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准文档格式：[超文本标记语言](http://www.w3.org/MarkUp)
- en: ''
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-996
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A standardized protocol to efficiently retrieve the documents stored on a server
  id: totrans-997
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个标准化的协议，以有效地检索存储在服务器上的文档
- en: Note
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Open standards and open implementations
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 开放标准和开放实现
- en: Open standards play a key role in the success of the world wide web as we know
    it today. Without open standards, the world wide web would have never reached
    its current size. In addition to open standards, another important factor for
    the success of the web was the availability of open and efficient implementations
    of these standards. When CERN started to work on the web, their objective was
    to build a running system that could be used by physicists. They developed open-source
    implementations of the [first web servers](http://www.w3.org/Daemon/) and [web
    clients](http://www.w3.org/Library/Activity.html). These open-source implementations
    were powerful and could be used as is, by institutions willing to share information.
    They were also extended by other developers who contributed to new features. For
    example, the [NCSA](https://www.ncsa.illinois.edu) added support for images in
    their [Mosaic browser](http://en.wikipedia.org/wiki/Mosaic_(web_browser)) that
    was eventually used to create [Netscape Communications](http://en.wikipedia.org/wiki/Netscape)
    and the first commercial browsers and servers.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 开放标准在我们今天所知的万维网的成功中扮演着关键角色。没有开放标准，万维网不可能达到其当前规模。除了开放标准之外，另一个对万维网成功至关重要的因素是这些标准的开放和高效实现。当欧洲核子研究中心（CERN）开始研究万维网时，他们的目标是构建一个可以被物理学家使用的运行系统。他们开发了[第一个万维网服务器](http://www.w3.org/Daemon/)和[万维网客户端](http://www.w3.org/Library/Activity.html)的开源实现。这些开源实现功能强大，可以被愿意共享信息的机构直接使用。它们也被其他开发者扩展，以贡献新的功能。例如，[NCSA](https://www.ncsa.illinois.edu)
    在他们的 [Mosaic 浏览器](http://en.wikipedia.org/wiki/Mosaic_(web_browser)) 中增加了对图像的支持，该浏览器最终被用来创建
    [Netscape Communications](http://en.wikipedia.org/wiki/Netscape) 和第一个商业浏览器和服务器。
- en: The first components of the world wide web are the Uniform Resource Identifiers
    (URI), defined in [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html).
    A URI is a character string that unambiguously identifies a resource on the world
    wide web. Here is a subset of the BNF for URIs
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网世界的第一个组成部分是统一资源标识符（URI），它在[**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html)中定义。URI是一个字符字符串，它明确地标识了互联网上的一个资源。以下是URI的BNF子集。
- en: '[PRE37]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The first component of a URI is its scheme. A scheme can be seen as a selector,
    indicating the meaning of the fields after it. In practice, the scheme often identifies
    the application-layer protocol that must be used by the client to retrieve the
    document, but it is not always the case. Some schemes do not imply a protocol
    at all and some do not indicate a retrievable document [[16]](#furiretrieve).
    The most frequent schemes are http and https. We focus on http in this section.
    A URI scheme can be defined for almost any application layer protocol [[17]](#furilist).
    The characters : and // follow the scheme of any URI.'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: URI的第一个组成部分是其方案。方案可以被视为一个选择器，指示其后字段的含义。在实践中，方案通常标识客户端必须使用的应用层协议来检索文档，但这并不总是如此。某些方案根本不暗示任何协议，而某些方案则不指示可检索的文档[[16]](#furiretrieve)。最频繁使用的方案是http和https。在本节中，我们重点关注http。可以为几乎任何应用层协议定义URI方案。冒号(:)和双斜杠(//)跟在URI的方案之后。
- en: The second part of the URI is the authority. With retrievable URIs, this includes
    the DNS name or the IP address of the server where the document can be retrieved
    using the protocol specified via the scheme. This name can be preceded by some
    information about the user (e.g. a user name) who is requesting the information.
    Earlier definitions of the URI allowed the specification of a user name and a
    password before the @ character ([**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html)),
    but this is now deprecated as placing a password inside a URI is insecure. The
    host name can be followed by the semicolon character and a port number. A default
    port number is defined for some protocols and the port number should only be included
    in the URI if a non-default port number is used (for other protocols, techniques
    like service DNS records can used).
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: URI的第二部分是权限部分。对于可检索的URI，这包括可以检索文档的服务器DNS名称或IP地址，该服务器通过方案指定的协议来检索文档。这个名称可以由请求信息（例如用户名）的用户信息
    precede。早期的URI定义允许在@字符之前指定用户名和密码（[**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html)），但现在这已被弃用，因为将密码放在URI中是不安全的。主机名后面可以跟分号字符和端口号。某些协议定义了默认端口号，并且只有在使用非默认端口号时才应在URI中包含端口号（对于其他协议，可以使用服务DNS记录等技术）。
- en: The third part of the URI is the path to the document. This path is structured
    as filenames on a Unix host (but it does not imply that the files are indeed stored
    this way on the server). If the path is not specified, the server will return
    a default document. The last two optional parts of the URI are used to provide
    a query parameter and indicate a specific part (e.g. a section in an article)
    of the requested document. Sample URIs are shown below.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: URI的第三部分是文档的路径。这个路径的结构类似于Unix主机上的文件名（但这并不意味着文件确实以这种方式存储在服务器上）。如果未指定路径，服务器将返回默认文档。URI的最后两个可选部分用于提供查询参数并指示请求文档的特定部分（例如文章中的某个部分）。以下显示了示例URI。
- en: '[PRE38]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first URI corresponds to a document named rfc3986.html that is stored on
    the server named tools.ietf.org and can be accessed by using the http protocol
    on its default port. The second URI corresponds to an email message, with subject
    current-issue, that will be sent to user infobot in domain example.com. The mailto:
    URI scheme is defined in [**RFC 2368**](https://datatracker.ietf.org/doc/html/rfc2368.html).
    The third URI references the portion BaseHTTPServer.BaseHTTPRequestHandler of
    the document basehttpserver.html that is stored in the library directory on the
    docs.python.org server. This document can be retrieved by using the http protocol.
    The query parameter highlight=http is associated to this URI. The fourth example
    is a server that operates the [telnet](https://en.wikipedia.org/wiki/Telnet) protocol,
    uses IPv6 address 2001:db8:3080:3::2 and is reachable on port 2323\. The last
    URI is somewhat special. Most users will assume that it corresponds to a document
    stored on the cnn.example.com server. However, to parse this URI, it is important
    to remember that the @ character is used to separate the user name from the host
    name in the authorization part of a URI. This implies that the URI points to a
    document named top_story.htm on the host having IPv4 address 10.0.0.1. The document
    will be retrieved by using the ftp protocol with the user name set to cnn.example.com&story=breaking_news.'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个URI对应于一个名为rfc3986.html的文档，该文档存储在名为tools.ietf.org的服务器上，可以通过使用默认端口上的http协议来访问。第二个URI对应于一个主题为current-issue的电子邮件消息，该消息将被发送到example.com域中的用户infobot。mailto:
    URI方案在[**RFC 2368**](https://datatracker.ietf.org/doc/html/rfc2368.html)中定义。第三个URI引用的是存储在docs.python.org服务器上的库目录中的文档basehttpserver.html的部分BaseHTTPServer.BaseHTTPRequestHandler。该文档可以通过使用http协议检索。查询参数highlight=http与该URI相关联。第四个例子是一个运行[telnet](https://en.wikipedia.org/wiki/Telnet)协议的服务器，使用IPv6地址2001:db8:3080:3::2，并在2323端口上可达。最后一个URI有些特殊。大多数用户会认为它对应于存储在cnn.example.com服务器上的文档。然而，为了解析这个URI，重要的是要记住，在URI的授权部分中，@字符用于将用户名与主机名分开。这意味着URI指向一个名为top_story.htm的文档，该文档存储在具有IPv4地址10.0.0.1的主机上。该文档将通过使用ftp协议并设置用户名为cnn.example.com&story=breaking_news来检索。'
- en: The second component of the word wide web is the HyperText Markup Language (HTML).
    HTML defines the format of the documents that are exchanged on the web. The [first
    version of HTML](http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html)
    was derived from the Standard Generalized Markup Language (SGML) that was standardized
    in 1986 by [ISO](../glossary.html#term-ISO). [SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)
    was designed to support large documents maintained by government, law firms or
    aerospace companies that must be shared efficiently in a machine-readable manner.
    These industries require documents to remain readable and editable for tens of
    years and insisted on a standardized format supported by multiple vendors. Today,
    [SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language) is
    no longer widely used beyond specific applications, but its descendants including
    [HTML](../glossary.html#term-HTML) and [XML](../glossary.html#term-XML) are now
    widespread.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网的第二个组成部分是超文本标记语言（HTML）。HTML定义了在网络上交换的文档的格式。[HTML的第一个版本](http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html)是从1986年由[ISO](../glossary.html#term-ISO)标准化的通用标记语言（SGML）派生出来的。[SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)是为了支持政府、律师事务所或航空航天公司维护的大型文档而设计的，这些文档必须以机器可读的方式高效共享。这些行业要求文档在十年甚至更长时间内保持可读和可编辑，并坚持使用由多个供应商支持的标准化格式。如今，[SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)已不再在特定应用之外广泛使用，但其后裔包括[HTML](../glossary.html#term-HTML)和[XML](../glossary.html#term-XML)现在却非常普遍。
- en: 'A markup language is a structured way of adding annotations about the formatting
    of the document within the document itself. Example markup languages include [troff](https://en.wikipedia.org/wiki/Troff),
    which is used to write the Unix man pages or [Latex](https://en.wikipedia.org/wiki/Latex).
    HTML uses markers to annotate text and a document is composed of HTML elements.
    Each element is usually composed of three parts: a start tag that potentially
    includes some specific attributes, some text (often including other elements),
    and an end tag. A HTML tag is a keyword enclosed in angle brackets. The generic
    form of an HTML element is'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 标记语言是一种在文档内部对文档格式进行注释的结构化方式。例如，标记语言包括[troff](https://en.wikipedia.org/wiki/Troff)，它用于编写Unix手册页或[Latex](https://en.wikipedia.org/wiki/Latex)。HTML使用标记来注释文本，一个文档由HTML元素组成。每个元素通常由三部分组成：一个可能包含一些特定属性的起始标签，一些文本（通常包括其他元素），以及一个结束标签。HTML标签是包含在尖括号内的关键字。HTML元素的通用形式是
- en: '[PRE39]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: More complex HTML elements can also include optional attributes in the start
    tag
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的HTML元素也可以在起始标签中包含可选属性
- en: '[PRE40]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The HTML document shown in [Fig. 34](#fig-html-page) is composed of two parts:
    a header, delineated by the <head> and </head> markers, and a body (between the
    <body> and </body> markers). In the example below, the header only contains a
    title, but other types of information can be included in the header. The body
    contains an image, some text and a list with three hyperlinks. The image is included
    in the web page by indicating its URI between brackets inside the <img src=”…”>
    marker. It is important to note that the image can reside on any server. The client
    will automatically download it when rendering the web page. The <h1>…</h1> marker
    is used to specify the first level of headings. The <ul> marker indicates an unnumbered
    list while the <li> marker indicates a list item. The <a href=”URI”>text</a> indicates
    a hyperlink. The text will be underlined in the rendered web page and the client
    will fetch the specified URI when the user clicks on the link.'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图34](#fig-html-page)中显示的HTML文档由两部分组成：一个由<head>和</head>标记界定的标题，以及一个主体（在<body>和</body>标记之间）。在下面的例子中，标题只包含一个标题，但标题中可以包含其他类型的信息。主体包含一个图像，一些文本和一个包含三个超链接的列表。图像通过在<img
    src=”…”>标记内的括号中指定其URI来包含在网页中。需要注意的是，图像可以位于任何服务器上。当客户端渲染网页时，它会自动下载图像。《h1>…</h1>标记用于指定第一级标题。《ul>标记表示无序列表，而《li>标记表示列表项。《a
    href=”URI”>text</a>表示超链接。在渲染的网页中，文本将被下划线，当用户点击链接时，客户端将获取指定的URI。
- en: '[![../_images/html-page.png](../Images/44780516838bc54a13c36a8fe2321d96.png)](../_images/html-page.png)'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/html-page.png](../Images/44780516838bc54a13c36a8fe2321d96.png)(../_images/html-page.png)'
- en: Fig. 34 A simple HTML page[#](#id63 "Link to this image")
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 图34 一个简单的HTML页面[#](#id63 "链接到这张图片")
- en: Over the years, various extensions to HTML have been proposed and implemented.
    These include the specification of style sheets that adjust the layout of the
    document and the possibility of adding or referencing javascript code. Additional
    details about the various extensions to HTML may be found in the [official specifications](http://www.w3.org/MarkUp/)
    maintained by [W3C](https://www.w3.org).
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，针对HTML的各种扩展已经被提出并实施。这包括指定样式表以调整文档布局以及添加或引用javascript代码的可能性。有关HTML各种扩展的更多详细信息，可以在由[W3C](https://www.w3.org)维护的[官方规范](http://www.w3.org/MarkUp/)中找到。
- en: The HyperText Transfer Protocol[#](#the-hypertext-transfer-protocol "Link to
    this heading")
  id: totrans-1017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超文本传输协议[#](#the-hypertext-transfer-protocol "链接到这个标题")
- en: 'The third component of the world wide web is the HyperText Transfer Protocol
    (HTTP). HTTP is a text-based protocol like SMTP. The client sends a request and
    the server returns a response. HTTP runs above the bytestream service and HTTP
    servers listen by default on port 80. The design of HTTP has largely been inspired
    by the Internet email protocols. Each HTTP request contains three parts :'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网的第三个组成部分是超文本传输协议（HTTP）。HTTP是一种基于文本的协议，类似于SMTP。客户端发送请求，服务器返回响应。HTTP运行在字节流服务之上，默认情况下HTTP服务器监听端口80。HTTP的设计在很大程度上受到了互联网电子邮件协议的启发。每个HTTP请求包含三个部分：
- en: a method, that indicates the type of request, a URI, and the version of the
    HTTP protocol used by the client
  id: totrans-1019
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法，它指示请求的类型、URI以及客户端使用的HTTP协议版本
- en: ''
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a header, that is used by the client to specify optional parameters for the
    request. An empty line is used to mark the end of the header
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，客户端用它来指定请求的可选参数。一个空行用来标记标题的结束
- en: ''
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an optional MIME document attached to the request
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求中附加的可选 MIME 文档
- en: 'The response sent by the server also contains three parts :'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的响应还包含三个部分：
- en: a status line , that indicates whether the request was successful or not
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态行，它指示请求是否成功
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a header, that contains additional information about the response. The response
    header ends with an empty line.
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含有关响应的附加信息的头部。响应头以一个空行结束。
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a MIME document
  id: totrans-1033
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MIME 文档
- en: Figure [Fig. 35](#fig-http-req-resp) provides sample HTTP request and response.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [图 35](#fig-http-req-resp) 提供了示例 HTTP 请求和响应。
- en: '![Figure made with TikZ](../Images/64fd856539fab465e6b2fadde6a8bd15.png)'
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/64fd856539fab465e6b2fadde6a8bd15.png)'
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 35 HTTP requests and responses
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 35 HTTP 请求和响应
- en: 'Several types of method can be used in HTTP requests. The three most important
    ones are :'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求可以使用多种类型的方法。其中三种最重要的是：
- en: 'the GET method is the most popular one. It is used to retrieve a document from
    a server. The GET method is encoded as GET followed by the path of the URI of
    the requested document and the version of HTTP used by the client. For example,
    to retrieve the [http://www.w3.org/MarkUp/](http://www.w3.org/MarkUp/) URI, a
    client must open a TCP connection on port 80 with host www.w3.org and send a HTTP
    request containing the following line:'
  id: totrans-1039
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET 方法是最受欢迎的方法之一。它用于从服务器检索文档。GET 方法编码为 GET，后跟请求文档的 URI 路径和客户端使用的 HTTP 版本。例如，要检索
    [http://www.w3.org/MarkUp/](http://www.w3.org/MarkUp/) URI，客户端必须在端口 80 上打开到主机
    www.w3.org 的 TCP 连接，并发送包含以下行的 HTTP 请求：
- en: ''
  id: totrans-1040
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the HEAD method is a variant of the GET method that allows the retrieval of
    the header lines for a given URI without retrieving the entire document. It can
    be used by a client to verify if a document exists, for instance.
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: HEAD 方法是 GET 方法的变体，允许检索给定 URI 的头部行，而不检索整个文档。它可以由客户端用于验证文档是否存在，例如。
- en: ''
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1047
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the POST method can be used by a client to send a document to a server. The
    document is attached to the HTTP request as a MIME document.
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST 方法可以由客户端用于向服务器发送文档。文档作为 MIME 文档附加到 HTTP 请求中。
- en: HTTP clients and servers can include different HTTP headers in HTTP requests
    and responses. Each HTTP header is encoded as a single ASCII-line terminated by
    CR and LF. Several of these headers are briefly described below. A detailed discussion
    of the standard headers may be found in [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html).
    The MIME headers can appear in both HTTP requests and HTTP responses.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端和服务器可以在 HTTP 请求和响应中包含不同的 HTTP 头。以下简要描述了这些头的一些。有关标准头的详细讨论，请参阅 [**RFC
    1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)。MIME 头可以出现在 HTTP 请求和
    HTTP 响应中。
- en: 'the Content-Length: header is the [MIME](../glossary.html#term-MIME) header
    that indicates the length of the MIME document in bytes.'
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Length: 头是 [MIME](../glossary.html#term-MIME) 头，它指示 MIME 文档的字节数。'
- en: ''
  id: totrans-1051
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1052
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Content-Type: header is the [MIME](../glossary.html#term-MIME) header that
    indicates the type of the attached MIME document. HTML pages use the text/html
    type.'
  id: totrans-1053
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Type: 头是 [MIME](../glossary.html#term-MIME) 头，它指示附加 MIME 文档的类型。HTML
    页面使用 text/html 类型。'
- en: ''
  id: totrans-1054
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Content-Encoding: header indicates how the [MIME document](../glossary.html#term-MIME-document)
    has been encoded. For example, this header would be set to x-gzip for a document
    compressed using the [gzip](https://www.gzip.org) software.'
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Encoding: 头指示 [MIME 文档](../glossary.html#term-MIME-document) 的编码方式。例如，此头将设置为
    x-gzip，用于使用 [gzip](https://www.gzip.org) 软件压缩的文档。'
- en: '[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html) and [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) define headers that
    are specific to HTTP responses. These server headers include:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html) 和 [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) 定义了特定于 HTTP 响应的头部。这些服务器头部包括：'
- en: 'the Server: header indicates the version of the web server that has generated
    the HTTP response. Some servers provide information about their software release
    and optional modules that they use. For security reasons, some system administrators
    disable these headers to avoid revealing too much information about their server
    to potential attackers.'
  id: totrans-1058
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Server: 头指示生成 HTTP 响应的 Web 服务器的版本。一些服务器提供有关它们的软件版本和它们使用的可选模块的信息。出于安全原因，一些系统管理员禁用这些头，以避免向潜在的攻击者透露太多关于其服务器的信息。'
- en: ''
  id: totrans-1059
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1060
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Date: header indicates when the HTTP response has been produced by the
    server.'
  id: totrans-1061
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Date: 头指示服务器何时生成 HTTP 响应。'
- en: ''
  id: totrans-1062
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Last-Modified: header indicates the date and time of the last modification
    of the document attached to the HTTP response.'
  id: totrans-1064
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Last-Modified:头指示附加到HTTP响应的文档的最后修改日期和时间。
- en: 'Similarly, the following header lines can only appear inside HTTP requests
    sent by a client:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下头行只能出现在客户端发送的HTTP请求中：
- en: 'the User-Agent: header provides information about the client that has generated
    the HTTP request. Some servers analyze this header line and return different headers
    and sometimes different documents for different user agents.'
  id: totrans-1066
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: User-Agent:头提供了有关生成HTTP请求的客户端的信息。一些服务器分析这一行头，并为不同的用户代理返回不同的头和有时不同的文档。
- en: ''
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1068
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the If-Modified-Since: header is followed by a date. It enables clients to
    cache in memory or on disk recent or most frequently used documents. When a client
    needs to request a URI from a server, it first checks whether the document is
    already in its cache. If it is, the client sends an HTTP request with the If-Modified-Since:
    header indicating the date of the cached document. The server will only return
    the document attached to the HTTP response if it is newer than the version stored
    in the client’s cache.'
  id: totrans-1069
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: If-Modified-Since:头后面跟着一个日期。它使客户端能够将最近或最常使用的文档缓存到内存或磁盘上。当客户端需要从服务器请求一个URI时，它首先检查文档是否已经在它的缓存中。如果是，客户端会发送一个带有If-Modified-Since:头的HTTP请求，指示缓存文档的日期。如果服务器响应的文档比客户端缓存中的版本新，它才会返回附加到HTTP响应的文档。
- en: ''
  id: totrans-1070
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1071
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Referrer: header is followed by a URI. It indicates the URI of the document
    that the client visited before sending this HTTP request. Thanks to this header,
    the server can know the URI of the document containing the hyperlink followed
    by the client, if any. This information is very useful to measure the impact of
    advertisements containing hyperlinks placed on websites.'
  id: totrans-1072
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Referrer:头后面跟着一个URI。它表示客户端在发送此HTTP请求之前访问的文档的URI。多亏了这个头，服务器可以知道客户端随后跟的超链接所指向的文档的URI，如果有的话。这个信息对于衡量在网站上放置的广告的影响非常有用。
- en: ''
  id: totrans-1073
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1074
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Host: header contains the fully qualified domain name of the URI being
    requested.'
  id: totrans-1075
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Host:头包含正在请求的URI的完全限定域名。
- en: Note
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The importance of the Host: header line'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: Host:头行的重要性
- en: 'The first version of HTTP did not include the Host: header line. This was a
    severe limitation for web hosting companies. For example consider a web hosting
    company that wants to serve both web.example.com and www.example.net on the same
    physical server. Both web sites contain a /index.html document. When a client
    sends a request for either http://web.example.com/index.html or http://www.example.net/index.html,
    the HTTP 1.0 request contains the following line :'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的第一个版本没有包括Host:头行。这对网络托管公司来说是一个严重的限制。例如，考虑一个想要在同一个物理服务器上为web.example.com和www.example.net提供服务的网络托管公司。这两个网站都包含一个/index.html文档。当客户端发送对http://web.example.com/index.html或http://www.example.net/index.html的请求时，HTTP
    1.0请求包含以下行：
- en: '[PRE42]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By parsing this line, a server cannot determine which index.html file is requested.
    Thanks to the Host: header line, the server knows whether the request is for http://web.example.com/index.html
    or http://www.dummy.net/index.html. Without the Host: header, this is impossible.
    The Host: header line allowed web hosting companies to develop their business
    by supporting a large number of independent web servers on the same physical server.'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解析这一行，服务器无法确定请求的是哪个index.html文件。多亏了Host:头行，服务器才能知道请求是针对http://web.example.com/index.html还是http://www.dummy.net/index.html。没有Host:头行，这是不可能的。Host:头行允许网络托管公司通过在同一个物理服务器上支持大量独立的网络服务器来发展他们的业务。
- en: 'The status line of the HTTP response begins with the version of HTTP used by
    the server (usually HTTP/1.0 defined in [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)
    or HTTP/1.1 defined in [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html))
    followed by a three digit status code and additional information in English. HTTP
    status codes have a similar structure as the reply codes used by SMTP:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应的状态行以服务器使用的HTTP版本（通常是定义在[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)中的HTTP/1.0或定义在[**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)中的HTTP/1.1）开头，后跟三位状态码和用英语表示的附加信息。HTTP状态码的结构与SMTP使用的回复码类似：
- en: All status codes starting with digit 2 indicate a valid response. 200 Ok indicates
    that the HTTP request was successfully processed by the server and that the response
    is valid.
  id: totrans-1082
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字2开头的状态码都表示有效的响应。200 Ok表示HTTP请求已被服务器成功处理，并且响应是有效的。
- en: ''
  id: totrans-1083
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1084
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All status codes starting with digit 3 indicate that the requested document
    is no longer available on the server. 301 Moved Permanently indicates that the
    requested document is no longer available on this server. A Location: header containing
    the new URI of the requested document is inserted in the HTTP response. 304 Not
    Modified is used in response to an HTTP request containing the If-Modified-Since:
    header. This status line is used by the server if the document stored on the server
    is not more recent than the date indicated in the If-Modified-Since: header.'
  id: totrans-1085
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '所有以数字3开头的状态码表示请求的文档在服务器上不再可用。301 永久移动表示请求的文档不再在此服务器上可用。在 HTTP 响应中插入一个包含请求文档新
    URI 的 Location: 头部。304 未修改用于响应包含 If-Modified-Since: 头部的 HTTP 请求。此状态行由服务器使用，如果服务器上存储的文档的日期不晚于
    If-Modified-Since: 头部中指示的日期。'
- en: ''
  id: totrans-1086
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1087
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All status codes starting with digit 4 indicate that the server has detected
    an error in the HTTP request sent by the client. 400 Bad Request indicates a syntax
    error in the HTTP request. 404 Not Found indicates that the requested document
    does not exist on the server.
  id: totrans-1088
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字4开头的状态码表示服务器检测到客户端发送的 HTTP 请求中存在错误。400 错误请求表示 HTTP 请求中存在语法错误。404 未找到表示请求的文档在服务器上不存在。
- en: ''
  id: totrans-1089
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1090
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All status codes starting with digit 5 indicate an error on the server. 500
    Internal Server Error indicates that the server could not process the request
    due to an error on the server itself.
  id: totrans-1091
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字5开头的状态码表示服务器上发生错误。500 内部服务器错误表示服务器由于自身错误无法处理请求。
- en: In both HTTP requests and responses, the MIME document refers to a representation
    of the document with the MIME headers indicating the type of document and its
    size.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求和响应中，MIME 文档指的是具有指示文档类型和大小的 MIME 头部的文档表示。
- en: 'As an illustration of HTTP/1.0, the transcript below shows a HTTP request for
    [http://www.ietf.org](http://www.ietf.org) and the corresponding HTTP response.
    The HTTP request was sent using the [curl](https://curl.haxx.se/) command line
    tool. The User-Agent: header line contains more information about this client
    software. There is no MIME document attached to this HTTP request, and it ends
    with a blank line.'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 'As an illustration of HTTP/1.0, the transcript below shows a HTTP request for
    [http://www.ietf.org](http://www.ietf.org) and the corresponding HTTP response.
    The HTTP request was sent using the [curl](https://curl.haxx.se/) command line
    tool. The User-Agent: header line contains more information about this client
    software. There is no MIME document attached to this HTTP request, and it ends
    with a blank line.'
- en: '[PRE43]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The HTTP response indicates the version of the server software used with the
    modules included. The Last-Modified: header indicates that the requested document
    was modified about one week before the request. A HTML document (not shown) is
    attached to the response. Note the blank line between the header of the HTTP response
    and the attached MIME document. The Server: header line has been truncated in
    this output.'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP 响应指示使用的服务器软件版本以及包含的模块。Last-Modified: 头部指示请求的文档在大约一周前被修改。一个 HTML 文档（未显示）附加到响应中。注意
    HTTP 响应头部和附加的 MIME 文档之间的空白行。Server: 头部行在此输出中被截断。'
- en: '[PRE44]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: HTTP was initially designed to share text documents. For this reason, and to
    ease the implementation of clients and servers, the designers of HTTP chose to
    open a TCP connection for each HTTP request. This implies that a client must open
    one TCP connection for each URI that it wants to retrieve from a server as illustrated
    on the figure below, showing HTTP 1.0 and the underlying TCP connection. For a
    web page containing only text documents this was a reasonable design choice as
    the client usually remains idle while the (human) user is reading the retrieved
    document.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 最初被设计用于共享文本文档。因此，为了简化客户端和服务器实现，HTTP 的设计者选择为每个 HTTP 请求打开一个 TCP 连接。这意味着客户端必须为它想要从服务器检索的每个
    URI 打开一个 TCP 连接，如图所示，显示了 HTTP 1.0 和其下层的 TCP 连接。对于只包含文本文档的网页，这是一个合理的设计选择，因为客户端通常在用户阅读检索到的文档时处于空闲状态。
- en: '![msc {'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client", linecolour=black],
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Client", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.request" ] ,
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.indication" ];
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.indication" ];
- en: d1=>c [ label = "CONNECT.response" ] ,
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.response" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.confirm" ];
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.confirm" ];
- en: a1=>b [ label = "DATA.request(Request)", linecolour=red, textcolour=red],
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.request(Request)", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: c==d1 [ label = "DATA.indication(Request)", linecolour=red, textcolour=red];
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: c==d1 [ label = "DATA.indication(Request)", linecolour=red, textcolour=red];
- en: d1=>c [ label = "DATA.request(Response)", linecolour=blue, textcolour=blue]
    ,
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.request(Response)", linecolour=blue, textcolour=blue]
    ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: b=>a1 [ label = "DATA.indication(Response)", linecolour=blue, textcolour=blue],
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DATA.indication(Response)", linecolour=blue, textcolour=blue],
- en: d1=>c [ label = "DISCONNECT.request"],
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.request"],
- en: c>>b [ arcskip="1"];
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.indication" ];
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.indication" ];
- en: a1=>b [ label = "DISCONNECT.request" ] ,
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DISCONNECT.indication" ];
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.indication" ];
- en: '}](../Images/15f6359ba4c5a3cfe439a837a247edb5.png)<map id="d49bedba389123d38d35a1fef746a30e5445ef03"
    name="d49bedba389123d38d35a1fef746a30e5445ef03"></map>'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/15f6359ba4c5a3cfe439a837a247edb5.png)<map id="d49bedba389123d38d35a1fef746a30e5445ef03"
    name="d49bedba389123d38d35a1fef746a30e5445ef03"></map>'
- en: However, as the web evolved to support richer documents containing images, opening
    a TCP connection for each URI became a performance problem [[Mogul1995]](../bibliography.html#mogul1995).
    Indeed, besides its HTML part, a web page may include dozens of images or more.
    Forcing the client to open a TCP connection for each component of a web page has
    two important drawbacks. First, the client and the server must exchange packets
    to open and close a TCP connection as we will see later. This increases the network
    overhead and the total delay of completely retrieving all the components of a
    web page. Second, a large number of established TCP connections may be a performance
    bottleneck on servers.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着网络的发展以支持包含图像等更丰富的文档，为每个URI打开TCP连接成为了一个性能问题[[Mogul1995]](../bibliography.html#mogul1995)。实际上，除了HTML部分，一个网页可能包含数十个或更多的图像。强迫客户端为网页的每个组件打开TCP连接有两个重要的缺点。首先，客户端和服务器必须交换数据包以打开和关闭TCP连接，正如我们稍后将要看到的。这增加了网络开销和完全检索网页所有组件的总延迟。其次，大量建立的TCP连接可能在服务器上成为性能瓶颈。
- en: This problem was solved by extending HTTP to support persistent TCP connections
    [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html). A persistent
    connection is a TCP connection over which a client may send several HTTP requests.
    This is illustrated in the figure below showing the persistent connection of HTTP
    1.1.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题通过扩展HTTP以支持持久TCP连接[**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)得到解决。持久连接是指客户端可以通过该连接发送多个HTTP请求的TCP连接。这在下图中展示了HTTP
    1.1的持久连接。
- en: '![msc {'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client", linecolour=black],
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Client", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.request" ] ,
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.indication" ];
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.indication" ];
- en: d1=>c [ label = "CONNECT.response" ] ,
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.response" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.confirm" ];
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.confirm" ];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET / HTTP1.1\nConnection: Keep-Alive\n...", linecolour=white,
    textcolour=red],'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET / HTTP1.1\nConnection: Keep-Alive\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=100\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=100\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /images/logo.gif HTTP1.1\nConnection: Keep-Alive\n...",
    linecolour=white, textcolour=red],'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /images/logo.gif HTTP1.1\nConnection: Keep-Alive\n...",
    linecolour=white, textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=99\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=99\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: '|||;'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: d1=>c [ label = "DISCONNECT.request"],
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.request"],
- en: c>>b [ arcskip="1"];
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.indication" ];
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.indication" ];
- en: a1=>b [ label = "DISCONNECT.request" ] ,
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DISCONNECT.indication" ];
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.indication" ];
- en: '}](../Images/1dd234f6259caa842e7721e4f7b6857e.png)<map id="e3a7f46f483e3da6d68605217fa3410d14c6e31b"
    name="e3a7f46f483e3da6d68605217fa3410d14c6e31b"></map>'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/1dd234f6259caa842e7721e4f7b6857e.png)<map id="e3a7f46f483e3da6d68605217fa3410d14c6e31b"
    name="e3a7f46f483e3da6d68605217fa3410d14c6e31b"></map>'
- en: 'To allow the clients and servers to control the utilization of these persistent
    TCP connections, HTTP 1.1 [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)
    defines several new HTTP headers:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许客户端和服务器控制这些持久 TCP 连接的利用率，HTTP 1.1 [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)
    定义了几个新的 HTTP 标头：
- en: 'The Connection: header is used with the Keep-Alive argument by the client to
    indicate that it expects the underlying TCP connection to be persistent. When
    this header is used with the Close argument, it indicates that the entity that
    sent it will close the underlying TCP connection at the end of the HTTP response.'
  id: totrans-1166
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Connection: 标头由客户端与 Keep-Alive 参数一起使用，以指示它期望底层 TCP 连接是持久的。当此标头与 Close 参数一起使用时，它表示发送此标头的实体将在
    HTTP 响应结束时关闭底层 TCP 连接。'
- en: ''
  id: totrans-1167
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1168
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Keep-Alive: header is used by the server to inform the client about how
    it agrees to use the persistent connection. A typical Keep-Alive: contains two
    parameters: the maximum number of requests that the server agrees to serve on
    the underlying TCP connection and the timeout (in seconds) after which the server
    will close an idle connection'
  id: totrans-1169
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Keep-Alive: 标头由服务器用于通知客户端它如何同意使用持久连接。典型的 Keep-Alive: 包含两个参数：服务器同意在底层 TCP 连接上服务的最大请求数量以及服务器将在多少秒后关闭空闲连接的超时时间。'
- en: 'The example below shows the operation of HTTP/1.1 over a persistent TCP connection
    to retrieve three URIs stored on the same server. Once the connection has been
    established, the client sends its first request with the Connection: Keep-Alive
    header to request a persistent connection.'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '下面示例展示了 HTTP/1.1 在持久 TCP 连接上操作以检索同一服务器上存储的三个 URI。一旦建立连接，客户端发送第一个请求，并在 Connection:
    Keep-Alive 标头中请求持久连接。'
- en: '[PRE45]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The server replies with the Connection: Keep-Alive header and indicates that
    it accepts a maximum of 100 HTTP requests over this connection and that it will
    close the connection if it remains idle for 15 seconds.'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '服务器回复 Connection: Keep-Alive 标头，并指示它接受通过此连接的最大 100 个 HTTP 请求，并且如果连接空闲 15 秒，它将关闭连接。'
- en: '[PRE46]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The client sends a second request for the style sheet of the retrieved web page.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送第二个请求，请求检索到的网页的样式表。
- en: '[PRE47]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The server replies with the requested style sheet and maintains the persistent
    connection. Note that the server only accepts 99 remaining HTTP requests over
    this persistent connection.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器回复请求的样式表并保持持久连接。请注意，服务器只接受通过此持久连接的 99 个剩余 HTTP 请求。
- en: '[PRE48]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then the client requested the web server’s icon [[18]](#ffavicon). This server
    does not contain such an icon and thus replies with a 404 HTTP status. However,
    the underlying TCP connection is not closed immediately.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户端请求网页服务器的图标 [[18]](#ffavicon)。该服务器不包含此类图标，因此以 404 HTTP 状态码回复。然而，底层的 TCP
    连接并没有立即关闭。
- en: '[PRE49]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As illustrated above, a client can send several HTTP requests over the same
    persistent TCP connection. However, it is important to note that all of these
    HTTP requests are considered to be independent by the server. Each HTTP request
    must be self-contained. This implies that each request must include all the header
    lines that are required by the server to understand the request. The independence
    of these requests is one of the key design choices of HTTP. As a consequence of
    this design choice, when a server processes a HTTP request, it does not use any
    other information than what is contained in the request itself. This explains
    why the client adds its User-Agent: header in all of the HTTP requests that it
    sends over the persistent TCP connection.'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，客户端可以在同一个持久的TCP连接上发送多个HTTP请求。然而，重要的是要注意，服务器认为所有这些HTTP请求都是独立的。每个HTTP请求都必须是自包含的。这意味着每个请求必须包含服务器理解请求所需的所有头部行。这些请求的独立性是HTTP的关键设计选择之一。由于这个设计选择，当服务器处理HTTP请求时，它不会使用请求本身之外的其他任何信息。这解释了为什么客户端会在它通过持久TCP连接发送的所有HTTP请求中添加其User-Agent:头部。
- en: However, in practice, some servers want to provide content tuned for each user.
    For example, some servers can provide information in several languages. Other
    servers want to provide advertisements that are targeted to different types of
    users. To do this, servers need to maintain some information about the preferences
    of each user and use this information to produce content matching the user’s preferences.
    HTTP contains several mechanisms to solve this problem. We discuss three of them
    below.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，一些服务器希望为每个用户提供定制的服务内容。例如，一些服务器可以提供多种语言的信息。其他服务器则希望提供针对不同类型用户的广告。为了做到这一点，服务器需要维护有关每个用户偏好的某些信息，并使用这些信息来生成符合用户偏好的内容。HTTP包含几个机制来解决此问题。以下我们讨论其中三个。
- en: A first solution is to force the users to be authenticated. This was the solution
    used by FTP to control the files that each user could access. Initially, user
    names and passwords could be included inside URIs [**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html).
    However, placing passwords in the clear in a potentially publicly visible URI
    is completely insecure and this usage has now been deprecated [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html).
    HTTP supports several extension headers [**RFC 2617**](https://datatracker.ietf.org/doc/html/rfc2617.html)
    that can be used by a server to request the authentication of the client by providing
    his/her credentials. However, user names and passwords have not been popular on
    web servers as they force human users to remember one user name and one password
    per server. Remembering a password is acceptable when a user needs to access protected
    content, but users will not accept to remember a unique user name and password
    for each web sites that they visit.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案是强制用户进行身份验证。这是FTP用来控制每个用户可以访问的文件所采用的解决方案。最初，用户名和密码可以包含在URI中[**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html)。然而，在可能公开可见的URI中明文放置密码是完全不安全的，并且这种用法现在已经过时[**RFC
    3986**](https://datatracker.ietf.org/doc/html/rfc3986.html)。HTTP支持几个扩展头部[**RFC
    2617**](https://datatracker.ietf.org/doc/html/rfc2617.html)，服务器可以使用这些头部请求客户端通过提供其凭据进行身份验证。然而，用户名和密码在Web服务器上并不受欢迎，因为它们强迫人类用户为每个服务器记住一个用户名和一个密码。当用户需要访问受保护的内容时，记住密码是可以接受的，但用户不会接受为每个他们访问的网站记住一个唯一的用户名和密码。
- en: 'A second solution to allow servers to tune that content to the needs and capabilities
    of the user is to rely on the different types of Accept-* HTTP headers. For example,
    the Accept-Language: header can be used by the client to indicate its preferred
    languages. Unfortunately, in practice this header is usually set based on the
    default language of the browser and it is difficult for a user to indicate the
    language it prefers by selecting options for each visited web server.'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 允许服务器根据用户的需求和能力调整内容的第二种解决方案是依赖于不同的Accept-* HTTP头部。例如，Accept-Language:头部可以被客户端用来表示其首选的语言。不幸的是，在实践中，这个头部通常是基于浏览器的默认语言设置的，用户很难通过为每个访问的Web服务器选择选项来表明他们偏好的语言。
- en: 'The third and widely adopted solution are HTTP cookies. HTTP cookies were initially
    developed as a private extension by [Netscape](https://en.wikipedia.org/wiki/Netscape).
    They are now part of the standard [**RFC 6265**](https://datatracker.ietf.org/doc/html/rfc6265.html).
    In a nutshell, a cookie is a short string that is chosen by a server to represent
    a given client. Two HTTP headers are used : Cookie: and Set-Cookie:. When a server
    receives an HTTP request from a new client (i.e. an HTTP request that does not
    contain the Cookie: header), it generates a cookie for the client and includes
    it in the Set-Cookie: header of the returned HTTP response. The Set-Cookie: header
    contains several additional parameters including the domain names for which the
    cookie is valid. The client stores all received cookies on disk and every time
    it sends an HTTP request, it verifies whether it already knows a cookie for this
    domain. If so, it attaches the Cookie: header to the HTTP request. This is illustrated
    in the figure below with HTTP 1.1, but cookies also work with HTTP 1.0.'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '第三种广泛采用的方法是HTTP cookie。HTTP cookie最初是由[Netscape](https://en.wikipedia.org/wiki/Netscape)作为私有扩展开发的。现在它是标准[**RFC
    6265**](https://datatracker.ietf.org/doc/html/rfc6265.html)的一部分。简而言之，cookie是一个由服务器选择的短字符串，用于表示特定的客户端。使用了两个HTTP头：Cookie:
    和 Set-Cookie:。当服务器收到来自新客户端的HTTP请求（即不包含Cookie:头的HTTP请求）时，它会为该客户端生成一个cookie，并将其包含在返回的HTTP响应的Set-Cookie:头中。Set-Cookie:头包含多个附加参数，包括cookie有效的域名。客户端将所有接收到的cookie存储在磁盘上，每次它发送HTTP请求时，它都会验证是否已经知道该域的cookie。如果是这样，它将Cookie:头附加到HTTP请求中。这如图所示，使用HTTP
    1.1，但cookie也适用于HTTP 1.0。'
- en: '![msc {'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client", linecolour=black],
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="客户端", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: a1=>b [ label = "GET / HTTP1.1\n...", linecolour=white, textcolour=red],
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "GET / HTTP1.1\n...", linecolour=white, textcolour=red],
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nSet-Cookie: machin\n...", linecolour=white,
    textcolour=blue],'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ label = "HTTP/1.1 200 OK\nSet-Cookie: machin\n...", linecolour=white,
    textcolour=blue],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "Browser saves cookie", linecolour=white],
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "浏览器保存cookie", linecolour=white],
- en: c=>d1 [ label = "Normal response", linecolour=white];
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "正常响应", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /doc HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /doc HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: c=>d1 [ label = "Response is function\nof URL and cookie", linecolour=white];
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "响应取决于URL和cookie", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /images/t.gif HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /images/t.gif HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ，
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "Browser sends cookie in\nall requests sent to server", linecolour=white];
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "浏览器在发送到服务器的所有请求中发送cookie", linecolour=white];
- en: '}](../Images/46342147d4ef4a386569e9a3c497ba69.png)<map id="577adf721a7a6a7a5af9beec3659eccef6881630"
    name="577adf721a7a6a7a5af9beec3659eccef6881630"></map>'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/46342147d4ef4a386569e9a3c497ba69.png)<map id="577adf721a7a6a7a5af9beec3659eccef6881630"
    name="577adf721a7a6a7a5af9beec3659eccef6881630"></map>'
- en: Note
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Privacy issues with HTTP cookies
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP cookies 的隐私问题
- en: The HTTP cookies introduced by [Netscape](https://en.wikipedia.org/wiki/Netscape)
    are key for large e-commerce websites. However, they have also raised many discussions
    concerning their [potential misuses](http://www.nytimes.com/2001/09/04/technology/04COOK.html).
    Consider ad.com, a company that delivers lots of advertisements on web sites.
    A web site that wishes to include ad.com’s advertisements next to its content
    will add links to ad.com inside its HTML pages. If ad.com is used by many web
    sites, ad.com could be able to track the interests of all the users that visit
    its client websites and use this information to provide targeted advertisements.
    Privacy advocates have even [sued](http://epic.org/privacy/internet/cookies/)
    online advertisement companies to force them to comply with the privacy regulations.
    More recent related technologies also raise [privacy concerns](http://www.eff.org/deeplinks/2009/09/new-cookie-technologies-harder-see-and-remove-wide).
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape [网景](https://en.wikipedia.org/wiki/Netscape) 引入的 HTTP cookies 对于大型电子商务网站至关重要。然而，它们也引发了关于其[潜在滥用](http://www.nytimes.com/2001/09/04/technology/04COOK.html)的许多讨论。以
    ad.com 公司为例，该公司在网站上投放大量广告。一个希望在其内容旁边包含 ad.com 广告的网站将在其 HTML 页面中添加指向 ad.com 的链接。如果许多网站都使用
    ad.com，那么 ad.com 可能能够追踪访问其客户网站的用户的兴趣，并利用这些信息提供定向广告。隐私倡导者甚至已对在线广告公司提起[诉讼](http://epic.org/privacy/internet/cookies/)，强迫它们遵守隐私法规。最近的相关技术也引发了[隐私担忧](http://www.eff.org/deeplinks/2009/09/new-cookie-technologies-harder-see-and-remove-wide)。
- en: '### HTTP version 2.0[#](#http-version-2-0 "Link to this heading")'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '### HTTP 版本 2.0[#](#http-version-2-0 "链接到本标题")'
- en: During the last decade, a growing number of services have been supported by
    world wide web servers. The web protocols are not only used to deliver static
    documents, they are also used to deliver streaming music or video. They also enable
    clients to use interactive applications including games or productivity applications.
    These services and applications have more stringent performance requirements than
    the delivery of static documents. Many researchers and companies have proposed
    solutions to improve the performance of web services and protocols during the
    last decade [[KR2001]](../bibliography.html#kr2001) [[WBK2014]](../bibliography.html#wbk2014).
    We discuss a subset of them in this section.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，越来越多的服务得到了全球互联网服务器的支持。Web 协议不仅用于传输静态文档，还用于传输流媒体音乐或视频。它们还使客户端能够使用交互式应用程序，包括游戏或生产力应用程序。这些服务和应用程序的性能要求比静态文档的传输更为严格。在过去十年中，许多研究人员和公司提出了提高
    Web 服务和协议性能的解决方案 [[KR2001]](../bibliography.html#kr2001) [[WBK2014]](../bibliography.html#wbk2014)。在本节中，我们讨论了其中的一部分。
- en: 'A first way to improve the performance of the web protocols is to tune the
    servers that provide content. In the early days, documents were stored on a single
    server. Clients established TCP connections to this server to retrieve each document.
    This architecture evolved in several directions. A first way to speedup web services
    is to avoid unnecessary transmissions. Thanks to the HEAD method and the If-Modified-Since:
    header, web browsers can verify that they have the most recent version of a document
    in their cache.'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '提高 Web 协议性能的第一种方法是调整提供内容的服务器。在早期，文档存储在单个服务器上。客户端通过建立到该服务器的 TCP 连接来检索每个文档。这种架构演变出几个方向。加快
    Web 服务的一种方法是避免不必要的传输。多亏了 HEAD 方法以及 If-Modified-Since: 头部，Web 浏览器可以验证它们是否拥有缓存中最新的文档版本。'
- en: '![Figure made with TikZ](../Images/e9483f4f858b0589cf3d76890882a4d6.png)'
  id: totrans-1228
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的照片](../Images/e9483f4f858b0589cf3d76890882a4d6.png)'
- en: ''
  id: totrans-1229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 36 Proxies relay client requests to servers and return the received responses
  id: totrans-1230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 36 代理将客户端请求转发到服务器，并返回接收到的响应
- en: Caches can also be used inside the network. To understand their benefits, let
    us consider an SME with a dozen of employees that are connected to the Internet
    through a low-speed link. These employees often access similar web sites. Consider
    that Alice and Bob want to browse today’s local newspaper. Their browsers will
    both retrieve the newspaper’s website through the low bandwidth link and store
    the main documents in their cache. Unfortunately, the same information passes
    twice over the low-speed link. Some companies have deployed web proxies to cope
    with this problem. A web proxy is a server that resides in the enterprise network.
    All the employee’s browsers are configured to send their HTTP requests to this
    proxy. When such a proxy receives a request, it checks whether the content is
    already stored inside its own cache. If so, it returns it directly. Otherwise,
    the request is sent to the remote server and the information is stored in the
    proxy cache. By reducing the number of web objects that are exchanged over low-speed
    links, such proxies can significantly improve performance. Some companies also
    use them to control the websites that are contacted by their employees and sometimes
    block illegitimate accesses.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存也可以在网络内部使用。为了理解它们的益处，让我们考虑一个拥有十几名员工的小型和中型企业（SME），这些员工通过低速链路连接到互联网。这些员工经常访问相似的网站。假设Alice和Bob想要浏览今天的当地报纸。他们的浏览器将通过低速带宽链路检索报纸的网站并将主要文档存储在他们的缓存中。不幸的是，相同的信息在低速链路上传输了两次。一些公司已经部署了网络代理来解决此问题。网络代理是一个位于企业网络中的服务器。所有员工的浏览器都配置为将他们的HTTP请求发送到这个代理。当这样的代理收到请求时，它会检查内容是否已经存储在其自己的缓存中。如果是这样，它将直接返回。否则，请求将被发送到远程服务器，信息将被存储在代理缓存中。通过减少在低速链路上交换的Web对象数量，此类代理可以显著提高性能。一些公司还使用它们来控制员工接触的网站，有时还会阻止非法访问。
- en: Proxies can also be located in front of servers. In this case, they are called
    reverse-proxies. Consider a dynamic web server that produces web pages by assembling
    information stored in different databases. When this server receives a request,
    it must send multiple queries to its databases and then create the HTML document.
    These queries and the creation of the HTML document take time and this limits
    the number of requests that our server can sustain. Many content providers would
    place a reverse proxy in front of such a server. The DNS servers are configured
    to point to the reverse proxy. Upon reception of a request, the reverse proxy
    first checks whether the response is already stored in its cache. If so, it can
    return it to the client without interacting with the official server. Otherwise,
    the reverse proxy contacts the server and then returns the response to the client.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也可以位于服务器之前。在这种情况下，它们被称为反向代理。考虑一个动态Web服务器，它通过组装存储在不同数据库中的信息来生成网页。当这个服务器收到请求时，它必须向其数据库发送多个查询，然后创建HTML文档。这些查询和HTML文档的创建需要时间，这限制了服务器可以处理的请求数量。许多内容提供商会在这样的服务器前面放置一个反向代理。DNS服务器被配置为指向反向代理。在收到请求后，反向代理首先检查响应是否已经存储在其缓存中。如果是这样，它可以返回给客户端而不与官方服务器交互。否则，反向代理会联系服务器，然后将响应返回给客户端。
- en: These reverse proxies can also be used to spread the load among different servers.
    In the above example, consider that a server needs 10 milliseconds to process
    each request and that it must handle them sequentially. Such a server cannot support
    more than 100 requests per second. If the service becomes popular, then the content
    provider will need to deploy several servers. These servers could serve the same
    reverse proxy.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反向代理也可以用来在不同服务器之间分配负载。在上面的例子中，假设服务器需要10毫秒来处理每个请求，并且必须按顺序处理它们。这样的服务器每秒不能支持超过100个请求。如果服务变得流行，那么内容提供商将需要部署多个服务器。这些服务器可以服务于同一个反向代理。
- en: Note
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Serving content from multiple servers
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 从多个服务器提供内容
- en: When a web user interacts with www.service.net, she expects that all the information
    comes from the www.service.net server. If the service is popular, there are probably
    tens, hundreds, thousands or more physical servers that support this service.
    Still, the user has the illusion that she is interacting with a single server.
    Several techniques have been deployed by content providers to scale web services.
    Consider a simple service that serves text documents from N different servers.
    There are different ways to architect such a service.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web用户与www.service.net交互时，她期望所有信息都来自www.service.net服务器。如果该服务很受欢迎，可能有一百台、一千台或更多的物理服务器支持此服务。尽管如此，用户仍然有一种错觉，认为她正在与单个服务器交互。内容提供商已经部署了多种技术来扩展Web服务。考虑一个简单的服务，该服务从N个不同的服务器中提供文本文档。构建此类服务有不同方式。
- en: A first approach is to store all files on each physical server and rely on the
    DNS to distribute the load among them. Each physical server has its own IP address
    and when the DNS server receives a query for www.service.net, it returns the IP
    address of one of them. Some DNS servers use Round-Robin to return one of these
    IP addresses. Others measure the load of the physical servers and return the address
    of the less loaded one. Another possibility is to locate the physical servers
    in different regions and configure the DNS server to return the IP address of
    the server that is geographically closer to the client’s IP address.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将所有文件存储在每个物理服务器上，并依赖DNS在它们之间分配负载。每个物理服务器都有自己的IP地址，当DNS服务器收到对www.service.net的查询时，它返回其中之一。一些DNS服务器使用轮询（Round-Robin）来返回这些IP地址中的一个。其他DNS服务器会测量物理服务器的负载，并返回负载较轻的那个地址。另一种可能性是将物理服务器放置在不同的地区，并配置DNS服务器以返回地理位置上更靠近客户端IP地址的服务器。
- en: A second approach is to rely on k reverse proxies and N-k servers. The servers
    store the content and the proxies cache the most frequently used files. The proxies
    can be geographically close to the clients while the servers can reside in the
    datacenters of the content provider. The DNS server can also distribute the load
    among the different proxies or return the geographically closest proxy. An important
    point to note about reverse proxies is that they receive HTTP requests from clients
    and send HTTP requests to the original servers that host the content. Several
    companies, usually called Content Distribution Networks, have deployed such reverse
    proxies throughout the world to cache web content next to the end-users. A good
    description of such a CDN may be found in [[NSS2010]](../bibliography.html#nss2010).
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法依赖于k个反向代理和N-k个服务器。服务器存储内容，而代理缓存最常使用的文件。代理可以地理位置上靠近客户端，而服务器可以位于内容提供商的数据中心。DNS服务器也可以在多个代理之间分配负载，或者返回地理位置上最近的代理。关于反向代理的一个重要观点是，它们从客户端接收HTTP请求，并将HTTP请求发送到托管内容的原始服务器。一些公司，通常被称为内容分发网络，已经在全球范围内部署了这样的反向代理，以缓存靠近最终用户的网络内容。在[[NSS2010]](../bibliography.html#nss2010)中可以找到对这种CDN的良好描述。
- en: A second way to improve the web performance is to reduce the time required to
    retrieve web objects. While the first web servers returned an HTML documents with
    possibly a few images, today’s rich web servers return one HTML document with
    associated style sheets, javascript code, images, fonts, … Some of these web objects
    come from the original server while others are hosted on different servers. Today,
    a typical web page contains almost 2 MBytes of data on average. The size of the
    web pages continues to grow according to statistics collected by httparchive.org
    as shown in [Fig. 37](#fig-httparchive). Web pages targeted to mobile devices
    are slightly smaller.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 提高网络性能的第二种方法是减少检索网络对象所需的时间。虽然最初的Web服务器返回了带有可能是一些图像的HTML文档，但今天的丰富Web服务器返回一个包含相关样式表、javascript代码、图像、字体等的HTML文档。其中一些网络对象来自原始服务器，而其他则托管在不同的服务器上。今天，一个典型的Web页面平均包含大约2
    MBytes的数据。根据httparchive.org收集的统计数据，Web页面的尺寸持续增长，如图37所示。针对移动设备的Web页面略小。
- en: '[![../_images/httparchive-bytes.png](../Images/e512429b911bc1ff17df73d156e86ce1.png)](../_images/httparchive-bytes.png)'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/httparchive-bytes.png](../Images/e512429b911bc1ff17df73d156e86ce1.png)'
- en: 'Fig. 37 Evolution of the size of the web pages (source: [https://httparchive.org/reports/page-weight](https://httparchive.org/reports/page-weight))[#](#id66
    "Link to this image")'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 图37 Web页面尺寸的演变（来源：[https://httparchive.org/reports/page-weight](https://httparchive.org/reports/page-weight))[#](#id66
    "链接到这张图片")
- en: A closer look at the average web page shows that it contains, on average, 27
    KBytes of HTML, 120 KBytes of fonts, 60 KBytes of CSS information, almost 1 MBytes
    of images and more than 400 KBytes of javascript. Each of these web page requires
    about 70 different HTTP requests. In other words, a browser needs to send on average
    70 requests to retrieve a complete web page.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察平均网页，可以发现它平均包含27 KBytes的HTML，120 KBytes的字体，60 KBytes的CSS信息，几乎1 MBytes的图像和超过400
    KBytes的javascript。每个网页都需要大约70个不同的HTTP请求。换句话说，浏览器需要平均发送70个请求来检索一个完整的网页。
- en: Two directions have been explored to improve the delivery of these web pages.
    The first direction is to tune the HTTP protocol. The second approach is to change
    the entire network stack. This approach is discussed in the QUIC chapter.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这些网页的传输，已经探索了两个方向。第一个方向是调整HTTP协议。第二个方法是改变整个网络栈。这种方法在QUIC章节中进行了讨论。
- en: One of the limitations of HTTP from a performance viewpoint is that the requests
    that are sent by a browser must be sequential. Typically, a browser requests the
    HTML page. Once the page has been retrieved, the browser parses it to identify
    all the objects that it references and requests them one after each other. The
    web page can only be displayed to the user once all the required web objects have
    been retrieved. This implies that the browser must wait until the reception of
    each response before sending the next request. Another possibility is to allow
    the browser to send multiple requests without waiting for their corresponding
    responses. This approach is called pipelining in [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html).
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，HTTP的一个局限性是浏览器发送的请求必须是顺序的。通常，浏览器请求HTML页面。一旦页面被检索到，浏览器会解析它以识别所有引用的对象，并依次请求它们。只有当所有必要的Web对象都被检索到后，网页才能显示给用户。这意味着浏览器必须在接收每个响应之前等待发送下一个请求。另一种可能性是允许浏览器在不等待相应响应的情况下发送多个请求。这种方法在[**RFC
    7230**](https://datatracker.ietf.org/doc/html/rfc7230.html)中被称为管道化。
- en: To understand the benefits of pipelining, let us consider a simple but illustrative
    example. A client needs to retrieve 5 web objects that are each 100 bytes. The
    underlying transport connection has a 1 Gbps bandwidth but a one-way delay of
    100 msec. A normal HTTP/1.x client would send the first request, wait 200 msec
    to receive the answer, then send another request… It would need one entire second
    to retrieve the five web objects. This is illustrated in [Fig. 38](#fig-http-nopipelining).
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解管道化的好处，让我们考虑一个简单但具有说明性的例子。一个客户端需要检索5个各为100字节的Web对象。底层传输连接具有1 Gbps的带宽，但单向延迟为100毫秒。一个正常的HTTP/1.x客户端会发送第一个请求，等待200毫秒以接收答案，然后发送另一个请求……它需要整整一秒钟来检索五个Web对象。这如图38所示(#fig-http-nopipelining)。
- en: '![Figure made with TikZ](../Images/902ce8ac285bbf69a2f6e825e8e51419.png)'
  id: totrans-1246
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/902ce8ac285bbf69a2f6e825e8e51419.png)'
- en: Fig. 38 A sequence of HTTP requests to a given server
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 图38 对给定服务器的HTTP请求序列
- en: With pipelining, the client sends the five requests immediately and receives
    the five responses after 200 msec. [Fig. 39](#fig-http-pipelining) illustrates
    the benefits of pipelining.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道化，客户端立即发送五个请求，并在200毫秒后收到五个响应。[图39](#fig-http-pipelining)说明了管道化的好处。
- en: '![Figure made with TikZ](../Images/d0394b043492534d50c59a67578ea778.png)'
  id: totrans-1249
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/d0394b043492534d50c59a67578ea778.png)'
- en: Fig. 39 A sequence of HTTP requests to a server with pipelining
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 图39 带有管道化的服务器HTTP请求序列
- en: However, as explained in [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html),
    there is one important limitation to pipelining. It can only be used to serve
    HTTP requests that are idempotent, i.e. none of the requests must depend on any
    of the previous requests in the pipeline. It turned out that it was difficult
    for web browsers to correctly support this requirement and very few of them have
    implemented pipelining [[19]](#fpipelining).
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如[**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html)中所述，管道化有一个重要的限制。它只能用于服务幂等的HTTP请求，即请求中没有任何一个必须依赖于管道中的任何前一个请求。结果发现，网络浏览器正确支持这一要求非常困难，而且其中非常少的部分实现了管道化
    [[19]](#fpipelining)。
- en: Another limitation of HTTP/1.1 is that all commands and parameters are encoded
    as ASCII strings. Using ASCII strings makes it easy to write simple clients or
    debug problems by observing packets. Unfortunately, the burden is placed on servers
    that need to include complex parsers that accept a wide range of partially compliant
    implementations. Furthermore, the flexibility of the ASCII encoding has enabled
    some classes of security attacks on servers [[CWE444]](../bibliography.html#cwe444).
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1的另一个限制是所有命令和参数都编码为ASCII字符串。使用ASCII字符串可以轻松编写简单的客户端或通过观察数据包来调试问题。不幸的是，服务器需要承担负担，包括复杂的解析器，以接受广泛的部分兼容实现。此外，ASCII编码的灵活性使得一些服务器上的安全攻击成为可能
    [[CWE444]](../bibliography.html#cwe444)。
- en: To cope with these two problems, the IETF HTTP working group developed version
    2.0 of HTTP. HTTP/2.0 diverges from HTTP/1.1 in two important ways. First, HTTP/2.0
    relies on binary encoding which is both more compact and easier to parse. Second,
    HTTP/2.0 supports multiple streams, which makes it possible to simultaneously
    transfer different web objects over a single transport connection. Furthermore,
    HTTP/2.0 also compresses the HTTP headers to reduce the amount of data transferred.
    This technique is described in [**RFC 7541**](https://datatracker.ietf.org/doc/html/rfc7541.html)
    but is not discussed in this chapter.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这两个问题，IETF HTTP工作组开发了HTTP的2.0版本。HTTP/2.0在两个重要方面与HTTP/1.1不同。首先，HTTP/2.0依赖于二进制编码，这种编码既更紧凑又更容易解析。其次，HTTP/2.0支持多个流，这使得在单个传输连接上同时传输不同的Web对象成为可能。此外，HTTP/2.0还压缩HTTP头，以减少传输的数据量。这项技术描述在[**RFC
    7541**](https://datatracker.ietf.org/doc/html/rfc7541.html)中，但本章没有讨论。
- en: Let us first examine how HTTP/2.0 structures the bytestream of the underlying
    connection.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来考察一下HTTP/2.0是如何对底层连接的字节流进行结构的。
- en: '[![../_images/http2-frame.svg](../Images/70ec7c103b170dfdecf10fd670dc9b85.png)](../_images/http2-frame.svg)'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/http2-frame.svg](../Images/70ec7c103b170dfdecf10fd670dc9b85.png)](../_images/http2-frame.svg)'
- en: Fig. 40 The HTTP/2.0 Frame header[#](#id69 "Link to this image")
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 图40 HTTP/2.0帧头[#](#id69 "链接到这张图片")
- en: The information exchanged over an HTTP/2.0 session is composed of frames. A
    frame starts with a 9 bytes-long header that carries several types of information
    as shown in [Fig. 40](#fig-http2-frame). The HTTP/2.0 frames have a variable length.
    The Length field of the header contains the length of the frame payload in bytes.
    As this field is encoded as a 24 bits field, an HTTP/2.0 frame cannot be longer
    than \(2^{24} -1\) bytes. It should be noted that [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    assumes a maximum size of \(2^{14}\) bytes, i.e. 16,384 bytes for the HTTP/2.0
    frame payload unless a longer maximum frame length has been negotiated at the
    beginning of the session using the HTTP/2.0 Settings frame that will be described
    later. The next field of the frames header indicates the frame type. The first
    frame types are Data which contains data from web objects and Headers containing
    HTTP/2.0 headers. When a client retrieves a web object from a server, it always
    receives an HTTP/2.0 Headers frame followed by an HTTP/2.0 Data frame. The Headers
    frame information contains essentially the same HTTP headers as the ones supported
    by HTTP/1.1, but those are encoded by leveraging a data compression technique
    that minimizes the number of bytes required to transmit them.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP/2.0会话中交换的信息由帧组成。一个帧以一个9字节长的头部开始，它携带了如图40所示的多类信息。HTTP/2.0帧的长度是可变的。头部中的长度字段包含帧有效载荷的长度（以字节为单位）。由于该字段编码为24位字段，HTTP/2.0帧的长度不能超过\(2^{24}
    -1\)字节。需要注意的是，[**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)假设HTTP/2.0帧有效载荷的最大大小为\(2^{14}\)字节，即16,384字节，除非在会话开始时通过HTTP/2.0设置帧协商了一个更长的最大帧长度，该设置帧将在后面描述。帧头部的下一个字段指示帧类型。最初的帧类型是Data，它包含来自Web对象的数据，以及Headers，包含HTTP/2.0头。当客户端从服务器检索Web对象时，它总是接收到一个HTTP/2.0
    Headers帧，然后是一个HTTP/2.0 Data帧。Headers帧信息基本上与HTTP/1.1支持的HTTP头相同，但它们通过利用数据压缩技术进行编码，以最小化传输这些头所需的字节数。
- en: Other frame types are described later. The Flags are used for some frame types
    and the R bit must be set to zero. The last important field of the HTTP/2.0 Frame
    header is the Stream Identifier. With HTTP/2.0, the bytestream of the underlying
    transport connection is divided in independent streams that are identified by
    an integer. The odd (resp. even) stream identifiers are managed by the client
    (resp. server). This enables the server (or the client) to multiplex data corresponding
    to different frames over a single bytestream.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 其他帧类型将在后面进行描述。标志用于某些帧类型，并且R位必须设置为0。HTTP/2.0帧头中最后一个重要的字段是流标识符。在HTTP/2.0中，底层传输连接的字节流被划分为独立的流，这些流由一个整数标识。奇数（或偶数）流标识符由客户端（或服务器）管理。这使得服务器（或客户端）能够在单个字节流上多路复用对应不同帧的数据。
- en: This multiplexing capability is probably the most important feature of HTTP/2.0
    from a performance viewpoint. To understand its benefits, let us consider a client
    that retrieves two web objects over a 1 Mbps connection. The two requests are
    sent together by the client. The first object is 125 bytes long, while the second
    is 12500 bytes long. In this case, the server will first return the first object
    as a single frame and the second will be sent in the subsequent frame.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多路复用能力可能是从性能角度来看HTTP/2.0最重要的特性。为了理解其优势，让我们考虑一个通过1 Mbps连接检索两个网页对象的客户端。这两个请求由客户端一起发送。第一个对象长度为125字节，而第二个对象长度为12500字节。在这种情况下，服务器将首先以单个帧的形式返回第一个对象，第二个对象将在后续帧中发送。
- en: Consider now that the first object is 12500 bytes long and the second 125 bytes
    long as shown in [Fig. 41](#fig-http-hol). With a 1 Mbps connection, this object
    will use the underlying connection during 100 milliseconds. The client will thus
    need to wait 100 milliseconds to retrieve the second object. This is the Head
    of Line (HoL) blocking problem that affects the performance of many web services.
    If the short web object is a javascript code that requests other web objects,
    its retrieval may be critical to display the retrieved web page.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第一个对象长度为12500字节，第二个对象长度为125字节，如图41所示。在1 Mbps连接下，这个对象将占用底层连接100毫秒。因此，客户端需要等待100毫秒才能检索第二个对象。这是首部阻塞（HoL）问题，它影响了许多网络服务的性能。如果短网页对象是请求其他网页对象的javascript代码，其检索可能对于显示检索到的网页至关重要。
- en: '![Figure made with TikZ](../Images/7fc784e24d2a3dd0171363ba394ef8ba.png)'
  id: totrans-1261
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/7fc784e24d2a3dd0171363ba394ef8ba.png)'
- en: Fig. 41 Head-of-line blocking, a large response may deal a small one
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 图41 首部阻塞，大响应可能影响小响应
- en: With HTTP/2.0 frames, the server could send the first 1250 bytes of the long
    object during 10 milliseconds, then send a second frame that contains the short
    object during one millisecond and later send a longer frame that contains the
    remaining 11250 bytes of the long object. This is illustrated in [Fig. 42](#fig-http2-no-hol).
    In this case, the client has received the short object after 10 milliseconds.
    Given the HTTP/2.0 streams, the transmission of long web objects does not anymore
    blocks the transmission of shorter ones.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP/2.0帧，服务器可以在10毫秒内发送长对象的第一个1250字节，然后发送一个包含短对象的第二个帧，持续一毫秒，之后发送一个包含长对象剩余11250字节的更长的帧。这如图42所示。在这种情况下，客户端在10毫秒后收到了短对象。考虑到HTTP/2.0流，长网页对象的传输不再会阻塞短对象的传输。
- en: The length of the HTTP/2.0 frames obviously affects how different web objects
    can be multiplexed over the underlying transport connection. If HTTP/2.0 frames
    are long, the overhead of the frame header is minimal, but long frames can block
    short web objects. On the other hand, if the frame length is small, then the overhead
    due to the HTTP/2.0 frame header could become significant.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0帧的长度显然会影响不同网页对象如何在底层传输连接上多路复用。如果HTTP/2.0帧很长，帧头的开销最小，但长帧可能会阻塞短网页对象。另一方面，如果帧长度较小，那么由于HTTP/2.0帧头引起的开销可能会变得显著。
- en: '![Figure made with TikZ](../Images/8873fd6b2b8e1c27c72e08f4926f28fb.png)'
  id: totrans-1265
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8873fd6b2b8e1c27c72e08f4926f28fb.png)'
- en: Fig. 42 The data from HTTP/2 frames can be interleaved to prevent head-of-line
    blocking
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 图42 HTTP/2.0帧中的数据可以交错，以防止首部阻塞
- en: The HTTP/2.0 streams can provide performance benefits, but they also increase
    the complexity of the implementations since an HTTP/2.0 receiver must be able
    to simultaneously process frames that correspond to different web objects. This
    complexity mainly resides on the client side. The HTTP/2.0 protocol includes several
    techniques that enable clients to manage the utilization of the HTTP/2.0 session.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 流可以提供性能优势，但它们也增加了实现的复杂性，因为 HTTP/2.0 接收器必须能够同时处理对应于不同网页对象的帧。这种复杂性主要存在于客户端。HTTP/2.0
    协议包括一些技术，使客户端能够管理 HTTP/2.0 会话的利用率。
- en: The first frame that a client sends over an HTTP/2.0 session is the Settings
    frame. This is a control frame that indicates some parameters that the client
    proposes for this session. Several of these parameters are defined in [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html).
    The most important ones are probably the SETTINGS_MAX_FRAME_SIZE that specifies
    the maximum length of the HTTP/2.0 frames that this implementation supports and
    the SETTINGS_MAX_CONCURRENT_STREAMS that specifies the maximum number of parallel
    streams that this implementation can manage. The SETTINGS_MAX_FRAME_SIZE must
    be at least \(2^{14}\) bytes but can go up to \(2^{24} -1\) bytes. There is no
    minimum value for SETTINGS_MAX_CONCURRENT_STREAMS, but [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    recommends to support at least 100 different stream identifiers.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在 HTTP/2.0 会话中发送的第一个帧是设置帧。这是一个控制帧，指示客户端为此次会话提出的某些参数。其中一些参数在 [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    中定义。其中最重要的可能是 SETTINGS_MAX_FRAME_SIZE，它指定了此实现支持的 HTTP/2.0 帧的最大长度，以及 SETTINGS_MAX_CONCURRENT_STREAMS，它指定了此实现可以管理的最大并行流数。SETTINGS_MAX_FRAME_SIZE
    必须至少为 \(2^{14}\) 字节，但可以高达 \(2^{24} -1\) 字节。SETTINGS_MAX_CONCURRENT_STREAMS 没有最小值，但
    [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html) 建议至少支持 100
    个不同的流标识符。
- en: By using multiple streams, the server can multiplex different web objects over
    the same underlying transport connection. However, these objects are only sent
    in response to requests from clients. There are some situations where the server
    might know in advance that the client will request a given object. It could speedup
    the transfer by sending it before having received a client request. This is the
    push feature of HTTP/2.0\. A server can independently push web objects to a client
    without having received any request. This feature can only be used by the server
    if the client has enabled it by sending SETTINGS_ENABLE_PUSH in its Settings frame.
    A classical use case for this push feature is to enable a server to automatically
    send an object which cannot be cached by the client, such as a dynamic javascript
    code, when another web object that references it is requested. However, measurement
    studies indicate that very few web servers seem to have adopted this feature [[ZWH2018]](../bibliography.html#zwh2018).
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个流，服务器可以在相同的底层传输连接上多路复用不同的网页对象。然而，这些对象只有在客户端请求时才会发送。有些情况下，服务器可能事先知道客户端将请求某个特定对象。它可以在收到客户端请求之前发送该对象，从而加快传输速度。这是
    HTTP/2.0 的推送功能。服务器可以在没有收到任何请求的情况下独立地将网页对象推送到客户端。如果客户端通过在它的设置帧中发送 SETTINGS_ENABLE_PUSH
    来启用它，则服务器可以使用此功能。此推送功能的经典用例是使服务器能够自动发送客户端无法缓存的对象，例如动态 JavaScript 代码，当请求引用它的另一个网页对象时。然而，测量研究表明，似乎很少有网页服务器采用了此功能
    [[ZWH2018]](../bibliography.html#zwh2018)。
- en: Another feature of HTTP/2.0 is that it is possible to assign different priorities
    to different streams. A high priority stream should carry more Data frames than
    a lower priority ones. The HTTP/2.0 specification defines Priority frames which
    can be used for this purpose.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 的另一个特性是，可以为不同的流分配不同的优先级。高优先级的流应该携带比低优先级流更多的数据帧。HTTP/2.0 规范定义了用于此目的的优先级帧。
- en: As the server can send multiple objects at the same time, there is a risk of
    overloading the client buffers. To cope with this potential problem, HTTP/2.0
    includes its own flow control mechanism. When an HTTP/2.0 session starts, a receiver
    agrees to receive up to 65,535 bytes over this connection (unless it has indicated
    a different initial window in its Settings frame). This limits the amount of data
    that a sender can transmit over the HTTP/2.0 session. The receiver can advertise
    a large receive window by sending a Window_Update frame at any time. This flow
    control mechanism can be applied to the entire connection or to a specific stream.
    In practice, using a small HTTP/2.0 window could severely limit the throughput
    over an HTTP/2.0 session.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器可以同时发送多个对象，客户端缓冲区过载的风险存在。为了应对这种潜在问题，HTTP/2.0 包含了自己的流量控制机制。当 HTTP/2.0 会话开始时，接收方同意通过此连接接收最多
    65,535 字节（除非它在其设置帧中指示了不同的初始窗口）。这限制了发送方在 HTTP/2.0 会话中可以传输的数据量。接收方可以通过在任何时候发送 Window_Update
    帧来宣传一个大的接收窗口。这种流量控制机制可以应用于整个连接或特定的流。在实践中，使用小的 HTTP/2.0 窗口可能会严重限制 HTTP/2.0 会话的吞吐量。
- en: HTTP/2.0 includes much more than what we have covered in this short introduction.
    There is for example a Ping frame that allows measuring the round-trip-time between
    a client and a server or the GoAway frame that indicates the termination of an
    HTTP/2.0 session. This frame contains an error code that indicates why the session
    has been terminated. Several error codes are defined in [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html),
    including ENHANCE_YOUR_CALM that is used to indicate that the other endpoint exhibits
    an behavior that could cause excessive load.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 包含的内容远不止我们在本简要介绍中涵盖的内容。例如，有一个允许测量客户端和服务器之间往返时间的 Ping 帧，或者表示 HTTP/2.0
    会话终止的 GoAway 帧。此帧包含一个错误代码，指示会话终止的原因。在 [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    中定义了几个错误代码，包括用于指示其他端点表现出可能导致过度负载行为的 ENHANCE_YOUR_CALM。
- en: Note
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Detecting whether a server supports HTTP/2.0
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 检测服务器是否支持 HTTP/2.0
- en: HTTP/2.0 is a new version of the HTTP protocol that still uses port 80\. When
    a client contacts an HTTP server, it must be able to determine whether it supports
    HTTP/1.x or HTTP/2.0\. If the client sends a binary encoded HTTP/2.0 request to
    a server that only supports the ASCII encoded HTTP/1.x, it could cause problems
    on the server and even crash it. To minimize the risk of crashing HTTP/1.x servers,
    an HTTP/2.0 session starts like an HTTP/1.1 session and the first request contains
    the Connection, Upgrade and HTTP2-Settings headers. An example of such a request
    to upgrade the version of HTTP is shown below.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 是 HTTP 协议的新版本，仍然使用端口 80。当客户端联系 HTTP 服务器时，它必须能够确定它是否支持 HTTP/1.x 或 HTTP/2.0。如果客户端向只支持
    ASCII 编码的 HTTP/1.x 服务器发送二进制编码的 HTTP/2.0 请求，可能会在服务器上引起问题，甚至导致其崩溃。为了最小化 HTTP/1.x
    服务器崩溃的风险，HTTP/2.0 会话以 HTTP/1.1 会话的方式开始，第一个请求包含连接、升级和 HTTP2-Settings 标头。以下是一个升级
    HTTP 版本的请求示例。
- en: '[PRE50]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The HTTP2-Settings line contains the HTTP/2.0 settings frame that the client
    would server over an HTTP/2.0 session encoded in Base64\. The server replies with
    a response that indicates that it has accepted to upgrade the connection to HTTP/2.0\.
    A sample response is shown below.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP2-Settings 行包含客户端在 HTTP/2.0 会话中通过 Base64 编码的 HTTP/2.0 设置帧。服务器通过响应表示它已接受升级连接到
    HTTP/2.0。以下是一个示例响应。
- en: '[PRE51]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, the client and the server need to confirm the utilization of HTTP/2.0\.
    A client confirms this by sending the following Magic string PRI * HTTP/2.0rnrnSMrnrn
    or 0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a in hex. This string is followed
    by a SETTINGS frame. The server must send a possibly empty SETTINGS frame.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端和服务器需要确认 HTTP/2.0 的使用。客户端通过发送以下魔法字符串 PRI * HTTP/2.0rnrnSMrnrn 或 0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
    以十六进制表示来确认。此字符串后面跟着一个设置帧。服务器必须发送一个可能为空的设置帧。
- en: The HyperText Transfer Protocol[#](#the-hypertext-transfer-protocol "Link to
    this heading")
  id: totrans-1280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超文本传输协议[#](#the-hypertext-transfer-protocol "链接到这个标题")
- en: 'The third component of the world wide web is the HyperText Transfer Protocol
    (HTTP). HTTP is a text-based protocol like SMTP. The client sends a request and
    the server returns a response. HTTP runs above the bytestream service and HTTP
    servers listen by default on port 80. The design of HTTP has largely been inspired
    by the Internet email protocols. Each HTTP request contains three parts :'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的第三个组成部分是超文本传输协议（HTTP）。HTTP 是一种基于文本的协议，类似于 SMTP。客户端发送请求，服务器返回响应。HTTP 在字节流服务之上运行，并且
    HTTP 服务器默认监听端口 80。HTTP 的设计在很大程度上受到了互联网电子邮件协议的启发。每个 HTTP 请求包含三个部分：
- en: a method, that indicates the type of request, a URI, and the version of the
    HTTP protocol used by the client
  id: totrans-1282
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法，它指示请求的类型、URI 以及客户端使用的 HTTP 协议版本
- en: ''
  id: totrans-1283
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1284
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a header, that is used by the client to specify optional parameters for the
    request. An empty line is used to mark the end of the header
  id: totrans-1285
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个头，客户端用它来指定请求的可选参数。一个空行用于标记头的结束
- en: ''
  id: totrans-1286
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1287
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an optional MIME document attached to the request
  id: totrans-1288
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的 MIME 文档附加到请求中
- en: 'The response sent by the server also contains three parts :'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的响应也包含三个部分：
- en: a status line , that indicates whether the request was successful or not
  id: totrans-1290
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态行，指示请求是否成功
- en: ''
  id: totrans-1291
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1292
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a header, that contains additional information about the response. The response
    header ends with an empty line.
  id: totrans-1293
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个头，包含有关响应的附加信息。响应头以一个空行结束。
- en: ''
  id: totrans-1294
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1295
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a MIME document
  id: totrans-1296
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 MIME 文档
- en: Figure [Fig. 35](#fig-http-req-resp) provides sample HTTP request and response.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [图 35](#fig-http-req-resp) 提供了示例 HTTP 请求和响应。
- en: '![Figure made with TikZ](../Images/64fd856539fab465e6b2fadde6a8bd15.png)'
  id: totrans-1298
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/64fd856539fab465e6b2fadde6a8bd15.png)'
- en: ''
  id: totrans-1299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 35 HTTP requests and responses
  id: totrans-1300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 35 HTTP 请求和响应
- en: 'Several types of method can be used in HTTP requests. The three most important
    ones are :'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求中可以使用多种类型的方法。其中最重要的三种是：
- en: 'the GET method is the most popular one. It is used to retrieve a document from
    a server. The GET method is encoded as GET followed by the path of the URI of
    the requested document and the version of HTTP used by the client. For example,
    to retrieve the [http://www.w3.org/MarkUp/](http://www.w3.org/MarkUp/) URI, a
    client must open a TCP connection on port 80 with host www.w3.org and send a HTTP
    request containing the following line:'
  id: totrans-1302
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET 方法是最受欢迎的一种。它用于从服务器检索文档。GET 方法编码为 GET，后跟请求文档的 URI 路径和客户端使用的 HTTP 版本。例如，要检索
    [http://www.w3.org/MarkUp/](http://www.w3.org/MarkUp/) URI，客户端必须在端口 80 上打开到主机
    www.w3.org 的 TCP 连接，并发送包含以下行的 HTTP 请求：
- en: ''
  id: totrans-1303
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1304
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1306
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ''
  id: totrans-1307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the HEAD method is a variant of the GET method that allows the retrieval of
    the header lines for a given URI without retrieving the entire document. It can
    be used by a client to verify if a document exists, for instance.
  id: totrans-1308
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: HEAD 方法是 GET 方法的变体，允许在不检索整个文档的情况下检索给定 URI 的头行。它可以由客户端用于验证文档是否存在，例如。
- en: ''
  id: totrans-1309
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1310
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the POST method can be used by a client to send a document to a server. The
    document is attached to the HTTP request as a MIME document.
  id: totrans-1311
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST 方法可以由客户端用于将文档发送到服务器。文档作为 MIME 文档附加到 HTTP 请求中。
- en: HTTP clients and servers can include different HTTP headers in HTTP requests
    and responses. Each HTTP header is encoded as a single ASCII-line terminated by
    CR and LF. Several of these headers are briefly described below. A detailed discussion
    of the standard headers may be found in [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html).
    The MIME headers can appear in both HTTP requests and HTTP responses.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端和服务器可以在 HTTP 请求和响应中包含不同的 HTTP 头。每个 HTTP 头都编码为单个以 CR 和 LF 结尾的 ASCII 行。以下简要描述了这些头的一些。有关标准头的详细讨论，请参阅
    [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)。MIME 头可以出现在
    HTTP 请求和 HTTP 响应中。
- en: 'the Content-Length: header is the [MIME](../glossary.html#term-MIME) header
    that indicates the length of the MIME document in bytes.'
  id: totrans-1313
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Length: 头是 [MIME](../glossary.html#term-MIME) 头，它指示 MIME 文档的字节数。'
- en: ''
  id: totrans-1314
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1315
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Content-Type: header is the [MIME](../glossary.html#term-MIME) header that
    indicates the type of the attached MIME document. HTML pages use the text/html
    type.'
  id: totrans-1316
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Type: 头是 [MIME](../glossary.html#term-MIME) 头，它指示附加 MIME 文档的类型。HTML
    页面使用 text/html 类型。'
- en: ''
  id: totrans-1317
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1318
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Content-Encoding: header indicates how the [MIME document](../glossary.html#term-MIME-document)
    has been encoded. For example, this header would be set to x-gzip for a document
    compressed using the [gzip](https://www.gzip.org) software.'
  id: totrans-1319
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Content-Encoding: 头指示 [MIME 文档](../glossary.html#term-MIME-document) 的编码方式。例如，此头将被设置为
    x-gzip，用于使用 [gzip](https://www.gzip.org) 软件压缩的文档。'
- en: '[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html) and [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) define headers that
    are specific to HTTP responses. These server headers include:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html) 和 [**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html) 定义了特定于 HTTP 响应的头。这些服务器头包括：'
- en: 'the Server: header indicates the version of the web server that has generated
    the HTTP response. Some servers provide information about their software release
    and optional modules that they use. For security reasons, some system administrators
    disable these headers to avoid revealing too much information about their server
    to potential attackers.'
  id: totrans-1321
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器头（Server）指示生成 HTTP 响应的 Web 服务器的版本。一些服务器提供有关它们的软件版本和它们使用的可选模块的信息。出于安全原因，一些系统管理员禁用这些头，以避免向潜在的攻击者透露太多关于其服务器的信息。
- en: ''
  id: totrans-1322
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1323
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Date: header indicates when the HTTP response has been produced by the
    server.'
  id: totrans-1324
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期头（Date）指示服务器生成 HTTP 响应的时间。
- en: ''
  id: totrans-1325
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1326
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Last-Modified: header indicates the date and time of the last modification
    of the document attached to the HTTP response.'
  id: totrans-1327
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后修改时间头（Last-Modified）指示附加到 HTTP 响应的文档的最后修改日期和时间。
- en: 'Similarly, the following header lines can only appear inside HTTP requests
    sent by a client:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下头行只能出现在客户端发送的 HTTP 请求中：
- en: 'the User-Agent: header provides information about the client that has generated
    the HTTP request. Some servers analyze this header line and return different headers
    and sometimes different documents for different user agents.'
  id: totrans-1329
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户代理头（User-Agent）提供了有关生成 HTTP 请求的客户端的信息。一些服务器分析这个头行，并为不同的用户代理返回不同的头和有时不同的文档。
- en: ''
  id: totrans-1330
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1331
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the If-Modified-Since: header is followed by a date. It enables clients to
    cache in memory or on disk recent or most frequently used documents. When a client
    needs to request a URI from a server, it first checks whether the document is
    already in its cache. If it is, the client sends an HTTP request with the If-Modified-Since:
    header indicating the date of the cached document. The server will only return
    the document attached to the HTTP response if it is newer than the version stored
    in the client’s cache.'
  id: totrans-1332
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果修改了自上次以来（If-Modified-Since）头后面跟着一个日期。它使客户端能够将最近或最常使用的文档缓存到内存或磁盘上。当客户端需要从服务器请求一个
    URI 时，它首先检查该文档是否已经在它的缓存中。如果是，客户端会发送一个带有 If-Modified-Since 头的 HTTP 请求，指示缓存文档的日期。如果服务器上的文档比客户端缓存中的版本新，服务器才会返回附加到
    HTTP 响应的文档。
- en: ''
  id: totrans-1333
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1334
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Referrer: header is followed by a URI. It indicates the URI of the document
    that the client visited before sending this HTTP request. Thanks to this header,
    the server can know the URI of the document containing the hyperlink followed
    by the client, if any. This information is very useful to measure the impact of
    advertisements containing hyperlinks placed on websites.'
  id: totrans-1335
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用头（Referrer）后面跟着一个 URI。它指示客户端在发送此 HTTP 请求之前访问的文档的 URI。多亏了这个头，服务器可以知道客户端跟随的超链接所包含的文档的
    URI，如果有的话。这个信息对于衡量在网站上放置的广告中包含的超链接的影响非常有用。
- en: ''
  id: totrans-1336
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1337
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the Host: header contains the fully qualified domain name of the URI being
    requested.'
  id: totrans-1338
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机头（Host）包含正在请求的 URI 的完全限定域名。
- en: Note
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The importance of the Host: header line'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: Host 头行的重要性
- en: 'The first version of HTTP did not include the Host: header line. This was a
    severe limitation for web hosting companies. For example consider a web hosting
    company that wants to serve both web.example.com and www.example.net on the same
    physical server. Both web sites contain a /index.html document. When a client
    sends a request for either http://web.example.com/index.html or http://www.example.net/index.html,
    the HTTP 1.0 request contains the following line :'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的第一个版本没有包括 Host 头行。这对网络托管公司来说是一个严重的限制。例如，考虑一个想要在同一个物理服务器上同时托管 web.example.com
    和 www.example.net 的网络托管公司。这两个网站都包含一个 /index.html 文档。当客户端发送对 http://web.example.com/index.html
    或 http://www.example.net/index.html 的请求时，HTTP 1.0 请求包含以下行：
- en: '[PRE53]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By parsing this line, a server cannot determine which index.html file is requested.
    Thanks to the Host: header line, the server knows whether the request is for http://web.example.com/index.html
    or http://www.dummy.net/index.html. Without the Host: header, this is impossible.
    The Host: header line allowed web hosting companies to develop their business
    by supporting a large number of independent web servers on the same physical server.'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解析此行，服务器无法确定请求的是哪个index.html文件。多亏了Host：头行，服务器知道请求是针对http://web.example.com/index.html还是http://www.dummy.net/index.html。没有Host：头，这是不可能的。Host：头行允许网络托管公司通过在同一个物理服务器上支持大量独立的Web服务器来发展他们的业务。
- en: 'The status line of the HTTP response begins with the version of HTTP used by
    the server (usually HTTP/1.0 defined in [**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)
    or HTTP/1.1 defined in [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html))
    followed by a three digit status code and additional information in English. HTTP
    status codes have a similar structure as the reply codes used by SMTP:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应的状态行以服务器使用的HTTP版本开始（通常是定义在[**RFC 1945**](https://datatracker.ietf.org/doc/html/rfc1945.html)中的HTTP/1.0或定义在[**RFC
    2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)中的HTTP/1.1），后面跟着一个三位数的状态码和用英语表示的附加信息。HTTP状态码的结构与SMTP使用的回复码类似：
- en: All status codes starting with digit 2 indicate a valid response. 200 Ok indicates
    that the HTTP request was successfully processed by the server and that the response
    is valid.
  id: totrans-1345
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字2开头的状态码表示有效的响应。200 正常表示HTTP请求已被服务器成功处理，并且响应是有效的。
- en: ''
  id: totrans-1346
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1347
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All status codes starting with digit 3 indicate that the requested document
    is no longer available on the server. 301 Moved Permanently indicates that the
    requested document is no longer available on this server. A Location: header containing
    the new URI of the requested document is inserted in the HTTP response. 304 Not
    Modified is used in response to an HTTP request containing the If-Modified-Since:
    header. This status line is used by the server if the document stored on the server
    is not more recent than the date indicated in the If-Modified-Since: header.'
  id: totrans-1348
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字3开头的状态码表示请求的文档在服务器上不再可用。301 永久移动表示请求的文档不再在此服务器上可用。HTTP响应中插入一个包含请求文档新URI的Location：头。304
    未修改用于响应包含If-Modified-Since：头的HTTP请求。如果服务器上存储的文档的日期不晚于If-Modified-Since：头中指示的日期，则服务器使用此状态行。
- en: ''
  id: totrans-1349
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1350
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All status codes starting with digit 4 indicate that the server has detected
    an error in the HTTP request sent by the client. 400 Bad Request indicates a syntax
    error in the HTTP request. 404 Not Found indicates that the requested document
    does not exist on the server.
  id: totrans-1351
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字4开头的状态码表示服务器检测到客户端发送的HTTP请求中存在错误。400 错误请求表示HTTP请求中存在语法错误。404 未找到表示请求的文档在服务器上不存在。
- en: ''
  id: totrans-1352
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1353
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All status codes starting with digit 5 indicate an error on the server. 500
    Internal Server Error indicates that the server could not process the request
    due to an error on the server itself.
  id: totrans-1354
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以数字5开头的状态码表示服务器上发生错误。500 服务器内部错误表示服务器由于自身错误无法处理请求。
- en: In both HTTP requests and responses, the MIME document refers to a representation
    of the document with the MIME headers indicating the type of document and its
    size.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP请求和响应中，MIME文档指的是具有MIME头指示文档类型和大小的文档表示。
- en: 'As an illustration of HTTP/1.0, the transcript below shows a HTTP request for
    [http://www.ietf.org](http://www.ietf.org) and the corresponding HTTP response.
    The HTTP request was sent using the [curl](https://curl.haxx.se/) command line
    tool. The User-Agent: header line contains more information about this client
    software. There is no MIME document attached to this HTTP request, and it ends
    with a blank line.'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个HTTP/1.0的示例，展示了针对[http://www.ietf.org](http://www.ietf.org)的HTTP请求及其相应的HTTP响应。HTTP请求是通过[curl](https://curl.haxx.se/)命令行工具发送的。User-Agent：头行包含有关此客户端软件的更多信息。此HTTP请求没有附加MIME文档，并以一个空行结束。
- en: '[PRE54]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The HTTP response indicates the version of the server software used with the
    modules included. The Last-Modified: header indicates that the requested document
    was modified about one week before the request. A HTML document (not shown) is
    attached to the response. Note the blank line between the header of the HTTP response
    and the attached MIME document. The Server: header line has been truncated in
    this output.'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应指示了所使用的服务器软件版本以及包含的模块。Last-Modified:头指示请求的文档在大约一周前被修改。附带的HTML文档（未显示）包含在响应中。注意HTTP响应头和附加的MIME文档之间的空白行。Server:头行在此输出中被截断。
- en: '[PRE55]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: HTTP was initially designed to share text documents. For this reason, and to
    ease the implementation of clients and servers, the designers of HTTP chose to
    open a TCP connection for each HTTP request. This implies that a client must open
    one TCP connection for each URI that it wants to retrieve from a server as illustrated
    on the figure below, showing HTTP 1.0 and the underlying TCP connection. For a
    web page containing only text documents this was a reasonable design choice as
    the client usually remains idle while the (human) user is reading the retrieved
    document.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP最初被设计用于共享文本文档。因此，为了简化客户端和服务器的设计实现，HTTP的设计者选择了为每个HTTP请求打开一个TCP连接。这意味着客户端必须为它从服务器检索的每个URI打开一个TCP连接，如图所示，显示了HTTP
    1.0及其底层的TCP连接。对于一个只包含文本文档的网页，这是一个合理的设计选择，因为客户端通常在用户阅读检索到的文档时处于空闲状态。
- en: '![msc {'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client", linecolour=black],
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Client", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Server", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.request" ] ,
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.indication" ];
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.indication" ];
- en: d1=>c [ label = "CONNECT.response" ] ,
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.response" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.confirm" ];
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.confirm" ];
- en: a1=>b [ label = "DATA.request(Request)", linecolour=red, textcolour=red],
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.request(Request)", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: c==d1 [ label = "DATA.indication(Request)", linecolour=red, textcolour=red];
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: c==d1 [ label = "DATA.indication(Request)", linecolour=red, textcolour=red];
- en: d1=>c [ label = "DATA.request(Response)", linecolour=blue, textcolour=blue]
    ,
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.request(Response)", linecolour=blue, textcolour=blue]
    ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: b=>a1 [ label = "DATA.indication(Response)", linecolour=blue, textcolour=blue],
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DATA.indication(Response)", linecolour=blue, textcolour=blue],
- en: d1=>c [ label = "DISCONNECT.request"],
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.request"],
- en: c>>b [ arcskip="1"];
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.indication" ];
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.indication" ];
- en: a1=>b [ label = "DISCONNECT.request" ] ,
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DISCONNECT.indication" ];
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.indication" ];
- en: '}](../Images/15f6359ba4c5a3cfe439a837a247edb5.png)<map id="d49bedba389123d38d35a1fef746a30e5445ef03"
    name="d49bedba389123d38d35a1fef746a30e5445ef03"></map>'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/15f6359ba4c5a3cfe439a837a247edb5.png)<map id="d49bedba389123d38d35a1fef746a30e5445ef03"
    name="d49bedba389123d38d35a1fef746a30e5445ef03"></map>'
- en: However, as the web evolved to support richer documents containing images, opening
    a TCP connection for each URI became a performance problem [[Mogul1995]](../bibliography.html#mogul1995).
    Indeed, besides its HTML part, a web page may include dozens of images or more.
    Forcing the client to open a TCP connection for each component of a web page has
    two important drawbacks. First, the client and the server must exchange packets
    to open and close a TCP connection as we will see later. This increases the network
    overhead and the total delay of completely retrieving all the components of a
    web page. Second, a large number of established TCP connections may be a performance
    bottleneck on servers.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着网络的发展以支持包含图像等更丰富的文档，为每个URI打开TCP连接成为了一个性能问题 [[Mogul1995]](../bibliography.html#mogul1995)。实际上，除了HTML部分，一个网页可能包含数十个甚至更多的图像。强迫客户端为网页的每个组件打开TCP连接有两个重要的缺点。首先，客户端和服务器必须交换数据包以打开和关闭TCP连接，正如我们稍后将要看到的。这增加了网络开销和完全检索网页所有组件的总延迟。其次，大量建立的TCP连接可能在服务器上成为性能瓶颈。
- en: This problem was solved by extending HTTP to support persistent TCP connections
    [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html). A persistent
    connection is a TCP connection over which a client may send several HTTP requests.
    This is illustrated in the figure below showing the persistent connection of HTTP
    1.1.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题通过扩展HTTP以支持持久TCP连接[**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)得到解决。持久连接是指客户端可以通过该连接发送多个HTTP请求的TCP连接。这在下图中展示了HTTP
    1.1的持久连接。
- en: '![msc {'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [标签="", 线条颜色=白色],
- en: a [label="", linecolour=white],
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: a [标签="", 线条颜色=白色],
- en: b [label="Client", linecolour=black],
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: b [标签="客户端", 线条颜色=黑色],
- en: z [label="", linecolour=white],
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: z [标签="", 线条颜色=白色],
- en: c [label="Server", linecolour=black],
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: c [标签="服务器", 线条颜色=黑色],
- en: d [label="", linecolour=white],
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: d [标签="", 线条颜色=白色],
- en: d1 [label="", linecolour=white];
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [标签="", 线条颜色=白色];
- en: a1=>b [ label = "CONNECT.request" ] ,
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "CONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 标签 = "", 弧跳过="1"];
- en: c=>d1 [ label = "CONNECT.indication" ];
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "CONNECT.indication" ];
- en: d1=>c [ label = "CONNECT.response" ] ,
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "CONNECT.response" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 标签 = "", 弧跳过="1"];
- en: b=>a1 [ label = "CONNECT.confirm" ];
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "CONNECT.confirm" ];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "", 线条颜色=红色, 文本颜色=红色].
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 线条颜色=红色, 弧跳过="1"];
- en: 'a1=>b [ label = "GET / HTTP1.1\nConnection: Keep-Alive\n...", linecolour=white,
    textcolour=red],'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ 标签 = "GET / HTTP1.1\n连接: 保持连接\n...", 线条颜色=白色, 文本颜色=红色],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "", 线条颜色=红色, 文本颜色=红色];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "", 线条颜色=蓝色, 文本颜色=蓝色] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 线条颜色=蓝色, 弧跳过="1" ];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=100\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ 标签 = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=100\n连接: 保持连接\n...",
    线条颜色=白色, 文本颜色=蓝色],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "", 线条颜色=蓝色, 文本颜色=蓝色];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "", 线条颜色=红色, 文本颜色=红色],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 线条颜色=红色, 弧跳过="1"];
- en: 'a1=>b [ label = "GET /images/logo.gif HTTP1.1\nConnection: Keep-Alive\n...",
    linecolour=white, textcolour=red],'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ 标签 = "GET /images/logo.gif HTTP1.1\n连接: 保持连接\n...", 线条颜色=白色, 文本颜色=红色],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "", 线条颜色=红色, 文本颜色=红色];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "", 线条颜色=蓝色, 文本颜色=蓝色] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 线条颜色=蓝色, 弧跳过="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=99\nConnection:
    Keep-Alive\n...", linecolour=white, textcolour=blue],'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ 标签 = "HTTP/1.1 200 OK\nKeep-Alive: timeout=15, max=99\n连接: 保持连接\n...",
    线条颜色=白色, 文本颜色=蓝色],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "", 线条颜色=蓝色, 文本颜色=蓝色];
- en: '|||;'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '|||;'
- en: d1=>c [ label = "DISCONNECT.request"],
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ 标签 = "DISCONNECT.request"],
- en: c>>b [ arcskip="1"];
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ 弧跳过="1"];
- en: b=>a1 [ label = "DISCONNECT.indication" ];
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ 标签 = "DISCONNECT.indication" ];
- en: a1=>b [ label = "DISCONNECT.request" ] ,
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ 标签 = "DISCONNECT.request" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ 标签 = "", 弧跳过="1"];
- en: c=>d1 [ label = "DISCONNECT.indication" ];
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ 标签 = "DISCONNECT.indication" ];
- en: '}](../Images/1dd234f6259caa842e7721e4f7b6857e.png)<map id="e3a7f46f483e3da6d68605217fa3410d14c6e31b"
    name="e3a7f46f483e3da6d68605217fa3410d14c6e31b"></map>'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/1dd234f6259caa842e7721e4f7b6857e.png)<map id="e3a7f46f483e3da6d68605217fa3410d14c6e31b"
    name="e3a7f46f483e3da6d68605217fa3410d14c6e31b"></map>'
- en: 'To allow the clients and servers to control the utilization of these persistent
    TCP connections, HTTP 1.1 [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)
    defines several new HTTP headers:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许客户端和服务器控制这些持久TCP连接的利用率，HTTP 1.1 [**RFC 2616**](https://datatracker.ietf.org/doc/html/rfc2616.html)定义了几个新的HTTP头：
- en: 'The Connection: header is used with the Keep-Alive argument by the client to
    indicate that it expects the underlying TCP connection to be persistent. When
    this header is used with the Close argument, it indicates that the entity that
    sent it will close the underlying TCP connection at the end of the HTTP response.'
  id: totrans-1429
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Connection: 头部与Keep-Alive参数一起使用时，客户端用来表示它期望底层的TCP连接是持久的。当此头部与Close参数一起使用时，表示发送此头部的实体将在HTTP响应结束时关闭底层的TCP连接。'
- en: ''
  id: totrans-1430
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1431
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Keep-Alive: header is used by the server to inform the client about how
    it agrees to use the persistent connection. A typical Keep-Alive: contains two
    parameters: the maximum number of requests that the server agrees to serve on
    the underlying TCP connection and the timeout (in seconds) after which the server
    will close an idle connection'
  id: totrans-1432
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Keep-Alive: 头部由服务器用于通知客户端它如何同意使用持久连接。典型的Keep-Alive: 包含两个参数：服务器同意在底层TCP连接上服务的最大请求数量以及服务器将在多少秒后关闭空闲连接的超时时间。'
- en: 'The example below shows the operation of HTTP/1.1 over a persistent TCP connection
    to retrieve three URIs stored on the same server. Once the connection has been
    established, the client sends its first request with the Connection: Keep-Alive
    header to request a persistent connection.'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的示例显示了通过持久TCP连接操作HTTP/1.1以检索存储在同一服务器上的三个URI。一旦建立连接，客户端就发送带有 Connection: Keep-Alive
    头部的第一个请求，以请求持久连接。'
- en: '[PRE56]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The server replies with the Connection: Keep-Alive header and indicates that
    it accepts a maximum of 100 HTTP requests over this connection and that it will
    close the connection if it remains idle for 15 seconds.'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '服务器回复带有 Connection: Keep-Alive 头部信息，并表明它接受通过此连接发送的最大100个HTTP请求，并且如果连接空闲15秒后，它将关闭连接。'
- en: '[PRE57]'
  id: totrans-1436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The client sends a second request for the style sheet of the retrieved web page.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送第二个请求，以获取检索到的网页的样式表。
- en: '[PRE58]'
  id: totrans-1438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The server replies with the requested style sheet and maintains the persistent
    connection. Note that the server only accepts 99 remaining HTTP requests over
    this persistent connection.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器回复请求的样式表，并保持持久连接。请注意，服务器在此持久连接上仅接受99个剩余的HTTP请求。
- en: '[PRE59]'
  id: totrans-1440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then the client requested the web server’s icon [[18]](#ffavicon). This server
    does not contain such an icon and thus replies with a 404 HTTP status. However,
    the underlying TCP connection is not closed immediately.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户端请求网站的图标 [[18]](#ffavicon)。该服务器不包含此类图标，因此回复404 HTTP状态。然而，底层的TCP连接不会立即关闭。
- en: '[PRE60]'
  id: totrans-1442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As illustrated above, a client can send several HTTP requests over the same
    persistent TCP connection. However, it is important to note that all of these
    HTTP requests are considered to be independent by the server. Each HTTP request
    must be self-contained. This implies that each request must include all the header
    lines that are required by the server to understand the request. The independence
    of these requests is one of the key design choices of HTTP. As a consequence of
    this design choice, when a server processes a HTTP request, it does not use any
    other information than what is contained in the request itself. This explains
    why the client adds its User-Agent: header in all of the HTTP requests that it
    sends over the persistent TCP connection.'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '如上图所示，客户端可以在同一持久TCP连接上发送多个HTTP请求。然而，重要的是要注意，服务器将这些HTTP请求视为相互独立。每个HTTP请求都必须是自包含的。这意味着每个请求必须包含服务器理解请求所需的所有头部行。这些请求的独立性是HTTP的关键设计选择之一。由于这个设计选择，当服务器处理HTTP请求时，它不会使用请求本身之外的其他任何信息。这也解释了为什么客户端在通过持久TCP连接发送的所有HTTP请求中都添加了User-Agent:
    头部。'
- en: However, in practice, some servers want to provide content tuned for each user.
    For example, some servers can provide information in several languages. Other
    servers want to provide advertisements that are targeted to different types of
    users. To do this, servers need to maintain some information about the preferences
    of each user and use this information to produce content matching the user’s preferences.
    HTTP contains several mechanisms to solve this problem. We discuss three of them
    below.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际应用中，一些服务器希望为每个用户提供定制的内容。例如，一些服务器可以提供多种语言的信息。其他服务器则希望提供针对不同类型用户的广告。为此，服务器需要维护有关每个用户偏好的某些信息，并使用这些信息生成符合用户偏好的内容。HTTP包含几个机制来解决此问题。以下我们讨论其中的三个。
- en: A first solution is to force the users to be authenticated. This was the solution
    used by FTP to control the files that each user could access. Initially, user
    names and passwords could be included inside URIs [**RFC 1738**](https://datatracker.ietf.org/doc/html/rfc1738.html).
    However, placing passwords in the clear in a potentially publicly visible URI
    is completely insecure and this usage has now been deprecated [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html).
    HTTP supports several extension headers [**RFC 2617**](https://datatracker.ietf.org/doc/html/rfc2617.html)
    that can be used by a server to request the authentication of the client by providing
    his/her credentials. However, user names and passwords have not been popular on
    web servers as they force human users to remember one user name and one password
    per server. Remembering a password is acceptable when a user needs to access protected
    content, but users will not accept to remember a unique user name and password
    for each web sites that they visit.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案是强制用户进行身份验证。这是 FTP 用于控制每个用户可以访问的文件所采用的解决方案。最初，用户名和密码可以包含在 URI 中 [**RFC
    1738**](https://datatracker.ietf.org/doc/html/rfc1738.html)。然而，在可能公开可见的 URI 中明文放置密码是完全不安全的，并且这种用法现在已经过时
    [**RFC 3986**](https://datatracker.ietf.org/doc/html/rfc3986.html)。HTTP 支持几个扩展头部
    [**RFC 2617**](https://datatracker.ietf.org/doc/html/rfc2617.html)，服务器可以通过提供其凭据来请求客户端进行身份验证。然而，用户名和密码在
    Web 服务器上并不受欢迎，因为它们强迫人类用户为每个服务器记住一个用户名和一个密码。当用户需要访问受保护的内容时，记住密码是可以接受的，但用户不会接受为每个他们访问的网站记住一个唯一的用户名和密码。
- en: 'A second solution to allow servers to tune that content to the needs and capabilities
    of the user is to rely on the different types of Accept-* HTTP headers. For example,
    the Accept-Language: header can be used by the client to indicate its preferred
    languages. Unfortunately, in practice this header is usually set based on the
    default language of the browser and it is difficult for a user to indicate the
    language it prefers by selecting options for each visited web server.'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '允许服务器根据用户的需求和能力调整内容的第二个解决方案是依赖于不同的 Accept-* HTTP 头部。例如，Accept-Language: 头部可以被客户端用来表示其首选的语言。不幸的是，在实践中，这个头部通常基于浏览器的默认语言来设置，用户很难通过为每个访问的网站选择选项来表明他们偏好的语言。'
- en: 'The third and widely adopted solution are HTTP cookies. HTTP cookies were initially
    developed as a private extension by [Netscape](https://en.wikipedia.org/wiki/Netscape).
    They are now part of the standard [**RFC 6265**](https://datatracker.ietf.org/doc/html/rfc6265.html).
    In a nutshell, a cookie is a short string that is chosen by a server to represent
    a given client. Two HTTP headers are used : Cookie: and Set-Cookie:. When a server
    receives an HTTP request from a new client (i.e. an HTTP request that does not
    contain the Cookie: header), it generates a cookie for the client and includes
    it in the Set-Cookie: header of the returned HTTP response. The Set-Cookie: header
    contains several additional parameters including the domain names for which the
    cookie is valid. The client stores all received cookies on disk and every time
    it sends an HTTP request, it verifies whether it already knows a cookie for this
    domain. If so, it attaches the Cookie: header to the HTTP request. This is illustrated
    in the figure below with HTTP 1.1, but cookies also work with HTTP 1.0.'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '第三个并且被广泛采用的解决方案是 HTTPCookies。HTTPCookies最初是由[Netscape](https://en.wikipedia.org/wiki/Netscape)作为一个私有扩展开发的。它们现在是标准的组成部分
    [**RFC 6265**](https://datatracker.ietf.org/doc/html/rfc6265.html)。简而言之，cookie
    是服务器选择的一个短字符串，用来代表一个特定的客户端。使用了两个HTTP头部：Cookie: 和 Set-Cookie:。当服务器收到来自新客户端的HTTP请求（即不包含Cookie:头部的HTTP请求）时，它会为客户端生成一个cookie，并将其包含在返回的HTTP响应的Set-Cookie:头部中。Set-Cookie:头部包含多个附加参数，包括cookie有效的域名。客户端将所有接收到的cookie存储在磁盘上，每次它发送HTTP请求时，它都会验证是否已经知道该域名的cookie。如果是这样，它会在HTTP请求中附加Cookie:头部。这在上面的图中用HTTP
    1.1进行了说明，但cookie也可以与HTTP 1.0一起工作。'
- en: '![msc {'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Client", linecolour=black],
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="客户端", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Server", linecolour=black],
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="服务器", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: a1=>b [ label = "GET / HTTP1.1\n...", linecolour=white, textcolour=red],
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "GET / HTTP1.1\n...", linecolour=white, textcolour=red],
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: 'd1=>c [ label = "HTTP/1.1 200 OK\nSet-Cookie: machin\n...", linecolour=white,
    textcolour=blue],'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 'd1=>c [ label = "HTTP/1.1 200 OK\nSet-Cookie: machin\n...", linecolour=white,
    textcolour=blue],'
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "Browser saves cookie", linecolour=white],
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "浏览器保存 cookie", linecolour=white],
- en: c=>d1 [ label = "Normal response", linecolour=white];
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "正常响应", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red],
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /doc HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /doc HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: c=>d1 [ label = "Response is function\nof URL and cookie", linecolour=white];
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "响应取决于 URL 和 cookie", linecolour=white];
- en: a1=>b [ label = "", linecolour=red, textcolour=red],
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=red, textcolour=red].
- en: b>>c [ linecolour=red, arcskip="1"];
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ linecolour=red, arcskip="1"];
- en: 'a1=>b [ label = "GET /images/t.gif HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 'a1=>b [ label = "GET /images/t.gif HTTP1.1\nCookie: machin\n...", linecolour=white,
    textcolour=red],'
- en: c=>d1 [ label = "", linecolour=red, textcolour=red];
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "", linecolour=red, textcolour=red];
- en: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "", linecolour=blue, textcolour=blue] ,
- en: c>>b [ linecolour=blue, arcskip="1"];
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ linecolour=blue, arcskip="1"];
- en: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "HTTP/1.1 200 OK\n...", linecolour=white, textcolour=blue],
- en: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "", linecolour=blue, textcolour=blue];
- en: a1=>b [ label = "Browser sends cookie in\nall requests sent to server", linecolour=white];
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "浏览器在发送到服务器的所有请求中发送 cookie", linecolour=white];
- en: '}](../Images/46342147d4ef4a386569e9a3c497ba69.png)<map id="577adf721a7a6a7a5af9beec3659eccef6881630"
    name="577adf721a7a6a7a5af9beec3659eccef6881630"></map>'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/46342147d4ef4a386569e9a3c497ba69.png)<map id="577adf721a7a6a7a5af9beec3659eccef6881630"
    name="577adf721a7a6a7a5af9beec3659eccef6881630"></map>'
- en: Note
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Privacy issues with HTTP cookies
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP cookies 的隐私问题
- en: The HTTP cookies introduced by [Netscape](https://en.wikipedia.org/wiki/Netscape)
    are key for large e-commerce websites. However, they have also raised many discussions
    concerning their [potential misuses](http://www.nytimes.com/2001/09/04/technology/04COOK.html).
    Consider ad.com, a company that delivers lots of advertisements on web sites.
    A web site that wishes to include ad.com’s advertisements next to its content
    will add links to ad.com inside its HTML pages. If ad.com is used by many web
    sites, ad.com could be able to track the interests of all the users that visit
    its client websites and use this information to provide targeted advertisements.
    Privacy advocates have even [sued](http://epic.org/privacy/internet/cookies/)
    online advertisement companies to force them to comply with the privacy regulations.
    More recent related technologies also raise [privacy concerns](http://www.eff.org/deeplinks/2009/09/new-cookie-technologies-harder-see-and-remove-wide).
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape [公司](https://en.wikipedia.org/wiki/Netscape)引入的 HTTP cookies 对于大型电子商务网站至关重要。然而，它们也引发了关于其[潜在滥用](http://www.nytimes.com/2001/09/04/technology/04COOK.html)的许多讨论。考虑
    ad.com，这是一家在网站上投放大量广告的公司。一个希望在其内容旁边包含 ad.com 广告的网站将在其 HTML 页面内添加指向 ad.com 的链接。如果许多网站使用
    ad.com，ad.com 可能能够跟踪访问其客户网站的用户的兴趣，并利用这些信息提供定向广告。隐私倡导者甚至已对在线广告公司提起[诉讼](http://epic.org/privacy/internet/cookies/)，强迫它们遵守隐私法规。更近期的相关技术也引发了[隐私担忧](http://www.eff.org/deeplinks/2009/09/new-cookie-technologies-harder-see-and-remove-wide)。
- en: '### HTTP version 2.0[#](#http-version-2-0 "Link to this heading")'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '### HTTP 版本 2.0[#](#http-version-2-0 "链接到本标题")'
- en: During the last decade, a growing number of services have been supported by
    world wide web servers. The web protocols are not only used to deliver static
    documents, they are also used to deliver streaming music or video. They also enable
    clients to use interactive applications including games or productivity applications.
    These services and applications have more stringent performance requirements than
    the delivery of static documents. Many researchers and companies have proposed
    solutions to improve the performance of web services and protocols during the
    last decade [[KR2001]](../bibliography.html#kr2001) [[WBK2014]](../bibliography.html#wbk2014).
    We discuss a subset of them in this section.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，越来越多的服务由全球范围内的Web服务器支持。Web协议不仅用于交付静态文档，还用于交付流媒体音乐或视频。它们还使客户端能够使用交互式应用程序，包括游戏或生产力应用程序。这些服务和应用程序的性能要求比静态文档的交付更为严格。在过去十年中，许多研究人员和公司提出了提高Web服务和协议性能的解决方案
    [[KR2001]](../bibliography.html#kr2001) [[WBK2014]](../bibliography.html#wbk2014)。在本节中，我们讨论了其中的一部分。
- en: 'A first way to improve the performance of the web protocols is to tune the
    servers that provide content. In the early days, documents were stored on a single
    server. Clients established TCP connections to this server to retrieve each document.
    This architecture evolved in several directions. A first way to speedup web services
    is to avoid unnecessary transmissions. Thanks to the HEAD method and the If-Modified-Since:
    header, web browsers can verify that they have the most recent version of a document
    in their cache.'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 提高Web协议性能的第一种方法是对提供内容的服务器进行调整。在早期，文档存储在单个服务器上。客户端建立TCP连接到该服务器以检索每个文档。这种架构在几个方向上进行了演变。加快Web服务的一种方法是不进行不必要的传输。多亏了HEAD方法和If-Modified-Since:头，Web浏览器可以验证它们是否已经拥有缓存中最新的文档版本。
- en: '![Figure made with TikZ](../Images/e9483f4f858b0589cf3d76890882a4d6.png)'
  id: totrans-1491
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e9483f4f858b0589cf3d76890882a4d6.png)'
- en: ''
  id: totrans-1492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 36 Proxies relay client requests to servers and return the received responses
  id: totrans-1493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图36 代理将客户端请求转发到服务器，并返回接收到的响应
- en: Caches can also be used inside the network. To understand their benefits, let
    us consider an SME with a dozen of employees that are connected to the Internet
    through a low-speed link. These employees often access similar web sites. Consider
    that Alice and Bob want to browse today’s local newspaper. Their browsers will
    both retrieve the newspaper’s website through the low bandwidth link and store
    the main documents in their cache. Unfortunately, the same information passes
    twice over the low-speed link. Some companies have deployed web proxies to cope
    with this problem. A web proxy is a server that resides in the enterprise network.
    All the employee’s browsers are configured to send their HTTP requests to this
    proxy. When such a proxy receives a request, it checks whether the content is
    already stored inside its own cache. If so, it returns it directly. Otherwise,
    the request is sent to the remote server and the information is stored in the
    proxy cache. By reducing the number of web objects that are exchanged over low-speed
    links, such proxies can significantly improve performance. Some companies also
    use them to control the websites that are contacted by their employees and sometimes
    block illegitimate accesses.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存也可以在网络内部使用。为了理解它们的益处，让我们考虑一个有十几名员工的小型和中型企业（SME），这些员工通过低速链路连接到互联网。这些员工经常访问类似的网站。假设爱丽丝和鲍勃想浏览今天的当地报纸。他们的浏览器将通过低速带宽链路检索报纸的网站并将主要文档存储在他们的缓存中。不幸的是，相同的信息在低速链路上传输了两次。一些公司已经部署了网络代理来解决这个问题。网络代理是位于企业网络中的服务器。所有员工的浏览器都配置为将他们的HTTP请求发送到这个代理。当这样的代理收到请求时，它会检查内容是否已经存储在其自己的缓存中。如果是这样，它将直接返回。否则，请求将被发送到远程服务器，信息将被存储在代理缓存中。通过减少在低速链路上交换的Web对象数量，此类代理可以显著提高性能。一些公司还使用它们来控制员工接触的网站，有时还会阻止非法访问。
- en: Proxies can also be located in front of servers. In this case, they are called
    reverse-proxies. Consider a dynamic web server that produces web pages by assembling
    information stored in different databases. When this server receives a request,
    it must send multiple queries to its databases and then create the HTML document.
    These queries and the creation of the HTML document take time and this limits
    the number of requests that our server can sustain. Many content providers would
    place a reverse proxy in front of such a server. The DNS servers are configured
    to point to the reverse proxy. Upon reception of a request, the reverse proxy
    first checks whether the response is already stored in its cache. If so, it can
    return it to the client without interacting with the official server. Otherwise,
    the reverse proxy contacts the server and then returns the response to the client.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也可以位于服务器之前。在这种情况下，它们被称为反向代理。考虑一个动态的Web服务器，它通过组装存储在不同数据库中的信息来生成网页。当这个服务器收到请求时，它必须向其数据库发送多个查询，然后创建HTML文档。这些查询和HTML文档的创建需要时间，这限制了服务器可以维持的请求数量。许多内容提供商会在这样的服务器前面放置一个反向代理。DNS服务器被配置为指向反向代理。在收到请求后，反向代理首先检查响应是否已经存储在其缓存中。如果是这样，它可以将其返回给客户端，而无需与官方服务器交互。否则，反向代理会联系服务器，然后将响应返回给客户端。
- en: These reverse proxies can also be used to spread the load among different servers.
    In the above example, consider that a server needs 10 milliseconds to process
    each request and that it must handle them sequentially. Such a server cannot support
    more than 100 requests per second. If the service becomes popular, then the content
    provider will need to deploy several servers. These servers could serve the same
    reverse proxy.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反向代理也可以用来在不同服务器之间分配负载。在上面的例子中，假设一个服务器需要10毫秒来处理每个请求，并且必须按顺序处理它们。这样的服务器每秒最多只能支持100个请求。如果服务变得流行，那么内容提供商将需要部署多个服务器。这些服务器可以提供相同的反向代理。
- en: Note
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Serving content from multiple servers
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 从多个服务器提供内容
- en: When a web user interacts with www.service.net, she expects that all the information
    comes from the www.service.net server. If the service is popular, there are probably
    tens, hundreds, thousands or more physical servers that support this service.
    Still, the user has the illusion that she is interacting with a single server.
    Several techniques have been deployed by content providers to scale web services.
    Consider a simple service that serves text documents from N different servers.
    There are different ways to architect such a service.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络用户与www.service.net互动时，她期望所有信息都来自www.service.net服务器。如果该服务很受欢迎，可能存在数十、数百、数千甚至更多的物理服务器来支持这项服务。然而，用户仍然有一种错觉，认为她正在与单个服务器互动。内容提供商已经部署了多种技术来扩展网络服务。考虑一个简单的服务，该服务从N个不同的服务器提供文本文档。构建此类服务有不同方式。
- en: A first approach is to store all files on each physical server and rely on the
    DNS to distribute the load among them. Each physical server has its own IP address
    and when the DNS server receives a query for www.service.net, it returns the IP
    address of one of them. Some DNS servers use Round-Robin to return one of these
    IP addresses. Others measure the load of the physical servers and return the address
    of the less loaded one. Another possibility is to locate the physical servers
    in different regions and configure the DNS server to return the IP address of
    the server that is geographically closer to the client’s IP address.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将在每个物理服务器上存储所有文件，并依赖DNS在它们之间分配负载。每个物理服务器都有自己的IP地址，当DNS服务器收到对www.service.net的查询时，它会返回它们的IP地址之一。一些DNS服务器使用轮询（Round-Robin）来返回这些IP地址中的一个。其他DNS服务器会测量物理服务器的负载，并返回负载较轻的那个服务器的地址。另一种可能性是将物理服务器放置在不同的地区，并配置DNS服务器以返回地理上更接近客户端IP地址的服务器IP地址。
- en: A second approach is to rely on k reverse proxies and N-k servers. The servers
    store the content and the proxies cache the most frequently used files. The proxies
    can be geographically close to the clients while the servers can reside in the
    datacenters of the content provider. The DNS server can also distribute the load
    among the different proxies or return the geographically closest proxy. An important
    point to note about reverse proxies is that they receive HTTP requests from clients
    and send HTTP requests to the original servers that host the content. Several
    companies, usually called Content Distribution Networks, have deployed such reverse
    proxies throughout the world to cache web content next to the end-users. A good
    description of such a CDN may be found in [[NSS2010]](../bibliography.html#nss2010).
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是依赖k个反向代理和N-k个服务器。服务器存储内容，而代理缓存最常用的文件。代理可以地理位置上靠近客户端，而服务器可以位于内容提供商的数据中心。DNS服务器还可以在不同代理之间分配负载或返回地理位置上最近的代理。关于反向代理的一个重要观点是，它们从客户端接收HTTP请求，并将HTTP请求发送到托管内容的原始服务器。一些公司，通常被称为内容分发网络，已经在全球范围内部署了这样的反向代理，以在终端用户附近缓存网页内容。在[[NSS2010]](../bibliography.html#nss2010)中可以找到对这种CDN的良好描述。
- en: A second way to improve the web performance is to reduce the time required to
    retrieve web objects. While the first web servers returned an HTML documents with
    possibly a few images, today’s rich web servers return one HTML document with
    associated style sheets, javascript code, images, fonts, … Some of these web objects
    come from the original server while others are hosted on different servers. Today,
    a typical web page contains almost 2 MBytes of data on average. The size of the
    web pages continues to grow according to statistics collected by httparchive.org
    as shown in [Fig. 37](#fig-httparchive). Web pages targeted to mobile devices
    are slightly smaller.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 提高网页性能的第二种方法是减少检索网页对象所需的时间。虽然最初的网页服务器返回的是包含可能几张图片的HTML文档，但今天的丰富网页服务器返回的是一个包含相关样式表、javascript代码、图片、字体等的HTML文档。其中一些网页对象来自原始服务器，而其他则托管在不同的服务器上。如今，一个典型的网页平均包含大约2
    MBytes的数据。根据httparchive.org收集的统计数据，网页的大小持续增长，如图37所示。针对移动设备的网页略小。
- en: '[![../_images/httparchive-bytes.png](../Images/e512429b911bc1ff17df73d156e86ce1.png)](../_images/httparchive-bytes.png)'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '![![../_images/httparchive-bytes.png](../Images/e512429b911bc1ff17df73d156e86ce1.png)](../_images/httparchive-bytes.png)'
- en: 'Fig. 37 Evolution of the size of the web pages (source: [https://httparchive.org/reports/page-weight](https://httparchive.org/reports/page-weight))[#](#id66
    "Link to this image")'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 图37 网页大小的演变（来源：[https://httparchive.org/reports/page-weight](https://httparchive.org/reports/page-weight))[#](#id66
    "链接到这张图片")
- en: A closer look at the average web page shows that it contains, on average, 27
    KBytes of HTML, 120 KBytes of fonts, 60 KBytes of CSS information, almost 1 MBytes
    of images and more than 400 KBytes of javascript. Each of these web page requires
    about 70 different HTTP requests. In other words, a browser needs to send on average
    70 requests to retrieve a complete web page.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察平均网页，可以发现它平均包含27 KBytes的HTML，120 KBytes的字体，60 KBytes的CSS信息，几乎1 MBytes的图片和超过400
    KBytes的javascript。每个网页都需要大约70个不同的HTTP请求。换句话说，浏览器需要平均发送70个请求来检索一个完整的网页。
- en: Two directions have been explored to improve the delivery of these web pages.
    The first direction is to tune the HTTP protocol. The second approach is to change
    the entire network stack. This approach is discussed in the QUIC chapter.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这些网页的交付，已经探索了两个方向。第一个方向是调整HTTP协议。第二个方法是改变整个网络栈。这种方法在QUIC章节中进行了讨论。
- en: One of the limitations of HTTP from a performance viewpoint is that the requests
    that are sent by a browser must be sequential. Typically, a browser requests the
    HTML page. Once the page has been retrieved, the browser parses it to identify
    all the objects that it references and requests them one after each other. The
    web page can only be displayed to the user once all the required web objects have
    been retrieved. This implies that the browser must wait until the reception of
    each response before sending the next request. Another possibility is to allow
    the browser to send multiple requests without waiting for their corresponding
    responses. This approach is called pipelining in [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html).
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，HTTP 的一些限制之一是浏览器发送的请求必须是顺序的。通常，浏览器会请求 HTML 页面。一旦页面被检索到，浏览器会解析它以识别所有引用的对象，并依次请求它们。只有当所有所需的网络对象都被检索到后，网页才能向用户显示。这意味着浏览器必须在接收每个响应之前等待发送下一个请求。另一种可能性是允许浏览器在不等待相应响应的情况下发送多个请求。这种方法被称为
    [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html) 中的流水线。
- en: To understand the benefits of pipelining, let us consider a simple but illustrative
    example. A client needs to retrieve 5 web objects that are each 100 bytes. The
    underlying transport connection has a 1 Gbps bandwidth but a one-way delay of
    100 msec. A normal HTTP/1.x client would send the first request, wait 200 msec
    to receive the answer, then send another request… It would need one entire second
    to retrieve the five web objects. This is illustrated in [Fig. 38](#fig-http-nopipelining).
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解流水线的优势，让我们考虑一个简单但具有说明性的例子。客户端需要检索 5 个各为 100 字节的网络对象。底层传输连接具有 1 Gbps 的带宽，但单向延迟为
    100 毫秒。一个正常的 HTTP/1.x 客户端会发送第一个请求，等待 200 毫秒以接收答案，然后发送另一个请求……它需要整整一秒来检索五个网络对象。这如图
    [图 38](#fig-http-nopipelining) 所示。
- en: '![Figure made with TikZ](../Images/902ce8ac285bbf69a2f6e825e8e51419.png)'
  id: totrans-1509
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/902ce8ac285bbf69a2f6e825e8e51419.png)'
- en: Fig. 38 A sequence of HTTP requests to a given server
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 图 38 对给定服务器的 HTTP 请求序列
- en: With pipelining, the client sends the five requests immediately and receives
    the five responses after 200 msec. [Fig. 39](#fig-http-pipelining) illustrates
    the benefits of pipelining.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流水线，客户端会立即发送五个请求，并在 200 毫秒后收到五个响应。[图 39](#fig-http-pipelining) 说明了流水线的优势。
- en: '![Figure made with TikZ](../Images/d0394b043492534d50c59a67578ea778.png)'
  id: totrans-1512
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/d0394b043492534d50c59a67578ea778.png)'
- en: Fig. 39 A sequence of HTTP requests to a server with pipelining
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 图 39 带有流水线的服务器的 HTTP 请求序列
- en: However, as explained in [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html),
    there is one important limitation to pipelining. It can only be used to serve
    HTTP requests that are idempotent, i.e. none of the requests must depend on any
    of the previous requests in the pipeline. It turned out that it was difficult
    for web browsers to correctly support this requirement and very few of them have
    implemented pipelining [[19]](#fpipelining).
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如 [**RFC 7230**](https://datatracker.ietf.org/doc/html/rfc7230.html) 中所述，流水线有一个重要的限制。它只能用于服务幂等的
    HTTP 请求，即管道中的任何请求都不能依赖于之前的任何请求。结果发现，网络浏览器正确支持这一要求非常困难，并且其中很少实现了流水线 [[19]](#fpipelining)。
- en: Another limitation of HTTP/1.1 is that all commands and parameters are encoded
    as ASCII strings. Using ASCII strings makes it easy to write simple clients or
    debug problems by observing packets. Unfortunately, the burden is placed on servers
    that need to include complex parsers that accept a wide range of partially compliant
    implementations. Furthermore, the flexibility of the ASCII encoding has enabled
    some classes of security attacks on servers [[CWE444]](../bibliography.html#cwe444).
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1 的另一个限制是，所有命令和参数都编码为 ASCII 字符串。使用 ASCII 字符串使得编写简单的客户端或通过观察数据包来调试问题变得容易。不幸的是，服务器需要承担负担，因为它们需要包含能够接受广泛部分兼容实现的复杂解析器。此外，ASCII
    编码的灵活性已经使得一些针对服务器的安全攻击成为可能 [[CWE444]](../bibliography.html#cwe444)。
- en: To cope with these two problems, the IETF HTTP working group developed version
    2.0 of HTTP. HTTP/2.0 diverges from HTTP/1.1 in two important ways. First, HTTP/2.0
    relies on binary encoding which is both more compact and easier to parse. Second,
    HTTP/2.0 supports multiple streams, which makes it possible to simultaneously
    transfer different web objects over a single transport connection. Furthermore,
    HTTP/2.0 also compresses the HTTP headers to reduce the amount of data transferred.
    This technique is described in [**RFC 7541**](https://datatracker.ietf.org/doc/html/rfc7541.html)
    but is not discussed in this chapter.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这两个问题，IETF HTTP工作组开发了HTTP的2.0版本。HTTP/2.0在两个重要方面与HTTP/1.1不同。首先，HTTP/2.0依赖于二进制编码，这种编码既更紧凑又更容易解析。其次，HTTP/2.0支持多个流，这使得在单个传输连接上同时传输不同的Web对象成为可能。此外，HTTP/2.0还压缩HTTP头信息以减少传输的数据量。这项技术描述在[**RFC
    7541**](https://datatracker.ietf.org/doc/html/rfc7541.html)中，但本章不会进行讨论。
- en: Let us first examine how HTTP/2.0 structures the bytestream of the underlying
    connection.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来考察一下HTTP/2.0是如何对底层连接的字节流进行结构的。
- en: '[![../_images/http2-frame.svg](../Images/70ec7c103b170dfdecf10fd670dc9b85.png)](../_images/http2-frame.svg)'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/http2-frame.svg](../Images/70ec7c103b170dfdecf10fd670dc9b85.png)'
- en: Fig. 40 The HTTP/2.0 Frame header[#](#id69 "Link to this image")
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 图40 HTTP/2.0帧头[#](#id69 "链接到这张图片")
- en: The information exchanged over an HTTP/2.0 session is composed of frames. A
    frame starts with a 9 bytes-long header that carries several types of information
    as shown in [Fig. 40](#fig-http2-frame). The HTTP/2.0 frames have a variable length.
    The Length field of the header contains the length of the frame payload in bytes.
    As this field is encoded as a 24 bits field, an HTTP/2.0 frame cannot be longer
    than \(2^{24} -1\) bytes. It should be noted that [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    assumes a maximum size of \(2^{14}\) bytes, i.e. 16,384 bytes for the HTTP/2.0
    frame payload unless a longer maximum frame length has been negotiated at the
    beginning of the session using the HTTP/2.0 Settings frame that will be described
    later. The next field of the frames header indicates the frame type. The first
    frame types are Data which contains data from web objects and Headers containing
    HTTP/2.0 headers. When a client retrieves a web object from a server, it always
    receives an HTTP/2.0 Headers frame followed by an HTTP/2.0 Data frame. The Headers
    frame information contains essentially the same HTTP headers as the ones supported
    by HTTP/1.1, but those are encoded by leveraging a data compression technique
    that minimizes the number of bytes required to transmit them.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP/2.0会话中交换的信息由帧组成。一个帧以一个9字节长的头部开始，它携带了如图40所示的多种类型的信息。[图40](#fig-http2-frame)。HTTP/2.0帧的长度是可变的。头部中的长度字段包含帧有效载荷的长度（以字节为单位）。由于该字段编码为24位字段，HTTP/2.0帧的长度不能超过\(2^{24}
    -1\)字节。需要注意的是，[**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)假设HTTP/2.0帧有效载荷的最大大小为\(2^{14}\)字节，即16,384字节，除非在会话开始时通过HTTP/2.0设置帧协商了一个更长的最大帧长度，该设置帧将在后面进行描述。帧头中的下一个字段指示帧类型。最初的帧类型是数据帧，它包含来自Web对象的数据，以及包含HTTP/2.0头部的头部帧。当客户端从服务器检索Web对象时，它总是先接收到一个HTTP/2.0头部帧，然后是一个HTTP/2.0数据帧。头部帧信息基本上与HTTP/1.1支持的HTTP头部相同，但它们通过利用数据压缩技术进行编码，以最小化传输这些头部所需的字节数。
- en: Other frame types are described later. The Flags are used for some frame types
    and the R bit must be set to zero. The last important field of the HTTP/2.0 Frame
    header is the Stream Identifier. With HTTP/2.0, the bytestream of the underlying
    transport connection is divided in independent streams that are identified by
    an integer. The odd (resp. even) stream identifiers are managed by the client
    (resp. server). This enables the server (or the client) to multiplex data corresponding
    to different frames over a single bytestream.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 其他帧类型将在后面进行描述。标志位用于某些帧类型，并且R位必须设置为0。HTTP/2.0帧头中最后一个重要的字段是流标识符。在HTTP/2.0中，底层传输连接的字节流被划分为独立的流，这些流通过一个整数进行标识。奇数（或偶数）流标识符由客户端（或服务器）管理。这使得服务器（或客户端）能够在单个字节流上多路复用对应不同帧的数据。
- en: This multiplexing capability is probably the most important feature of HTTP/2.0
    from a performance viewpoint. To understand its benefits, let us consider a client
    that retrieves two web objects over a 1 Mbps connection. The two requests are
    sent together by the client. The first object is 125 bytes long, while the second
    is 12500 bytes long. In this case, the server will first return the first object
    as a single frame and the second will be sent in the subsequent frame.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复用能力可能是从性能角度来看HTTP/2.0最重要的特性。为了理解其优势，让我们考虑一个通过1 Mbps连接检索两个网页对象的客户端。这两个请求由客户端一起发送。第一个对象长度为125字节，而第二个对象长度为12500字节。在这种情况下，服务器将首先以单个帧返回第一个对象，第二个对象将在后续帧中发送。
- en: Consider now that the first object is 12500 bytes long and the second 125 bytes
    long as shown in [Fig. 41](#fig-http-hol). With a 1 Mbps connection, this object
    will use the underlying connection during 100 milliseconds. The client will thus
    need to wait 100 milliseconds to retrieve the second object. This is the Head
    of Line (HoL) blocking problem that affects the performance of many web services.
    If the short web object is a javascript code that requests other web objects,
    its retrieval may be critical to display the retrieved web page.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第一个对象长度为12500字节，第二个对象长度为125字节，如图[图41](#fig-http-hol)所示。在有1 Mbps连接的情况下，此对象将在100毫秒内使用底层连接。因此，客户端需要等待100毫秒才能检索第二个对象。这就是影响许多网络服务性能的首部阻塞（HoL）问题。如果短网页对象是请求其他网页对象的javascript代码，其检索可能对显示检索到的网页至关重要。
- en: '![Figure made with TikZ](../Images/7fc784e24d2a3dd0171363ba394ef8ba.png)'
  id: totrans-1524
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/7fc784e24d2a3dd0171363ba394ef8ba.png)'
- en: Fig. 41 Head-of-line blocking, a large response may deal a small one
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 图41 首部阻塞，大响应可能处理小的一个
- en: With HTTP/2.0 frames, the server could send the first 1250 bytes of the long
    object during 10 milliseconds, then send a second frame that contains the short
    object during one millisecond and later send a longer frame that contains the
    remaining 11250 bytes of the long object. This is illustrated in [Fig. 42](#fig-http2-no-hol).
    In this case, the client has received the short object after 10 milliseconds.
    Given the HTTP/2.0 streams, the transmission of long web objects does not anymore
    blocks the transmission of shorter ones.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP/2.0帧，服务器可以在10毫秒内发送长对象的第一个1250字节，然后发送一个包含短对象的第二个帧，持续一毫秒，之后发送一个包含长对象剩余11250字节的更长帧。这如图[图42](#fig-http2-no-hol)所示。在这种情况下，客户端在10毫秒后收到了短对象。考虑到HTTP/2.0流，长网页对象的传输不再阻塞短网页对象的传输。
- en: The length of the HTTP/2.0 frames obviously affects how different web objects
    can be multiplexed over the underlying transport connection. If HTTP/2.0 frames
    are long, the overhead of the frame header is minimal, but long frames can block
    short web objects. On the other hand, if the frame length is small, then the overhead
    due to the HTTP/2.0 frame header could become significant.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0帧的长度显然会影响不同网页对象如何在底层传输连接上复用。如果HTTP/2.0帧很长，帧头部的开销最小，但长帧可能会阻塞短网页对象。另一方面，如果帧长度较小，那么由于HTTP/2.0帧头部的开销可能会变得显著。
- en: '![Figure made with TikZ](../Images/8873fd6b2b8e1c27c72e08f4926f28fb.png)'
  id: totrans-1528
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/8873fd6b2b8e1c27c72e08f4926f28fb.png)'
- en: Fig. 42 The data from HTTP/2 frames can be interleaved to prevent head-of-line
    blocking
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 图42 HTTP/2帧中的数据可以交错以防止首部阻塞
- en: The HTTP/2.0 streams can provide performance benefits, but they also increase
    the complexity of the implementations since an HTTP/2.0 receiver must be able
    to simultaneously process frames that correspond to different web objects. This
    complexity mainly resides on the client side. The HTTP/2.0 protocol includes several
    techniques that enable clients to manage the utilization of the HTTP/2.0 session.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0流可以提供性能优势，但它们也增加了实现的复杂性，因为HTTP/2.0接收器必须能够同时处理对应不同网页对象的帧。这种复杂性主要存在于客户端。HTTP/2.0协议包括几种技术，使客户端能够管理HTTP/2.0会话的利用率。
- en: The first frame that a client sends over an HTTP/2.0 session is the Settings
    frame. This is a control frame that indicates some parameters that the client
    proposes for this session. Several of these parameters are defined in [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html).
    The most important ones are probably the SETTINGS_MAX_FRAME_SIZE that specifies
    the maximum length of the HTTP/2.0 frames that this implementation supports and
    the SETTINGS_MAX_CONCURRENT_STREAMS that specifies the maximum number of parallel
    streams that this implementation can manage. The SETTINGS_MAX_FRAME_SIZE must
    be at least \(2^{14}\) bytes but can go up to \(2^{24} -1\) bytes. There is no
    minimum value for SETTINGS_MAX_CONCURRENT_STREAMS, but [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)
    recommends to support at least 100 different stream identifiers.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在 HTTP/2.0 会话中发送的第一个帧是设置帧。这是一个控制帧，它指示客户端为此次会话提出的某些参数。其中一些参数在[**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)中定义。其中最重要的可能是SETTINGS_MAX_FRAME_SIZE，它指定了此实现支持的
    HTTP/2.0 帧的最大长度，以及SETTINGS_MAX_CONCURRENT_STREAMS，它指定了此实现可以管理的最大并行流数量。SETTINGS_MAX_FRAME_SIZE
    至少为 \(2^{14}\) 字节，但可以高达 \(2^{24} -1\) 字节。SETTINGS_MAX_CONCURRENT_STREAMS 没有最小值，但[**RFC
    7540**](https://datatracker.ietf.org/doc/html/rfc7540.html)建议至少支持 100 个不同的流标识符。
- en: By using multiple streams, the server can multiplex different web objects over
    the same underlying transport connection. However, these objects are only sent
    in response to requests from clients. There are some situations where the server
    might know in advance that the client will request a given object. It could speedup
    the transfer by sending it before having received a client request. This is the
    push feature of HTTP/2.0\. A server can independently push web objects to a client
    without having received any request. This feature can only be used by the server
    if the client has enabled it by sending SETTINGS_ENABLE_PUSH in its Settings frame.
    A classical use case for this push feature is to enable a server to automatically
    send an object which cannot be cached by the client, such as a dynamic javascript
    code, when another web object that references it is requested. However, measurement
    studies indicate that very few web servers seem to have adopted this feature [[ZWH2018]](../bibliography.html#zwh2018).
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个流，服务器可以在相同的底层传输连接上多路复用不同的网页对象。然而，这些对象只有在客户端请求时才会发送。在某些情况下，服务器可能事先知道客户端将请求某个对象。它可以在收到客户端请求之前发送该对象，从而加快传输速度。这是
    HTTP/2.0 的推送功能。服务器可以在没有收到任何请求的情况下独立地将网页对象推送到客户端。如果客户端通过在设置帧中发送 SETTINGS_ENABLE_PUSH
    启用它，则该功能只能由服务器使用。此推送功能的经典用例是使服务器能够在请求引用它的另一个网页对象时自动发送一个客户端无法缓存的对象，例如动态 JavaScript
    代码。然而，测量研究表明，似乎很少有网页服务器采用了此功能 [[ZWH2018]](../bibliography.html#zwh2018)。
- en: Another feature of HTTP/2.0 is that it is possible to assign different priorities
    to different streams. A high priority stream should carry more Data frames than
    a lower priority ones. The HTTP/2.0 specification defines Priority frames which
    can be used for this purpose.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 的另一个特性是，可以为不同的流分配不同的优先级。高优先级的流应该携带比低优先级流更多的数据帧。HTTP/2.0 规范定义了用于此目的的优先级帧。
- en: As the server can send multiple objects at the same time, there is a risk of
    overloading the client buffers. To cope with this potential problem, HTTP/2.0
    includes its own flow control mechanism. When an HTTP/2.0 session starts, a receiver
    agrees to receive up to 65,535 bytes over this connection (unless it has indicated
    a different initial window in its Settings frame). This limits the amount of data
    that a sender can transmit over the HTTP/2.0 session. The receiver can advertise
    a large receive window by sending a Window_Update frame at any time. This flow
    control mechanism can be applied to the entire connection or to a specific stream.
    In practice, using a small HTTP/2.0 window could severely limit the throughput
    over an HTTP/2.0 session.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器可以同时发送多个对象，因此存在过载客户端缓冲区的风险。为了应对这种潜在问题，HTTP/2.0 包含了自己的流量控制机制。当 HTTP/2.0
    会话开始时，接收方同意通过此连接接收最多 65,535 字节（除非它在设置帧中指明了不同的初始窗口）。这限制了发送方在 HTTP/2.0 会话中可以传输的数据量。接收方可以通过在任何时候发送
    Window_Update 帧来宣传一个大的接收窗口。这种流量控制机制可以应用于整个连接或特定的流。实际上，使用小的 HTTP/2.0 窗口可能会严重限制
    HTTP/2.0 会话的吞吐量。
- en: HTTP/2.0 includes much more than what we have covered in this short introduction.
    There is for example a Ping frame that allows measuring the round-trip-time between
    a client and a server or the GoAway frame that indicates the termination of an
    HTTP/2.0 session. This frame contains an error code that indicates why the session
    has been terminated. Several error codes are defined in [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html),
    including ENHANCE_YOUR_CALM that is used to indicate that the other endpoint exhibits
    an behavior that could cause excessive load.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 包含的内容远不止我们在本简短介绍中涵盖的内容。例如，有一个允许测量客户端和服务器之间往返时间的 Ping 帧，或者表示 HTTP/2.0
    会话终止的 GoAway 帧。此帧包含一个错误代码，指示会话终止的原因。定义了多个错误代码，包括用于指示其他端点表现出可能导致过度负载行为的 ENHANCE_YOUR_CALM，在
    [**RFC 7540**](https://datatracker.ietf.org/doc/html/rfc7540.html) 中定义。
- en: Note
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Detecting whether a server supports HTTP/2.0
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 检测服务器是否支持 HTTP/2.0
- en: HTTP/2.0 is a new version of the HTTP protocol that still uses port 80\. When
    a client contacts an HTTP server, it must be able to determine whether it supports
    HTTP/1.x or HTTP/2.0\. If the client sends a binary encoded HTTP/2.0 request to
    a server that only supports the ASCII encoded HTTP/1.x, it could cause problems
    on the server and even crash it. To minimize the risk of crashing HTTP/1.x servers,
    an HTTP/2.0 session starts like an HTTP/1.1 session and the first request contains
    the Connection, Upgrade and HTTP2-Settings headers. An example of such a request
    to upgrade the version of HTTP is shown below.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2.0 是 HTTP 协议的新版本，仍然使用端口 80。当客户端联系 HTTP 服务器时，它必须能够确定它是否支持 HTTP/1.x 或 HTTP/2.0。如果客户端向只支持
    ASCII 编码的 HTTP/1.x 服务器发送二进制编码的 HTTP/2.0 请求，可能会在服务器上引起问题，甚至导致其崩溃。为了最小化 HTTP/1.x
    服务器崩溃的风险，HTTP/2.0 会话的启动方式类似于 HTTP/1.1 会话，第一个请求包含连接、升级和 HTTP2-Settings 标头。以下是一个升级
    HTTP 版本的请求示例。
- en: '[PRE61]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The HTTP2-Settings line contains the HTTP/2.0 settings frame that the client
    would server over an HTTP/2.0 session encoded in Base64\. The server replies with
    a response that indicates that it has accepted to upgrade the connection to HTTP/2.0\.
    A sample response is shown below.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP2-Settings 行包含客户端在 HTTP/2.0 会话中通过 Base64 编码发送的 HTTP/2.0 设置帧。服务器通过一个响应来表示它已接受升级连接到
    HTTP/2.0。以下是一个示例响应。
- en: '[PRE62]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, the client and the server need to confirm the utilization of HTTP/2.0\.
    A client confirms this by sending the following Magic string PRI * HTTP/2.0rnrnSMrnrn
    or 0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a in hex. This string is followed
    by a SETTINGS frame. The server must send a possibly empty SETTINGS frame.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端和服务器需要确认使用 HTTP/2.0。客户端通过发送以下魔法字符串 PRI * HTTP/2.0rnrnSMrnrn 或 0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
    以十六进制表示。该字符串之后是一个设置帧。服务器必须发送一个可能为空的设置帧。
- en: Remote Procedure Calls[#](#remote-procedure-calls "Link to this heading")
  id: totrans-1543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程过程调用[#](#remote-procedure-calls "链接到本标题")
- en: In the previous sections, we have described several protocols that enable humans
    to exchange messages and access to remote documents. This is not the only usage
    of computer networks and in many situations applications use the network to exchange
    information with other applications. When an application needs to perform a large
    computation on a host, it can sometimes be useful to request computations from
    other hosts. Many distributed systems have been built by distributing applications
    on different hosts and using Remote Procedure Calls as a basic building block.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了几个协议，这些协议使人类能够交换消息和访问远程文档。这并不是计算机网络使用的唯一用途，在许多情况下，应用程序使用网络与其他应用程序交换信息。当一个应用程序需要在主机上执行大量计算时，有时从其他主机请求计算可能是有用的。许多分布式系统是通过在不同主机上分布应用程序并使用远程过程调用作为基本构建块来构建的。
- en: 'In traditional programming languages, procedure calls allow programmers to
    better structure their code. Each procedure is identified by a name, a return
    type and a set of parameters. When a procedure is called, the current flow of
    program execution is diverted to execute the procedure. This procedure uses the
    provided parameters to perform its computation and returns one or more values.
    This programming model was designed with a single host in mind. In a nutshell,
    most programming languages support it as follows :'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的编程语言中，过程调用允许程序员更好地组织他们的代码。每个过程通过一个名称、一个返回类型和一组参数来标识。当调用一个过程时，程序执行的当前流程会被转移到执行该过程。这个过程使用提供的参数来执行其计算，并返回一个或多个值。这个编程模型是以单个主机为设计目标的。简而言之，大多数编程语言都支持它，如下所示：
- en: The caller places the values of the parameters at a location (register, stack,
    …) where the callee can access them
  id: totrans-1546
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将参数的值放置在（寄存器、堆栈等）一个位置，以便被调用者可以访问它们
- en: ''
  id: totrans-1547
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1548
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The caller transfers the control of execution to the callee’s procedure
  id: totrans-1549
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者将执行控制权转移到被调用者的过程
- en: ''
  id: totrans-1550
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1551
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The callee accesses the parameters and performs the requested computation
  id: totrans-1552
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用者访问参数并执行所需的计算
- en: ''
  id: totrans-1553
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1554
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The callee places the return value(s) at a location (register, stack, …) where
    the caller can access them
  id: totrans-1555
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用者将返回值放置在（寄存器、堆栈等）一个位置，以便调用者可以访问它们
- en: ''
  id: totrans-1556
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1557
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The callee returns the control of execution to the caller’s
  id: totrans-1558
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用者将执行控制权返回给调用者
- en: This model was developed with a single host in mind. How should it be modified
    if the caller and the callee are different hosts connected through a network ?
    Since the two hosts can be different, the two main problems are the fact they
    do not share the same memory and that they do not necessarily use the same representation
    for numbers, characters, … Let us examine how the five steps identified above
    can be supported through a network.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型是以单个主机为设计目标的。如果调用者和被调用者是通过网络连接的不同主机，应该如何修改？由于两个主机可能不同，两个主要问题就是它们不共享相同的内存，并且它们不一定使用相同的表示来处理数字、字符等。让我们看看上述确定的五个步骤如何通过网络得到支持。
- en: The first problem to be solved is how to transfer the information from the caller
    to the callee. This problem is not simple and includes two sub-problems. The first
    sub-problem is the encoding of the information. How to encode the values of the
    parameters so that they can be transferred correctly through the network ? The
    second problem is how to reach the callee through the network ? The callee is
    identified by a procedure name, but to use the transport service, we need to convert
    this name into an address and a port number.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的首要问题是如何将信息从调用者传输到被调用者。这个问题并不简单，包括两个子问题。第一个子问题是信息的编码。如何编码参数的值，以便它们可以通过网络正确传输？第二个问题是如何通过网络到达被调用者？被调用者通过一个过程名称来标识，但为了使用传输服务，我们需要将此名称转换为地址和端口号。
- en: '### Encoding data[#](#encoding-data "Link to this heading")'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '### 数据编码[#](#encoding-data "链接到这个标题")'
- en: The encoding problem exists in a wide range of applications. In the previous
    sections, we have described how character-based encodings are used by email and
    HTTP. Although standard encoding techniques such as ASN.1 [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    have been defined to cover most application needs, many applications have defined
    their specific encoding. Remote Procedure Call are no exception to this rule.
    The three most popular encoding methods are probably XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    used by ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html),
    XML, used by XML-RPC and JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html).
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 编码问题存在于广泛的应用中。在前面的章节中，我们描述了基于字符的编码如何被电子邮件和HTTP使用。尽管已经定义了标准编码技术，如ASN.1 [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    来覆盖大多数应用需求，但许多应用已经定义了它们自己的特定编码。远程过程调用也不例外。最流行的三种编码方法可能是ONC-RPC [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    使用的XDR，XML [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)
    用于XML-RPC，以及JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)。
- en: The eXternal Data Representation (XDR) Standard, defined in [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    is an early specification that describes how information exchanged during Remote
    Procedure Calls should be encoded before being transmitted through a network.
    Since the transport service enables transferring a block of bytes (with the connectionless
    service) or a stream of bytes (by using the connection-oriented service), XDR
    maps each datatype onto a sequence of bytes. The caller encodes each data in the
    appropriate sequence and the callee decodes the received information. Here are
    a few examples extracted from [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    to illustrate how this encoding/decoding can be performed.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数据表示（XDR）标准，在 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    中定义，是一个早期规范，描述了在远程过程调用期间交换的信息在通过网络传输之前应该如何编码。由于传输服务允许传输一个字节数组块（使用无连接服务）或一个字节数据流（通过使用面向连接的服务），XDR
    将每个数据类型映射到一系列字节。调用方将每个数据编码到适当的序列中，而被调用方解码接收到的信息。以下是从 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    中提取的一些示例，以说明如何执行这种编码/解码。
- en: For basic data types, [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    simply maps their representation into a sequence of bytes. For example a 32 bits
    integer is transmitted as shown in [Fig. 43](#fig-xdr-int32) (with the most significant
    byte first, which corresponds to big-endian encoding).
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本数据类型，[**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    简单地将它们的表示映射到一系列字节。例如，32 位整数按[图 43](#fig-xdr-int32) 所示传输（最高有效字节在前，对应大端编码）。
- en: '![../_images/xdr-integer.svg](../Images/d52e7c6b6281eb132d460857ec233eff.png)'
  id: totrans-1565
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/xdr-integer.svg](../Images/d52e7c6b6281eb132d460857ec233eff.png)'
- en: Fig. 43 XDR representation of a 32 bits integer[#](#id72 "Link to this image")
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 图 43 XDR 表示的 32 位整数[#](#id72 "链接到此图像")
- en: 'XDR also supports 64 bits integers and booleans. The booleans are mapped onto
    integers (0 for false and 1 for true). For the floating point numbers, the encoding
    defined in the IEEE standard is used. In the representation, the first bit (S)
    is the sign (0 represents positive). The next 11 bits represent the exponent of
    the number (E), in base 2, and the remaining 52 bits are the fractional part of
    the number (F). The floating point number that corresponds to this representation
    is \((-1)^{S} \times 2^{E-1023} \times 1.F\). XDR also allows encoding complex
    data types. A first example is the string of bytes. A string of bytes is composed
    of two parts : a length (encoded as an integer) and a sequence of bytes. For performance
    reasons, the encoding of a string is aligned to 32 bits boundaries. This implies
    that some padding bytes may be inserted during the encoding operation is the length
    of the string is not a multiple of 4\. The structure of the string is shown below
    (source [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)).'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: XDR 还支持 64 位整数和布尔值。布尔值映射到整数（0 表示假，1 表示真）。对于浮点数，使用 IEEE 标准中定义的编码。在表示中，第一个位（S）是符号（0
    表示正）。接下来的 11 位表示数字的指数（E），以 2 为基数，剩余的 52 位是数字的小数部分（F）。与这种表示相对应的浮点数是 \((-1)^{S}
    \times 2^{E-1023} \times 1.F\)。XDR 还允许编码复杂的数据类型。第一个例子是字节数组字符串。字节数组字符串由两部分组成：一个长度（编码为一个整数）和一个字节序列。出于性能考虑，字符串的编码对齐到
    32 位边界。这意味着如果字符串的长度不是 4 的倍数，编码操作过程中可能会插入一些填充字节。字符串的结构如下所示（来源 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html))。
- en: '[![../_images/xdr-float.svg](../Images/b3e916ca81c68d2a4b58075d4bf0bb7c.png)](../_images/xdr-float.svg)'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '![![../_images/xdr-float.svg](../Images/b3e916ca81c68d2a4b58075d4bf0bb7c.png)](../_images/xdr-float.svg)'
- en: Fig. 44 XDR representation of a floating point number[#](#id73 "Link to this
    image")
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 图 44 XDR 表示的浮点数[#](#id73 "链接到此图像")
- en: In some situations, it is necessary to encode fixed or variable length arrays.
    XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html) supports
    such arrays. For example, the encoding in [Fig. 45](#fig-xdr-narray) corresponds
    to an array containing n elements. The encoded representation starts with an integer
    that contains the number of elements and follows with all elements in sequence.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要对固定长度或可变长度数组进行编码。XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    支持此类数组。例如，[图 45](#fig-xdr-narray) 中的编码对应于包含 n 个元素的数组。编码表示从包含元素数量的整数开始，随后是所有元素的顺序。
- en: '[![../_images/xdr-array.svg](../Images/e1244da31b6e5cd69f0f51dd6cf774b8.png)](../_images/xdr-array.svg)'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '![![../_images/xdr-array.svg](../Images/e1244da31b6e5cd69f0f51dd6cf774b8.png)](../_images/xdr-array.svg)'
- en: Fig. 45 XDR representation of an array[#](#id74 "Link to this image")
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 图45 XDR表示数组[#](#id74 "链接到这张图片")
- en: XDR also supports the definition of unions, structures, … Additional details
    are provided in [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html).
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: XDR也支持联合、结构体等的定义。更多详细信息请参阅[**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)。
- en: A second popular method to encode data is the JavaScript Object Notation (JSON).
    This syntax was initially defined to allow applications written in JavaScript
    to exchange data, but it has now wider usages. JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    is a text-based representation. The simplest data type is the integer. It is represented
    as a sequence of digits in ASCII. Strings can also be encoding by using JSON.
    A JSON string always starts and ends with a quote character (”) as in the C language.
    As in the C language, some characters (like “ or \) must be escaped if they appear
    in a string. [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    describes this in details. Booleans are also supported by using the strings false
    and true. Like XDR, JSON supports more complex data types. A structure or object
    is defined as a comma separated list of elements enclosed in curly brackets. [**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) provides the following
    example as an illustration.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据的第二种流行方法是JavaScript对象表示法（JSON）。这种语法最初是为了允许用JavaScript编写的应用程序交换数据而定义的，但现在它有更广泛的应用。JSON
    [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)是一种基于文本的表示。最简单的数据类型是整数，它以ASCII码中的数字序列表示。字符串也可以通过使用JSON进行编码。JSON字符串始终以引号字符（”）开头和结尾，就像C语言一样。与C语言一样，如果某些字符（如“或\）出现在字符串中，则必须进行转义。[**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)对此进行了详细描述。布尔值也通过使用字符串false和true来支持。与XDR一样，JSON支持更复杂的数据类型。结构体或对象定义为用花括号括起来的元素列表，元素之间用逗号分隔。[**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)提供了以下示例作为说明。
- en: '[PRE63]'
  id: totrans-1575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This object has one field named Image. It has five attributes. The first one,
    Width, is an integer set to 800\. The third one is a string. The fourth attribute,
    Thumbnail is also an object composed of three different attributes, one string
    and two integers. JSON can also be used to encode arrays or lists. In this case,
    square brackets are used as delimiters. The snippet below shows an array which
    contains the prime integers that are smaller than ten.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象有一个名为Image的字段。它有五个属性。第一个属性，Width，是一个设置为800的整数。第三个属性是一个字符串。第四个属性，Thumbnail，也是一个由三个不同属性组成的对象，包括一个字符串和两个整数。JSON也可以用来编码数组或列表。在这种情况下，使用方括号作为分隔符。下面的代码片段显示了一个包含小于十的质数的数组。
- en: '[PRE64]'
  id: totrans-1577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Compared with XDR, the main advantage of JSON is that the transfer syntax is
    easily readable by a human. However, this comes at the expense of a less compact
    encoding. Some data encoded in JSON will usually take more space than when it
    is encoded with XDR. More compact encoding schemes have been defined, see e.g.
    [[BH2013]](../bibliography.html#bh2013) and the references therein.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 与XDR相比，JSON的主要优势是传输语法易于人类阅读。然而，这是以牺牲更紧凑的编码为代价的。一些用JSON编码的数据通常比用XDR编码时占用更多空间。已经定义了更紧凑的编码方案，例如参见[[BH2013]](../bibliography.html#bh2013)及其参考文献。
- en: Reaching the callee[#](#reaching-the-callee "Link to this heading")
  id: totrans-1579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到达被调用者[#](#reaching-the-callee "链接到这个标题")
- en: 'The second sub-problem is how to reach the callee. A simple solution to this
    problem is to make sure that the callee listens on a specific port on the remote
    machine and then exchange information with this server process. This is the solution
    chosen for JSON-RPC [[JSON-RPC2]](../bibliography.html#json-rpc2). JSON-RPC can
    be used over the connectionless or the connection-oriented transport service.
    A JSON-RPC request contains the following fields:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子问题是如何到达被调用者。这个问题的简单解决方案是确保被调用者在远程机器上的特定端口监听，然后与这个服务器进程交换信息。这是JSON-RPC [[JSON-RPC2]](../bibliography.html#json-rpc2)所选择的解决方案。JSON-RPC可以通过无连接或面向连接的传输服务使用。一个JSON-RPC请求包含以下字段：
- en: 'jsonrpc: a string indicating the version of the protocol used. This is important
    to allow the protocol to evolve in the future.'
  id: totrans-1581
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jsonrpc: 表示所使用的协议版本的字符串。这对于允许协议在未来进行演变非常重要。'
- en: ''
  id: totrans-1582
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1583
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'method: a string that contains the name of the procedure which is invoked'
  id: totrans-1584
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'method: 包含被调用过程名称的字符串'
- en: ''
  id: totrans-1585
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1586
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'params: a structure that contains the values of the parameters that are passed
    to the method'
  id: totrans-1587
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'params: 包含传递给方法的参数值的结构体'
- en: ''
  id: totrans-1588
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1589
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: an identifier chosen by the caller'
  id: totrans-1590
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'id: 由调用者选择的标识符'
- en: The JSON-RPC is encoded as a JSON object. For example, the example below shows
    an invocation of a method called sum with 1 and 3 as parameters.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC被编码为一个JSON对象。例如，下面的例子显示了调用一个名为sum的方法，参数为1和3。
- en: '[PRE65]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Upon reception of this JSON structure, the callee parses the object, locates
    the corresponding method and passes the parameters. This method returns a response
    which is also encoded as a JSON structure. This response contains the following
    fields:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到这个JSON结构时，调用者解析对象，找到对应的方法并传递参数。此方法返回一个响应，该响应也编码为JSON结构。此响应包含以下字段：
- en: 'jsonrpc: a string indicating the version of the protocol used to encode the
    response'
  id: totrans-1594
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jsonrpc: 一个字符串，表示用于编码响应的协议版本'
- en: ''
  id: totrans-1595
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1596
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: the same identifier as the identifier chosen by the caller'
  id: totrans-1597
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'id: 与调用者选择的标识符相同的标识符'
- en: ''
  id: totrans-1598
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1599
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: if the request succeeded, this member contains the result of the request
    (in our example, value 4).'
  id: totrans-1600
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'result: 如果请求成功，此成员包含请求的结果（在我们的例子中，值为4）。'
- en: ''
  id: totrans-1601
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1602
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'error: if the method called does not exist or its execution causes an error,
    the result element will be replaced by an error element which contains the following
    members :'
  id: totrans-1603
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'error: 如果调用不存在或其执行导致错误，结果元素将被替换为包含以下成员的错误元素：'
- en: ''
  id: totrans-1604
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1605
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1606
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'code: a number that indicates the type of error. Several error codes are defined
    in [[JSON-RPC2]](../bibliography.html#json-rpc2). For example, -32700 indicates
    an error in parsing the request, -32602 indicates invalid parameters and -32601
    indicates that the method could not be found on the server. Other error codes
    are listed in [[JSON-RPC2]](../bibliography.html#json-rpc2).'
  id: totrans-1607
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'code: 一个数字，表示错误的类型。在[[JSON-RPC2]](../bibliography.html#json-rpc2)中定义了几个错误代码。例如，-32700表示请求解析错误，-32602表示参数无效，-32601表示服务器上找不到该方法。其他错误代码在[[JSON-RPC2]](../bibliography.html#json-rpc2)中列出。'
- en: ''
  id: totrans-1608
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1609
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message: a string (limited to one sentence) that provides a short description
    of the error.'
  id: totrans-1610
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'message: 一个字符串（限于一句话），提供对错误的简短描述。'
- en: ''
  id: totrans-1611
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1612
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'data: an optional field that provides additional information about the error.'
  id: totrans-1613
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'data: 一个可选字段，提供有关错误的附加信息。'
- en: Coming back to our example with the call for the sum procedure, it would return
    the following JSON structure.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们调用sum过程的例子，它将返回以下JSON结构。
- en: '[PRE66]'
  id: totrans-1615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the sum method is not implemented on the server, it would reply with the
    following response.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器上未实现sum方法，它将回复以下响应。
- en: '[PRE67]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The id field, which is present in the request and the response plays the same
    role as the identifier field in the DNS message. It allows the caller to match
    the response with the request that it sent. This id is very important when JSON-RPC
    is used over the connectionless transport service which is unreliable. If a request
    is sent, it may need to be retransmitted and it is possible that a callee will
    receive twice the same request (e.g. if the response for the first request was
    lost). In the DNS, when a request is lost, it can be retransmitted without causing
    any difficulty. However with remote procedure calls in general, losses can cause
    some problems. Consider a method which is used to deposit money on a bank account.
    If the request is lost, it will be retransmitted and the deposit will be eventually
    performed. However, if the response is lost, the caller will also retransmit its
    request. This request will be received by the callee that will deposit the money
    again. To prevent this problem from affecting the application, either the programmer
    must ensure that the remote procedures that it calls can be safely called multiple
    times or the application must verify whether the request has been transmitted
    earlier. In most deployments, the programmers use remote methods that can be safely
    called multiple times without breaking the application logic.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: id字段存在于请求和响应中，它在DNS消息中的标识符字段中扮演相同的角色。它允许调用者将响应与其发送的请求匹配。当在不可靠的无连接传输服务上使用JSON-RPC时，此id非常重要。如果发送了一个请求，它可能需要重新传输，并且可能调用者会收到两次相同的请求（例如，如果第一个请求的响应丢失了）。在DNS中，当请求丢失时，可以重新传输而不会造成任何困难。然而，在一般远程过程调用中，丢失可能会引起一些问题。考虑一个用于在银行账户上存钱的函数。如果请求丢失，它将被重新传输，存款最终会完成。然而，如果响应丢失，调用者也会重新传输其请求。这个请求将被调用者接收，并将再次存钱。为了防止这个问题影响应用程序，程序员必须确保它调用的远程过程可以安全地多次调用，或者应用程序必须验证请求是否已经传输过。在大多数部署中，程序员使用可以安全多次调用而不破坏应用程序逻辑的远程方法。
- en: ONC-RPC uses a more complex method to allow a caller to reach the callee. On
    a host, server processes can run on different ports and given the limited number
    of port values (\(2^{16}\) per host on the Internet), it is impossible to reserve
    one port number for each method. The solution used in ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)
    is to use a special method which is called the portmapper [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html).
    The portmapper is a kind of directory that runs on a server that hosts methods.
    The portmapper runs on a standard port (111 for ONC-RPC [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)).
    A server process that implements a method registers its method on the local portmapper.
    When a caller needs to call a method on a remote server, it first contacts the
    portmapper to obtain the port number of the server process which implements the
    method. The response from the portmapper allows it to directly contact the server
    process which implements the method.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: ONC-RPC使用一种更复杂的方法来允许调用者到达被调用者。在主机上，服务器进程可以运行在不同的端口上，考虑到端口值的限制（因特网上的每个主机有\(2^{16}\)个端口值），不可能为每种方法保留一个端口号。ONC-RPC
    [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)中使用的解决方案是使用一种特殊的方法，称为端口号映射器
    [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)。端口号映射器是一种在提供方法的主机上运行的目录。端口号映射器在一个标准端口上运行（ONC-RPC
    [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)的111号端口）。实现方法的服务器进程在其本地端口号映射器上注册其方法。当调用者需要调用远程服务器上的方法时，它首先联系端口号映射器以获取实现该方法的进程的端口号。端口号映射器的响应允许它直接联系实现该方法的进程。
- en: Footnotes
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: '### Encoding data[#](#encoding-data "Link to this heading")'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '### 编码数据[#](#encoding-data "链接到本标题")'
- en: The encoding problem exists in a wide range of applications. In the previous
    sections, we have described how character-based encodings are used by email and
    HTTP. Although standard encoding techniques such as ASN.1 [[Dubuisson2000]](../bibliography.html#dubuisson2000)
    have been defined to cover most application needs, many applications have defined
    their specific encoding. Remote Procedure Call are no exception to this rule.
    The three most popular encoding methods are probably XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    used by ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html),
    XML, used by XML-RPC and JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html).
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 编码问题存在于广泛的应用中。在前面的章节中，我们描述了基于字符的编码如何被电子邮件和HTTP使用。尽管已经定义了标准编码技术，如ASN.1 [[Dubuisson2000]](../bibliography.html#dubuisson2000)，以覆盖大多数应用需求，但许多应用已经定义了它们自己的特定编码。远程过程调用也不例外。最流行的三种编码方法可能是XDR
    [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)，它被ONC-RPC [**RFC
    1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)使用，XML，它被XML-RPC使用，以及JSON
    [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)。
- en: The eXternal Data Representation (XDR) Standard, defined in [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    is an early specification that describes how information exchanged during Remote
    Procedure Calls should be encoded before being transmitted through a network.
    Since the transport service enables transferring a block of bytes (with the connectionless
    service) or a stream of bytes (by using the connection-oriented service), XDR
    maps each datatype onto a sequence of bytes. The caller encodes each data in the
    appropriate sequence and the callee decodes the received information. Here are
    a few examples extracted from [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    to illustrate how this encoding/decoding can be performed.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数据表示（XDR）标准，定义在[**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)中，是一个早期的规范，它描述了在远程过程调用期间交换的信息在通过网络传输之前应该如何编码。由于传输服务能够传输一个字节数组（通过无连接服务）或一个字节流（通过使用面向连接的服务），XDR将每个数据类型映射到一个字节序列。调用者将每个数据编码到适当的序列中，而被调用者解码接收到的信息。以下是从[**RFC
    1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)中提取的一些示例，以说明这种编码/解码是如何进行的。
- en: For basic data types, [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    simply maps their representation into a sequence of bytes. For example a 32 bits
    integer is transmitted as shown in [Fig. 43](#fig-xdr-int32) (with the most significant
    byte first, which corresponds to big-endian encoding).
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本数据类型，[**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)简单地将它们的表示映射到一个字节序列。例如，一个32位整数按照[图43](#fig-xdr-int32)所示的方式传输（最高有效字节在前，这对应于大端编码）。
- en: '![../_images/xdr-integer.svg](../Images/d52e7c6b6281eb132d460857ec233eff.png)'
  id: totrans-1625
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/xdr-integer.svg](../Images/d52e7c6b6281eb132d460857ec233eff.png)'
- en: Fig. 43 XDR representation of a 32 bits integer[#](#id72 "Link to this image")
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 图 43 XDR 表示 32 位整数[#](#id72 "链接到这张图片")
- en: 'XDR also supports 64 bits integers and booleans. The booleans are mapped onto
    integers (0 for false and 1 for true). For the floating point numbers, the encoding
    defined in the IEEE standard is used. In the representation, the first bit (S)
    is the sign (0 represents positive). The next 11 bits represent the exponent of
    the number (E), in base 2, and the remaining 52 bits are the fractional part of
    the number (F). The floating point number that corresponds to this representation
    is \((-1)^{S} \times 2^{E-1023} \times 1.F\). XDR also allows encoding complex
    data types. A first example is the string of bytes. A string of bytes is composed
    of two parts : a length (encoded as an integer) and a sequence of bytes. For performance
    reasons, the encoding of a string is aligned to 32 bits boundaries. This implies
    that some padding bytes may be inserted during the encoding operation is the length
    of the string is not a multiple of 4\. The structure of the string is shown below
    (source [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)).'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: XDR 还支持 64 位整数和布尔值。布尔值映射到整数（0 表示假，1 表示真）。对于浮点数，使用 IEEE 标准中定义的编码。在表示中，第一个位（S）是符号（0
    表示正）。接下来的 11 位表示数字的指数（E），以 2 为基数，剩余的 52 位是数字的小数部分（F）。与这种表示相对应的浮点数是 \((-1)^{S}
    \times 2^{E-1023} \times 1.F\)。XDR 还允许编码复杂的数据类型。第一个例子是字节数组。字节数组由两部分组成：一个长度（编码为一个整数）和一个字节序列。出于性能考虑，字符串的编码对齐到
    32 位边界。这意味着如果字符串的长度不是 4 的倍数，编码操作过程中可能会插入一些填充字节。字符串的结构如下所示（来源 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html))。
- en: '[![../_images/xdr-float.svg](../Images/b3e916ca81c68d2a4b58075d4bf0bb7c.png)](../_images/xdr-float.svg)'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '![![../_images/xdr-float.svg](../Images/b3e916ca81c68d2a4b58075d4bf0bb7c.png)](../_images/xdr-float.svg)'
- en: Fig. 44 XDR representation of a floating point number[#](#id73 "Link to this
    image")
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 图 44 XDR 表示浮点数[#](#id73 "链接到这张图片")
- en: In some situations, it is necessary to encode fixed or variable length arrays.
    XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html) supports
    such arrays. For example, the encoding in [Fig. 45](#fig-xdr-narray) corresponds
    to an array containing n elements. The encoded representation starts with an integer
    that contains the number of elements and follows with all elements in sequence.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要编码固定长度或可变长度数组。XDR [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)
    支持此类数组。例如，[图 45](#fig-xdr-narray) 中的编码对应于包含 n 个元素的数组。编码表示以一个包含元素数量的整数开始，随后是所有元素的顺序序列。
- en: '[![../_images/xdr-array.svg](../Images/e1244da31b6e5cd69f0f51dd6cf774b8.png)](../_images/xdr-array.svg)'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '![![../_images/xdr-array.svg](../Images/e1244da31b6e5cd69f0f51dd6cf774b8.png)](../_images/xdr-array.svg)'
- en: Fig. 45 XDR representation of an array[#](#id74 "Link to this image")
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 图 45 XDR 表示数组[#](#id74 "链接到这张图片")
- en: XDR also supports the definition of unions, structures, … Additional details
    are provided in [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html).
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: XDR 还支持定义联合、结构体等。更多详细信息请参阅 [**RFC 1832**](https://datatracker.ietf.org/doc/html/rfc1832.html)。
- en: A second popular method to encode data is the JavaScript Object Notation (JSON).
    This syntax was initially defined to allow applications written in JavaScript
    to exchange data, but it has now wider usages. JSON [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    is a text-based representation. The simplest data type is the integer. It is represented
    as a sequence of digits in ASCII. Strings can also be encoding by using JSON.
    A JSON string always starts and ends with a quote character (”) as in the C language.
    As in the C language, some characters (like “ or \) must be escaped if they appear
    in a string. [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html)
    describes this in details. Booleans are also supported by using the strings false
    and true. Like XDR, JSON supports more complex data types. A structure or object
    is defined as a comma separated list of elements enclosed in curly brackets. [**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) provides the following
    example as an illustration.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据的第二种流行方法是JavaScript对象表示法（JSON）。这种语法最初是为了允许用JavaScript编写的应用程序交换数据而定义的，但现在它有更广泛的应用。JSON
    [**RFC 4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) 是一种基于文本的表示。最简单的数据类型是整数，它以ASCII码中的数字序列表示。字符串也可以通过使用JSON进行编码。JSON字符串始终以引号字符（”）开头和结尾，就像C语言一样。与C语言一样，如果某些字符（如“或\）出现在字符串中，则必须进行转义。[**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) 详细描述了这一点。布尔值也通过使用字符串false和true来支持。与XDR一样，JSON支持更复杂的数据类型。结构或对象定义为用花括号括起来的元素列表，元素之间用逗号分隔。[**RFC
    4627**](https://datatracker.ietf.org/doc/html/rfc4627.html) 提供了以下示例作为说明。
- en: '[PRE68]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This object has one field named Image. It has five attributes. The first one,
    Width, is an integer set to 800\. The third one is a string. The fourth attribute,
    Thumbnail is also an object composed of three different attributes, one string
    and two integers. JSON can also be used to encode arrays or lists. In this case,
    square brackets are used as delimiters. The snippet below shows an array which
    contains the prime integers that are smaller than ten.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象有一个名为Image的字段。它有五个属性。第一个属性，Width，是一个设置为800的整数。第三个属性是一个字符串。第四个属性，Thumbnail，也是一个由三个不同属性组成的对象，包括一个字符串和两个整数。JSON也可以用来编码数组或列表。在这种情况下，方括号用作分隔符。下面的代码片段显示了一个包含小于十的质数的数组。
- en: '[PRE69]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Compared with XDR, the main advantage of JSON is that the transfer syntax is
    easily readable by a human. However, this comes at the expense of a less compact
    encoding. Some data encoded in JSON will usually take more space than when it
    is encoded with XDR. More compact encoding schemes have been defined, see e.g.
    [[BH2013]](../bibliography.html#bh2013) and the references therein.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 与XDR相比，JSON的主要优势是传输语法易于人类阅读。然而，这是以牺牲更紧凑的编码为代价的。一些用JSON编码的数据通常比用XDR编码时占用更多空间。已经定义了更紧凑的编码方案，例如参见[[BH2013]](../bibliography.html#bh2013)及其参考文献。
- en: Reaching the callee[#](#reaching-the-callee "Link to this heading")
  id: totrans-1639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 达到被调用方[#](#reaching-the-callee "链接到这个标题")
- en: 'The second sub-problem is how to reach the callee. A simple solution to this
    problem is to make sure that the callee listens on a specific port on the remote
    machine and then exchange information with this server process. This is the solution
    chosen for JSON-RPC [[JSON-RPC2]](../bibliography.html#json-rpc2). JSON-RPC can
    be used over the connectionless or the connection-oriented transport service.
    A JSON-RPC request contains the following fields:'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子问题是如何到达被调用方。解决这个问题的简单方法是在远程机器上的特定端口确保被调用方监听，然后与这个服务器进程交换信息。这是为JSON-RPC [[JSON-RPC2]](../bibliography.html#json-rpc2)
    选择的方法。JSON-RPC可以通过无连接或面向连接的传输服务使用。一个JSON-RPC请求包含以下字段：
- en: 'jsonrpc: a string indicating the version of the protocol used. This is important
    to allow the protocol to evolve in the future.'
  id: totrans-1641
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jsonrpc: 表示所使用的协议版本的字符串。这对于允许协议在未来进行演变非常重要。'
- en: ''
  id: totrans-1642
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1643
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'method: a string that contains the name of the procedure which is invoked'
  id: totrans-1644
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'method: 包含被调用的过程名称的字符串'
- en: ''
  id: totrans-1645
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1646
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'params: a structure that contains the values of the parameters that are passed
    to the method'
  id: totrans-1647
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'params: 包含传递给方法的参数值的结构'
- en: ''
  id: totrans-1648
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1649
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: an identifier chosen by the caller'
  id: totrans-1650
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'id: 由调用者选择的标识符'
- en: The JSON-RPC is encoded as a JSON object. For example, the example below shows
    an invocation of a method called sum with 1 and 3 as parameters.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC被编码为一个JSON对象。例如，下面的示例显示了调用名为sum的方法，参数为1和3。
- en: '[PRE70]'
  id: totrans-1652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Upon reception of this JSON structure, the callee parses the object, locates
    the corresponding method and passes the parameters. This method returns a response
    which is also encoded as a JSON structure. This response contains the following
    fields:'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到这个 JSON 结构后，被调用者解析该对象，定位相应的函数并传递参数。此函数返回一个响应，该响应也编码为 JSON 结构。此响应包含以下字段：
- en: 'jsonrpc: a string indicating the version of the protocol used to encode the
    response'
  id: totrans-1654
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: jsonrpc：一个字符串，表示用于编码响应的协议版本
- en: ''
  id: totrans-1655
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1656
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'id: the same identifier as the identifier chosen by the caller'
  id: totrans-1657
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: id：与调用者选择的标识符相同的标识符
- en: ''
  id: totrans-1658
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1659
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'result: if the request succeeded, this member contains the result of the request
    (in our example, value 4).'
  id: totrans-1660
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: result：如果请求成功，此成员包含请求的结果（在我们的例子中，值为 4）。
- en: ''
  id: totrans-1661
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1662
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'error: if the method called does not exist or its execution causes an error,
    the result element will be replaced by an error element which contains the following
    members :'
  id: totrans-1663
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: error：如果调用的方法不存在或其执行导致错误，结果元素将被替换为一个包含以下成员的错误元素：
- en: ''
  id: totrans-1664
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1665
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1666
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'code: a number that indicates the type of error. Several error codes are defined
    in [[JSON-RPC2]](../bibliography.html#json-rpc2). For example, -32700 indicates
    an error in parsing the request, -32602 indicates invalid parameters and -32601
    indicates that the method could not be found on the server. Other error codes
    are listed in [[JSON-RPC2]](../bibliography.html#json-rpc2).'
  id: totrans-1667
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: code：一个数字，表示错误的类型。在 [[JSON-RPC2]](../bibliography.html#json-rpc2) 中定义了几个错误代码。例如，-32700
    表示请求解析错误，-32602 表示参数无效，-32601 表示服务器上找不到该函数。其他错误代码在 [[JSON-RPC2]](../bibliography.html#json-rpc2)
    中列出。
- en: ''
  id: totrans-1668
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1669
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message: a string (limited to one sentence) that provides a short description
    of the error.'
  id: totrans-1670
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: message：一个字符串（限于一句话），提供错误的简短描述。
- en: ''
  id: totrans-1671
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1672
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'data: an optional field that provides additional information about the error.'
  id: totrans-1673
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: data：一个可选字段，提供有关错误的附加信息。
- en: Coming back to our example with the call for the sum procedure, it would return
    the following JSON structure.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们关于求和过程的调用示例，它将返回以下 JSON 结构。
- en: '[PRE71]'
  id: totrans-1675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If the sum method is not implemented on the server, it would reply with the
    following response.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器上未实现求和方法，它将回复以下响应。
- en: '[PRE72]'
  id: totrans-1677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The id field, which is present in the request and the response plays the same
    role as the identifier field in the DNS message. It allows the caller to match
    the response with the request that it sent. This id is very important when JSON-RPC
    is used over the connectionless transport service which is unreliable. If a request
    is sent, it may need to be retransmitted and it is possible that a callee will
    receive twice the same request (e.g. if the response for the first request was
    lost). In the DNS, when a request is lost, it can be retransmitted without causing
    any difficulty. However with remote procedure calls in general, losses can cause
    some problems. Consider a method which is used to deposit money on a bank account.
    If the request is lost, it will be retransmitted and the deposit will be eventually
    performed. However, if the response is lost, the caller will also retransmit its
    request. This request will be received by the callee that will deposit the money
    again. To prevent this problem from affecting the application, either the programmer
    must ensure that the remote procedures that it calls can be safely called multiple
    times or the application must verify whether the request has been transmitted
    earlier. In most deployments, the programmers use remote methods that can be safely
    called multiple times without breaking the application logic.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: id 字段，存在于请求和响应中，在 DNS 消息中的标识符字段中扮演相同角色。它允许调用者将响应与它发送的请求匹配。当 JSON-RPC 在不可靠的无连接传输服务上使用时，此
    id 非常重要。如果发送了一个请求，可能需要重新传输，并且可能调用者会收到两次相同的请求（例如，如果第一个请求的响应丢失）。在 DNS 中，当请求丢失时，可以重新传输而不会造成任何困难。然而，在一般远程过程调用中，丢失可能会引起一些问题。考虑一个用于在银行账户上存钱的函数。如果请求丢失，它将被重新传输，存款最终会完成。然而，如果响应丢失，调用者也会重新发送其请求。这个请求将被调用者接收，并将再次存钱。为了防止这个问题影响应用程序，程序员必须确保它调用的远程过程可以安全地多次调用，或者应用程序必须验证请求是否已经发送过。在大多数部署中，程序员使用可以安全多次调用而不破坏应用程序逻辑的远程方法。
- en: ONC-RPC uses a more complex method to allow a caller to reach the callee. On
    a host, server processes can run on different ports and given the limited number
    of port values (\(2^{16}\) per host on the Internet), it is impossible to reserve
    one port number for each method. The solution used in ONC-RPC [**RFC 1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)
    is to use a special method which is called the portmapper [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html).
    The portmapper is a kind of directory that runs on a server that hosts methods.
    The portmapper runs on a standard port (111 for ONC-RPC [**RFC 1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)).
    A server process that implements a method registers its method on the local portmapper.
    When a caller needs to call a method on a remote server, it first contacts the
    portmapper to obtain the port number of the server process which implements the
    method. The response from the portmapper allows it to directly contact the server
    process which implements the method.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: ONC-RPC使用一种更复杂的方法来允许调用者连接到被调用者。在主机上，服务器进程可以运行在不同的端口上，考虑到端口号的数量有限（每个互联网主机有\(2^{16}\)个端口号），为每种方法预留一个端口号是不可能的。ONC-RPC中使用的解决方案是在[**RFC
    1831**](https://datatracker.ietf.org/doc/html/rfc1831.html)中，采用一种特殊的方法，称为端口号映射器[**RFC
    1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)。端口号映射器是一种运行在提供方法的主机上的目录。端口号映射器运行在标准端口上（对于ONC-RPC是111[**RFC
    1833**](https://datatracker.ietf.org/doc/html/rfc1833.html)）。实现方法的服务器进程在其本地端口号映射器上注册其方法。当调用者需要远程服务器上的方法时，它首先联系端口号映射器以获取实现该方法的进程的端口号。端口号映射器的响应允许它直接联系实现该方法的进程。
- en: Footnotes
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
