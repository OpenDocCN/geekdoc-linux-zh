["```sh #!/bin/bash\n# mail-format.sh (ver. 1.1): Format e-mail messages.\n\n# Gets rid of carets, tabs, and also folds excessively long lines.\n\n# =================================================================\n#                 Standard Check for Script Argument(s)\nARGS=1\nE_BADARGS=85\nE_NOFILE=86\n\nif [ $# -ne $ARGS ]  # Correct number of arguments passed to script?\nthen\n  echo \"Usage: `basename $0` filename\"\n  exit $E_BADARGS\nfi\n\nif [ -f \"$1\" ]       # Check if file exists.\nthen\n    file_name=$1\nelse\n    echo \"File \\\"$1\\\" does not exist.\"\n    exit $E_NOFILE\nfi\n# -----------------------------------------------------------------\n\nMAXWIDTH=70          # Width to fold excessively long lines to.\n\n# =================================\n# A variable can hold a sed script.\n# It's a useful technique.\nsedscript='s/^>//\ns/^  *>//\ns/^  *//\ns/\t\t*//'\n# =================================\n\n#  Delete carets and tabs at beginning of lines,\n#+ then fold lines to $MAXWIDTH characters.\nsed \"$sedscript\" $1 &#124; fold -s --width=$MAXWIDTH\n                        #  -s option to \"fold\"\n                        #+ breaks lines at whitespace, if possible.\n\n#  This script was inspired by an article in a well-known trade journal\n#+ extolling a 164K MS Windows utility with similar functionality.\n#\n#  An nice set of text processing utilities and an efficient\n#+ scripting language provide an alternative to the bloated executables\n#+ of a clunky operating system.\n\nexit $?\n```", "```sh #! /bin/bash\n# rn.sh\n\n# Very simpleminded filename \"rename\" utility (based on \"lowercase.sh\").\n#\n#  The \"ren\" utility, by Vladimir Lanin (lanin@csd2.nyu.edu),\n#+ does a much better job of this.\n\nARGS=2\nE_BADARGS=85\nONE=1                     # For getting singular/plural right (see below).\n\nif [ $# -ne \"$ARGS\" ]\nthen\n  echo \"Usage: `basename $0` old-pattern new-pattern\"\n  # As in \"rn gif jpg\", which renames all gif files in working directory to jpg.\n  exit $E_BADARGS\nfi\n\nnumber=0                  # Keeps track of how many files actually renamed.\n\nfor filename in *$1*      #Traverse all matching files in directory.\ndo\n   if [ -f \"$filename\" ]  # If finds match...\n   then\n     fname=`basename $filename`            # Strip off path.\n     n=`echo $fname &#124; sed -e \"s/$1/$2/\"`   # Substitute new for old in filename.\n     mv $fname $n                          # Rename.\n     let \"number += 1\"\n   fi\ndone   \n\nif [ \"$number\" -eq \"$ONE\" ]                # For correct grammar.\nthen\n echo \"$number file renamed.\"\nelse \n echo \"$number files renamed.\"\nfi \n\nexit $?\n\n# Exercises:\n# ---------\n# What types of files will this not work on?\n# How can this be fixed?\n```", "```sh #! /bin/bash\n# blank-rename.sh\n#\n# Substitutes underscores for blanks in all the filenames in a directory.\n\nONE=1                     # For getting singular/plural right (see below).\nnumber=0                  # Keeps track of how many files actually renamed.\nFOUND=0                   # Successful return value.\n\nfor filename in *         #Traverse all files in directory.\ndo\n     echo \"$filename\" &#124; grep -q \" \"         #  Check whether filename\n     if [ $? -eq $FOUND ]                   #+ contains space(s).\n     then\n       fname=$filename                      # Yes, this filename needs work.\n       n=`echo $fname &#124; sed -e \"s/ /_/g\"`   # Substitute underscore for blank.\n       mv \"$fname\" \"$n\"                     # Do the actual renaming.\n       let \"number += 1\"\n     fi\ndone   \n\nif [ \"$number\" -eq \"$ONE\" ]                 # For correct grammar.\nthen\n echo \"$number file renamed.\"\nelse \n echo \"$number files renamed.\"\nfi \n\nexit 0\n```", "```sh #!/bin/bash\n\n# Example \"ex72.sh\" modified to use encrypted password.\n\n#  Note that this is still rather insecure,\n#+ since the decrypted password is sent in the clear.\n#  Use something like \"ssh\" if this is a concern.\n\nE_BADARGS=85\n\nif [ -z \"$1\" ]\nthen\n  echo \"Usage: `basename $0` filename\"\n  exit $E_BADARGS\nfi  \n\nUsername=bozo           # Change to suit.\npword=/home/bozo/secret/password_encrypted.file\n# File containing encrypted password.\n\nFilename=`basename $1`  # Strips pathname out of file name.\n\nServer=\"XXX\"\nDirectory=\"YYY\"         # Change above to actual server name & directory.\n\nPassword=`cruft <$pword`          # Decrypt password.\n#  Uses the author's own \"cruft\" file encryption package,\n#+ based on the classic \"onetime pad\" algorithm,\n#+ and obtainable from:\n#+ Primary-site:   ftp://ibiblio.org/pub/Linux/utils/file\n#+                 cruft-0.2.tar.gz [16k]\n\nftp -n $Server <<End-Of-Session\nuser $Username $Password\nbinary\nbell\ncd $Directory\nput $Filename\nbye\nEnd-Of-Session\n# -n option to \"ftp\" disables auto-logon.\n# Note that \"bell\" rings 'bell' after each file transfer.\n\nexit 0\n```", "```sh #!/bin/bash\n# copy-cd.sh: copying a data CD\n\nCDROM=/dev/cdrom                           # CD ROM device\nOF=/home/bozo/projects/cdimage.iso         # output file\n#       /xxxx/xxxxxxxx/                      Change to suit your system.\nBLOCKSIZE=2048\n# SPEED=10                                 # If unspecified, uses max spd.\n# DEVICE=/dev/cdrom                          older version.\nDEVICE=\"1,0,0\"\n\necho; echo \"Insert source CD, but do *not* mount it.\"\necho \"Press ENTER when ready. \"\nread ready                                 # Wait for input, $ready not used.\n\necho; echo \"Copying the source CD to $OF.\"\necho \"This may take a while. Please be patient.\"\n\ndd if=$CDROM of=$OF bs=$BLOCKSIZE          # Raw device copy.\n\necho; echo \"Remove data CD.\"\necho \"Insert blank CDR.\"\necho \"Press ENTER when ready. \"\nread ready                                 # Wait for input, $ready not used.\n\necho \"Copying $OF to CDR.\"\n\n# cdrecord -v -isosize speed=$SPEED dev=$DEVICE $OF   # Old version.\nwodim -v -isosize dev=$DEVICE $OF\n# Uses Joerg Schilling's \"cdrecord\" package (see its docs).\n# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html\n# Newer Linux distros may use \"wodim\" rather than \"cdrecord\" ...\n\necho; echo \"Done copying $OF to CDR on device $CDROM.\"\n\necho \"Do you want to erase the image file (y/n)? \"  # Probably a huge file.\nread answer\n\ncase \"$answer\" in\n[yY]) rm -f $OF\n      echo \"$OF erased.\"\n      ;;\n*)    echo \"$OF not erased.\";;\nesac\n\necho\n\n# Exercise:\n# Change the above \"case\" statement to also accept \"yes\" and \"Yes\" as input.\n\nexit 0\n```", "```sh #!/bin/bash\n# collatz.sh\n\n#  The notorious \"hailstone\" or Collatz series.\n#  -------------------------------------------\n#  1) Get the integer \"seed\" from the command-line.\n#  2) NUMBER <-- seed\n#  3) Print NUMBER.\n#  4)  If NUMBER is even, divide by 2, or\n#  5)+ if odd, multiply by 3 and add 1.\n#  6) NUMBER <-- result \n#  7) Loop back to step 3 (for specified number of iterations).\n#\n#  The theory is that every such sequence,\n#+ no matter how large the initial value,\n#+ eventually settles down to repeating \"4,2,1...\" cycles,\n#+ even after fluctuating through a wide range of values.\n#\n#  This is an instance of an \"iterate,\"\n#+ an operation that feeds its output back into its input.\n#  Sometimes the result is a \"chaotic\" series.\n\nMAX_ITERATIONS=200\n# For large seed numbers (>32000), try increasing MAX_ITERATIONS.\n\nh=${1:-$$}                      #  Seed.\n                                #  Use $PID as seed,\n                                #+ if not specified as command-line arg.\n\necho\necho \"C($h) -*- $MAX_ITERATIONS Iterations\"\necho\n\nfor ((i=1; i<=MAX_ITERATIONS; i++))\ndo\n\n# echo -n \"$h\t\"\n#            ^^^ \n#            tab\n# printf does it better ...\nCOLWIDTH=%7d\nprintf $COLWIDTH $h\n\n  let \"remainder = h % 2\"\n  if [ \"$remainder\" -eq 0 ]   # Even?\n  then\n    let \"h /= 2\"              # Divide by 2.\n  else\n    let \"h = h*3 + 1\"         # Multiply by 3 and add 1.\n  fi\n\nCOLUMNS=10                    # Output 10 values per line.\nlet \"line_break = i % $COLUMNS\"\nif [ \"$line_break\" -eq 0 ]\nthen\n  echo\nfi  \n\ndone\n\necho\n\n#  For more information on this strange mathematical function,\n#+ see _Computers, Pattern, Chaos, and Beauty_, by Pickover, p. 185 ff.,\n#+ as listed in the bibliography.\n\nexit 0\n```", "```sh #!/bin/bash\n# days-between.sh:    Number of days between two dates.\n# Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY\n#\n# Note: Script modified to account for changes in Bash, v. 2.05b +,\n#+      that closed the loophole permitting large negative\n#+      integer return values.\n\nARGS=2                # Two command-line parameters expected.\nE_PARAM_ERR=85        # Param error.\n\nREFYR=1600            # Reference year.\nCENTURY=100\nDIY=365\nADJ_DIY=367           # Adjusted for leap year + fraction.\nMIY=12\nDIM=31\nLEAPCYCLE=4\n\nMAXRETVAL=255         #  Largest permissible\n                      #+ positive return value from a function.\n\ndiff=                 # Declare global variable for date difference.\nvalue=                # Declare global variable for absolute value.\nday=                  # Declare globals for day, month, year.\nmonth=\nyear=\n\nParam_Error ()        # Command-line parameters wrong.\n{\n  echo \"Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY\"\n  echo \"       (date must be after 1/3/1600)\"\n  exit $E_PARAM_ERR\n}  \n\nParse_Date ()                 # Parse date from command-line params.\n{\n  month=${1%%/**}\n  dm=${1%/**}                 # Day and month.\n  day=${dm#*/}\n  let \"year = `basename $1`\"  # Not a filename, but works just the same.\n}  \n\ncheck_date ()                 # Checks for invalid date(s) passed.\n{\n  [ \"$day\" -gt \"$DIM\" ] &#124;&#124; [ \"$month\" -gt \"$MIY\" ] &#124;&#124;\n  [ \"$year\" -lt \"$REFYR\" ] && Param_Error\n  # Exit script on bad value(s).\n  # Uses or-list / and-list.\n  #\n  # Exercise: Implement more rigorous date checking.\n}\n\nstrip_leading_zero () #  Better to strip possible leading zero(s)\n{                     #+ from day and/or month\n  return ${1#0}       #+ since otherwise Bash will interpret them\n}                     #+ as octal values (POSIX.2, sect 2.9.2.1).\n\nday_index ()          # Gauss' Formula:\n{                     # Days from March 1, 1600 to date passed as param.\n                      #           ^^^^^^^^^^^^^\n  day=$1\n  month=$2\n  year=$3\n\n  let \"month = $month - 2\"\n  if [ \"$month\" -le 0 ]\n  then\n    let \"month += 12\"\n    let \"year -= 1\"\n  fi  \n\n  let \"year -= $REFYR\"\n  let \"indexyr = $year / $CENTURY\"\n\n  let \"Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr \\\n              + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM\"\n  #  For an in-depth explanation of this algorithm, see\n  #+   http://weblogs.asp.net/pgreborio/archive/2005/01/06/347968.aspx\n\n  echo $Days\n\n}  \n\ncalculate_difference ()            # Difference between two day indices.\n{\n  let \"diff = $1 - $2\"             # Global variable.\n}  \n\nabs ()                             #  Absolute value\n{                                  #  Uses global \"value\" variable.\n  if [ \"$1\" -lt 0 ]                #  If negative\n  then                             #+ then\n    let \"value = 0 - $1\"           #+ change sign,\n  else                             #+ else\n    let \"value = $1\"               #+ leave it alone.\n  fi\n}\n\nif [ $# -ne \"$ARGS\" ]              # Require two command-line params.\nthen\n  Param_Error\nfi  \n\nParse_Date $1\ncheck_date $day $month $year       #  See if valid date.\n\nstrip_leading_zero $day            #  Remove any leading zeroes\nday=$?                             #+ on day and/or month.\nstrip_leading_zero $month\nmonth=$?\n\nlet \"date1 = `day_index $day $month $year`\"\n\nParse_Date $2\ncheck_date $day $month $year\n\nstrip_leading_zero $day\nday=$?\nstrip_leading_zero $month\nmonth=$?\n\ndate2=$(day_index $day $month $year) # Command substitution.\n\ncalculate_difference $date1 $date2\n\nabs $diff                            # Make sure it's positive.\ndiff=$value\n\necho $diff\n\nexit 0\n\n#  Exercise:\n#  --------\n#  If given only one command-line parameter, have the script\n#+ use today's date as the second.\n\n#  Compare this script with\n#+ the implementation of Gauss' Formula in a C program at\n#+    http://buschencrew.hypermart.net/software/datedif\n```", "```sh #!/bin/bash\n# makedict.sh  [make dictionary]\n\n# Modification of /usr/sbin/mkdict (/usr/sbin/cracklib-forman) script.\n# Original script copyright 1993, by Alec Muffett.\n#\n#  This modified script included in this document in a manner\n#+ consistent with the \"LICENSE\" document of the \"Crack\" package\n#+ that the original script is a part of.\n\n#  This script processes text files to produce a sorted list\n#+ of words found in the files.\n#  This may be useful for compiling dictionaries\n#+ and for other lexicographic purposes.\n\nE_BADARGS=85\n\nif [ ! -r \"$1\" ]                    #  Need at least one\nthen                                #+ valid file argument.\n  echo \"Usage: $0 files-to-process\"\n  exit $E_BADARGS\nfi  \n\n# SORT=\"sort\"                       #  No longer necessary to define\n                                    #+ options to sort. Changed from\n                                    #+ original script.\n\ncat $* &#124;                            #  Dump specified files to stdout.\n        tr A-Z a-z &#124;                #  Convert to lowercase.\n        tr ' ' '\\012' &#124;             #  New: change spaces to newlines.\n#       tr -cd '\\012[a-z][0-9]' &#124;   #  Get rid of everything\n                                    #+ non-alphanumeric (in orig. script).\n        tr -c '\\012a-z'  '\\012' &#124;   #  Rather than deleting non-alpha\n                                    #+ chars, change them to newlines.\n        sort &#124;                      #  $SORT options unnecessary now.\n        uniq &#124;                      #  Remove duplicates.\n        grep -v '^#' &#124;              #  Delete lines starting with #.\n        grep -v '^$'                #  Delete blank lines.\n\nexit $?\n```", "```sh #!/bin/bash\n# soundex.sh: Calculate \"soundex\" code for names\n\n# =======================================================\n#        Soundex script\n#              by\n#         Mendel Cooper\n#     thegrendel.abs@gmail.com\n#     reldate: 23 January, 2002\n#\n#   Placed in the Public Domain.\n#\n# A slightly different version of this script appeared in\n#+ Ed Schaefer's July, 2002 \"Shell Corner\" column\n#+ in \"Unix Review\" on-line,\n#+ http://www.unixreview.com/documents/uni1026336632258/\n# =======================================================\n\nARGCOUNT=1                     # Need name as argument.\nE_WRONGARGS=90\n\nif [ $# -ne \"$ARGCOUNT\" ]\nthen\n  echo \"Usage: `basename $0` name\"\n  exit $E_WRONGARGS\nfi  \n\nassign_value ()                #  Assigns numerical value\n{                              #+ to letters of name.\n\n  val1=bfpv                    # 'b,f,p,v' = 1\n  val2=cgjkqsxz                # 'c,g,j,k,q,s,x,z' = 2\n  val3=dt                      #  etc.\n  val4=l\n  val5=mn\n  val6=r\n\n# Exceptionally clever use of 'tr' follows.\n# Try to figure out what is going on here.\n\nvalue=$( echo \"$1\" \\\n&#124; tr -d wh \\\n&#124; tr $val1 1 &#124; tr $val2 2 &#124; tr $val3 3 \\\n&#124; tr $val4 4 &#124; tr $val5 5 &#124; tr $val6 6 \\\n&#124; tr -s 123456 \\\n&#124; tr -d aeiouy )\n\n# Assign letter values.\n# Remove duplicate numbers, except when separated by vowels.\n# Ignore vowels, except as separators, so delete them last.\n# Ignore 'w' and 'h', even as separators, so delete them first.\n#\n# The above command substitution lays more pipe than a plumber <g>.\n\n}  \n\ninput_name=\"$1\"\necho\necho \"Name = $input_name\"\n\n# Change all characters of name input to lowercase.\n# ------------------------------------------------\nname=$( echo $input_name &#124; tr A-Z a-z )\n# ------------------------------------------------\n# Just in case argument to script is mixed case.\n\n# Prefix of soundex code: first letter of name.\n# --------------------------------------------\n\nchar_pos=0                     # Initialize character position. \nprefix0=${name:$char_pos:1}\nprefix=`echo $prefix0 &#124; tr a-z A-Z`\n                               # Uppercase 1st letter of soundex.\n\nlet \"char_pos += 1\"            # Bump character position to 2nd letter of name.\nname1=${name:$char_pos}\n\n# ++++++++++++++++++++++++++ Exception Patch ++++++++++++++++++++++++++++++\n#  Now, we run both the input name and the name shifted one char\n#+ to the right through the value-assigning function.\n#  If we get the same value out, that means that the first two characters\n#+ of the name have the same value assigned, and that one should cancel.\n#  However, we also need to test whether the first letter of the name\n#+ is a vowel or 'w' or 'h', because otherwise this would bollix things up.\n\nchar1=`echo $prefix &#124; tr A-Z a-z`    # First letter of name, lowercased.\n\nassign_value $name\ns1=$value\nassign_value $name1\ns2=$value\nassign_value $char1\ns3=$value\ns3=9$s3                              #  If first letter of name is a vowel\n                                     #+ or 'w' or 'h',\n                                     #+ then its \"value\" will be null (unset).\n\t\t\t\t     #+ Therefore, set it to 9, an otherwise\n\t\t\t\t     #+ unused value, which can be tested for.\n\nif [[ \"$s1\" -ne \"$s2\" &#124;&#124; \"$s3\" -eq 9 ]]\nthen\n  suffix=$s2\nelse  \n  suffix=${s2:$char_pos}\nfi  \n# ++++++++++++++++++++++ end Exception Patch ++++++++++++++++++++++++++++++\n\npadding=000                    # Use at most 3 zeroes to pad.\n\nsoun=$prefix$suffix$padding    # Pad with zeroes.\n\nMAXLEN=4                       # Truncate to maximum of 4 chars.\nsoundex=${soun:0:$MAXLEN}\n\necho \"Soundex = $soundex\"\n\necho\n\n#  The soundex code is a method of indexing and classifying names\n#+ by grouping together the ones that sound alike.\n#  The soundex code for a given name is the first letter of the name,\n#+ followed by a calculated three-number code.\n#  Similar sounding names should have almost the same soundex codes.\n\n#   Examples:\n#   Smith and Smythe both have a \"S-530\" soundex.\n#   Harrison = H-625\n#   Hargison = H-622\n#   Harriman = H-655\n\n#  This works out fairly well in practice, but there are numerous anomalies.\n#\n#\n#  The U.S. Census and certain other governmental agencies use soundex,\n#  as do genealogical researchers.\n#\n#  For more information,\n#+ see the \"National Archives and Records Administration home page\",\n#+ http://www.nara.gov/genealogy/soundex/soundex.html\n\n# Exercise:\n# --------\n# Simplify the \"Exception Patch\" section of this script.\n\nexit 0\n```", "```sh #!/bin/bash\n# life.sh: \"Life in the Slow Lane\"\n# Author: Mendel Cooper\n# License: GPL3\n\n# Version 0.2:   Patched by Daniel Albers\n#+               to allow non-square grids as input.\n# Version 0.2.1: Added 2-second delay between generations.\n\n# ##################################################################### #\n# This is the Bash script version of John Conway's \"Game of Life\".      #\n# \"Life\" is a simple implementation of cellular automata.               #\n# --------------------------------------------------------------------- #\n# On a rectangular grid, let each \"cell\" be either \"living\" or \"dead.\"  #\n# Designate a living cell with a dot, and a dead one with a blank space.#\n#      Begin with an arbitrarily drawn dot-and-blank grid,              #\n#+     and let this be the starting generation: generation 0\\.           #\n# Determine each successive generation by the following rules:          #\n#   1) Each cell has 8 neighbors, the adjoining cells                   #\n#+     left, right, top, bottom, and the 4 diagonals.                   #\n#                                                                       #\n#                       123                                             #\n#                       4*5     The * is the cell under consideration.  #\n#                       678                                             #\n#                                                                       #\n# 2) A living cell with either 2 or 3 living neighbors remains alive.   #\nSURVIVE=2                                                               #\n# 3) A dead cell with 3 living neighbors comes alive, a \"birth.\"        #\nBIRTH=3                                                                 #\n# 4) All other cases result in a dead cell for the next generation.     #\n# ##################################################################### #\n\nstartfile=gen0   # Read the starting generation from the file \"gen0\" ...\n                 # Default, if no other file specified when invoking script.\n                 #\nif [ -n \"$1\" ]   # Specify another \"generation 0\" file.\nthen\n    startfile=\"$1\"\nfi  \n\n############################################\n#  Abort script if \"startfile\" not specified\n#+ and\n#+ default file \"gen0\" not present.\n\nE_NOSTARTFILE=86\n\nif [ ! -e \"$startfile\" ]\nthen\n  echo \"Startfile \\\"\"$startfile\"\\\" missing!\"\n  exit $E_NOSTARTFILE\nfi\n############################################\n\nALIVE1=.\nDEAD1=_\n                 # Represent living and dead cells in the start-up file.\n\n#  -----------------------------------------------------#\n#  This script uses a 10 x 10 grid (may be increased,\n#+ but a large grid will slow down execution).\nROWS=10\nCOLS=10\n#  Change above two variables to match desired grid size.\n#  -----------------------------------------------------#\n\nGENERATIONS=10          #  How many generations to cycle through.\n                        #  Adjust this upwards\n                        #+ if you have time on your hands.\n\nNONE_ALIVE=85           #  Exit status on premature bailout,\n                        #+ if no cells left alive.\nDELAY=2                 #  Pause between generations.\nTRUE=0\nFALSE=1\nALIVE=0\nDEAD=1\n\navar=                   # Global; holds current generation.\ngeneration=0            # Initialize generation count.\n\n# =================================================================\n\nlet \"cells = $ROWS * $COLS\"   # How many cells.\n\n# Arrays containing \"cells.\"\ndeclare -a initial\ndeclare -a current\n\ndisplay ()\n{\n\nalive=0                 # How many cells alive at any given time.\n                        # Initially zero.\n\ndeclare -a arr\narr=( `echo \"$1\"` )     # Convert passed arg to array.\n\nelement_count=${#arr[*]}\n\nlocal i\nlocal rowcheck\n\nfor ((i=0; i<$element_count; i++))\ndo\n\n  # Insert newline at end of each row.\n  let \"rowcheck = $i % COLS\"\n  if [ \"$rowcheck\" -eq 0 ]\n  then\n    echo                # Newline.\n    echo -n \"      \"    # Indent.\n  fi  \n\n  cell=${arr[i]}\n\n  if [ \"$cell\" = . ]\n  then\n    let \"alive += 1\"\n  fi  \n\n  echo -n \"$cell\" &#124; sed -e 's/_/ /g'\n  # Print out array, changing underscores to spaces.\ndone  \n\nreturn\n\n}\n\nIsValid ()                            # Test if cell coordinate valid.\n{\n\n  if [ -z \"$1\"  -o -z \"$2\" ]          # Mandatory arguments missing?\n  then\n    return $FALSE\n  fi\n\nlocal row\nlocal lower_limit=0                   # Disallow negative coordinate.\nlocal upper_limit\nlocal left\nlocal right\n\nlet \"upper_limit = $ROWS * $COLS - 1\" # Total number of cells.\n\nif [ \"$1\" -lt \"$lower_limit\" -o \"$1\" -gt \"$upper_limit\" ]\nthen\n  return $FALSE                       # Out of array bounds.\nfi  \n\nrow=$2\nlet \"left = $row * $COLS\"             # Left limit.\nlet \"right = $left + $COLS - 1\"       # Right limit.\n\nif [ \"$1\" -lt \"$left\" -o \"$1\" -gt \"$right\" ]\nthen\n  return $FALSE                       # Beyond row boundary.\nfi  \n\nreturn $TRUE                          # Valid coordinate.\n\n}  \n\nIsAlive ()              #  Test whether cell is alive.\n                        #  Takes array, cell number, and\n{                       #+ state of cell as arguments.\n  GetCount \"$1\" $2      #  Get alive cell count in neighborhood.\n  local nhbd=$?\n\n  if [ \"$nhbd\" -eq \"$BIRTH\" ]  # Alive in any case.\n  then\n    return $ALIVE\n  fi\n\n  if [ \"$3\" = \".\" -a \"$nhbd\" -eq \"$SURVIVE\" ]\n  then                  # Alive only if previously alive.\n    return $ALIVE\n  fi  \n\n  return $DEAD          # Defaults to dead.\n\n}  \n\nGetCount ()             # Count live cells in passed cell's neighborhood.\n                        # Two arguments needed:\n\t\t\t# $1) variable holding array\n\t\t\t# $2) cell number\n{\n  local cell_number=$2\n  local array\n  local top\n  local center\n  local bottom\n  local r\n  local row\n  local i\n  local t_top\n  local t_cen\n  local t_bot\n  local count=0\n  local ROW_NHBD=3\n\n  array=( `echo \"$1\"` )\n\n  let \"top = $cell_number - $COLS - 1\"    # Set up cell neighborhood.\n  let \"center = $cell_number - 1\"\n  let \"bottom = $cell_number + $COLS - 1\"\n  let \"r = $cell_number / $COLS\"\n\n  for ((i=0; i<$ROW_NHBD; i++))           # Traverse from left to right. \n  do\n    let \"t_top = $top + $i\"\n    let \"t_cen = $center + $i\"\n    let \"t_bot = $bottom + $i\"\n\n    let \"row = $r\"                        # Count center row.\n    IsValid $t_cen $row                   # Valid cell position?\n    if [ $? -eq \"$TRUE\" ]\n    then\n      if [ ${array[$t_cen]} = \"$ALIVE1\" ] # Is it alive?\n      then                                # If yes, then ...\n        let \"count += 1\"                  # Increment count.\n      fi\t\n    fi  \n\n    let \"row = $r - 1\"                    # Count top row.          \n    IsValid $t_top $row\n    if [ $? -eq \"$TRUE\" ]\n    then\n      if [ ${array[$t_top]} = \"$ALIVE1\" ] # Redundancy here.\n      then                                # Can it be optimized?\n        let \"count += 1\"\n      fi\t\n    fi  \n\n    let \"row = $r + 1\"                    # Count bottom row.\n    IsValid $t_bot $row\n    if [ $? -eq \"$TRUE\" ]\n    then\n      if [ ${array[$t_bot]} = \"$ALIVE1\" ] \n      then\n        let \"count += 1\"\n      fi\t\n    fi  \n\n  done  \n\n  if [ ${array[$cell_number]} = \"$ALIVE1\" ]\n  then\n    let \"count -= 1\"        #  Make sure value of tested cell itself\n  fi                        #+ is not counted.\n\n  return $count\n\n}\n\nnext_gen ()               # Update generation array.\n{\n\nlocal array\nlocal i=0\n\narray=( `echo \"$1\"` )     # Convert passed arg to array.\n\nwhile [ \"$i\" -lt \"$cells\" ]\ndo\n  IsAlive \"$1\" $i ${array[$i]}   # Is the cell alive?\n  if [ $? -eq \"$ALIVE\" ]\n  then                           #  If alive, then\n    array[$i]=.                  #+ represent the cell as a period.\n  else  \n    array[$i]=\"_\"                #  Otherwise underscore\n   fi                            #+ (will later be converted to space).\n  let \"i += 1\" \ndone   \n\n#    let \"generation += 1\"       # Increment generation count.\n###  Why was the above line commented out?\n\n# Set variable to pass as parameter to \"display\" function.\navar=`echo ${array[@]}`   # Convert array back to string variable.\ndisplay \"$avar\"           # Display it.\necho; echo\necho \"Generation $generation  -  $alive alive\"\n\nif [ \"$alive\" -eq 0 ]\nthen\n  echo\n  echo \"Premature exit: no more cells alive!\"\n  exit $NONE_ALIVE        #  No point in continuing\nfi                        #+ if no live cells.\n\n}\n\n# =========================================================\n\n# main ()\n# {\n\n# Load initial array with contents of startup file.\ninitial=( `cat \"$startfile\" &#124; sed -e '/#/d' &#124; tr -d '\\n' &#124;\\\n# Delete lines containing '#' comment character.\n           sed -e 's/\\./\\. /g' -e 's/_/_ /g'` )\n# Remove linefeeds and insert space between elements.\n\nclear          # Clear screen.\n\necho #         Title\nsetterm -reverse on\necho \"=======================\"\nsetterm -reverse off\necho \"    $GENERATIONS generations\"\necho \"           of\"\necho \"\\\"Life in the Slow Lane\\\"\"\nsetterm -reverse on\necho \"=======================\"\nsetterm -reverse off\n\nsleep $DELAY   # Display \"splash screen\" for 2 seconds.\n\n# -------- Display first generation. --------\nGen0=`echo ${initial[@]}`\ndisplay \"$Gen0\"           # Display only.\necho; echo\necho \"Generation $generation  -  $alive alive\"\nsleep $DELAY\n# -------------------------------------------\n\nlet \"generation += 1\"     # Bump generation count.\necho\n\n# ------- Display second generation. -------\nCur=`echo ${initial[@]}`\nnext_gen \"$Cur\"          # Update & display.\nsleep $DELAY\n# ------------------------------------------\n\nlet \"generation += 1\"     # Increment generation count.\n\n# ------ Main loop for displaying subsequent generations ------\nwhile [ \"$generation\" -le \"$GENERATIONS\" ]\ndo\n  Cur=\"$avar\"\n  next_gen \"$Cur\"\n  let \"generation += 1\"\n  sleep $DELAY\ndone\n# ==============================================================\n\necho\n# }\n\nexit 0   # CEOF:EOF\n\n# The grid in this script has a \"boundary problem.\"\n# The the top, bottom, and sides border on a void of dead cells.\n# Exercise: Change the script to have the grid wrap around,\n# +         so that the left and right sides will \"touch,\"      \n# +         as will the top and bottom.\n#\n# Exercise: Create a new \"gen0\" file to seed this script.\n#           Use a 12 x 16 grid, instead of the original 10 x 10 one.\n#           Make the necessary changes to the script,\n#+          so it will run with the altered file.\n#\n# Exercise: Modify this script so that it can determine the grid size\n#+          from the \"gen0\" file, and set any variables necessary\n#+          for the script to run.\n#           This would make unnecessary any changes to variables\n#+          in the script for an altered grid size.\n#\n# Exercise: Optimize this script.\n#           It has redundant code.\n```", "```sh # gen0\n#\n# This is an example \"generation 0\" start-up file for \"life.sh\".\n# --------------------------------------------------------------\n#  The \"gen0\" file is a 10 x 10 grid using a period (.) for live cells,\n#+ and an underscore (_) for dead ones. We cannot simply use spaces\n#+ for dead cells in this file because of a peculiarity in Bash arrays.\n#  [Exercise for the reader: explain this.]\n#\n# Lines beginning with a '#' are comments, and the script ignores them.\n__.__..___\n__.._.____\n____.___..\n_._______.\n____._____\n..__...___\n____._____\n___...____\n__.._..___\n_..___..__\n```", "```sh #! /bin/sh\n#  Strips off the header from a mail/News message i.e. till the first\n#+ empty line.\n#  Author: Mark Moraes, University of Toronto\n\n# ==> These comments added by author of this document.\n\nif [ $# -eq 0 ]; then\n# ==> If no command-line args present, then works on file redirected to stdin.\n\tsed -e '1,/^$/d' -e '/^[ \t]*$/d'\n\t# --> Delete empty lines and all lines until \n\t# --> first one beginning with white space.\nelse\n# ==> If command-line args present, then work on files named.\n\tfor i do\n\t\tsed -e '1,/^$/d' -e '/^[ \t]*$/d' $i\n\t\t# --> Ditto, as above.\n\tdone\nfi\n\nexit\n\n# ==> Exercise: Add error checking and other options.\n# ==>\n# ==> Note that the small sed script repeats, except for the arg passed.\n# ==> Does it make sense to embed it in a function? Why or why not?\n\n/*\n * Copyright University of Toronto 1988, 1989.\n * Written by Mark Moraes\n *\n * Permission is granted to anyone to use this software for any purpose on\n * any computer system, and to alter it and redistribute it freely, subject\n * to the following restrictions:\n *\n * 1\\. The author and the University of Toronto are not responsible \n *    for the consequences of use of this software, no matter how awful, \n *    even if they arise from flaws in it.\n *\n * 2\\. The origin of this software must not be misrepresented, either by\n *    explicit claim or by omission.  Since few users ever read sources,\n *    credits must appear in the documentation.\n *\n * 3\\. Altered versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.  Since few users\n *    ever read sources, credits must appear in the documentation.\n *\n * 4\\. This notice may not be removed or altered.\n */\n```", "```sh #!/bin/bash\n#\n#\n#  Random password generator for Bash 2.x +\n#+ by Antek Sawicki <tenox@tenox.tc>,\n#+ who generously gave usage permission to the ABS Guide author.\n#\n# ==> Comments added by document author ==>\n\nMATRIX=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n# ==> Password will consist of alphanumeric characters.\nLENGTH=\"8\"\n# ==> May change 'LENGTH' for longer password.\n\nwhile [ \"${n:=1}\" -le \"$LENGTH\" ]\n# ==> Recall that := is \"default substitution\" operator.\n# ==> So, if 'n' has not been initialized, set it to 1.\ndo\n\tPASS=\"$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}\"\n\t# ==> Very clever, but tricky.\n\n\t# ==> Starting from the innermost nesting...\n\t# ==> ${#MATRIX} returns length of array MATRIX.\n\n\t# ==> $RANDOM%${#MATRIX} returns random number between 1\n\t# ==> and [length of MATRIX] - 1.\n\n\t# ==> ${MATRIX:$(($RANDOM%${#MATRIX})):1}\n\t# ==> returns expansion of MATRIX at random position, by length 1\\. \n\t# ==> See {var:pos:len} parameter substitution in Chapter 9.\n\t# ==> and the associated examples.\n\n\t# ==> PASS=... simply pastes this result onto previous PASS (concatenation).\n\n\t# ==> To visualize this more clearly, uncomment the following line\n\t#                 echo \"$PASS\"\n\t# ==> to see PASS being built up,\n\t# ==> one character at a time, each iteration of the loop.\n\n\tlet n+=1\n\t# ==> Increment 'n' for next pass.\ndone\n\necho \"$PASS\"      # ==> Or, redirect to a file, as desired.\n\nexit 0\n```", "```sh #!/bin/bash\n# ==> Script by James R. Van Zandt, and used here with his permission.\n\n# ==> Comments added by author of this document.\n\n  HERE=`uname -n`    # ==> hostname\n  THERE=bilbo\n  echo \"starting remote backup to $THERE at `date +%r`\"\n  # ==> `date +%r` returns time in 12-hour format, i.e. \"08:08:34 PM\".\n\n  # make sure /pipe really is a pipe and not a plain file\n  rm -rf /pipe\n  mkfifo /pipe       # ==> Create a \"named pipe\", named \"/pipe\" ...\n\n  # ==> 'su xyz' runs commands as user \"xyz\".\n  # ==> 'ssh' invokes secure shell (remote login client).\n  su xyz -c \"ssh $THERE \\\"cat > /home/xyz/backup/${HERE}-daily.tar.gz\\\" < /pipe\"&\n  cd /\n  tar -czf - bin boot dev etc home info lib man root sbin share usr var > /pipe\n  # ==> Uses named pipe, /pipe, to communicate between processes:\n  # ==> 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.\n\n  # ==> The end result is this backs up the main directories, from / on down.\n\n  # ==>  What are the advantages of a \"named pipe\" in this situation,\n  # ==>+ as opposed to an \"anonymous pipe\", with &#124;?\n  # ==>  Will an anonymous pipe even work here?\n\n  # ==>  Is it necessary to delete the pipe before exiting the script?\n  # ==>  How could that be done?\n\n  exit 0\n```", "```sh #!/bin/bash\n# primes.sh: Generate prime numbers, without using arrays.\n# Script contributed by Stephane Chazelas.\n\n#  This does *not* use the classic \"Sieve of Eratosthenes\" algorithm,\n#+ but instead the more intuitive method of testing each candidate number\n#+ for factors (divisors), using the \"%\" modulo operator.\n\nLIMIT=1000                    # Primes, 2 ... 1000.\n\nPrimes()\n{\n (( n = $1 + 1 ))             # Bump to next integer.\n shift                        # Next parameter in list.\n#  echo \"_n=$n i=$i_\"\n\n if (( n == LIMIT ))\n then echo $*\n return\n fi\n\n for i; do                    # \"i\" set to \"@\", previous values of $n.\n#   echo \"-n=$n i=$i-\"\n   (( i * i > n )) && break   # Optimization.\n   (( n % i )) && continue    # Sift out non-primes using modulo operator.\n   Primes $n $@               # Recursion inside loop.\n   return\n   done\n\n   Primes $n $@ $n            #  Recursion outside loop.\n                              #  Successively accumulate\n\t\t\t      #+ positional parameters.\n                              #  \"$@\" is the accumulating list of primes.\n}\n\nPrimes 1\n\nexit $?\n\n# Pipe output of the script to 'fmt' for prettier printing.\n\n#  Uncomment lines 16 and 24 to help figure out what is going on.\n\n#  Compare the speed of this algorithm for generating primes\n#+ with the Sieve of Eratosthenes (ex68.sh).\n\n#  Exercise: Rewrite this script without recursion.\n```", "```sh #!/bin/bash\n# tree.sh\n\n#  Written by Rick Boivie.\n#  Used with permission.\n#  This is a revised and simplified version of a script\n#+ by Jordi Sanfeliu (the original author), and patched by Ian Kjos.\n#  This script replaces the earlier version used in\n#+ previous releases of the Advanced Bash Scripting Guide.\n#  Copyright (c) 2002, by Jordi Sanfeliu, Rick Boivie, and Ian Kjos.\n\n# ==> Comments added by the author of this document.\n\nsearch () {\nfor dir in `echo *`\n#  ==> `echo *` lists all the files in current working directory,\n#+ ==> without line breaks.\n#  ==> Similar effect to for dir in *\n#  ==> but \"dir in `echo *`\" will not handle filenames with blanks.\ndo\n  if [ -d \"$dir\" ] ; then # ==> If it is a directory (-d)...\n  zz=0                    # ==> Temp variable, keeping track of\n                          #     directory level.\n  while [ $zz != $1 ]     # Keep track of inner nested loop.\n    do\n      echo -n \"&#124; \"        # ==> Display vertical connector symbol,\n                          # ==> with 2 spaces & no line feed\n                          #     in order to indent.\n      zz=`expr $zz + 1`   # ==> Increment zz.\n    done\n\n    if [ -L \"$dir\" ] ; then # ==> If directory is a symbolic link...\n      echo \"+---$dir\" `ls -l $dir &#124; sed 's/^.*'$dir' //'`\n      # ==> Display horiz. connector and list directory name, but...\n      # ==> delete date/time part of long listing.\n    else\n      echo \"+---$dir\"       # ==> Display horizontal connector symbol...\n      # ==> and print directory name.\n      numdirs=`expr $numdirs + 1` # ==> Increment directory count.\n      if cd \"$dir\" ; then         # ==> If can move to subdirectory...\n        search `expr $1 + 1`      # with recursion ;-)\n        # ==> Function calls itself.\n        cd ..\n      fi\n    fi\n  fi\ndone\n}\n\nif [ $# != 0 ] ; then\n  cd $1   # Move to indicated directory.\n  #else   # stay in current directory\nfi\n\necho \"Initial directory = `pwd`\"\nnumdirs=0\n\nsearch 0\necho \"Total directories = $numdirs\"\n\nexit 0\n```", "```sh #!/bin/bash\n# tree2.sh\n\n# Lightly modified/reformatted by ABS Guide author.\n# Included in ABS Guide with permission of script author (thanks!).\n\n## Recursive file/dirsize checking script, by Patsie\n##\n## This script builds a list of files/directories and their size (du -akx)\n## and processes this list to a human readable tree shape\n## The 'du -akx' is only as good as the permissions the owner has.\n## So preferably run as root* to get the best results, or use only on\n## directories for which you have read permissions. Anything you can't\n## read is not in the list.\n\n#* ABS Guide author advises caution when running scripts as root!\n\n##########  THIS IS CONFIGURABLE  ##########\n\nTOP=5                   # Top 5 biggest (sub)directories.\nMAXRECURS=5             # Max 5 subdirectories/recursions deep.\nE_BL=80                 # Blank line already returned.\nE_DIR=81                # Directory not specified.\n\n##########  DON'T CHANGE ANYTHING BELOW THIS LINE  ##########\n\nPID=$$                            # Our own process ID.\nSELF=`basename $0`                # Our own program name.\nTMP=\"/tmp/${SELF}.${PID}.tmp\"     # Temporary 'du' result.\n\n# Convert number to dotted thousand.\nfunction dot { echo \"            $*\" &#124;\n               sed -e :a -e 's/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta' &#124;\n               tail -c 12; }\n\n# Usage: tree <recursion> <indent prefix> <min size> <directory>\nfunction tree {\n  recurs=\"$1\"           # How deep nested are we?\n  prefix=\"$2\"           # What do we display before file/dirname?\n  minsize=\"$3\"          # What is the minumum file/dirsize?\n  dirname=\"$4\"          # Which directory are we checking?\n\n# Get ($TOP) biggest subdirs/subfiles from TMP file.\n  LIST=`egrep \"[[:space:]]${dirname}/[^/]*$\" \"$TMP\" &#124;\n        awk '{if($1>'$minsize') print;}' &#124; sort -nr &#124; head -$TOP`\n  [ -z \"$LIST\" ] && return        # Empty list, then go back.\n\n  cnt=0\n  num=`echo \"$LIST\" &#124; wc -l`      # How many entries in the list.\n\n  ## Main loop\n  echo \"$LIST\" &#124; while read size name; do\n    ((cnt+=1))\t\t          # Count entry number.\n    bname=`basename \"$name\"`      # We only need a basename of the entry.\n    [ -d \"$name\" ] && bname=\"$bname/\"\n                                  # If it's a directory, append a slash.\n    echo \"`dot $size`$prefix +-$bname\"\n                                  # Display the result.\n    #  Call ourself recursively if it's a directory\n    #+ and we're not nested too deep ($MAXRECURS).\n    #  The recursion goes up: $((recurs+1))\n    #  The prefix gets a space if it's the last entry,\n    #+ or a pipe if there are more entries.\n    #  The minimum file/dirsize becomes\n    #+ a tenth of his parent: $((size/10)).\n    # Last argument is the full directory name to check.\n    if [ -d \"$name\" -a $recurs -lt $MAXRECURS ]; then\n      [ $cnt -lt $num ] \\\n        &#124;&#124; (tree $((recurs+1)) \"$prefix  \" $((size/10)) \"$name\") \\\n        && (tree $((recurs+1)) \"$prefix &#124;\" $((size/10)) \"$name\")\n    fi\n  done\n\n  [ $? -eq 0 ] && echo \"           $prefix\"\n  # Every time we jump back add a 'blank' line.\n  return $E_BL\n  # We return 80 to tell we added a blank line already.\n}\n\n###                ###\n###  main program  ###\n###                ###\n\nrootdir=\"$@\"\n[ -d \"$rootdir\" ] &#124;&#124;\n  { echo \"$SELF: Usage: $SELF <directory>\" >&2; exit $E_DIR; }\n  # We should be called with a directory name.\n\necho \"Building inventory list, please wait ...\"\n     # Show \"please wait\" message.\ndu -akx \"$rootdir\" 1>\"$TMP\" 2>/dev/null\n     # Build a temporary list of all files/dirs and their size.\nsize=`tail -1 \"$TMP\" &#124; awk '{print $1}'`\n     # What is our rootdirectory's size?\necho \"`dot $size` $rootdir\"\n     # Display rootdirectory's entry.\ntree 0 \"\" 0 \"$rootdir\"\n     # Display the tree below our rootdirectory.\n\nrm \"$TMP\" 2>/dev/null\n     # Clean up TMP file.\n\nexit $?\n```", "```sh #!/bin/bash\n\n# string.bash --- bash emulation of string(3) library routines\n# Author: Noah Friedman <friedman@prep.ai.mit.edu>\n# ==>     Used with his kind permission in this document.\n# Created: 1992-07-01\n# Last modified: 1993-09-29\n# Public domain\n\n# Conversion to bash v2 syntax done by Chet Ramey\n\n# Commentary:\n# Code:\n\n#:docstring strcat:\n# Usage: strcat s1 s2\n#\n# Strcat appends the value of variable s2 to variable s1\\. \n#\n# Example:\n#    a=\"foo\"\n#    b=\"bar\"\n#    strcat a b\n#    echo $a\n#    => foobar\n#\n#:end docstring:\n\n###;;;autoload   ==> Autoloading of function commented out.\nfunction strcat ()\n{\n    local s1_val s2_val\n\n    s1_val=${!1}                        # indirect variable expansion\n    s2_val=${!2}\n    eval \"$1\"=\\'\"${s1_val}${s2_val}\"\\'\n    # ==> eval $1='${s1_val}${s2_val}' avoids problems,\n    # ==> if one of the variables contains a single quote.\n}\n\n#:docstring strncat:\n# Usage: strncat s1 s2 $n\n# \n# Line strcat, but strncat appends a maximum of n characters from the value\n# of variable s2\\.  It copies fewer if the value of variabl s2 is shorter\n# than n characters.  Echoes result on stdout.\n#\n# Example:\n#    a=foo\n#    b=barbaz\n#    strncat a b 3\n#    echo $a\n#    => foobar\n#\n#:end docstring:\n\n###;;;autoload\nfunction strncat ()\n{\n    local s1=\"$1\"\n    local s2=\"$2\"\n    local -i n=\"$3\"\n    local s1_val s2_val\n\n    s1_val=${!s1}                       # ==> indirect variable expansion\n    s2_val=${!s2}\n\n    if [ ${#s2_val} -gt ${n} ]; then\n       s2_val=${s2_val:0:$n}            # ==> substring extraction\n    fi\n\n    eval \"$s1\"=\\'\"${s1_val}${s2_val}\"\\'\n    # ==> eval $1='${s1_val}${s2_val}' avoids problems,\n    # ==> if one of the variables contains a single quote.\n}\n\n#:docstring strcmp:\n# Usage: strcmp $s1 $s2\n#\n# Strcmp compares its arguments and returns an integer less than, equal to,\n# or greater than zero, depending on whether string s1 is lexicographically\n# less than, equal to, or greater than string s2.\n#:end docstring:\n\n###;;;autoload\nfunction strcmp ()\n{\n    [ \"$1\" = \"$2\" ] && return 0\n\n    [ \"${1}\" '<' \"${2}\" ] > /dev/null && return -1\n\n    return 1\n}\n\n#:docstring strncmp:\n# Usage: strncmp $s1 $s2 $n\n# \n# Like strcmp, but makes the comparison by examining a maximum of n\n# characters (n less than or equal to zero yields equality).\n#:end docstring:\n\n###;;;autoload\nfunction strncmp ()\n{\n    if [ -z \"${3}\" -o \"${3}\" -le \"0\" ]; then\n       return 0\n    fi\n\n    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then\n       strcmp \"$1\" \"$2\"\n       return $?\n    else\n       s1=${1:0:$3}\n       s2=${2:0:$3}\n       strcmp $s1 $s2\n       return $?\n    fi\n}\n\n#:docstring strlen:\n# Usage: strlen s\n#\n# Strlen returns the number of characters in string literal s.\n#:end docstring:\n\n###;;;autoload\nfunction strlen ()\n{\n    eval echo \"\\${#${1}}\"\n    # ==> Returns the length of the value of the variable\n    # ==> whose name is passed as an argument.\n}\n\n#:docstring strspn:\n# Usage: strspn $s1 $s2\n# \n# Strspn returns the length of the maximum initial segment of string s1,\n# which consists entirely of characters from string s2.\n#:end docstring:\n\n###;;;autoload\nfunction strspn ()\n{\n    # Unsetting IFS allows whitespace to be handled as normal chars. \n    local IFS=\n    local result=\"${1%%[!${2}]*}\"\n\n    echo ${#result}\n}\n\n#:docstring strcspn:\n# Usage: strcspn $s1 $s2\n#\n# Strcspn returns the length of the maximum initial segment of string s1,\n# which consists entirely of characters not from string s2.\n#:end docstring:\n\n###;;;autoload\nfunction strcspn ()\n{\n    # Unsetting IFS allows whitspace to be handled as normal chars. \n    local IFS=\n    local result=\"${1%%[${2}]*}\"\n\n    echo ${#result}\n}\n\n#:docstring strstr:\n# Usage: strstr s1 s2\n# \n# Strstr echoes a substring starting at the first occurrence of string s2 in\n# string s1, or nothing if s2 does not occur in the string.  If s2 points to\n# a string of zero length, strstr echoes s1.\n#:end docstring:\n\n###;;;autoload\nfunction strstr ()\n{\n    # if s2 points to a string of zero length, strstr echoes s1\n    [ ${#2} -eq 0 ] && { echo \"$1\" ; return 0; }\n\n    # strstr echoes nothing if s2 does not occur in s1\n    case \"$1\" in\n    *$2*) ;;\n    *) return 1;;\n    esac\n\n    # use the pattern matching code to strip off the match and everything\n    # following it\n    first=${1/$2*/}\n\n    # then strip off the first unmatched portion of the string\n    echo \"${1##$first}\"\n}\n\n#:docstring strtok:\n# Usage: strtok s1 s2\n#\n# Strtok considers the string s1 to consist of a sequence of zero or more\n# text tokens separated by spans of one or more characters from the\n# separator string s2\\.  The first call (with a non-empty string s1\n# specified) echoes a string consisting of the first token on stdout. The\n# function keeps track of its position in the string s1 between separate\n# calls, so that subsequent calls made with the first argument an empty\n# string will work through the string immediately following that token.  In\n# this way subsequent calls will work through the string s1 until no tokens\n# remain.  The separator string s2 may be different from call to call.\n# When no token remains in s1, an empty value is echoed on stdout.\n#:end docstring:\n\n###;;;autoload\nfunction strtok ()\n{\n :\n}\n\n#:docstring strtrunc:\n# Usage: strtrunc $n $s1 {$s2} {$...}\n#\n# Used by many functions like strncmp to truncate arguments for comparison.\n# Echoes the first n characters of each string s1 s2 ... on stdout. \n#:end docstring:\n\n###;;;autoload\nfunction strtrunc ()\n{\n    n=$1 ; shift\n    for z; do\n        echo \"${z:0:$n}\"\n    done\n}\n\n# provide string\n\n# string.bash ends here\n\n# ========================================================================== #\n# ==> Everything below here added by the document author.\n\n# ==> Suggested use of this script is to delete everything below here,\n# ==> and \"source\" this file into your own scripts.\n\n# strcat\nstring0=one\nstring1=two\necho\necho \"Testing \\\"strcat\\\" function:\"\necho \"Original \\\"string0\\\" = $string0\"\necho \"\\\"string1\\\" = $string1\"\nstrcat string0 string1\necho \"New \\\"string0\\\" = $string0\"\necho\n\n# strlen\necho\necho \"Testing \\\"strlen\\\" function:\"\nstr=123456789\necho \"\\\"str\\\" = $str\"\necho -n \"Length of \\\"str\\\" = \"\nstrlen str\necho\n\n# Exercise:\n# --------\n# Add code to test all the other string functions above.\n\nexit 0\n```", "```sh #! /bin/bash\n# directory-info.sh\n# Parses and lists directory information.\n\n# NOTE: Change lines 273 and 353 per \"README\" file.\n\n# Michael Zick is the author of this script.\n# Used here with his permission.\n\n# Controls\n# If overridden by command arguments, they must be in the order:\n#   Arg1: \"Descriptor Directory\"\n#   Arg2: \"Exclude Paths\"\n#   Arg3: \"Exclude Directories\"\n#\n# Environment Settings override Defaults.\n# Command arguments override Environment Settings.\n\n# Default location for content addressed file descriptors.\nMD5UCFS=${1:-${MD5UCFS:-'/tmpfs/ucfs'}}\n\n# Directory paths never to list or enter\ndeclare -a \\\n  EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-'(/proc /dev /devfs /tmpfs)'}}\n\n# Directories never to list or enter\ndeclare -a \\\n  EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-'(ucfs lost+found tmp wtmp)'}}\n\n# Files never to list or enter\ndeclare -a \\\n  EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-'(core \"Name with Spaces\")'}}\n\n# Here document used as a comment block.\n: <<LSfieldsDoc\n# # # # # List Filesystem Directory Information # # # # #\n#\n#\tListDirectory \"FileGlob\" \"Field-Array-Name\"\n# or\n#\tListDirectory -of \"FileGlob\" \"Field-Array-Filename\"\n#\t'-of' meaning 'output to filename'\n# # # # #\n\nString format description based on: ls (GNU fileutils) version 4.0.36\n\nProduces a line (or more) formatted:\ninode permissions hard-links owner group ...\n32736 -rw-------    1 mszick   mszick\n\nsize    day month date hh:mm:ss year path\n2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core\n\nUnless it is formatted:\ninode permissions hard-links owner group ...\n266705 crw-rw----    1    root  uucp\n\nmajor minor day month date hh:mm:ss year path\n4,  68 Sun Apr 20 09:27:33 2003 /dev/ttyS4\nNOTE: that pesky comma after the major number\n\nNOTE: the 'path' may be multiple fields:\n/home/mszick/core\n/proc/982/fd/0 -> /dev/null\n/proc/982/fd/1 -> /home/mszick/.xsession-errors\n/proc/982/fd/13 -> /tmp/tmpfZVVOCs (deleted)\n/proc/982/fd/7 -> /tmp/kde-mszick/ksycoca\n/proc/982/fd/8 -> socket:[11586]\n/proc/982/fd/9 -> pipe:[11588]\n\nIf that isn't enough to keep your parser guessing,\neither or both of the path components may be relative:\n../Built-Shared -> Built-Static\n../linux-2.4.20.tar.bz2 -> ../../../SRCS/linux-2.4.20.tar.bz2\n\nThe first character of the 11 (10?) character permissions field:\n's' Socket\n'd' Directory\n'b' Block device\n'c' Character device\n'l' Symbolic link\nNOTE: Hard links not marked - test for identical inode numbers\non identical filesystems.\nAll information about hard linked files are shared, except\nfor the names and the name's location in the directory system.\nNOTE: A \"Hard link\" is known as a \"File Alias\" on some systems.\n'-' An undistingushed file\n\nFollowed by three groups of letters for: User, Group, Others\nCharacter 1: '-' Not readable; 'r' Readable\nCharacter 2: '-' Not writable; 'w' Writable\nCharacter 3, User and Group: Combined execute and special\n'-' Not Executable, Not Special\n'x' Executable, Not Special\n's' Executable, Special\n'S' Not Executable, Special\nCharacter 3, Others: Combined execute and sticky (tacky?)\n'-' Not Executable, Not Tacky\n'x' Executable, Not Tacky\n't' Executable, Tacky\n'T' Not Executable, Tacky\n\nFollowed by an access indicator\nHaven't tested this one, it may be the eleventh character\nor it may generate another field\n' ' No alternate access\n'+' Alternate access\nLSfieldsDoc\n\nListDirectory()\n{\n\tlocal -a T\n\tlocal -i of=0\t\t# Default return in variable\n#\tOLD_IFS=$IFS\t\t# Using BASH default ' \\t\\n'\n\n\tcase \"$#\" in\n\t3)\tcase \"$1\" in\n\t\t-of)\tof=1 ; shift ;;\n\t\t * )\treturn 1 ;;\n\t\tesac ;;\n\t2)\t: ;;\t\t# Poor man's \"continue\"\n\t*)\treturn 1 ;;\n\tesac\n\n\t# NOTE: the (ls) command is NOT quoted (\")\n\tT=( $(ls --inode --ignore-backups --almost-all --directory \\\n\t--full-time --color=none --time=status --sort=none \\\n\t--format=long $1) )\n\n\tcase $of in\n\t# Assign T back to the array whose name was passed as $2\n\t\t0) eval $2=\\( \\\"\\$\\{T\\[@\\]\\}\\\" \\) ;;\n\t# Write T into filename passed as $2\n\t\t1) echo \"${T[@]}\" > \"$2\" ;;\n\tesac\n\treturn 0\n   }\n\n# # # # # Is that string a legal number? # # # # #\n#\n#\tIsNumber \"Var\"\n# # # # # There has to be a better way, sigh...\n\nIsNumber()\n{\n\tlocal -i int\n\tif [ $# -eq 0 ]\n\tthen\n\t\treturn 1\n\telse\n\t\t(let int=$1)  2>/dev/null\n\t\treturn $?\t# Exit status of the let thread\n\tfi\n}\n\n# # # # # Index Filesystem Directory Information # # # # #\n#\n#\tIndexList \"Field-Array-Name\" \"Index-Array-Name\"\n# or\n#\tIndexList -if Field-Array-Filename Index-Array-Name\n#\tIndexList -of Field-Array-Name Index-Array-Filename\n#\tIndexList -if -of Field-Array-Filename Index-Array-Filename\n# # # # #\n\n: <<IndexListDoc\nWalk an array of directory fields produced by ListDirectory\n\nHaving suppressed the line breaks in an otherwise line oriented\nreport, build an index to the array element which starts each line.\n\nEach line gets two index entries, the first element of each line\n(inode) and the element that holds the pathname of the file.\n\nThe first index entry pair (Line-Number==0) are informational:\nIndex-Array-Name[0] : Number of \"Lines\" indexed\nIndex-Array-Name[1] : \"Current Line\" pointer into Index-Array-Name\n\nThe following index pairs (if any) hold element indexes into\nthe Field-Array-Name per:\nIndex-Array-Name[Line-Number * 2] : The \"inode\" field element.\nNOTE: This distance may be either +11 or +12 elements.\nIndex-Array-Name[(Line-Number * 2) + 1] : The \"pathname\" element.\nNOTE: This distance may be a variable number of elements.\nNext line index pair for Line-Number+1.\nIndexListDoc\n\nIndexList()\n{\n\tlocal -a LIST\t\t\t# Local of listname passed\n\tlocal -a -i INDEX=( 0 0 )\t# Local of index to return\n\tlocal -i Lidx Lcnt\n\tlocal -i if=0 of=0\t\t# Default to variable names\n\n\tcase \"$#\" in\t\t\t# Simplistic option testing\n\t\t0) return 1 ;;\n\t\t1) return 1 ;;\n\t\t2) : ;;\t\t\t# Poor man's continue\n\t\t3) case \"$1\" in\n\t\t\t-if) if=1 ;;\n\t\t\t-of) of=1 ;;\n\t\t\t * ) return 1 ;;\n\t\t   esac ; shift ;;\n\t\t4) if=1 ; of=1 ; shift ; shift ;;\n\t\t*) return 1\n\tesac\n\n\t# Make local copy of list\n\tcase \"$if\" in\n\t\t0) eval LIST=\\( \\\"\\$\\{$1\\[@\\]\\}\\\" \\) ;;\n\t\t1) LIST=( $(cat $1) ) ;;\n\tesac\n\n\t# Grok (grope?) the array\n\tLcnt=${#LIST[@]}\n\tLidx=0\n\tuntil (( Lidx >= Lcnt ))\n\tdo\n\tif IsNumber ${LIST[$Lidx]}\n\tthen\n\t\tlocal -i inode name\n\t\tlocal ft\n\t\tinode=Lidx\n\t\tlocal m=${LIST[$Lidx+2]}\t# Hard Links field\n\t\tft=${LIST[$Lidx+1]:0:1} \t# Fast-Stat\n\t\tcase $ft in\n\t\tb)\t((Lidx+=12)) ;;\t\t# Block device\n\t\tc)\t((Lidx+=12)) ;;\t\t# Character device\n\t\t*)\t((Lidx+=11)) ;;\t\t# Anything else\n\t\tesac\n\t\tname=Lidx\n\t\tcase $ft in\n\t\t-)\t((Lidx+=1)) ;;\t\t# The easy one\n\t\tb)\t((Lidx+=1)) ;;\t\t# Block device\n\t\tc)\t((Lidx+=1)) ;;\t\t# Character device\n\t\td)\t((Lidx+=1)) ;;\t\t# The other easy one\n\t\tl)\t((Lidx+=3)) ;;\t\t# At LEAST two more fields\n#  A little more elegance here would handle pipes,\n#+ sockets, deleted files - later.\n\t\t*)\tuntil IsNumber ${LIST[$Lidx]} &#124;&#124; ((Lidx >= Lcnt))\n\t\t\tdo\n\t\t\t\t((Lidx+=1))\n\t\t\tdone\n\t\t\t;;\t\t\t# Not required\n\t\tesac\n\t\tINDEX[${#INDEX[*]}]=$inode\n\t\tINDEX[${#INDEX[*]}]=$name\n\t\tINDEX[0]=${INDEX[0]}+1\t\t# One more \"line\" found\n# echo \"Line: ${INDEX[0]} Type: $ft Links: $m Inode: \\\n# ${LIST[$inode]} Name: ${LIST[$name]}\"\n\n\telse\n\t\t((Lidx+=1))\n\tfi\n\tdone\n\tcase \"$of\" in\n\t\t0) eval $2=\\( \\\"\\$\\{INDEX\\[@\\]\\}\\\" \\) ;;\n\t\t1) echo \"${INDEX[@]}\" > \"$2\" ;;\n\tesac\n\treturn 0\t\t\t\t# What could go wrong?\n}\n\n# # # # # Content Identify File # # # # #\n#\n#\tDigestFile Input-Array-Name Digest-Array-Name\n# or\n#\tDigestFile -if Input-FileName Digest-Array-Name\n# # # # #\n\n# Here document used as a comment block.\n: <<DigestFilesDoc\n\nThe key (no pun intended) to a Unified Content File System (UCFS)\nis to distinguish the files in the system based on their content.\nDistinguishing files by their name is just so 20th Century.\n\nThe content is distinguished by computing a checksum of that content.\nThis version uses the md5sum program to generate a 128 bit checksum\nrepresentative of the file's contents.\nThere is a chance that two files having different content might\ngenerate the same checksum using md5sum (or any checksum).  Should\nthat become a problem, then the use of md5sum can be replace by a\ncyrptographic signature.  But until then...\n\nThe md5sum program is documented as outputting three fields (and it\ndoes), but when read it appears as two fields (array elements).  This\nis caused by the lack of whitespace between the second and third field.\nSo this function gropes the md5sum output and returns:\n\t[0]\t32 character checksum in hexidecimal (UCFS filename)\n\t[1]\tSingle character: ' ' text file, '*' binary file\n\t[2]\tFilesystem (20th Century Style) name\n\tNote: That name may be the character '-' indicating STDIN read.\n\nDigestFilesDoc\n\nDigestFile()\n{\n\tlocal if=0\t\t# Default, variable name\n\tlocal -a T1 T2\n\n\tcase \"$#\" in\n\t3)\tcase \"$1\" in\n\t\t-if)\tif=1 ; shift ;;\n\t\t * )\treturn 1 ;;\n\t\tesac ;;\n\t2)\t: ;;\t\t# Poor man's \"continue\"\n\t*)\treturn 1 ;;\n\tesac\n\n\tcase $if in\n\t0) eval T1=\\( \\\"\\$\\{$1\\[@\\]\\}\\\" \\)\n\t   T2=( $(echo ${T1[@]} &#124; md5sum -) )\n\t   ;;\n\t1) T2=( $(md5sum $1) )\n\t   ;;\n\tesac\n\n\tcase ${#T2[@]} in\n\t0) return 1 ;;\n\t1) return 1 ;;\n\t2) case ${T2[1]:0:1} in\t\t# SanScrit-2.0.5\n\t   \\*) T2[${#T2[@]}]=${T2[1]:1}\n\t       T2[1]=\\*\n\t       ;;\n\t    *) T2[${#T2[@]}]=${T2[1]}\n\t       T2[1]=\" \"\n\t       ;;\n\t   esac\n\t   ;;\n\t3) : ;; # Assume it worked\n\t*) return 1 ;;\n\tesac\n\n\tlocal -i len=${#T2[0]}\n\tif [ $len -ne 32 ] ; then return 1 ; fi\n\teval $2=\\( \\\"\\$\\{T2\\[@\\]\\}\\\" \\)\n}\n\n# # # # # Locate File # # # # #\n#\n#\tLocateFile [-l] FileName Location-Array-Name\n# or\n#\tLocateFile [-l] -of FileName Location-Array-FileName\n# # # # #\n\n# A file location is Filesystem-id and inode-number\n\n# Here document used as a comment block.\n: <<StatFieldsDoc\n\tBased on stat, version 2.2\n\tstat -t and stat -lt fields\n\t[0]\tname\n\t[1]\tTotal size\n\t\tFile - number of bytes\n\t\tSymbolic link - string length of pathname\n\t[2]\tNumber of (512 byte) blocks allocated\n\t[3]\tFile type and Access rights (hex)\n\t[4]\tUser ID of owner\n\t[5]\tGroup ID of owner\n\t[6]\tDevice number\n\t[7]\tInode number\n\t[8]\tNumber of hard links\n\t[9]\tDevice type (if inode device) Major\n\t[10]\tDevice type (if inode device) Minor\n\t[11]\tTime of last access\n\t\tMay be disabled in 'mount' with noatime\n\t\tatime of files changed by exec, read, pipe, utime, mknod (mmap?)\n\t\tatime of directories changed by addition/deletion of files\n\t[12]\tTime of last modification\n\t\tmtime of files changed by write, truncate, utime, mknod\n\t\tmtime of directories changed by addtition/deletion of files\n\t[13]\tTime of last change\n\t\tctime reflects time of changed inode information (owner, group\n\t\tpermissions, link count\n-*-*- Per:\n\tReturn code: 0\n\tSize of array: 14\n\tContents of array\n\tElement 0: /home/mszick\n\tElement 1: 4096\n\tElement 2: 8\n\tElement 3: 41e8\n\tElement 4: 500\n\tElement 5: 500\n\tElement 6: 303\n\tElement 7: 32385\n\tElement 8: 22\n\tElement 9: 0\n\tElement 10: 0\n\tElement 11: 1051221030\n\tElement 12: 1051214068\n\tElement 13: 1051214068\n\n\tFor a link in the form of linkname -> realname\n\tstat -t  linkname returns the linkname (link) information\n\tstat -lt linkname returns the realname information\n\n\tstat -tf and stat -ltf fields\n\t[0]\tname\n\t[1]\tID-0?\t\t# Maybe someday, but Linux stat structure\n\t[2]\tID-0?\t\t# does not have either LABEL nor UUID\n\t\t\t\t# fields, currently information must come\n\t\t\t\t# from file-system specific utilities\n\tThese will be munged into:\n\t[1]\tUUID if possible\n\t[2]\tVolume Label if possible\n\tNote: 'mount -l' does return the label and could return the UUID\n\n\t[3]\tMaximum length of filenames\n\t[4]\tFilesystem type\n\t[5]\tTotal blocks in the filesystem\n\t[6]\tFree blocks\n\t[7]\tFree blocks for non-root user(s)\n\t[8]\tBlock size of the filesystem\n\t[9]\tTotal inodes\n\t[10]\tFree inodes\n\n-*-*- Per:\n\tReturn code: 0\n\tSize of array: 11\n\tContents of array\n\tElement 0: /home/mszick\n\tElement 1: 0\n\tElement 2: 0\n\tElement 3: 255\n\tElement 4: ef53\n\tElement 5: 2581445\n\tElement 6: 2277180\n\tElement 7: 2146050\n\tElement 8: 4096\n\tElement 9: 1311552\n\tElement 10: 1276425\n\nStatFieldsDoc\n\n#\tLocateFile [-l] FileName Location-Array-Name\n#\tLocateFile [-l] -of FileName Location-Array-FileName\n\nLocateFile()\n{\n\tlocal -a LOC LOC1 LOC2\n\tlocal lk=\"\" of=0\n\n\tcase \"$#\" in\n\t0) return 1 ;;\n\t1) return 1 ;;\n\t2) : ;;\n\t*) while (( \"$#\" > 2 ))\n\t   do\n\t      case \"$1\" in\n\t       -l) lk=-1 ;;\n\t      -of) of=1 ;;\n\t        *) return 1 ;;\n\t      esac\n\t   shift\n           done ;;\n\tesac\n\n# More Sanscrit-2.0.5\n      # LOC1=( $(stat -t $lk $1) )\n      # LOC2=( $(stat -tf $lk $1) )\n      # Uncomment above two lines if system has \"stat\" command installed.\n\tLOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}\n\t      ${LOC2[@]:1:2} ${LOC2[@]:4:1} )\n\n\tcase \"$of\" in\n\t\t0) eval $2=\\( \\\"\\$\\{LOC\\[@\\]\\}\\\" \\) ;;\n\t\t1) echo \"${LOC[@]}\" > \"$2\" ;;\n\tesac\n\treturn 0\n# Which yields (if you are lucky, and have \"stat\" installed)\n# -*-*- Location Discriptor -*-*-\n#\tReturn code: 0\n#\tSize of array: 15\n#\tContents of array\n#\tElement 0: /home/mszick\t\t20th Century name\n#\tElement 1: 41e8\t\t\tType and Permissions\n#\tElement 2: 500\t\t\tUser\n#\tElement 3: 500\t\t\tGroup\n#\tElement 4: 303\t\t\tDevice\n#\tElement 5: 32385\t\tinode\n#\tElement 6: 22\t\t\tLink count\n#\tElement 7: 0\t\t\tDevice Major\n#\tElement 8: 0\t\t\tDevice Minor\n#\tElement 9: 1051224608\t\tLast Access\n#\tElement 10: 1051214068\t\tLast Modify\n#\tElement 11: 1051214068\t\tLast Status\n#\tElement 12: 0\t\t\tUUID (to be)\n#\tElement 13: 0\t\t\tVolume Label (to be)\n#\tElement 14: ef53\t\tFilesystem type\n}\n\n# And then there was some test code\n\nListArray() # ListArray Name\n{\n\tlocal -a Ta\n\n\teval Ta=\\( \\\"\\$\\{$1\\[@\\]\\}\\\" \\)\n\techo\n\techo \"-*-*- List of Array -*-*-\"\n\techo \"Size of array $1: ${#Ta[*]}\"\n\techo \"Contents of array $1:\"\n\tfor (( i=0 ; i<${#Ta[*]} ; i++ ))\n\tdo\n\t    echo -e \"\\tElement $i: ${Ta[$i]}\"\n\tdone\n\treturn 0\n}\n\ndeclare -a CUR_DIR\n# For small arrays\nListDirectory \"${PWD}\" CUR_DIR\nListArray CUR_DIR\n\ndeclare -a DIR_DIG\nDigestFile CUR_DIR DIR_DIG\necho \"The new \\\"name\\\" (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}\"\n\ndeclare -a DIR_ENT\n# BIG_DIR # For really big arrays - use a temporary file in ramdisk\n# BIG-DIR # ListDirectory -of \"${CUR_DIR[11]}/*\" \"/tmpfs/junk2\"\nListDirectory \"${CUR_DIR[11]}/*\" DIR_ENT\n\ndeclare -a DIR_IDX\n# BIG-DIR # IndexList -if \"/tmpfs/junk2\" DIR_IDX\nIndexList DIR_ENT DIR_IDX\n\ndeclare -a IDX_DIG\n# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )\n# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG\nDigestFile DIR_ENT IDX_DIG\n# Small (should) be able to parallize IndexList & DigestFile\n# Large (should) be able to parallize IndexList & DigestFile & the assignment\necho \"The \\\"name\\\" (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}\"\n\ndeclare -a FILE_LOC\nLocateFile ${PWD} FILE_LOC\nListArray FILE_LOC\n\nexit 0\n```", "```sh # Hash:\n# Hash function library\n# Author: Mariusz Gniazdowski <mariusz.gn-at-gmail.com>\n# Date: 2005-04-07\n\n# Functions making emulating hashes in Bash a little less painful.\n\n#    Limitations:\n#  * Only global variables are supported.\n#  * Each hash instance generates one global variable per value.\n#  * Variable names collisions are possible\n#+   if you define variable like __hash__hashname_key\n#  * Keys must use chars that can be part of a Bash variable name\n#+   (no dashes, periods, etc.).\n#  * The hash is created as a variable:\n#    ... hashname_keyname\n#    So if somone will create hashes like:\n#      myhash_ + mykey = myhash__mykey\n#      myhash + _mykey = myhash__mykey\n#    Then there will be a collision.\n#    (This should not pose a major problem.)\n\nHash_config_varname_prefix=__hash__\n\n# Emulates:  hash[key]=value\n#\n# Params:\n# 1 - hash\n# 2 - key\n# 3 - value\nfunction hash_set {\n\teval \"${Hash_config_varname_prefix}${1}_${2}=\\\"${3}\\\"\"\n}\n\n# Emulates:  value=hash[key]\n#\n# Params:\n# 1 - hash\n# 2 - key\n# 3 - value (name of global variable to set)\nfunction hash_get_into {\n\teval \"$3=\\\"\\$${Hash_config_varname_prefix}${1}_${2}\\\"\"\n}\n\n# Emulates:  echo hash[key]\n#\n# Params:\n# 1 - hash\n# 2 - key\n# 3 - echo params (like -n, for example)\nfunction hash_echo {\n\teval \"echo $3 \\\"\\$${Hash_config_varname_prefix}${1}_${2}\\\"\"\n}\n\n# Emulates:  hash1[key1]=hash2[key2]\n#\n# Params:\n# 1 - hash1\n# 2 - key1\n# 3 - hash2\n# 4 - key2\nfunction hash_copy {\neval \"${Hash_config_varname_prefix}${1}_${2}\\\n=\\\"\\$${Hash_config_varname_prefix}${3}_${4}\\\"\"\n}\n\n# Emulates:  hash[keyN-1]=hash[key2]=...hash[key1]\n#\n# Copies first key to rest of keys.\n#\n# Params:\n# 1 - hash1\n# 2 - key1\n# 3 - key2\n# . . .\n# N - keyN\nfunction hash_dup {\n  local hashName=\"$1\" keyName=\"$2\"\n  shift 2\n  until [ ${#} -le 0 ]; do\n    eval \"${Hash_config_varname_prefix}${hashName}_${1}\\\n=\\\"\\$${Hash_config_varname_prefix}${hashName}_${keyName}\\\"\"\n  shift;\n  done;\n}\n\n# Emulates:  unset hash[key]\n#\n# Params:\n# 1 - hash\n# 2 - key\nfunction hash_unset {\n\teval \"unset ${Hash_config_varname_prefix}${1}_${2}\"\n}\n\n# Emulates something similar to:  ref=&hash[key]\n#\n# The reference is name of the variable in which value is held.\n#\n# Params:\n# 1 - hash\n# 2 - key\n# 3 - ref - Name of global variable to set.\nfunction hash_get_ref_into {\n\teval \"$3=\\\"${Hash_config_varname_prefix}${1}_${2}\\\"\"\n}\n\n# Emulates something similar to:  echo &hash[key]\n#\n# That reference is name of variable in which value is held.\n#\n# Params:\n# 1 - hash\n# 2 - key\n# 3 - echo params (like -n for example)\nfunction hash_echo_ref {\n\teval \"echo $3 \\\"${Hash_config_varname_prefix}${1}_${2}\\\"\"\n}\n\n# Emulates something similar to:  $$hash[key](param1, param2, ...)\n#\n# Params:\n# 1 - hash\n# 2 - key\n# 3,4, ... - Function parameters\nfunction hash_call {\n  local hash key\n  hash=$1\n  key=$2\n  shift 2\n  eval \"eval \\\"\\$${Hash_config_varname_prefix}${hash}_${key} \\\\\\\"\\\\\\$@\\\\\\\"\\\"\"\n}\n\n# Emulates something similar to:  isset(hash[key]) or hash[key]==NULL\n#\n# Params:\n# 1 - hash\n# 2 - key\n# Returns:\n# 0 - there is such key\n# 1 - there is no such key\nfunction hash_is_set {\n  eval \"if [[ \\\"\\${${Hash_config_varname_prefix}${1}_${2}-a}\\\" = \\\"a\\\" && \n  \\\"\\${${Hash_config_varname_prefix}${1}_${2}-b}\\\" = \\\"b\\\" ]]\n    then return 1; else return 0; fi\"\n}\n\n# Emulates something similar to:\n#   foreach($hash as $key => $value) { fun($key,$value); }\n#\n# It is possible to write different variations of this function.\n# Here we use a function call to make it as \"generic\" as possible.\n#\n# Params:\n# 1 - hash\n# 2 - function name\nfunction hash_foreach {\n  local keyname oldIFS=\"$IFS\"\n  IFS=' '\n  for i in $(eval \"echo \\${!${Hash_config_varname_prefix}${1}_*}\"); do\n    keyname=$(eval \"echo \\${i##${Hash_config_varname_prefix}${1}_}\")\n    eval \"$2 $keyname \\\"\\$$i\\\"\"\n  done\nIFS=\"$oldIFS\"\n}\n\n#  NOTE: In lines 103 and 116, ampersand changed.\n#  But, it doesn't matter, because these are comment lines anyhow.\n```", "```sh #!/bin/bash\n# hash-example.sh: Colorizing text.\n# Author: Mariusz Gniazdowski <mariusz.gn-at-gmail.com>\n\n. Hash.lib      # Load the library of functions.\n\nhash_set colors red          \"\\033[0;31m\"\nhash_set colors blue         \"\\033[0;34m\"\nhash_set colors light_blue   \"\\033[1;34m\"\nhash_set colors light_red    \"\\033[1;31m\"\nhash_set colors cyan         \"\\033[0;36m\"\nhash_set colors light_green  \"\\033[1;32m\"\nhash_set colors light_gray   \"\\033[0;37m\"\nhash_set colors green        \"\\033[0;32m\"\nhash_set colors yellow       \"\\033[1;33m\"\nhash_set colors light_purple \"\\033[1;35m\"\nhash_set colors purple       \"\\033[0;35m\"\nhash_set colors reset_color  \"\\033[0;00m\"\n\n# $1 - keyname\n# $2 - value\ntry_colors() {\n\techo -en \"$2\"\n\techo \"This line is $1.\"\n}\nhash_foreach colors try_colors\nhash_echo colors reset_color -en\n\necho -e '\\nLet us overwrite some colors with yellow.\\n'\n# It's hard to read yellow text on some terminals.\nhash_dup colors yellow   red light_green blue green light_gray cyan\nhash_foreach colors try_colors\nhash_echo colors reset_color -en\n\necho -e '\\nLet us delete them and try colors once more . . .\\n'\n\nfor i in red light_green blue green light_gray cyan; do\n\thash_unset colors $i\ndone\nhash_foreach colors try_colors\nhash_echo colors reset_color -en\n\nhash_set other txt \"Other examples . . .\"\nhash_echo other txt\nhash_get_into other txt text\necho $text\n\nhash_set other my_fun try_colors\nhash_call other my_fun   purple \"`hash_echo colors purple`\"\nhash_echo colors reset_color -en\n\necho; echo \"Back to normal?\"; echo\n\nexit $?\n\n#  On some terminals, the \"light\" colors print in bold,\n#  and end up looking darker than the normal ones.\n#  Why is this?\n```", "```sh #!/bin/bash\n# $Id: ha.sh,v 1.2 2005/04/21 23:24:26 oliver Exp $\n# Copyright 2005 Oliver Beckstein\n# Released under the GNU Public License\n# Author of script granted permission for inclusion in ABS Guide.\n# (Thank you!)\n\n#----------------------------------------------------------------\n# pseudo hash based on indirect parameter expansion\n# API: access through functions:\n# \n# create the hash:\n#  \n#      newhash Lovers\n#\n# add entries (note single quotes for spaces)\n#    \n#      addhash Lovers Tristan Isolde\n#      addhash Lovers 'Romeo Montague' 'Juliet Capulet'\n#\n# access value by key\n#\n#      gethash Lovers Tristan   ---->  Isolde\n#\n# show all keys\n#\n#      keyshash Lovers         ----> 'Tristan'  'Romeo Montague'\n#\n#\n# Convention: instead of perls' foo{bar} = boing' syntax,\n# use\n#       '_foo_bar=boing' (two underscores, no spaces)\n#\n# 1) store key   in _NAME_keys[]\n# 2) store value in _NAME_values[] using the same integer index\n# The integer index for the last entry is _NAME_ptr\n#\n# NOTE: No error or sanity checks, just bare bones.\n\nfunction _inihash () {\n    # private function\n    # call at the beginning of each procedure\n    # defines: _keys _values _ptr\n    #\n    # Usage: _inihash NAME\n    local name=$1\n    _keys=_${name}_keys\n    _values=_${name}_values\n    _ptr=_${name}_ptr\n}\n\nfunction newhash () {\n    # Usage: newhash NAME\n    #        NAME should not contain spaces or dots.\n    #        Actually: it must be a legal name for a Bash variable.\n    # We rely on Bash automatically recognising arrays.\n    local name=$1 \n    local _keys _values _ptr\n    _inihash ${name}\n    eval ${_ptr}=0\n}\n\nfunction addhash () {\n    # Usage: addhash NAME KEY 'VALUE with spaces'\n    #        arguments with spaces need to be quoted with single quotes ''\n    local name=$1 k=\"$2\" v=\"$3\" \n    local _keys _values _ptr\n    _inihash ${name}\n\n    #echo \"DEBUG(addhash): ${_ptr}=${!_ptr}\"\n\n    eval let ${_ptr}=${_ptr}+1\n    eval \"$_keys[${!_ptr}]=\\\"${k}\\\"\"\n    eval \"$_values[${!_ptr}]=\\\"${v}\\\"\"\n}\n\nfunction gethash () {\n    #  Usage: gethash NAME KEY\n    #         Returns boing\n    #         ERR=0 if entry found, 1 otherwise\n    #  That's not a proper hash --\n    #+ we simply linearly search through the keys.\n    local name=$1 key=\"$2\" \n    local _keys _values _ptr \n    local k v i found h\n    _inihash ${name}\n\n    # _ptr holds the highest index in the hash\n    found=0\n\n    for i in $(seq 1 ${!_ptr}); do\n\th=\"\\${${_keys}[${i}]}\"  #  Safer to do it in two steps,\n\teval k=${h}             #+ especially when quoting for spaces.\n\tif [ \"${k}\" = \"${key}\" ]; then found=1; break; fi\n    done;\n\n    [ ${found} = 0 ] && return 1;\n    # else: i is the index that matches the key\n    h=\"\\${${_values}[${i}]}\"\n    eval echo \"${h}\"\n    return 0;\t\n}\n\nfunction keyshash () {\n    # Usage: keyshash NAME\n    # Returns list of all keys defined for hash name.\n    local name=$1 key=\"$2\" \n    local _keys _values _ptr \n    local k i h\n    _inihash ${name}\n\n    # _ptr holds the highest index in the hash\n    for i in $(seq 1 ${!_ptr}); do\n\th=\"\\${${_keys}[${i}]}\"   #  Safer to do it in two steps,\n\teval k=${h}              #+ especially when quoting for spaces.\n\techo -n \"'${k}' \"\n    done;\n}\n\n# -----------------------------------------------------------------------\n\n# Now, let's test it.\n# (Per comments at the beginning of the script.)\nnewhash Lovers\naddhash Lovers Tristan Isolde\naddhash Lovers 'Romeo Montague' 'Juliet Capulet'\n\n# Output results.\necho\ngethash Lovers Tristan      # Isolde\necho\nkeyshash Lovers             # 'Tristan' 'Romeo Montague'\necho; echo\n\nexit 0\n\n# Exercise:\n# --------\n\n# Add error checks to the functions.\n```", "```sh #!/bin/bash\n# ==> usb.sh\n# ==> Script for mounting and installing pen/keychain USB storage devices.\n# ==> Runs as root at system startup (see below).\n# ==>\n# ==> Newer Linux distros (2004 or later) autodetect\n# ==> and install USB pen drives, and therefore don't need this script.\n# ==> But, it's still instructive.\n\n#  This code is free software covered by GNU GPL license version 2 or above.\n#  Please refer to http://www.gnu.org/ for the full license text.\n#\n#  Some code lifted from usb-mount by Michael Hamilton's usb-mount (LGPL)\n#+ see http://users.actrix.co.nz/michael/usbmount.html\n#\n#  INSTALL\n#  -------\n#  Put this in /etc/hotplug/usb/diskonkey.\n#  Then look in /etc/hotplug/usb.distmap, and copy all usb-storage entries\n#+ into /etc/hotplug/usb.usermap, substituting \"usb-storage\" for \"diskonkey\".\n#  Otherwise this code is only run during the kernel module invocation/removal\n#+ (at least in my tests), which defeats the purpose.\n#\n#  TODO\n#  ----\n#  Handle more than one diskonkey device at one time (e.g. /dev/diskonkey1\n#+ and /mnt/diskonkey1), etc. The biggest problem here is the handling in\n#+ devlabel, which I haven't yet tried.\n#\n#  AUTHOR and SUPPORT\n#  ------------------\n#  Konstantin Riabitsev, <icon linux duke edu>.\n#  Send any problem reports to my email address at the moment.\n#\n# ==> Comments added by ABS Guide author.\n\nSYMLINKDEV=/dev/diskonkey\nMOUNTPOINT=/mnt/diskonkey\nDEVLABEL=/sbin/devlabel\nDEVLABELCONFIG=/etc/sysconfig/devlabel\nIAM=$0\n\n##\n# Functions lifted near-verbatim from usb-mount code.\n#\nfunction allAttachedScsiUsb {\n  find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f &#124;\n  xargs grep -l 'Attached: Yes'\n}\nfunction scsiDevFromScsiUsb {\n  echo $1 &#124; awk -F\"[-/]\" '{ n=$(NF-1);\n  print \"/dev/sd\" substr(\"abcdefghijklmnopqrstuvwxyz\", n+1, 1) }'\n}\n\nif [ \"${ACTION}\" = \"add\" ] && [ -f \"${DEVICE}\" ]; then\n    ##\n    # lifted from usbcam code.\n    #\n    if [ -f /var/run/console.lock ]; then\n        CONSOLEOWNER=`cat /var/run/console.lock`\n    elif [ -f /var/lock/console.lock ]; then\n        CONSOLEOWNER=`cat /var/lock/console.lock`\n    else\n        CONSOLEOWNER=\n    fi\n    for procEntry in $(allAttachedScsiUsb); do\n        scsiDev=$(scsiDevFromScsiUsb $procEntry)\n        #  Some bug with usb-storage?\n        #  Partitions are not in /proc/partitions until they are accessed\n        #+ somehow.\n        /sbin/fdisk -l $scsiDev >/dev/null\n        ##\n        #  Most devices have partitioning info, so the data would be on\n        #+ /dev/sd?1\\. However, some stupider ones don't have any partitioning\n        #+ and use the entire device for data storage. This tries to\n        #+ guess semi-intelligently if we have a /dev/sd?1 and if not, then\n        #+ it uses the entire device and hopes for the better.\n        #\n        if grep -q `basename $scsiDev`1 /proc/partitions; then\n            part=\"$scsiDev\"\"1\"\n        else\n            part=$scsiDev\n        fi\n        ##\n        #  Change ownership of the partition to the console user so they can\n        #+ mount it.\n        #\n        if [ ! -z \"$CONSOLEOWNER\" ]; then\n            chown $CONSOLEOWNER:disk $part\n        fi\n        ##\n        # This checks if we already have this UUID defined with devlabel.\n        # If not, it then adds the device to the list.\n        #\n        prodid=`$DEVLABEL printid -d $part`\n        if ! grep -q $prodid $DEVLABELCONFIG; then\n            # cross our fingers and hope it works\n            $DEVLABEL add -d $part -s $SYMLINKDEV 2>/dev/null\n        fi\n        ##\n        # Check if the mount point exists and create if it doesn't.\n        #\n        if [ ! -e $MOUNTPOINT ]; then\n            mkdir -p $MOUNTPOINT\n        fi\n        ##\n        # Take care of /etc/fstab so mounting is easy.\n        #\n        if ! grep -q \"^$SYMLINKDEV\" /etc/fstab; then\n            # Add an fstab entry\n            echo -e \\\n                \"$SYMLINKDEV\\t\\t$MOUNTPOINT\\t\\tauto\\tnoauto,owner,kudzu 0 0\" \\\n                >> /etc/fstab\n        fi\n    done\n    if [ ! -z \"$REMOVER\" ]; then\n        ##\n        # Make sure this script is triggered on device removal.\n        #\n        mkdir -p `dirname $REMOVER`\n        ln -s $IAM $REMOVER\n    fi\nelif [ \"${ACTION}\" = \"remove\" ]; then\n    ##\n    # If the device is mounted, unmount it cleanly.\n    #\n    if grep -q \"$MOUNTPOINT\" /etc/mtab; then\n        # unmount cleanly\n        umount -l $MOUNTPOINT\n    fi\n    ##\n    # Remove it from /etc/fstab if it's there.\n    #\n    if grep -q \"^$SYMLINKDEV\" /etc/fstab; then\n        grep -v \"^$SYMLINKDEV\" /etc/fstab > /etc/.fstab.new\n        mv -f /etc/.fstab.new /etc/fstab\n    fi\nfi\n\nexit 0\n```", "```sh #!/bin/bash\n# tohtml.sh [v. 0.2.01, reldate: 04/13/12, a teeny bit less buggy]\n\n# Convert a text file to HTML format.\n# Author: Mendel Cooper\n# License: GPL3\n# Usage: sh tohtml.sh < textfile > htmlfile\n# Script can easily be modified to accept source and target filenames.\n\n#    Assumptions:\n# 1) Paragraphs in (target) text file are separated by a blank line.\n# 2) Jpeg images (*.jpg) are located in \"images\" subdirectory.\n#    In the target file, the image names are enclosed in square brackets,\n#    for example, [image01.jpg].\n# 3) Emphasized (italic) phrases begin with a space+underscore\n#+   or the first character on the line is an underscore,\n#+   and end with an underscore+space or underscore+end-of-line.\n\n# Settings\nFNTSIZE=2        # Small-medium font size\nIMGDIR=\"images\"  # Image directory\n# Headers\nHDR01='<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">'\nHDR02='<!-- Converted to HTML by ***tohtml.sh*** script -->'\nHDR03='<!-- script author: M. Leo Cooper <thegrendel.abs@gmail.com> -->'\nHDR10='<html>'\nHDR11='<head>'\nHDR11a='</head>'\nHDR12a='<title>'\nHDR12b='</title>'\nHDR121='<META NAME=\"GENERATOR\" CONTENT=\"tohtml.sh script\">'\nHDR13='<body bgcolor=\"#dddddd\">'   # Change background color to suit.\nHDR14a='<font size='\nHDR14b='>'\n# Footers\nFTR10='</body>'\nFTR11='</html>'\n# Tags\nBOLD=\"<b>\"\nCENTER=\"<center>\"\nEND_CENTER=\"</center>\"\nLF=\"<br>\"\n\nwrite_headers ()\n  {\n  echo \"$HDR01\"\n  echo\n  echo \"$HDR02\"\n  echo \"$HDR03\"\n  echo\n  echo\n  echo \"$HDR10\"\n  echo \"$HDR11\"\n  echo \"$HDR121\"\n  echo \"$HDR11a\"\n  echo \"$HDR13\"\n  echo\n  echo -n \"$HDR14a\"\n  echo -n \"$FNTSIZE\"\n  echo \"$HDR14b\"\n  echo\n  echo \"$BOLD\"        # Everything in bold (more easily readable).\n  }\n\nprocess_text ()\n  {\n  while read line     # Read one line at a time.\n  do\n    {\n    if [ ! \"$line\" ]  # Blank line?\n    then              # Then new paragraph must follow.\n      echo\n      echo \"$LF\"      # Insert two <br> tags.\n      echo \"$LF\"\n      echo\n      continue        # Skip the underscore test.\n    else              # Otherwise . . .\n\n      if [[ \"$line\" =~ \\[*jpg\\] ]]    # Is a graphic?\n      then                            # Strip away brackets.\n        temp=$( echo \"$line\" &#124; sed -e 's/\\[//' -e 's/\\]//' )\n        line=\"\"$CENTER\" <img src=\"\\\"$IMGDIR\"/$temp\\\"> \"$END_CENTER\" \"\n                                      # Add image tag.\n                                      # And, center it.\n      fi\n\n    fi\n\n    echo \"$line\" &#124; grep -q _\n    if [ \"$?\" -eq 0 ]    # If line contains underscore ...\n    then\n      # ===================================================\n      # Convert underscored phrase to italics.\n      temp=$( echo \"$line\" &#124;\n              sed -e 's/ _/ <i>/' -e 's/_/<\\/i> /' &#124;\n              sed -e 's/^_/<i>/'  -e 's/_/<\\/i>/' )\n      #  Process only underscores prefixed by space,\n      #+ or at beginning or end of line.\n      #  Do not convert underscores embedded within a word!\n      line=\"$temp\"\n      # Slows script execution. Can be optimized?\n      # ===================================================\n    fi\n\n#   echo\n    echo \"$line\"\n#   echo\n#   Don't want extra blank lines in generated text!\n    } # End while\n  done\n  }   # End process_text ()\n\nwrite_footers ()  # Termination tags.\n  {\n  echo \"$FTR10\"\n  echo \"$FTR11\"\n  }\n\n# main () {\n# =========\nwrite_headers\nprocess_text\nwrite_footers\n# =========\n#         }\n\nexit $?\n\n#  Exercises:\n#  ---------\n#  1) Fixup: Check for closing underscore before a comma or period.\n#  2) Add a test for the presence of a closing underscore\n#+    in phrases to be italicized.\n```", "```sh #!/bin/bash\n# archiveweblogs.sh v1.0\n\n# Troy Engel <tengel@fluid.com>\n# Slightly modified by document author.\n# Used with permission.\n#\n#  This script will preserve the normally rotated and\n#+ thrown away weblogs from a default RedHat/Apache installation.\n#  It will save the files with a date/time stamp in the filename,\n#+ bzipped, to a given directory.\n#\n#  Run this from crontab nightly at an off hour,\n#+ as bzip2 can suck up some serious CPU on huge logs:\n#  0 2 * * * /opt/sbin/archiveweblogs.sh\n\nPROBLEM=66\n\n# Set this to your backup dir.\nBKP_DIR=/opt/backups/weblogs\n\n# Default Apache/RedHat stuff\nLOG_DAYS=\"4 3 2 1\"\nLOG_DIR=/var/log/httpd\nLOG_FILES=\"access_log error_log\"\n\n# Default RedHat program locations\nLS=/bin/ls\nMV=/bin/mv\nID=/usr/bin/id\nCUT=/bin/cut\nCOL=/usr/bin/column\nBZ2=/usr/bin/bzip2\n\n# Are we root?\nUSER=`$ID -u`\nif [ \"X$USER\" != \"X0\" ]; then\n  echo \"PANIC: Only root can run this script!\"\n  exit $PROBLEM\nfi\n\n# Backup dir exists/writable?\nif [ ! -x $BKP_DIR ]; then\n  echo \"PANIC: $BKP_DIR doesn't exist or isn't writable!\"\n  exit $PROBLEM\nfi\n\n# Move, rename and bzip2 the logs\nfor logday in $LOG_DAYS; do\n  for logfile in $LOG_FILES; do\n    MYFILE=\"$LOG_DIR/$logfile.$logday\"\n    if [ -w $MYFILE ]; then\n      DTS=`$LS -lgo --time-style=+%Y%m%d $MYFILE &#124; $COL -t &#124; $CUT -d ' ' -f7`\n      $MV $MYFILE $BKP_DIR/$logfile.$DTS\n      $BZ2 $BKP_DIR/$logfile.$DTS\n    else\n      # Only spew an error if the file exits (ergo non-writable).\n      if [ -f $MYFILE ]; then\n        echo \"ERROR: $MYFILE not writable. Skipping.\"\n      fi\n    fi\n  done\ndone\n\nexit 0\n```", "```sh #! /bin/bash\n# protect_literal.sh\n\n# set -vx\n\n:<<-'_Protect_Literal_String_Doc'\n\n    Copyright (c) Michael S. Zick, 2003; All Rights Reserved\n    License: Unrestricted reuse in any form, for any purpose.\n    Warranty: None\n    Revision: $ID$\n\n    Documentation redirected to the Bash no-operation.\n    Bash will '/dev/null' this block when the script is first read.\n    (Uncomment the above set command to see this action.)\n\n    Remove the first (Sha-Bang) line when sourcing this as a library\n    procedure.  Also comment out the example use code in the two\n    places where shown.\n\n    Usage:\n        _protect_literal_str 'Whatever string meets your ${fancy}'\n        Just echos the argument to standard out, hard quotes\n        restored.\n\n        $(_protect_literal_str 'Whatever string meets your ${fancy}')\n        as the right-hand-side of an assignment statement.\n\n    Does:\n        As the right-hand-side of an assignment, preserves the\n        hard quotes protecting the contents of the literal during\n        assignment.\n\n    Notes:\n        The strange names (_*) are used to avoid trampling on\n        the user's chosen names when this is sourced as a\n        library.\n\n_Protect_Literal_String_Doc\n\n# The 'for illustration' function form\n\n_protect_literal_str() {\n\n# Pick an un-used, non-printing character as local IFS.\n# Not required, but shows that we are ignoring it.\n    local IFS=$'\\x1B'               # \\ESC character\n\n# Enclose the All-Elements-Of in hard quotes during assignment.\n    local tmp=$'\\x27'$@$'\\x27'\n#    local tmp=$'\\''$@$'\\''         # Even uglier.\n\n    local len=${#tmp}               # Info only.\n    echo $tmp is $len long.         # Output AND information.\n}\n\n# This is the short-named version.\n_pls() {\n    local IFS=$'x1B'                # \\ESC character (not required)\n    echo $'\\x27'$@$'\\x27'           # Hard quoted parameter glob\n}\n\n# :<<-'_Protect_Literal_String_Test'\n# # # Remove the above \"# \" to disable this code. # # #\n\n# See how that looks when printed.\necho\necho \"- - Test One - -\"\n_protect_literal_str 'Hello $user'\n_protect_literal_str 'Hello \"${username}\"'\necho\n\n# Which yields:\n# - - Test One - -\n# 'Hello $user' is 13 long.\n# 'Hello \"${username}\"' is 21 long.\n\n#  Looks as expected, but why all of the trouble?\n#  The difference is hidden inside the Bash internal order\n#+ of operations.\n#  Which shows when you use it on the RHS of an assignment.\n\n# Declare an array for test values.\ndeclare -a arrayZ\n\n# Assign elements with various types of quotes and escapes.\narrayZ=( zero \"$(_pls 'Hello ${Me}')\" 'Hello ${You}' \"\\'Pass: ${pw}\\'\" )\n\n# Now list that array and see what is there.\necho \"- - Test Two - -\"\nfor (( i=0 ; i<${#arrayZ[*]} ; i++ ))\ndo\n    echo  Element $i: ${arrayZ[$i]} is: ${#arrayZ[$i]} long.\ndone\necho\n\n# Which yields:\n# - - Test Two - -\n# Element 0: zero is: 4 long.           # Our marker element\n# Element 1: 'Hello ${Me}' is: 13 long. # Our \"$(_pls '...' )\"\n# Element 2: Hello ${You} is: 12 long.  # Quotes are missing\n# Element 3: \\'Pass: \\' is: 10 long.    # ${pw} expanded to nothing\n\n# Now make an assignment with that result.\ndeclare -a array2=( ${arrayZ[@]} )\n\n# And print what happened.\necho \"- - Test Three - -\"\nfor (( i=0 ; i<${#array2[*]} ; i++ ))\ndo\n    echo  Element $i: ${array2[$i]} is: ${#array2[$i]} long.\ndone\necho\n\n# Which yields:\n# - - Test Three - -\n# Element 0: zero is: 4 long.           # Our marker element.\n# Element 1: Hello ${Me} is: 11 long.   # Intended result.\n# Element 2: Hello is: 5 long.          # ${You} expanded to nothing.\n# Element 3: 'Pass: is: 6 long.         # Split on the whitespace.\n# Element 4: ' is: 1 long.              # The end quote is here now.\n\n#  Our Element 1 has had its leading and trailing hard quotes stripped.\n#  Although not shown, leading and trailing whitespace is also stripped.\n#  Now that the string contents are set, Bash will always, internally,\n#+ hard quote the contents as required during its operations.\n\n#  Why?\n#  Considering our \"$(_pls 'Hello ${Me}')\" construction:\n#  \" ... \" -> Expansion required, strip the quotes.\n#  $( ... ) -> Replace with the result of..., strip this.\n#  _pls ' ... ' -> called with literal arguments, strip the quotes.\n#  The result returned includes hard quotes; BUT the above processing\n#+ has already been done, so they become part of the value assigned.\n#\n#  Similarly, during further usage of the string variable, the ${Me}\n#+ is part of the contents (result) and survives any operations\n#  (Until explicitly told to evaluate the string).\n\n#  Hint: See what happens when the hard quotes ($'\\x27') are replaced\n#+ with soft quotes ($'\\x22') in the above procedures.\n#  Interesting also is to remove the addition of any quoting.\n\n# _Protect_Literal_String_Test\n# # # Remove the above \"# \" to disable this code. # # #\n\nexit 0\n```", "```sh #! /bin/bash\n# unprotect_literal.sh\n\n# set -vx\n\n:<<-'_UnProtect_Literal_String_Doc'\n\n    Copyright (c) Michael S. Zick, 2003; All Rights Reserved\n    License: Unrestricted reuse in any form, for any purpose.\n    Warranty: None\n    Revision: $ID$\n\n    Documentation redirected to the Bash no-operation. Bash will\n    '/dev/null' this block when the script is first read.\n    (Uncomment the above set command to see this action.)\n\n    Remove the first (Sha-Bang) line when sourcing this as a library\n    procedure.  Also comment out the example use code in the two\n    places where shown.\n\n    Usage:\n        Complement of the \"$(_pls 'Literal String')\" function.\n        (See the protect_literal.sh example.)\n\n        StringVar=$(_upls ProtectedSringVariable)\n\n    Does:\n        When used on the right-hand-side of an assignment statement;\n        makes the substitions embedded in the protected string.\n\n    Notes:\n        The strange names (_*) are used to avoid trampling on\n        the user's chosen names when this is sourced as a\n        library.\n\n_UnProtect_Literal_String_Doc\n\n_upls() {\n    local IFS=$'x1B'                # \\ESC character (not required)\n    eval echo $@                    # Substitution on the glob.\n}\n\n# :<<-'_UnProtect_Literal_String_Test'\n# # # Remove the above \"# \" to disable this code. # # #\n\n_pls() {\n    local IFS=$'x1B'                # \\ESC character (not required)\n    echo $'\\x27'$@$'\\x27'           # Hard quoted parameter glob\n}\n\n# Declare an array for test values.\ndeclare -a arrayZ\n\n# Assign elements with various types of quotes and escapes.\narrayZ=( zero \"$(_pls 'Hello ${Me}')\" 'Hello ${You}' \"\\'Pass: ${pw}\\'\" )\n\n# Now make an assignment with that result.\ndeclare -a array2=( ${arrayZ[@]} )\n\n# Which yielded:\n# - - Test Three - -\n# Element 0: zero is: 4 long            # Our marker element.\n# Element 1: Hello ${Me} is: 11 long    # Intended result.\n# Element 2: Hello is: 5 long           # ${You} expanded to nothing.\n# Element 3: 'Pass: is: 6 long          # Split on the whitespace.\n# Element 4: ' is: 1 long               # The end quote is here now.\n\n# set -vx\n\n#  Initialize 'Me' to something for the embedded ${Me} substitution.\n#  This needs to be done ONLY just prior to evaluating the\n#+ protected string.\n#  (This is why it was protected to begin with.)\n\nMe=\"to the array guy.\"\n\n# Set a string variable destination to the result.\nnewVar=$(_upls ${array2[1]})\n\n# Show what the contents are.\necho $newVar\n\n# Do we really need a function to do this?\nnewerVar=$(eval echo ${array2[1]})\necho $newerVar\n\n#  I guess not, but the _upls function gives us a place to hang\n#+ the documentation on.\n#  This helps when we forget what a # construction like:\n#+ $(eval echo ... ) means.\n\n# What if Me isn't set when the protected string is evaluated?\nunset Me\nnewestVar=$(_upls ${array2[1]})\necho $newestVar\n\n# Just gone, no hints, no runs, no errors.\n\n#  Why in the world?\n#  Setting the contents of a string variable containing character\n#+ sequences that have a meaning in Bash is a general problem in\n#+ script programming.\n#\n#  This problem is now solved in eight lines of code\n#+ (and four pages of description).\n\n#  Where is all this going?\n#  Dynamic content Web pages as an array of Bash strings.\n#  Content set per request by a Bash 'eval' command\n#+ on the stored page template.\n#  Not intended to replace PHP, just an interesting thing to do.\n###\n#  Don't have a webserver application?\n#  No problem, check the example directory of the Bash source;\n#+ there is a Bash script for that also.\n\n# _UnProtect_Literal_String_Test\n# # # Remove the above \"# \" to disable this code. # # #\n\nexit 0\n```", "```sh #!/bin/bash\n\n# $Id: is_spammer.bash,v 1.12.2.11 2004/10/01 21:42:33 mszick Exp $\n# Above line is RCS info.\n\n# The latest version of this script is available from http://www.morethan.org.\n#\n# Spammer-identification\n# by Michael S. Zick\n# Used in the ABS Guide with permission.\n\n#######################################################\n# Documentation\n# See also \"Quickstart\" at end of script.\n#######################################################\n\n:<<-'__is_spammer_Doc_'\n\n    Copyright (c) Michael S. Zick, 2004\n    License: Unrestricted reuse in any form, for any purpose.\n    Warranty: None -{Its a script; the user is on their own.}-\n\nImpatient?\n    Application code: goto \"# # # Hunt the Spammer' program code # # #\"\n    Example output: \":<<-'_is_spammer_outputs_'\"\n    How to use: Enter script name without arguments.\n                Or goto \"Quickstart\" at end of script.\n\nProvides\n    Given a domain name or IP(v4) address as input:\n\n    Does an exhaustive set of queries to find the associated\n    network resources (short of recursing into TLDs).\n\n    Checks the IP(v4) addresses found against Blacklist\n    nameservers.\n\n    If found to be a blacklisted IP(v4) address,\n    reports the blacklist text records.\n    (Usually hyper-links to the specific report.)\n\nRequires\n    A working Internet connection.\n    (Exercise: Add check and/or abort if not on-line when running script.)\n    Bash with arrays (2.05b+).\n\n    The external program 'dig' --\n    a utility program provided with the 'bind' set of programs.\n    Specifically, the version which is part of Bind series 9.x\n    See: http://www.isc.org\n\n    All usages of 'dig' are limited to wrapper functions,\n    which may be rewritten as required.\n    See: dig_wrappers.bash for details.\n         (\"Additional documentation\" -- below)\n\nUsage\n    Script requires a single argument, which may be:\n    1) A domain name;\n    2) An IP(v4) address;\n    3) A filename, with one name or address per line.\n\n    Script accepts an optional second argument, which may be:\n    1) A Blacklist server name;\n    2) A filename, with one Blacklist server name per line.\n\n    If the second argument is not provided, the script uses\n    a built-in set of (free) Blacklist servers.\n\n    See also, the Quickstart at the end of this script (after 'exit').\n\nReturn Codes\n    0 - All OK\n    1 - Script failure\n    2 - Something is Blacklisted\n\nOptional environment variables\n    SPAMMER_TRACE\n        If set to a writable file,\n        script will log an execution flow trace.\n\n    SPAMMER_DATA\n        If set to a writable file, script will dump its\n        discovered data in the form of GraphViz file.\n        See: http://www.research.att.com/sw/tools/graphviz\n\n    SPAMMER_LIMIT\n        Limits the depth of resource tracing.\n\n        Default is 2 levels.\n\n        A setting of 0 (zero) means 'unlimited' . . .\n          Caution: script might recurse the whole Internet!\n\n        A limit of 1 or 2 is most useful when processing\n        a file of domain names and addresses.\n        A higher limit can be useful when hunting spam gangs.\n\nAdditional documentation\n    Download the archived set of scripts\n    explaining and illustrating the function contained within this script.\n    http://bash.deta.in/mszick_clf.tar.bz2\n\nStudy notes\n    This script uses a large number of functions.\n    Nearly all general functions have their own example script.\n    Each of the example scripts have tutorial level comments.\n\nScripting project\n    Add support for IP(v6) addresses.\n    IP(v6) addresses are recognized but not processed.\n\nAdvanced project\n    Add the reverse lookup detail to the discovered information.\n\n    Report the delegation chain and abuse contacts.\n\n    Modify the GraphViz file output to include the\n    newly discovered information.\n\n__is_spammer_Doc_\n\n#######################################################\n\n#### Special IFS settings used for string parsing. ####\n\n# Whitespace == :Space:Tab:Line Feed:Carriage Return:\nWSP_IFS=$'\\x20'$'\\x09'$'\\x0A'$'\\x0D'\n\n# No Whitespace == Line Feed:Carriage Return\nNO_WSP=$'\\x0A'$'\\x0D'\n\n# Field separator for dotted decimal IP addresses\nADR_IFS=${NO_WSP}'.'\n\n# Array to dotted string conversions\nDOT_IFS='.'${WSP_IFS}\n\n# # # Pending operations stack machine # # #\n# This set of functions described in func_stack.bash.\n# (See \"Additional documentation\" above.)\n# # #\n\n# Global stack of pending operations.\ndeclare -f -a _pending_\n# Global sentinel for stack runners\ndeclare -i _p_ctrl_\n# Global holder for currently executing function\ndeclare -f _pend_current_\n\n# # # Debug version only - remove for regular use # # #\n#\n# The function stored in _pend_hook_ is called\n# immediately before each pending function is\n# evaluated.  Stack clean, _pend_current_ set.\n#\n# This thingy demonstrated in pend_hook.bash.\ndeclare -f _pend_hook_\n# # #\n\n# The do nothing function\npend_dummy() { : ; }\n\n# Clear and initialize the function stack.\npend_init() {\n    unset _pending_[@]\n    pend_func pend_stop_mark\n    _pend_hook_='pend_dummy'  # Debug only.\n}\n\n# Discard the top function on the stack.\npend_pop() {\n    if [ ${#_pending_[@]} -gt 0 ]\n    then\n        local -i _top_\n        _top_=${#_pending_[@]}-1\n        unset _pending_[$_top_]\n    fi\n}\n\n# pend_func function_name [$(printf '%q\\n' arguments)]\npend_func() {\n    local IFS=${NO_WSP}\n    set -f\n    _pending_[${#_pending_[@]}]=$@\n    set +f\n}\n\n# The function which stops the release:\npend_stop_mark() {\n    _p_ctrl_=0\n}\n\npend_mark() {\n    pend_func pend_stop_mark\n}\n\n# Execute functions until 'pend_stop_mark' . . .\npend_release() {\n    local -i _top_             # Declare _top_ as integer.\n    _p_ctrl_=${#_pending_[@]}\n    while [ ${_p_ctrl_} -gt 0 ]\n    do\n       _top_=${#_pending_[@]}-1\n       _pend_current_=${_pending_[$_top_]}\n       unset _pending_[$_top_]\n       $_pend_hook_            # Debug only.\n       eval $_pend_current_\n    done\n}\n\n# Drop functions until 'pend_stop_mark' . . .\npend_drop() {\n    local -i _top_\n    local _pd_ctrl_=${#_pending_[@]}\n    while [ ${_pd_ctrl_} -gt 0 ]\n    do\n       _top_=$_pd_ctrl_-1\n       if [ \"${_pending_[$_top_]}\" == 'pend_stop_mark' ]\n       then\n           unset _pending_[$_top_]\n           break\n       else\n           unset _pending_[$_top_]\n           _pd_ctrl_=$_top_\n       fi\n    done\n    if [ ${#_pending_[@]} -eq 0 ]\n    then\n        pend_func pend_stop_mark\n    fi\n}\n\n#### Array editors ####\n\n# This function described in edit_exact.bash.\n# (See \"Additional documentation,\" above.)\n# edit_exact <excludes_array_name> <target_array_name>\nedit_exact() {\n    [ $# -eq 2 ] &#124;&#124;\n    [ $# -eq 3 ] &#124;&#124; return 1\n    local -a _ee_Excludes\n    local -a _ee_Target\n    local _ee_x\n    local _ee_t\n    local IFS=${NO_WSP}\n    set -f\n    eval _ee_Excludes=\\( \\$\\{$1\\[@\\]\\} \\)\n    eval _ee_Target=\\( \\$\\{$2\\[@\\]\\} \\)\n    local _ee_len=${#_ee_Target[@]}     # Original length.\n    local _ee_cnt=${#_ee_Excludes[@]}   # Exclude list length.\n    [ ${_ee_len} -ne 0 ] &#124;&#124; return 0    # Can't edit zero length.\n    [ ${_ee_cnt} -ne 0 ] &#124;&#124; return 0    # Can't edit zero length.\n    for (( x = 0; x < ${_ee_cnt} ; x++ ))\n    do\n        _ee_x=${_ee_Excludes[$x]}\n        for (( n = 0 ; n < ${_ee_len} ; n++ ))\n        do\n            _ee_t=${_ee_Target[$n]}\n            if [ x\"${_ee_t}\" == x\"${_ee_x}\" ]\n            then\n                unset _ee_Target[$n]     # Discard match.\n                [ $# -eq 2 ] && break    # If 2 arguments, then done.\n            fi\n        done\n    done\n    eval $2=\\( \\$\\{_ee_Target\\[@\\]\\} \\)\n    set +f\n    return 0\n}\n\n# This function described in edit_by_glob.bash.\n# edit_by_glob <excludes_array_name> <target_array_name>\nedit_by_glob() {\n    [ $# -eq 2 ] &#124;&#124;\n    [ $# -eq 3 ] &#124;&#124; return 1\n    local -a _ebg_Excludes\n    local -a _ebg_Target\n    local _ebg_x\n    local _ebg_t\n    local IFS=${NO_WSP}\n    set -f\n    eval _ebg_Excludes=\\( \\$\\{$1\\[@\\]\\} \\)\n    eval _ebg_Target=\\( \\$\\{$2\\[@\\]\\} \\)\n    local _ebg_len=${#_ebg_Target[@]}\n    local _ebg_cnt=${#_ebg_Excludes[@]}\n    [ ${_ebg_len} -ne 0 ] &#124;&#124; return 0\n    [ ${_ebg_cnt} -ne 0 ] &#124;&#124; return 0\n    for (( x = 0; x < ${_ebg_cnt} ; x++ ))\n    do\n        _ebg_x=${_ebg_Excludes[$x]}\n        for (( n = 0 ; n < ${_ebg_len} ; n++ ))\n        do\n            [ $# -eq 3 ] && _ebg_x=${_ebg_x}'*'  #  Do prefix edit\n            if [ ${_ebg_Target[$n]:=} ]          #+ if defined & set.\n            then\n                _ebg_t=${_ebg_Target[$n]/#${_ebg_x}/}\n                [ ${#_ebg_t} -eq 0 ] && unset _ebg_Target[$n]\n            fi\n        done\n    done\n    eval $2=\\( \\$\\{_ebg_Target\\[@\\]\\} \\)\n    set +f\n    return 0\n}\n\n# This function described in unique_lines.bash.\n# unique_lines <in_name> <out_name>\nunique_lines() {\n    [ $# -eq 2 ] &#124;&#124; return 1\n    local -a _ul_in\n    local -a _ul_out\n    local -i _ul_cnt\n    local -i _ul_pos\n    local _ul_tmp\n    local IFS=${NO_WSP}\n    set -f\n    eval _ul_in=\\( \\$\\{$1\\[@\\]\\} \\)\n    _ul_cnt=${#_ul_in[@]}\n    for (( _ul_pos = 0 ; _ul_pos < ${_ul_cnt} ; _ul_pos++ ))\n    do\n        if [ ${_ul_in[${_ul_pos}]:=} ]      # If defined & not empty\n        then\n            _ul_tmp=${_ul_in[${_ul_pos}]}\n            _ul_out[${#_ul_out[@]}]=${_ul_tmp}\n            for (( zap = _ul_pos ; zap < ${_ul_cnt} ; zap++ ))\n            do\n                [ ${_ul_in[${zap}]:=} ] &&\n                [ 'x'${_ul_in[${zap}]} == 'x'${_ul_tmp} ] &&\n                    unset _ul_in[${zap}]\n            done\n        fi\n    done\n    eval $2=\\( \\$\\{_ul_out\\[@\\]\\} \\)\n    set +f\n    return 0\n}\n\n# This function described in char_convert.bash.\n# to_lower <string>\nto_lower() {\n    [ $# -eq 1 ] &#124;&#124; return 1\n    local _tl_out\n    _tl_out=${1//A/a}\n    _tl_out=${_tl_out//B/b}\n    _tl_out=${_tl_out//C/c}\n    _tl_out=${_tl_out//D/d}\n    _tl_out=${_tl_out//E/e}\n    _tl_out=${_tl_out//F/f}\n    _tl_out=${_tl_out//G/g}\n    _tl_out=${_tl_out//H/h}\n    _tl_out=${_tl_out//I/i}\n    _tl_out=${_tl_out//J/j}\n    _tl_out=${_tl_out//K/k}\n    _tl_out=${_tl_out//L/l}\n    _tl_out=${_tl_out//M/m}\n    _tl_out=${_tl_out//N/n}\n    _tl_out=${_tl_out//O/o}\n    _tl_out=${_tl_out//P/p}\n    _tl_out=${_tl_out//Q/q}\n    _tl_out=${_tl_out//R/r}\n    _tl_out=${_tl_out//S/s}\n    _tl_out=${_tl_out//T/t}\n    _tl_out=${_tl_out//U/u}\n    _tl_out=${_tl_out//V/v}\n    _tl_out=${_tl_out//W/w}\n    _tl_out=${_tl_out//X/x}\n    _tl_out=${_tl_out//Y/y}\n    _tl_out=${_tl_out//Z/z}\n    echo ${_tl_out}\n    return 0\n}\n\n#### Application helper functions ####\n\n# Not everybody uses dots as separators (APNIC, for example).\n# This function described in to_dot.bash\n# to_dot <string>\nto_dot() {\n    [ $# -eq 1 ] &#124;&#124; return 1\n    echo ${1//[#&#124;@&#124;%]/.}\n    return 0\n}\n\n# This function described in is_number.bash.\n# is_number <input>\nis_number() {\n    [ \"$#\" -eq 1 ]    &#124;&#124; return 1  # is blank?\n    [ x\"$1\" == 'x0' ] && return 0  # is zero?\n    local -i tst\n    let tst=$1 2>/dev/null         # else is numeric!\n    return $?\n}\n\n# This function described in is_address.bash.\n# is_address <input>\nis_address() {\n    [ $# -eq 1 ] &#124;&#124; return 1    # Blank ==> false\n    local -a _ia_input\n    local IFS=${ADR_IFS}\n    _ia_input=( $1 )\n    if  [ ${#_ia_input[@]} -eq 4 ]  &&\n        is_number ${_ia_input[0]}   &&\n        is_number ${_ia_input[1]}   &&\n        is_number ${_ia_input[2]}   &&\n        is_number ${_ia_input[3]}   &&\n        [ ${_ia_input[0]} -lt 256 ] &&\n        [ ${_ia_input[1]} -lt 256 ] &&\n        [ ${_ia_input[2]} -lt 256 ] &&\n        [ ${_ia_input[3]} -lt 256 ]\n    then\n        return 0\n    else\n        return 1\n    fi\n}\n\n#  This function described in split_ip.bash.\n#  split_ip <IP_address>\n#+ <array_name_norm> [<array_name_rev>]\nsplit_ip() {\n    [ $# -eq 3 ] &#124;&#124;              #  Either three\n    [ $# -eq 2 ] &#124;&#124; return 1     #+ or two arguments\n    local -a _si_input\n    local IFS=${ADR_IFS}\n    _si_input=( $1 )\n    IFS=${WSP_IFS}\n    eval $2=\\(\\ \\$\\{_si_input\\[@\\]\\}\\ \\)\n    if [ $# -eq 3 ]\n    then\n        # Build query order array.\n        local -a _dns_ip\n        _dns_ip[0]=${_si_input[3]}\n        _dns_ip[1]=${_si_input[2]}\n        _dns_ip[2]=${_si_input[1]}\n        _dns_ip[3]=${_si_input[0]}\n        eval $3=\\(\\ \\$\\{_dns_ip\\[@\\]\\}\\ \\)\n    fi\n    return 0\n}\n\n# This function described in dot_array.bash.\n# dot_array <array_name>\ndot_array() {\n    [ $# -eq 1 ] &#124;&#124; return 1     # Single argument required.\n    local -a _da_input\n    eval _da_input=\\(\\ \\$\\{$1\\[@\\]\\}\\ \\)\n    local IFS=${DOT_IFS}\n    local _da_output=${_da_input[@]}\n    IFS=${WSP_IFS}\n    echo ${_da_output}\n    return 0\n}\n\n# This function described in file_to_array.bash\n# file_to_array <file_name> <line_array_name>\nfile_to_array() {\n    [ $# -eq 2 ] &#124;&#124; return 1  # Two arguments required.\n    local IFS=${NO_WSP}\n    local -a _fta_tmp_\n    _fta_tmp_=( $(cat $1) )\n    eval $2=\\( \\$\\{_fta_tmp_\\[@\\]\\} \\)\n    return 0\n}\n\n#  Columnized print of an array of multi-field strings.\n#  col_print <array_name> <min_space> <\n#+ tab_stop [tab_stops]>\ncol_print() {\n    [ $# -gt 2 ] &#124;&#124; return 0\n    local -a _cp_inp\n    local -a _cp_spc\n    local -a _cp_line\n    local _cp_min\n    local _cp_mcnt\n    local _cp_pos\n    local _cp_cnt\n    local _cp_tab\n    local -i _cp\n    local -i _cpf\n    local _cp_fld\n    # WARNING: FOLLOWING LINE NOT BLANK -- IT IS QUOTED SPACES.\n    local _cp_max='                                                            '\n    set -f\n    local IFS=${NO_WSP}\n    eval _cp_inp=\\(\\ \\$\\{$1\\[@\\]\\}\\ \\)\n    [ ${#_cp_inp[@]} -gt 0 ] &#124;&#124; return 0 # Empty is easy.\n    _cp_mcnt=$2\n    _cp_min=${_cp_max:1:${_cp_mcnt}}\n    shift\n    shift\n    _cp_cnt=$#\n    for (( _cp = 0 ; _cp < _cp_cnt ; _cp++ ))\n    do\n        _cp_spc[${#_cp_spc[@]}]=\"${_cp_max:2:$1}\" #\"\n        shift\n    done\n    _cp_cnt=${#_cp_inp[@]}\n    for (( _cp = 0 ; _cp < _cp_cnt ; _cp++ ))\n    do\n        _cp_pos=1\n        IFS=${NO_WSP}$'\\x20'\n        _cp_line=( ${_cp_inp[${_cp}]} )\n        IFS=${NO_WSP}\n        for (( _cpf = 0 ; _cpf < ${#_cp_line[@]} ; _cpf++ ))\n        do\n            _cp_tab=${_cp_spc[${_cpf}]:${_cp_pos}}\n            if [ ${#_cp_tab} -lt ${_cp_mcnt} ]\n            then\n                _cp_tab=\"${_cp_min}\"\n            fi\n            echo -n \"${_cp_tab}\"\n            (( _cp_pos = ${_cp_pos} + ${#_cp_tab} ))\n            _cp_fld=\"${_cp_line[${_cpf}]}\"\n            echo -n ${_cp_fld}\n            (( _cp_pos = ${_cp_pos} + ${#_cp_fld} ))\n        done\n        echo\n    done\n    set +f\n    return 0\n}\n\n# # # # 'Hunt the Spammer' data flow # # # #\n\n# Application return code\ndeclare -i _hs_RC\n\n# Original input, from which IP addresses are removed\n# After which, domain names to check\ndeclare -a uc_name\n\n# Original input IP addresses are moved here\n# After which, IP addresses to check\ndeclare -a uc_address\n\n# Names against which address expansion run\n# Ready for name detail lookup\ndeclare -a chk_name\n\n# Addresses against which name expansion run\n# Ready for address detail lookup\ndeclare -a chk_address\n\n#  Recursion is depth-first-by-name.\n#  The expand_input_address maintains this list\n#+ to prohibit looking up addresses twice during\n#+ domain name recursion.\ndeclare -a been_there_addr\nbeen_there_addr=( '127.0.0.1' ) # Whitelist localhost\n\n# Names which we have checked (or given up on)\ndeclare -a known_name\n\n# Addresses which we have checked (or given up on)\ndeclare -a known_address\n\n#  List of zero or more Blacklist servers to check.\n#  Each 'known_address' will be checked against each server,\n#+ with negative replies and failures suppressed.\ndeclare -a list_server\n\n# Indirection limit - set to zero == no limit\nindirect=${SPAMMER_LIMIT:=2}\n\n# # # # 'Hunt the Spammer' information output data # # # #\n\n# Any domain name may have multiple IP addresses.\n# Any IP address may have multiple domain names.\n# Therefore, track unique address-name pairs.\ndeclare -a known_pair\ndeclare -a reverse_pair\n\n#  In addition to the data flow variables; known_address\n#+ known_name and list_server, the following are output to the\n#+ external graphics interface file.\n\n# Authority chain, parent -> SOA fields.\ndeclare -a auth_chain\n\n# Reference chain, parent name -> child name\ndeclare -a ref_chain\n\n# DNS chain - domain name -> address\ndeclare -a name_address\n\n# Name and service pairs - domain name -> service\ndeclare -a name_srvc\n\n# Name and resource pairs - domain name -> Resource Record\ndeclare -a name_resource\n\n# Parent and Child pairs - parent name -> child name\n# This MAY NOT be the same as the ref_chain followed!\ndeclare -a parent_child\n\n# Address and Blacklist hit pairs - address->server\ndeclare -a address_hits\n\n# Dump interface file data\ndeclare -f _dot_dump\n_dot_dump=pend_dummy   # Initially a no-op\n\n#  Data dump is enabled by setting the environment variable SPAMMER_DATA\n#+ to the name of a writable file.\ndeclare _dot_file\n\n# Helper function for the dump-to-dot-file function\n# dump_to_dot <array_name> <prefix>\ndump_to_dot() {\n    local -a _dda_tmp\n    local -i _dda_cnt\n    local _dda_form='    '${2}'%04u %s\\n'\n    local IFS=${NO_WSP}\n    eval _dda_tmp=\\(\\ \\$\\{$1\\[@\\]\\}\\ \\)\n    _dda_cnt=${#_dda_tmp[@]}\n    if [ ${_dda_cnt} -gt 0 ]\n    then\n        for (( _dda = 0 ; _dda < _dda_cnt ; _dda++ ))\n        do\n            printf \"${_dda_form}\" \\\n                   \"${_dda}\" \"${_dda_tmp[${_dda}]}\" >>${_dot_file}\n        done\n    fi\n}\n\n# Which will also set _dot_dump to this function . . .\ndump_dot() {\n    local -i _dd_cnt\n    echo '# Data vintage: '$(date -R) >${_dot_file}\n    echo '# ABS Guide: is_spammer.bash; v2, 2004-msz' >>${_dot_file}\n    echo >>${_dot_file}\n    echo 'digraph G {' >>${_dot_file}\n\n    if [ ${#known_name[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known domain name nodes' >>${_dot_file}\n        _dd_cnt=${#known_name[@]}\n        for (( _dd = 0 ; _dd < _dd_cnt ; _dd++ ))\n        do\n            printf '    N%04u [label=\"%s\"] ;\\n' \\\n                   \"${_dd}\" \"${known_name[${_dd}]}\" >>${_dot_file}\n        done\n    fi\n\n    if [ ${#known_address[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known address nodes' >>${_dot_file}\n        _dd_cnt=${#known_address[@]}\n        for (( _dd = 0 ; _dd < _dd_cnt ; _dd++ ))\n        do\n            printf '    A%04u [label=\"%s\"] ;\\n' \\\n                   \"${_dd}\" \"${known_address[${_dd}]}\" >>${_dot_file}\n        done\n    fi\n\n    echo                                   >>${_dot_file}\n    echo '/*'                              >>${_dot_file}\n    echo ' * Known relationships :: User conversion to'  >>${_dot_file}\n    echo ' * graphic form by hand or program required.'  >>${_dot_file}\n    echo ' *'                              >>${_dot_file}\n\n    if [ ${#auth_chain[@]} -gt 0 ]\n    then\n      echo >>${_dot_file}\n      echo '# Authority ref. edges followed & field source.' >>${_dot_file}\n        dump_to_dot auth_chain AC\n    fi\n\n    if [ ${#ref_chain[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Name ref. edges followed and field source.' >>${_dot_file}\n        dump_to_dot ref_chain RC\n    fi\n\n    if [ ${#name_address[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known name->address edges' >>${_dot_file}\n        dump_to_dot name_address NA\n    fi\n\n    if [ ${#name_srvc[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known name->service edges' >>${_dot_file}\n        dump_to_dot name_srvc NS\n    fi\n\n    if [ ${#name_resource[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known name->resource edges' >>${_dot_file}\n        dump_to_dot name_resource NR\n    fi\n\n    if [ ${#parent_child[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known parent->child edges' >>${_dot_file}\n        dump_to_dot parent_child PC\n    fi\n\n    if [ ${#list_server[@]} -gt 0 ]\n    then\n        echo >>${_dot_file}\n        echo '# Known Blacklist nodes' >>${_dot_file}\n        _dd_cnt=${#list_server[@]}\n        for (( _dd = 0 ; _dd < _dd_cnt ; _dd++ ))\n        do\n            printf '    LS%04u [label=\"%s\"] ;\\n' \\\n                   \"${_dd}\" \"${list_server[${_dd}]}\" >>${_dot_file}\n        done\n    fi\n\n    unique_lines address_hits address_hits\n    if [ ${#address_hits[@]} -gt 0 ]\n    then\n      echo >>${_dot_file}\n      echo '# Known address->Blacklist_hit edges' >>${_dot_file}\n      echo '# CAUTION: dig warnings can trigger false hits.' >>${_dot_file}\n       dump_to_dot address_hits AH\n    fi\n    echo          >>${_dot_file}\n    echo ' *'     >>${_dot_file}\n    echo ' * That is a lot of relationships. Happy graphing.' >>${_dot_file}\n    echo ' */'    >>${_dot_file}\n    echo '}'      >>${_dot_file}\n    return 0\n}\n\n# # # # 'Hunt the Spammer' execution flow # # # #\n\n#  Execution trace is enabled by setting the\n#+ environment variable SPAMMER_TRACE to the name of a writable file.\ndeclare -a _trace_log\ndeclare _log_file\n\n# Function to fill the trace log\ntrace_logger() {\n    _trace_log[${#_trace_log[@]}]=${_pend_current_}\n}\n\n# Dump trace log to file function variable.\ndeclare -f _log_dump\n_log_dump=pend_dummy   # Initially a no-op.\n\n# Dump the trace log to a file.\ndump_log() {\n    local -i _dl_cnt\n    _dl_cnt=${#_trace_log[@]}\n    for (( _dl = 0 ; _dl < _dl_cnt ; _dl++ ))\n    do\n        echo ${_trace_log[${_dl}]} >> ${_log_file}\n    done\n    _dl_cnt=${#_pending_[@]}\n    if [ ${_dl_cnt} -gt 0 ]\n    then\n        _dl_cnt=${_dl_cnt}-1\n        echo '# # # Operations stack not empty # # #' >> ${_log_file}\n        for (( _dl = ${_dl_cnt} ; _dl >= 0 ; _dl-- ))\n        do\n            echo ${_pending_[${_dl}]} >> ${_log_file}\n        done\n    fi\n}\n\n# # # Utility program 'dig' wrappers # # #\n#\n#  These wrappers are derived from the\n#+ examples shown in dig_wrappers.bash.\n#\n#  The major difference is these return\n#+ their results as a list in an array.\n#\n#  See dig_wrappers.bash for details and\n#+ use that script to develop any changes.\n#\n# # #\n\n# Short form answer: 'dig' parses answer.\n\n# Forward lookup :: Name -> Address\n# short_fwd <domain_name> <array_name>\nshort_fwd() {\n    local -a _sf_reply\n    local -i _sf_rc\n    local -i _sf_cnt\n    IFS=${NO_WSP}\necho -n '.'\n# echo 'sfwd: '${1}\n  _sf_reply=( $(dig +short ${1} -c in -t a 2>/dev/null) )\n  _sf_rc=$?\n  if [ ${_sf_rc} -ne 0 ]\n  then\n    _trace_log[${#_trace_log[@]}]='## Lookup error '${_sf_rc}' on '${1}' ##'\n# [ ${_sf_rc} -ne 9 ] && pend_drop\n        return ${_sf_rc}\n    else\n        # Some versions of 'dig' return warnings on stdout.\n        _sf_cnt=${#_sf_reply[@]}\n        for (( _sf = 0 ; _sf < ${_sf_cnt} ; _sf++ ))\n        do\n            [ 'x'${_sf_reply[${_sf}]:0:2} == 'x;;' ] &&\n                unset _sf_reply[${_sf}]\n        done\n        eval $2=\\( \\$\\{_sf_reply\\[@\\]\\} \\)\n    fi\n    return 0\n}\n\n# Reverse lookup :: Address -> Name\n# short_rev <ip_address> <array_name>\nshort_rev() {\n    local -a _sr_reply\n    local -i _sr_rc\n    local -i _sr_cnt\n    IFS=${NO_WSP}\necho -n '.'\n# echo 'srev: '${1}\n  _sr_reply=( $(dig +short -x ${1} 2>/dev/null) )\n  _sr_rc=$?\n  if [ ${_sr_rc} -ne 0 ]\n  then\n    _trace_log[${#_trace_log[@]}]='## Lookup error '${_sr_rc}' on '${1}' ##'\n# [ ${_sr_rc} -ne 9 ] && pend_drop\n        return ${_sr_rc}\n    else\n        # Some versions of 'dig' return warnings on stdout.\n        _sr_cnt=${#_sr_reply[@]}\n        for (( _sr = 0 ; _sr < ${_sr_cnt} ; _sr++ ))\n        do\n            [ 'x'${_sr_reply[${_sr}]:0:2} == 'x;;' ] &&\n                unset _sr_reply[${_sr}]\n        done\n        eval $2=\\( \\$\\{_sr_reply\\[@\\]\\} \\)\n    fi\n    return 0\n}\n\n# Special format lookup used to query blacklist servers.\n# short_text <ip_address> <array_name>\nshort_text() {\n    local -a _st_reply\n    local -i _st_rc\n    local -i _st_cnt\n    IFS=${NO_WSP}\n# echo 'stxt: '${1}\n  _st_reply=( $(dig +short ${1} -c in -t txt 2>/dev/null) )\n  _st_rc=$?\n  if [ ${_st_rc} -ne 0 ]\n  then\n    _trace_log[${#_trace_log[@]}]='##Text lookup error '${_st_rc}' on '${1}'##'\n# [ ${_st_rc} -ne 9 ] && pend_drop\n        return ${_st_rc}\n    else\n        # Some versions of 'dig' return warnings on stdout.\n        _st_cnt=${#_st_reply[@]}\n        for (( _st = 0 ; _st < ${#_st_cnt} ; _st++ ))\n        do\n            [ 'x'${_st_reply[${_st}]:0:2} == 'x;;' ] &&\n                unset _st_reply[${_st}]\n        done\n        eval $2=\\( \\$\\{_st_reply\\[@\\]\\} \\)\n    fi\n    return 0\n}\n\n# The long forms, a.k.a., the parse it yourself versions\n\n# RFC 2782   Service lookups\n# dig +noall +nofail +answer _ldap._tcp.openldap.org -t srv\n# _<service>._<protocol>.<domain_name>\n# _ldap._tcp.openldap.org. 3600   IN     SRV    0 0 389 ldap.openldap.org.\n# domain TTL Class SRV Priority Weight Port Target\n\n# Forward lookup :: Name -> poor man's zone transfer\n# long_fwd <domain_name> <array_name>\nlong_fwd() {\n    local -a _lf_reply\n    local -i _lf_rc\n    local -i _lf_cnt\n    IFS=${NO_WSP}\necho -n ':'\n# echo 'lfwd: '${1}\n  _lf_reply=( $(\n     dig +noall +nofail +answer +authority +additional \\\n         ${1} -t soa ${1} -t mx ${1} -t any 2>/dev/null) )\n  _lf_rc=$?\n  if [ ${_lf_rc} -ne 0 ]\n  then\n    _trace_log[${#_trace_log[@]}]='# Zone lookup err '${_lf_rc}' on '${1}' #'\n# [ ${_lf_rc} -ne 9 ] && pend_drop\n        return ${_lf_rc}\n    else\n        # Some versions of 'dig' return warnings on stdout.\n        _lf_cnt=${#_lf_reply[@]}\n        for (( _lf = 0 ; _lf < ${_lf_cnt} ; _lf++ ))\n        do\n            [ 'x'${_lf_reply[${_lf}]:0:2} == 'x;;' ] &&\n                unset _lf_reply[${_lf}]\n        done\n        eval $2=\\( \\$\\{_lf_reply\\[@\\]\\} \\)\n    fi\n    return 0\n}\n#  The reverse lookup domain name corresponding to the IPv6 address:\n#      4321:0:1:2:3:4:567:89ab\n#  would be (nibble, I.E: Hexdigit) reversed:\n#  b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.\n\n# Reverse lookup :: Address -> poor man's delegation chain\n# long_rev <rev_ip_address> <array_name>\nlong_rev() {\n    local -a _lr_reply\n    local -i _lr_rc\n    local -i _lr_cnt\n    local _lr_dns\n    _lr_dns=${1}'.in-addr.arpa.'\n    IFS=${NO_WSP}\necho -n ':'\n# echo 'lrev: '${1}\n  _lr_reply=( $(\n       dig +noall +nofail +answer +authority +additional \\\n           ${_lr_dns} -t soa ${_lr_dns} -t any 2>/dev/null) )\n  _lr_rc=$?\n  if [ ${_lr_rc} -ne 0 ]\n  then\n    _trace_log[${#_trace_log[@]}]='# Deleg lkp error '${_lr_rc}' on '${1}' #'\n# [ ${_lr_rc} -ne 9 ] && pend_drop\n        return ${_lr_rc}\n    else\n        # Some versions of 'dig' return warnings on stdout.\n        _lr_cnt=${#_lr_reply[@]}\n        for (( _lr = 0 ; _lr < ${_lr_cnt} ; _lr++ ))\n        do\n            [ 'x'${_lr_reply[${_lr}]:0:2} == 'x;;' ] &&\n                unset _lr_reply[${_lr}]\n        done\n        eval $2=\\( \\$\\{_lr_reply\\[@\\]\\} \\)\n    fi\n    return 0\n}\n\n# # # Application specific functions # # #\n\n# Mung a possible name; suppresses root and TLDs.\n# name_fixup <string>\nname_fixup(){\n    local -a _nf_tmp\n    local -i _nf_end\n    local _nf_str\n    local IFS\n    _nf_str=$(to_lower ${1})\n    _nf_str=$(to_dot ${_nf_str})\n    _nf_end=${#_nf_str}-1\n    [ ${_nf_str:${_nf_end}} != '.' ] &&\n        _nf_str=${_nf_str}'.'\n    IFS=${ADR_IFS}\n    _nf_tmp=( ${_nf_str} )\n    IFS=${WSP_IFS}\n    _nf_end=${#_nf_tmp[@]}\n    case ${_nf_end} in\n    0) # No dots, only dots.\n        echo\n        return 1\n    ;;\n    1) # Only a TLD.\n        echo\n        return 1\n    ;;\n    2) # Maybe okay.\n       echo ${_nf_str}\n       return 0\n       # Needs a lookup table?\n       if [ ${#_nf_tmp[1]} -eq 2 ]\n       then # Country coded TLD.\n           echo\n           return 1\n       else\n           echo ${_nf_str}\n           return 0\n       fi\n    ;;\n    esac\n    echo ${_nf_str}\n    return 0\n}\n\n# Grope and mung original input(s).\nsplit_input() {\n    [ ${#uc_name[@]} -gt 0 ] &#124;&#124; return 0\n    local -i _si_cnt\n    local -i _si_len\n    local _si_str\n    unique_lines uc_name uc_name\n    _si_cnt=${#uc_name[@]}\n    for (( _si = 0 ; _si < _si_cnt ; _si++ ))\n    do\n        _si_str=${uc_name[$_si]}\n        if is_address ${_si_str}\n        then\n            uc_address[${#uc_address[@]}]=${_si_str}\n            unset uc_name[$_si]\n        else\n            if ! uc_name[$_si]=$(name_fixup ${_si_str})\n            then\n                unset ucname[$_si]\n            fi\n        fi\n    done\n  uc_name=( ${uc_name[@]} )\n  _si_cnt=${#uc_name[@]}\n  _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd name input(s).#'\n  _si_cnt=${#uc_address[@]}\n  _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd addr input(s).#'\n    return 0\n}\n\n# # # Discovery functions -- recursively interlocked by external data # # #\n# # # The leading 'if list is empty; return 0' in each is required. # # #\n\n# Recursion limiter\n# limit_chk() <next_level>\nlimit_chk() {\n    local -i _lc_lmt\n    # Check indirection limit.\n    if [ ${indirect} -eq 0 ] &#124;&#124; [ $# -eq 0 ]\n    then\n        # The 'do-forever' choice\n        echo 1                 # Any value will do.\n        return 0               # OK to continue.\n    else\n        # Limiting is in effect.\n        if [ ${indirect} -lt ${1} ]\n        then\n            echo ${1}          # Whatever.\n            return 1           # Stop here.\n        else\n            _lc_lmt=${1}+1     # Bump the given limit.\n            echo ${_lc_lmt}    # Echo it.\n            return 0           # OK to continue.\n        fi\n    fi\n}\n\n# For each name in uc_name:\n#     Move name to chk_name.\n#     Add addresses to uc_address.\n#     Pend expand_input_address.\n#     Repeat until nothing new found.\n# expand_input_name <indirection_limit>\nexpand_input_name() {\n    [ ${#uc_name[@]} -gt 0 ] &#124;&#124; return 0\n    local -a _ein_addr\n    local -a _ein_new\n    local -i _ucn_cnt\n    local -i _ein_cnt\n    local _ein_tst\n    _ucn_cnt=${#uc_name[@]}\n\n    if  ! _ein_cnt=$(limit_chk ${1})\n    then\n        return 0\n    fi\n\n    for (( _ein = 0 ; _ein < _ucn_cnt ; _ein++ ))\n    do\n        if short_fwd ${uc_name[${_ein}]} _ein_new\n        then\n          for (( _ein_cnt = 0 ; _ein_cnt < ${#_ein_new[@]}; _ein_cnt++ ))\n          do\n              _ein_tst=${_ein_new[${_ein_cnt}]}\n              if is_address ${_ein_tst}\n              then\n                  _ein_addr[${#_ein_addr[@]}]=${_ein_tst}\n              fi\n    done\n        fi\n    done\n    unique_lines _ein_addr _ein_addr     # Scrub duplicates.\n    edit_exact chk_address _ein_addr     # Scrub pending detail.\n    edit_exact known_address _ein_addr   # Scrub already detailed.\n if [ ${#_ein_addr[@]} -gt 0 ]        # Anything new?\n then\n   uc_address=( ${uc_address[@]} ${_ein_addr[@]} )\n   pend_func expand_input_address ${1}\n   _trace_log[${#_trace_log[@]}]='#Add '${#_ein_addr[@]}' unchkd addr inp.#'\n    fi\n    edit_exact chk_name uc_name          # Scrub pending detail.\n    edit_exact known_name uc_name        # Scrub already detailed.\n    if [ ${#uc_name[@]} -gt 0 ]\n    then\n        chk_name=( ${chk_name[@]} ${uc_name[@]}  )\n        pend_func detail_each_name ${1}\n    fi\n    unset uc_name[@]\n    return 0\n}\n\n# For each address in uc_address:\n#     Move address to chk_address.\n#     Add names to uc_name.\n#     Pend expand_input_name.\n#     Repeat until nothing new found.\n# expand_input_address <indirection_limit>\nexpand_input_address() {\n    [ ${#uc_address[@]} -gt 0 ] &#124;&#124; return 0\n    local -a _eia_addr\n    local -a _eia_name\n    local -a _eia_new\n    local -i _uca_cnt\n    local -i _eia_cnt\n    local _eia_tst\n    unique_lines uc_address _eia_addr\n    unset uc_address[@]\n    edit_exact been_there_addr _eia_addr\n    _uca_cnt=${#_eia_addr[@]}\n    [ ${_uca_cnt} -gt 0 ] &&\n        been_there_addr=( ${been_there_addr[@]} ${_eia_addr[@]} )\n\n    for (( _eia = 0 ; _eia < _uca_cnt ; _eia++ ))\n     do\n       if short_rev ${_eia_addr[${_eia}]} _eia_new\n       then\n         for (( _eia_cnt = 0 ; _eia_cnt < ${#_eia_new[@]} ; _eia_cnt++ ))\n         do\n           _eia_tst=${_eia_new[${_eia_cnt}]}\n           if _eia_tst=$(name_fixup ${_eia_tst})\n           then\n             _eia_name[${#_eia_name[@]}]=${_eia_tst}\n       fi\n     done\n           fi\n    done\n    unique_lines _eia_name _eia_name     # Scrub duplicates.\n    edit_exact chk_name _eia_name        # Scrub pending detail.\n    edit_exact known_name _eia_name      # Scrub already detailed.\n if [ ${#_eia_name[@]} -gt 0 ]        # Anything new?\n then\n   uc_name=( ${uc_name[@]} ${_eia_name[@]} )\n   pend_func expand_input_name ${1}\n   _trace_log[${#_trace_log[@]}]='#Add '${#_eia_name[@]}' unchkd name inp.#'\n    fi\n    edit_exact chk_address _eia_addr     # Scrub pending detail.\n    edit_exact known_address _eia_addr   # Scrub already detailed.\n    if [ ${#_eia_addr[@]} -gt 0 ]        # Anything new?\n    then\n        chk_address=( ${chk_address[@]} ${_eia_addr[@]} )\n        pend_func detail_each_address ${1}\n    fi\n    return 0\n}\n\n# The parse-it-yourself zone reply.\n# The input is the chk_name list.\n# detail_each_name <indirection_limit>\ndetail_each_name() {\n    [ ${#chk_name[@]} -gt 0 ] &#124;&#124; return 0\n    local -a _den_chk       # Names to check\n    local -a _den_name      # Names found here\n    local -a _den_address   # Addresses found here\n    local -a _den_pair      # Pairs found here\n    local -a _den_rev       # Reverse pairs found here\n    local -a _den_tmp       # Line being parsed\n    local -a _den_auth      # SOA contact being parsed\n    local -a _den_new       # The zone reply\n    local -a _den_pc        # Parent-Child gets big fast\n    local -a _den_ref       # So does reference chain\n    local -a _den_nr        # Name-Resource can be big\n    local -a _den_na        # Name-Address\n    local -a _den_ns        # Name-Service\n    local -a _den_achn      # Chain of Authority\n    local -i _den_cnt       # Count of names to detail\n    local -i _den_lmt       # Indirection limit\n    local _den_who          # Named being processed\n    local _den_rec          # Record type being processed\n    local _den_cont         # Contact domain\n    local _den_str          # Fixed up name string\n    local _den_str2         # Fixed up reverse\n    local IFS=${WSP_IFS}\n\n    # Local, unique copy of names to check\n    unique_lines chk_name _den_chk\n    unset chk_name[@]       # Done with globals.\n\n    # Less any names already known\n    edit_exact known_name _den_chk\n    _den_cnt=${#_den_chk[@]}\n\n    # If anything left, add to known_name.\n    [ ${_den_cnt} -gt 0 ] &&\n        known_name=( ${known_name[@]} ${_den_chk[@]} )\n\n    # for the list of (previously) unknown names . . .\n    for (( _den = 0 ; _den < _den_cnt ; _den++ ))\n    do\n        _den_who=${_den_chk[${_den}]}\n        if long_fwd ${_den_who} _den_new\n        then\n            unique_lines _den_new _den_new\n            if [ ${#_den_new[@]} -eq 0 ]\n            then\n                _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}\n            fi\n\n            # Parse each line in the reply.\n            for (( _line = 0 ; _line < ${#_den_new[@]} ; _line++ ))\n            do\n                IFS=${NO_WSP}$'\\x09'$'\\x20'\n                _den_tmp=( ${_den_new[${_line}]} )\n                IFS=${WSP_IFS}\n              # If usable record and not a warning message . . .\n              if [ ${#_den_tmp[@]} -gt 4 ] && [ 'x'${_den_tmp[0]} != 'x;;' ]\n              then\n                    _den_rec=${_den_tmp[3]}\n                    _den_nr[${#_den_nr[@]}]=${_den_who}' '${_den_rec}\n                    # Begin at RFC1033 (+++)\n                    case ${_den_rec} in\n\n#<name> [<ttl>]  [<class>] SOA <origin> <person>\n                    SOA) # Start Of Authority\n    if _den_str=$(name_fixup ${_den_tmp[0]})\n    then\n      _den_name[${#_den_name[@]}]=${_den_str}\n      _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str}' SOA'\n      # SOA origin -- domain name of master zone record\n      if _den_str2=$(name_fixup ${_den_tmp[4]})\n      then\n        _den_name[${#_den_name[@]}]=${_den_str2}\n        _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str2}' SOA.O'\n      fi\n      # Responsible party e-mail address (possibly bogus).\n      # Possibility of first.last@domain.name ignored.\n      set -f\n      if _den_str2=$(name_fixup ${_den_tmp[5]})\n      then\n        IFS=${ADR_IFS}\n        _den_auth=( ${_den_str2} )\n        IFS=${WSP_IFS}\n        if [ ${#_den_auth[@]} -gt 2 ]\n        then\n          _den_cont=${_den_auth[1]}\n          for (( _auth = 2 ; _auth < ${#_den_auth[@]} ; _auth++ ))\n          do\n            _den_cont=${_den_cont}'.'${_den_auth[${_auth}]}\n          done\n          _den_name[${#_den_name[@]}]=${_den_cont}'.'\n          _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_cont}'. SOA.C'\n                                fi\n        fi\n        set +f\n                        fi\n                    ;;\n\n      A) # IP(v4) Address Record\n      if _den_str=$(name_fixup ${_den_tmp[0]})\n      then\n        _den_name[${#_den_name[@]}]=${_den_str}\n        _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}\n        _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}\n        _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' A'\n      else\n        _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'\n        _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}\n        _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain A'\n      fi\n      _den_address[${#_den_address[@]}]=${_den_tmp[4]}\n      _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}\n             ;;\n\n             NS) # Name Server Record\n             # Domain name being serviced (may be other than current)\n               if _den_str=$(name_fixup ${_den_tmp[0]})\n                 then\n                   _den_name[${#_den_name[@]}]=${_den_str}\n                   _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' NS'\n\n             # Domain name of service provider\n             if _den_str2=$(name_fixup ${_den_tmp[4]})\n             then\n               _den_name[${#_den_name[@]}]=${_den_str2}\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' NSH'\n               _den_ns[${#_den_ns[@]}]=${_den_str2}' NS'\n               _den_pc[${#_den_pc[@]}]=${_den_str}' '${_den_str2}\n              fi\n               fi\n                    ;;\n\n             MX) # Mail Server Record\n                 # Domain name being serviced (wildcards not handled here)\n             if _den_str=$(name_fixup ${_den_tmp[0]})\n             then\n               _den_name[${#_den_name[@]}]=${_den_str}\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MX'\n             fi\n             # Domain name of service provider\n             if _den_str=$(name_fixup ${_den_tmp[5]})\n             then\n               _den_name[${#_den_name[@]}]=${_den_str}\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MXH'\n               _den_ns[${#_den_ns[@]}]=${_den_str}' MX'\n               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}\n             fi\n                    ;;\n\n             PTR) # Reverse address record\n                  # Special name\n             if _den_str=$(name_fixup ${_den_tmp[0]})\n             then\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' PTR'\n               # Host name (not a CNAME)\n               if _den_str2=$(name_fixup ${_den_tmp[4]})\n               then\n                 _den_rev[${#_den_rev[@]}]=${_den_str}' '${_den_str2}\n                 _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' PTRH'\n                 _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}\n               fi\n             fi\n                    ;;\n\n             AAAA) # IP(v6) Address Record\n             if _den_str=$(name_fixup ${_den_tmp[0]})\n             then\n               _den_name[${#_den_name[@]}]=${_den_str}\n               _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}\n               _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' AAAA'\n               else\n                 _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'\n                 _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}\n                 _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain'\n               fi\n               # No processing for IPv6 addresses\n               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}\n                    ;;\n\n             CNAME) # Alias name record\n                    # Nickname\n             if _den_str=$(name_fixup ${_den_tmp[0]})\n             then\n               _den_name[${#_den_name[@]}]=${_den_str}\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CNAME'\n               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}\n             fi\n                    # Hostname\n             if _den_str=$(name_fixup ${_den_tmp[4]})\n             then\n               _den_name[${#_den_name[@]}]=${_den_str}\n               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CHOST'\n               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}\n             fi\n                    ;;\n#            TXT)\n#            ;;\n                    esac\n                fi\n            done\n        else # Lookup error == 'A' record 'unknown address'\n            _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}\n        fi\n    done\n\n    # Control dot array growth.\n    unique_lines _den_achn _den_achn      # Works best, all the same.\n    edit_exact auth_chain _den_achn       # Works best, unique items.\n    if [ ${#_den_achn[@]} -gt 0 ]\n    then\n        IFS=${NO_WSP}\n        auth_chain=( ${auth_chain[@]} ${_den_achn[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    unique_lines _den_ref _den_ref      # Works best, all the same.\n    edit_exact ref_chain _den_ref       # Works best, unique items.\n    if [ ${#_den_ref[@]} -gt 0 ]\n    then\n        IFS=${NO_WSP}\n        ref_chain=( ${ref_chain[@]} ${_den_ref[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    unique_lines _den_na _den_na\n    edit_exact name_address _den_na\n    if [ ${#_den_na[@]} -gt 0 ]\n    then\n        IFS=${NO_WSP}\n        name_address=( ${name_address[@]} ${_den_na[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    unique_lines _den_ns _den_ns\n    edit_exact name_srvc _den_ns\n    if [ ${#_den_ns[@]} -gt 0 ]\n    then\n        IFS=${NO_WSP}\n        name_srvc=( ${name_srvc[@]} ${_den_ns[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    unique_lines _den_nr _den_nr\n    edit_exact name_resource _den_nr\n    if [ ${#_den_nr[@]} -gt 0 ]\n    then\n        IFS=${NO_WSP}\n        name_resource=( ${name_resource[@]} ${_den_nr[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    unique_lines _den_pc _den_pc\n    edit_exact parent_child _den_pc\n    if [ ${#_den_pc[@]} -gt 0 ]\n    then\n        IFS=${NO_WSP}\n        parent_child=( ${parent_child[@]} ${_den_pc[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    # Update list known_pair (Address and Name).\n    unique_lines _den_pair _den_pair\n    edit_exact known_pair _den_pair\n    if [ ${#_den_pair[@]} -gt 0 ]  # Anything new?\n    then\n        IFS=${NO_WSP}\n        known_pair=( ${known_pair[@]} ${_den_pair[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    # Update list of reverse pairs.\n    unique_lines _den_rev _den_rev\n    edit_exact reverse_pair _den_rev\n    if [ ${#_den_rev[@]} -gt 0 ]   # Anything new?\n    then\n        IFS=${NO_WSP}\n        reverse_pair=( ${reverse_pair[@]} ${_den_rev[@]} )\n        IFS=${WSP_IFS}\n    fi\n\n    # Check indirection limit -- give up if reached.\n    if ! _den_lmt=$(limit_chk ${1})\n    then\n        return 0\n    fi\n\n# Execution engine is LIFO. Order of pend operations is important.\n# Did we define any new addresses?\nunique_lines _den_address _den_address    # Scrub duplicates.\nedit_exact known_address _den_address     # Scrub already processed.\nedit_exact un_address _den_address        # Scrub already waiting.\nif [ ${#_den_address[@]} -gt 0 ]          # Anything new?\nthen\n  uc_address=( ${uc_address[@]} ${_den_address[@]} )\n  pend_func expand_input_address ${_den_lmt}\n  _trace_log[${#_trace_log[@]}]='# Add '${#_den_address[@]}' unchkd addr. #'\n    fi\n\n# Did we find any new names?\nunique_lines _den_name _den_name          # Scrub duplicates.\nedit_exact known_name _den_name           # Scrub already processed.\nedit_exact uc_name _den_name              # Scrub already waiting.\nif [ ${#_den_name[@]} -gt 0 ]             # Anything new?\nthen\n  uc_name=( ${uc_name[@]} ${_den_name[@]} )\n  pend_func expand_input_name ${_den_lmt}\n  _trace_log[${#_trace_log[@]}]='#Added '${#_den_name[@]}' unchkd name#'\n    fi\n    return 0\n}\n\n# The parse-it-yourself delegation reply\n# Input is the chk_address list.\n# detail_each_address <indirection_limit>\ndetail_each_address() {\n    [ ${#chk_address[@]} -gt 0 ] &#124;&#124; return 0\n    unique_lines chk_address chk_address\n    edit_exact known_address chk_address\n    if [ ${#chk_address[@]} -gt 0 ]\n    then\n        known_address=( ${known_address[@]} ${chk_address[@]} )\n        unset chk_address[@]\n    fi\n    return 0\n}\n\n# # # Application specific output functions # # #\n\n# Pretty print the known pairs.\nreport_pairs() {\n    echo\n    echo 'Known network pairs.'\n    col_print known_pair 2 5 30\n\n    if [ ${#auth_chain[@]} -gt 0 ]\n    then\n        echo\n        echo 'Known chain of authority.'\n        col_print auth_chain 2 5 30 55\n    fi\n\n    if [ ${#reverse_pair[@]} -gt 0 ]\n    then\n        echo\n        echo 'Known reverse pairs.'\n        col_print reverse_pair 2 5 55\n    fi\n    return 0\n}\n\n# Check an address against the list of blacklist servers.\n# A good place to capture for GraphViz: address->status(server(reports))\n# check_lists <ip_address>\ncheck_lists() {\n    [ $# -eq 1 ] &#124;&#124; return 1\n    local -a _cl_fwd_addr\n    local -a _cl_rev_addr\n    local -a _cl_reply\n    local -i _cl_rc\n    local -i _ls_cnt\n    local _cl_dns_addr\n    local _cl_lkup\n\n    split_ip ${1} _cl_fwd_addr _cl_rev_addr\n    _cl_dns_addr=$(dot_array _cl_rev_addr)'.'\n    _ls_cnt=${#list_server[@]}\n    echo '    Checking address '${1}\n    for (( _cl = 0 ; _cl < _ls_cnt ; _cl++ ))\n    do\n      _cl_lkup=${_cl_dns_addr}${list_server[${_cl}]}\n      if short_text ${_cl_lkup} _cl_reply\n      then\n        if [ ${#_cl_reply[@]} -gt 0 ]\n        then\n          echo '        Records from '${list_server[${_cl}]}\n          address_hits[${#address_hits[@]}]=${1}' '${list_server[${_cl}]}\n          _hs_RC=2\n          for (( _clr = 0 ; _clr < ${#_cl_reply[@]} ; _clr++ ))\n          do\n            echo '            '${_cl_reply[${_clr}]}\n          done\n        fi\n      fi\n    done\n    return 0\n}\n\n# # # The usual application glue # # #\n\n# Who did it?\ncredits() {\n   echo\n   echo 'Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz'\n}\n\n# How to use it?\n# (See also, \"Quickstart\" at end of script.)\nusage() {\n    cat <<-'_usage_statement_'\n    The script is_spammer.bash requires either one or two arguments.\n\n    arg 1) May be one of:\n        a) A domain name\n        b) An IPv4 address\n        c) The name of a file with any mix of names\n           and addresses, one per line.\n\n    arg 2) May be one of:\n        a) A Blacklist server domain name\n        b) The name of a file with Blacklist server\n           domain names, one per line.\n        c) If not present, a default list of (free)\n           Blacklist servers is used.\n        d) If a filename of an empty, readable, file\n           is given,\n           Blacklist server lookup is disabled.\n\n    All script output is written to stdout.\n\n    Return codes: 0 -> All OK, 1 -> Script failure,\n                  2 -> Something is Blacklisted.\n\n    Requires the external program 'dig' from the 'bind-9'\n    set of DNS programs.  See: http://www.isc.org\n\n    The domain name lookup depth limit defaults to 2 levels.\n    Set the environment variable SPAMMER_LIMIT to change.\n    SPAMMER_LIMIT=0 means 'unlimited'\n\n    Limit may also be set on the command-line.\n    If arg#1 is an integer, the limit is set to that value\n    and then the above argument rules are applied.\n\n    Setting the environment variable 'SPAMMER_DATA' to a filename\n    will cause the script to write a GraphViz graphic file.\n\n    For the development version;\n    Setting the environment variable 'SPAMMER_TRACE' to a filename\n    will cause the execution engine to log a function call trace.\n\n_usage_statement_\n}\n\n# The default list of Blacklist servers:\n# Many choices, see: http://www.spews.org/lists.html\n\ndeclare -a default_servers\n# See: http://www.spamhaus.org (Conservative, well maintained)\ndefault_servers[0]='sbl-xbl.spamhaus.org'\n# See: http://ordb.org (Open mail relays)\ndefault_servers[1]='relays.ordb.org'\n# See: http://www.spamcop.net/ (You can report spammers here)\ndefault_servers[2]='bl.spamcop.net'\n# See: http://www.spews.org (An 'early detect' system)\ndefault_servers[3]='l2.spews.dnsbl.sorbs.net'\n# See: http://www.dnsbl.us.sorbs.net/using.shtml\ndefault_servers[4]='dnsbl.sorbs.net'\n# See: http://dsbl.org/usage (Various mail relay lists)\ndefault_servers[5]='list.dsbl.org'\ndefault_servers[6]='multihop.dsbl.org'\ndefault_servers[7]='unconfirmed.dsbl.org'\n\n# User input argument #1\nsetup_input() {\n    if [ -e ${1} ] && [ -r ${1} ]  # Name of readable file\n    then\n        file_to_array ${1} uc_name\n        echo 'Using filename >'${1}'< as input.'\n    else\n        if is_address ${1}          # IP address?\n        then\n            uc_address=( ${1} )\n            echo 'Starting with address >'${1}'<'\n        else                       # Must be a name.\n            uc_name=( ${1} )\n            echo 'Starting with domain name >'${1}'<'\n        fi\n    fi\n    return 0\n}\n\n# User input argument #2\nsetup_servers() {\n    if [ -e ${1} ] && [ -r ${1} ]  # Name of a readable file\n    then\n        file_to_array ${1} list_server\n        echo 'Using filename >'${1}'< as blacklist server list.'\n    else\n        list_server=( ${1} )\n        echo 'Using blacklist server >'${1}'<'\n    fi\n    return 0\n}\n\n# User environment variable SPAMMER_TRACE\nlive_log_die() {\n    if [ ${SPAMMER_TRACE:=} ]    # Wants trace log?\n    then\n        if [ ! -e ${SPAMMER_TRACE} ]\n        then\n            if ! touch ${SPAMMER_TRACE} 2>/dev/null\n            then\n                pend_func echo $(printf '%q\\n' \\\n                'Unable to create log file >'${SPAMMER_TRACE}'<')\n                pend_release\n                exit 1\n            fi\n            _log_file=${SPAMMER_TRACE}\n            _pend_hook_=trace_logger\n            _log_dump=dump_log\n        else\n            if [ ! -w ${SPAMMER_TRACE} ]\n            then\n                pend_func echo $(printf '%q\\n' \\\n                'Unable to write log file >'${SPAMMER_TRACE}'<')\n                pend_release\n                exit 1\n            fi\n            _log_file=${SPAMMER_TRACE}\n            echo '' > ${_log_file}\n            _pend_hook_=trace_logger\n            _log_dump=dump_log\n        fi\n    fi\n    return 0\n}\n\n# User environment variable SPAMMER_DATA\ndata_capture() {\n    if [ ${SPAMMER_DATA:=} ]    # Wants a data dump?\n    then\n        if [ ! -e ${SPAMMER_DATA} ]\n        then\n            if ! touch ${SPAMMER_DATA} 2>/dev/null\n            then\n                pend_func echo $(printf '%q]n' \\\n                'Unable to create data output file >'${SPAMMER_DATA}'<')\n                pend_release\n                exit 1\n            fi\n            _dot_file=${SPAMMER_DATA}\n            _dot_dump=dump_dot\n        else\n            if [ ! -w ${SPAMMER_DATA} ]\n            then\n                pend_func echo $(printf '%q\\n' \\\n                'Unable to write data output file >'${SPAMMER_DATA}'<')\n                pend_release\n                exit 1\n            fi\n            _dot_file=${SPAMMER_DATA}\n            _dot_dump=dump_dot\n        fi\n    fi\n    return 0\n}\n\n# Grope user specified arguments.\ndo_user_args() {\n    if [ $# -gt 0 ] && is_number $1\n    then\n        indirect=$1\n        shift\n    fi\n\n    case $# in                     # Did user treat us well?\n        1)\n            if ! setup_input $1    # Needs error checking.\n            then\n                pend_release\n                $_log_dump\n                exit 1\n            fi\n            list_server=( ${default_servers[@]} )\n            _list_cnt=${#list_server[@]}\n            echo 'Using default blacklist server list.'\n            echo 'Search depth limit: '${indirect}\n            ;;\n        2)\n            if ! setup_input $1    # Needs error checking.\n            then\n                pend_release\n                $_log_dump\n                exit 1\n            fi\n            if ! setup_servers $2  # Needs error checking.\n            then\n                pend_release\n                $_log_dump\n                exit 1\n            fi\n            echo 'Search depth limit: '${indirect}\n            ;;\n        *)\n            pend_func usage\n            pend_release\n            $_log_dump\n            exit 1\n            ;;\n    esac\n    return 0\n}\n\n# A general purpose debug tool.\n# list_array <array_name>\nlist_array() {\n    [ $# -eq 1 ] &#124;&#124; return 1  # One argument required.\n\n    local -a _la_lines\n    set -f\n    local IFS=${NO_WSP}\n    eval _la_lines=\\(\\ \\$\\{$1\\[@\\]\\}\\ \\)\n    echo\n    echo \"Element count \"${#_la_lines[@]}\" array \"${1}\n    local _ln_cnt=${#_la_lines[@]}\n\n    for (( _i = 0; _i < ${_ln_cnt}; _i++ ))\n    do\n        echo 'Element '$_i' >'${_la_lines[$_i]}'<'\n    done\n    set +f\n    return 0\n}\n\n# # # 'Hunt the Spammer' program code # # #\npend_init                               # Ready stack engine.\npend_func credits                       # Last thing to print.\n\n# # # Deal with user # # #\nlive_log_die                            # Setup debug trace log.\ndata_capture                            # Setup data capture file.\necho\ndo_user_args $@\n\n# # # Haven't exited yet - There is some hope # # #\n# Discovery group - Execution engine is LIFO - pend\n# in reverse order of execution.\n_hs_RC=0                                # Hunt the Spammer return code\npend_mark\n    pend_func report_pairs              # Report name-address pairs.\n\n    # The two detail_* are mutually recursive functions.\n    # They also pend expand_* functions as required.\n    # These two (the last of ???) exit the recursion.\n    pend_func detail_each_address       # Get all resources of addresses.\n    pend_func detail_each_name          # Get all resources of names.\n\n    #  The two expand_* are mutually recursive functions,\n    #+ which pend additional detail_* functions as required.\n    pend_func expand_input_address 1    # Expand input names by address.\n    pend_func expand_input_name 1       # #xpand input addresses by name.\n\n    # Start with a unique set of names and addresses.\n    pend_func unique_lines uc_address uc_address\n    pend_func unique_lines uc_name uc_name\n\n    # Separate mixed input of names and addresses.\n    pend_func split_input\npend_release\n\n# # # Pairs reported -- Unique list of IP addresses found\necho\n_ip_cnt=${#known_address[@]}\nif [ ${#list_server[@]} -eq 0 ]\nthen\n    echo 'Blacklist server list empty, none checked.'\nelse\n    if [ ${_ip_cnt} -eq 0 ]\n    then\n        echo 'Known address list empty, none checked.'\n    else\n        _ip_cnt=${_ip_cnt}-1   # Start at top.\n        echo 'Checking Blacklist servers.'\n        for (( _ip = _ip_cnt ; _ip >= 0 ; _ip-- ))\n        do\n          pend_func check_lists $( printf '%q\\n' ${known_address[$_ip]} )\n        done\n    fi\nfi\npend_release\n$_dot_dump                   # Graphics file dump\n$_log_dump                   # Execution trace\necho\n\n##############################\n# Example output from script #\n##############################\n:<<-'_is_spammer_outputs_'\n\n./is_spammer.bash 0 web4.alojamentos7.com\n\nStarting with domain name >web4.alojamentos7.com<\nUsing default blacklist server list.\nSearch depth limit: 0\n.:....::::...:::...:::.......::..::...:::.......::\nKnown network pairs.\n    66.98.208.97             web4.alojamentos7.com.\n    66.98.208.97             ns1.alojamentos7.com.\n    69.56.202.147            ns2.alojamentos.ws.\n    66.98.208.97             alojamentos7.com.\n    66.98.208.97             web.alojamentos7.com.\n    69.56.202.146            ns1.alojamentos.ws.\n    69.56.202.146            alojamentos.ws.\n    66.235.180.113           ns1.alojamentos.org.\n    66.235.181.192           ns2.alojamentos.org.\n    66.235.180.113           alojamentos.org.\n    66.235.180.113           web6.alojamentos.org.\n    216.234.234.30           ns1.theplanet.com.\n    12.96.160.115            ns2.theplanet.com.\n    216.185.111.52           mail1.theplanet.com.\n    69.56.141.4              spooling.theplanet.com.\n    216.185.111.40           theplanet.com.\n    216.185.111.40           www.theplanet.com.\n    216.185.111.52           mail.theplanet.com.\n\nChecking Blacklist servers.\n  Checking address 66.98.208.97\n      Records from dnsbl.sorbs.net\n  \"Spam Received See: http://www.dnsbl.sorbs.net/lookup.shtml?66.98.208.97\"\n    Checking address 69.56.202.147\n    Checking address 69.56.202.146\n    Checking address 66.235.180.113\n    Checking address 66.235.181.192\n    Checking address 216.185.111.40\n    Checking address 216.234.234.30\n    Checking address 12.96.160.115\n    Checking address 216.185.111.52\n    Checking address 69.56.141.4\n\nAdvanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz\n\n_is_spammer_outputs_\n\nexit ${_hs_RC}\n\n####################################################\n#  The script ignores everything from here on down #\n#+ because of the 'exit' command, just above.      #\n####################################################\n\nQuickstart\n==========\n\n Prerequisites\n\n  Bash version 2.05b or 3.00 (bash --version)\n  A version of Bash which supports arrays. Array \n  support is included by default Bash configurations.\n\n  'dig,' version 9.x.x (dig $HOSTNAME, see first line of output)\n  A version of dig which supports the +short options. \n  See: dig_wrappers.bash for details.\n\n Optional Prerequisites\n\n  'named,' a local DNS caching program. Any flavor will do.\n  Do twice: dig $HOSTNAME \n  Check near bottom of output for: SERVER: 127.0.0.1#53\n  That means you have one running.\n\n Optional Graphics Support\n\n  'date,' a standard *nix thing. (date -R)\n\n  dot Program to convert graphic description file to a \n  diagram. (dot -V)\n  A part of the Graph-Viz set of programs.\n  See: [http://www.research.att.com/sw/tools/graphviz&#124;&#124;GraphViz]\n\n  'dotty,' a visual editor for graphic description files.\n  Also a part of the Graph-Viz set of programs.\n\n Quick Start\n\nIn the same directory as the is_spammer.bash script; \nDo: ./is_spammer.bash\n\n Usage Details\n\n1\\. Blacklist server choices.\n\n  (a) To use default, built-in list: Do nothing.\n\n  (b) To use your own list: \n\n    i. Create a file with a single Blacklist server \n       domain name per line.\n\n    ii. Provide that filename as the last argument to \n        the script.\n\n  (c) To use a single Blacklist server: Last argument \n      to the script.\n\n  (d) To disable Blacklist lookups:\n\n    i. Create an empty file (touch spammer.nul)\n       Your choice of filename.\n\n    ii. Provide the filename of that empty file as the \n        last argument to the script.\n\n2\\. Search depth limit.\n\n  (a) To use the default value of 2: Do nothing.\n\n  (b) To set a different limit: \n      A limit of 0 means: no limit.\n\n    i. export SPAMMER_LIMIT=1\n       or whatever limit you want.\n\n    ii. OR provide the desired limit as the first \n       argument to the script.\n\n3\\. Optional execution trace log.\n\n  (a) To use the default setting of no log output: Do nothing.\n\n  (b) To write an execution trace log:\n      export SPAMMER_TRACE=spammer.log\n      or whatever filename you want.\n\n4\\. Optional graphic description file.\n\n  (a) To use the default setting of no graphic file: Do nothing.\n\n  (b) To write a Graph-Viz graphic description file:\n      export SPAMMER_DATA=spammer.dot\n      or whatever filename you want.\n\n5\\. Where to start the search.\n\n  (a) Starting with a single domain name:\n\n    i. Without a command-line search limit: First \n       argument to script.\n\n    ii. With a command-line search limit: Second \n        argument to script.\n\n  (b) Starting with a single IP address:\n\n    i. Without a command-line search limit: First \n       argument to script.\n\n    ii. With a command-line search limit: Second \n        argument to script.\n\n  (c) Starting with (mixed) multiple name(s) and/or address(es):\n      Create a file with one name or address per line.\n      Your choice of filename.\n\n    i. Without a command-line search limit: Filename as \n       first argument to script.\n\n    ii. With a command-line search limit: Filename as \n        second argument to script.\n\n6\\. What to do with the display output.\n\n  (a) To view display output on screen: Do nothing.\n\n  (b) To save display output to a file: Redirect stdout to a filename.\n\n  (c) To discard display output: Redirect stdout to /dev/null.\n\n7\\. Temporary end of decision making. \n   press RETURN \n   wait (optionally, watch the dots and colons).\n\n8\\. Optionally check the return code.\n\n  (a) Return code 0: All OK\n\n  (b) Return code 1: Script setup failure\n\n  (c) Return code 2: Something was blacklisted.\n\n9\\. Where is my graph (diagram)?\n\nThe script does not directly produce a graph (diagram). \nIt only produces a graphic description file. You can \nprocess the graphic descriptor file that was output \nwith the 'dot' program.\n\nUntil you edit that descriptor file, to describe the \nrelationships you want shown, all that you will get is \na bunch of labeled name and address nodes.\n\nAll of the script's discovered relationships are within \na comment block in the graphic descriptor file, each \nwith a descriptive heading.\n\nThe editing required to draw a line between a pair of \nnodes from the information in the descriptor file may \nbe done with a text editor. \n\nGiven these lines somewhere in the descriptor file:\n\n# Known domain name nodes\n\nN0000 [label=\"guardproof.info.\"] ;\n\nN0002 [label=\"third.guardproof.info.\"] ;\n\n# Known address nodes\n\nA0000 [label=\"61.141.32.197\"] ;\n\n/*\n\n# Known name->address edges\n\nNA0000 third.guardproof.info. 61.141.32.197\n\n# Known parent->child edges\n\nPC0000 guardproof.info. third.guardproof.info.\n\n */\n\nTurn that into the following lines by substituting node \nidentifiers into the relationships:\n\n# Known domain name nodes\n\nN0000 [label=\"guardproof.info.\"] ;\n\nN0002 [label=\"third.guardproof.info.\"] ;\n\n# Known address nodes\n\nA0000 [label=\"61.141.32.197\"] ;\n\n# PC0000 guardproof.info. third.guardproof.info.\n\nN0000->N0002 ;\n\n# NA0000 third.guardproof.info. 61.141.32.197\n\nN0002->A0000 ;\n\n/*\n\n# Known name->address edges\n\nNA0000 third.guardproof.info. 61.141.32.197\n\n# Known parent->child edges\n\nPC0000 guardproof.info. third.guardproof.info.\n\n */\n\nProcess that with the 'dot' program, and you have your \nfirst network diagram.\n\nIn addition to the conventional graphic edges, the \ndescriptor file includes similar format pair-data that \ndescribes services, zone records (sub-graphs?), \nblacklisted addresses, and other things which might be \ninteresting to include in your graph. This additional \ninformation could be displayed as different node \nshapes, colors, line sizes, etc.\n\nThe descriptor file can also be read and edited by a \nBash script (of course). You should be able to find \nmost of the functions required within the \n\"is_spammer.bash\" script.\n\n# End Quickstart.\n\nAdditional Note\n========== ====\n\nMichael Zick points out that there is a \"makeviz.bash\" interactive\nWeb site at rediris.es. Can't give the full URL, since this is not\na publically accessible site.\n```", "```sh #!/bin/bash\n# whx.sh: \"whois\" spammer lookup\n# Author: Walter Dnes\n# Slight revisions (first section) by ABS Guide author.\n# Used in ABS Guide with permission.\n\n# Needs version 3.x or greater of Bash to run (because of =~ operator).\n# Commented by script author and ABS Guide author.\n\nE_BADARGS=85        # Missing command-line arg.\nE_NOHOST=86         # Host not found.\nE_TIMEOUT=87        # Host lookup timed out.\nE_UNDEF=88          # Some other (undefined) error.\n\nHOSTWAIT=10         # Specify up to 10 seconds for host query reply.\n                    # The actual wait may be a bit longer.\nOUTFILE=whois.txt   # Output file.\nPORT=4321\n\nif [ -z \"$1\" ]      # Check for (required) command-line arg.\nthen\n  echo \"Usage: $0 domain name or IP address\"\n  exit $E_BADARGS\nfi\n\nif [[ \"$1\" =~ [a-zA-Z][a-zA-Z]$ ]]  #  Ends in two alpha chars?\nthen                                  #  It's a domain name &&\n                                      #+ must do host lookup.\n  IPADDR=$(host -W $HOSTWAIT $1 &#124; awk '{print $4}')\n                                      #  Doing host lookup\n                                      #+ to get IP address.\n\t\t\t\t      #  Extract final field.\nelse\n  IPADDR=\"$1\"                         #  Command-line arg was IP address.\nfi\n\necho; echo \"IP Address is: \"$IPADDR\"\"; echo\n\nif [ -e \"$OUTFILE\" ]\nthen\n  rm -f \"$OUTFILE\"\n  echo \"Stale output file \\\"$OUTFILE\\\" removed.\"; echo\nfi\n\n#  Sanity checks.\n#  (This section needs more work.)\n#  ===============================\nif [ -z \"$IPADDR\" ]\n# No response.\nthen\n  echo \"Host not found!\"\n  exit $E_NOHOST    # Bail out.\nfi\n\nif [[ \"$IPADDR\" =~ ^[;;] ]]\n#  ;; Connection timed out; no servers could be reached.\nthen\n  echo \"Host lookup timed out!\"\n  exit $E_TIMEOUT   # Bail out.\nfi\n\nif [[ \"$IPADDR\" =~ [(NXDOMAIN)]$ ]]\n#  Host xxxxxxxxx.xxx not found: 3(NXDOMAIN)\nthen\n  echo \"Host not found!\"\n  exit $E_NOHOST    # Bail out.\nfi\n\nif [[ \"$IPADDR\" =~ [(SERVFAIL)]$ ]]\n#  Host xxxxxxxxx.xxx not found: 2(SERVFAIL)\nthen\n  echo \"Host not found!\"\n  exit $E_NOHOST    # Bail out.\nfi\n\n# ======================== Main body of script ========================\n\nAFRINICquery() {\n#  Define the function that queries AFRINIC. Echo a notification to the\n#+ screen, and then run the actual query, redirecting output to $OUTFILE.\n\n  echo \"Searching for $IPADDR in whois.afrinic.net\"\n  whois -h whois.afrinic.net \"$IPADDR\" > $OUTFILE\n\n#  Check for presence of reference to an rwhois.\n#  Warn about non-functional rwhois.infosat.net server\n#+ and attempt rwhois query.\n  if grep -e \"^remarks: .*rwhois\\.[^ ]\\+\" \"$OUTFILE\"\n  then\n    echo \" \" >> $OUTFILE\n    echo \"***\" >> $OUTFILE\n    echo \"***\" >> $OUTFILE\n    echo \"Warning: rwhois.infosat.net was not working \\\n      as of 2005/02/02\" >> $OUTFILE\n    echo \"         when this script was written.\" >> $OUTFILE\n    echo \"***\" >> $OUTFILE\n    echo \"***\" >> $OUTFILE\n    echo \" \" >> $OUTFILE\n    RWHOIS=`grep \"^remarks: .*rwhois\\.[^ ]\\+\" \"$OUTFILE\" &#124; tail -n 1 &#124;\\\n    sed \"s/\\(^.*\\)\\(rwhois\\..*\\)\\(:4.*\\)/\\2/\"`\n    whois -h ${RWHOIS}:${PORT} \"$IPADDR\" >> $OUTFILE\n  fi\n}\n\nAPNICquery() {\n  echo \"Searching for $IPADDR in whois.apnic.net\"\n  whois -h whois.apnic.net \"$IPADDR\" > $OUTFILE\n\n#  Just  about  every  country has its own internet registrar.\n#  I don't normally bother consulting them, because the regional registry\n#+ usually supplies sufficient information.\n#  There are a few exceptions, where the regional registry simply\n#+ refers to the national registry for direct data.\n#  These are Japan and South Korea in APNIC, and Brasil in LACNIC.\n#  The following if statement checks $OUTFILE (whois.txt) for the presence\n#+ of \"KR\" (South Korea) or \"JP\" (Japan) in the country field.\n#  If either is found, the query is re-run against the appropriate\n#+ national registry.\n\n  if grep -E \"^country:[ ]+KR$\" \"$OUTFILE\"\n  then\n    echo \"Searching for $IPADDR in whois.krnic.net\"\n    whois -h whois.krnic.net \"$IPADDR\" >> $OUTFILE\n  elif grep -E \"^country:[ ]+JP$\" \"$OUTFILE\"\n  then\n    echo \"Searching for $IPADDR in whois.nic.ad.jp\"\n    whois -h whois.nic.ad.jp \"$IPADDR\"/e >> $OUTFILE\n  fi\n}\n\nARINquery() {\n  echo \"Searching for $IPADDR in whois.arin.net\"\n  whois -h whois.arin.net \"$IPADDR\" > $OUTFILE\n\n#  Several large internet providers listed by ARIN have their own\n#+ internal whois service, referred to as \"rwhois\".\n#  A large block of IP addresses is listed with the provider\n#+ under the ARIN registry.\n#  To get the IP addresses of 2nd-level ISPs or other large customers,\n#+ one has to refer to the rwhois server on port 4321.\n#  I originally started with a bunch of \"if\" statements checking for\n#+ the larger providers.\n#  This approach is unwieldy, and there's always another rwhois server\n#+ that I didn't know about.\n#  A more elegant approach is to check $OUTFILE for a reference\n#+ to a whois server, parse that server name out of the comment section,\n#+ and re-run the query against the appropriate rwhois server.\n#  The parsing looks a bit ugly, with a long continued line inside\n#+ backticks.\n#  But it only has to be done once, and will work as new servers are added.\n#@   ABS Guide author comment: it isn't all that ugly, and is, in fact,\n#@+  an instructive use of Regular Expressions.\n\n  if grep -E \"^Comment: .*rwhois.[^ ]+\" \"$OUTFILE\"\n  then\n    RWHOIS=`grep -e \"^Comment:.*rwhois\\.[^ ]\\+\" \"$OUTFILE\" &#124; tail -n 1 &#124;\\\n    sed \"s/^\\(.*\\)\\(rwhois\\.[^ ]\\+\\)\\(.*$\\)/\\2/\"`\n    echo \"Searching for $IPADDR in ${RWHOIS}\"\n    whois -h ${RWHOIS}:${PORT} \"$IPADDR\" >> $OUTFILE\n  fi\n}\n\nLACNICquery() {\n  echo \"Searching for $IPADDR in whois.lacnic.net\"\n  whois -h whois.lacnic.net \"$IPADDR\" > $OUTFILE\n\n#  The  following if statement checks $OUTFILE (whois.txt) for\n#+ the presence of \"BR\" (Brasil) in the country field.\n#  If it is found, the query is re-run against whois.registro.br.\n\n  if grep -E \"^country:[ ]+BR$\" \"$OUTFILE\"\n  then\n    echo \"Searching for $IPADDR in whois.registro.br\"\n    whois -h whois.registro.br \"$IPADDR\" >> $OUTFILE\n  fi\n}\n\nRIPEquery() {\n  echo \"Searching for $IPADDR in whois.ripe.net\"\n  whois -h whois.ripe.net \"$IPADDR\" > $OUTFILE\n}\n\n#  Initialize a few variables.\n#  * slash8 is the most significant octet\n#  * slash16 consists of the two most significant octets\n#  * octet2 is the second most significant octet\n\nslash8=`echo $IPADDR &#124; cut -d. -f 1`\n  if [ -z \"$slash8\" ]  # Yet another sanity check.\n  then\n    echo \"Undefined error!\"\n    exit $E_UNDEF\n  fi\nslash16=`echo $IPADDR &#124; cut -d. -f 1-2`\n#                             ^ Period specified as 'cut\" delimiter.\n  if [ -z \"$slash16\" ]\n  then\n    echo \"Undefined error!\"\n    exit $E_UNDEF\n  fi\noctet2=`echo $slash16 &#124; cut -d. -f 2`\n  if [ -z \"$octet2\" ]\n  then\n    echo \"Undefined error!\"\n    exit $E_UNDEF\n  fi\n\n#  Check for various odds and ends of reserved space.\n#  There is no point in querying for those addresses.\n\nif [ $slash8 == 0 ]; then\n  echo $IPADDR is '\"This Network\"' space\\; Not querying\nelif [ $slash8 == 10 ]; then\n  echo $IPADDR is RFC1918 space\\; Not querying\nelif [ $slash8 == 14 ]; then\n  echo $IPADDR is '\"Public Data Network\"' space\\; Not querying\nelif [ $slash8 == 127 ]; then\n  echo $IPADDR is loopback space\\; Not querying\nelif [ $slash16 == 169.254 ]; then\n  echo $IPADDR is link-local space\\; Not querying\nelif [ $slash8 == 172 ] && [ $octet2 -ge 16 ] && [ $octet2 -le 31 ];then\n  echo $IPADDR is RFC1918 space\\; Not querying\nelif [ $slash16 == 192.168 ]; then\n  echo $IPADDR is RFC1918 space\\; Not querying\nelif [ $slash8 -ge 224 ]; then\n  echo $IPADDR is either Multicast or reserved space\\; Not querying\nelif [ $slash8 -ge 200 ] && [ $slash8 -le 201 ]; then LACNICquery \"$IPADDR\"\nelif [ $slash8 -ge 202 ] && [ $slash8 -le 203 ]; then APNICquery \"$IPADDR\"\nelif [ $slash8 -ge 210 ] && [ $slash8 -le 211 ]; then APNICquery \"$IPADDR\"\nelif [ $slash8 -ge 218 ] && [ $slash8 -le 223 ]; then APNICquery \"$IPADDR\"\n\n#  If we got this far without making a decision, query ARIN.\n#  If a reference is found in $OUTFILE to APNIC, AFRINIC, LACNIC, or RIPE,\n#+ query the appropriate whois server.\n\nelse\n  ARINquery \"$IPADDR\"\n  if grep \"whois.afrinic.net\" \"$OUTFILE\"; then\n    AFRINICquery \"$IPADDR\"\n  elif grep -E \"^OrgID:[ ]+RIPE$\" \"$OUTFILE\"; then\n    RIPEquery \"$IPADDR\"\n  elif grep -E \"^OrgID:[ ]+APNIC$\" \"$OUTFILE\"; then\n    APNICquery \"$IPADDR\"\n  elif grep -E \"^OrgID:[ ]+LACNIC$\" \"$OUTFILE\"; then\n    LACNICquery \"$IPADDR\"\n  fi\nfi\n\n#@  ---------------------------------------------------------------\n#   Try also:\n#   wget http://logi.cc/nw/whois.php3?ACTION=doQuery&DOMAIN=$IPADDR\n#@  ---------------------------------------------------------------\n\n#  We've  now  finished  the querying.\n#  Echo a copy of the final result to the screen.\n\ncat $OUTFILE\n# Or \"less $OUTFILE\" . . .\n\nexit 0\n\n#@  ABS Guide author comments:\n#@  Nothing fancy here, but still a very useful tool for hunting spammers.\n#@  Sure, the script can be cleaned up some, and it's still a bit buggy,\n#@+ (exercise for reader), but all the same, it's a nice piece of coding\n#@+ by Walter Dnes.\n#@  Thank you!\n```", "```sh #!/bin/bash\n# wgetter2.bash\n\n# Author: Little Monster [monster@monstruum.co.uk]\n# ==> Used in ABS Guide with permission of script author.\n# ==> This script still needs debugging and fixups (exercise for reader).\n# ==> It could also use some additional editing in the comments.\n\n#  This is wgetter2 --\n#+ a Bash script to make wget a bit more friendly, and save typing.\n\n#  Carefully crafted by Little Monster.\n#  More or less complete on 02/02/2005.\n#  If you think this script can be improved,\n#+ email me at: monster@monstruum.co.uk\n# ==> and cc: to the author of the ABS Guide, please.\n#  This script is licenced under the GPL.\n#  You are free to copy, alter and re-use it,\n#+ but please don't try to claim you wrote it.\n#  Log your changes here instead.\n\n# =======================================================================\n# changelog:\n\n# 07/02/2005\\.  Fixups by Little Monster.\n# 02/02/2005\\.  Minor additions by Little Monster.\n#              (See after # +++++++++++ )\n# 29/01/2005\\.  Minor stylistic edits and cleanups by author of ABS Guide.\n#              Added exit error codes.\n# 22/11/2004\\.  Finished initial version of second version of wgetter:\n#              wgetter2 is born.\n# 01/12/2004\\.  Changed 'runn' function so it can be run 2 ways --\n#              either ask for a file name or have one input on the CL.\n# 01/12/2004\\.  Made sensible handling of no URL's given.\n# 01/12/2004\\.  Made loop of main options, so you don't\n#              have to keep calling wgetter 2 all the time.\n#              Runs as a session instead.\n# 01/12/2004\\.  Added looping to 'runn' function.\n#              Simplified and improved.\n# 01/12/2004\\.  Added state to recursion setting.\n#              Enables re-use of previous value.\n# 05/12/2004\\.  Modified the file detection routine in the 'runn' function\n#              so it's not fooled by empty values, and is cleaner.\n# 01/02/2004\\.  Added cookie finding routine from later version (which \n#              isn't ready yet), so as not to have hard-coded paths.\n# =======================================================================\n\n# Error codes for abnormal exit.\nE_USAGE=67        # Usage message, then quit.\nE_NO_OPTS=68      # No command-line args entered.\nE_NO_URLS=69      # No URLs passed to script.\nE_NO_SAVEFILE=70  # No save filename passed to script.\nE_USER_EXIT=71    # User decides to quit.\n\n#  Basic default wget command we want to use.\n#  This is the place to change it, if required.\n#  NB: if using a proxy, set http_proxy = yourproxy in .wgetrc.\n#  Otherwise delete --proxy=on, below.\n# ====================================================================\nCommandA=\"wget -nc -c -t 5 --progress=bar --random-wait --proxy=on -r\"\n# ====================================================================\n\n# --------------------------------------------------------------------\n# Set some other variables and explain them.\n\npattern=\" -A .jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.htm,.html,.shtml,.php\"\n                    # wget's option to only get certain types of file.\n                    # comment out if not using\ntoday=`date +%F`    # Used for a filename.\nhome=$HOME          # Set HOME to an internal variable.\n                    # In case some other path is used, change it here.\ndepthDefault=3      # Set a sensible default recursion.\nDepth=$depthDefault # Otherwise user feedback doesn't tie in properly.\nRefA=\"\"             # Set blank referring page.\nFlag=\"\"             #  Default to not saving anything,\n                    #+ or whatever else might be wanted in future.\nlister=\"\"           # Used for passing a list of urls directly to wget.\nWoptions=\"\"         # Used for passing wget some options for itself.\ninFile=\"\"           # Used for the run function.\nnewFile=\"\"          # Used for the run function.\nsavePath=\"$home/w-save\"\nConfig=\"$home/.wgetter2rc\"\n                    #  This is where some variables can be stored, \n                    #+ if permanently changed from within the script.\nCookie_List=\"$home/.cookielist\"\n                    # So we know where the cookies are kept . . .\ncFlag=\"\"            # Part of the cookie file selection routine.\n\n# Define the options available. Easy to change letters here if needed.\n# These are the optional options; you don't just wait to be asked.\n\nsave=s   # Save command instead of executing it.\ncook=c   # Change cookie file for this session.\nhelp=h   # Usage guide.\nlist=l   # Pass wget the -i option and URL list.\nrunn=r   # Run saved commands as an argument to the option.\ninpu=i   # Run saved commands interactively.\nwopt=w   # Allow to enter options to pass directly to wget.\n# --------------------------------------------------------------------\n\nif [ -z \"$1\" ]; then   # Make sure we get something for wget to eat.\n   echo \"You must at least enter a URL or option!\"\n   echo \"-$help for usage.\"\n   exit $E_NO_OPTS\nfi\n\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n# added added added added added added added added added added added added\n\nif [ ! -e \"$Config\" ]; then   # See if configuration file exists.\n   echo \"Creating configuration file, $Config\"\n   echo \"# This is the configuration file for wgetter2\" > \"$Config\"\n   echo \"# Your customised settings will be saved in this file\" >> \"$Config\"\nelse\n   source $Config             # Import variables we set outside the script.\nfi\n\nif [ ! -e \"$Cookie_List\" ]; then\n   # Set up a list of cookie files, if there isn't one.\n   echo \"Hunting for cookies . . .\"\n   find -name cookies.txt >> $Cookie_List # Create the list of cookie files.\nfi #  Isolate this in its own 'if' statement,\n   #+ in case we got interrupted while searching.\n\nif [ -z \"$cFlag\" ]; then # If we haven't already done this . . .\n   echo                  # Make a nice space after the command prompt.\n   echo \"Looks like you haven't set up your source of cookies yet.\"\n   n=0                   #  Make sure the counter\n                         #+ doesn't contain random values.\n   while read; do\n      Cookies[$n]=$REPLY # Put the cookie files we found into an array.\n      echo \"$n) ${Cookies[$n]}\"  # Create a menu.\n      n=$(( n + 1 ))     # Increment the counter.\n   done < $Cookie_List   # Feed the read statement.\n   echo \"Enter the number of the cookie file you want to use.\"\n   echo \"If you won't be using cookies, just press RETURN.\"\n   echo\n   echo \"I won't be asking this again. Edit $Config\"\n   echo \"If you decide to change at a later date\"\n   echo \"or use the -${cook} option for per session changes.\"\n   read\n   if [ ! -z $REPLY ]; then   # User didn't just press return.\n      Cookie=\" --load-cookies ${Cookies[$REPLY]}\"\n      # Set the variable here as well as in the config file.\n\n      echo \"Cookie=\\\" --load-cookies ${Cookies[$REPLY]}\\\"\" >> $Config\n   fi\n   echo \"cFlag=1\" >> $Config  # So we know not to ask again.\nfi\n\n# end added section end added section end added section end added section\n# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n# Another variable.\n# This one may or may not be subject to variation.\n# A bit like the small print.\nCookiesON=$Cookie\n# echo \"cookie file is $CookiesON\" # For debugging.\n# echo \"home is ${home}\"           # For debugging.\n                                   # Got caught with this one!\n\nwopts()\n{\necho \"Enter options to pass to wget.\"\necho \"It is assumed you know what you're doing.\"\necho\necho \"You can pass their arguments here too.\"\n# That is to say, everything passed here is passed to wget.\n\nread Wopts\n# Read in the options to be passed to wget.\n\nWoptions=\" $Wopts\"\n#         ^  Why the leading space?\n# Assign to another variable.\n# Just for fun, or something . . .\n\necho \"passing options ${Wopts} to wget\"\n# Mainly for debugging.\n# Is cute.\n\nreturn\n}\n\nsave_func()\n{\necho \"Settings will be saved.\"\nif [ ! -d $savePath ]; then  #  See if directory exists.\n   mkdir $savePath           #  Create the directory to save things in\n                             #+ if it isn't already there.\nfi\n\nFlag=S\n# Tell the final bit of code what to do.\n# Set a flag since stuff is done in main.\n\nreturn\n}\n\nusage() # Tell them how it works.\n{\n    echo \"Welcome to wgetter.  This is a front end to wget.\"\n    echo \"It will always run wget with these options:\"\n    echo \"$CommandA\"\n    echo \"and the pattern to match: $pattern \\\n(which you can change at the top of this script).\"\n    echo \"It will also ask you for recursion depth, \\\nand if you want to use a referring page.\"\n    echo \"Wgetter accepts the following options:\"\n    echo \"\"\n    echo \"-$help : Display this help.\"\n    echo \"-$save : Save the command to a file $savePath/wget-($today) \\\ninstead of running it.\"\n    echo \"-$runn : Run saved wget commands instead of starting a new one -\"\n    echo \"Enter filename as argument to this option.\"\n    echo \"-$inpu : Run saved wget commands interactively --\"\n    echo \"The script will ask you for the filename.\"\n    echo \"-$cook : Change the cookies file for this session.\"\n    echo \"-$list : Tell wget to use URL's from a list instead of \\\nfrom the command-line.\"\n    echo \"-$wopt : Pass any other options direct to wget.\"\n    echo \"\"\n    echo \"See the wget man page for additional options \\\nyou can pass to wget.\"\n    echo \"\"\n\n    exit $E_USAGE  # End here. Don't process anything else.\n}\n\nlist_func() #  Gives the user the option to use the -i option to wget,\n            #+ and a list of URLs.\n{\nwhile [ 1 ]; do\n   echo \"Enter the name of the file containing URL's (press q to change\nyour mind).\"\n   read urlfile\n   if [ ! -e \"$urlfile\" ] && [ \"$urlfile\" != q ]; then\n       # Look for a file, or the quit option.\n       echo \"That file does not exist!\"\n   elif [ \"$urlfile\" = q ]; then # Check quit option.\n       echo \"Not using a url list.\"\n       return\n   else\n      echo \"using $urlfile.\"\n      echo \"If you gave url's on the command-line, I'll use those first.\"\n                            # Report wget standard behaviour to the user.\n      lister=\" -i $urlfile\" # This is what we want to pass to wget.\n      return\n   fi\ndone\n}\n\ncookie_func() # Give the user the option to use a different cookie file.\n{\nwhile [ 1 ]; do\n   echo \"Change the cookies file. Press return if you don't want to change \nit.\"\n   read Cookies\n   # NB: this is not the same as Cookie, earlier.\n   # There is an 's' on the end.\n   # Bit like chocolate chips.\n   if [ -z \"$Cookies\" ]; then                 # Escape clause for wusses.\n      return\n   elif [ ! -e \"$Cookies\" ]; then\n      echo \"File does not exist.  Try again.\" # Keep em going . . .\n   else\n       CookiesON=\" --load-cookies $Cookies\"   # File is good -- use it!\n       return\n   fi\ndone\n}\n\nrun_func()\n{\nif [ -z \"$OPTARG\" ]; then\n# Test to see if we used the in-line option or the query one.\n   if [ ! -d \"$savePath\" ]; then      # If directory doesn't exist . . .\n      echo \"$savePath does not appear to exist.\"\n      echo \"Please supply path and filename of saved wget commands:\"\n      read newFile\n         until [ -f \"$newFile\" ]; do  # Keep going till we get something.\n            echo \"Sorry, that file does not exist.  Please try again.\"\n            # Try really hard to get something.\n            read newFile\n         done\n\n# -----------------------------------------------------------------------\n#       if [ -z ( grep wget ${newfile} ) ]; then\n        # Assume they haven't got the right file and bail out.\n#       echo \"Sorry, that file does not contain wget commands.  Aborting.\"\n#       exit\n#       fi\n#\n# This is bogus code.\n# It doesn't actually work.\n# If anyone wants to fix it, feel free!\n# -----------------------------------------------------------------------\n\n      filePath=\"${newFile}\"\n   else\n   echo \"Save path is $savePath\"\n     echo \"Please enter name of the file which you want to use.\"\n     echo \"You have a choice of:\"\n     ls $savePath                                    # Give them a choice.\n     read inFile\n       until [ -f \"$savePath/$inFile\" ]; do         #  Keep going till\n                                                    #+ we get something.\n          if [ ! -f \"${savePath}/${inFile}\" ]; then # If file doesn't exist.\n             echo \"Sorry, that file does not exist.  Please choose from:\"\n             ls $savePath                           # If a mistake is made.\n             read inFile\n          fi\n         done\n      filePath=\"${savePath}/${inFile}\"  # Make one variable . . .\n   fi\nelse filePath=\"${savePath}/${OPTARG}\"   # Which can be many things . . .\nfi\n\nif [ ! -f \"$filePath\" ]; then           # If a bogus file got through.\n   echo \"You did not specify a suitable file.\"\n   echo \"Run this script with the -${save} option first.\"\n   echo \"Aborting.\"\n   exit $E_NO_SAVEFILE\nfi\necho \"Using: $filePath\"\nwhile read; do\n    eval $REPLY\n    echo \"Completed: $REPLY\"\ndone < $filePath  # Feed the actual file we are using into a 'while' loop.\n\nexit\n}\n\n# Fish out any options we are using for the script.\n# This is based on the demo in \"Learning The Bash Shell\" (O'Reilly).\nwhile getopts \":$save$cook$help$list$runn:$inpu$wopt\" opt\ndo\n  case $opt in\n     $save) save_func;;   #  Save some wgetter sessions for later.\n     $cook) cookie_func;; #  Change cookie file.\n     $help) usage;;       #  Get help.\n     $list) list_func;;   #  Allow wget to use a list of URLs.\n     $runn) run_func;;    #  Useful if you are calling wgetter from,\n                          #+ for example, a cron script.\n     $inpu) run_func;;    #  When you don't know what your files are named.\n     $wopt) wopts;;       #  Pass options directly to wget.\n        \\?) echo \"Not a valid option.\"\n            echo \"Use -${wopt} to pass options directly to wget,\"\n            echo \"or -${help} for help\";;      # Catch anything else.\n  esac\ndone\nshift $((OPTIND - 1))     # Do funky magic stuff with $#.\n\nif [ -z \"$1\" ] && [ -z \"$lister\" ]; then\n                          #  We should be left with at least one URL\n                          #+ on the command-line, unless a list is \n\t\t\t  #+ being used -- catch empty CL's.\n   echo \"No URL's given! You must enter them on the same line as wgetter2.\"\n   echo \"E.g.,  wgetter2 http://somesite http://anothersite.\"\n   echo \"Use $help option for more information.\"\n   exit $E_NO_URLS        # Bail out, with appropriate error code.\nfi\n\nURLS=\" $@\"\n# Use this so that URL list can be changed if we stay in the option loop.\n\nwhile [ 1 ]; do\n   # This is where we ask for the most used options.\n   # (Mostly unchanged from version 1 of wgetter)\n   if [ -z $curDepth ]; then\n      Current=\"\"\n   else Current=\" Current value is $curDepth\"\n   fi\n       echo \"How deep should I go? \\\n(integer: Default is $depthDefault.$Current)\"\n       read Depth   # Recursion -- how far should we go?\n       inputB=\"\"    # Reset this to blank on each pass of the loop.\n       echo \"Enter the name of the referring page (default is none).\"\n       read inputB  # Need this for some sites.\n\n       echo \"Do you want to have the output logged to the terminal\"\n       echo \"(y/n, default is yes)?\"\n       read noHide  # Otherwise wget will just log it to a file.\n\n       case $noHide in    # Now you see me, now you don't.\n          y&#124;Y ) hide=\"\";;\n          n&#124;N ) hide=\" -b\";;\n            * ) hide=\"\";;\n       esac\n\n       if [ -z ${Depth} ]; then\n       #  User accepted either default or current depth,\n       #+ in which case Depth is now empty.\n          if [ -z ${curDepth} ]; then\n          #  See if a depth was set on a previous iteration.\n             Depth=\"$depthDefault\"\n             #  Set the default recursion depth if nothing\n             #+ else to use.\n          else Depth=\"$curDepth\" #  Otherwise, set the one we used before.\n          fi\n       fi\n   Recurse=\" -l $Depth\"          # Set how deep we want to go.\n   curDepth=$Depth               # Remember setting for next time.\n\n       if [ ! -z $inputB ]; then\n          RefA=\" --referer=$inputB\"   # Option to use referring page.\n       fi\n\n   WGETTER=\"${CommandA}${pattern}${hide}${RefA}${Recurse}\\\n${CookiesON}${lister}${Woptions}${URLS}\"\n   #  Just string the whole lot together . . .\n   #  NB: no embedded spaces.\n   #  They are in the individual elements so that if any are empty,\n   #+ we don't get an extra space.\n\n   if [ -z \"${CookiesON}\" ] && [ \"$cFlag\" = \"1\" ] ; then\n       echo \"Warning -- can't find cookie file\"\n       #  This should be changed,\n       #+ in case the user has opted to not use cookies.\n   fi\n\n   if [ \"$Flag\" = \"S\" ]; then\n      echo \"$WGETTER\" >> $savePath/wget-${today}\n      #  Create a unique filename for today, or append to it if it exists.\n      echo \"$inputB\" >> $savePath/site-list-${today}\n      #  Make a list, so it's easy to refer back to,\n      #+ since the whole command is a bit confusing to look at.\n      echo \"Command saved to the file $savePath/wget-${today}\"\n           # Tell the user.\n      echo \"Referring page URL saved to the file$ \\\nsavePath/site-list-${today}\"\n           # Tell the user.\n      Saver=\" with save option\"\n      # Stick this somewhere, so it appears in the loop if set.\n   else\n       echo \"*****************\"\n       echo \"*****Getting*****\"\n       echo \"*****************\"\n       echo \"\"\n       echo \"$WGETTER\"\n       echo \"\"\n       echo \"*****************\"\n       eval \"$WGETTER\"\n   fi\n\n       echo \"\"\n       echo \"Starting over$Saver.\"\n       echo \"If you want to stop, press q.\"\n       echo \"Otherwise, enter some URL's:\"\n       # Let them go again. Tell about save option being set.\n\n       read\n       case $REPLY in\n       # Need to change this to a 'trap' clause.\n          q&#124;Q ) exit $E_USER_EXIT;;  # Exercise for the reader?\n            * ) URLS=\" $REPLY\";;\n       esac\n\n       echo \"\"\ndone\n\nexit 0\n```", "```sh #!/bin/bash\n\n#  bashpodder.sh:\n#  By Linc 10/1/2004\n#  Find the latest script at\n#+ http://linc.homeunix.org:8080/scripts/bashpodder\n#  Last revision 12/14/2004 - Many Contributors!\n#  If you use this and have made improvements or have comments\n#+ drop me an email at linc dot fessenden at gmail dot com\n#  I'd appreciate it!\n\n# ==>  ABS Guide extra comments.\n\n# ==>  Author of this script has kindly granted permission\n# ==>+ for inclusion in ABS Guide.\n\n# ==> ################################################################\n# \n# ==> What is \"podcasting\"?\n\n# ==> It's broadcasting \"radio shows\" over the Internet.\n# ==> These shows can be played on iPods and other music file players.\n\n# ==> This script makes it possible.\n# ==> See documentation at the script author's site, above.\n\n# ==> ################################################################\n\n# Make script crontab friendly:\ncd $(dirname $0)\n# ==> Change to directory where this script lives.\n\n# datadir is the directory you want podcasts saved to:\ndatadir=$(date +%Y-%m-%d)\n# ==> Will create a date-labeled directory, named: YYYY-MM-DD\n\n# Check for and create datadir if necessary:\nif test ! -d $datadir\n        then\n        mkdir $datadir\nfi\n\n# Delete any temp file:\nrm -f temp.log\n\n#  Read the bp.conf file and wget any url not already\n#+ in the podcast.log file:\nwhile read podcast\n  do # ==> Main action follows.\n  file=$(wget -q $podcast -O - &#124; tr '\\r' '\\n' &#124; tr \\' \\\" &#124; \\\nsed -n 's/.*url=\"\\([^\"]*\\)\".*/\\1/p')\n  for url in $file\n                do\n                echo $url >> temp.log\n                if ! grep \"$url\" podcast.log > /dev/null\n                        then\n                        wget -q -P $datadir \"$url\"\n                fi\n                done\n    done < bp.conf\n\n# Move dynamically created log file to permanent log file:\ncat podcast.log >> temp.log\nsort temp.log &#124; uniq > podcast.log\nrm temp.log\n# Create an m3u playlist:\nls $datadir &#124; grep -v m3u > $datadir/podcast.m3u\n\nexit 0\n\n#################################################\nFor a different scripting approach to Podcasting,\nsee Phil Salkie's article, \n\"Internet Radio to Podcast with Shell Tools\"\nin the September, 2005 issue of LINUX JOURNAL,\nhttp://www.linuxjournal.com/article/8171\n#################################################\n```", "```sh #!/bin/bash\n# nightly-backup.sh\n# http://www.richardneill.org/source.php#nightly-backup-rsync\n# Copyright (c) 2005 Richard Neill <backup@richardneill.org>.\n# This is Free Software licensed under the GNU GPL.\n# ==> Included in ABS Guide with script author's kind permission.\n# ==> (Thanks!)\n\n#  This does a backup from the host computer to a locally connected\n#+ firewire HDD using rsync and ssh.\n#  (Script should work with USB-connected device (see lines 40-43).\n#  It then rotates the backups.\n#  Run it via cron every night at 5am.\n#  This only backs up the home directory.\n#  If ownerships (other than the user's) should be preserved,\n#+ then run the rsync process as root (and re-instate the -o).\n#  We save every day for 7 days, then every week for 4 weeks,\n#+ then every month for 3 months.\n\n#  See: http://www.mikerubel.org/computers/rsync_snapshots/\n#+ for more explanation of the theory.\n#  Save as: $HOME/bin/nightly-backup_firewire-hdd.sh\n\n#  Known bugs:\n#  ----------\n#  i)  Ideally, we want to exclude ~/.tmp and the browser caches.\n\n#  ii) If the user is sitting at the computer at 5am,\n#+     and files are modified while the rsync is occurring,\n#+     then the BACKUP_JUSTINCASE branch gets triggered.\n#      To some extent, this is a \n#+     feature, but it also causes a \"disk-space leak\".\n\n##### BEGIN CONFIGURATION SECTION ############################################\nLOCAL_USER=rjn                # User whose home directory should be backed up.\nMOUNT_POINT=/backup           # Mountpoint of backup drive.\n                              # NO trailing slash!\n                              # This must be unique (eg using a udev symlink)\n# MOUNT_POINT=/media/disk     # For USB-connected device.\nSOURCE_DIR=/home/$LOCAL_USER  # NO trailing slash - it DOES matter to rsync.\nBACKUP_DEST_DIR=$MOUNT_POINT/backup/`hostname -s`.${LOCAL_USER}.nightly_backup\nDRY_RUN=false                 #If true, invoke rsync with -n, to do a dry run.\n                              # Comment out or set to false for normal use.\nVERBOSE=false                 # If true, make rsync verbose.\n                              # Comment out or set to false otherwise.\nCOMPRESS=false                # If true, compress.\n                              # Good for internet, bad on LAN.\n                              # Comment out or set to false otherwise.\n\n### Exit Codes ###\nE_VARS_NOT_SET=64\nE_COMMANDLINE=65\nE_MOUNT_FAIL=70\nE_NOSOURCEDIR=71\nE_UNMOUNTED=72\nE_BACKUP=73\n##### END CONFIGURATION SECTION ##############################################\n\n# Check that all the important variables have been set:\nif [ -z \"$LOCAL_USER\" ] &#124;&#124;\n   [ -z \"$SOURCE_DIR\" ] &#124;&#124;\n   [ -z \"$MOUNT_POINT\" ]  &#124;&#124;\n   [ -z \"$BACKUP_DEST_DIR\" ]\nthen\n   echo 'One of the variables is not set! Edit the file: $0\\. BACKUP FAILED.'\n   exit $E_VARS_NOT_SET\nfi\n\nif [ \"$#\" != 0 ]  # If command-line param(s) . . .\nthen              # Here document(ation).\n  cat <<-ENDOFTEXT\n    Automatic Nightly backup run from cron.\n    Read the source for more details: $0\n    The backup directory is $BACKUP_DEST_DIR .\n    It will be created if necessary; initialisation is no longer required.\n\n    WARNING: Contents of $BACKUP_DEST_DIR are rotated.\n    Directories named 'backup.\\$i' will eventually be DELETED.\n    We keep backups from every day for 7 days (1-8),\n    then every week for 4 weeks (9-12),\n    then every month for 3 months (13-15).\n\n    You may wish to add this to your crontab using 'crontab -e'\n    #  Back up files: $SOURCE_DIR to $BACKUP_DEST_DIR\n    #+ every night at 3:15 am\n         15 03 * * * /home/$LOCAL_USER/bin/nightly-backup_firewire-hdd.sh\n\n    Don't forget to verify the backups are working,\n    especially if you don't read cron's mail!\"\n\tENDOFTEXT\n   exit $E_COMMANDLINE\nfi\n\n# Parse the options.\n# ==================\n\nif [ \"$DRY_RUN\" == \"true\" ]; then\n  DRY_RUN=\"-n\"\n  echo \"WARNING:\"\n  echo \"THIS IS A 'DRY RUN'!\"\n  echo \"No data will actually be transferred!\"\nelse\n  DRY_RUN=\"\"\nfi\n\nif [ \"$VERBOSE\" == \"true\" ]; then\n  VERBOSE=\"-v\"\nelse\n  VERBOSE=\"\"\nfi\n\nif [ \"$COMPRESS\" == \"true\" ]; then\n  COMPRESS=\"-z\"\nelse\n  COMPRESS=\"\"\nfi\n\n#  Every week (actually of 8 days) and every month,\n#+ extra backups are preserved.\nDAY_OF_MONTH=`date +%d`            # Day of month (01..31).\nif [ $DAY_OF_MONTH = 01 ]; then    # First of month.\n  MONTHSTART=true\nelif [ $DAY_OF_MONTH = 08 \\\n    -o $DAY_OF_MONTH = 16 \\\n    -o $DAY_OF_MONTH = 24 ]; then\n    # Day 8,16,24  (use 8, not 7 to better handle 31-day months)\n      WEEKSTART=true\nfi\n\n#  Check that the HDD is mounted.\n#  At least, check that *something* is mounted here!\n#  We can use something unique to the device, rather than just guessing\n#+ the scsi-id by having an appropriate udev rule in\n#+ /etc/udev/rules.d/10-rules.local\n#+ and by putting a relevant entry in /etc/fstab.\n#  Eg: this udev rule:\n# BUS=\"scsi\", KERNEL=\"sd*\", SYSFS{vendor}=\"WDC WD16\",\n# SYSFS{model}=\"00JB-00GVA0     \", NAME=\"%k\", SYMLINK=\"lacie_1394d%n\"\n\nif mount &#124; grep $MOUNT_POINT >/dev/null; then\n  echo \"Mount point $MOUNT_POINT is indeed mounted. OK\"\nelse\n  echo -n \"Attempting to mount $MOUNT_POINT...\"\t\n           # If it isn't mounted, try to mount it.\n  sudo mount $MOUNT_POINT 2>/dev/null\n\n  if mount &#124; grep $MOUNT_POINT >/dev/null; then\n    UNMOUNT_LATER=TRUE\n    echo \"OK\"\n    #  Note: Ensure that this is also unmounted\n    #+ if we exit prematurely with failure.\n  else\n    echo \"FAILED\"\n    echo -e \"Nothing is mounted at $MOUNT_POINT. BACKUP FAILED!\"\n    exit $E_MOUNT_FAIL\n  fi\nfi\n\n# Check that source dir exists and is readable.\nif [ ! -r  $SOURCE_DIR ] ; then\n  echo \"$SOURCE_DIR does not exist, or cannot be read. BACKUP FAILED.\"\n  exit $E_NOSOURCEDIR\nfi\n\n# Check that the backup directory structure is as it should be.\n# If not, create it.\n# Create the subdirectories.\n# Note that backup.0 will be created as needed by rsync.\n\nfor ((i=1;i<=15;i++)); do\n  if [ ! -d $BACKUP_DEST_DIR/backup.$i ]; then\n    if /bin/mkdir -p $BACKUP_DEST_DIR/backup.$i ; then\n    #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  No [ ] test brackets. Why?\n      echo \"Warning: directory $BACKUP_DEST_DIR/backup.$i is missing,\"\n      echo \"or was not initialised. (Re-)creating it.\"\n    else\n      echo \"ERROR: directory $BACKUP_DEST_DIR/backup.$i\"\n      echo \"is missing and could not be created.\"\n    if  [ \"$UNMOUNT_LATER\" == \"TRUE\" ]; then\n        # Before we exit, unmount the mount point if necessary.\n        cd\n\tsudo umount $MOUNT_POINT &&\n\techo \"Unmounted $MOUNT_POINT again. Giving up.\"\n    fi\n      exit $E_UNMOUNTED\n  fi\nfi\ndone\n\n#  Set the permission to 700 for security\n#+ on an otherwise permissive multi-user system.\nif ! /bin/chmod 700 $BACKUP_DEST_DIR ; then\n  echo \"ERROR: Could not set permissions on $BACKUP_DEST_DIR to 700.\"\n\n  if  [ \"$UNMOUNT_LATER\" == \"TRUE\" ]; then\n  # Before we exit, unmount the mount point if necessary.\n     cd ; sudo umount $MOUNT_POINT \\\n     && echo \"Unmounted $MOUNT_POINT again. Giving up.\"\n  fi\n\n  exit $E_UNMOUNTED\nfi\n\n# Create the symlink: current -> backup.1 if required.\n# A failure here is not critical.\ncd $BACKUP_DEST_DIR\nif [ ! -h current ] ; then\n  if ! /bin/ln -s backup.1 current ; then\n    echo \"WARNING: could not create symlink current -> backup.1\"\n  fi\nfi\n\n# Now, do the rsync.\necho \"Now doing backup with rsync...\"\necho \"Source dir: $SOURCE_DIR\"\necho -e \"Backup destination dir: $BACKUP_DEST_DIR\\n\"\n\n/usr/bin/rsync $DRY_RUN $VERBOSE -a -S --delete --modify-window=60 \\\n--link-dest=../backup.1 $SOURCE_DIR $BACKUP_DEST_DIR/backup.0/\n\n#  Only warn, rather than exit if the rsync failed,\n#+ since it may only be a minor problem.\n#  E.g., if one file is not readable, rsync will fail.\n#  This shouldn't prevent the rotation.\n#  Not using, e.g., `date +%a`  since these directories\n#+ are just full of links and don't consume *that much* space.\n\nif [ $? != 0 ]; then\n  BACKUP_JUSTINCASE=backup.`date +%F_%T`.justincase\n  echo \"WARNING: the rsync process did not entirely succeed.\"\n  echo \"Something might be wrong.\"\n  echo \"Saving an extra copy at: $BACKUP_JUSTINCASE\"\n  echo \"WARNING: if this occurs regularly, a LOT of space will be consumed,\"\n  echo \"even though these are just hard-links!\"\nfi\n\n# Save a readme in the backup parent directory.\n# Save another one in the recent subdirectory.\necho \"Backup of $SOURCE_DIR on `hostname` was last run on \\\n`date`\" > $BACKUP_DEST_DIR/README.txt\necho \"This backup of $SOURCE_DIR on `hostname` was created on \\\n`date`\" > $BACKUP_DEST_DIR/backup.0/README.txt\n\n# If we are not in a dry run, rotate the backups.\n[ -z \"$DRY_RUN\" ] &&\n\n  #  Check how full the backup disk is.\n  #  Warn if 90%. if 98% or more, we'll probably fail, so give up.\n  #  (Note: df can output to more than one line.)\n  #  We test this here, rather than before\n  #+ so that rsync may possibly have a chance.\n  DISK_FULL_PERCENT=`/bin/df $BACKUP_DEST_DIR &#124;\n  tr \"\\n\" ' ' &#124; awk '{print $12}' &#124; grep -oE [0-9]+ `\n  echo \"Disk space check on backup partition \\\n  $MOUNT_POINT $DISK_FULL_PERCENT% full.\"\n  if [ $DISK_FULL_PERCENT -gt 90 ]; then\n    echo \"Warning: Disk is greater than 90% full.\"\n  fi\n  if [ $DISK_FULL_PERCENT -gt 98 ]; then\n    echo \"Error: Disk is full! Giving up.\"\n      if  [ \"$UNMOUNT_LATER\" == \"TRUE\" ]; then\n        # Before we exit, unmount the mount point if necessary.\n        cd; sudo umount $MOUNT_POINT &&\n        echo \"Unmounted $MOUNT_POINT again. Giving up.\"\n      fi\n    exit $E_UNMOUNTED\n  fi\n\n # Create an extra backup.\n # If this copy fails, give up.\n if [ -n \"$BACKUP_JUSTINCASE\" ]; then\n   if ! /bin/cp -al $BACKUP_DEST_DIR/backup.0 \\\n      $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE\n   then\n     echo \"ERROR: Failed to create extra copy \\\n     $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE\"\n     if  [ \"$UNMOUNT_LATER\" == \"TRUE\" ]; then\n       # Before we exit, unmount the mount point if necessary.\n       cd ;sudo umount $MOUNT_POINT &&\n       echo \"Unmounted $MOUNT_POINT again. Giving up.\"\n     fi\n     exit $E_UNMOUNTED\n   fi\n fi\n\n # At start of month, rotate the oldest 8.\n if [ \"$MONTHSTART\" == \"true\" ]; then\n   echo -e \"\\nStart of month. \\\n   Removing oldest backup: $BACKUP_DEST_DIR/backup.15\"  &&\n   /bin/rm -rf  $BACKUP_DEST_DIR/backup.15  &&\n   echo \"Rotating monthly,weekly backups: \\\n   $BACKUP_DEST_DIR/backup.[8-14] -> $BACKUP_DEST_DIR/backup.[9-15]\"  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.14 $BACKUP_DEST_DIR/backup.15  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.13 $BACKUP_DEST_DIR/backup.14  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.12 $BACKUP_DEST_DIR/backup.13  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9\n\n # At start of week, rotate the second-oldest 4.\n elif [ \"$WEEKSTART\" == \"true\" ]; then\n   echo -e \"\\nStart of week. \\\n   Removing oldest weekly backup: $BACKUP_DEST_DIR/backup.12\"  &&\n   /bin/rm -rf  $BACKUP_DEST_DIR/backup.12  &&\n\n   echo \"Rotating weekly backups: \\\n   $BACKUP_DEST_DIR/backup.[8-11] -> $BACKUP_DEST_DIR/backup.[9-12]\"  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9\n\n else\n   echo -e \"\\nRemoving oldest daily backup: $BACKUP_DEST_DIR/backup.8\"  &&\n     /bin/rm -rf  $BACKUP_DEST_DIR/backup.8\n\n fi  &&\n\n # Every day, rotate the newest 8.\n echo \"Rotating daily backups: \\\n $BACKUP_DEST_DIR/backup.[1-7] -> $BACKUP_DEST_DIR/backup.[2-8]\"  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.7 $BACKUP_DEST_DIR/backup.8  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.6 $BACKUP_DEST_DIR/backup.7  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.5 $BACKUP_DEST_DIR/backup.6  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.4 $BACKUP_DEST_DIR/backup.5  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.3 $BACKUP_DEST_DIR/backup.4  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.2 $BACKUP_DEST_DIR/backup.3  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.1 $BACKUP_DEST_DIR/backup.2  &&\n     /bin/mv $BACKUP_DEST_DIR/backup.0 $BACKUP_DEST_DIR/backup.1  &&\n\n SUCCESS=true\n\nif  [ \"$UNMOUNT_LATER\" == \"TRUE\" ]; then\n  # Unmount the mount point if it wasn't mounted to begin with.\n  cd ; sudo umount $MOUNT_POINT && echo \"Unmounted $MOUNT_POINT again.\"\nfi\n\nif [ \"$SUCCESS\" == \"true\" ]; then\n  echo 'SUCCESS!'\n  exit 0\nfi\n\n# Should have already exited if backup worked.\necho 'BACKUP FAILED! Is this just a dry run? Is the disk full?) '\nexit $E_BACKUP\n```", "```sh ###########################################################################\n#\n#       cdll\n#       by Phil Braham\n#\n#       ############################################\n#       Latest version of this script available from\n#       http://freshmeat.net/projects/cd/\n#       ############################################\n#\n#       .cd_new\n#\n#       An enhancement of the Unix cd command\n#\n#       There are unlimited stack entries and special entries. The stack\n#       entries keep the last cd_maxhistory\n#       directories that have been used. The special entries can be\n#       assigned to commonly used directories.\n#\n#       The special entries may be pre-assigned by setting the environment\n#       variables CDSn or by using the -u or -U command.\n#\n#       The following is a suggestion for the .profile file:\n#\n#               . cdll              #  Set up the cd command\n#       alias cd='cd_new'           #  Replace the cd command\n#               cd -U               #  Upload pre-assigned entries for\n#                                   #+ the stack and special entries\n#               cd -D               #  Set non-default mode\n#               alias @=\"cd_new @\"  #  Allow @ to be used to get history\n#\n#       For help type:\n#\n#               cd -h or\n#               cd -H\n#\n#\n###########################################################################\n#\n#       Version 1.2.1\n#\n#       Written by Phil Braham - Realtime Software Pty Ltd\n#       (realtime@mpx.com.au)\n#       Please send any suggestions or enhancements to the author (also at\n#       phil@braham.net)\n#\n############################################################################\n\ncd_hm ()\n{\n        ${PRINTF} \"%s\" \"cd [dir] [0-9] [@[s&#124;h] [-g [<dir>]] [-d] \\\n[-D] [-r<n>] [dir&#124;0-9] [-R<n>] [<dir>&#124;0-9]\n   [-s<n>] [-S<n>] [-u] [-U] [-f] [-F] [-h] [-H] [-v]\n    <dir> Go to directory\n    0-n         Go to previous directory (0 is previous, 1 is last but 1 etc)\n                n is up to max history (default is 50)\n    @           List history and special entries\n    @h          List history entries\n    @s          List special entries\n    -g [<dir>]  Go to literal name (bypass special names)\n                This is to allow access to dirs called '0','1','-h' etc\n    -d          Change default action - verbose. (See note)\n    -D          Change default action - silent. (See note)\n    -s<n> Go to the special entry <n>*\n    -S<n> Go to the special entry <n>\n                and replace it with the current dir*\n    -r<n> [<dir>] Go to directory <dir>\n                              and then put it on special entry <n>*\n    -R<n> [<dir>] Go to directory <dir>\n                              and put current dir on special entry <n>*\n    -a<n>       Alternative suggested directory. See note below.\n    -f [<file>] File entries to <file>.\n    -u [<file>] Update entries from <file>.\n                If no filename supplied then default file\n                (${CDPath}${2:-\"$CDFile\"}) is used\n                -F and -U are silent versions\n    -v          Print version number\n    -h          Help\n    -H          Detailed help\n\n    *The special entries (0 - 9) are held until log off, replaced by another\n     entry or updated with the -u command\n\n    Alternative suggested directories:\n    If a directory is not found then CD will suggest any\n    possibilities. These are directories starting with the same letters\n    and if any are found they are listed prefixed with -a<n>\n    where <n> is a number.\n    It's possible to go to the directory by entering cd -a<n>\n    on the command line.\n\n    The directory for -r<n> or -R<n> may be a number.\n    For example:\n        $ cd -r3 4  Go to history entry 4 and put it on special entry 3\n        $ cd -R3 4  Put current dir on the special entry 3\n                    and go to history entry 4\n        $ cd -s3    Go to special entry 3\n\n    Note that commands R,r,S and s may be used without a number\n    and refer to 0:\n        $ cd -s     Go to special entry 0\n        $ cd -S     Go to special entry 0 and make special\n                    entry 0 current dir\n        $ cd -r 1   Go to history entry 1 and put it on special entry 0\n        $ cd -r     Go to history entry 0 and put it on special entry 0\n    \"\n        if ${TEST} \"$CD_MODE\" = \"PREV\"\n        then\n                ${PRINTF} \"$cd_mnset\"\n        else\n                ${PRINTF} \"$cd_mset\"\n        fi\n}\n\ncd_Hm ()\n{\n        cd_hm\n        ${PRINTF} \"%s\" \"\n        The previous directories (0-$cd_maxhistory) are stored in the\n        environment variables CD[0] - CD[$cd_maxhistory]\n        Similarly the special directories S0 - $cd_maxspecial are in\n        the environment variable CDS[0] - CDS[$cd_maxspecial]\n        and may be accessed from the command line\n\n        The default pathname for the -f and -u commands is $CDPath\n        The default filename for the -f and -u commands is $CDFile\n\n        Set the following environment variables:\n            CDL_PROMPTLEN  - Set to the length of prompt you require.\n                Prompt string is set to the right characters of the\n                current directory.\n                If not set then prompt is left unchanged\n            CDL_PROMPT_PRE - Set to the string to prefix the prompt.\n                Default is:\n                    non-root:  \\\"\\\\[\\\\e[01;34m\\\\]\\\"  (sets colour to blue).\n                    root:      \\\"\\\\[\\\\e[01;31m\\\\]\\\"  (sets colour to red).\n            CDL_PROMPT_POST    - Set to the string to suffix the prompt.\n                Default is:\n                    non-root:  \\\"\\\\[\\\\e[00m\\\\]$\\\"\n                                (resets colour and displays $).\n                    root:      \\\"\\\\[\\\\e[00m\\\\]#\\\"\n                                (resets colour and displays #).\n            CDPath - Set the default path for the -f & -u options.\n                     Default is home directory\n            CDFile - Set the default filename for the -f & -u options.\n                     Default is cdfile\n\n\"\n    cd_version\n\n}\n\ncd_version ()\n{\n printf \"Version: ${VERSION_MAJOR}.${VERSION_MINOR} Date: ${VERSION_DATE}\\n\"\n}\n\n#\n# Truncate right.\n#\n# params:\n#   p1 - string\n#   p2 - length to truncate to\n#\n# returns string in tcd\n#\ncd_right_trunc ()\n{\n    local tlen=${2}\n    local plen=${#1}\n    local str=\"${1}\"\n    local diff\n    local filler=\"<--\"\n    if ${TEST} ${plen} -le ${tlen}\n    then\n        tcd=\"${str}\"\n    else\n        let diff=${plen}-${tlen}\n        elen=3\n        if ${TEST} ${diff} -le 2\n        then\n            let elen=${diff}\n        fi\n        tlen=-${tlen}\n        let tlen=${tlen}+${elen}\n        tcd=${filler:0:elen}${str:tlen}\n    fi\n}\n\n#\n# Three versions of do history:\n#    cd_dohistory  - packs history and specials side by side\n#    cd_dohistoryH - Shows only hstory\n#    cd_dohistoryS - Shows only specials\n#\ncd_dohistory ()\n{\n    cd_getrc\n        ${PRINTF} \"History:\\n\"\n    local -i count=${cd_histcount}\n    while ${TEST} ${count} -ge 0\n    do\n        cd_right_trunc \"${CD[count]}\" ${cd_lchar}\n            ${PRINTF} \"%2d %-${cd_lchar}.${cd_lchar}s \" ${count} \"${tcd}\"\n\n        cd_right_trunc \"${CDS[count]}\" ${cd_rchar}\n            ${PRINTF} \"S%d %-${cd_rchar}.${cd_rchar}s\\n\" ${count} \"${tcd}\"\n        count=${count}-1\n    done\n}\n\ncd_dohistoryH ()\n{\n    cd_getrc\n        ${PRINTF} \"History:\\n\"\n        local -i count=${cd_maxhistory}\n        while ${TEST} ${count} -ge 0\n        do\n          ${PRINTF} \"${count} %-${cd_flchar}.${cd_flchar}s\\n\" ${CD[$count]}\n          count=${count}-1\n        done\n}\n\ncd_dohistoryS ()\n{\n    cd_getrc\n        ${PRINTF} \"Specials:\\n\"\n        local -i count=${cd_maxspecial}\n        while ${TEST} ${count} -ge 0\n        do\n          ${PRINTF} \"S${count} %-${cd_flchar}.${cd_flchar}s\\n\" ${CDS[$count]}\n          count=${count}-1\n        done\n}\n\ncd_getrc ()\n{\n    cd_flchar=$(stty -a &#124; awk -F \\;\n    '/rows/ { print $2 $3 }' &#124; awk -F \\  '{ print $4 }')\n    if ${TEST} ${cd_flchar} -ne 0\n    then\n        cd_lchar=${cd_flchar}/2-5\n        cd_rchar=${cd_flchar}/2-5\n            cd_flchar=${cd_flchar}-5\n    else\n            cd_flchar=${FLCHAR:=75}\n\t    # cd_flchar is used for for the @s & @h history\n            cd_lchar=${LCHAR:=35}\n            cd_rchar=${RCHAR:=35}\n    fi\n}\n\ncd_doselection ()\n{\n        local -i nm=0\n        cd_doflag=\"TRUE\"\n        if ${TEST} \"${CD_MODE}\" = \"PREV\"\n        then\n                if ${TEST} -z \"$cd_npwd\"\n                then\n                        cd_npwd=0\n                fi\n        fi\n        tm=$(echo \"${cd_npwd}\" &#124; cut -b 1)\n    if ${TEST} \"${tm}\" = \"-\"\n    then\n        pm=$(echo \"${cd_npwd}\" &#124; cut -b 2)\n        nm=$(echo \"${cd_npwd}\" &#124; cut -d $pm -f2)\n        case \"${pm}\" in\n             a) cd_npwd=${cd_sugg[$nm]} ;;\n             s) cd_npwd=\"${CDS[$nm]}\" ;;\n             S) cd_npwd=\"${CDS[$nm]}\" ; CDS[$nm]=`pwd` ;;\n             r) cd_npwd=\"$2\" ; cd_specDir=$nm ; cd_doselection \"$1\" \"$2\";;\n             R) cd_npwd=\"$2\" ; CDS[$nm]=`pwd` ; cd_doselection \"$1\" \"$2\";;\n        esac\n    fi\n\n    if ${TEST} \"${cd_npwd}\" != \".\" -a \"${cd_npwd}\" \\\n!= \"..\" -a \"${cd_npwd}\" -le ${cd_maxhistory} >>/dev/null 2>&1\n    then\n      cd_npwd=${CD[$cd_npwd]}\n     else\n       case \"$cd_npwd\" in\n                @)  cd_dohistory ; cd_doflag=\"FALSE\" ;;\n               @h) cd_dohistoryH ; cd_doflag=\"FALSE\" ;;\n               @s) cd_dohistoryS ; cd_doflag=\"FALSE\" ;;\n               -h) cd_hm ; cd_doflag=\"FALSE\" ;;\n               -H) cd_Hm ; cd_doflag=\"FALSE\" ;;\n               -f) cd_fsave \"SHOW\" $2 ; cd_doflag=\"FALSE\" ;;\n               -u) cd_upload \"SHOW\" $2 ; cd_doflag=\"FALSE\" ;;\n               -F) cd_fsave \"NOSHOW\" $2 ; cd_doflag=\"FALSE\" ;;\n               -U) cd_upload \"NOSHOW\" $2 ; cd_doflag=\"FALSE\" ;;\n               -g) cd_npwd=\"$2\" ;;\n               -d) cd_chdefm 1; cd_doflag=\"FALSE\" ;;\n               -D) cd_chdefm 0; cd_doflag=\"FALSE\" ;;\n               -r) cd_npwd=\"$2\" ; cd_specDir=0 ; cd_doselection \"$1\" \"$2\";;\n               -R) cd_npwd=\"$2\" ; CDS[0]=`pwd` ; cd_doselection \"$1\" \"$2\";;\n               -s) cd_npwd=\"${CDS[0]}\" ;;\n               -S) cd_npwd=\"${CDS[0]}\"  ; CDS[0]=`pwd` ;;\n               -v) cd_version ; cd_doflag=\"FALSE\";;\n       esac\n    fi\n}\n\ncd_chdefm ()\n{\n        if ${TEST} \"${CD_MODE}\" = \"PREV\"\n        then\n                CD_MODE=\"\"\n                if ${TEST} $1 -eq 1\n                then\n                        ${PRINTF} \"${cd_mset}\"\n                fi\n        else\n                CD_MODE=\"PREV\"\n                if ${TEST} $1 -eq 1\n                then\n                        ${PRINTF} \"${cd_mnset}\"\n                fi\n        fi\n}\n\ncd_fsave ()\n{\n        local sfile=${CDPath}${2:-\"$CDFile\"}\n        if ${TEST} \"$1\" = \"SHOW\"\n        then\n                ${PRINTF} \"Saved to %s\\n\" $sfile\n        fi\n        ${RM} -f ${sfile}\n        local -i count=0\n        while ${TEST} ${count} -le ${cd_maxhistory}\n        do\n                echo \"CD[$count]=\\\"${CD[$count]}\\\"\" >> ${sfile}\n                count=${count}+1\n        done\n        count=0\n        while ${TEST} ${count} -le ${cd_maxspecial}\n        do\n                echo \"CDS[$count]=\\\"${CDS[$count]}\\\"\" >> ${sfile}\n                count=${count}+1\n        done\n}\n\ncd_upload ()\n{\n        local sfile=${CDPath}${2:-\"$CDFile\"}\n        if ${TEST} \"${1}\" = \"SHOW\"\n        then\n                ${PRINTF} \"Loading from %s\\n\" ${sfile}\n        fi\n        . ${sfile}\n}\n\ncd_new ()\n{\n    local -i count\n    local -i choose=0\n\n        cd_npwd=\"${1}\"\n        cd_specDir=-1\n        cd_doselection \"${1}\" \"${2}\"\n\n        if ${TEST} ${cd_doflag} = \"TRUE\"\n        then\n                if ${TEST} \"${CD[0]}\" != \"`pwd`\"\n                then\n                        count=$cd_maxhistory\n                        while ${TEST} $count -gt 0\n                        do\n                                CD[$count]=${CD[$count-1]}\n                                count=${count}-1\n                        done\n                        CD[0]=`pwd`\n                fi\n                command cd \"${cd_npwd}\" 2>/dev/null\n        if ${TEST} $? -eq 1\n        then\n            ${PRINTF} \"Unknown dir: %s\\n\" \"${cd_npwd}\"\n            local -i ftflag=0\n            for i in \"${cd_npwd}\"*\n            do\n                if ${TEST} -d \"${i}\"\n                then\n                    if ${TEST} ${ftflag} -eq 0\n                    then\n                        ${PRINTF} \"Suggest:\\n\"\n                        ftflag=1\n                fi\n                    ${PRINTF} \"\\t-a${choose} %s\\n\" \"$i\"\n                                        cd_sugg[$choose]=\"${i}\"\n                    choose=${choose}+1\n        fi\n            done\n        fi\n        fi\n\n        if ${TEST} ${cd_specDir} -ne -1\n        then\n                CDS[${cd_specDir}]=`pwd`\n        fi\n\n        if ${TEST} ! -z \"${CDL_PROMPTLEN}\"\n        then\n        cd_right_trunc \"${PWD}\" ${CDL_PROMPTLEN}\n            cd_rp=${CDL_PROMPT_PRE}${tcd}${CDL_PROMPT_POST}\n                export PS1=\"$(echo -ne ${cd_rp})\"\n        fi\n}\n#########################################################################\n#                                                                       #\n#                        Initialisation here                            #\n#                                                                       #\n#########################################################################\n#\nVERSION_MAJOR=\"1\"\nVERSION_MINOR=\"2.1\"\nVERSION_DATE=\"24-MAY-2003\"\n#\nalias cd=cd_new\n#\n# Set up commands\nRM=/bin/rm\nTEST=test\nPRINTF=printf              # Use builtin printf\n\n#########################################################################\n#                                                                       #\n# Change this to modify the default pre- and post prompt strings.       #\n# These only come into effect if CDL_PROMPTLEN is set.                  #\n#                                                                       #\n#########################################################################\nif ${TEST} ${EUID} -eq 0\nthen\n#   CDL_PROMPT_PRE=${CDL_PROMPT_PRE:=\"$HOSTNAME@\"}\n    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:=\"\\\\[\\\\e[01;31m\\\\]\"}  # Root is in red\n    CDL_PROMPT_POST=${CDL_PROMPT_POST:=\"\\\\[\\\\e[00m\\\\]#\"}\nelse\n    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:=\"\\\\[\\\\e[01;34m\\\\]\"}  # Users in blue\n    CDL_PROMPT_POST=${CDL_PROMPT_POST:=\"\\\\[\\\\e[00m\\\\]$\"}\nfi\n#########################################################################\n#\n# cd_maxhistory defines the max number of history entries allowed.\ntypeset -i cd_maxhistory=50\n\n#########################################################################\n#\n# cd_maxspecial defines the number of special entries.\ntypeset -i cd_maxspecial=9\n#\n#\n#########################################################################\n#\n#  cd_histcount defines the number of entries displayed in\n#+ the history command.\ntypeset -i cd_histcount=9\n#\n#########################################################################\nexport CDPath=${HOME}/\n#  Change these to use a different                                      #\n#+ default path and filename                                            #\nexport CDFile=${CDFILE:=cdfile}           # for the -u and -f commands  #\n#\n#########################################################################\n                                                                        #\ntypeset -i cd_lchar cd_rchar cd_flchar\n                        #  This is the number of chars to allow for the #\ncd_flchar=${FLCHAR:=75} #+ cd_flchar is used for for the @s & @h history#\n\ntypeset -ax CD CDS\n#\ncd_mset=\"\\n\\tDefault mode is now set - entering cd with no parameters \\\nhas the default action\\n\\tUse cd -d or -D for cd to go to \\\nprevious directory with no parameters\\n\"\ncd_mnset=\"\\n\\tNon-default mode is now set - entering cd with no \\\nparameters is the same as entering cd 0\\n\\tUse cd -d or \\\n-D to change default cd action\\n\"\n\n# ==================================================================== #\n\n: <<DOCUMENTATION\n\nWritten by Phil Braham. Realtime Software Pty Ltd.\nReleased under GNU license. Free to use. Please pass any modifications\nor comments to the author Phil Braham:\n\nrealtime@mpx.com.au\n=======================================================================\n\ncdll is a replacement for cd and incorporates similar functionality to\nthe bash pushd and popd commands but is independent of them.\n\nThis version of cdll has been tested on Linux using Bash. It will work\non most Linux versions but will probably not work on other shells without\nmodification.\n\nIntroduction\n============\n\ncdll allows easy moving about between directories. When changing to a new\ndirectory the current one is automatically put onto a stack. By default\n50 entries are kept, but this is configurable. Special directories can be\nkept for easy access - by default up to 10, but this is configurable. The\nmost recent stack entries and the special entries can be easily viewed.\n\nThe directory stack and special entries can be saved to, and loaded from,\na file. This allows them to be set up on login, saved before logging out\nor changed when moving project to project.\n\nIn addition, cdll provides a flexible command prompt facility that allows,\nfor example, a directory name in colour that is truncated from the left\nif it gets too long.\n\nSetting up cdll\n===============\n\nCopy cdll to either your local home directory or a central directory\nsuch as /usr/bin (this will require root access).\n\nCopy the file cdfile to your home directory. It will require read and\nwrite access. This a default file that contains a directory stack and\nspecial entries.\n\nTo replace the cd command you must add commands to your login script.\nThe login script is one or more of:\n\n    /etc/profile\n    ~/.bash_profile\n    ~/.bash_login\n    ~/.profile\n    ~/.bashrc\n    /etc/bash.bashrc.local\n\nTo setup your login, ~/.bashrc is recommended, for global (and root) setup\nadd the commands to /etc/bash.bashrc.local\n\nTo set up on login, add the command:\n    . <dir>/cdll\nFor example if cdll is in your local home directory:\n    . ~/cdll\nIf in /usr/bin then:\n    . /usr/bin/cdll\n\nIf you want to use this instead of the buitin cd command then add:\n    alias cd='cd_new'\nWe would also recommend the following commands:\n    alias @='cd_new @'\n    cd -U\n    cd -D\n\nIf you want to use cdll's prompt facilty then add the following:\n    CDL_PROMPTLEN=nn\nWhere nn is a number described below. Initially 99 would be suitable\nnumber.\n\nThus the script looks something like this:\n\n    ######################################################################\n    # CD Setup\n    ######################################################################\n    CDL_PROMPTLEN=21        # Allow a prompt length of up to 21 characters\n    . /usr/bin/cdll         # Initialise cdll\n    alias cd='cd_new'       # Replace the built in cd command\n    alias @='cd_new @'      # Allow @ at the prompt to display history\n    cd -U                   # Upload directories\n    cd -D                   # Set default action to non-posix\n    ######################################################################\n\nThe full meaning of these commands will become clear later.\n\nThere are a couple of caveats. If another program changes the directory\nwithout calling cdll, then the directory won't be put on the stack and\nalso if the prompt facility is used then this will not be updated. Two\nprograms that can do this are pushd and popd. To update the prompt and\nstack simply enter:\n\n    cd .\n\nNote that if the previous entry on the stack is the current directory\nthen the stack is not updated.\n\nUsage\n=====  \ncd [dir] [0-9] [@[s&#124;h] [-g <dir>] [-d] [-D] [-r<n>]\n   [dir&#124;0-9] [-R<n>] [<dir>&#124;0-9] [-s<n>] [-S<n>]\n   [-u] [-U] [-f] [-F] [-h] [-H] [-v]\n\n    <dir>       Go to directory\n    0-n         Goto previous directory (0 is previous,\n                1 is last but 1, etc.)\n                n is up to max history (default is 50)\n    @           List history and special entries (Usually available as $ @)\n    @h          List history entries\n    @s          List special entries\n    -g [<dir>]  Go to literal name (bypass special names)\n                This is to allow access to dirs called '0','1','-h' etc\n    -d          Change default action - verbose. (See note)\n    -D          Change default action - silent. (See note)\n    -s<n>       Go to the special entry <n>\n    -S<n>       Go to the special entry <n>\n                      and replace it with the current dir\n    -r<n> [<dir>] Go to directory <dir>\n                              and then put it on special entry <n>\n    -R<n> [<dir>] Go to directory <dir>\n                              and put current dir on special entry <n>\n    -a<n>       Alternative suggested directory. See note below.\n    -f [<file>] File entries to <file>.\n    -u [<file>] Update entries from <file>.\n                If no filename supplied then default file (~/cdfile) is used\n                -F and -U are silent versions\n    -v          Print version number\n    -h          Help\n    -H          Detailed help\n\nExamples\n========\n\nThese examples assume non-default mode is set (that is, cd with no\nparameters will go to the most recent stack directory), that aliases\nhave been set up for cd and @ as described above and that cd's prompt\nfacility is active and the prompt length is 21 characters.\n\n    /home/phil$ @\n    # List the entries with the @\n    History:\n    # Output of the @ command\n    .....\n    # Skipped these entries for brevity\n    1 /home/phil/ummdev               S1 /home/phil/perl\n    # Most recent two history entries\n    0 /home/phil/perl/eg              S0 /home/phil/umm/ummdev\n    # and two special entries are shown\n\n    /home/phil$ cd /home/phil/utils/Cdll\n    # Now change directories\n    /home/phil/utils/Cdll$ @\n    # Prompt reflects the directory.\n    History:\n    # New history\n    .....   \n    1 /home/phil/perl/eg              S1 /home/phil/perl\n    # History entry 0 has moved to 1\n    0 /home/phil                      S0 /home/phil/umm/ummdev\n    # and the most recent has entered\n\nTo go to a history entry:\n\n    /home/phil/utils/Cdll$ cd 1\n    # Go to history entry 1.\n    /home/phil/perl/eg$\n    # Current directory is now what was 1\n\nTo go to a special entry:\n\n    /home/phil/perl/eg$ cd -s1\n    # Go to special entry 1\n    /home/phil/umm/ummdev$\n    # Current directory is S1\n\nTo go to a directory called, for example, 1:\n\n    /home/phil$ cd -g 1\n    # -g ignores the special meaning of 1\n    /home/phil/1$\n\nTo put current directory on the special list as S1:\n    cd -r1 .        #  OR\n    cd -R1 .        #  These have the same effect if the directory is\n                    #+ . (the current directory)\n\nTo go to a directory and add it as a special  \n  The directory for -r<n> or -R<n> may be a number.\n  For example:\n        $ cd -r3 4  Go to history entry 4 and put it on special entry 3\n        $ cd -R3 4  Put current dir on the special entry 3 and go to\n                    history entry 4\n        $ cd -s3    Go to special entry 3\n\n    Note that commands R,r,S and s may be used without a number and\n    refer to 0:\n        $ cd -s     Go to special entry 0\n        $ cd -S     Go to special entry 0 and make special entry 0\n                    current dir\n        $ cd -r 1   Go to history entry 1 and put it on special entry 0\n        $ cd -r     Go to history entry 0 and put it on special entry 0\n\n    Alternative suggested directories:\n\n    If a directory is not found, then CD will suggest any\n    possibilities. These are directories starting with the same letters\n    and if any are found they are listed prefixed with -a<n>\n    where <n> is a number. It's possible to go to the directory\n    by entering cd -a<n> on the command line.\n\n        Use cd -d or -D to change default cd action. cd -H will show\n        current action.\n\n        The history entries (0-n) are stored in the environment variables\n        CD[0] - CD[n]\n        Similarly the special directories S0 - 9 are in the environment\n        variable CDS[0] - CDS[9]\n        and may be accessed from the command line, for example:\n\n            ls -l ${CDS[3]}\n            cat ${CD[8]}/file.txt\n\n        The default pathname for the -f and -u commands is ~\n        The default filename for the -f and -u commands is cdfile\n\nConfiguration\n=============\n\n    The following environment variables can be set:\n\n        CDL_PROMPTLEN  - Set to the length of prompt you require.\n            Prompt string is set to the right characters of the current\n            directory. If not set, then prompt is left unchanged. Note\n            that this is the number of characters that the directory is\n            shortened to, not the total characters in the prompt.\n\n            CDL_PROMPT_PRE - Set to the string to prefix the prompt.\n                Default is:\n                    non-root:  \"\\\\[\\\\e[01;34m\\\\]\"  (sets colour to blue).\n                    root:      \"\\\\[\\\\e[01;31m\\\\]\"  (sets colour to red).\n\n            CDL_PROMPT_POST    - Set to the string to suffix the prompt.\n                Default is:\n                    non-root:  \"\\\\[\\\\e[00m\\\\]$\"\n                               (resets colour and displays $).\n                    root:      \"\\\\[\\\\e[00m\\\\]#\"\n                               (resets colour and displays #).\n\n        Note:\n            CDL_PROMPT_PRE & _POST only t\n\n        CDPath - Set the default path for the -f & -u options.\n                 Default is home directory\n        CDFile - Set the default filename for the -f & -u options.\n                 Default is cdfile\n\n    There are three variables defined in the file cdll which control the\n    number of entries stored or displayed. They are in the section labeled\n    'Initialisation here' towards the end of the file.\n\n        cd_maxhistory       - The number of history entries stored.\n                              Default is 50.\n        cd_maxspecial       - The number of special entries allowed.\n                              Default is 9.\n        cd_histcount        - The number of history and special entries\n                              displayed. Default is 9.\n\n    Note that cd_maxspecial should be >= cd_histcount to avoid displaying\n    special entries that can't be set.\n\nVersion: 1.2.1 Date: 24-MAY-2003\n\nDOCUMENTATION\n```", "```sh #!/bin/bash\n# soundcard-on.sh\n\n#  Script author: Mkarcher\n#  http://www.thinkwiki.org/wiki  ...\n#  /Script_for_configuring_the_CS4239_sound_chip_in_PnP_mode\n#  ABS Guide author made minor changes and added comments.\n#  Couldn't contact script author to ask for permission to use, but ...\n#+ the script was released under the FDL,\n#+ so its use here should be both legal and ethical.\n\n#  Sound-via-pnp-script for Thinkpad 600E\n#+ and possibly other computers with onboard CS4239/CS4610\n#+ that do not work with the PCI driver\n#+ and are not recognized by the PnP code of snd-cs4236.\n#  Also for some 770-series Thinkpads, such as the 770x.\n#  Run as root user, of course.\n#\n#  These are old and very obsolete laptop computers,\n#+ but this particular script is very instructive,\n#+ as it shows how to set up and hack device files.\n\n#  Search for sound card pnp device:\n\nfor dev in /sys/bus/pnp/devices/*\ndo\n  grep CSC0100 $dev/id > /dev/null && WSSDEV=$dev\n  grep CSC0110 $dev/id > /dev/null && CTLDEV=$dev\ndone\n# On 770x:\n# WSSDEV = /sys/bus/pnp/devices/00:07\n# CTLDEV = /sys/bus/pnp/devices/00:06\n# These are symbolic links to /sys/devices/pnp0/ ...\n\n#  Activate devices:\n#  Thinkpad boots with devices disabled unless \"fast boot\" is turned off\n#+ (in BIOS).\n\necho activate > $WSSDEV/resources\necho activate > $CTLDEV/resources\n\n# Parse resource settings.\n\n{ read # Discard \"state = active\" (see below).\n  read bla port1\n  read bla port2\n  read bla port3\n  read bla irq\n  read bla dma1\n  read bla dma2\n # The \"bla's\" are labels in the first field: \"io,\" \"state,\" etc.\n # These are discarded.\n\n #  Hack: with PnPBIOS: ports are: port1: WSS, port2:\n #+ OPL, port3: sb (unneeded)\n #       with ACPI-PnP:ports are: port1: OPL, port2: sb, port3: WSS\n #  (ACPI bios seems to be wrong here, the PnP-card-code in snd-cs4236.c\n #+  uses the PnPBIOS port order)\n #  Detect port order using the fixed OPL port as reference.\n  if [ ${port2%%-*} = 0x388 ]\n #            ^^^^  Strip out everything following hyphen in port address.\n #                  So, if port1 is 0x530-0x537\n #+                 we're left with 0x530 -- the start address of the port.\n then\n   # PnPBIOS: usual order\n   port=${port1%%-*}\n   oplport=${port2%%-*}\n else\n   # ACPI: mixed-up order\n   port=${port3%%-*}\n   oplport=${port1%%-*}\n fi\n } < $WSSDEV/resources\n# To see what's going on here:\n# ---------------------------\n#   cat /sys/devices/pnp0/00:07/resources\n#\n#   state = active\n#   io 0x530-0x537\n#   io 0x388-0x38b\n#   io 0x220-0x233\n#   irq 5\n#   dma 1\n#   dma 0\n#   ^^^   \"bla\" labels in first field (discarded). \n\n{ read # Discard first line, as above.\n  read bla port1\n  cport=${port1%%-*}\n  #            ^^^^\n  # Just want _start_ address of port.\n} < $CTLDEV/resources\n\n# Load the module:\n\nmodprobe --ignore-install snd-cs4236 port=$port cport=$cport\\\nfm_port=$oplport irq=$irq dma1=$dma1 dma2=$dma2 isapnp=0 index=0\n# See the modprobe manpage.\n\nexit $?\n```", "```sh #!/bin/bash\n# find-splitpara.sh\n#  Finds split paragraphs in a text file,\n#+ and tags the line numbers.\n\nARGCOUNT=1       # Expect one arg.\nOFF=0            # Flag states.\nON=1\nE_WRONGARGS=85\n\nfile=\"$1\"        # Target filename.\nlineno=1         # Line number. Start at 1.\nFlag=$OFF        # Blank line flag.\n\nif [ $# -ne \"$ARGCOUNT\" ]\nthen\n  echo \"Usage: `basename $0` FILENAME\"\n  exit $E_WRONGARGS\nfi  \n\nfile_read ()     # Scan file for pattern, then print line.\n{\nwhile read line\ndo\n\n  if [[ \"$line\" =~ ^[a-z] && $Flag -eq $ON ]]\n     then  # Line begins with lowercase character, following blank line.\n     echo -n \"$lineno::   \"\n     echo \"$line\"\n  fi\n\n  if [[ \"$line\" =~ ^$ ]]\n     then       #  If blank line,\n     Flag=$ON   #+ set flag.\n  else\n     Flag=$OFF\n  fi\n\n  ((lineno++))\n\ndone\n} < $file  # Redirect file into function's stdin.\n\nfile_read\n\nexit $?\n\n# ----------------------------------------------------------------\nThis is line one of an example paragraph, bla, bla, bla.\nThis is line two, and line three should follow on next line, but\n\nthere is a blank line separating the two parts of the paragraph.\n# ----------------------------------------------------------------\n\nRunning this script on a file containing the above paragraph\nyields:\n\n4::   there is a blank line separating the two parts of the paragraph.\n\nThere will be additional output for all the other split paragraphs\nin the target file.\n```", "```sh #!/bin/bash\n# insertion-sort.bash: Insertion sort implementation in Bash\n#                      Heavy use of Bash array features:\n#+                     (string) slicing, merging, etc\n# URL: http://www.lugmen.org.ar/~jjo/jjotip/insertion-sort.bash.d\n#+          /insertion-sort.bash.sh\n#\n# Author: JuanJo Ciarlante <jjo@irrigacion.gov.ar>\n# Lightly reformatted by ABS Guide author.\n# License: GPLv2\n# Used in ABS Guide with author's permission (thanks!).\n#\n# Test with:   ./insertion-sort.bash -t\n# Or:          bash insertion-sort.bash -t\n# The following *doesn't* work:\n#              sh insertion-sort.bash -t\n#  Why not? Hint: which Bash-specific features are disabled\n#+ when running a script by 'sh script.sh'?\n#\n: ${DEBUG:=0}  # Debug, override with:  DEBUG=1 ./scriptname . . .\n# Parameter substitution -- set DEBUG to 0 if not previously set.\n\n# Global array: \"list\"\ntypeset -a list\n# Load whitespace-separated numbers from stdin.\nif [ \"$1\" = \"-t\" ]; then\nDEBUG=1\n        read -a list < <( od -Ad -w24 -t u2 /dev/urandom ) # Random list.\n#                    ^ ^  process substition\nelse\n        read -a list\nfi\nnumelem=${#list[*]}\n\n#  Shows the list, marking the element whose index is $1\n#+ by surrounding it with the two chars passed as $2.\n#  Whole line prefixed with $3.\nshowlist()\n  {\n  echo \"$3\"${list[@]:0:$1} ${2:0:1}${list[$1]}${2:1:1} ${list[@]:$1+1};\n  }\n\n# Loop _pivot_ -- from second element to end of list.\nfor(( i=1; i<numelem; i++ )) do\n        ((DEBUG))&&showlist i \"[]\" \" \"\n        # From current _pivot_, back to first element.\n        for(( j=i; j; j-- )) do\n                # Search for the 1st elem. less than current \"pivot\" . . .\n                [[ \"${list[j-1]}\" -le \"${list[i]}\" ]] && break\n        done\n\t(( i==j )) && continue ## No insertion was needed for this element.\n\t# . . . Move list[i] (pivot) to the left of list[j]:\n        list=(${list[@]:0:j} ${list[i]} ${list[j]}\\\n\t#         {0,j-1}        {i}       {j}\n              ${list[@]:j+1:i-(j+1)} ${list[@]:i+1})\n\t#         {j+1,i-1}              {i+1,last}\n\t((DEBUG))&&showlist j \"<>\" \"*\"\ndone\n\necho\necho  \"------\"\necho $'Result:\\n'${list[@]}\n\nexit $?\n```", "```sh #!/bin/bash\n# sd.sh: Standard Deviation\n\n#  The Standard Deviation indicates how consistent a set of data is.\n#  It shows to what extent the individual data points deviate from the\n#+ arithmetic mean, i.e., how much they \"bounce around\" (or cluster).\n#  It is essentially the average deviation-distance of the\n#+ data points from the mean.\n\n# =========================================================== #\n#    To calculate the Standard Deviation:\n#\n# 1  Find the arithmetic mean (average) of all the data points.\n# 2  Subtract each data point from the arithmetic mean,\n#    and square that difference.\n# 3  Add all of the individual difference-squares in # 2.\n# 4  Divide the sum in # 3 by the number of data points.\n#    This is known as the \"variance.\"\n# 5  The square root of # 4 gives the Standard Deviation.\n# =========================================================== #\n\ncount=0         # Number of data points; global.\nSC=9            # Scale to be used by bc. Nine decimal places.\nE_DATAFILE=90   # Data file error.\n\n# ----------------- Set data file ---------------------\nif [ ! -z \"$1\" ]  # Specify filename as cmd-line arg?\nthen\n  datafile=\"$1\" #  ASCII text file,\nelse            #+ one (numerical) data point per line!\n  datafile=sample.dat\nfi              #  See example data file, below.\n\nif [ ! -e \"$datafile\" ]\nthen\n  echo \"\\\"\"$datafile\"\\\" does not exist!\"\n  exit $E_DATAFILE\nfi\n# -----------------------------------------------------\n\narith_mean ()\n{\n  local rt=0         # Running total.\n  local am=0         # Arithmetic mean.\n  local ct=0         # Number of data points.\n\n  while read value   # Read one data point at a time.\n  do\n    rt=$(echo \"scale=$SC; $rt + $value\" &#124; bc)\n    (( ct++ ))\n  done\n\n  am=$(echo \"scale=$SC; $rt / $ct\" &#124; bc)\n\n  echo $am; return $ct   # This function \"returns\" TWO values!\n  #  Caution: This little trick will not work if $ct > 255!\n  #  To handle a larger number of data points,\n  #+ simply comment out the \"return $ct\" above.\n} <\"$datafile\"   # Feed in data file.\n\nsd ()\n{\n  mean1=$1  # Arithmetic mean (passed to function).\n  n=$2      # How many data points.\n  sum2=0    # Sum of squared differences (\"variance\").\n  avg2=0    # Average of $sum2.\n  sdev=0    # Standard Deviation.\n\n  while read value   # Read one line at a time.\n  do\n    diff=$(echo \"scale=$SC; $mean1 - $value\" &#124; bc)\n    # Difference between arith. mean and data point.\n    dif2=$(echo \"scale=$SC; $diff * $diff\" &#124; bc) # Squared.\n    sum2=$(echo \"scale=$SC; $sum2 + $dif2\" &#124; bc) # Sum of squares.\n  done\n\n    avg2=$(echo \"scale=$SC; $sum2 / $n\" &#124; bc)  # Avg. of sum of squares.\n    sdev=$(echo \"scale=$SC; sqrt($avg2)\" &#124; bc) # Square root =\n    echo $sdev                                 # Standard Deviation.\n\n} <\"$datafile\"   # Rewinds data file.\n\n# ======================================================= #\nmean=$(arith_mean); count=$?   # Two returns from function!\nstd_dev=$(sd $mean $count)\n\necho\necho \"Number of data points in \\\"\"$datafile\"\\\" = $count\"\necho \"Arithmetic mean (average) = $mean\"\necho \"Standard Deviation = $std_dev\"\necho\n# ======================================================= #\n\nexit\n\n#  This script could stand some drastic streamlining,\n#+ but not at the cost of reduced legibility, please.\n\n# ++++++++++++++++++++++++++++++++++++++++ #\n# A sample data file (sample1.dat):\n\n# 18.35\n# 19.0\n# 18.88\n# 18.91\n# 18.64\n\n# $ sh sd.sh sample1.dat\n\n# Number of data points in \"sample1.dat\" = 5\n# Arithmetic mean (average) = 18.756000000\n# Standard Deviation = .235338054\n# ++++++++++++++++++++++++++++++++++++++++ #\n```", "```sh #!/bin/bash\n# pad.sh\n\n#######################################################\n#               PAD (xml) file creator\n#+ Written by Mendel Cooper <thegrendel.abs@gmail.com>.\n#+ Released to the Public Domain.\n#\n#  Generates a \"PAD\" descriptor file for shareware\n#+ packages, according to the specifications\n#+ of the ASP.\n#  http://www.asp-shareware.org/pad\n#######################################################\n\n# Accepts (optional) save filename as a command-line argument.\nif [ -n \"$1\" ]\nthen\n  savefile=$1\nelse\n  savefile=save_file.xml               # Default save_file name.\nfi  \n\n# ===== PAD file headers =====\nHDR1=\"<?xml version=\\\"1.0\\\" encoding=\\\"Windows-1252\\\" ?>\"\nHDR2=\"<XML_DIZ_INFO>\"\nHDR3=\"<MASTER_PAD_VERSION_INFO>\"\nHDR4=\"\\t<MASTER_PAD_VERSION>1.15</MASTER_PAD_VERSION>\"\nHDR5=\"\\t<MASTER_PAD_INFO>Portable Application Description, or PAD\nfor short, is a data set that is used by shareware authors to\ndisseminate information to anyone interested in their software products.\nTo find out more go to http://www.asp-shareware.org/pad</MASTER_PAD_INFO>\"\nHDR6=\"</MASTER_PAD_VERSION_INFO>\"\n# ============================\n\nfill_in ()\n{\n  if [ -z \"$2\" ]\n  then\n    echo -n \"$1? \"     # Get user input.\n  else\n    echo -n \"$1 $2? \"  # Additional query?\n  fi  \n\n  read var             # May paste to fill in field.\n                       # This shows how flexible \"read\" can be.\n\n  if [ -z \"$var\" ]\n  then\n    echo -e \"\\t\\t<$1 />\" >>$savefile    # Indent with 2 tabs.\n    return\n  else\n    echo -e \"\\t\\t<$1>$var</$1>\" >>$savefile\n    return ${#var}     # Return length of input string.\n  fi\n}    \n\ncheck_field_length ()  # Check length of program description fields.\n{\n  # $1 = maximum field length\n  # $2 = actual field length\n  if [ \"$2\" -gt \"$1\" ]\n  then\n    echo \"Warning: Maximum field length of $1 characters exceeded!\"\n  fi\n}  \n\nclear                  # Clear screen.\necho \"PAD File Creator\"\necho \"--- ---- -------\"\necho\n\n# Write File Headers to file.\necho $HDR1 >$savefile\necho $HDR2 >>$savefile\necho $HDR3 >>$savefile\necho -e $HDR4 >>$savefile\necho -e $HDR5 >>$savefile\necho $HDR6 >>$savefile\n\n# Company_Info\necho \"COMPANY INFO\"\nCO_HDR=\"Company_Info\"\necho \"<$CO_HDR>\" >>$savefile\n\nfill_in Company_Name\nfill_in Address_1\nfill_in Address_2\nfill_in City_Town \nfill_in State_Province\nfill_in Zip_Postal_Code\nfill_in Country\n\n# If applicable:\n# fill_in ASP_Member \"[Y/N]\"\n# fill_in ASP_Member_Number\n# fill_in ESC_Member \"[Y/N]\"\n\nfill_in Company_WebSite_URL\n\nclear   # Clear screen between sections.\n\n   # Contact_Info\necho \"CONTACT INFO\"\nCONTACT_HDR=\"Contact_Info\"\necho \"<$CONTACT_HDR>\" >>$savefile\nfill_in Author_First_Name\nfill_in Author_Last_Name\nfill_in Author_Email\nfill_in Contact_First_Name\nfill_in Contact_Last_Name\nfill_in Contact_Email\necho -e \"\\t</$CONTACT_HDR>\" >>$savefile\n   # END Contact_Info\n\nclear\n\n   # Support_Info\necho \"SUPPORT INFO\"\nSUPPORT_HDR=\"Support_Info\"\necho \"<$SUPPORT_HDR>\" >>$savefile\nfill_in Sales_Email\nfill_in Support_Email\nfill_in General_Email\nfill_in Sales_Phone\nfill_in Support_Phone\nfill_in General_Phone\nfill_in Fax_Phone\necho -e \"\\t</$SUPPORT_HDR>\" >>$savefile\n   # END Support_Info\n\necho \"</$CO_HDR>\" >>$savefile\n# END Company_Info\n\nclear\n\n# Program_Info \necho \"PROGRAM INFO\"\nPROGRAM_HDR=\"Program_Info\"\necho \"<$PROGRAM_HDR>\" >>$savefile\nfill_in Program_Name\nfill_in Program_Version\nfill_in Program_Release_Month\nfill_in Program_Release_Day\nfill_in Program_Release_Year\nfill_in Program_Cost_Dollars\nfill_in Program_Cost_Other\nfill_in Program_Type \"[Shareware/Freeware/GPL]\"\nfill_in Program_Release_Status \"[Beta, Major Upgrade, etc.]\"\nfill_in Program_Install_Support\nfill_in Program_OS_Support \"[Win9x/Win2k/Linux/etc.]\"\nfill_in Program_Language \"[English/Spanish/etc.]\"\n\necho; echo\n\n  # File_Info \necho \"FILE INFO\"\nFILEINFO_HDR=\"File_Info\"\necho \"<$FILEINFO_HDR>\" >>$savefile\nfill_in Filename_Versioned\nfill_in Filename_Previous\nfill_in Filename_Generic\nfill_in Filename_Long\nfill_in File_Size_Bytes\nfill_in File_Size_K\nfill_in File_Size_MB\necho -e \"\\t</$FILEINFO_HDR>\" >>$savefile\n  # END File_Info \n\nclear\n\n  # Expire_Info \necho \"EXPIRE INFO\"\nEXPIRE_HDR=\"Expire_Info\"\necho \"<$EXPIRE_HDR>\" >>$savefile\nfill_in Has_Expire_Info \"Y/N\"\nfill_in Expire_Count\nfill_in Expire_Based_On\nfill_in Expire_Other_Info\nfill_in Expire_Month\nfill_in Expire_Day\nfill_in Expire_Year\necho -e \"\\t</$EXPIRE_HDR>\" >>$savefile\n  # END Expire_Info \n\nclear\n\n  # More Program_Info\necho \"ADDITIONAL PROGRAM INFO\"\nfill_in Program_Change_Info\nfill_in Program_Specific_Category\nfill_in Program_Categories\nfill_in Includes_JAVA_VM \"[Y/N]\"\nfill_in Includes_VB_Runtime \"[Y/N]\"\nfill_in Includes_DirectX \"[Y/N]\"\n  # END More Program_Info\n\necho \"</$PROGRAM_HDR>\" >>$savefile\n# END Program_Info \n\nclear\n\n# Program Description\necho \"PROGRAM DESCRIPTIONS\"\nPROGDESC_HDR=\"Program_Descriptions\"\necho \"<$PROGDESC_HDR>\" >>$savefile\n\nLANG=\"English\"\necho \"<$LANG>\" >>$savefile\n\nfill_in Keywords \"[comma + space separated]\"\necho\necho \"45, 80, 250, 450, 2000 word program descriptions\"\necho \"(may cut and paste into field)\"\n#  It would be highly appropriate to compose the following\n#+ \"Char_Desc\" fields with a text editor,\n#+ then cut-and-paste the text into the answer fields.\necho\necho \"              &#124;---------------45 characters---------------&#124;\"\nfill_in Char_Desc_45\ncheck_field_length 45 \"$?\"\necho\nfill_in Char_Desc_80\ncheck_field_length 80 \"$?\"\n\nfill_in Char_Desc_250\ncheck_field_length 250 \"$?\"\n\nfill_in Char_Desc_450\nfill_in Char_Desc_2000\n\necho \"</$LANG>\" >>$savefile\necho \"</$PROGDESC_HDR>\" >>$savefile\n# END Program Description\n\nclear\necho \"Done.\"; echo; echo\necho \"Save file is:  \\\"\"$savefile\"\\\"\"\n\nexit 0\n```", "```sh #!/bin/bash\n# maned.sh\n# A rudimentary man page editor\n\n# Version: 0.1 (Alpha, probably buggy)\n# Author: Mendel Cooper <thegrendel.abs@gmail.com>\n# Reldate: 16 June 2008\n# License: GPL3\n\nsavefile=      # Global, used in multiple functions.\nE_NOINPUT=90   # User input missing (error). May or may not be critical.\n\n# =========== Markup Tags ============ #\nTopHeader=\".TH\"\nNameHeader=\".SH NAME\"\nSyntaxHeader=\".SH SYNTAX\"\nSynopsisHeader=\".SH SYNOPSIS\"\nInstallationHeader=\".SH INSTALLATION\"\nDescHeader=\".SH DESCRIPTION\"\nOptHeader=\".SH OPTIONS\"\nFilesHeader=\".SH FILES\"\nEnvHeader=\".SH ENVIRONMENT\"\nAuthHeader=\".SH AUTHOR\"\nBugsHeader=\".SH BUGS\"\nSeeAlsoHeader=\".SH SEE ALSO\"\nBOLD=\".B\"\n# Add more tags, as needed.\n# See groff docs for markup meanings.\n# ==================================== #\n\nstart ()\n{\nclear                  # Clear screen.\necho \"ManEd\"\necho \"-----\"\necho\necho \"Simple man page creator\"\necho \"Author: Mendel Cooper\"\necho \"License: GPL3\"\necho; echo; echo\n}\n\nprogname ()\n{\n  echo -n \"Program name? \"\n  read name\n\n  echo -n \"Manpage section? [Hit RETURN for default (\\\"1\\\") ]  \"\n  read section\n  if [ -z \"$section\" ]\n  then\n    section=1   # Most man pages are in section 1.\n  fi\n\n  if [ -n \"$name\" ]\n  then\n    savefile=\"\"$name\".\"$section\"\"       #  Filename suffix = section.\n    echo -n \"$1 \" >>$savefile\n    name1=$(echo \"$name\" &#124; tr a-z A-Z)  #  Change to uppercase,\n                                        #+ per man page convention.\n    echo -n \"$name1\" >>$savefile\n  else\n    echo \"Error! No input.\"             # Mandatory input.\n    exit $E_NOINPUT                     # Critical!\n    #  Exercise: The script-abort if no filename input is a bit clumsy.\n    #            Rewrite this section so a default filename is used\n    #+           if no input.\n  fi\n\n  echo -n \"  \\\"$section\\\"\">>$savefile   # Append, always append.\n\n  echo -n \"Version? \"\n  read ver\n  echo -n \" \\\"Version $ver \\\"\">>$savefile\n  echo >>$savefile\n\n  echo -n \"Short description [0 - 5 words]? \"\n  read sdesc\n  echo \"$NameHeader\">>$savefile\n  echo \"\"$BOLD\" \"$name\"\">>$savefile\n  echo \"\\- \"$sdesc\"\">>$savefile\n\n}\n\nfill_in ()\n{ # This function more or less copied from \"pad.sh\" script.\n  echo -n \"$2? \"       # Get user input.\n  read var             # May paste (a single line only!) to fill in field.\n\n  if [ -n \"$var\" ]\n  then\n    echo \"$1 \" >>$savefile\n    echo -n \"$var\" >>$savefile\n  else                 # Don't append empty field to file.\n    return $E_NOINPUT  # Not critical here.\n  fi\n\n  echo >>$savefile\n\n}    \n\nend ()\n{\nclear\necho -n \"Would you like to view the saved man page (y/n)? \"\nread ans\nif [ \"$ans\" = \"n\" -o \"$ans\" = \"N\" ]; then exit; fi\nexec less \"$savefile\"  #  Exit script and hand off control to \"less\" ...\n                       #+ ... which formats for viewing man page source.\n}\n\n# ---------------------------------------- #\nstart\nprogname \"$TopHeader\"\nfill_in \"$SynopsisHeader\" \"Synopsis\"\nfill_in \"$DescHeader\" \"Long description\"\n# May paste in *single line* of text.\nfill_in \"$OptHeader\" \"Options\"\nfill_in \"$FilesHeader\" \"Files\"\nfill_in \"$AuthHeader\" \"Author\"\nfill_in \"$BugsHeader\" \"Bugs\"\nfill_in \"$SeeAlsoHeader\" \"See also\"\n# fill_in \"$OtherHeader\" ... as necessary.\nend    # ... exit not needed.\n# ---------------------------------------- #\n\n#  Note that the generated man page will usually\n#+ require manual fine-tuning with a text editor.\n#  However, it's a distinct improvement upon\n#+ writing man source from scratch\n#+ or even editing a blank man page template.\n\n#  The main deficiency of the script is that it permits\n#+ pasting only a single text line into the input fields.\n#  This may be a long, cobbled-together line, which groff\n#  will automatically wrap and hyphenate.\n#  However, if you want multiple (newline-separated) paragraphs,\n#+ these must be inserted by manual text editing on the\n#+ script-generated man page.\n#  Exercise (difficult): Fix this!\n\n#  This script is not nearly as elaborate as the\n#+ full-featured \"manedit\" package\n#+ http://freshmeat.net/projects/manedit/\n#+ but it's much easier to use.\n```", "```sh #!/bin/bash -i\n# petals.sh\n\n#########################################################################\n# Petals Around the Rose                                                #\n#                                                                       #\n# Version 0.1 Created by Serghey Rodin                                  #\n# Version 0.2 Modded by ABS Guide Author                                #\n#                                                                       #\n# License: GPL3                                                         #\n# Used in ABS Guide with permission.                                    #\n# ##################################################################### #\n\nhits=0      # Correct guesses.\nWIN=6       # Mastered the game.\nALMOST=5    # One short of mastery.\nEXIT=exit   # Give up early?\n\nRANDOM=$$   # Seeds the random number generator from PID of script.\n\n# Bones (ASCII graphics for dice)\nbone1[1]=\"&#124;         &#124;\"\nbone1[2]=\"&#124;       o &#124;\"\nbone1[3]=\"&#124;       o &#124;\"\nbone1[4]=\"&#124; o     o &#124;\"\nbone1[5]=\"&#124; o     o &#124;\"\nbone1[6]=\"&#124; o     o &#124;\"\nbone2[1]=\"&#124;    o    &#124;\"\nbone2[2]=\"&#124;         &#124;\"\nbone2[3]=\"&#124;    o    &#124;\"\nbone2[4]=\"&#124;         &#124;\"\nbone2[5]=\"&#124;    o    &#124;\"\nbone2[6]=\"&#124; o     o &#124;\"\nbone3[1]=\"&#124;         &#124;\"\nbone3[2]=\"&#124; o       &#124;\"\nbone3[3]=\"&#124; o       &#124;\"\nbone3[4]=\"&#124; o     o &#124;\"\nbone3[5]=\"&#124; o     o &#124;\"\nbone3[6]=\"&#124; o     o &#124;\"\nbone=\"+---------+\"\n\n# Functions\n\ninstructions () {\n\n  clear\n  echo -n \"Do you need instructions? (y/n) \"; read ans\n  if [ \"$ans\" = \"y\" -o \"$ans\" = \"Y\" ]; then\n    clear\n    echo -e '\\E[34;47m'  # Blue type.\n\n#  \"cat document\"\n    cat <<INSTRUCTIONSZZZ\nThe name of the game is Petals Around the Rose,\nand that name is significant.\nFive dice will roll and you must guess the \"answer\" for each roll.\nIt will be zero or an even number.\nAfter your guess, you will be told the answer for the roll, but . . .\nthat's ALL the information you will get.\n\nSix consecutive correct guesses admits you to the\nFellowship of the Rose.\nINSTRUCTIONSZZZ\n\n    echo -e \"\\033[0m\"    # Turn off blue.\n    else clear\n  fi\n\n}\n\nfortune ()\n{\n  RANGE=7\n  FLOOR=0\n  number=0\n  while [ \"$number\" -le $FLOOR ]\n  do\n    number=$RANDOM\n    let \"number %= $RANGE\"   # 1 - 6.\n  done\n\n  return $number\n}\n\nthrow () { # Calculate each individual die.\n  fortune; B1=$?\n  fortune; B2=$?\n  fortune; B3=$?\n  fortune; B4=$?\n  fortune; B5=$?\n\n  calc () { # Function embedded within a function!\n    case \"$1\" in\n       3   ) rose=2;;\n       5   ) rose=4;;\n       *   ) rose=0;;\n    esac    # Simplified algorithm.\n            # Doesn't really get to the heart of the matter.\n    return $rose\n  }\n\n  answer=0\n  calc \"$B1\"; answer=$(expr $answer + $(echo $?))\n  calc \"$B2\"; answer=$(expr $answer + $(echo $?))\n  calc \"$B3\"; answer=$(expr $answer + $(echo $?))\n  calc \"$B4\"; answer=$(expr $answer + $(echo $?))\n  calc \"$B5\"; answer=$(expr $answer + $(echo $?))\n}\n\ngame ()\n{ # Generate graphic display of dice throw.\n  throw\n    echo -e \"\\033[1m\"    # Bold.\n  echo -e \"\\n\"\n  echo -e \"$bone\\t$bone\\t$bone\\t$bone\\t$bone\"\n  echo -e \\\n \"${bone1[$B1]}\\t${bone1[$B2]}\\t${bone1[$B3]}\\t${bone1[$B4]}\\t${bone1[$B5]}\"\n  echo -e \\\n \"${bone2[$B1]}\\t${bone2[$B2]}\\t${bone2[$B3]}\\t${bone2[$B4]}\\t${bone2[$B5]}\"\n  echo -e \\\n \"${bone3[$B1]}\\t${bone3[$B2]}\\t${bone3[$B3]}\\t${bone3[$B4]}\\t${bone3[$B5]}\"\n  echo -e \"$bone\\t$bone\\t$bone\\t$bone\\t$bone\"\n  echo -e \"\\n\\n\\t\\t\"\n    echo -e \"\\033[0m\"    # Turn off bold.\n  echo -n \"There are how many petals around the rose? \"\n}\n\n# ============================================================== #\n\ninstructions\n\nwhile [ \"$petal\" != \"$EXIT\" ]    # Main loop.\ndo\n  game\n  read petal\n  echo \"$petal\" &#124; grep [0-9] >/dev/null  # Filter response for digit.\n                                         # Otherwise just roll dice again.\n  if [ \"$?\" -eq 0 ]   # If-loop #1.\n  then\n    if [ \"$petal\" == \"$answer\" ]; then    # If-loop #2.\n    \techo -e \"\\nCorrect. There are $petal petals around the rose.\\n\"\n        (( hits++ ))\n\n        if [ \"$hits\" -eq \"$WIN\" ]; then   # If-loop #3.\n          echo -e '\\E[31;47m'  # Red type.\n          echo -e \"\\033[1m\"    # Bold.\n          echo \"You have unraveled the mystery of the Rose Petals!\"\n          echo \"Welcome to the Fellowship of the Rose!!!\"\n          echo \"(You are herewith sworn to secrecy.)\"; echo\n          echo -e \"\\033[0m\"    # Turn off red & bold.\n          break                # Exit!\n        else echo \"You have $hits correct so far.\"; echo\n\n        if [ \"$hits\" -eq \"$ALMOST\" ]; then\n          echo \"Just one more gets you to the heart of the mystery!\"; echo\n        fi\n\n      fi                                  # Close if-loop #3.\n\n    else\n      echo -e \"\\nWrong. There are $answer petals around the rose.\\n\"\n      hits=0   # Reset number of correct guesses.\n    fi                                    # Close if-loop #2.\n\n    echo -n \"Hit ENTER for the next roll, or type \\\"exit\\\" to end. \"\n    read\n    if [ \"$REPLY\" = \"$EXIT\" ]; then exit\n    fi\n\n  fi                  # Close if-loop #1.\n\n  clear\ndone                  # End of main (while) loop.\n\n###\n\nexit $?\n\n# Resources:\n# ---------\n# 1) http://en.wikipedia.org/wiki/Petals_Around_the_Rose\n#    (Wikipedia entry.)\n# 2) http://www.borrett.id.au/computing/petals-bg.htm\n#    (How Bill Gates coped with the Petals Around the Rose challenge.)\n```", "```sh #!/bin/bash\n# qky.sh\n\n##############################################################\n# QUACKEY: a somewhat simplified version of Perquackey [TM]. #\n#                                                            #\n# Author: Mendel Cooper  <thegrendel.abs@gmail.com>          #\n# version 0.1.02      03 May, 2008                           #\n# License: GPL3                                              #\n##############################################################\n\nWLIST=/usr/share/dict/word.lst\n#                     ^^^^^^^^  Word list file found here.\n#  ASCII word list, one word per line, UNIX format.\n#  A suggested list is the script author's \"yawl\" word list package.\n#  http://bash.deta.in/yawl-0.3.2.tar.gz\n#    or\n#  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz\n\nNONCONS=0     # Word not constructable from letter set.\nCONS=1        # Constructable.\nSUCCESS=0\nNG=1\nFAILURE=''\nNULL=0        # Zero out value of letter (if found).\nMINWLEN=3     # Minimum word length.\nMAXCAT=5      # Maximum number of words in a given category.\nPENALTY=200   # General-purpose penalty for unacceptable words.\ntotal=\nE_DUP=70      # Duplicate word error.\n\nTIMEOUT=10    # Time for word input.\n\nNVLET=10      # 10 letters for non-vulnerable.\nVULET=13      # 13 letters for vulnerable (not yet implemented!).\n\ndeclare -a Words\ndeclare -a Status\ndeclare -a Score=( 0 0 0 0 0 0 0 0 0 0 0 )\n\nletters=( a n s r t m l k p r b c i d s i d z e w u e t f\ne y e r e f e g t g h h i t r s c i t i d i j a t a o l a\nm n a n o v n w o s e l n o s p a q e e r a b r s a o d s\nt g t i t l u e u v n e o x y m r k )\n#  Letter distribution table shamelessly borrowed from \"Wordy\" game,\n#+ ca. 1992, written by a certain fine fellow named Mendel Cooper.\n\ndeclare -a LS\n\nnumelements=${#letters[@]}\nrandseed=\"$1\"\n\ninstructions ()\n{\n  clear\n  echo \"Welcome to QUACKEY, the anagramming word construction game.\"; echo\n  echo -n \"Do you need instructions? (y/n) \"; read ans\n\n   if [ \"$ans\" = \"y\" -o \"$ans\" = \"Y\" ]; then\n     clear\n     echo -e '\\E[31;47m'  # Red foreground. '\\E[34;47m' for blue.\n     cat <<INSTRUCTION1\n\nQUACKEY is a variant of Perquackey [TM].\nThe rules are the same, but the scoring is simplified\nand plurals of previously played words are allowed.\n\"Vulnerable\" play is not yet implemented,\nbut it is otherwise feature-complete.\n\nAs the game begins, the player gets 10 letters.\nThe object is to construct valid dictionary words\nof at least 3-letter length from the letterset.\nEach word-length category\n-- 3-letter, 4-letter, 5-letter, ... --\nfills up with the fifth word entered,\nand no further words in that category are accepted.\n\nThe penalty for too-short (two-letter), duplicate, unconstructable,\nand invalid (not in dictionary) words is -200\\. The same penalty applies\nto attempts to enter a word in a filled-up category.\n\nINSTRUCTION1\n\n  echo -n \"Hit ENTER for next page of instructions. \"; read az1\n\n     cat <<INSTRUCTION2\n\nThe scoring mostly corresponds to classic Perquackey:\nThe first 3-letter word scores    60, plus   10 for each additional one.\nThe first 4-letter word scores   120, plus   20 for each additional one.\nThe first 5-letter word scores   200, plus   50 for each additional one.\nThe first 6-letter word scores   300, plus  100 for each additional one.\nThe first 7-letter word scores   500, plus  150 for each additional one.\nThe first 8-letter word scores   750, plus  250 for each additional one.\nThe first 9-letter word scores  1000, plus  500 for each additional one.\nThe first 10-letter word scores 2000, plus 2000 for each additional one.\n\nCategory completion bonuses are:\n3-letter words   100\n4-letter words   200\n5-letter words   400\n6-letter words   800\n7-letter words  2000\n8-letter words 10000\nThis is a simplification of the absurdly baroque Perquackey bonus\nscoring system.\n\nINSTRUCTION2\n\n  echo -n \"Hit ENTER for final page of instructions. \"; read az1\n\n     cat <<INSTRUCTION3\n\nHitting just ENTER for a word entry ends the game.\n\nIndividual word entry is timed to a maximum of 10 seconds.\n*** Timing out on an entry ends the game. ***\nAside from that, the game is untimed.\n\n--------------------------------------------------\nGame statistics are automatically saved to a file.\n--------------------------------------------------\n\nFor competitive (\"duplicate\") play, a previous letterset\nmay be duplicated by repeating the script's random seed,\ncommand-line parameter \\$1.\nFor example, \"qky 7633\" specifies the letterset \nc a d i f r h u s k ...\nINSTRUCTION3\n\n  echo; echo -n \"Hit ENTER to begin game. \"; read az1\n\n       echo -e \"\\033[0m\"    # Turn off red.\n     else clear\n  fi\n\n  clear\n\n}\n\nseed_random ()\n{                         #  Seed random number generator.\n  if [ -n \"$randseed\" ]   #  Can specify random seed.\n  then                    #+ for play in competitive mode.\n#   RANDOM=\"$randseed\"\n    echo \"RANDOM seed set to \"$randseed\"\"\n  else\n    randseed=\"$$\"         # Or get random seed from process ID.\n    echo \"RANDOM seed not specified, set to Process ID of script ($$).\"\n  fi\n\n  RANDOM=\"$randseed\"\n\n  echo\n}\n\nget_letset ()\n{\n  element=0\n  echo -n \"Letterset:\"\n\n  for lset in $(seq $NVLET)\n  do  # Pick random letters to fill out letterset.\n    LS[element]=\"${letters[$((RANDOM%numelements))]}\"\n    ((element++))\n  done\n\n  echo\n  echo \"${LS[@]}\"\n\n}\n\nadd_word ()\n{\n  wrd=\"$1\"\n  local idx=0\n\n  Status[0]=\"\"\n  Status[3]=\"\"\n  Status[4]=\"\"\n\n  while [ \"${Words[idx]}\" != '' ]\n  do\n    if [ \"${Words[idx]}\" = \"$wrd\" ]\n    then\n      Status[3]=\"Duplicate-word-PENALTY\"\n      let \"Score[0]= 0 - $PENALTY\"\n      let \"Score[1]-=$PENALTY\"\n      return $E_DUP\n    fi\n\n    ((idx++))\n  done\n\n  Words[idx]=\"$wrd\"\n  get_score\n\n}\n\nget_score()\n{\n  local wlen=0\n  local score=0\n  local bonus=0\n  local first_word=0\n  local add_word=0\n  local numwords=0\n\n  wlen=${#wrd}\n  numwords=${Score[wlen]}\n  Score[2]=0\n  Status[4]=\"\"   # Initialize \"bonus\" to 0.\n\n  case \"$wlen\" in\n    3) first_word=60\n       add_word=10;;\n    4) first_word=120\n       add_word=20;;\n    5) first_word=200\n       add_word=50;;\n    6) first_word=300\n       add_word=100;;\n    7) first_word=500\n       add_word=150;;\n    8) first_word=750\n       add_word=250;;\n    9) first_word=1000\n       add_word=500;;\n   10) first_word=2000\n       add_word=2000;;   # This category modified from original rules!\n      esac\n\n  ((Score[wlen]++))\n  if [ ${Score[wlen]} -eq $MAXCAT ]\n  then   # Category completion bonus scoring simplified!\n    case $wlen in\n      3 ) bonus=100;;\n      4 ) bonus=200;;\n      5 ) bonus=400;;\n      6 ) bonus=800;;\n      7 ) bonus=2000;;\n      8 ) bonus=10000;;\n    esac  # Needn't worry about 9's and 10's.\n    Status[4]=\"Category-$wlen-completion***BONUS***\"\n    Score[2]=$bonus\n  else\n    Status[4]=\"\"   # Erase it.\n  fi\n\n    let \"score =  $first_word +   $add_word * $numwords\"\n    if [ \"$numwords\" -eq 0 ]\n    then\n      Score[0]=$score\n    else\n      Score[0]=$add_word\n    fi   #  All this to distinguish last-word score\n         #+ from total running score.\n  let \"Score[1] += ${Score[0]}\"\n  let \"Score[1] += ${Score[2]}\"\n\n}\n\nget_word ()\n{\n  local wrd=''\n  read -t $TIMEOUT wrd   # Timed read.\n  echo $wrd\n}\n\nis_constructable ()\n{ # This is the most complex and difficult-to-write function.\n  local -a local_LS=( \"${LS[@]}\" )  # Local copy of letter set.\n  local is_found=0\n  local idx=0\n  local pos\n  local strlen\n  local local_word=( \"$1\" )\n  strlen=${#local_word}\n\n  while [ \"$idx\" -lt \"$strlen\" ]\n  do\n    is_found=$(expr index \"${local_LS[*]}\" \"${local_word:idx:1}\")\n    if [ \"$is_found\" -eq \"$NONCONS\" ] # Not constructable!\n    then\n      echo \"$FAILURE\"; return\n    else\n      ((pos = ($is_found - 1) / 2))   # Compensate for spaces betw. letters!\n      local_LS[pos]=$NULL             # Zero out used letters.\n      ((idx++))                       # Bump index.\n    fi\n  done\n\n  echo \"$SUCCESS\"\n  return\n}\n\nis_valid ()\n{ # Surprisingly easy to check if word in dictionary ...\n  fgrep -qw \"$1\" \"$WLIST\"   # ... courtesy of 'grep' ...\n  echo $?\n}\n\ncheck_word ()\n{\n  if [ -z \"$1\" ]\n  then\n    return\n  fi\n\n  Status[1]=\"\"\n  Status[2]=\"\"\n  Status[3]=\"\"\n  Status[4]=\"\"\n\n  iscons=$(is_constructable \"$1\")\n  if [ \"$iscons\" ]\n  then\n    Status[1]=\"constructable\" \n    v=$(is_valid \"$1\")\n    if [ \"$v\" -eq \"$SUCCESS\" ]\n    then\n      Status[2]=\"valid\" \n      strlen=${#1}\n\n      if [ ${Score[strlen]} -eq \"$MAXCAT\" ]   # Category full!\n      then\n        Status[3]=\"Category-$strlen-overflow-PENALTY\"\n        return $NG\n      fi\n\n      case \"$strlen\" in\n        1 &#124; 2 )\n        Status[3]=\"Two-letter-word-PENALTY\"\n        return $NG;;\n        * ) \n\tStatus[3]=\"\"\n\treturn $SUCCESS;;\n      esac\n    else\n      Status[3]=\"Not-valid-PENALTY\"\n      return $NG\n    fi\n  else\n    Status[3]=\"Not-constructable-PENALTY\" \n      return $NG\n  fi\n\n  ### FIXME: Streamline the above code block.\n\n}\n\ndisplay_words ()\n{\n  local idx=0\n  local wlen0\n\n  clear\n  echo \"Letterset:   ${LS[@]}\"\n  echo \"Threes:    Fours:    Fives:     Sixes:    Sevens:    Eights:\"\n  echo \"------------------------------------------------------------\"\n\n  while [ \"${Words[idx]}\" != '' ]\n  do\n   wlen0=${#Words[idx]}\n   case \"$wlen0\" in\n     3) ;;\n     4) echo -n \"           \" ;;\n     5) echo -n \"                     \" ;;\n     6) echo -n \"                                \" ;;\n     7) echo -n \"                                          \" ;;\n     8) echo -n \"                                                     \" ;;\n   esac\n   echo \"${Words[idx]}\"\n   ((idx++))\n  done\n\n  ### FIXME: The word display is pretty crude.\n}\n\nplay ()\n{\n  word=\"Start game\"   # Dummy word, to start ...\n\n  while [ \"$word\" ]   #  If player just hits return (null word),\n  do                  #+ then game ends.\n    echo \"$word: \"${Status[@]}\"\"\n    echo -n \"Last score: [${Score[0]}]   TOTAL score: [${Score[1]}]:     Next word: \"\n    total=${Score[1]}\n    word=$(get_word)\n    check_word \"$word\"\n\n    if [ \"$?\" -eq \"$SUCCESS\" ]\n    then\n      add_word \"$word\"\n    else\n      let \"Score[0]= 0 - $PENALTY\"\n      let \"Score[1]-=$PENALTY\"\n    fi\n\n  display_words\n  done   # Exit game.\n\n  ### FIXME: The play () function calls too many other functions.\n  ### This verges on \"spaghetti code\" !!!\n}\n\nend_of_game ()\n{ # Save and display stats.\n\n  #######################Autosave##########################\n  savefile=qky.save.$$\n  #                 ^^ PID of script\n  echo `date` >> $savefile\n  echo \"Letterset # $randseed  (random seed) \">> $savefile\n  echo -n \"Letterset: \" >> $savefile\n  echo \"${LS[@]}\" >> $savefile\n  echo \"---------\" >> $savefile\n  echo \"Words constructed:\" >> $savefile\n  echo \"${Words[@]}\" >> $savefile\n  echo >> $savefile\n  echo \"Score: $total\" >> $savefile\n\n  echo \"Statistics for this round saved in \\\"\"$savefile\"\\\"\"\n  #########################################################\n\n  echo \"Score for this round: $total\"\n  echo \"Words:  ${Words[@]}\"\n}\n\n# ---------#\ninstructions\nseed_random\nget_letset\nplay\nend_of_game\n# ---------#\n\nexit $?\n\n# TODO:\n#\n# 1) Clean up code!\n# 2) Prettify the display_words () function (maybe with widgets?).\n# 3) Improve the time-out ... maybe change to untimed entry,\n#+   but with a time limit for the overall round.   \n# 4) An on-screen countdown timer would be nice.\n# 5) Implement \"vulnerable\" mode of play for compatibility with classic\n#+   version of the game.\n# 6) Improve save-to-file capability (and maybe make it optional).\n# 7) Fix bugs!!!\n\n# For more info, reference:\n# http://bash.deta.in/qky.README.html\n```", "```sh #!/bin/bash\n# nim.sh: Game of Nim\n\n# Author: Mendel Cooper\n# Reldate: 15 July 2008\n# License: GPL3\n\nROWS=5     # Five rows of pegs (or matchsticks).\nWON=91     # Exit codes to keep track of wins/losses.\nLOST=92    # Possibly useful if running in batch mode.  \nQUIT=99\npeg_msg=   # Peg/Pegs?\nRows=( 0 5 4 3 2 1 )   # Array holding play info.\n# ${Rows[0]} holds total number of pegs, updated after each turn.\n# Other array elements hold number of pegs in corresponding row.\n\ninstructions ()\n{\n  clear\n  tput bold\n  echo \"Welcome to the game of Nim.\"; echo\n  echo -n \"Do you need instructions? (y/n) \"; read ans\n\n   if [ \"$ans\" = \"y\" -o \"$ans\" = \"Y\" ]; then\n     clear\n     echo -e '\\E[33;41m'  # Yellow fg., over red bg.; bold.\n     cat <<INSTRUCTIONS\n\nNim is a game with roots in the distant past.\nThis particular variant starts with five rows of pegs.\n\n1:    &#124; &#124; &#124; &#124; &#124; \n2:     &#124; &#124; &#124; &#124; \n3:      &#124; &#124; &#124; \n4:       &#124; &#124; \n5:        &#124; \n\nThe number at the left identifies the row.\n\nThe human player moves first, and alternates turns with the bot.\nA turn consists of removing at least one peg from a single row.\nIt is permissable to remove ALL the pegs from a row.\nFor example, in row 2, above, the player can remove 1, 2, 3, or 4 pegs.\nThe player who removes the last peg loses.\n\nThe strategy consists of trying to be the one who removes\nthe next-to-last peg(s), leaving the loser with the final peg.\n\nTo exit the game early, hit ENTER during your turn.\nINSTRUCTIONS\n\necho; echo -n \"Hit ENTER to begin game. \"; read azx\n\n      echo -e \"\\033[0m\"    # Restore display.\n      else tput sgr0; clear\n  fi\n\nclear\n\n}\n\ntally_up ()\n{\n  let \"Rows[0] = ${Rows[1]} + ${Rows[2]} + ${Rows[3]} + ${Rows[4]} + \\\n  ${Rows[5]}\"    # Add up how many pegs remaining.\n}\n\ndisplay ()\n{\n  index=1   # Start with top row.\n  echo\n\n  while [ \"$index\" -le \"$ROWS\" ]\n  do\n    p=${Rows[index]}\n    echo -n \"$index:   \"          # Show row number.\n\n  # ------------------------------------------------\n  # Two concurrent inner loops.\n\n      indent=$index\n      while [ \"$indent\" -gt 0 ]\n      do\n        echo -n \" \"               # Staggered rows.\n        ((indent--))              # Spacing between pegs.\n      done\n\n    while [ \"$p\" -gt 0 ]\n    do\n      echo -n \"&#124; \"\n      ((p--))\n    done\n  # -----------------------------------------------\n\n  echo\n  ((index++))\n  done  \n\n  tally_up\n\n  rp=${Rows[0]}\n\n  if [ \"$rp\" -eq 1 ]\n  then\n    peg_msg=peg\n    final_msg=\"Game over.\"\n  else             # Game not yet over . . .\n    peg_msg=pegs\n    final_msg=\"\"   # . . . So \"final message\" is blank.\n  fi\n\n  echo \"      $rp $peg_msg remaining.\"\n  echo \"      \"$final_msg\"\"\n\n  echo\n}\n\nplayer_move ()\n{\n\n  echo \"Your move:\"\n\n  echo -n \"Which row? \"\n  while read idx\n  do                   # Validity check, etc.\n\n    if [ -z \"$idx\" ]   # Hitting return quits.\n    then\n        echo \"Premature exit.\"; echo\n        tput sgr0      # Restore display.\n        exit $QUIT\n    fi\n\n    if [ \"$idx\" -gt \"$ROWS\" -o \"$idx\" -lt 1 ]   # Bounds check.\n    then\n      echo \"Invalid row number!\"\n      echo -n \"Which row? \"\n    else\n      break\n    fi\n    # TODO:\n    # Add check for non-numeric input.\n    # Also, script crashes on input outside of range of long double.\n    # Fix this.\n\n  done\n\n  echo -n \"Remove how many? \"\n  while read num\n  do                   # Validity check.\n\n  if [ -z \"$num\" ]\n  then\n    echo \"Premature exit.\"; echo\n    tput sgr0          # Restore display.\n    exit $QUIT\n  fi\n\n    if [ \"$num\" -gt ${Rows[idx]} -o \"$num\" -lt 1 ]\n    then\n      echo \"Cannot remove $num!\"\n      echo -n \"Remove how many? \"\n    else\n      break\n    fi\n  done\n  # TODO:\n  # Add check for non-numeric input.\n  # Also, script crashes on input outside of range of long double.\n  # Fix this.\n\n  let \"Rows[idx] -= $num\"\n\n  display\n  tally_up\n\n  if [ ${Rows[0]} -eq 1 ]\n  then\n   echo \"      Human wins!\"\n   echo \"      Congratulations!\"\n   tput sgr0   # Restore display.\n   echo\n   exit $WON\n  fi\n\n  if [ ${Rows[0]} -eq 0 ]\n  then          # Snatching defeat from the jaws of victory . . .\n    echo \"      Fool!\"\n    echo \"      You just removed the last peg!\"\n    echo \"      Bot wins!\"\n    tput sgr0   # Restore display.\n    echo\n    exit $LOST\n  fi\n}\n\nbot_move ()\n{\n\n  row_b=0\n  while [[ $row_b -eq 0 &#124;&#124; ${Rows[row_b]} -eq 0 ]]\n  do\n    row_b=$RANDOM          # Choose random row.\n    let \"row_b %= $ROWS\"\n  done\n\n  num_b=0\n  r0=${Rows[row_b]}\n\n  if [ \"$r0\" -eq 1 ]\n  then\n    num_b=1\n  else\n    let \"num_b = $r0 - 1\"\n         #  Leave only a single peg in the row.\n  fi     #  Not a very strong strategy,\n         #+ but probably a bit better than totally random.\n\n  let \"Rows[row_b] -= $num_b\"\n  echo -n \"Bot:  \"\n  echo \"Removing from row $row_b ... \"\n\n  if [ \"$num_b\" -eq 1 ]\n  then\n    peg_msg=peg\n  else\n    peg_msg=pegs\n  fi\n\n  echo \"      $num_b $peg_msg.\"\n\n  display\n  tally_up\n\n  if [ ${Rows[0]} -eq 1 ]\n  then\n   echo \"      Bot wins!\"\n   tput sgr0   # Restore display.\n   exit $WON\n  fi\n\n}\n\n# ================================================== #\ninstructions     # If human player needs them . . .\ntput bold        # Bold characters for easier viewing.\ndisplay          # Show game board.\n\nwhile [ true ]   # Main loop.\ndo               # Alternate human and bot turns.\n  player_move\n  bot_move\ndone\n# ================================================== #\n\n# Exercise:\n# --------\n# Improve the bot's strategy.\n# There is, in fact, a Nim strategy that can force a win.\n# See the Wikipedia article on Nim:  http://en.wikipedia.org/wiki/Nim\n# Recode the bot to use this strategy (rather difficult).\n\n#  Curiosities:\n#  -----------\n#  Nim played a prominent role in Alain Resnais' 1961 New Wave film,\n#+ Last Year at Marienbad.\n#\n#  In 1978, Leo Christopherson wrote an animated version of Nim,\n#+ Android Nim, for the TRS-80 Model I.\n```", "```sh #!/bin/sh\n# sw.sh\n# A command-line Stopwatch\n\n# Author: Pdraig Brady\n#    http://www.pixelbeat.org/scripts/sw\n#    (Minor reformatting by ABS Guide author.)\n#    Used in ABS Guide with script author's permission.\n# Notes:\n#    This script starts a few processes per lap, in addition to\n#    the shell loop processing, so the assumption is made that\n#    this takes an insignificant amount of time compared to\n#    the response time of humans (~.1s) (or the keyboard\n#    interrupt rate (~.05s)).\n#    '?' for splits must be entered twice if characters\n#    (erroneously) entered before it (on the same line).\n#    '?' since not generating a signal may be slightly delayed\n#    on heavily loaded systems.\n#    Lap timings on ubuntu may be slightly delayed due to:\n#    https://bugs.launchpad.net/bugs/62511\n# Changes:\n#    V1.0, 23 Aug 2005, Initial release\n#    V1.1, 26 Jul 2007, Allow both splits and laps from single invocation.\n#                       Only start timer after a key is pressed.\n#                       Indicate lap number\n#                       Cache programs at startup so there is less error\n#                       due to startup delays.\n#    V1.2, 01 Aug 2007, Work around `date` commands that don't have\n#                       nanoseconds.\n#                       Use stty to change interrupt keys to space for\n#                       laps etc.\n#                       Ignore other input as it causes problems.\n#    V1.3, 01 Aug 2007, Testing release.\n#    V1.4, 02 Aug 2007, Various tweaks to get working under ubuntu\n#                       and Mac OS X.\n#    V1.5, 27 Jun 2008, set LANG=C as got vague bug report about it.\n\nexport LANG=C\n\nulimit -c 0   # No coredumps from SIGQUIT.\ntrap '' TSTP  # Ignore Ctrl-Z just in case.\nsave_tty=`stty -g` && trap \"stty $save_tty\" EXIT  # Restore tty on exit.\nstty quit ' ' # Space for laps rather than Ctrl-\\.\nstty eof  '?' # ? for splits rather than Ctrl-D.\nstty -echo    # Don't echo input.\n\ncache_progs() {\n    stty > /dev/null\n    date > /dev/null\n    grep . < /dev/null\n    (echo \"import time\" &#124; python) 2> /dev/null\n    bc < /dev/null\n    sed '' < /dev/null\n    printf '1' > /dev/null\n    /usr/bin/time false 2> /dev/null\n    cat < /dev/null\n}\ncache_progs   # To minimise startup delay.\n\ndate +%s.%N &#124; grep -qF 'N' && use_python=1 # If `date` lacks nanoseconds.\nnow() {\n    if [ \"$use_python\" ]; then\n        echo \"import time; print time.time()\" 2>/dev/null &#124; python\n    else\n        printf \"%.2f\" `date +%s.%N`\n    fi\n}\n\nfmt_seconds() {\n    seconds=$1\n    mins=`echo $seconds/60 &#124; bc`\n    if [ \"$mins\" != \"0\" ]; then\n        seconds=`echo \"$seconds - ($mins*60)\" &#124; bc`\n        echo \"$mins:$seconds\"\n    else\n        echo \"$seconds\"\n    fi\n}\n\ntotal() {\n    end=`now`\n    total=`echo \"$end - $start\" &#124; bc`\n    fmt_seconds $total\n}\n\nstop() {\n    [ \"$lapped\" ] && lap \"$laptime\" \"display\"\n    total\n    exit\n}\n\nlap() {\n    laptime=`echo \"$1\" &#124; sed -n 's/.*real[^0-9.]*\\(.*\\)/\\1/p'`\n    [ ! \"$laptime\" -o \"$laptime\" = \"0.00\" ] && return\n    # Signals too frequent.\n    laptotal=`echo $laptime+0$laptotal &#124; bc`\n    if [ \"$2\" = \"display\" ]; then\n        lapcount=`echo 0$lapcount+1 &#124; bc`\n        laptime=`fmt_seconds $laptotal`\n        echo $laptime \"($lapcount)\"\n        lapped=\"true\"\n        laptotal=\"0\"\n    fi\n}\n\necho -n \"Space for lap &#124; ? for split &#124; Ctrl-C to stop &#124; Space to start...\">&2\n\nwhile true; do\n    trap true INT QUIT  # Set signal handlers.\n    laptime=`/usr/bin/time -p 2>&1 cat >/dev/null`\n    ret=$?\n    trap '' INT QUIT    # Ignore signals within this script.\n    if [ $ret -eq 1 -o $ret -eq 2 -o $ret -eq 130 ]; then # SIGINT = stop\n        [ ! \"$start\" ] && { echo >&2; exit; }\n        stop\n    elif [ $ret -eq 3 -o $ret -eq 131 ]; then             # SIGQUIT = lap\n        if [ ! \"$start\" ]; then\n            start=`now` &#124;&#124; exit 1\n            echo >&2\n            continue\n        fi\n        lap \"$laptime\" \"display\"\n    else                # eof = split\n        [ ! \"$start\" ] && continue\n        total\n        lap \"$laptime\"  # Update laptotal.\n    fi\ndone\n\nexit $?\n```", "```sh #!/bin/bash\n#  homework.sh: All-purpose homework assignment solution.\n#  Author: M. Leo Cooper\n#  If you substitute your own name as author, then it is plagiarism,\n#+ possibly a lesser sin than cheating on your homework!\n#  License: Public Domain\n\n#  This script may be turned in to your instructor\n#+ in fulfillment of ALL shell scripting homework assignments.\n#  It's sparsely commented, but you, the student, can easily remedy that.\n#  The script author repudiates all responsibility!\n\nDLA=1\nP1=2\nP2=4\nP3=7\nPP1=0\nPP2=8\nMAXL=9\nE_LZY=99\n\ndeclare -a L\nL[0]=\"3 4 0 17 29 8 13 18 19 17 20 2 19 14 17 28\"\nL[1]=\"8 29 12 14 18 19 29 4 12 15 7 0 19 8 2 0 11 11 24 29 17 4 6 17 4 19\"\nL[2]=\"29 19 7 0 19 29 8 29 7 0 21 4 29 13 4 6 11 4 2 19 4 3\"\nL[3]=\"19 14 29 2 14 12 15 11 4 19 4 29 19 7 8 18 29\"\nL[4]=\"18 2 7 14 14 11 22 14 17 10 29 0 18 18 8 6 13 12 4 13 19 26\"\nL[5]=\"15 11 4 0 18 4 29 0 2 2 4 15 19 29 12 24 29 7 20 12 1 11 4 29\"\nL[6]=\"4 23 2 20 18 4 29 14 5 29 4 6 17 4 6 8 14 20 18 29\"\nL[7]=\"11 0 25 8 13 4 18 18 27\"\nL[8]=\"0 13 3 29 6 17 0 3 4 29 12 4 29 0 2 2 14 17 3 8 13 6 11 24 26\"\nL[9]=\"19 7 0 13 10 29 24 14 20 26\"\n\ndeclare -a \\\nalph=( A B C D E F G H I J K L M N O P Q R S T U V W X Y Z . , : ' ' )\n\npt_lt ()\n{\n  echo -n \"${alph[$1]}\"\n  echo -n -e \"\\a\"\n  sleep $DLA\n}\n\nb_r ()\n{\n echo -e '\\E[31;48m\\033[1m'\n}\n\ncr ()\n{\n echo -e \"\\a\"\n sleep $DLA\n}\n\nrestore ()\n{\n  echo -e '\\033[0m'            # Bold off.\n  tput sgr0                    # Normal.\n}\n\np_l ()\n{\n  for ltr in $1\n  do\n    pt_lt \"$ltr\"\n  done\n}\n\n# ----------------------\nb_r\n\nfor i in $(seq 0 $MAXL)\ndo\n  p_l \"${L[i]}\"\n  if [[ \"$i\" -eq \"$P1\" &#124;&#124; \"$i\" -eq \"$P2\" &#124;&#124; \"$i\" -eq \"$P3\" ]]\n  then\n    cr\n  elif [[ \"$i\" -eq \"$PP1\" &#124;&#124; \"$i\" -eq \"$PP2\" ]]\n  then\n    cr; cr\n  fi\ndone\n\nrestore\n# ----------------------\n\necho\n\nexit $E_LZY\n\n#  A typical example of an obfuscated script that is difficult\n#+ to understand, and frustrating to maintain.\n#  In your career as a sysadmin, you'll run into these critters\n#+ all too often.\n```", "```sh #!/bin/bash\n# ktour.sh\n\n# author: mendel cooper\n# reldate: 12 Jan 2009\n# license: public domain\n# (Not much sense GPLing something that's pretty much in the common\n#+ domain anyhow.)\n\n###################################################################\n#             The Knight's Tour, a classic problem.               #\n#             =====================================               #\n#  The knight must move onto every square of the chess board,     #\n#  but cannot revisit any square he has already visited.          #\n#                                                                 #\n#  And just why is Sir Knight unwelcome for a return visit?       #\n#  Could it be that he has a habit of partying into the wee hours #\n#+ of the morning?                                                #\n#  Possibly he leaves pizza crusts in the bed, empty beer bottles #\n#+ all over the floor, and clogs the plumbing. . . .              #\n#                                                                 #\n#  -------------------------------------------------------------  #\n#                                                                 #\n#  Usage: ktour.sh [start-square] [stupid]                        #\n#                                                                 #\n#  Note that start-square can be a square number                  #\n#+ in the range 0 - 63 ... or                                     #\n#  a square designator in conventional chess notation,            #\n#  such as a1, f5, h3, etc.                                       #\n#                                                                 #\n#  If start-square-number not supplied,                           #\n#+ then starts on a random square somewhere on the board.         #\n#                                                                 #\n# \"stupid\" as second parameter sets the stupid strategy.          #\n#                                                                 #\n#  Examples:                                                      #\n#  ktour.sh 23          starts on square #23 (h3)                 #\n#  ktour.sh g6 stupid   starts on square #46,                     #\n#                       using \"stupid\" (non-Warnsdorff) strategy. #\n###################################################################\n\nDEBUG=      # Set this to echo debugging info to stdout.\nSUCCESS=0\nFAIL=99\nBADMOVE=-999\nFAILURE=1\nLINELEN=21  # How many moves to display per line.\n# ---------------------------------------- #\n# Board array params\nROWS=8   # 8 x 8 board.\nCOLS=8\nlet \"SQUARES = $ROWS * $COLS\"\nlet \"MAX = $SQUARES - 1\"\nMIN=0\n# 64 squares on board, indexed from 0 to 63.\n\nVISITED=1\nUNVISITED=-1\nUNVSYM=\"##\"\n# ---------------------------------------- #\n# Global variables.\nstartpos=    # Starting position (square #, 0 - 63).\ncurrpos=     # Current position.\nmovenum=     # Move number.\nCRITPOS=37   # Have to patch for f5 starting position!\n\ndeclare -i board\n# Use a one-dimensional array to simulate a two-dimensional one.\n# This can make life difficult and result in ugly kludges; see below.\ndeclare -i moves  # Offsets from current knight position.\n\ninitialize_board ()\n{\n  local idx\n\n  for idx in {0..63}\n  do\n    board[$idx]=$UNVISITED\n  done\n}\n\nprint_board ()\n{\n  local idx\n\n  echo \"    _____________________________________\"\n  for row in {7..0}               #  Reverse order of rows ...\n  do                              #+ so it prints in chessboard order.\n    let \"rownum = $row + 1\"       #  Start numbering rows at 1.\n    echo -n \"$rownum  &#124;\"          #  Mark board edge with border and\n    for column in {0..7}          #+ \"algebraic notation.\"\n    do\n      let \"idx = $ROWS*$row + $column\"\n      if [ ${board[idx]} -eq $UNVISITED ]\n      then\n        echo -n \"$UNVSYM   \"      ##\n      else                        # Mark square with move number.\n        printf \"%02d \" \"${board[idx]}\"; echo -n \"  \"\n      fi\n    done\n    echo -e -n \"\\b\\b\\b&#124;\"  # \\b is a backspace.\n    echo                  # -e enables echoing escaped chars.\n  done\n\n  echo \"    -------------------------------------\"\n  echo \"     a    b    c    d    e    f    g    h\"\n}\n\nfailure()\n{ # Whine, then bail out.\n  echo\n  print_board\n  echo\n  echo    \"   Waah!!! Ran out of squares to move to!\"\n  echo -n \"   Knight's Tour attempt ended\"\n  echo    \" on $(to_algebraic $currpos) [square #$currpos]\"\n  echo    \"   after just $movenum moves!\"\n  echo\n  exit $FAIL\n}\n\nxlat_coords ()   #  Translate x/y coordinates to board position\n{                #+ (board-array element #).\n  #  For user input of starting board position as x/y coords.\n  #  This function not used in initial release of ktour.sh.\n  #  May be used in an updated version, for compatibility with\n  #+ standard implementation of the Knight's Tour in C, Python, etc.\n  if [ -z \"$1\" -o -z \"$2\" ]\n  then\n    return $FAIL\n  fi\n\n  local xc=$1\n  local yc=$2\n\n  let \"board_index = $xc * $ROWS + yc\"\n\n  if [ $board_index -lt $MIN -o $board_index -gt $MAX ]\n  then\n    return $FAIL    # Strayed off the board!\n  else\n    return $board_index\n  fi\n}\n\nto_algebraic ()   #  Translate board position (board-array element #)\n{                 #+ to standard algebraic notation used by chess players.\n  if [ -z \"$1\" ]\n  then\n    return $FAIL\n  fi\n\n  local element_no=$1   # Numerical board position.\n  local col_arr=( a b c d e f g h )\n  local row_arr=( 1 2 3 4 5 6 7 8 )\n\n  let \"row_no = $element_no / $ROWS\"\n  let \"col_no = $element_no % $ROWS\"\n  t1=${col_arr[col_no]}; t2=${row_arr[row_no]}\n  local apos=$t1$t2   # Concatenate.\n  echo $apos\n}\n\nfrom_algebraic ()   #  Translate standard algebraic chess notation\n{                   #+ to numerical board position (board-array element #).\n                    #  Or recognize numerical input & return it unchanged.\n  if [ -z \"$1\" ]\n  then\n    return $FAIL\n  fi   # If no command-line arg, then will default to random start pos.\n\n  local ix\n  local ix_count=0\n  local b_index     # Board index [0-63]\n  local alpos=\"$1\"\n\n  arow=${alpos:0:1} # position = 0, length = 1\n  acol=${alpos:1:1}\n\n  if [[ $arow =~ [[:digit:]] ]]   #  Numerical input?\n  then       #  POSIX char class\n    if [[ $acol =~ [[:alpha:]] ]] # Number followed by a letter? Illegal!\n      then return $FAIL\n    else if [ $alpos -gt $MAX ]   # Off board?\n      then return $FAIL\n    else return $alpos            #  Return digit(s) unchanged . . .\n      fi                          #+ if within range.\n    fi\n  fi\n\n  if [[ $acol -eq $MIN &#124;&#124; $acol -gt $ROWS ]]\n  then        # Outside of range 1 - 8?\n    return $FAIL\n  fi\n\n  for ix in a b c d e f g h\n  do  # Convert column letter to column number.\n   if [ \"$arow\" = \"$ix\" ]\n   then\n     break\n   fi\n  ((ix_count++))    # Find index count.\n  done\n\n  ((acol--))        # Decrementing converts to zero-based array.\n  let \"b_index = $ix_count + $acol * $ROWS\"\n\n  if [ $b_index -gt $MAX ]   # Off board?\n  then\n    return $FAIL\n  fi\n\n  return $b_index\n\n}\n\ngenerate_moves ()   #  Calculate all valid knight moves,\n{                   #+ relative to current position ($1),\n                    #+ and store in ${moves} array.\n  local kt_hop=1    #  One square  :: short leg of knight move.\n  local kt_skip=2   #  Two squares :: long leg  of knight move.\n  local valmov=0    #  Valid moves.\n  local row_pos; let \"row_pos = $1 % $COLS\"\n\n  let \"move1 = -$kt_skip + $ROWS\"           # 2 sideways to-the-left,  1 up\n    if [[ `expr $row_pos - $kt_skip` -lt $MIN ]]   # An ugly, ugly kludge!\n    then                                           # Can't move off board.\n      move1=$BADMOVE                               # Not even temporarily.\n    else\n      ((valmov++))\n    fi\n  let \"move2 = -$kt_hop + $kt_skip * $ROWS\" # 1 sideways to-the-left,  2 up\n    if [[ `expr $row_pos - $kt_hop` -lt $MIN ]]    # Kludge continued ...\n    then\n      move2=$BADMOVE\n    else\n      ((valmov++))\n    fi\n  let \"move3 =  $kt_hop + $kt_skip * $ROWS\" # 1 sideways to-the-right, 2 up\n    if [[ `expr $row_pos + $kt_hop` -ge $COLS ]]\n    then\n      move3=$BADMOVE\n    else\n      ((valmov++))\n    fi\n  let \"move4 =  $kt_skip + $ROWS\"           # 2 sideways to-the-right, 1 up\n    if [[ `expr $row_pos + $kt_skip` -ge $COLS ]]\n    then\n      move4=$BADMOVE\n    else\n      ((valmov++))\n    fi\n  let \"move5 =  $kt_skip - $ROWS\"           # 2 sideways to-the-right, 1 dn\n    if [[ `expr $row_pos + $kt_skip` -ge $COLS ]]\n    then\n      move5=$BADMOVE\n    else\n      ((valmov++))\n    fi\n  let \"move6 =  $kt_hop - $kt_skip * $ROWS\" # 1 sideways to-the-right, 2 dn\n    if [[ `expr $row_pos + $kt_hop` -ge $COLS ]]\n    then\n      move6=$BADMOVE\n    else\n      ((valmov++))\n    fi\n  let \"move7 = -$kt_hop - $kt_skip * $ROWS\" # 1 sideways to-the-left,  2 dn\n    if [[ `expr $row_pos - $kt_hop` -lt $MIN ]]\n    then\n      move7=$BADMOVE\n    else\n      ((valmov++))\n    fi\n  let \"move8 = -$kt_skip - $ROWS\"           # 2 sideways to-the-left,  1 dn\n    if [[ `expr $row_pos - $kt_skip` -lt $MIN ]]\n    then\n      move8=$BADMOVE\n    else\n      ((valmov++))\n    fi   # There must be a better way to do this.\n\n  local m=( $valmov $move1 $move2 $move3 $move4 $move5 $move6 $move7 $move8 )\n  # ${moves[0]} = number of valid moves.\n  # ${moves[1]} ... ${moves[8]} = possible moves.\n  echo \"${m[*]}\"    # Elements of array to stdout for capture in a var.\n\n}\n\nis_on_board ()  # Is position actually on the board?\n{\n  if [[ \"$1\" -lt \"$MIN\" &#124;&#124; \"$1\" -gt \"$MAX\" ]]\n  then\n    return $FAILURE\n  else\n    return $SUCCESS\n  fi\n}\n\ndo_move ()      # Move the knight!\n{\n  local valid_moves=0\n  local aapos\n  currposl=\"$1\"\n  lmin=$ROWS\n  iex=0\n  squarel=\n  mpm=\n  mov=\n  declare -a p_moves\n\n  ########################## DECIDE-MOVE #############################\n  if [ $startpos -ne $CRITPOS ]\n  then   # CRITPOS = square #37\n    decide_move\n  else                     # Needs a special patch for startpos=37 !!!\n    decide_move_patched    # Why this particular move and no other ???\n  fi\n  ####################################################################\n\n  (( ++movenum ))          # Increment move count.\n  let \"square = $currposl + ${moves[iex]}\"\n\n  ##################    DEBUG    ###############\n  if [ \"$DEBUG\" ]\n    then debug   # Echo debugging information.\n  fi\n  ##############################################\n\n  if [[ \"$square\" -gt $MAX &#124;&#124; \"$square\" -lt $MIN &#124;&#124;\n        ${board[square]} -ne $UNVISITED ]]\n  then\n    (( --movenum ))              #  Decrement move count,\n    echo \"RAN OUT OF SQUARES!!!\" #+ since previous one was invalid.\n    return $FAIL\n  fi\n\n  board[square]=$movenum\n  currpos=$square       # Update current position.\n  ((valid_moves++));    # moves[0]=$valid_moves\n  aapos=$(to_algebraic $square)\n  echo -n \"$aapos \"\n  test $(( $Moves % $LINELEN )) -eq 0 && echo\n  # Print LINELEN=21 moves per line. A valid tour shows 3 complete lines.\n  return $valid_moves   # Found a square to move to!\n}\n\ndo_move_stupid()   #  Dingbat algorithm,\n{                  #+ courtesy of script author, *not* Warnsdorff.\n  local valid_moves=0\n  local movloc\n  local squareloc\n  local aapos\n  local cposloc=\"$1\"\n\n  for movloc in {1..8}\n  do       # Move to first-found unvisited square.\n    let \"squareloc = $cposloc + ${moves[movloc]}\"\n    is_on_board $squareloc\n    if [ $? -eq $SUCCESS ] && [ ${board[squareloc]} -eq $UNVISITED ]\n    then   # Add conditions to above if-test to improve algorithm.\n      (( ++movenum ))\n      board[squareloc]=$movenum\n      currpos=$squareloc     # Update current position.\n      ((valid_moves++));     # moves[0]=$valid_moves\n      aapos=$(to_algebraic $squareloc)\n      echo -n \"$aapos \"\n      test $(( $Moves % $LINELEN )) -eq 0 && echo   # Print 21 moves/line.\n      return $valid_moves    # Found a square to move to!\n    fi\n  done\n\n  return $FAIL\n  #  If no square found in all 8 loop iterations,\n  #+ then Knight's Tour attempt ends in failure.\n\n  #  Dingbat algorithm will typically fail after about 30 - 40 moves,\n  #+ but executes _much_ faster than Warnsdorff's in do_move() function.\n}\n\ndecide_move ()         #  Which move will we make?\n{                      #  But, fails on startpos=37 !!!\n  for mov in {1..8}\n  do\n    let \"squarel = $currposl + ${moves[mov]}\"\n    is_on_board $squarel\n    if [[ $? -eq $SUCCESS && ${board[squarel]} -eq $UNVISITED ]]\n    then   #  Find accessible square with least possible future moves.\n           #  This is Warnsdorff's algorithm.\n           #  What happens is that the knight wanders toward the outer edge\n           #+ of the board, then pretty much spirals inward.\n           #  Given two or more possible moves with same value of\n           #+ least-possible-future-moves, this implementation chooses\n           #+ the _first_ of those moves.\n           #  This means that there is not necessarily a unique solution\n           #+ for any given starting position.\n\n      possible_moves $squarel\n      mpm=$?\n      p_moves[mov]=$mpm\n\n      if [ $mpm -lt $lmin ]  # If less than previous minimum ...\n      then #     ^^\n        lmin=$mpm            # Update minimum.\n        iex=$mov             # Save index.\n      fi\n\n    fi\n  done\n}\n\ndecide_move_patched ()         #  Decide which move to make,\n{  #        ^^^^^^^            #+ but only if startpos=37 !!!\n  for mov in {1..8}\n  do\n    let \"squarel = $currposl + ${moves[mov]}\"\n    is_on_board $squarel\n    if [[ $? -eq $SUCCESS && ${board[squarel]} -eq $UNVISITED ]]\n    then\n      possible_moves $squarel\n      mpm=$?\n      p_moves[mov]=$mpm\n\n      if [ $mpm -le $lmin ]  # If less-than-or equal to prev. minimum!\n      then #     ^^\n        lmin=$mpm\n        iex=$mov\n      fi\n\n    fi\n  done                       # There has to be a better way to do this.\n}\n\npossible_moves ()            #  Calculate number of possible moves,\n{                            #+ given the current position.\n\n  if [ -z \"$1\" ]\n  then\n    return $FAIL\n  fi\n\n  local curr_pos=$1\n  local valid_movl=0\n  local icx=0\n  local movl\n  local sq\n  declare -a movesloc\n\n  movesloc=( $(generate_moves $curr_pos) )\n\n  for movl in {1..8}\n  do\n    let \"sq = $curr_pos + ${movesloc[movl]}\"\n    is_on_board $sq\n    if [ $? -eq $SUCCESS ] && [ ${board[sq]} -eq $UNVISITED ]\n    then\n      ((valid_movl++));\n    fi\n  done\n\n  return $valid_movl         # Found a square to move to!\n}\n\nstrategy ()\n{\n  echo\n\n  if [ -n \"$STUPID\" ]\n  then\n    for Moves in {1..63}\n    do\n      cposl=$1\n      moves=( $(generate_moves $currpos) )\n      do_move_stupid \"$currpos\"\n      if [ $? -eq $FAIL ]\n      then\n        failure\n      fi\n      done\n  fi\n\n  #  Don't need an \"else\" clause here,\n  #+ because Stupid Strategy will always fail and exit!\n  for Moves in {1..63}\n  do\n    cposl=$1\n    moves=( $(generate_moves $currpos) )\n    do_move \"$currpos\"\n    if [ $? -eq $FAIL ]\n    then\n      failure\n    fi\n\n  done\n        #  Could have condensed above two do-loops into a single one,\n  echo  #+ but this would have slowed execution.\n\n  print_board\n  echo\n  echo \"Knight's Tour ends on $(to_algebraic $currpos) [square #$currpos].\"\n  return $SUCCESS\n}\n\ndebug ()\n{       # Enable this by setting DEBUG=1 near beginning of script.\n  local n\n\n  echo \"=================================\"\n  echo \"  At move number  $movenum:\"\n  echo \" *** possible moves = $mpm ***\"\n# echo \"### square = $square ###\"\n  echo \"lmin = $lmin\"\n  echo \"${moves[@]}\"\n\n  for n in {1..8}\n  do\n    echo -n \"($n):${p_moves[n]} \"\n  done\n\n  echo\n  echo \"iex = $iex :: moves[iex] = ${moves[iex]}\"\n  echo \"square = $square\"\n  echo \"=================================\"\n  echo\n} # Gives pretty complete status after ea. move.\n\n# =============================================================== #\n# int main () {\nfrom_algebraic \"$1\"\nstartpos=$?\nif [ \"$startpos\" -eq \"$FAIL\" ]          # Okay even if no $1.\nthen   #         ^^^^^^^^^^^              Okay even if input -lt 0.\n  echo \"No starting square specified (or illegal input).\"\n  let \"startpos = $RANDOM % $SQUARES\"   # 0 - 63 permissable range.\nfi\n\nif [ \"$2\" = \"stupid\" ]\nthen\n  STUPID=1\n  echo -n \"     ### Stupid Strategy ###\"\nelse\n  STUPID=''\n  echo -n \"  *** Warnsdorff's Algorithm ***\"\nfi\n\ninitialize_board\n\nmovenum=0\nboard[startpos]=$movenum   # Mark each board square with move number.\ncurrpos=$startpos\nalgpos=$(to_algebraic $startpos)\n\necho; echo \"Starting from $algpos [square #$startpos] ...\"; echo\necho -n \"Moves:\"\n\nstrategy \"$currpos\"\n\necho\n\nexit 0   # return 0;\n\n# }      # End of main() pseudo-function.\n# =============================================================== #\n\n# Exercises:\n# ---------\n#\n# 1) Extend this example to a 10 x 10 board or larger.\n# 2) Improve the \"stupid strategy\" by modifying the\n#    do_move_stupid function.\n#    Hint: Prevent straying into corner squares in early moves\n#          (the exact opposite of Warnsdorff's algorithm!).\n# 3) This script could stand considerable improvement and\n#    streamlining, especially in the poorly-written\n#    generate_moves() function\n#    and in the DECIDE-MOVE patch in the do_move() function.\n#    Must figure out why standard algorithm fails for startpos=37 ...\n#+   but _not_ on any other, including symmetrical startpos=26.\n#    Possibly, when calculating possible moves, counts the move back\n#+   to the originating square. If so, it might be a relatively easy fix.\n```", "```sh #!/bin/bash\n# msquare.sh\n# Magic Square generator (odd-order squares only!)\n\n# Author: mendel cooper\n# reldate: 19 Jan. 2009\n# License: Public Domain\n# A C-program by the very talented Kwon Young Shin inspired this script.\n#     http://user.chollian.net/~brainstm/MagicSquare.htm\n\n# Definition: A \"magic square\" is a two-dimensional array\n#             of integers in which all the rows, columns,\n#             and *long* diagonals add up to the same number.\n#             Being \"square,\" the array has the same number\n#             of rows and columns. That number is the \"order.\"\n# An example of a magic square of order 3 is:\n#   8  1  6   \n#   3  5  7   \n#   4  9  2   \n# All the rows, columns, and the two long diagonals add up to 15.\n\n# Globals\nEVEN=2\nMAXSIZE=31   # 31 rows x 31 cols.\nE_usage=90   # Invocation error.\ndimension=\ndeclare -i square\n\nusage_message ()\n{\n  echo \"Usage: $0 order\"\n  echo \"   ... where \\\"order\\\" (square size) is an ODD integer\"\n  echo \"       in the range 3 - 31.\"\n  #  Actually works for squares up to order 159,\n  #+ but large squares will not display pretty-printed in a term window.\n  #  Try increasing MAXSIZE, above.\n  exit $E_usage\n}\n\ncalculate ()       # Here's where the actual work gets done.\n{\n  local row col index dimadj j k cell_val=1\n  dimension=$1\n\n  let \"dimadj = $dimension * 3\"; let \"dimadj /= 2\"   # x 1.5, then truncate.\n\n  for ((j=0; j < dimension; j++))\n  do\n    for ((k=0; k < dimension; k++))\n    do  # Calculate indices, then convert to 1-dim. array index.\n        # Bash doesn't support multidimensional arrays. Pity.\n      let \"col = $k - $j + $dimadj\"; let \"col %= $dimension\"\n      let \"row = $j * 2 - $k + $dimension\"; let \"row %= $dimension\"\n      let \"index = $row*($dimension) + $col\"\n      square[$index]=cell_val; ((cell_val++))\n    done\n  done\n}     # Plain math, visualization not required.\n\nprint_square ()               # Output square, one row at a time.\n{\n  local row col idx d1\n  let \"d1 = $dimension - 1\"   # Adjust for zero-indexed array.\n\n  for row in $(seq 0 $d1)\n  do\n\n    for col in $(seq 0 $d1)\n    do\n      let \"idx = $row * $dimension + $col\"\n      printf \"%3d \" \"${square[idx]}\"; echo -n \"  \"\n    done   # Displays up to 13th order neatly in 80-column term window.\n\n    echo   # Newline after each row.\n  done\n}\n\n#################################################\nif [[ -z \"$1\" ]] &#124;&#124; [[ \"$1\" -gt $MAXSIZE ]]\nthen\n  usage_message\nfi\n\nlet \"test_even = $1 % $EVEN\"\nif [ $test_even -eq 0 ]\nthen           # Can't handle even-order squares.\n  usage_message\nfi\n\ncalculate $1\nprint_square   # echo \"${square[@]}\"   # DEBUG\n\nexit $?\n#################################################\n\n# Exercises:\n# ---------\n# 1) Add a function to calculate the sum of each row, column,\n#    and *long* diagonal. The sums must match.\n#    This is the \"magic constant\" of that particular order square.\n# 2) Have the print_square function auto-calculate how much space\n#    to allot between square elements for optimized display.\n#    This might require parameterizing the \"printf\" line.\n# 3) Add appropriate functions for generating magic squares\n#    with an *even* number of rows/columns.\n#    This is non-trivial(!).\n#    See the URL for Kwon Young Shin, above, for help.\n```", "```sh #!/bin/bash\n# fifteen.sh\n\n# Classic \"Fifteen Puzzle\"\n# Author: Antonio Macchi\n# Lightly edited and commented by ABS Guide author.\n# Used in ABS Guide with permission. (Thanks!)\n\n#  The invention of the Fifteen Puzzle is attributed to either\n#+ Sam Loyd or Noyes Palmer Chapman.\n#  The puzzle was wildly popular in the late 19th-century.\n\n#  Object: Rearrange the numbers so they read in order,\n#+ from 1 - 15:   ________________\n#                &#124;  1   2   3   4 &#124;\n#                &#124;  5   6   7   8 &#124;\n#                &#124;  9  10  11  12 &#124;\n#                &#124; 13  14  15     &#124;\n#                 ----------------\n\n#######################\n# Constants           #\n  SQUARES=16          #\n  FAIL=70             #\n  E_PREMATURE_EXIT=80 #\n#######################\n\n########\n# Data #\n########\n\nPuzzle=( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \" \" )\n\n#############\n# Functions #\n#############\n\nfunction swap\n{\n  local tmp\n\n  tmp=${Puzzle[$1]}\n  Puzzle[$1]=${Puzzle[$2]}\n  Puzzle[$2]=$tmp\n}\n\nfunction Jumble\n{ # Scramble the pieces at beginning of round.\n  local i pos1 pos2\n\n  for i in {1..100}\n  do\n    pos1=$(( $RANDOM % $SQUARES))\n    pos2=$(( $RANDOM % $SQUARES ))\n    swap $pos1 $pos2\n  done\n}\n\nfunction PrintPuzzle\n{\n  local i1 i2 puzpos\n  puzpos=0\n\n  clear\n  echo \"Enter  quit  to exit.\"; echo   # Better that than Ctl-C.\n\n  echo \",----.----.----.----.\"   # Top border.\n  for i1 in {1..4}\n  do\n    for i2 in {1..4} \n    do\n      printf \"&#124; %2s \" \"${Puzzle[$puzpos]}\"\n      (( puzpos++ ))\n    done\n    echo \"&#124;\"                     # Right-side border.\n    test $i1 = 4 &#124;&#124; echo \"+----+----+----+----+\"\n  done\n  echo \"'----'----'----'----'\"   # Bottom border.\n}\n\nfunction GetNum\n{ # Test for valid input.\n  local puznum garbage\n\n  while true\n  do \n\t  echo \"Moves: $moves\" # Also counts invalid moves.\n    read -p \"Number to move: \" puznum garbage\n      if [ \"$puznum\" = \"quit\" ]; then echo; exit $E_PREMATURE_EXIT; fi\n    test -z \"$puznum\" -o -n \"${puznum//[0-9]/}\" && continue\n    test $puznum -gt 0 -a $puznum -lt $SQUARES && break\n  done\n  return $puznum\n}\n\nfunction GetPosFromNum\n{ # $1 = puzzle-number\n  local puzpos\n\n  for puzpos in {0..15}\n  do\n    test \"${Puzzle[$puzpos]}\" = \"$1\" && break\n  done\n  return $puzpos\n}\n\nfunction Move\n{ # $1=Puzzle-pos\n  test $1 -gt 3 && test \"${Puzzle[$(( $1 - 4 ))]}\" = \" \"\\\n       && swap $1 $(( $1 - 4 )) && return 0\n  test $(( $1%4 )) -ne 3 && test \"${Puzzle[$(( $1 + 1 ))]}\" = \" \"\\\n       && swap $1 $(( $1 + 1 )) && return 0\n  test $1 -lt 12 && test \"${Puzzle[$(( $1 + 4 ))]}\" = \" \"\\\n       && swap $1 $(( $1 + 4 )) && return 0\n  test $(( $1%4 )) -ne 0 && test \"${Puzzle[$(( $1 - 1 ))]}\" = \" \" &&\\\n       swap $1 $(( $1 - 1 )) && return 0\n  return 1\n}\n\nfunction Solved\n{\n  local pos\n\n  for pos in {0..14}\n  do\n    test \"${Puzzle[$pos]}\" = $(( $pos + 1 )) &#124;&#124; return $FAIL\n    # Check whether number in each square = square number.\n  done\n  return 0   # Successful solution.\n}\n\n################### MAIN () #######################{\nmoves=0\nJumble\n\nwhile true   # Loop continuously until puzzle solved.\ndo\n  echo; echo\n  PrintPuzzle\n  echo\n  while true\n  do\n    GetNum\n    puznum=$?\n    GetPosFromNum $puznum\n    puzpos=$?\n    ((moves++))\n    Move $puzpos && break\n  done\n  Solved && break\ndone\n\necho;echo\nPrintPuzzle\necho; echo \"BRAVO!\"; echo\n\nexit 0\n###################################################}\n\n#  Exercise:\n#  --------\n#  Rewrite the script to display the letters A - O,\n#+ rather than the numbers 1 - 15.\n```", "```sh #! /bin/bash\n# The Towers Of Hanoi\n# Original script (hanoi.bash) copyright (C) 2000 Amit Singh.\n# All Rights Reserved.\n# http://hanoi.kernelthread.com\n\n#  hanoi2.bash\n#  Version 2.00: modded for ASCII-graphic display.\n#  Version 2.01: fixed no command-line param bug.\n#  Uses code contributed by Antonio Macchi,\n#+ with heavy editing by ABS Guide author.\n#  This variant falls under the original copyright, see above.\n#  Used in ABS Guide with Amit Singh's permission (thanks!).\n\n###   Variables && sanity check   ###\n\nE_NOPARAM=86\nE_BADPARAM=87            # Illegal no. of disks passed to script.\nE_NOEXIT=88\n\nDISKS=${1:-$E_NOPARAM}   # Must specify how many disks.\nMoves=0\n\nMWIDTH=7\nMARGIN=2\n# Arbitrary \"magic\" constants; work okay for relatively small # of disks.\n# BASEWIDTH=51   # Original code.\nlet \"basewidth = $MWIDTH * $DISKS + $MARGIN\"       # \"Base\" beneath rods.\n# Above \"algorithm\" could likely stand improvement.\n\n###   Display variables   ###\nlet \"disks1 = $DISKS - 1\"\nlet \"spaces1 = $DISKS\" \nlet \"spaces2 = 2 * $DISKS\" \n\nlet \"lastmove_t = $DISKS - 1\"                      # Final move?\n\ndeclare -a Rod1 Rod2 Rod3\n\n###   #########################   ###\n\nfunction repeat  {  # $1=char $2=number of repetitions\n  local n           # Repeat-print a character.\n\n  for (( n=0; n<$2; n++ )); do\n    echo -n \"$1\"\n  done\n}\n\nfunction FromRod  {\n  local rod summit weight sequence\n\n  while true; do\n    rod=$1\n    test ${rod/[^123]/} &#124;&#124; continue\n\n    sequence=$(echo $(seq 0 $disks1 &#124; tac))\n    for summit in $sequence; do\n      eval weight=\\${Rod${rod}[$summit]}\n      test $weight -ne 0 &&\n           { echo \"$rod $summit $weight\"; return; }\n    done\n  done\n}\n\nfunction ToRod  { # $1=previous (FromRod) weight\n  local rod firstfree weight sequence\n\n  while true; do\n    rod=$2\n    test ${rod/[^123]} &#124;&#124; continue\n\n    sequence=$(echo $(seq 0 $disks1 &#124; tac))\n    for firstfree in $sequence; do\n      eval weight=\\${Rod${rod}[$firstfree]}\n      test $weight -gt 0 && { (( firstfree++ )); break; }\n    done\n    test $weight -gt $1 -o $firstfree = 0 &&\n         { echo \"$rod $firstfree\"; return; }\n  done\n}\n\nfunction PrintRods  {\n  local disk rod empty fill sp sequence\n\n  repeat \" \" $spaces1\n  echo -n \"&#124;\"\n  repeat \" \" $spaces2\n  echo -n \"&#124;\"\n  repeat \" \" $spaces2\n  echo \"&#124;\"\n\n  sequence=$(echo $(seq 0 $disks1 &#124; tac))\n  for disk in $sequence; do\n    for rod in {1..3}; do\n      eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) ))\n      eval fill=\\${Rod${rod}[$disk]}\n      repeat \" \" $empty\n      test $fill -gt 0 && repeat \"*\" $fill &#124;&#124; echo -n \"&#124;\"\n      repeat \" \" $empty\n    done\n    echo\n  done\n  repeat \"=\" $basewidth   # Print \"base\" beneath rods.\n  echo\n}\n\ndisplay ()\n{\n  echo\n  PrintRods\n\n  # Get rod-number, summit and weight\n  first=( `FromRod $1` )\n  eval Rod${first[0]}[${first[1]}]=0\n\n  # Get rod-number and first-free position\n  second=( `ToRod ${first[2]} $2` )\n  eval Rod${second[0]}[${second[1]}]=${first[2]}\n\necho; echo; echo\nif [ \"${Rod3[lastmove_t]}\" = 1 ]\nthen   # Last move? If yes, then display final position.\n    echo \"+  Final Position: $Moves moves\"; echo\n    PrintRods\n  fi\n}\n\n# From here down, almost the same as original (hanoi.bash) script.\n\ndohanoi() {   # Recursive function.\n    case $1 in\n    0)\n        ;;\n    *)\n        dohanoi \"$(($1-1))\" $2 $4 $3\n\tif [ \"$Moves\" -ne 0 ]\n        then\n\t  echo \"+  Position after move $Moves\"\n        fi\n        ((Moves++))\n        echo -n \"   Next move will be:  \"\n        echo $2 \"-->\" $3\n          display $2 $3\n        dohanoi \"$(($1-1))\" $4 $3 $2\n        ;;\n    esac\n}\n\nsetup_arrays ()\n{\n  local dim n elem\n\n  let \"dim1 = $1 - 1\"\n  elem=$dim1\n\n  for n in $(seq 0 $dim1)\n  do\n   let \"Rod1[$elem] = 2 * $n + 1\"\n   Rod2[$n]=0\n   Rod3[$n]=0\n   ((elem--))\n  done\n}\n\n###   Main   ###\n\nsetup_arrays $DISKS\necho; echo \"+  Start Position\"\n\ncase $# in\n    1) case $(($1>0)) in     # Must have at least one disk.\n       1)\n           disks=$1\n           dohanoi $1 1 3 2\n#          Total moves = 2^n - 1, where n = number of disks.\n\t   echo\n           exit 0;\n           ;;\n       *)\n           echo \"$0: Illegal value for number of disks\";\n           exit $E_BADPARAM;\n           ;;\n       esac\n    ;;\n    *)\n       clear\n       echo \"usage: $0 N\"\n       echo \"       Where \\\"N\\\" is the number of disks.\"\n       exit $E_NOPARAM;\n       ;;\nesac\n\nexit $E_NOEXIT   # Shouldn't exit here.\n\n# Note:\n# Redirect script output to a file, otherwise it scrolls off display.\n```", "```sh #! /bin/bash\n# The Towers Of Hanoi\n# Original script (hanoi.bash) copyright (C) 2000 Amit Singh.\n# All Rights Reserved.\n# http://hanoi.kernelthread.com\n\n#  hanoi2.bash\n#  Version 2: modded for ASCII-graphic display.\n#  Uses code contributed by Antonio Macchi,\n#+ with heavy editing by ABS Guide author.\n#  This variant also falls under the original copyright, see above.\n#  Used in ABS Guide with Amit Singh's permission (thanks!).\n\n#   Variables   #\nE_NOPARAM=86\nE_BADPARAM=87   # Illegal no. of disks passed to script.\nE_NOEXIT=88\nDELAY=2         # Interval, in seconds, between moves. Change, if desired.\nDISKS=$1\nMoves=0\n\nMWIDTH=7\nMARGIN=2\n# Arbitrary \"magic\" constants, work okay for relatively small # of disks.\n# BASEWIDTH=51   # Original code.\nlet \"basewidth = $MWIDTH * $DISKS + $MARGIN\" # \"Base\" beneath rods.\n# Above \"algorithm\" could likely stand improvement.\n\n# Display variables.\nlet \"disks1 = $DISKS - 1\"\nlet \"spaces1 = $DISKS\" \nlet \"spaces2 = 2 * $DISKS\" \n\nlet \"lastmove_t = $DISKS - 1\"                # Final move?\n\ndeclare -a Rod1 Rod2 Rod3\n\n#################\n\nfunction repeat  {  # $1=char $2=number of repetitions\n  local n           # Repeat-print a character.\n\n  for (( n=0; n<$2; n++ )); do\n    echo -n \"$1\"\n  done\n}\n\nfunction FromRod  {\n  local rod summit weight sequence\n\n  while true; do\n    rod=$1\n    test ${rod/[^123]/} &#124;&#124; continue\n\n    sequence=$(echo $(seq 0 $disks1 &#124; tac))\n    for summit in $sequence; do\n      eval weight=\\${Rod${rod}[$summit]}\n      test $weight -ne 0 &&\n           { echo \"$rod $summit $weight\"; return; }\n    done\n  done\n}\n\nfunction ToRod  { # $1=previous (FromRod) weight\n  local rod firstfree weight sequence\n\n  while true; do\n    rod=$2\n    test ${rod/[^123]} &#124;&#124; continue\n\n    sequence=$(echo $(seq 0 $disks1 &#124; tac))\n    for firstfree in $sequence; do\n      eval weight=\\${Rod${rod}[$firstfree]}\n      test $weight -gt 0 && { (( firstfree++ )); break; }\n    done\n    test $weight -gt $1 -o $firstfree = 0 &&\n         { echo \"$rod $firstfree\"; return; }\n  done\n}\n\nfunction PrintRods  {\n  local disk rod empty fill sp sequence\n\n  tput cup 5 0\n\n  repeat \" \" $spaces1\n  echo -n \"&#124;\"\n  repeat \" \" $spaces2\n  echo -n \"&#124;\"\n  repeat \" \" $spaces2\n  echo \"&#124;\"\n\n  sequence=$(echo $(seq 0 $disks1 &#124; tac))\n  for disk in $sequence; do\n    for rod in {1..3}; do\n      eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) ))\n      eval fill=\\${Rod${rod}[$disk]}\n      repeat \" \" $empty\n      test $fill -gt 0 && repeat \"*\" $fill &#124;&#124; echo -n \"&#124;\"\n      repeat \" \" $empty\n    done\n    echo\n  done\n  repeat \"=\" $basewidth   # Print \"base\" beneath rods.\n  echo\n}\n\ndisplay ()\n{\n  echo\n  PrintRods\n\n  # Get rod-number, summit and weight\n  first=( `FromRod $1` )\n  eval Rod${first[0]}[${first[1]}]=0\n\n  # Get rod-number and first-free position\n  second=( `ToRod ${first[2]} $2` )\n  eval Rod${second[0]}[${second[1]}]=${first[2]}\n\n  if [ \"${Rod3[lastmove_t]}\" = 1 ]\n  then   # Last move? If yes, then display final position.\n    tput cup 0 0\n    echo; echo \"+  Final Position: $Moves moves\"\n    PrintRods\n  fi\n\n  sleep $DELAY\n}\n\n# From here down, almost the same as original (hanoi.bash) script.\n\ndohanoi() {   # Recursive function.\n    case $1 in\n    0)\n        ;;\n    *)\n        dohanoi \"$(($1-1))\" $2 $4 $3\n\tif [ \"$Moves\" -ne 0 ]\n        then\n\t  tput cup 0 0\n\t  echo; echo \"+  Position after move $Moves\"\n        fi\n        ((Moves++))\n        echo -n \"   Next move will be:  \"\n        echo $2 \"-->\" $3\n        display $2 $3\n        dohanoi \"$(($1-1))\" $4 $3 $2\n        ;;\n    esac\n}\n\nsetup_arrays ()\n{\n  local dim n elem\n\n  let \"dim1 = $1 - 1\"\n  elem=$dim1\n\n  for n in $(seq 0 $dim1)\n  do\n   let \"Rod1[$elem] = 2 * $n + 1\"\n   Rod2[$n]=0\n   Rod3[$n]=0\n   ((elem--))\n  done\n}\n\n###   Main   ###\n\ntrap \"tput cnorm\" 0\ntput civis\nclear\n\nsetup_arrays $DISKS\n\ntput cup 0 0\necho; echo \"+  Start Position\"\n\ncase $# in\n    1) case $(($1>0)) in     # Must have at least one disk.\n       1)\n           disks=$1\n           dohanoi $1 1 3 2\n#          Total moves = 2^n - 1, where n = # of disks.\n\t   echo\n           exit 0;\n           ;;\n       *)\n           echo \"$0: Illegal value for number of disks\";\n           exit $E_BADPARAM;\n           ;;\n       esac\n    ;;\n    *)\n       echo \"usage: $0 N\"\n       echo \"       Where \\\"N\\\" is the number of disks.\"\n       exit $E_NOPARAM;\n       ;;\nesac\n\nexit $E_NOEXIT   # Shouldn't exit here.\n\n#  Exercise:\n#  --------\n#  There is a minor bug in the script that causes the display of\n#+ the next-to-last move to be skipped.\n#+ Fix this.\n```", "```sh #!/bin/bash\n# UseGetOpt.sh\n\n# Author: Peggy Russell <prusselltechgroup@gmail.com>\n\nUseGetOpt () {\n  declare inputOptions\n  declare -r E_OPTERR=85\n  declare -r ScriptName=${0##*/}\n  declare -r ShortOpts=\"adf:hlt\"\n  declare -r LongOpts=\"aoption,debug,file:,help,log,test\"\n\nDoSomething () {\n    echo \"The function name is '${FUNCNAME}'\"\n    #  Recall that $FUNCNAME is an internal variable\n    #+ holding the name of the function it is in.\n  }\n\n  inputOptions=$(getopt -o \"${ShortOpts}\" --long \\\n              \"${LongOpts}\" --name \"${ScriptName}\" -- \"${@}\")\n\n  if [[ ($? -ne 0) &#124;&#124; ($# -eq 0) ]]; then\n    echo \"Usage: ${ScriptName} [-dhlt] {OPTION...}\"\n    exit $E_OPTERR\n  fi\n\n  eval set -- \"${inputOptions}\"\n\n  # Only for educational purposes. Can be removed.\n  #-----------------------------------------------\n  echo \"++ Test: Number of arguments: [$#]\"\n  echo '++ Test: Looping through \"$@\"'\n  for a in \"$@\"; do\n    echo \"  ++ [$a]\"\n  done\n  #-----------------------------------------------\n\n  while true; do\n    case \"${1}\" in\n      --aoption &#124; -a)  # Argument found.\n        echo \"Option [$1]\"\n        ;;\n\n      --debug &#124; -d)    # Enable informational messages.\n        echo \"Option [$1] Debugging enabled\"\n        ;;\n\n      --file &#124; -f)     #  Check for optional argument.\n        case \"$2\" in   #+ Double colon is optional argument.\n          \"\")          #  Not there.\n              echo \"Option [$1] Use default\"\n              shift\n              ;;\n\n          *) # Got it\n             echo \"Option [$1] Using input [$2]\"\n             shift\n             ;;\n\n        esac\n        DoSomething\n        ;;\n\n      --log &#124; -l) # Enable Logging.\n        echo \"Option [$1] Logging enabled\"\n        ;;\n\n      --test &#124; -t) # Enable testing.\n        echo \"Option [$1] Testing enabled\"\n        ;;\n\n      --help &#124; -h)\n        echo \"Option [$1] Display help\"\n        break\n        ;;\n\n      --)   # Done! $# is argument number for \"--\", $@ is \"--\"\n        echo \"Option [$1] Dash Dash\"\n        break\n        ;;\n\n       *)\n        echo \"Major internal error!\"\n        exit 8\n        ;;\n\n    esac\n    echo \"Number of arguments: [$#]\"\n    shift\n  done\n\n  shift\n  # Only for educational purposes. Can be removed.\n  #----------------------------------------------------------------------\n  echo \"++ Test: Number of arguments after \\\"--\\\" is [$#] They are: [$@]\"\n  echo '++ Test: Looping through \"$@\"'\n  for a in \"$@\"; do\n    echo \"  ++ [$a]\"\n  done\n  #----------------------------------------------------------------------\n\n}\n\n################################### M A I N ########################\n#  If you remove \"function UseGetOpt () {\" and corresponding \"}\",\n#+ you can uncomment the \"exit 0\" line below, and invoke this script\n#+ with the various options from the command-line.\n#-------------------------------------------------------------------\n# exit 0\n\necho \"Test 1\"\nUseGetOpt -f myfile one \"two three\" four\n\necho;echo \"Test 2\"\nUseGetOpt -h\n\necho;echo \"Test 3 - Short Options\"\nUseGetOpt -adltf myfile  anotherfile\n\necho;echo \"Test 4 - Long Options\"\nUseGetOpt --aoption --debug --log --test --file myfile anotherfile\n\nexit\n```", "```sh #!/bin/bash\n\n#  UseGetOpt-2.sh\n#  Modified version of the script for illustrating tab-expansion\n#+ of command-line options.\n#  See the \"Introduction to Tab Expansion\" appendix.\n\n#  Possible options: -a -d -f -l -t -h\n#+                   --aoption, --debug --file --log --test -- help --\n\n#  Author of original script: Peggy Russell <prusselltechgroup@gmail.com>\n\n# UseGetOpt () {\n  declare inputOptions\n  declare -r E_OPTERR=85\n  declare -r ScriptName=${0##*/}\n  declare -r ShortOpts=\"adf:hlt\"\n  declare -r LongOpts=\"aoption,debug,file:,help,log,test\"\n\nDoSomething () {\n    echo \"The function name is '${FUNCNAME}'\"\n  }\n\n  inputOptions=$(getopt -o \"${ShortOpts}\" --long \\\n              \"${LongOpts}\" --name \"${ScriptName}\" -- \"${@}\")\n\n  if [[ ($? -ne 0) &#124;&#124; ($# -eq 0) ]]; then\n    echo \"Usage: ${ScriptName} [-dhlt] {OPTION...}\"\n    exit $E_OPTERR\n  fi\n\n  eval set -- \"${inputOptions}\"\n\n  while true; do\n    case \"${1}\" in\n      --aoption &#124; -a)  # Argument found.\n        echo \"Option [$1]\"\n        ;;\n\n      --debug &#124; -d)    # Enable informational messages.\n        echo \"Option [$1] Debugging enabled\"\n        ;;\n\n      --file &#124; -f)     #  Check for optional argument.\n        case \"$2\" in   #+ Double colon is optional argument.\n          \"\")          #  Not there.\n              echo \"Option [$1] Use default\"\n              shift\n              ;;\n\n          *) # Got it\n             echo \"Option [$1] Using input [$2]\"\n             shift\n             ;;\n\n        esac\n        DoSomething\n        ;;\n\n      --log &#124; -l) # Enable Logging.\n        echo \"Option [$1] Logging enabled\"\n        ;;\n\n      --test &#124; -t) # Enable testing.\n        echo \"Option [$1] Testing enabled\"\n        ;;\n\n      --help &#124; -h)\n        echo \"Option [$1] Display help\"\n        break\n        ;;\n\n      --)   # Done! $# is argument number for \"--\", $@ is \"--\"\n        echo \"Option [$1] Dash Dash\"\n        break\n        ;;\n\n       *)\n        echo \"Major internal error!\"\n        exit 8\n        ;;\n\n    esac\n    echo \"Number of arguments: [$#]\"\n    shift\n  done\n\n  shift\n\n#  }\n\nexit\n```", "```sh #!/bin/bash\n\n# show-all-colors.sh\n# Displays all 256 possible background colors, using ANSI escape sequences.\n# Author: Chetankumar Phulpagare\n# Used in ABS Guide with permission.\n\nT1=8\nT2=6\nT3=36\noffset=0\n\nfor num1 in {0..7}\ndo {\n   for num2 in {0,1}\n       do {\n          shownum=`echo \"$offset + $T1 * ${num2} + $num1\" &#124; bc`\n          echo -en \"\\E[0;48;5;${shownum}m color ${shownum} \\E[0m\"\n          }\n       done\n   echo\n   }\ndone\n\noffset=16\nfor num1 in {0..5}\ndo {\n   for num2 in {0..5}\n       do {\n          for num3 in {0..5}\n              do {\n                 shownum=`echo \"$offset + $T2 * ${num3} \\\n                 + $num2 + $T3 * ${num1}\" &#124; bc`\n                 echo -en \"\\E[0;48;5;${shownum}m color ${shownum} \\E[0m\"\n                 }\n               done\n          echo\n          }\n       done\n}\ndone\n\noffset=232\nfor num1 in {0..23}\ndo {\n   shownum=`expr $offset + $num1`\n   echo -en \"\\E[0;48;5;${shownum}m ${shownum}\\E[0m\"\n}\ndone\n\necho\n```", "```sh #!/bin/bash\n# sam.sh, v. .01a\n# Still Another Morse (code training script)\n# With profuse apologies to Sam (F.B.) Morse.\n# Author: Mendel Cooper\n# License: GPL3\n# Reldate: 05/25/11\n\n# Morse code training script.\n# Converts arguments to audible dots and dashes.\n# Note: lowercase input only at this time.\n\n# Get the wav files from the source tarball:\n# http://bash.deta.in/abs-guide-latest.tar.bz2\nDOT='soundfiles/dot.wav'\nDASH='soundfiles/dash.wav'\n# Maybe move soundfiles to /usr/local/sounds?\n\nLETTERSPACE=300000  # Microseconds.\nWORDSPACE=980000\n# Nice and slow, for beginners. Maybe 5 wpm?\n\nEXIT_MSG=\"May the Morse be with you!\"\nE_NOARGS=75         # No command-line args?\n\ndeclare -A morse    # Associative array!\n# ======================================= #\nmorse[a]=\"dot; dash\"\nmorse[b]=\"dash; dot; dot; dot\"\nmorse[c]=\"dash; dot; dash; dot\"\nmorse[d]=\"dash; dot; dot\"\nmorse[e]=\"dot\"\nmorse[f]=\"dot; dot; dash; dot\"\nmorse[g]=\"dash; dash; dot\"\nmorse[h]=\"dot; dot; dot; dot\"\nmorse[i]=\"dot; dot;\"\nmorse[j]=\"dot; dash; dash; dash\"\nmorse[k]=\"dash; dot; dash\"\nmorse[l]=\"dot; dash; dot; dot\"\nmorse[m]=\"dash; dash\"\nmorse[n]=\"dash; dot\"\nmorse[o]=\"dash; dash; dash\"\nmorse[p]=\"dot; dash; dash; dot\"\nmorse[q]=\"dash; dash; dot; dash\"\nmorse[r]=\"dot; dash; dot\"\nmorse[s]=\"dot; dot; dot\"\nmorse[t]=\"dash\"\nmorse[u]=\"dot; dot; dash\"\nmorse[v]=\"dot; dot; dot; dash\"\nmorse[w]=\"dot; dash; dash\"\nmorse[x]=\"dash; dot; dot; dash\"\nmorse[y]=\"dash; dot; dash; dash\"\nmorse[z]=\"dash; dash; dot; dot\"\nmorse[0]=\"dash; dash; dash; dash; dash\"\nmorse[1]=\"dot; dash; dash; dash; dash\"\nmorse[2]=\"dot; dot; dash; dash; dash\"\nmorse[3]=\"dot; dot; dot; dash; dash\"\nmorse[4]=\"dot; dot; dot; dot; dash\"\nmorse[5]=\"dot; dot; dot; dot; dot\"\nmorse[6]=\"dash; dot; dot; dot; dot\"\nmorse[7]=\"dash; dash; dot; dot; dot\"\nmorse[8]=\"dash; dash; dash; dot; dot\"\nmorse[9]=\"dash; dash; dash; dash; dot\"\n# The following must be escaped or quoted.\nmorse[?]=\"dot; dot; dash; dash; dot; dot\"\nmorse[.]=\"dot; dash; dot; dash; dot; dash\"\nmorse[,]=\"dash; dash; dot; dot; dash; dash\"\nmorse[/]=\"dash; dot; dot; dash; dot\"\nmorse[\\@]=\"dot; dash; dash; dot; dash; dot\"\n# ======================================= #\n\nplay_letter ()\n{\n  eval ${morse[$1]}   # Play dots, dashes from appropriate sound files.\n  # Why is 'eval' necessary here?\n  usleep $LETTERSPACE # Pause in between letters.\n}\n\nextract_letters ()\n{                     # Slice string apart, letter by letter.\n  local pos=0         # Starting at left end of string.\n  local len=1         # One letter at a time.\n  strlen=${#1}\n\n  while [ $pos -lt $strlen ]\n  do\n    letter=${1:pos:len}\n    #      ^^^^^^^^^^^^    See Chapter 10.1.\n    play_letter $letter\n    echo -n \"*\"       #    Mark letter just played.\n    ((pos++))\n  done\n}\n\n######### Play the sounds ############\ndot()  { aplay \"$DOT\" 2&>/dev/null;  }\ndash() { aplay \"$DASH\" 2&>/dev/null; }\n######################################\n\nno_args ()\n{\n    declare -a usage\n    usage=( $0 word1 word2 ... )\n\n    echo \"Usage:\"; echo\n    echo ${usage[*]}\n    for index in 0 1 2 3\n    do\n      extract_letters ${usage[index]}     \n      usleep $WORDSPACE\n      echo -n \" \"     # Print space between words.\n    done\n#   echo \"Usage: $0 word1 word2 ... \"\n    echo; echo\n}\n\n# int main()\n# {\n\nclear                 # Clear the terminal screen.\necho \"            SAM\"\necho \"Still Another Morse code trainer\"\necho \"    Author: Mendel Cooper\"\necho; echo;\n\nif [ -z \"$1\" ]\nthen\n  no_args\n  echo; echo; echo \"$EXIT_MSG\"; echo\n  exit $E_NOARGS\nfi\n\necho; echo \"$*\"       # Print text that will be played.\n\nuntil [ -z \"$1\" ]\ndo\n  extract_letters $1\n  shift           # On to next word.\n  usleep $WORDSPACE\n  echo -n \" \"     # Print space between words.\ndone\n\necho; echo; echo \"$EXIT_MSG\"; echo\n\nexit 0\n# }\n\n#  Exercises:\n#  ---------\n#  1) Have the script accept either lowercase or uppercase words\n#+    as arguments. Hint: Use 'tr' . . .\n#  2) Have the script optionally accept input from a text file.\n```", "```sh #!/bin/bash\n# base64.sh: Bash implementation of Base64 encoding and decoding.\n#\n# Copyright (c) 2011 vladz <vladz@devzero.fr>\n# Used in ABSG with permission (thanks!).\n#\n#  Encode or decode original Base64 (and also Base64url)\n#+ from STDIN to STDOUT.\n#\n#    Usage:\n#\n#    Encode\n#    $ ./base64.sh < binary-file > binary-file.base64\n#    Decode\n#    $ ./base64.sh -d < binary-file.base64 > binary-file\n#\n# Reference:\n#\n#    [1]  RFC4648 - \"The Base16, Base32, and Base64 Data Encodings\"\n#         http://tools.ietf.org/html/rfc4648#section-5\n\n# The base64_charset[] array contains entire base64 charset,\n# and additionally the character \"=\" ...\nbase64_charset=( {A..Z} {a..z} {0..9} + / = )\n                # Nice illustration of brace expansion.\n\n#  Uncomment the ### line below to use base64url encoding instead of\n#+ original base64.\n### base64_charset=( {A..Z} {a..z} {0..9} - _ = )\n\n#  Output text width when encoding\n#+ (64 characters, just like openssl output).\ntext_width=64\n\nfunction display_base64_char {\n#  Convert a 6-bit number (between 0 and 63) into its corresponding values\n#+ in Base64, then display the result with the specified text width.\n  printf \"${base64_charset[$1]}\"; (( width++ ))\n  (( width % text_width == 0 )) && printf \"\\n\"\n}\n\nfunction encode_base64 {\n# Encode three 8-bit hexadecimal codes into four 6-bit numbers.\n  #    We need two local int array variables:\n  #    c8[]: to store the codes of the 8-bit characters to encode\n  #    c6[]: to store the corresponding encoded values on 6-bit\n  declare -a -i c8 c6\n\n  #  Convert hexadecimal to decimal.\n  c8=( $(printf \"ibase=16; ${1:0:2}\\n${1:2:2}\\n${1:4:2}\\n\" &#124; bc) )\n\n  #  Let's play with bitwise operators\n  #+ (3x8-bit into 4x6-bits conversion).\n  (( c6[0] = c8[0] >> 2 ))\n  (( c6[1] = ((c8[0] &  3) << 4) &#124; (c8[1] >> 4) ))\n\n  # The following operations depend on the c8 element number.\n  case ${#c8[*]} in \n    3) (( c6[2] = ((c8[1] & 15) << 2) &#124; (c8[2] >> 6) ))\n       (( c6[3] = c8[2] & 63 )) ;;\n    2) (( c6[2] = (c8[1] & 15) << 2 ))\n       (( c6[3] = 64 )) ;;\n    1) (( c6[2] = c6[3] = 64 )) ;;\n  esac\n\n  for char in ${c6[@]}; do\n    display_base64_char ${char}\n  done\n}\n\nfunction decode_base64 {\n# Decode four base64 characters into three hexadecimal ASCII characters.\n  #  c8[]: to store the codes of the 8-bit characters\n  #  c6[]: to store the corresponding Base64 values on 6-bit\n  declare -a -i c8 c6\n\n  # Find decimal value corresponding to the current base64 character.\n  for current_char in ${1:0:1} ${1:1:1} ${1:2:1} ${1:3:1}; do\n     [ \"${current_char}\" = \"=\" ] && break\n\n     position=0\n     while [ \"${current_char}\" != \"${base64_charset[${position}]}\" ]; do\n        (( position++ ))\n     done\n\n     c6=( ${c6[*]} ${position} )\n  done\n\n  #  Let's play with bitwise operators\n  #+ (4x8-bit into 3x6-bits conversion).\n  (( c8[0] = (c6[0] << 2) &#124; (c6[1] >> 4) ))\n\n  # The next operations depends on the c6 elements number.\n  case ${#c6[*]} in\n    3) (( c8[1] = ( (c6[1] & 15) << 4) &#124; (c6[2] >> 2) ))\n       (( c8[2] = (c6[2] & 3) << 6 )); unset c8[2] ;;\n    4) (( c8[1] = ( (c6[1] & 15) << 4) &#124; (c6[2] >> 2) ))\n       (( c8[2] = ( (c6[2] &  3) << 6) &#124;  c6[3] )) ;;\n  esac\n\n  for char in ${c8[*]}; do\n     printf \"\\x$(printf \"%x\" ${char})\"\n  done\n}\n\n# main ()\n\nif [ \"$1\" = \"-d\" ]; then   # decode\n\n  # Reformat STDIN in pseudo 4x6-bit groups.\n  content=$(cat - &#124; tr -d \"\\n\" &#124; sed -r \"s/(.{4})/\\1 /g\")\n\n  for chars in ${content}; do decode_base64 ${chars}; done\n\nelse\n  # Make a hexdump of stdin and reformat in 3-byte groups.\n  content=$(cat - &#124; xxd -ps -u &#124; sed -r \"s/(\\w{6})/\\1 /g\" &#124;\n            tr -d \"\\n\")\n\n  for chars in ${content}; do encode_base64 ${chars}; done\n\n  echo\n\nfi\n```", "```sh #!/bin/bash\n#  Prepends a string at a specified line\n#+ in files with names ending in \"sample\"\n#+ in the current working directory.\n#  000000000000000000000000000000000000\n#  This script overwrites files!\n#  Be careful running it in a directory\n#+ where you have important files!!!\n#  000000000000000000000000000000000000\n\n#  Create a couple of files to operate on ...\n#  01sample\n#  02sample\n#  ... etc.\n#  These files must not be empty, else the prepend will not work.\n\nlineno=1            # Append at line 1 (prepend).\nfilespec=\"*sample\"  # Filename pattern to operate on.\n\nstring=$(whoami)    # Will set your username as string to insert.\n                    # It could just as easily be any other string.\n\nfor file in $filespec # Specify which files to alter.\ndo #        ^^^^^^^^^\n sed -i \"\"$lineno\"i \"$string\"\" $file\n#    ^^ -i option edits files in-place.\n#                 ^ Insert (i) command.\n echo \"\"$file\" altered!\"\ndone\n\necho \"Warning: files possibly clobbered!\"\n\nexit 0\n\n# Exercise:\n# Add error checking to this script.\n# It needs it badly.\n```", "```sh #!/bin/bash\n# gronsfeld.bash\n\n# License: GPL3\n# Reldate 06/23/11\n\n#  This is an implementation of the Gronsfeld Cipher.\n#  It's essentially a stripped-down variant of the \n#+ polyalphabetic Vigenre Tableau, but with only 10 alphabets.\n#  The classic Gronsfeld has a numeric sequence as the key word,\n#+ but here we substitute a letter string, for ease of use.\n#  Allegedly, this cipher was invented by the eponymous Count Gronsfeld\n#+ in the 17th Century. It was at one time considered to be unbreakable.\n#  Note that this is ###not### a secure cipher by modern standards.\n\n#  Global Variables  #\nEnc_suffix=\"29379\"   #  Encrypted text output with this 5-digit suffix. \n                     #  This functions as a decryption flag,\n                     #+ and when used to generate passwords adds security.\nDefault_key=\"gronsfeldk\"\n                     #  The script uses this if key not entered below\n                     #  (at \"Keychain\").\n                     #  Change the above two values frequently\n                     #+ for added security.\n\nGROUPLEN=5           #  Output in groups of 5 letters, per tradition.\nalpha1=( abcdefghijklmnopqrstuvwxyz )\nalpha2=( {A..Z} )    #  Output in all caps, per tradition.\n                     #  Use   alpha2=( {a..z} )   for password generator.\nwraplen=26           #  Wrap around if past end of alphabet.\ndflag=               #  Decrypt flag (set if $Enc_suffix present).\nE_NOARGS=76          #  Missing command-line args?\nDEBUG=77             #  Debugging flag.\ndeclare -a offsets   #  This array holds the numeric shift values for\n                     #+ encryption/decryption.\n\n########Keychain#########\nkey=  ### Put key here!!!\n      # 10 characters!\n#########################\n\n# Function\n: ()\n{ # Encrypt or decrypt, depending on whether $dflag is set.\n  # Why \": ()\" as a function name? Just to prove that it can be done.\n\n  local idx keydx mlen off1 shft\n  local plaintext=\"$1\"\n  local mlen=${#plaintext}\n\nfor (( idx=0; idx<$mlen; idx++ ))\ndo\n  let \"keydx = $idx % $keylen\"\n  shft=${offsets[keydx]}\n\n  if [ -n \"$dflag\" ]\n  then                  # Decrypt!\n    let \"off1 = $(expr index \"${alpha1[*]}\" ${plaintext:idx:1}) - $shft\"\n    # Shift backward to decrypt.\n  else                  # Encrypt!\n    let \"off1 = $(expr index \"${alpha1[*]}\" ${plaintext:idx:1}) + $shft\"\n    # Shift forward to encrypt.\n    test $(( $idx % $GROUPLEN)) = 0 && echo -n \" \"  # Groups of 5 letters.\n    #  Comment out above line for output as a string without whitespace,\n    #+ for example, if using the script as a password generator.\n  fi\n\n  ((off1--))   # Normalize. Why is this necessary?\n\n      if [ $off1 -lt 0 ]\n      then     # Catch negative indices.\n        let \"off1 += $wraplen\"\n      fi\n\n  ((off1 %= $wraplen))   # Wrap around if past end of alphabet.\n\n  echo -n \"${alpha2[off1]}\"\n\ndone\n\n  if [ -z \"$dflag\" ]\n  then\n    echo \" $Enc_suffix\"\n#   echo \"$Enc_suffix\"  # For password generator.\n  else\n    echo\n  fi\n} # End encrypt/decrypt function.\n\n# int main () {\n\n# Check for command-line args.\nif [ -z \"$1\" ]\nthen\n   echo \"Usage: $0 TEXT TO ENCODE/DECODE\"\n   exit $E_NOARGS\nfi\n\nif [ ${!#} == \"$Enc_suffix\" ]\n#    ^^^^^ Final command-line arg.\nthen\n  dflag=ON\n  echo -n \"+\"           # Flag decrypted text with a \"+\" for easy ID.\nfi\n\nif [ -z \"$key\" ]\nthen\n  key=\"$Default_key\"    # \"gronsfeldk\" per above.\nfi\n\nkeylen=${#key}\n\nfor (( idx=0; idx<$keylen; idx++ ))\ndo  # Calculate shift values for encryption/decryption.\n  offsets[idx]=$(expr index \"${alpha1[*]}\" ${key:idx:1})   # Normalize.\n  ((offsets[idx]--))  #  Necessary because \"expr index\" starts at 1,\n                      #+ whereas array count starts at 0.\n  # Generate array of numerical offsets corresponding to the key.\n  # There are simpler ways to accomplish this.\ndone\n\nargs=$(echo \"$*\" &#124; sed -e 's/ //g' &#124; tr A-Z a-z &#124; sed -e 's/[0-9]//g')\n# Remove whitespace and digits from command-line args.\n# Can modify to also remove punctuation characters, if desired.\n\n         # Debug:\n         # echo \"$args\"; exit $DEBUG\n\n: \"$args\"               # Call the function named \":\".\n# : is a null operator, except . . . when it's a function name!\n\nexit $?    # } End-of-script\n\n#   **************************************************************   #\n#   This script can function as a  password generator,\n#+  with several minor mods, see above.\n#   That would allow an easy-to-remember password, even the word\n#+ \"password\" itself, which encrypts to vrgfotvo29379\n#+  a fairly secure password not susceptible to a dictionary attack.\n#   Or, you could use your own name (surely that's easy to remember!).\n#   For example, Bozo Bozeman encrypts to hfnbttdppkt29379.\n#   **************************************************************   #\n```", "```sh #!/bin/bash\n# bingo.sh\n# Bingo number generator\n# Reldate 20Aug12, License: Public Domain\n\n#######################################################################\n# This script generates bingo numbers.\n# Hitting a key generates a new number.\n# Hitting 'q' terminates the script.\n# In a given run of the script, there will be no duplicate numbers.\n# When the script terminates, it prints a log of the numbers generated.\n#######################################################################\n\nMIN=1       # Lowest allowable bingo number.\nMAX=75      # Highest allowable bingo number.\nCOLS=15     # Numbers in each column (B I N G O).\nSINGLE_DIGIT_MAX=9\n\ndeclare -a Numbers\nPrefix=(B I N G O)\n\ninitialize_Numbers ()\n{  # Zero them out to start.\n   # They'll be incremented if chosen.\n   local index=0\n   until [ \"$index\" -gt $MAX ]\n   do\n     Numbers[index]=0\n     ((index++))\n   done\n\n   Numbers[0]=1   # Flag zero, so it won't be selected.\n}\n\ngenerate_number ()\n{\n   local number\n\n   while [ 1 ]\n   do\n     let \"number = $(expr $RANDOM % $MAX)\"\n     if [ ${Numbers[number]} -eq 0 ]    # Number not yet called.\n     then\n       let \"Numbers[number]+=1\"         # Flag it in the array.\n       break                            # And terminate loop.\n     fi   # Else if already called, loop and generate another number.\n   done\n   # Exercise: Rewrite this more elegantly as an until-loop.\n\n   return $number\n}\n\nprint_numbers_called ()\n{   # Print out the called number log in neat columns.\n    # echo ${Numbers[@]}\n\nlocal pre2=0                #  Prefix a zero, so columns will align\n                            #+ on single-digit numbers.\n\necho \"Number Stats\"\n\nfor (( index=1; index<=MAX; index++))\ndo\n  count=${Numbers[index]}\n  let \"t = $index - 1\"      # Normalize, since array begins with index 0.\n  let \"column = $(expr $t / $COLS)\"\n  pre=${Prefix[column]}\n# echo -n \"${Prefix[column]} \"\n\nif [ $(expr $t % $COLS) -eq 0 ]\nthen\n  echo   # Newline at end of row.\nfi\n\n  if [ \"$index\" -gt $SINGLE_DIGIT_MAX ]  # Check for single-digit number.\n  then\n    echo -n \"$pre$index#$count \"\n  else    # Prefix a zero.\n    echo -n \"$pre$pre2$index#$count \"\n  fi\n\ndone\n}\n\n# main () {\nRANDOM=$$   # Seed random number generator.\n\ninitialize_Numbers   # Zero out the number tracking array.\n\nclear\necho \"Bingo Number Caller\"; echo\n\nwhile [[ \"$key\" != \"q\" ]]   # Main loop.\ndo\n  read -s -n1 -p \"Hit a key for the next number [q to exit] \" key\n  # Usually 'q' exits, but not always.\n  # Can always hit Ctl-C if q fails.\n  echo\n\n  generate_number; new_number=$?\n\n  let \"column = $(expr $new_number / $COLS)\"\n  echo -n \"${Prefix[column]} \"   # B-I-N-G-O\n\n  echo $new_number\ndone\n\necho; echo\n\n# Game over ...\nprint_numbers_called\necho; echo \"[#0 = not called . . . #1 = called]\"\n\necho\n\nexit 0\n# }\n\n# Certainly, this script could stand some improvement.\n#See also the author's Instructable:\n#www.instructables.com/id/Binguino-An-Arduino-based-Bingo-Number-Generato/\n```", "```sh #!/bin/bash\n# basics-reviewed.bash\n\n# File extension == *.bash == specific to Bash\n\n#   Copyright (c) Michael S. Zick, 2003; All rights reserved.\n#   License: Use in any form, for any purpose.\n#   Revision: $ID$\n#\n#              Edited for layout by M.C.\n#   (author of the \"Advanced Bash Scripting Guide\")\n#   Fixes and updates (04/08) by Cliff Bamford.\n\n#  This script tested under Bash versions 2.04, 2.05a and 2.05b.\n#  It may not work with earlier versions.\n#  This demonstration script generates one --intentional--\n#+ \"command not found\" error message. See line 436.\n\n#  The current Bash maintainer, Chet Ramey, has fixed the items noted\n#+ for later versions of Bash.\n\n        ###-------------------------------------------###\n        ###  Pipe the output of this script to 'more' ###\n        ###+ else it will scroll off the page.        ###\n        ###                                           ###\n        ###  You may also redirect its output         ###\n        ###+ to a file for examination.               ###  \n        ###-------------------------------------------###\n\n#  Most of the following points are described at length in\n#+ the text of the foregoing \"Advanced Bash Scripting Guide.\"\n#  This demonstration script is mostly just a reorganized presentation.\n#      -- msz\n\n# Variables are not typed unless otherwise specified.\n\n#  Variables are named. Names must contain a non-digit.\n#  File descriptor names (as in, for example: 2>&1)\n#+ contain ONLY digits.\n\n# Parameters and Bash array elements are numbered.\n# (Parameters are very similar to Bash arrays.)\n\n# A variable name may be undefined (null reference).\nunset VarNull\n\n# A variable name may be defined but empty (null contents).\nVarEmpty=''                         # Two, adjacent, single quotes.\n\n# A variable name may be defined and non-empty.\nVarSomething='Literal'\n\n# A variable may contain:\n#   * A whole number as a signed 32-bit (or larger) integer\n#   * A string\n# A variable may also be an array.\n\n#  A string may contain embedded blanks and may be treated\n#+ as if it where a function name with optional arguments.\n\n#  The names of variables and the names of functions\n#+ are in different namespaces.\n\n#  A variable may be defined as a Bash array either explicitly or\n#+ implicitly by the syntax of the assignment statement.\n#  Explicit:\ndeclare -a ArrayVar\n\n# The echo command is a builtin.\necho $VarSomething\n\n# The printf command is a builtin.\n# Translate %s as: String-Format\nprintf %s $VarSomething         # No linebreak specified, none output.\necho                            # Default, only linebreak output.\n\n# The Bash parser word breaks on whitespace.\n# Whitespace, or the lack of it is significant.\n# (This holds true in general; there are, of course, exceptions.)\n\n# Translate the DOLLAR_SIGN character as: Content-Of.\n\n# Extended-Syntax way of writing Content-Of:\necho ${VarSomething}\n\n#  The ${ ... } Extended-Syntax allows more than just the variable\n#+ name to be specified.\n#  In general, $VarSomething can always be written as: ${VarSomething}.\n\n# Call this script with arguments to see the following in action.\n\n#  Outside of double-quotes, the special characters @ and *\n#+ specify identical behavior.\n#  May be pronounced as: All-Elements-Of.\n\n#  Without specification of a name, they refer to the\n#+ pre-defined parameter Bash-Array.\n\n# Glob-Pattern references\necho $*                         # All parameters to script or function\necho ${*}                       # Same\n\n# Bash disables filename expansion for Glob-Patterns.\n# Only character matching is active.\n\n# All-Elements-Of references\necho $@                         # Same as above\necho ${@}                       # Same as above\n\n#  Within double-quotes, the behavior of Glob-Pattern references\n#+ depends on the setting of IFS (Input Field Separator).\n#  Within double-quotes, All-Elements-Of references behave the same.\n\n#  Specifying only the name of a variable holding a string refers\n#+ to all elements (characters) of a string.\n\n#  To specify an element (character) of a string,\n#+ the Extended-Syntax reference notation (see below) MAY be used.\n\n#  Specifying only the name of a Bash array references\n#+ the subscript zero element,\n#+ NOT the FIRST DEFINED nor the FIRST WITH CONTENTS element.\n\n#  Additional qualification is needed to reference other elements,\n#+ which means that the reference MUST be written in Extended-Syntax.\n#  The general form is: ${name[subscript]}.\n\n#  The string forms may also be used: ${name:subscript}\n#+ for Bash-Arrays when referencing the subscript zero element.\n\n# Bash-Arrays are implemented internally as linked lists,\n#+ not as a fixed area of storage as in some programming languages.\n\n#   Characteristics of Bash arrays (Bash-Arrays):\n#   --------------------------------------------\n\n#   If not otherwise specified, Bash-Array subscripts begin with\n#+  subscript number zero. Literally: [0]\n#   This is called zero-based indexing.\n###\n#   If not otherwise specified, Bash-Arrays are subscript packed\n#+  (sequential subscripts without subscript gaps).\n###\n#   Negative subscripts are not allowed.\n###\n#   Elements of a Bash-Array need not all be of the same type.\n###\n#   Elements of a Bash-Array may be undefined (null reference).\n#       That is, a Bash-Array may be \"subscript sparse.\"\n###\n#   Elements of a Bash-Array may be defined and empty (null contents).\n###\n#   Elements of a Bash-Array may contain:\n#     * A whole number as a signed 32-bit (or larger) integer\n#     * A string\n#     * A string formated so that it appears to be a function name\n#     + with optional arguments\n###\n#   Defined elements of a Bash-Array may be undefined (unset).\n#       That is, a subscript packed Bash-Array may be changed\n#   +   into a subscript sparse Bash-Array.\n###\n#   Elements may be added to a Bash-Array by defining an element\n#+  not previously defined.\n###\n# For these reasons, I have been calling them \"Bash-Arrays\".\n# I'll return to the generic term \"array\" from now on.\n#     -- msz\n\necho \"=========================================================\"\n\n#  Lines 202 - 334 supplied by Cliff Bamford. (Thanks!)\n#  Demo --- Interaction with Arrays, quoting, IFS, echo, * and @   ---  \n#+ all affect how things work\n\nArrayVar[0]='zero'                    # 0 normal\nArrayVar[1]=one                       # 1 unquoted literal\nArrayVar[2]='two'                     # 2 normal\nArrayVar[3]='three'                   # 3 normal\nArrayVar[4]='I am four'               # 4 normal with spaces\nArrayVar[5]='five'                    # 5 normal\nunset ArrayVar[6]                     # 6 undefined\nArrayValue[7]='seven'                 # 7 normal\nArrayValue[8]=''                      # 8 defined but empty\nArrayValue[9]='nine'                  # 9 normal\n\necho '--- Here is the array we are using for this test'\necho\necho \"ArrayVar[0]='zero'             # 0 normal\"\necho \"ArrayVar[1]=one                # 1 unquoted literal\"\necho \"ArrayVar[2]='two'              # 2 normal\"\necho \"ArrayVar[3]='three'            # 3 normal\"\necho \"ArrayVar[4]='I am four'        # 4 normal with spaces\"\necho \"ArrayVar[5]='five'             # 5 normal\"\necho \"unset ArrayVar[6]              # 6 undefined\"\necho \"ArrayValue[7]='seven'          # 7 normal\"\necho \"ArrayValue[8]=''               # 8 defined but empty\"\necho \"ArrayValue[9]='nine'           # 9 normal\"\necho\n\necho\necho '---Case0: No double-quotes, Default IFS of space,tab,newline ---'\nIFS=$'\\x20'$'\\x09'$'\\x0A'            # In exactly this order.\necho 'Here is: printf %q {${ArrayVar[*]}'\nprintf %q ${ArrayVar[*]}\necho\necho 'Here is: printf %q {${ArrayVar[@]}'\nprintf %q ${ArrayVar[@]}\necho\necho 'Here is: echo ${ArrayVar[*]}'\necho  ${ArrayVar[@]}\necho 'Here is: echo {${ArrayVar[@]}'\necho ${ArrayVar[@]}\n\necho\necho '---Case1: Within double-quotes - Default IFS of space-tab- \nnewline ---'\nIFS=$'\\x20'$'\\x09'$'\\x0A'\t    #  These three bytes,\necho 'Here is: printf %q \"{${ArrayVar[*]}\"'\nprintf %q \"${ArrayVar[*]}\"\necho\necho 'Here is: printf %q \"{${ArrayVar[@]}\"'\nprintf %q \"${ArrayVar[@]}\"\necho\necho 'Here is: echo \"${ArrayVar[*]}\"'\necho  \"${ArrayVar[@]}\"\necho 'Here is: echo \"{${ArrayVar[@]}\"'\necho \"${ArrayVar[@]}\"\n\necho\necho '---Case2: Within double-quotes - IFS is q'\nIFS='q'\necho 'Here is: printf %q \"{${ArrayVar[*]}\"'\nprintf %q \"${ArrayVar[*]}\"\necho\necho 'Here is: printf %q \"{${ArrayVar[@]}\"'\nprintf %q \"${ArrayVar[@]}\"\necho\necho 'Here is: echo \"${ArrayVar[*]}\"'\necho  \"${ArrayVar[@]}\"\necho 'Here is: echo \"{${ArrayVar[@]}\"'\necho \"${ArrayVar[@]}\"\n\necho\necho '---Case3: Within double-quotes - IFS is ^'\nIFS='^'\necho 'Here is: printf %q \"{${ArrayVar[*]}\"'\nprintf %q \"${ArrayVar[*]}\"\necho\necho 'Here is: printf %q \"{${ArrayVar[@]}\"'\nprintf %q \"${ArrayVar[@]}\"\necho\necho 'Here is: echo \"${ArrayVar[*]}\"'\necho  \"${ArrayVar[@]}\"\necho 'Here is: echo \"{${ArrayVar[@]}\"'\necho \"${ArrayVar[@]}\"\n\necho\necho '---Case4: Within double-quotes - IFS is ^ followed by  \nspace,tab,newline'\nIFS=$'^'$'\\x20'$'\\x09'$'\\x0A'       # ^ + space tab newline\necho 'Here is: printf %q \"{${ArrayVar[*]}\"'\nprintf %q \"${ArrayVar[*]}\"\necho\necho 'Here is: printf %q \"{${ArrayVar[@]}\"'\nprintf %q \"${ArrayVar[@]}\"\necho\necho 'Here is: echo \"${ArrayVar[*]}\"'\necho  \"${ArrayVar[@]}\"\necho 'Here is: echo \"{${ArrayVar[@]}\"'\necho \"${ArrayVar[@]}\"\n\necho\necho '---Case6: Within double-quotes - IFS set and empty '\nIFS=''\necho 'Here is: printf %q \"{${ArrayVar[*]}\"'\nprintf %q \"${ArrayVar[*]}\"\necho\necho 'Here is: printf %q \"{${ArrayVar[@]}\"'\nprintf %q \"${ArrayVar[@]}\"\necho\necho 'Here is: echo \"${ArrayVar[*]}\"'\necho  \"${ArrayVar[@]}\"\necho 'Here is: echo \"{${ArrayVar[@]}\"'\necho \"${ArrayVar[@]}\"\n\necho\necho '---Case7: Within double-quotes - IFS is unset'\nunset IFS\necho 'Here is: printf %q \"{${ArrayVar[*]}\"'\nprintf %q \"${ArrayVar[*]}\"\necho\necho 'Here is: printf %q \"{${ArrayVar[@]}\"'\nprintf %q \"${ArrayVar[@]}\"\necho\necho 'Here is: echo \"${ArrayVar[*]}\"'\necho  \"${ArrayVar[@]}\"\necho 'Here is: echo \"{${ArrayVar[@]}\"'\necho \"${ArrayVar[@]}\"\n\necho\necho '---End of Cases---'\necho \"=========================================================\"; echo\n\n# Put IFS back to the default.\n# Default is exactly these three bytes.\nIFS=$'\\x20'$'\\x09'$'\\x0A'           # In exactly this order.\n\n# Interpretation of the above outputs:\n#   A Glob-Pattern is I/O; the setting of IFS matters.\n###\n#   An All-Elements-Of does not consider IFS settings.\n###\n#   Note the different output using the echo command and the\n#+  quoted format operator of the printf command.\n\n#  Recall:\n#   Parameters are similar to arrays and have the similar behaviors.\n###\n#  The above examples demonstrate the possible variations.\n#  To retain the shape of a sparse array, additional script\n#+ programming is required.\n###\n#  The source code of Bash has a routine to output the\n#+ [subscript]=value   array assignment format.\n#  As of version 2.05b, that routine is not used,\n#+ but that might change in future releases.\n\n# The length of a string, measured in non-null elements (characters):\necho\necho '- - Non-quoted references - -'\necho 'Non-Null character count: '${#VarSomething}' characters.'\n\n# test='Lit'$'\\x00''eral'           # $'\\x00' is a null character.\n# echo ${#test}                     # See that?\n\n#  The length of an array, measured in defined elements,\n#+ including null content elements.\necho\necho 'Defined content count: '${#ArrayVar[@]}' elements.'\n# That is NOT the maximum subscript (4).\n# That is NOT the range of the subscripts (1 . . 4 inclusive).\n# It IS the length of the linked list.\n###\n#  Both the maximum subscript and the range of the subscripts may\n#+ be found with additional script programming.\n\n# The length of a string, measured in non-null elements (characters):\necho\necho '- - Quoted, Glob-Pattern references - -'\necho 'Non-Null character count: '\"${#VarSomething}\"' characters.'\n\n#  The length of an array, measured in defined elements,\n#+ including null-content elements.\necho\necho 'Defined element count: '\"${#ArrayVar[*]}\"' elements.'\n\n#  Interpretation: Substitution does not effect the ${# ... } operation.\n#  Suggestion:\n#  Always use the All-Elements-Of character\n#+ if that is what is intended (independence from IFS).\n\n#  Define a simple function.\n#  I include an underscore in the name\n#+ to make it distinctive in the examples below.\n###\n#  Bash separates variable names and function names\n#+ in different namespaces.\n#  The Mark-One eyeball isn't that advanced.\n###\n_simple() {\n    echo -n 'SimpleFunc'$@          #  Newlines are swallowed in\n}                                   #+ result returned in any case.\n\n# The ( ... ) notation invokes a command or function.\n# The $( ... ) notation is pronounced: Result-Of.\n\n# Invoke the function _simple\necho\necho '- - Output of function _simple - -'\n_simple                             # Try passing arguments.\necho\n# or\n(_simple)                           # Try passing arguments.\necho\n\necho '- Is there a variable of that name? -'\necho $_simple not defined           # No variable by that name.\n\n# Invoke the result of function _simple (Error msg intended)\n\n###\n$(_simple)                          # Gives an error message:\n#                          line 436: SimpleFunc: command not found\n#                          ---------------------------------------\n\necho\n###\n\n#  The first word of the result of function _simple\n#+ is neither a valid Bash command nor the name of a defined function.\n###\n# This demonstrates that the output of _simple is subject to evaluation.\n###\n# Interpretation:\n#   A function can be used to generate in-line Bash commands.\n\n# A simple function where the first word of result IS a bash command:\n###\n_print() {\n    echo -n 'printf %q '$@\n}\n\necho '- - Outputs of function _print - -'\n_print parm1 parm2                  # An Output NOT A Command.\necho\n\n$(_print parm1 parm2)               #  Executes: printf %q parm1 parm2\n                                    #  See above IFS examples for the\n                                    #+ various possibilities.\necho\n\n$(_print $VarSomething)             # The predictable result.\necho\n\n# Function variables\n# ------------------\n\necho\necho '- - Function variables - -'\n# A variable may represent a signed integer, a string or an array.\n# A string may be used like a function name with optional arguments.\n\n# set -vx                           #  Enable if desired\ndeclare -f funcVar                  #+ in namespace of functions\n\nfuncVar=_print                      # Contains name of function.\n$funcVar parm1                      # Same as _print at this point.\necho\n\nfuncVar=$(_print )                  # Contains result of function.\n$funcVar                            # No input, No output.\n$funcVar $VarSomething              # The predictable result.\necho\n\nfuncVar=$(_print $VarSomething)     #  $VarSomething replaced HERE.\n$funcVar                            #  The expansion is part of the\necho                                #+ variable contents.\n\nfuncVar=\"$(_print $VarSomething)\"   #  $VarSomething replaced HERE.\n$funcVar                            #  The expansion is part of the\necho                                #+ variable contents.\n\n#  The difference between the unquoted and the double-quoted versions\n#+ above can be seen in the \"protect_literal.sh\" example.\n#  The first case above is processed as two, unquoted, Bash-Words.\n#  The second case above is processed as one, quoted, Bash-Word.\n\n# Delayed replacement\n# -------------------\n\necho\necho '- - Delayed replacement - -'\nfuncVar=\"$(_print '$VarSomething')\" # No replacement, single Bash-Word.\neval $funcVar                       # $VarSomething replaced HERE.\necho\n\nVarSomething='NewThing'\neval $funcVar                       # $VarSomething replaced HERE.\necho\n\n# Restore the original setting trashed above.\nVarSomething=Literal\n\n#  There are a pair of functions demonstrated in the\n#+ \"protect_literal.sh\" and \"unprotect_literal.sh\" examples.\n#  These are general purpose functions for delayed replacement literals\n#+ containing variables.\n\n# REVIEW:\n# ------\n\n#  A string can be considered a Classic-Array of elements (characters).\n#  A string operation applies to all elements (characters) of the string\n#+ (in concept, anyway).\n###\n#  The notation: ${array_name[@]} represents all elements of the\n#+ Bash-Array: array_name.\n###\n#  The Extended-Syntax string operations can be applied to all\n#+ elements of an array.\n###\n#  This may be thought of as a For-Each operation on a vector of strings.\n###\n#  Parameters are similar to an array.\n#  The initialization of a parameter array for a script\n#+ and a parameter array for a function only differ\n#+ in the initialization of ${0}, which never changes its setting.\n###\n#  Subscript zero of the script's parameter array contains\n#+ the name of the script.\n###\n#  Subscript zero of a function's parameter array DOES NOT contain\n#+ the name of the function.\n#  The name of the current function is accessed by the $FUNCNAME variable.\n###\n#  A quick, review list follows (quick, not short).\n\necho\necho '- - Test (but not change) - -'\necho '- null reference -'\necho -n ${VarNull-'NotSet'}' '          # NotSet\necho ${VarNull}                         # NewLine only\necho -n ${VarNull:-'NotSet'}' '         # NotSet\necho ${VarNull}                         # Newline only\n\necho '- null contents -'\necho -n ${VarEmpty-'Empty'}' '          # Only the space\necho ${VarEmpty}                        # Newline only\necho -n ${VarEmpty:-'Empty'}' '         # Empty\necho ${VarEmpty}                        # Newline only\n\necho '- contents -'\necho ${VarSomething-'Content'}          # Literal\necho ${VarSomething:-'Content'}         # Literal\n\necho '- Sparse Array -'\necho ${ArrayVar[@]-'not set'}\n\n# ASCII-Art time\n# State     Y==yes, N==no\n#           -       :-\n# Unset     Y       Y       ${# ... } == 0\n# Empty     N       Y       ${# ... } == 0\n# Contents  N       N       ${# ... } > 0\n\n#  Either the first and/or the second part of the tests\n#+ may be a command or a function invocation string.\necho\necho '- - Test 1 for undefined - -'\ndeclare -i t\n_decT() {\n    t=$t-1\n}\n\n# Null reference, set: t == -1\nt=${#VarNull}                           # Results in zero.\n${VarNull- _decT }                      # Function executes, t now -1.\necho $t\n\n# Null contents, set: t == 0\nt=${#VarEmpty}                          # Results in zero.\n${VarEmpty- _decT }                     # _decT function NOT executed.\necho $t\n\n# Contents, set: t == number of non-null characters\nVarSomething='_simple'                  # Set to valid function name.\nt=${#VarSomething}                      # non-zero length\n${VarSomething- _decT }                 # Function _simple executed.\necho $t                                 # Note the Append-To action.\n\n# Exercise: clean up that example.\nunset t\nunset _decT\nVarSomething=Literal\n\necho\necho '- - Test and Change - -'\necho '- Assignment if null reference -'\necho -n ${VarNull='NotSet'}' '          # NotSet NotSet\necho ${VarNull}\nunset VarNull\n\necho '- Assignment if null reference -'\necho -n ${VarNull:='NotSet'}' '         # NotSet NotSet\necho ${VarNull}\nunset VarNull\n\necho '- No assignment if null contents -'\necho -n ${VarEmpty='Empty'}' '          # Space only\necho ${VarEmpty}\nVarEmpty=''\n\necho '- Assignment if null contents -'\necho -n ${VarEmpty:='Empty'}' '         # Empty Empty\necho ${VarEmpty}\nVarEmpty=''\n\necho '- No change if already has contents -'\necho ${VarSomething='Content'}          # Literal\necho ${VarSomething:='Content'}         # Literal\n\n# \"Subscript sparse\" Bash-Arrays\n###\n#  Bash-Arrays are subscript packed, beginning with\n#+ subscript zero unless otherwise specified.\n###\n#  The initialization of ArrayVar was one way\n#+ to \"otherwise specify\".  Here is the other way:\n###\necho\ndeclare -a ArraySparse\nArraySparse=( [1]=one [2]='' [4]='four' )\n# [0]=null reference, [2]=null content, [3]=null reference\n\necho '- - Array-Sparse List - -'\n# Within double-quotes, default IFS, Glob-Pattern\n\nIFS=$'\\x20'$'\\x09'$'\\x0A'\nprintf %q \"${ArraySparse[*]}\"\necho\n\n#  Note that the output does not distinguish between \"null content\"\n#+ and \"null reference\".\n#  Both print as escaped whitespace.\n###\n#  Note also that the output does NOT contain escaped whitespace\n#+ for the \"null reference(s)\" prior to the first defined element.\n###\n# This behavior of 2.04, 2.05a and 2.05b has been reported\n#+ and may change in a future version of Bash.\n\n#  To output a sparse array and maintain the [subscript]=value\n#+ relationship without change requires a bit of programming.\n#  One possible code fragment:\n###\n# local l=${#ArraySparse[@]}        # Count of defined elements\n# local f=0                         # Count of found subscripts\n# local i=0                         # Subscript to test\n(                                   # Anonymous in-line function\n    for (( l=${#ArraySparse[@]}, f = 0, i = 0 ; f < l ; i++ ))\n    do\n        # 'if defined then...'\n        ${ArraySparse[$i]+ eval echo '\\ ['$i']='${ArraySparse[$i]} ; (( f++ )) }\n    done\n)\n\n# The reader coming upon the above code fragment cold\n#+ might want to review \"command lists\" and \"multiple commands on a line\"\n#+ in the text of the foregoing \"Advanced Bash Scripting Guide.\"\n###\n#  Note:\n#  The \"read -a array_name\" version of the \"read\" command\n#+ begins filling array_name at subscript zero.\n#  ArraySparse does not define a value at subscript zero.\n###\n#  The user needing to read/write a sparse array to either\n#+ external storage or a communications socket must invent\n#+ a read/write code pair suitable for their purpose.\n###\n# Exercise: clean it up.\n\nunset ArraySparse\n\necho\necho '- - Conditional alternate (But not change)- -'\necho '- No alternate if null reference -'\necho -n ${VarNull+'NotSet'}' '\necho ${VarNull}\nunset VarNull\n\necho '- No alternate if null reference -'\necho -n ${VarNull:+'NotSet'}' '\necho ${VarNull}\nunset VarNull\n\necho '- Alternate if null contents -'\necho -n ${VarEmpty+'Empty'}' '              # Empty\necho ${VarEmpty}\nVarEmpty=''\n\necho '- No alternate if null contents -'\necho -n ${VarEmpty:+'Empty'}' '             # Space only\necho ${VarEmpty}\nVarEmpty=''\n\necho '- Alternate if already has contents -'\n\n# Alternate literal\necho -n ${VarSomething+'Content'}' '        # Content Literal\necho ${VarSomething}\n\n# Invoke function\necho -n ${VarSomething:+ $(_simple) }' '    # SimpleFunc Literal\necho ${VarSomething}\necho\n\necho '- - Sparse Array - -'\necho ${ArrayVar[@]+'Empty'}                 # An array of 'Empty'(ies)\necho\n\necho '- - Test 2 for undefined - -'\n\ndeclare -i t\n_incT() {\n    t=$t+1\n}\n\n#  Note:\n#  This is the same test used in the sparse array\n#+ listing code fragment.\n\n# Null reference, set: t == -1\nt=${#VarNull}-1                     # Results in minus-one.\n${VarNull+ _incT }                  # Does not execute.\necho $t' Null reference'\n\n# Null contents, set: t == 0\nt=${#VarEmpty}-1                    # Results in minus-one.\n${VarEmpty+ _incT }                 # Executes.\necho $t'  Null content'\n\n# Contents, set: t == (number of non-null characters)\nt=${#VarSomething}-1                # non-null length minus-one\n${VarSomething+ _incT }             # Executes.\necho $t'  Contents'\n\n# Exercise: clean up that example.\nunset t\nunset _incT\n\n# ${name?err_msg} ${name:?err_msg}\n#  These follow the same rules but always exit afterwards\n#+ if an action is specified following the question mark.\n#  The action following the question mark may be a literal\n#+ or a function result.\n###\n#  ${name?} ${name:?} are test-only, the return can be tested.\n\n# Element operations\n# ------------------\n\necho\necho '- - Trailing sub-element selection - -'\n\n#  Strings, Arrays and Positional parameters\n\n#  Call this script with multiple arguments\n#+ to see the parameter selections.\n\necho '- All -'\necho ${VarSomething:0}              # all non-null characters\necho ${ArrayVar[@]:0}               # all elements with content\necho ${@:0}                         # all parameters with content;\n                                    # ignoring parameter[0]\n\necho\necho '- All after -'\necho ${VarSomething:1}              # all non-null after character[0]\necho ${ArrayVar[@]:1}               # all after element[0] with content\necho ${@:2}                         # all after param[1] with content\n\necho\necho '- Range after -'\necho ${VarSomething:4:3}            # ral\n                                    # Three characters after\n                                    # character[3]\n\necho '- Sparse array gotch -'\necho ${ArrayVar[@]:1:2}     #  four - The only element with content.\n                            #  Two elements after (if that many exist).\n                            #  the FIRST WITH CONTENTS\n                            #+ (the FIRST WITH  CONTENTS is being\n                            #+ considered as if it\n                            #+ were subscript zero).\n#  Executed as if Bash considers ONLY array elements with CONTENT\n#  printf %q \"${ArrayVar[@]:0:3}\"    # Try this one\n\n#  In versions 2.04, 2.05a and 2.05b,\n#+ Bash does not handle sparse arrays as expected using this notation.\n#\n#  The current Bash maintainer, Chet Ramey, has corrected this.\n\necho '- Non-sparse array -'\necho ${@:2:2}               # Two parameters following parameter[1]\n\n# New victims for string vector examples:\nstringZ=abcABC123ABCabc\narrayZ=( abcabc ABCABC 123123 ABCABC abcabc )\nsparseZ=( [1]='abcabc' [3]='ABCABC' [4]='' [5]='123123' )\n\necho\necho ' - - Victim string - -'$stringZ'- - '\necho ' - - Victim array - -'${arrayZ[@]}'- - '\necho ' - - Sparse array - -'${sparseZ[@]}'- - '\necho ' - [0]==null ref, [2]==null ref, [4]==null content - '\necho ' - [1]=abcabc [3]=ABCABC [5]=123123 - '\necho ' - non-null-reference count: '${#sparseZ[@]}' elements'\n\necho\necho '- - Prefix sub-element removal - -'\necho '- - Glob-Pattern match must include the first character. - -'\necho '- - Glob-Pattern may be a literal or a function result. - -'\necho\n\n# Function returning a simple, Literal, Glob-Pattern\n_abc() {\n    echo -n 'abc'\n}\n\necho '- Shortest prefix -'\necho ${stringZ#123}                 # Unchanged (not a prefix).\necho ${stringZ#$(_abc)}             # ABC123ABCabc\necho ${arrayZ[@]#abc}               # Applied to each element.\n\n# echo ${sparseZ[@]#abc}            # Version-2.05b core dumps.\n# Has since been fixed by Chet Ramey.\n\n# The -it would be nice- First-Subscript-Of\n# echo ${#sparseZ[@]#*}             # This is NOT valid Bash.\n\necho\necho '- Longest prefix -'\necho ${stringZ##1*3}                # Unchanged (not a prefix)\necho ${stringZ##a*C}                # abc\necho ${arrayZ[@]##a*c}              # ABCABC 123123 ABCABC\n\n# echo ${sparseZ[@]##a*c}           # Version-2.05b core dumps.\n# Has since been fixed by Chet Ramey.\n\necho\necho '- - Suffix sub-element removal - -'\necho '- - Glob-Pattern match must include the last character. - -'\necho '- - Glob-Pattern may be a literal or a function result. - -'\necho\necho '- Shortest suffix -'\necho ${stringZ%1*3}                 # Unchanged (not a suffix).\necho ${stringZ%$(_abc)}             # abcABC123ABC\necho ${arrayZ[@]%abc}               # Applied to each element.\n\n# echo ${sparseZ[@]%abc}            # Version-2.05b core dumps.\n# Has since been fixed by Chet Ramey.\n\n# The -it would be nice- Last-Subscript-Of\n# echo ${#sparseZ[@]%*}             # This is NOT valid Bash.\n\necho\necho '- Longest suffix -'\necho ${stringZ%%1*3}                # Unchanged (not a suffix)\necho ${stringZ%%b*c}                # a\necho ${arrayZ[@]%%b*c}              # a ABCABC 123123 ABCABC a\n\n# echo ${sparseZ[@]%%b*c}           # Version-2.05b core dumps.\n# Has since been fixed by Chet Ramey.\n\necho\necho '- - Sub-element replacement - -'\necho '- - Sub-element at any location in string. - -'\necho '- - First specification is a Glob-Pattern - -'\necho '- - Glob-Pattern may be a literal or Glob-Pattern function result. - -'\necho '- - Second specification may be a literal or function result. - -'\necho '- - Second specification may be unspecified. Pronounce that'\necho '    as: Replace-With-Nothing (Delete) - -'\necho\n\n# Function returning a simple, Literal, Glob-Pattern\n_123() {\n    echo -n '123'\n}\n\necho '- Replace first occurrence -'\necho ${stringZ/$(_123)/999}         # Changed (123 is a component).\necho ${stringZ/ABC/xyz}             # xyzABC123ABCabc\necho ${arrayZ[@]/ABC/xyz}           # Applied to each element.\necho ${sparseZ[@]/ABC/xyz}          # Works as expected.\n\necho\necho '- Delete first occurrence -'\necho ${stringZ/$(_123)/}\necho ${stringZ/ABC/}\necho ${arrayZ[@]/ABC/}\necho ${sparseZ[@]/ABC/}\n\n#  The replacement need not be a literal,\n#+ since the result of a function invocation is allowed.\n#  This is general to all forms of replacement.\necho\necho '- Replace first occurrence with Result-Of -'\necho ${stringZ/$(_123)/$(_simple)}  # Works as expected.\necho ${arrayZ[@]/ca/$(_simple)}     # Applied to each element.\necho ${sparseZ[@]/ca/$(_simple)}    # Works as expected.\n\necho\necho '- Replace all occurrences -'\necho ${stringZ//[b2]/X}             # X-out b's and 2's\necho ${stringZ//abc/xyz}            # xyzABC123ABCxyz\necho ${arrayZ[@]//abc/xyz}          # Applied to each element.\necho ${sparseZ[@]//abc/xyz}         # Works as expected.\n\necho\necho '- Delete all occurrences -'\necho ${stringZ//[b2]/}\necho ${stringZ//abc/}\necho ${arrayZ[@]//abc/}\necho ${sparseZ[@]//abc/}\n\necho\necho '- - Prefix sub-element replacement - -'\necho '- - Match must include the first character. - -'\necho\n\necho '- Replace prefix occurrences -'\necho ${stringZ/#[b2]/X}             # Unchanged (neither is a prefix).\necho ${stringZ/#$(_abc)/XYZ}        # XYZABC123ABCabc\necho ${arrayZ[@]/#abc/XYZ}          # Applied to each element.\necho ${sparseZ[@]/#abc/XYZ}         # Works as expected.\n\necho\necho '- Delete prefix occurrences -'\necho ${stringZ/#[b2]/}\necho ${stringZ/#$(_abc)/}\necho ${arrayZ[@]/#abc/}\necho ${sparseZ[@]/#abc/}\n\necho\necho '- - Suffix sub-element replacement - -'\necho '- - Match must include the last character. - -'\necho\n\necho '- Replace suffix occurrences -'\necho ${stringZ/%[b2]/X}             # Unchanged (neither is a suffix).\necho ${stringZ/%$(_abc)/XYZ}        # abcABC123ABCXYZ\necho ${arrayZ[@]/%abc/XYZ}          # Applied to each element.\necho ${sparseZ[@]/%abc/XYZ}         # Works as expected.\n\necho\necho '- Delete suffix occurrences -'\necho ${stringZ/%[b2]/}\necho ${stringZ/%$(_abc)/}\necho ${arrayZ[@]/%abc/}\necho ${sparseZ[@]/%abc/}\n\necho\necho '- - Special cases of null Glob-Pattern - -'\necho\n\necho '- Prefix all -'\n# null substring pattern means 'prefix'\necho ${stringZ/#/NEW}               # NEWabcABC123ABCabc\necho ${arrayZ[@]/#/NEW}             # Applied to each element.\necho ${sparseZ[@]/#/NEW}            # Applied to null-content also.\n                                    # That seems reasonable.\n\necho\necho '- Suffix all -'\n# null substring pattern means 'suffix'\necho ${stringZ/%/NEW}               # abcABC123ABCabcNEW\necho ${arrayZ[@]/%/NEW}             # Applied to each element.\necho ${sparseZ[@]/%/NEW}            # Applied to null-content also.\n                                    # That seems reasonable.\n\necho\necho '- - Special case For-Each Glob-Pattern - -'\necho '- - - - This is a nice-to-have dream - - - -'\necho\n\n_GenFunc() {\n    echo -n ${0}                    # Illustration only.\n    # Actually, that would be an arbitrary computation.\n}\n\n# All occurrences, matching the AnyThing pattern.\n# Currently //*/ does not match null-content nor null-reference.\n# /#/ and /%/ does match null-content but not null-reference.\necho ${sparseZ[@]//*/$(_GenFunc)}\n\n#  A possible syntax would be to make\n#+ the parameter notation used within this construct mean:\n#   ${1} - The full element\n#   ${2} - The prefix, if any, to the matched sub-element\n#   ${3} - The matched sub-element\n#   ${4} - The suffix, if any, to the matched sub-element\n#\n# echo ${sparseZ[@]//*/$(_GenFunc ${3})}   # Same as ${1} here.\n# Perhaps it will be implemented in a future version of Bash.\n\nexit 0\n```", "```sh #!/bin/bash\n#  test-execution-time.sh\n#  Example by Erik Brandsberg, for testing execution time\n#+ of certain operations.\n#  Referenced in the \"Optimizations\" section of \"Miscellany\" chapter.\n\ncount=50000\necho \"Math tests\"\necho \"Math via \\$(( ))\"\ntime for (( i=0; i< $count; i++))\ndo\n  result=$(( $i%2 ))\ndone\n\necho \"Math via *expr*:\"\ntime for (( i=0; i< $count; i++))\ndo\n  result=`expr \"$i%2\"`\ndone\n\necho \"Math via *let*:\"\ntime for (( i=0; i< $count; i++))\ndo\n  let result=$i%2\ndone\n\necho\necho \"Conditional testing tests\"\n\necho \"Test via case:\"\ntime for (( i=0; i< $count; i++))\ndo\n  case $(( $i%2 )) in\n    0) : ;;\n    1) : ;;\n  esac\ndone\n\necho \"Test with if [], no quotes:\"\ntime for (( i=0; i< $count; i++))\ndo\n  if [ $(( $i%2 )) = 0 ]; then\n     :\n  else\n     :\n  fi\ndone\n\necho \"Test with if [], quotes:\"\ntime for (( i=0; i< $count; i++))\ndo\n  if [ \"$(( $i%2 ))\" = \"0\" ]; then\n     :\n  else\n     :\n  fi\ndone\n\necho \"Test with if [], using -eq:\"\ntime for (( i=0; i< $count; i++))\ndo\n  if [ $(( $i%2 )) -eq 0 ]; then\n     :\n  else\n     :\n  fi\ndone\n\nexit $?\n```", "```sh #!/bin/bash\n#  assoc-arr-test.sh\n#  Benchmark test script to compare execution times of\n#  numeric-indexed array vs. associative array.\n#     Thank you, Erik Brandsberg.\n\ncount=100000       # May take a while for some of the tests below.\ndeclare simple     # Can change to 20000, if desired.\ndeclare -a array1\ndeclare -A array2\ndeclare -a array3\ndeclare -A array4\n\necho \"===Assignment tests===\"\necho\n\necho \"Assigning a simple variable:\"\n# References $i twice to equalize lookup times.\ntime for (( i=0; i< $count; i++)); do\n        simple=$i$i\ndone\n\necho \"---\"\n\necho \"Assigning a numeric index array entry:\"\ntime for (( i=0; i< $count; i++)); do\n        array1[$i]=$i\ndone\n\necho \"---\"\n\necho \"Overwriting a numeric index array entry:\"\ntime for (( i=0; i< $count; i++)); do\n        array1[$i]=$i\ndone\n\necho \"---\"\n\necho \"Linear reading of numeric index array:\"\ntime for (( i=0; i< $count; i++)); do\n        simple=array1[$i]\ndone\n\necho \"---\"\n\necho \"Assigning an associative array entry:\"\ntime for (( i=0; i< $count; i++)); do\n        array2[$i]=$i\ndone\n\necho \"---\"\n\necho \"Overwriting an associative array entry:\"\ntime for (( i=0; i< $count; i++)); do\n        array2[$i]=$i\ndone\n\necho \"---\"\n\necho \"Linear reading an associative array entry:\"\ntime for (( i=0; i< $count; i++)); do\n        simple=array2[$i]\ndone\n\necho \"---\"\n\necho \"Assigning a random number to a simple variable:\"\ntime for (( i=0; i< $count; i++)); do\n        simple=$RANDOM\ndone\n\necho \"---\"\n\necho \"Assign a sparse numeric index array entry randomly into 64k cells:\"\ntime for (( i=0; i< $count; i++)); do\n        array3[$RANDOM]=$i\ndone\n\necho \"---\"\n\necho \"Reading sparse numeric index array entry:\"\ntime for value in \"${array3[@]}\"i; do\n        simple=$value\ndone\n\necho \"---\"\n\necho \"Assigning a sparse associative array entry randomly into 64k cells:\"\ntime for (( i=0; i< $count; i++)); do\n        array4[$RANDOM]=$i\ndone\n\necho \"---\"\n\necho \"Reading sparse associative index array entry:\"\ntime for value in \"${array4[@]}\"; do\n        simple=$value\ndone\n\nexit $?\n```"]