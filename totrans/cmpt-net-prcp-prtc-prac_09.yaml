- en: Building a network#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建网络#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/networks/network.html](https://4ed.computer-networking.info/syllabus/default/networks/network.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://4ed.computer-networking.info/syllabus/default/networks/network.html](https://4ed.computer-networking.info/syllabus/default/networks/network.html)
- en: In the previous parts, we have explained how hosts operate while considering
    the network as a black box. In this part, we open the black box and describe how
    networks operate. The key layer for the operation of a network is the network
    layer illustrated in [Fig. 5](../hosts/introduction.html#fig-network-layer). The
    main objective of the network layer is to allow hosts, connected to different
    networks, to exchange information through intermediate systems called [router](../glossary.html#term-router).
    The unit of information in the network layer is called a [packet](../glossary.html#term-packet).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们已经解释了在将网络视为黑盒的情况下，主机是如何操作的。在本部分中，我们打开黑盒，描述网络是如何操作的。网络操作的关键层是图[图 5](../hosts/introduction.html#fig-network-layer)中展示的网络层。网络层的主要目标是允许连接到不同网络的主机通过称为[路由器](../glossary.html#term-router)的中间系统交换信息。网络层的信息单元称为[数据包](../glossary.html#term-packet)。
- en: Before explaining the operation of the network layer, it is useful to remember
    the characteristics of the service provided by the datalink layer. There are many
    variants of the datalink layer. Some provide a reliable service while others do
    not provide any guarantee of delivery. The reliable datalink layer services are
    popular in environments such as wireless networks where transmission errors are
    frequent. On the other hand, unreliable services are usually used when the physical
    layer provides an almost reliable service (i.e. only a negligible fraction of
    the frames are affected by transmission errors). Such almost reliable services
    are frequently used in wired and optical networks. In this chapter, we will assume
    that the datalink layer service provides an almost reliable service since this
    is both the most general one and also the most widely deployed one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释网络层的操作之前，记住数据链路层提供的服务特征是有用的。数据链路层有许多变体。一些提供可靠的服务，而另一些则不提供任何交付保证。可靠的链路层服务在无线网络等传输错误频繁的环境中很受欢迎。另一方面，当物理层提供几乎可靠的服务时（即只有极小一部分的帧受到传输错误的影响），通常使用不可靠的服务。这种几乎可靠的服务在有线和光纤网络中经常使用。在本章中，我们将假设数据链路层服务提供几乎可靠的服务，因为这是最一般的一种，也是部署最广泛的一种。
- en: '![Figure made with TikZ](../Images/dc19c34d49b1c14ad1e1c5f6a6f78cc3.png)'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/dc19c34d49b1c14ad1e1c5f6a6f78cc3.png)'
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 126 The point-to-point datalink layer
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 126 点对点数据链路层
- en: There are two main types of datalink layers. The simplest datalink layer is
    when there are only two communicating systems that are directly connected through
    the physical layer. Such a datalink layer is used when there is a point-to-point
    link between the two communicating systems. These two systems can be hosts or
    routers. PPP (Point-to-Point Protocol), defined in [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html),
    is an example of such a point-to-point datalink layer. Datalink layer entities
    exchange frames. A datalink [frame](../glossary.html#term-frame) sent by a datalink
    layer entity on the left is transmitted through the physical layer, so that it
    can reach the datalink layer entity on the right. Point-to-point datalink layers
    can either provide an unreliable service (frames can be corrupted or lost) or
    a reliable service (in this case, the datalink layer includes retransmission mechanisms).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层主要有两种类型。最简单的数据链路层是当只有两个直接通过物理层连接的通信系统时。这种数据链路层在两个通信系统之间存在点对点链路时使用。这两个系统可以是主机或路由器。PPP（点对点协议），在[**RFC
    1661**](https://datatracker.ietf.org/doc/html/rfc1661.html)中定义，是这种点对点数据链路层的例子。数据链路层实体交换帧。数据链路层实体发送的[帧](../glossary.html#term-frame)通过物理层传输，以便它能够到达右侧的数据链路层实体。点对点数据链路层可以提供不可靠的服务（帧可能被损坏或丢失）或可靠的服务（在这种情况下，数据链路层包括重传机制）。
- en: The second type of datalink layer is the one used in Local Area Networks (LAN).
    Conceptually, a LAN is a set of communicating devices such that any two devices
    can directly exchange frames through the datalink layer. Both hosts and routers
    can be connected to a LAN. Some LANs only connect a few devices, but there are
    LANs that can connect hundreds or even thousands of devices. In this chapter,
    we focus on the utilization of point-to-point datalink layers. We describe later
    the organization and the operation of Local Area Networks and their impact on
    the network layer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种数据链路层是用于局域网（LAN）的。从概念上讲，局域网是一组通信设备，其中任何两个设备都可以通过数据链路层直接交换帧。主机和路由器都可以连接到局域网。有些局域网只连接少量设备，但也有一些局域网可以连接数百甚至数千个设备。在本章中，我们重点关注点对点数据链路层的利用。我们将在后面描述局域网的组织和操作及其对网络层的影响。
- en: Even if we only consider the point-to-point datalink layers, there is an important
    characteristic of these layers that we cannot ignore. No datalink layer is able
    to send frames of unlimited size. Each datalink layer is characterized by a maximum
    frame size. There are more than dozen different datalink layers and unfortunately
    most of them use a different maximum frame size. This heterogeneity in the maximum
    frame sizes will cause problems when we will need to exchange data between hosts
    attached to different types of datalink layers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只考虑点对点数据链路层，这些层的一个重要特性我们也无法忽视。没有任何数据链路层能够发送无限大小的帧。每个数据链路层都有一个最大帧大小。有十几种不同的数据链路层，不幸的是，其中大多数使用不同的最大帧大小。这种最大帧大小的异质性在我们需要在不同类型的数据链路层连接的主机之间交换数据时会导致问题。
- en: As a first step, let us assume that we only need to exchange a small amount
    of data. In this case, there is no issue with the maximum length of the frames.
    However, there are other more interesting problems that we need to tackle. To
    understand these problems, let us consider the network represented in the figure
    [Fig. 127](#fig-net-3hosts-5routers).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们假设我们只需要交换少量数据。在这种情况下，帧的最大长度没有问题。然而，还有其他更有趣的问题需要我们解决。为了理解这些问题，让我们考虑图[图127](#fig-net-3hosts-5routers)中所示的网络。
- en: '![Figure made with TikZ](../Images/216416ec64aeca9b1fa48c3009b429db.png)'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/216416ec64aeca9b1fa48c3009b429db.png)'
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 127 A simple network containing three hosts and five routers
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图127 包含三个主机和五个路由器的简单网络
- en: This network contains two types of devices. The hosts, represented with circles
    and the routers, represented as boxes. A host is a device which is able to send
    and receive data for its own usage in contrast with routers that most of the time
    simply forward data towards their final destination. Routers have multiple links
    to neighboring routers or hosts. Hosts are usually attached via a single link
    to the network. Nowadays, with the growth of wireless networks, more and more
    hosts are equipped with several physical interfaces. These hosts are often called
    multihomed. Still, using several interfaces at the same time often leads to practical
    issues that are beyond the scope of this document. For this reason, we focus on
    single-homed hosts, i.e. hosts attached to a single network, in this e-book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该网络包含两种类型的设备。主机用圆圈表示，路由器用方框表示。主机是一种能够发送和接收数据以供自身使用的设备，与大多数时间只是简单地将数据转发到最终目的地的路由器形成对比。路由器与相邻的路由器或主机有多条链路。主机通常通过单个链路连接到网络。如今，随着无线网络的增长，越来越多的主机配备了多个物理接口。这些主机通常被称为多宿主。然而，同时使用多个接口往往会导致超出本文件范围的实际问题。因此，我们在这本电子书中专注于单宿主主机，即连接到单个网络的主机。
- en: To understand the key principles behind the operation of a network, let us analyze
    all the operations that need to be performed to allow host A in the above network
    to send one byte to host B. Thanks to the datalink layer used above the A-R1 link,
    host A can easily send a byte to router R1 inside a frame. However, upon reception
    of this frame, router R1 needs to understand that this byte is destined to host
    B and not to itself. This is the objective of the network layer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解网络操作背后的关键原则，让我们分析所有需要执行的操作，以便允许上述网络中的主机A向主机B发送一个字节。多亏了A-R1链路上使用的链路层，主机A可以轻松地将一个字节封装在帧中发送给路由器R1。然而，在接收到这个帧后，路由器R1需要理解这个字节是发送给主机B而不是给自己。这就是网络层的目标。
- en: The network layer enables the transmission of information between hosts that
    are not directly connected through intermediate routers. This transmission is
    carried out by putting the information to be transmitted inside a data structure
    which is called a packet. As a frame that contains useful data and control information,
    a packet also contains both data supplied by the user and control information.
    An important issue in the network layer is the ability to identify a node (host
    or router) inside the network. This identification is performed by associating
    an address to each node. An [address](../glossary.html#term-address) is usually
    represented as a sequence of bits. Most networks use fixed-length addresses. At
    this stage, let us simply assume that each of the nodes in the above network has
    an address which corresponds to the binary representation of its name on the figure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层使得在通过中间路由器不直接连接的主机之间传输信息成为可能。这种传输是通过将信息放入称为数据包的数据结构来实现的。作为一个包含有用数据和控制信息的数据帧，数据包同时包含用户提供的数据和控制信息。网络层的一个重要问题是能够识别网络内的一个节点（主机或路由器）。这种识别是通过将一个地址与每个节点关联来实现的。一个[地址](../glossary.html#term-address)通常表示为一串比特。大多数网络使用固定长度的地址。在这个阶段，我们只需假设上述网络中的每个节点都有一个地址，该地址对应于图上其名称的二进制表示。
- en: To send one byte of information to host B, host A needs to place this information
    inside a packet. In addition to the data being transmitted, the packet also contains
    either the addresses of the source and the destination nodes or information that
    indicates the path that needs to be followed to reach the destination.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要向主机B发送一个字节的信息，主机A需要将此信息放入一个数据包中。除了传输的数据外，数据包还包含源节点和目的节点的地址，或者指示到达目的地的路径的信息。
- en: 'There are two possible organizations for the network layer :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层有两种可能的组织形式：
- en: datagram
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据报
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: virtual circuits
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟电路
- en: The datagram organization[#](#the-datagram-organization "Link to this heading")
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据报组织[#](#the-datagram-organization "链接到本标题")
- en: 'The first and most popular organization of the network layer is the datagram
    organization. This organization is inspired by the organization of the postal
    service. Each host is identified by a network layer address. To send information
    to a remote host, a host creates a packet that contains:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层最常见和最受欢迎的组织形式是数据报组织。这种组织形式受到了邮政服务组织的启发。每个主机都有一个网络层地址。要向远程主机发送信息，主机创建一个包含以下内容的数据包：
- en: the network layer address of the destination host
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的主机的网络层地址
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: its own network layer address
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自己的网络层地址
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the information to be sent
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发送的信息
- en: To understand the datagram organization, let us consider [Fig. 128](#fig-simple-internetwork).
    A network layer address, represented by a letter, has been assigned to each host
    and router. To send some information to host J, host A creates a packet containing
    its own address, the destination address and the information to be exchanged.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解数据报组织，让我们考虑[图128](#fig-simple-internetwork)。每个主机和路由器都被分配了一个表示为字母的网络层地址。要向主机J发送一些信息，主机A创建一个包含其自己的地址、目的地址和要交换的信息的数据包。
- en: '![Figure made with TikZ](../Images/b17c456b68f70d26fa9339dd30edb066.png)'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/b17c456b68f70d26fa9339dd30edb066.png)'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 128 A simple internetwork
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图128 简单的互联网
- en: With the datagram organization, routers use hop-by-hop forwarding. This means
    that when a router receives a packet that is not destined to itself, it looks
    up the destination address of the packet in its forwarding table. A forwarding
    table is a data structure that maps each destination address (or set of destination
    addresses) to the outgoing interface over which a packet destined to this address
    must be forwarded to reach its final destination. The router consults its forwarding
    table to forward each packet that it handles.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据报组织，路由器使用逐跳转发。这意味着当路由器收到一个不是发送给它的数据包时，它会查找数据包的目的地址在其转发表中。转发表是一种数据结构，它将每个目的地址（或一组目的地址）映射到必须通过该接口转发的数据包，以便到达其最终目的地。路由器通过其转发表来转发它处理的每个数据包。
- en: The figure illustrates some possible forwarding tables in this network. By inspecting
    the forwarding tables of the different routers, one can find the path followed
    by packets sent from a source to a particular destination. In the example above,
    host A sends its packet to router R1. R1 consults its forwarding table and forwards
    the packet towards R2. Based on its own table, R2 decides to forward the packet
    to R5 that can deliver it to its destination. Thus, the path from A to J is A
    -> R1 -> R2 -> R5 -> J.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图形展示了该网络中一些可能的转发表。通过检查不同路由器的转发表，可以找到从源发送到特定目的地的数据包所遵循的路径。在上面的例子中，主机A将其数据包发送到路由器R1。R1查阅其转发表并将数据包转发到R2。根据其自己的表，R2决定将数据包转发到可以将其送达目的地的R5。因此，从A到J的路径是A
    -> R1 -> R2 -> R5 -> J。
- en: The computation of the forwarding tables of all the routers inside a network
    is a key element for the correct operation of the network. This computation can
    be carried out by using either distributed or centralized algorithms. These algorithms
    provide different performance, may lead to different types of paths, but their
    composition must lead to valid paths.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 计算网络内部所有路由器的转发表是网络正确运行的关键要素。此计算可以通过使用分布式或集中式算法来完成。这些算法提供不同的性能，可能导致不同类型的路径，但它们的组合必须导致有效的路径。
- en: In a network, a path can be defined as the list of all intermediate routers
    for a given source destination pair. For a given source/destination pair, the
    path can be derived by first consulting the forwarding table of the router attached
    to the source to determine the next router on the path towards the chosen destination.
    Then, the forwarding table of this router is queried for the same destination…
    The queries continue until the destination is reached. In a network that has valid
    forwarding tables, all the paths between all source/destination pairs contain
    a finite number of intermediate routers. However, if forwarding tables have not
    been correctly computed, two types of invalid paths can occur.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，路径可以定义为给定源/目的地址对的所有中间路由器的列表。对于给定的源/目的地址对，可以通过首先查阅连接到源的路由器的转发表，以确定所选目的地路径上的下一个路由器来推导路径。然后，查询此路由器的转发表以获取相同的目的地…查询会继续，直到到达目的地。在一个具有有效转发表的网络中，所有源/目的地址对之间的路径都包含有限数量的中间路由器。然而，如果转发表没有正确计算，可能会出现两种无效路径。
- en: A path may lead to a black hole. In a network, a black hole is a router that
    receives packets for at least one given source/destination pair but does not have
    an entry inside its forwarding table for this destination. Since it does not know
    how to reach the destination, the router cannot forward the received packets and
    must discard them. Any centralized or distributed algorithm that computes forwarding
    tables must ensure that there are not black holes inside the network.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一条路径可能通向一个黑洞。在网络中，黑洞是一个接收至少一对给定源/目的地址数据包但在此目的地址的转发表中没有条目的路由器。由于它不知道如何到达目的地，该路由器无法转发接收到的数据包，必须丢弃它们。任何计算转发表的集中式或分布式算法都必须确保网络内部没有黑洞。
- en: A second type of problem may exist in networks using the datagram organization.
    Consider a path that contains a cycle. For example, router R1 sends all packets
    towards destination D via router R2. Router R2 forwards these packets to router
    R3 and finally router R3’s forwarding table uses router R1 as its nexthop to reach
    destination D. In this case, if a packet destined to D is received by router R1,
    it will loop on the R1 -> R2 -> R3 -> R1 cycle and will never reach its final
    destination. As in the black hole case, the destination is not reachable from
    all sources in the network. In practice the loop problem is more annoying than
    the black hole problem because when a packet is caught in a forwarding loop, it
    unnecessarily consumes bandwidth. In the black hole case, the problematic packet
    is quickly discarded. We will see later that network layer protocols include techniques
    to minimize the impact of such forwarding loops.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据报组织的网络中，可能存在第二种类型的问题。考虑一个包含循环的路径。例如，路由器R1通过路由器R2将所有数据包发送到目的地D。路由器R2将这些数据包转发到路由器R3，最终路由器R3的转发表使用路由器R1作为其下一跳以到达目的地D。在这种情况下，如果目的地为D的数据包被路由器R1接收，它将在R1
    -> R2 -> R3 -> R1的循环中循环，并且永远不会到达其最终目的地。与黑洞情况一样，目的地不是从网络中的所有源可达的。在实践中，循环问题比黑洞问题更令人烦恼，因为当数据包陷入转发循环时，它会无谓地消耗带宽。在黑洞情况下，有问题的数据包会迅速被丢弃。我们将在后面看到，网络层协议包括减少此类转发循环影响的技术。
- en: Any solution which is used to compute the forwarding tables of a network must
    ensure that all destinations are reachable from any source. This implies that
    it must guarantee the absence of black holes and forwarding loops.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用于计算网络转发表的解决方案都必须确保所有目的地都可以从任何源到达。这意味着它必须保证不存在黑洞和转发环路。
- en: The forwarding tables and the precise format of the packets that are exchanged
    inside the network are part of the data plane of the network. This data plane
    contains all the protocols and algorithms that are used by hosts and routers to
    create and process the packets that contain user data. On high-end routers, the
    data plane is often implemented in hardware for performance reasons.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 转发表和网络内部交换的数据包的精确格式是网络数据平面的一部分。这个数据平面包含所有主机和路由器使用的协议和算法，用于创建和处理包含用户数据的数据包。在高端路由器上，出于性能原因，数据平面通常在硬件中实现。
- en: Besides the data plane, a network is also characterized by its control plane.
    The control plane includes all the protocols and algorithms (often distributed)
    that compute the forwarding tables that are installed on all routers inside the
    network. While there is only one possible data plane for a given networking technology,
    different networks using the same technology may use different control planes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据平面，网络还以其控制平面为特征。控制平面包括所有计算并安装在网络内部所有路由器上的转发表的协议和算法（通常是分布式的）。对于给定的网络技术，虽然只有一个可能的数据平面，但使用相同技术的不同网络可能使用不同的控制平面。
- en: The simplest control plane for a network is to manually compute the forwarding
    tables of all routers inside the network. This simple control plane is sufficient
    when the network is (very) small, usually up to a few routers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网络最简单的控制平面就是手动计算网络内部所有路由器的转发表。当网络（非常）小的时候，这种简单的控制平面是足够的，通常不超过几个路由器。
- en: In most networks, manual forwarding tables are not a solution for two reasons.
    First, most networks are too large to enable a manual computation of the forwarding
    tables. Second, with manually computed forwarding tables, it is very difficult
    to deal with link and router failures. Networks need to operate 24h a day, 365
    days per year. Many events can affect the routers and links that compose a network.
    Link failures are regular events in deployed networks. Links can fail for various
    reasons, including electromagnetic interference, fiber cuts, hardware or software
    problems on the terminating routers,… Some links also need to be either added
    to or removed from the network because their utilization is too low or their cost
    is too high.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网络中，手动转发表不是解决方案，原因有两个。首先，大多数网络太大，无法手动计算转发表。其次，使用手动计算的转发表，处理链路和路由器故障非常困难。网络需要每天24小时，每年365天运行。许多事件都可能影响构成网络的链路和路由器。链路故障是部署网络中的常规事件。链路可能因为各种原因而失效，包括电磁干扰、光纤切割、终止路由器上的硬件或软件问题，……有些链路可能需要添加到网络中或从网络中移除，因为它们的利用率太低或成本太高。
- en: Similarly, routers also fail. There are two types of failures that affect routers.
    A router may stop forwarding packets due to hardware or software problems (e.g.,
    due to a crash of its operating system). A router may also need to be halted from
    time to time (e.g., to upgrade its operating system or to install new interface
    cards). These planned and unplanned events affect the set of links and routers
    that can be used to forward packets in the network. Still, most network users
    expect that their network will continue to correctly forward packets despite all
    these events. With manually computed forwarding tables, it is usually impossible
    to pre-compute the forwarding tables while taking into account all possible failure
    scenarios.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，路由器也可能出现故障。影响路由器的有两种类型的故障。路由器可能因为硬件或软件问题（例如，由于操作系统的崩溃）而停止转发数据包。路由器也可能需要不时地停止运行（例如，升级其操作系统或安装新的接口卡）。这些计划和未计划的意外事件会影响可以用于在网络中转发数据包的链路和路由器的集合。尽管如此，大多数网络用户期望尽管所有这些事件，他们的网络仍然能够正确地转发数据包。使用手动计算的转发表，通常无法预先计算转发表，同时考虑到所有可能的故障场景。
- en: An alternative to manually computed forwarding tables is to use a network management
    platform that tracks the network status and can push new forwarding tables on
    the routers when it detects any modification to the network topology. This solution
    gives some flexibility to the network managers in computing the paths inside their
    network. However, this solution only works if the network management platform
    is always capable of reaching all routers even when the network topology changes.
    This may require a dedicated network that allows the management platform to push
    information on the forwarding tables. Openflow is a modern example of such solutions
    [[MAB2008]](../bibliography.html#mab2008). In a nutshell, Openflow is a protocol
    that enables a network controller to install specific entries in the forwarding
    tables of remote routers and much more.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 手动计算转发表的替代方案是使用一个网络管理平台，该平台跟踪网络状态，并在检测到网络拓扑有任何修改时，能够将新的转发表推送到路由器。这种解决方案为网络管理员在计算其网络内部路径时提供了一定的灵活性。然而，这种解决方案仅在网络管理平台始终能够到达所有路由器，即使网络拓扑发生变化时也能工作。这可能需要一个专用网络，以便管理平台能够推送转发表信息。Openflow是此类解决方案的现代例子[[MAB2008]](../bibliography.html#mab2008)。简而言之，Openflow是一种协议，它使网络控制器能够安装远程路由器转发表中的特定条目，以及更多功能。
- en: Another interesting point that is worth being discussed is when the forwarding
    tables are computed. A widely used solution is to compute the entries of the forwarding
    tables for all destinations on all routers. This ensures that each router has
    a valid route towards each destination. These entries can be updated when an event
    occurs and the network topology changes. A drawback of this approach is that the
    forwarding tables can become large in large networks since each router must always
    maintain one entry for each destination inside its forwarding table.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得讨论的有趣点是转发表的计算时机。一种广泛使用的解决方案是为所有路由器上的所有目的地计算转发表的条目。这确保了每个路由器都有通往每个目的地的有效路由。当发生事件且网络拓扑发生变化时，这些条目可以更新。这种方法的缺点是，在大规模网络中，转发表可能会变得很大，因为每个路由器必须始终在其转发表中为每个目的地维护一个条目。
- en: Some networks use the arrival of packets as the trigger to compute the corresponding
    entries in the forwarding tables. Several technologies have been built upon this
    principle. When a packet arrives, the router consults its forwarding table to
    find a path towards the destination. If the destination is present in the forwarding
    table, the packet is forwarded. Otherwise, the router needs to find a way to forward
    the packet and update its forwarding table.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络使用数据包到达作为计算转发表中相应条目的触发器。基于此原理已经开发出多种技术。当数据包到达时，路由器会查阅其转发表以找到通往目的地的路径。如果目的地存在于转发表中，则转发数据包。否则，路由器需要找到转发数据包的方法并更新其转发表。
- en: Computing forwarding tables[#](#computing-forwarding-tables "Link to this heading")
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算转发表[#](#computing-forwarding-tables "链接到本标题")
- en: Networks deployed several techniques to update the forwarding tables upon the
    arrival of a packet. In this section, we briefly present the principles that underlie
    three of these techniques.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 部署网络时采用了多种技术来在数据包到达时更新转发表。在本节中，我们将简要介绍这三种技术背后的原理。
- en: The first technique assumes that the underlying network topology is a tree.
    A tree is the simplest network to be considered when forwarding packets. The main
    advantage of using a tree is that there is only one path between any pair of nodes
    inside the network. Since a tree does not contain any cycle, it is impossible
    to have forwarding loops in a tree-shaped network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术假设底层网络拓扑是一个树。在转发数据包时，树是最简单的网络结构。使用树的主要优势是网络中任意两个节点之间只有一条路径。由于树不包含任何循环，因此在树形网络中不可能出现转发环路。
- en: In a tree-shaped network, it is relatively simple for each node to automatically
    compute its forwarding table by inspecting the packets that it receives. For this,
    each node uses the source and destination addresses present inside each packet.
    Thanks to the source address, a node can learn the location of the different sources
    inside the network. Each source has a unique address. When a node receives a packet
    over a given interface, it learns that the source (address) of this packet is
    reachable via this interface. The node maintains a data structure that maps each
    known source address to an incoming interface. This data structure is often called
    the port-address table since it indicates the interface (or port) to reach a given
    address.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在树形网络中，每个节点通过检查它接收到的数据包自动计算其转发表相对简单。为此，每个节点使用每个数据包中存在的源和目的地地址。多亏了源地址，一个节点可以学习网络中不同源的位置。每个源都有一个唯一的地址。当一个节点通过某个接口收到一个数据包时，它了解到这个数据包的源（地址）可以通过这个接口访问。节点维护一个将每个已知源地址映射到入接口的数据结构。这个数据结构通常被称为端口地址表，因为它指示了到达给定地址的接口（或端口）。
- en: Learning the location of the sources is not sufficient, nodes also need to forward
    packets towards their destination. When a node receives a packet whose destination
    address is already present inside its port-address table, it simply forwards the
    packet on the interface listed in the port-address table. In this case, the packet
    will follow the port-address table entries in the downstream nodes and will reach
    the destination. If the destination address is not included in the port-address
    table, the node simply forwards the packet on all its interfaces, except the interface
    from which the packet was received. Forwarding a packet over all interfaces is
    usually called broadcasting in the terminology of computer networks. Sending the
    packet over all interfaces except one is a costly operation since the packet is
    sent over links that do not reach the destination. Given the tree-shape of the
    network, the packet will explore all downstream branches of the tree and will
    finally reach its destination. In practice, the broadcasting operation does not
    occur too often and its performance impact remains limited.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 仅学习源的位置是不够的，节点还需要将数据包转发到它们的目的地。当一个节点收到一个其目的地地址已经存在于其端口地址表中的数据包时，它只需将数据包转发到端口地址表中列出的接口。在这种情况下，数据包将遵循下游节点中的端口地址表条目，并到达目的地。如果目的地地址未包含在端口地址表中，节点只需将其数据包转发到所有接口，除了接收数据包的接口。在计算机网络术语中，将数据包转发到所有接口通常称为广播。将数据包发送到除一个接口之外的所有接口是一种昂贵的操作，因为数据包是通过无法到达目的地的链路发送的。鉴于网络的树形结构，数据包将探索树的所有下游分支，并最终到达目的地。在实践中，广播操作并不太常见，其性能影响仍然有限。
- en: 'To understand the operation of the port-address table, let us consider the
    example network shown in [Fig. 129](#fig-simple-tree-network). This network contains
    three hosts: A, B and C and five routers, R1 to R5. When the network boots, all
    the forwarding tables of the nodes are empty.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解端口地址表的操作，让我们考虑图 [129](#fig-simple-tree-network) 中所示的示例网络。这个网络包含三个主机：A、B
    和 C 以及五个路由器，R1 到 R5。当网络启动时，所有节点的转发表都是空的。
- en: '![Figure made with TikZ](../Images/d7769586ddea01abce95ea2ac91eaad6.png)'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/d7769586ddea01abce95ea2ac91eaad6.png)'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 129 A simple tree-shaped network
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 129 一个简单的树形网络
- en: Host A sends a packet towards B. When receiving this packet, R1 learns that
    A is reachable via its West interface. Since it does not have an entry for destination
    B in its port-address table, it forwards the packet to both R2 and R3. When R2
    receives the packet, it updates its own forwarding table and forward the packet
    to C. Since C is not the intended recipient, it simply discards the received packet.
    Router R3 also receives the packet. It learns that A is reachable via its North-West
    interface and broadcasts the packet to R4 and R5. R5 also updates its forwarding
    table and finally forwards it to destination B. Let us now consider what happens
    when B sends a reply to A. R5 first learns that B is attached to its North-East
    port. It then consults its port-address table and finds that A is reachable via
    its North-West interface. The packet is then forwarded hop-by-hop to A without
    any broadcasting. Later on, if C sends a packet to B, this packet will reach R1
    that contains a valid forwarding entry in its forwarding table.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 主机A向B发送一个数据包。当收到这个数据包时，R1了解到A可以通过其西接口到达。由于它在端口地址表中没有为目的地B的条目，它将数据包转发给R2和R3。当R2收到数据包时，它更新自己的转发表并将数据包转发给C。由于C不是预期的接收者，它简单地丢弃了接收到的数据包。路由器R3也收到了数据包。它了解到A可以通过其西北接口到达，并将数据包广播到R4和R5。R5也更新了其转发表，并最终将其转发到目的地B。现在让我们考虑当B向A发送回复时会发生什么。R5首先了解到B连接到其东北端口。然后它查阅其端口地址表，发现A可以通过其西北接口到达。然后数据包逐跳转发到A，没有任何广播。稍后，如果C向B发送一个数据包，这个数据包将到达包含有效转发条目的R1。
- en: By inspecting the source and destination addresses of packets, network nodes
    can automatically derive their forwarding tables. As we will discuss later, this
    technique is used in [Ethernet](../glossary.html#term-Ethernet) networks. Despite
    being widely used, it has two important drawbacks. First, packets sent to unknown
    destinations must be broadcasted in the network even if the destination is not
    attached to the network. Consider the transmission of ten packets destined to
    Z in the network above. When a node receives a packet towards this destination,
    it can only broadcast that packet. Since Z is not attached to the network, no
    node will ever receive a packet whose source is Z to update its forwarding table.
    The second and more important problem is that few networks have a tree-shaped
    topology. It is interesting to analyze what happens when a port-address table
    is used in a network that contains a cycle. Consider the simple network shown
    in [Fig. 130](#fig-simple-redundant-network) with a single host.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查数据包的源地址和目的地址，网络节点可以自动推导出它们的转发表。正如我们稍后将要讨论的，这种技术在[以太网](../glossary.html#term-Ethernet)网络中被使用。尽管这种技术被广泛使用，但它有两个重要的缺点。首先，发送到未知目的地的数据包即使在目的地未连接到网络的情况下也必须在网络中广播。考虑上面网络中发送到Z的十个数据包的传输。当一个节点收到指向该目的地的数据包时，它只能广播该数据包。由于Z未连接到网络，没有任何节点会收到源地址为Z的数据包来更新其转发表。第二个且更为重要的问题是，很少有网络具有树形拓扑结构。分析在包含环路的网络中使用端口地址表时发生的情况是很有趣的。考虑图[130](#fig-simple-redundant-network)中显示的简单且冗余的网络。
- en: '![Figure made with TikZ](../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png)'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png)'
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 130 A simple and redundant network
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图130 简单且冗余的网络
- en: Assume that the network has started and all port-address and forwarding tables
    are empty. Host A sends a packet towards B. Upon reception of this packet, R1
    updates its port-address table. Since B is not present in the port-address table,
    the packet is broadcasted. Both R2 and R3 receive a copy of the packet sent by
    A. They both update their port-address table. Unfortunately, they also both broadcast
    the received packet. B receives a first copy of the packet, but R3 and R2 receive
    it again. R3 will then broadcast this copy of the packet to B and R1 while R2
    will broadcast its copy to R1. Although B has already received two copies of the
    packet, it is still inside the network and continues to loop. Due to the presence
    of the cycle, a single packet towards an unknown destination generates many copies
    of this packet that loop and will eventually saturate the network. Network operators
    who are using port-address tables to automatically compute the forwarding tables
    also use distributed algorithms to ensure that the network topology is always
    a tree.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设网络已经开始运行，并且所有端口地址和转发表都是空的。主机 A 向 B 发送一个数据包。当收到这个数据包时，R1 更新其端口地址表。由于 B 不在端口地址表中，该数据包被广播。R2
    和 R3 都收到了 A 发送的数据包副本。它们都更新了它们的端口地址表。不幸的是，它们也同时广播了接收到的数据包。B 收到了数据包的第一个副本，但 R3 和
    R2 又收到了它。然后 R3 将这个数据包副本广播给 B 和 R1，而 R2 将其副本广播给 R1。尽管 B 已经收到了两个数据包副本，但它仍然在网络中，并继续循环。由于存在循环，一个未知目标的数据包会产生许多循环的数据包副本，最终会饱和网络。使用端口地址表来自动计算转发表的网络操作员也使用分布式算法来确保网络拓扑始终是树形结构。
- en: 'Another technique called source routing can be used to automatically compute
    forwarding tables. It has been used in interconnecting Token Ring networks and
    in some wireless networks. Intuitively, source routing enables a destination to
    automatically discover the paths from a given source towards itself. This technique
    requires nodes to encode information inside some packets. For simplicity, let
    us assume that the data plane supports two types of packets :'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种称为源路由的技术可以用来自动计算转发表。它已被用于连接令牌环网络和某些无线网络。直观地说，源路由允许目标自动发现从给定源到自身的路径。这种技术要求节点在数据包中编码信息。为了简单起见，让我们假设数据平面支持两种类型的数据包：
- en: the data packets
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the control packets
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制包
- en: Data packets are used to exchange data while control packets are used to discover
    the paths between hosts. With source routing, routers can be kept as simple as
    possible and all the complexity is placed on the hosts. This is in contrast with
    the previous technique where the nodes had to maintain a port-address and a forwarding
    table while the hosts simply sent and received packets. Each node is configured
    with one unique address and there is one identifier per outgoing link. For simplicity
    and to avoid cluttering the figures with those identifiers, we assume that each
    node uses as link identifiers north, west, south,… In practice, a node would associate
    one integer to each outgoing link. This is illustrated in [Fig. 131](#fig-simple-2hosts-4routers).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包用于交换数据，而控制包用于发现主机之间的路径。使用源路由，可以将路由器保持得尽可能简单，并将所有复杂性放在主机上。这与先前的技术形成对比，其中节点必须维护端口地址表和转发表，而主机只是发送和接收数据包。每个节点配置了一个唯一的地址，每个出链路都有一个标识符。为了简单起见，避免在图中添加这些标识符，我们假设每个节点使用北、西、南等作为链路标识符。在实际中，节点会将一个整数与每个出链路关联。这如图
    [图 131](#fig-simple-2hosts-4routers) 所示。
- en: '![Figure made with TikZ](../Images/4bdec978a60e773b93a0a4c896847066.png)'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/4bdec978a60e773b93a0a4c896847066.png)'
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 131 A simple network with two hosts and four routers
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 131 一个包含两个主机和四个路由器的简单网络
- en: In the network above, router R2 is attached to two outgoing links. R2 is connected
    to both R1 and R3. R2 can easily determine that it is connected to these two nodes
    by exchanging packets with them or observing the packets that it receives over
    each interface. Assume for example that when a node (either host or router) starts,
    it sends a special control packet over each of its interfaces to advertise its
    own address to its neighbors. When a node receives such a packet, it automatically
    replies with its own address. This exchange can also be used to verify whether
    a neighbor, either router or host, is still alive. With source routing, the data
    plane packets include a list of identifiers. This list is called a source route.
    It indicates the path to be followed by the packet as a sequence of link identifiers.
    When a node receives such a data plane packet, it first checks whether the packet’s
    destination is a direct neighbor. In this case, the packet is forwarded to this
    neighbor. Otherwise, the node extracts the next address from the list and forwards
    it to the neighbor. This allows the source to specify the explicit path to be
    followed for each packet. For example, in the figure above there are two possible
    paths between A and B. To use the path via R2, A would send a packet that contains
    R1,R2,R3 as source route. To avoid going via R2, A would place R1,R3 as the source
    route in its transmitted packet. If A knows the complete network topology and
    all link identifiers, it can easily compute the source route towards each destination.
    It can even use different paths, e.g. for redundancy, to reach a given destination.
    However, in a real network hosts do not usually have a map of the entire network
    topology.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述网络中，路由器R2连接了两个出链路。R2与R1和R3都相连。R2可以通过与它们交换数据包或观察每个接口接收到的数据包来轻松确定自己连接到这两个节点。例如，当一个节点（无论是主机还是路由器）启动时，它会通过每个接口发送一个特殊的控制数据包来向邻居通告自己的地址。当一个节点收到这样的数据包时，它会自动回复自己的地址。这种交换也可以用来验证邻居（无论是路由器还是主机）是否仍然存活。在源路由中，数据平面数据包包含一个标识符列表。这个列表被称为源路由，它指示数据包应遵循的路径，即一系列链路标识符。当一个节点收到这样的数据平面数据包时，它首先检查数据包的目的地是否是直接邻居。在这种情况下，数据包被转发到这个邻居。否则，节点从列表中提取下一个地址并将其转发给邻居。这允许源节点为每个数据包指定要遵循的显式路径。例如，在上面的图中，A和B之间存在两条可能的路径。要使用通过R2的路径，A会发送一个包含R1、R2、R3作为源路由的数据包。要避免通过R2，A会在其传输的数据包中将R1、R3作为源路由。如果A知道完整的网络拓扑和所有链路标识符，它可以轻松地计算到每个目的地的源路由。它甚至可以使用不同的路径，例如为了冗余，到达给定的目的地。然而，在现实网络中，主机通常不会拥有整个网络拓扑的映射。
- en: In networks that rely on source routing, hosts use control packets to automatically
    discover the best path(s). In addition to the source and destination addresses,
    control packets contain a list that records the intermediate nodes. This list
    is often called the record route because it allows recording the route followed
    by a given packet. When a node receives such a control packet, it first checks
    whether its address is included in the record route. If yes, the packet has already
    been forwarded by this node and it is silently discarded. Otherwise, it adds its
    own address to the record route and forwards the packet to all its interfaces,
    except the interface over which the packet has been received. Thanks to this,
    the control packet can explore all paths between a source and a given destination.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖于源路由的网络中，主机使用控制数据包来自动发现最佳路径。除了源地址和目的地址外，控制数据包还包含一个列表，记录中间节点。这个列表通常被称为记录路由，因为它允许记录给定数据包遵循的路径。当一个节点收到这样的控制数据包时，它首先检查自己的地址是否包含在记录路由中。如果是，则表示数据包已经被这个节点转发，并且它会被静默丢弃。否则，它会将自己的地址添加到记录路由中，并将数据包转发到所有接口，除了接收数据包的接口。因此，控制数据包可以探索源节点和给定目的地之间的所有路径。
- en: For example, consider again the network topology above. A sends a control packet
    towards B. The initial record route is empty. When R1 receives the packet, it
    adds its own address to the record route and forwards a copy to R2 and another
    to R3. R2 receives the packet, adds itself to the record route and forwards it
    to R3. R3 receives two copies of the packet. The first contains the [R1,R2] record
    route and the second [R1]. In the end, B will receive two control packets containing
    [R1,R2,R3,R4] and [R1,R3,R4] as record routes. B can keep these two paths or select
    the best one and discard the second. A popular heuristic is to select the record
    route of the first received packet as being the best one since this likely corresponds
    to the shortest delay path.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，再次考虑上面的网络拓扑。A向B发送一个控制包。初始记录路由为空。当R1接收到数据包时，它将自己的地址添加到记录路由中，并将一个副本转发给R2，另一个转发给R3。R2接收到数据包，将其自身添加到记录路由中，并将其转发给R3。R3接收到两个数据包副本。第一个包含[R1,R2]记录路由，第二个包含[R1]。最终，B将接收到包含[R1,R2,R3,R4]和[R1,R3,R4]作为记录路由的两个控制包。B可以保留这两条路径或选择其中最好的一条并丢弃第二条。一种流行的启发式方法是选择第一个接收到的记录路由作为最佳路径，因为这很可能对应于最短延迟路径。
- en: With the received record route, B can send a data packet to A. For this, it
    simply reverses the chosen record route. However, we still need to communicate
    the chosen path to A. This can be done by putting the record route inside a control
    packet which is sent back to A over the reverse path. An alternative is to simply
    send a data packet back to A. This packet will travel back to A. To allow A to
    inspect the entire path followed by the data packet, its source route must contain
    all intermediate routers when it is received by A. This can be achieved by encoding
    the source route using a data structure that contains an index and the ordered
    list of node addresses. The index always points to the next address in the source
    route. It is initialized at 0 when a packet is created and incremented by each
    intermediate node.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接收到的记录路由，B可以向A发送一个数据包。为此，它只需简单地反转所选的记录路由。然而，我们仍然需要将所选路径传达给A。这可以通过将记录路由放入一个控制包中来实现，该控制包通过反向路径发送回A。另一种方法是简单地发送一个数据包回A。这个数据包将返回到A。为了允许A检查数据包所经过的整个路径，其源路由必须在A接收到时包含所有中间路由器。这可以通过使用包含索引和节点地址有序列表的数据结构来编码源路由来实现。索引始终指向源路由中的下一个地址。当创建数据包时，它初始化为0，并且每个中间节点递增。
- en: The third technique to compute forwarding tables is to rely on a control plane
    using a distributed algorithm. Routers exchange control messages to discover the
    network topology and build their forwarding table based on them. We dedicate a
    more detailed description of such distributed algorithms later in this section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 计算转发表的第三种技术是依赖于使用分布式算法的控制平面。路由器交换控制消息以发现网络拓扑并根据它们构建它们的转发表。我们将在本节稍后更详细地描述此类分布式算法。
- en: Flat or hierarchical addresses[#](#flat-or-hierarchical-addresses "Link to this
    heading")
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面或分层地址[#](#flat-or-hierarchical-addresses "链接到本标题")
- en: The last, but important, point to discuss about the data plane of the networks
    that rely on the datagram mode is their addressing scheme. In the examples above,
    we have used letters to represent the addresses of the hosts and network nodes.
    In practice, all addresses are encoded as a bit string. Most network technologies
    use a fixed size bit string to represent source and destination address. These
    addresses can be organized in two different ways.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，关于依赖于数据报模式的网络的数据平面的讨论点是它们的寻址方案。在上面的例子中，我们使用字母来表示主机和网络节点的地址。在实践中，所有地址都被编码为一个位串。大多数网络技术使用固定大小的位串来表示源地址和目的地址。这些地址可以以两种不同的方式组织。
- en: The first organization, which is the one that we have implicitly assumed until
    now, is the flat addressing scheme. Under this scheme, each host and network node
    has a unique address. The unicity of the addresses is important for the operation
    of the network. If two hosts have the same address, it can become difficult for
    the network to forward packets towards this destination. Flat addresses are typically
    used in situations where network nodes and hosts need to be able to communicate
    immediately with unique addresses. These flat addresses are often embedded inside
    the network interface cards. The network card manufacturer creates one unique
    address for each interface and this address is stored in the read-only memory
    of the interface. An advantage of this addressing scheme is that it easily supports
    unstructured and mobile networks. When a host moves, it can attach to another
    network and remain confident that its address is unique and enables it to communicate
    inside the new network.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组织，即我们直到现在都隐含假设的组织，是平面寻址方案。在这种方案下，每个主机和网络节点都有一个唯一的地址。地址的唯一性对于网络的运行非常重要。如果两个主机有相同的地址，网络转发数据包到该目的地可能会变得困难。平面地址通常用于网络节点和主机需要能够通过唯一地址立即通信的情况。这些平面地址通常嵌入在网络接口卡中。网络卡制造商为每个接口创建一个唯一的地址，并将该地址存储在接口的只读存储器中。这种寻址方案的一个优点是它很容易支持无结构和移动网络。当主机移动时，它可以连接到另一个网络，并确信其地址是唯一的，并且它能够在新网络中进行通信。
- en: With flat addressing the lookup operation in the forwarding table can be implemented
    as an exact match. The forwarding table contains the (sorted) list of all known
    destination addresses. When a packet arrives, a network node only needs to check
    whether this address is included in the forwarding table or not. In software,
    this is an O(log(n)) operation if the list is sorted. In hardware, Content Addressable
    Memories can efficiently perform this lookup operation, but their size is usually
    limited.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平面寻址，转发表中的查找操作可以实施为精确匹配。转发表包含所有已知目标地址的（排序）列表。当一个数据包到达时，网络节点只需检查此地址是否包含在转发表中。如果列表已排序，在软件中这是一个O(log(n))的操作。在硬件中，内容可寻址存储器可以有效地执行此查找操作，但它们的大小通常有限。
- en: A drawback of the flat addressing scheme is that the forwarding tables linearly
    grow with the number of devices in the network. This addressing scheme is notably
    used by Ethernet networks described in chapter [Ethernet](lan.html#chapter-ethernet).
    With this addressing scheme, each forwarding table must contain an entry that
    points to every address reachable inside the network. Since large networks can
    contain tens of millions of hosts or more, this is a major problem on routers
    that need to be able to quickly forward packets. As an illustration, it is interesting
    to consider the case of an interface running at 10 Gbps. Such interfaces are found
    on high-end servers and in various routers today. Assuming a packet size of 1000
    bits, a conservative number, such interface must forward ten million packets every
    second. This implies that a router that receives packets over such a link must
    forward one 1000 bits packet every 100 nanoseconds. This is the same order of
    magnitude as the memory access times of old DRAMs. This delay decreases when packets
    are smaller or as links become faster. High-end routers today support 400 Gbps
    or 800 Gbps line cards.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 平面寻址方案的缺点是，随着网络中设备数量的线性增长，转发表也会线性增长。这种寻址方案在[以太网](lan.html#chapter-ethernet)章节中描述的以太网网络中被特别使用。在这种寻址方案下，每个转发表必须包含一个指向网络内部可到达的每个地址的条目。由于大型网络可以包含数千万甚至更多的主机，这在需要能够快速转发数据包的路由器上是一个主要问题。作为一个例子，考虑一个以10
    Gbps运行的接口是有趣的。这样的接口现在可以在高端服务器和各种路由器上找到。假设数据包大小为1000位，这是一个保守的数字，这样的接口每秒必须转发一千万个数据包。这意味着接收此类链路上的数据包的路由器必须每100纳秒转发一个1000位的数据包。这与旧DRAM的内存访问时间在同一数量级。当数据包更小或链路更快时，这种延迟会降低。今天的高端路由器支持400
    Gbps或800 Gbps的线路卡。
- en: A widely used alternative to the flat addressing scheme is the hierarchical
    addressing scheme. This addressing scheme builds upon the fact that networks usually
    contain much more hosts than routers. In this case, a first solution to reduce
    the size of the forwarding tables is to create a hierarchy of addresses. This
    is the solution chosen by the post office since postal addresses contain a country,
    sometimes a state or province, a city, a street and finally a street number. When
    an envelope is forwarded by a post office in a remote country, it only looks at
    the destination country, while a post office in the same province will look at
    the city information. Only the post office responsible for a given city will look
    at the street name and only the postman will use the street number. Hierarchical
    addresses provide a similar solution for network addresses. For example, the address
    of an Internet host attached to a campus network could contain in the high-order
    bits an identification of the Internet Service Provider (ISP) that serves the
    campus network. Then, a subsequent block of bits identifies the campus network
    which is one of the customers of the ISP. Finally, the low order bits of the address
    identify the host in the campus network. Both IPv4 and IPv6 use hierarchical addresses.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛使用的平面寻址方案的替代方案是分层寻址方案。这种寻址方案基于这样一个事实：网络通常包含比路由器多得多的主机。在这种情况下，减少转发表大小的第一个解决方案是创建地址层次结构。这是邮局所选择的解决方案，因为邮政地址包含国家、有时是州或省、城市、街道，最后是街道号码。当一个信封被一个遥远国家的邮局转发时，它只查看目的地国家，而同一省份的邮局将查看城市信息。只有负责特定城市的邮局会查看街道名称，而只有邮递员会使用街道号码。分层地址为网络地址提供了类似的解决方案。例如，连接到校园网络的互联网主机的地址可以在高阶位中包含为该校园网络服务的互联网服务提供商（ISP）的标识。然后，随后的位块标识了校园网络，这是ISP的众多客户之一。最后，地址的低阶位标识了校园网络中的主机。IPv4和IPv6都使用分层地址。
- en: This hierarchical allocation of addresses can be applied in any type of network.
    In practice, the allocation of the addresses must follow the network topology.
    Usually, this is achieved by dividing the addressing space in consecutive blocks
    and then allocating these blocks to different parts of the network. In a small
    network, the simplest solution is to allocate one block of addresses to each network
    node and assign the host addresses from the attached node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种地址的分层分配可以应用于任何类型的网络。在实践中，地址的分配必须遵循网络拓扑。通常，这是通过将寻址空间划分为连续的块，然后将这些块分配给网络的不同部分来实现的。在一个小型网络中，最简单的解决方案是将一个地址块分配给每个网络节点，并从连接的节点分配主机地址。
- en: '![Figure made with TikZ](../Images/4bdec978a60e773b93a0a4c896847066.png)'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/4bdec978a60e773b93a0a4c896847066.png)'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 132 A simple network with two hosts and four routers
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 132 一个包含两个主机和四个路由器的简单网络
- en: In figure [Fig. 132](#fig-net-2hosts-4routers), assume that the network uses
    16 bits addresses and that the prefix 01001010 has been assigned to the entire
    network. Since the network contains four routers, the network operator could assign
    one block of sixty-four addresses to each router. R1 would use address 0100101000000000
    while A could use address 0100101000000001. R2 could be assigned all addresses
    from 0100101001000000 to 0100101001111111. R4 could then use 0100101011000000
    and assign 0100101011000001 to B. Other allocation schemes are possible. For example,
    R3 could be allocated a larger block of addresses than R2 and R4 could use a sub-block
    from R3 ‘s address block.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [图 132](#fig-net-2hosts-4routers) 中，假设网络使用 16 位地址，并且前缀 01001010 已分配给整个网络。由于网络包含四个路由器，网络运营商可以为每个路由器分配一个包含
    64 个地址的块。R1 将使用地址 0100101000000000，而 A 可以使用地址 0100101000000001。R2 可以分配从 0100101001000000
    到 0100101001111111 的所有地址。然后，R4 可以使用 0100101011000000 并将 0100101011000001 分配给 B。其他分配方案也是可能的。例如，R3
    可以分配比 R2 和 R4 更大的地址块，而 R4 可以使用 R3 地址块的一个子块。
- en: The main advantage of hierarchical addresses is that it is possible to significantly
    reduce the size of the forwarding tables. In many networks, the number of routers
    can be several orders of magnitude smaller than the number of hosts. A campus
    network may contain a dozen routers and thousands of hosts. The largest Internet
    Services Providers typically contain no more than a few tens of thousands of routers
    but still serve tens or hundreds of millions of hosts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分层地址的主要优点是，可以显著减少转发表的大小。在许多网络中，路由器的数量可以比主机数量小几个数量级。一个校园网络可能包含十几个路由器和数千个主机。最大的互联网服务提供商通常不超过几万个路由器，但仍为数千或数亿个主机提供服务。
- en: Despite their popularity, hierarchical addresses have some drawbacks. Their
    first drawback is that a lookup in the forwarding table is more complex than when
    using flat addresses. For example, on the Internet, network nodes have to perform
    a longest-match to forward each packet. This is partially compensated by the reduction
    in the size of the forwarding tables, but the additional complexity of the lookup
    operation has been a difficulty to implement hardware support for packet forwarding.
    A second drawback of the utilization of hierarchical addresses is that when a
    host connects for the first time to a network, it must contact one router to determine
    its own address. This requires some packet exchanges between the host and some
    routers. Furthermore, if a host moves and is attached to another routers, its
    network address will change. This can be an issue with some mobile hosts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分层地址很受欢迎，但它们也有一些缺点。它们的首要缺点是，在转发表中查找比使用平面地址更复杂。例如，在互联网上，网络节点必须执行最长匹配来转发每个数据包。这通过减少转发表的大小部分得到补偿，但查找操作的额外复杂性一直是实现硬件支持数据包转发的难题。分层地址使用的第二个缺点是，当主机首次连接到网络时，它必须联系一个路由器以确定自己的地址。这需要在主机和某些路由器之间进行一些数据包交换。此外，如果主机移动并连接到另一个路由器，其网络地址将改变。这可能会对某些移动主机造成问题。
- en: Dealing with heterogeneous datalink layers[#](#dealing-with-heterogeneous-datalink-layers
    "Link to this heading")
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异构数据链路层[#](#dealing-with-heterogeneous-datalink-layers "链接到本标题")
- en: Sometimes, the network layer needs to deal with heterogeneous datalink layers.
    For example, two hosts connected to different datalink layers exchange packets
    via routers that are using other types of datalink layers. Thanks to the network
    layer, this exchange of packets is possible provided that each packet can be placed
    inside a datalink layer frame before being transmitted. If all datalink layers
    support the same frame size, this is simple. When a node receives a frame, it
    decapsulates the packet that it contains, checks the header and forwards it, encapsulated
    inside another frame, to the outgoing interface. Unfortunately, the encapsulation
    operation is not always possible. Each datalink layer is characterized by the
    maximum frame size that it supports. Datalink layers typically support frames
    containing up to a few hundreds or a few thousands of bytes. The maximum frame
    size that a given datalink layer supports depends on its underlying technology.
    Unfortunately, most datalink layers support a different maximum frame size. This
    implies that when a host sends a large packet inside a frame to its nexthop router,
    there is a risk that this packet will have to traverse a link that is not capable
    of forwarding the packet inside a single frame. In principle, there are three
    possibilities to solve this problem. To discuss them, we consider a simple scenario
    with two hosts connected to a router as shown in the figure below.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，网络层需要处理异构数据链路层。例如，连接到不同数据链路层的两个主机通过使用其他类型数据链路层路由器交换数据包。多亏了网络层，只要每个数据包在传输前都能放入一个数据链路层帧中，这种数据包交换是可能的。如果所有数据链路层都支持相同的帧大小，这很简单。当一个节点接收到一个帧时，它会解封装包含的数据包，检查头部并转发它，封装在另一个帧中，发送到出口接口。不幸的是，封装操作并不总是可能的。每个数据链路层的特点是它所支持的最大的帧大小。数据链路层通常支持包含数百或数千字节的帧。一个特定数据链路层所支持的最大的帧大小取决于其底层技术。不幸的是，大多数数据链路层支持不同的最大帧大小。这意味着当主机在帧中发送一个大型数据包到其下一跳路由器时，存在这种数据包将不得不穿越无法在单个帧中转发该数据包的链路的风险。原则上，有三种可能性来解决此问题。为了讨论它们，我们考虑一个简单的场景，其中两个主机连接到一个路由器，如图所示。
- en: '![Figure made with TikZ](../Images/b50bd82cdce23b386cd09872d74ee6e1.png)'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/b50bd82cdce23b386cd09872d74ee6e1.png)'
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 133 A simple heterogeneous network
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图133 一个简单的异构网络
- en: Consider in the network above that host A wants to send a 900 bytes packet (870
    bytes of payload and 30 bytes of header) to host B via router R1. Host A encapsulates
    this packet inside a single frame. The frame is received by router R1 which extracts
    the packet. Router R1 has three possible options to process this packet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的网络中，假设主机A想要通过路由器R1向主机B发送一个900字节的分组（870字节的负载和30字节的头部）。主机A将这个分组封装在一个单独的帧中。这个帧被路由器R1接收，并从中提取出分组。路由器R1有三个可能的选择来处理这个分组。
- en: The packet is too large and router R1 cannot forward it to router R2. It rejects
    the packet and sends a control packet back to the source (host A) to indicate
    that it cannot forward packets longer than 500 bytes (minus the packet header).
    The source could react to this control packet by retransmitting the information
    in smaller packets.
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分组太大，路由器R1无法将其转发到路由器R2。它拒绝了这个分组，并向源（主机A）发送一个控制分组，以表明它无法转发超过500字节（减去分组头部）的分组。源可以对此控制分组做出反应，通过将信息重传为更小的分组。
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The network layer is able to fragment a packet. In our example, the router could
    fragment the packet in two parts. The first part contains the beginning of the
    payload and the second the end. There are two possible ways to perform this fragmentation.
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络层能够分片分组。在我们的例子中，路由器可以将分组分成两部分。第一部分包含负载的开始部分，第二部分包含结束部分。有两种可能的方法来进行这种分片。
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Router R1 fragments the packet into two fragments before transmitting them to
    router R2. Router R2 reassembles the two packet fragments in a larger packet before
    transmitting them on the link towards host B.
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器R1在将分组传输到路由器R2之前将其分成两个分片。路由器R2在将分组传输到主机B的链路之前，将这两个分组分片重新组装成更大的分组。
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Each of the packet fragments is a valid packet that contains a header with the
    source (host A) and destination (host B) addresses. When router R2 receives a
    packet fragment, it treats this packet as a regular packet and forwards it to
    its final destination (host B). Host B reassembles the received fragments.
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个分组分片都是一个有效的分组，它包含一个带有源（主机A）和目的（主机B）地址的头部。当路由器R2接收到一个分组分片时，它将这个分组视为一个常规分组，并将其转发到其最终目的地（主机B）。主机B重新组装接收到的分片。
- en: These three solutions have advantages and drawbacks. With the first solution,
    routers remain simple and do not need to perform any fragmentation operation.
    This is important when routers are implemented mainly in hardware. However, hosts
    must be complex since they need to store the packets that they produce if they
    need to pass through a link that does not support large packets. This increases
    the buffering required on the hosts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种解决方案各有优缺点。第一种解决方案中，路由器保持简单，不需要执行任何分片操作。当路由器主要在硬件中实现时，这一点很重要。然而，主机必须复杂，因为它们需要存储它们产生的分组，如果它们需要通过不支持大分组的链路，这会增加主机上所需的缓冲区。
- en: Furthermore, a single large packet may potentially need to be retransmitted
    several times. Consider for example a network similar to the one shown above but
    with four routers. Assume that the link R1->R2 supports 1000 bytes packets, link
    R2->R3 800 bytes packets and link R3->R4 600 bytes packets. A host attached to
    R1 that sends large packet will have to first try 1000 bytes, then 800 bytes and
    finally 600 bytes. Fortunately, this scenario does not occur very often in practice
    and this is the reason why this solution is used in real networks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个单独的大分组可能需要被重传多次。例如，考虑一个类似于上面所示的网络，但包含四个路由器。假设R1->R2链路支持1000字节的分组，R2->R3链路支持800字节的分组，R3->R4链路支持600字节的分组。连接到R1的主机发送大分组时，首先尝试1000字节，然后是800字节，最后是600字节。幸运的是，这种情况在实践中并不常见，这也是为什么这种解决方案在真实网络中被使用的原因。
- en: Fragmenting packets on a per-link basis, as presented for the second solution,
    can minimize the transmission overhead since a packet is only fragmented on the
    links where fragmentation is required. Large packets can continue to be used downstream
    of a link that only accepts small packets. However, this reduction of the overhead
    comes with two drawbacks. First, fragmenting packets, potentially on all links,
    increases the processing time and the buffer requirements on the routers. Second,
    this solution leads to a longer end-to-end delay since the downstream router has
    to reassemble all the packet fragments before forwarding the packet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按链路分片数据包，如第二个解决方案中所示，可以最小化传输开销，因为数据包只在需要分片的地方进行分片。大数据包可以继续在只接受小数据包的链路下游使用。然而，这种开销的减少伴随着两个缺点。首先，在所有链路上分片数据包，可能会增加路由器的处理时间和缓冲区需求。其次，这个解决方案会导致更长的端到端延迟，因为下游路由器必须在转发数据包之前重新组装所有的数据包片段。
- en: The last solution is a compromise between the two others. Routers need to perform
    fragmentation but they do not need to reassemble packet fragments. Only the hosts
    need to have buffers to reassemble the received fragments. This solution has a
    lower end-to-end delay and requires fewer processing time and memory on the routers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种解决方案是介于其他两种解决方案之间的折衷方案。路由器需要执行分片，但不需要重新组装数据包片段。只有主机需要缓冲区来重新组装接收到的片段。这种解决方案具有更低的端到端延迟，并且需要路由器更少的处理时间和内存。
- en: 'The first solution to the fragmentation problem presented above suggests the
    utilization of control packets to inform the source about the reception of a too
    long packet. This is only one of the functions that are performed by the control
    protocol in the network layer. Other functions include :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提出的分片问题第一种解决方案建议利用控制数据包通知源端关于接收到的过长数据包的情况。这只是网络层控制协议执行的功能之一。其他功能包括：
- en: sending a control packet back to the source if a packet is received by a router
    that does not have a valid entry in its forwarding table
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由器收到一个没有有效条目在其转发表中的数据包，则向源发送控制数据包
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: sending a control packet back to the source if a router detects that a packet
    is looping inside the network
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由器检测到数据包在网络内部循环，则向源发送控制数据包
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: verifying that packets can reach a given destination
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据包能否到达指定的目的地
- en: We will discuss these functions in more details when we will describe the protocols
    that are used in the network layer of the TCP/IP protocol suite.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们描述TCP/IP协议套件网络层中使用的协议时，我们将更详细地讨论这些功能。
- en: Virtual circuit organization[#](#virtual-circuit-organization "Link to this
    heading")
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟电路组织[#](#virtual-circuit-organization "链接到这个标题")
- en: The second organization of the network layer, called virtual circuits, has been
    inspired by the organization of telephone networks. Telephone networks have been
    designed to carry phone calls that usually last a few minutes. Each phone is identified
    by a telephone number and is attached to a telephone switch. To initiate a phone
    call, a telephone first needs to send the destination’s phone number to its local
    switch. The switch cooperates with the other switches in the network to create
    a bi-directional channel between the two telephones through the network. This
    channel will be used by the two telephones during the lifetime of the call and
    will be released at the end of the call. Until the 1960s, most of these channels
    were created manually, by telephone operators, upon request of the caller. Today’s
    telephone networks use automated switches and allow several channels to be carried
    over the same physical link, but the principles roughly remain the same.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层的第二种组织方式，称为虚拟电路，其组织结构受到了电话网络组织的启发。电话网络的设计是为了承载通常持续几分钟的电话通话。每部电话通过电话号码进行标识，并连接到电话交换机。为了发起电话通话，电话首先需要将其目的地电话号码发送到其本地交换机。交换机与网络中的其他交换机合作，在网络中为两部电话之间创建一个双向通道。这个通道将在通话期间被两部电话使用，并在通话结束时释放。直到20世纪60年代，这些通道大多数都是通过电话操作员根据呼叫者的请求手动创建的。今天的电话网络使用自动化交换机，并允许在同一物理链路上传输多个通道，但基本原理大致相同。
- en: 'In a network using virtual circuits, all hosts are also identified with a network
    layer address. However, packet forwarding is not performed by looking at the destination
    address of each packet. With the virtual circuit organization, each data packet
    contains one label [[1]](#flabels). A label is an integer which is part of the
    packet header. Routers implement label switching to forward labelled data packet.
    Upon reception of a packet, a router consults its label forwarding table to find
    the outgoing interface for this packet. In contrast with the datagram mode, this
    lookup is very simple. The label forwarding table is an array stored in memory
    and the label of the incoming packet is the index to access this array. This implies
    that the lookup operation has an O(1) complexity in contrast with other packet
    forwarding techniques. To ensure that on each node the packet label is an index
    in the label forwarding table, each router that forwards a packet replaces the
    label of the forwarded packet with the label found in the label forwarding table.
    Each entry of the label forwarding table contains two pieces of information :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚电路的网络中，所有主机也使用网络层地址进行标识。然而，数据包转发不是通过查看每个数据包的目的地址来进行的。在虚电路组织结构中，每个数据包包含一个标签
    [[1]](#flabels)。标签是一个整数，它是数据包头部的一部分。路由器通过标签交换来转发标记数据包。在接收到数据包后，路由器会查阅其标签转发表以找到该数据包的出口接口。与数据报模式相比，这种查找非常简单。标签转发表是存储在内存中的数组，而进入数据包的标签是该数组的索引。这意味着查找操作具有O(1)的复杂度，与其他数据包转发技术相比。为了确保在每个节点上数据包标签是标签转发表中的索引，每个转发数据包的路由器都会将转发数据包的标签替换为标签转发表中找到的标签。标签转发表的每个条目包含两份数据：
- en: the outgoing interface for the packet
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包的出口接口
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the label for the outgoing packet
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出口数据包的标签
- en: For example, consider the label forwarding table of a network node below.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下网络节点的标签转发表。
- en: '| index | outgoing interface | label |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 出口接口 | 标签 |'
- en: '| 0 | South | 7 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 南 | 7 |'
- en: '| 1 | none | none |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 无 | 无 |'
- en: '| 2 | West | 2 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 西 | 2 |'
- en: '| 3 | East | 2 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 东 | 2 |'
- en: If this node receives a packet with label=2, it forwards the packet on its West
    interface and sets the label of the outgoing packet to 2. If the received packet’s
    label is set to 3, then the packet is forwarded over the East interface and the
    label of the outgoing packet is set to 2. If a packet is received with a label
    field set to 1, the packet is discarded since the corresponding label forwarding
    table entry is invalid.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个节点接收到标签=2的数据包，它将在其西接口上转发数据包并将出口数据包的标签设置为2。如果接收到的数据包的标签设置为3，则数据包将通过东接口转发，出口数据包的标签也设置为2。如果接收到标签字段设置为1的数据包，则该数据包将被丢弃，因为相应的标签转发表条目是无效的。
- en: 'Label switching enables a full control over the path followed by packets inside
    the network. Consider the network below and assume that we want to use two virtual
    circuits : R1->R3->R4->R2->R5 and R2->R1->R3->R4->R5.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标签交换允许完全控制网络内部数据包的路径。考虑以下网络，并假设我们想使用两个虚电路：R1->R3->R4->R2->R5和R2->R1->R3->R4->R5。
- en: '![Figure made with TikZ](../Images/c5fa5b3b06d080fc6776a20d0bcd17c6.png)'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c5fa5b3b06d080fc6776a20d0bcd17c6.png)'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 134 An example of network where label switching can be applied to tune
    its paths
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图134：一个可以应用标签交换来调整其路径的网络示例
- en: 'To create these virtual circuits, we need to configure the label forwarding
    tables of all routers. For simplicity, assume that a label forwarding table only
    contains two entries. Assume that R5 wants to receive the packets from the virtual
    circuit created by R1 (resp. R2) with label=1 (label=0). R4 could use the following
    label forwarding table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些虚电路，我们需要配置所有路由器的标签转发表。为了简化，假设标签转发表只包含两个条目。假设R5想要接收由R1（分别由R2）创建的带有标签=1（标签=0）的虚电路中的数据包。R4可以使用以下标签转发表：
- en: '| R4’s label forwarding table |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| R4的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 出口接口 | 标签 |'
- en: '| 0 | ->R2 | 1 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ->R2 | 1 |'
- en: '| 1 | ->R5 | 0 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R5 | 0 |'
- en: 'Since a packet received with label=1 must be forwarded to R5 with label=1,
    R2’s label forwarding table could contain :'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于带有标签=1的接收到的数据包必须转发到带有标签=1的R5，R2的标签转发表可能包含：
- en: '| R2’s label forwarding table |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| R2的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 出口接口 | 标签 |'
- en: '| 0 | none | none |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 无 | 无 |'
- en: '| 1 | ->R5 | 1 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R5 | 1 |'
- en: Two virtual circuits pass through R3. They both need to be forwarded to R4,
    but R4 expects label=1 for packets belonging to the virtual circuit originated
    by R2 and label=0 for packets belonging to the other virtual circuit. R3 could
    choose to leave the labels unchanged.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两个虚拟电路通过R3。它们都需要转发到R4，但R4期望来自R2的虚拟电路的数据包标签为1，而来自其他虚拟电路的数据包标签为0。R3可以选择保持标签不变。
- en: '| R3’s label forwarding table |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| R3的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | ->R4 | 0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ->R4 | 0 |'
- en: '| 1 | ->R4 | 1 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R4 | 1 |'
- en: 'With the above label forwarding table, R1 needs to originate the packets that
    belong to the R1->R3->R4->R2->R5 circuit with label=0. The packets received from
    R2 and belonging to the R2->R1->R3->R4->R5 circuit would then use label=1 on the
    R1-R3 link. R1 ‘s label forwarding table could be built as follows :'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述标签转发表中，R1需要以标签=0启动属于R1->R3->R4->R2->R5电路的数据包。然后从R2接收到的属于R2->R1->R3->R4->R5电路的数据包将在R1-R3链路上使用标签=1。R1的标签转发表可以构建如下：
- en: '| R1’s label forwarding table |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| R1的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | ->R3 | 0 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ->R3 | 0 |'
- en: '| 1 | ->R3 | 1 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R3 | 1 |'
- en: The figure below shows the path followed by the packets on the R1->R3->R4->R2->R5
    path in red with on each arrow the label used in the packets.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在R1->R3->R4->R2->R5路径上数据包的路径，用红色表示，每个箭头上的标签是数据包中使用的标签。
- en: '![Figure made with TikZ](../Images/aac335913fe6b920a1747148900960d0.png)'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/aac335913fe6b920a1747148900960d0.png)'
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 135 The path followed by packets for a specific circuit
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图135 特定电路的数据包路径
- en: MultiProtocol Label Switching (MPLS) is the example of a deployed networking
    technology that relies on label switching. MPLS is more complex than the above
    description because it has been designed to be easily integrated with datagram
    technologies. However, the principles remain. Asynchronous Transfer Mode (ATM)
    and Frame Relay are other examples of technologies that rely on label switching.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 多协议标签交换（MPLS）是依赖于标签交换的已部署网络技术的例子。MPLS比上述描述更复杂，因为它被设计成容易与数据报技术集成。然而，原则仍然是。异步传输模式（ATM）和帧中继是其他依赖于标签交换技术的例子。
- en: 'Nowadays, most deployed networks rely on distributed algorithms, called routing
    protocols, to compute the forwarding tables that are installed on the routers.
    These distributed algorithms are part of the control plane. They are usually implemented
    in software and are executed on the main CPU of the routers. There are two main
    families of routing protocols : distance vector routing and link state routing.
    Both are capable of discovering autonomously the network and react dynamically
    to topology changes.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数部署的网络都依赖于称为路由协议的分布式算法来计算安装在路由器上的转发表。这些分布式算法是控制平面的一部分。它们通常在软件中实现，并在路由器的主CPU上执行。有两种主要的路由协议家族：距离矢量路由和链路状态路由。两者都能够自主发现网络，并能够动态地响应拓扑变化。
- en: Footnotes
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: The datagram organization[#](#the-datagram-organization "Link to this heading")
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据报组织[#](#the-datagram-organization "链接到本标题")
- en: 'The first and most popular organization of the network layer is the datagram
    organization. This organization is inspired by the organization of the postal
    service. Each host is identified by a network layer address. To send information
    to a remote host, a host creates a packet that contains:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层的第一种和最流行的组织形式是数据报组织。这种组织形式受到了邮政服务组织的启发。每个主机都由一个网络层地址标识。为了向远程主机发送信息，主机创建一个包含以下内容的数据包：
- en: the network layer address of the destination host
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的主机的网络层地址
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: its own network layer address
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自己的网络层地址
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the information to be sent
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发送的信息
- en: To understand the datagram organization, let us consider [Fig. 128](#fig-simple-internetwork).
    A network layer address, represented by a letter, has been assigned to each host
    and router. To send some information to host J, host A creates a packet containing
    its own address, the destination address and the information to be exchanged.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解数据报组织，让我们考虑[图128](#fig-simple-internetwork)。每个主机和路由器都分配了一个由字母表示的网络层地址。为了向主机J发送一些信息，主机A创建了一个包含其自己的地址、目标地址和要交换的信息的数据包。
- en: '![Figure made with TikZ](../Images/b17c456b68f70d26fa9339dd30edb066.png)'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/b17c456b68f70d26fa9339dd30edb066.png)'
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 128 A simple internetwork
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图128 简单的互联网
- en: With the datagram organization, routers use hop-by-hop forwarding. This means
    that when a router receives a packet that is not destined to itself, it looks
    up the destination address of the packet in its forwarding table. A forwarding
    table is a data structure that maps each destination address (or set of destination
    addresses) to the outgoing interface over which a packet destined to this address
    must be forwarded to reach its final destination. The router consults its forwarding
    table to forward each packet that it handles.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据报组织结构中，路由器使用逐跳转发。这意味着当一个路由器收到一个不是发往自己的数据包时，它会在其转发表中查找数据包的目的地址。转发表是一种数据结构，它将每个目的地址（或一组目的地址）映射到必须通过该接口转发数据包以到达其最终目的地的出口接口。路由器咨询其转发表以转发它处理的每个数据包。
- en: The figure illustrates some possible forwarding tables in this network. By inspecting
    the forwarding tables of the different routers, one can find the path followed
    by packets sent from a source to a particular destination. In the example above,
    host A sends its packet to router R1. R1 consults its forwarding table and forwards
    the packet towards R2. Based on its own table, R2 decides to forward the packet
    to R5 that can deliver it to its destination. Thus, the path from A to J is A
    -> R1 -> R2 -> R5 -> J.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图中说明了该网络中一些可能的转发表。通过检查不同路由器的转发表，可以找到从源发送到特定目的地的数据包所遵循的路径。在上面的例子中，主机A将其数据包发送到路由器R1。R1咨询其转发表并将数据包转发到R2。根据其自己的表，R2决定将数据包转发到可以将其交付到目的地的R5。因此，从A到J的路径是A
    -> R1 -> R2 -> R5 -> J。
- en: The computation of the forwarding tables of all the routers inside a network
    is a key element for the correct operation of the network. This computation can
    be carried out by using either distributed or centralized algorithms. These algorithms
    provide different performance, may lead to different types of paths, but their
    composition must lead to valid paths.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络内部计算所有路由器的转发表是网络正确运行的关键要素。这个计算可以通过使用分布式或集中式算法来完成。这些算法提供不同的性能，可能会导致不同类型的路径，但它们的组合必须导致有效的路径。
- en: In a network, a path can be defined as the list of all intermediate routers
    for a given source destination pair. For a given source/destination pair, the
    path can be derived by first consulting the forwarding table of the router attached
    to the source to determine the next router on the path towards the chosen destination.
    Then, the forwarding table of this router is queried for the same destination…
    The queries continue until the destination is reached. In a network that has valid
    forwarding tables, all the paths between all source/destination pairs contain
    a finite number of intermediate routers. However, if forwarding tables have not
    been correctly computed, two types of invalid paths can occur.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，路径可以定义为给定源/目的对的所有中间路由器的列表。对于给定的源/目的对，路径可以通过首先咨询连接到源的路由器的转发表来确定通往所选目的地的路径上的下一个路由器。然后，查询此路由器的转发表以获取相同的目的地…查询会继续，直到达到目的地。在一个具有有效转发表的网络中，所有源/目的对之间的路径都包含有限数量的中间路由器。然而，如果转发表没有正确计算，可能会出现两种无效路径。
- en: A path may lead to a black hole. In a network, a black hole is a router that
    receives packets for at least one given source/destination pair but does not have
    an entry inside its forwarding table for this destination. Since it does not know
    how to reach the destination, the router cannot forward the received packets and
    must discard them. Any centralized or distributed algorithm that computes forwarding
    tables must ensure that there are not black holes inside the network.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可能导致黑洞。在网络中，黑洞是至少接收一个给定源/目的对的数据包但在其转发表中没有该目的地的条目的路由器。由于它不知道如何到达目的地，该路由器无法转发接收到的数据包并必须丢弃它们。任何计算转发表的集中式或分布式算法都必须确保网络中没有黑洞。
- en: A second type of problem may exist in networks using the datagram organization.
    Consider a path that contains a cycle. For example, router R1 sends all packets
    towards destination D via router R2. Router R2 forwards these packets to router
    R3 and finally router R3’s forwarding table uses router R1 as its nexthop to reach
    destination D. In this case, if a packet destined to D is received by router R1,
    it will loop on the R1 -> R2 -> R3 -> R1 cycle and will never reach its final
    destination. As in the black hole case, the destination is not reachable from
    all sources in the network. In practice the loop problem is more annoying than
    the black hole problem because when a packet is caught in a forwarding loop, it
    unnecessarily consumes bandwidth. In the black hole case, the problematic packet
    is quickly discarded. We will see later that network layer protocols include techniques
    to minimize the impact of such forwarding loops.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据报组织的网络中可能存在第二种类型的问题。考虑一个包含循环的路径。例如，路由器R1通过路由器R2将所有数据包发送到目的地D。路由器R2将这些数据包转发到路由器R3，最后路由器R3的转发表使用路由器R1作为其下一跳来到达目的地D。在这种情况下，如果路由器R1收到一个目的地为D的数据包，它将在R1
    -> R2 -> R3 -> R1的循环中循环，并且永远不会到达其最终目的地。就像在黑洞案例中一样，目的地不是从网络中的所有源可达。在实践中，循环问题比黑洞问题更令人烦恼，因为当数据包陷入转发环路时，它会无谓地消耗带宽。在黑洞情况下，有问题的数据包会迅速被丢弃。我们将在后面看到，网络层协议包括技术来最小化这种转发环路的影响。
- en: Any solution which is used to compute the forwarding tables of a network must
    ensure that all destinations are reachable from any source. This implies that
    it must guarantee the absence of black holes and forwarding loops.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用于计算网络转发表的解决方案都必须确保所有目的地都可通过任何源到达。这意味着它必须保证不存在黑洞和转发环路。
- en: The forwarding tables and the precise format of the packets that are exchanged
    inside the network are part of the data plane of the network. This data plane
    contains all the protocols and algorithms that are used by hosts and routers to
    create and process the packets that contain user data. On high-end routers, the
    data plane is often implemented in hardware for performance reasons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 转发表和在网络内部交换的数据包的精确格式是网络数据平面的一部分。这个数据平面包含所有主机和路由器使用的协议和算法，用于创建和处理包含用户数据的数据包。在高端路由器上，出于性能原因，数据平面通常在硬件中实现。
- en: Besides the data plane, a network is also characterized by its control plane.
    The control plane includes all the protocols and algorithms (often distributed)
    that compute the forwarding tables that are installed on all routers inside the
    network. While there is only one possible data plane for a given networking technology,
    different networks using the same technology may use different control planes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据平面，网络还以其控制平面为特征。控制平面包括所有计算并安装在网络上所有路由器上的转发表的协议和算法（通常是分布式的）。对于给定的网络技术，可能只有一个可能的数据平面，但使用相同技术的不同网络可能使用不同的控制平面。
- en: The simplest control plane for a network is to manually compute the forwarding
    tables of all routers inside the network. This simple control plane is sufficient
    when the network is (very) small, usually up to a few routers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络来说，最简单的控制平面是手动计算网络内部所有路由器的转发表。当网络（非常）小，通常不超过几个路由器时，这种简单的控制平面是足够的。
- en: In most networks, manual forwarding tables are not a solution for two reasons.
    First, most networks are too large to enable a manual computation of the forwarding
    tables. Second, with manually computed forwarding tables, it is very difficult
    to deal with link and router failures. Networks need to operate 24h a day, 365
    days per year. Many events can affect the routers and links that compose a network.
    Link failures are regular events in deployed networks. Links can fail for various
    reasons, including electromagnetic interference, fiber cuts, hardware or software
    problems on the terminating routers,… Some links also need to be either added
    to or removed from the network because their utilization is too low or their cost
    is too high.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网络中，手动转发表不是解决方案，有两个原因。首先，大多数网络太大，无法手动计算转发表。其次，使用手动计算的转发表，很难处理链路和路由器故障。网络需要每天24小时，每年365天运行。许多事件可以影响构成网络的路由器和链路。链路故障是部署网络中的常规事件。链路可能因各种原因而失败，包括电磁干扰、光纤切割、终止路由器上的硬件或软件问题等。一些链路也需要添加到网络中或从网络中移除，因为它们的利用率太低或成本太高。
- en: Similarly, routers also fail. There are two types of failures that affect routers.
    A router may stop forwarding packets due to hardware or software problems (e.g.,
    due to a crash of its operating system). A router may also need to be halted from
    time to time (e.g., to upgrade its operating system or to install new interface
    cards). These planned and unplanned events affect the set of links and routers
    that can be used to forward packets in the network. Still, most network users
    expect that their network will continue to correctly forward packets despite all
    these events. With manually computed forwarding tables, it is usually impossible
    to pre-compute the forwarding tables while taking into account all possible failure
    scenarios.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，路由器也可能出现故障。有两种类型的故障会影响路由器。路由器可能因为硬件或软件问题（例如，由于操作系统的崩溃）而停止转发数据包。路由器也可能需要不时地停止运行（例如，升级其操作系统或安装新的接口卡）。这些计划和未计划的事件会影响网络中可用于转发数据包的链路和路由器的集合。尽管如此，大多数网络用户都期望他们的网络将继续正确地转发数据包，尽管发生了所有这些事件。使用手动计算的转发表，通常不可能在考虑所有可能的故障场景的同时预先计算转发表。
- en: An alternative to manually computed forwarding tables is to use a network management
    platform that tracks the network status and can push new forwarding tables on
    the routers when it detects any modification to the network topology. This solution
    gives some flexibility to the network managers in computing the paths inside their
    network. However, this solution only works if the network management platform
    is always capable of reaching all routers even when the network topology changes.
    This may require a dedicated network that allows the management platform to push
    information on the forwarding tables. Openflow is a modern example of such solutions
    [[MAB2008]](../bibliography.html#mab2008). In a nutshell, Openflow is a protocol
    that enables a network controller to install specific entries in the forwarding
    tables of remote routers and much more.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 手动计算转发表的替代方案是使用一个网络管理平台，该平台跟踪网络状态，并在检测到网络拓扑的任何修改时，可以在路由器上推送新的转发表。这种解决方案为网络管理员在计算其网络内部的路径时提供了一定的灵活性。然而，这种解决方案仅在网络管理平台始终能够到达所有路由器，即使网络拓扑发生变化时才有效。这可能需要一个专用网络，以便管理平台能够推送转发表信息。Openflow是这类解决方案的现代例子
    [[MAB2008]](../bibliography.html#mab2008)。简而言之，Openflow是一种协议，它使网络控制器能够安装远程路由器转发表中的特定条目，以及更多功能。
- en: Another interesting point that is worth being discussed is when the forwarding
    tables are computed. A widely used solution is to compute the entries of the forwarding
    tables for all destinations on all routers. This ensures that each router has
    a valid route towards each destination. These entries can be updated when an event
    occurs and the network topology changes. A drawback of this approach is that the
    forwarding tables can become large in large networks since each router must always
    maintain one entry for each destination inside its forwarding table.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得讨论的有趣点是转发表的计算时机。一个广泛使用的解决方案是为所有路由器上的所有目的地计算转发表的条目。这确保了每个路由器都对每个目的地有一个有效的路由。当发生事件且网络拓扑发生变化时，这些条目可以被更新。这种方法的缺点是，在大规模网络中，转发表可能会变得很大，因为每个路由器必须始终在其转发表中为每个目的地维护一个条目。
- en: Some networks use the arrival of packets as the trigger to compute the corresponding
    entries in the forwarding tables. Several technologies have been built upon this
    principle. When a packet arrives, the router consults its forwarding table to
    find a path towards the destination. If the destination is present in the forwarding
    table, the packet is forwarded. Otherwise, the router needs to find a way to forward
    the packet and update its forwarding table.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络使用数据包到达作为计算转发表中相应条目的触发器。基于这一原则已经开发出几种技术。当数据包到达时，路由器会查阅其转发表以找到通往目的地的路径。如果目的地存在于转发表中，则转发数据包。否则，路由器需要找到一种方法来转发数据包并更新其转发表。
- en: Computing forwarding tables[#](#computing-forwarding-tables "Link to this heading")
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算转发表[#](#computing-forwarding-tables "链接到本标题")
- en: Networks deployed several techniques to update the forwarding tables upon the
    arrival of a packet. In this section, we briefly present the principles that underlie
    three of these techniques.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 部署网络使用了多种技术来在数据包到达时更新转发表。在本节中，我们将简要介绍这三种技术背后的原理。
- en: The first technique assumes that the underlying network topology is a tree.
    A tree is the simplest network to be considered when forwarding packets. The main
    advantage of using a tree is that there is only one path between any pair of nodes
    inside the network. Since a tree does not contain any cycle, it is impossible
    to have forwarding loops in a tree-shaped network.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术假设底层网络拓扑是树形。在转发数据包时，树形是最简单的网络。使用树的主要优点是网络中任意一对节点之间只有一条路径。由于树不包含任何循环，因此在树形网络中不可能有转发环路。
- en: In a tree-shaped network, it is relatively simple for each node to automatically
    compute its forwarding table by inspecting the packets that it receives. For this,
    each node uses the source and destination addresses present inside each packet.
    Thanks to the source address, a node can learn the location of the different sources
    inside the network. Each source has a unique address. When a node receives a packet
    over a given interface, it learns that the source (address) of this packet is
    reachable via this interface. The node maintains a data structure that maps each
    known source address to an incoming interface. This data structure is often called
    the port-address table since it indicates the interface (or port) to reach a given
    address.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在树形网络中，每个节点通过检查它接收到的数据包，相对简单就能自动计算其转发表。为此，每个节点使用每个数据包中存在的源和目的地地址。多亏了源地址，节点可以学习网络中不同源的位置。每个源都有一个唯一的地址。当一个节点通过某个接口收到一个数据包时，它了解到这个数据包的源（地址）可以通过这个接口访问。节点维护一个将每个已知源地址映射到入接口的数据结构。这个数据结构通常被称为端地址表，因为它指示了到达给定地址的接口（或端口）。
- en: Learning the location of the sources is not sufficient, nodes also need to forward
    packets towards their destination. When a node receives a packet whose destination
    address is already present inside its port-address table, it simply forwards the
    packet on the interface listed in the port-address table. In this case, the packet
    will follow the port-address table entries in the downstream nodes and will reach
    the destination. If the destination address is not included in the port-address
    table, the node simply forwards the packet on all its interfaces, except the interface
    from which the packet was received. Forwarding a packet over all interfaces is
    usually called broadcasting in the terminology of computer networks. Sending the
    packet over all interfaces except one is a costly operation since the packet is
    sent over links that do not reach the destination. Given the tree-shape of the
    network, the packet will explore all downstream branches of the tree and will
    finally reach its destination. In practice, the broadcasting operation does not
    occur too often and its performance impact remains limited.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 仅学习源的位置是不够的，节点还需要将数据包转发到它们的目的地。当一个节点收到一个其目的地地址已经在其端地址表中存在的数据包时，它只需在端地址表中列出的接口上转发数据包。在这种情况下，数据包将遵循下游节点的端地址表条目并到达目的地。如果目的地地址未包含在端地址表中，节点只需在其所有接口上转发数据包，除了接收数据包的接口。在计算机网络术语中，将数据包转发到所有接口通常称为广播。通过所有接口发送数据包是一种昂贵的操作，因为数据包是通过无法到达目的地的链路发送的。鉴于网络的树形结构，数据包将探索树的所有下游分支，并最终到达目的地。在实践中，广播操作并不太常见，其性能影响仍然有限。
- en: 'To understand the operation of the port-address table, let us consider the
    example network shown in [Fig. 129](#fig-simple-tree-network). This network contains
    three hosts: A, B and C and five routers, R1 to R5. When the network boots, all
    the forwarding tables of the nodes are empty.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解端地址表的操作，让我们考虑图 [Fig. 129](#fig-simple-tree-network) 所示的示例网络。这个网络包含三个主机：A、B
    和 C 以及五个路由器，R1 到 R5。当网络启动时，所有节点的转发表都是空的。
- en: '![Figure made with TikZ](../Images/d7769586ddea01abce95ea2ac91eaad6.png)'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的照片](../Images/d7769586ddea01abce95ea2ac91eaad6.png)'
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 129 A simple tree-shaped network
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 [Fig. 129](#fig-simple-tree-network) 一个简单的树形网络
- en: Host A sends a packet towards B. When receiving this packet, R1 learns that
    A is reachable via its West interface. Since it does not have an entry for destination
    B in its port-address table, it forwards the packet to both R2 and R3. When R2
    receives the packet, it updates its own forwarding table and forward the packet
    to C. Since C is not the intended recipient, it simply discards the received packet.
    Router R3 also receives the packet. It learns that A is reachable via its North-West
    interface and broadcasts the packet to R4 and R5. R5 also updates its forwarding
    table and finally forwards it to destination B. Let us now consider what happens
    when B sends a reply to A. R5 first learns that B is attached to its North-East
    port. It then consults its port-address table and finds that A is reachable via
    its North-West interface. The packet is then forwarded hop-by-hop to A without
    any broadcasting. Later on, if C sends a packet to B, this packet will reach R1
    that contains a valid forwarding entry in its forwarding table.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 主机A向B发送一个数据包。当收到这个数据包时，R1了解到A可以通过其西接口到达。由于它在端口地址表中没有为目的地B的条目，它将数据包转发给R2和R3。当R2收到数据包时，它更新自己的转发表并将数据包转发给C。由于C不是预期的接收者，它简单地丢弃了接收到的数据包。路由器R3也收到了数据包。它了解到A可以通过其西北接口到达，并将数据包广播给R4和R5。R5也更新了其转发表，并最终将其转发到目的地B。现在让我们考虑当B向A发送回复时会发生什么。R5首先了解到B连接到其东北端口。然后它查阅其端口地址表，发现A可以通过其西北接口到达。然后数据包逐跳转发到A，没有任何广播。稍后，如果C向B发送一个数据包，这个数据包将到达包含有效转发条目的R1。
- en: By inspecting the source and destination addresses of packets, network nodes
    can automatically derive their forwarding tables. As we will discuss later, this
    technique is used in [Ethernet](../glossary.html#term-Ethernet) networks. Despite
    being widely used, it has two important drawbacks. First, packets sent to unknown
    destinations must be broadcasted in the network even if the destination is not
    attached to the network. Consider the transmission of ten packets destined to
    Z in the network above. When a node receives a packet towards this destination,
    it can only broadcast that packet. Since Z is not attached to the network, no
    node will ever receive a packet whose source is Z to update its forwarding table.
    The second and more important problem is that few networks have a tree-shaped
    topology. It is interesting to analyze what happens when a port-address table
    is used in a network that contains a cycle. Consider the simple network shown
    in [Fig. 130](#fig-simple-redundant-network) with a single host.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查数据包的源地址和目的地址，网络节点可以自动推导出它们的转发表。正如我们稍后将要讨论的，这种技术在[以太网](../glossary.html#term-Ethernet)网络中被使用。尽管这种技术被广泛使用，但它有两个重要的缺点。首先，即使目的地址未连接到网络，发送到未知目的地的数据包也必须在网络中广播。考虑网络中发送到Z的十个数据包的传输。当一个节点收到指向该目的地的数据包时，它只能广播该数据包。由于Z未连接到网络，没有任何节点会收到源地址为Z的数据包来更新其转发表。第二个且更为重要的问题是，很少有网络具有树形拓扑结构。分析在包含环路的网络中使用端口地址表时发生的情况是很有趣的。考虑图130中显示的简单且冗余的网络[图](#fig-simple-redundant-network)。
- en: '![Figure made with TikZ](../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png)'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png)'
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 130 A simple and redundant network
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图130 简单且冗余的网络
- en: Assume that the network has started and all port-address and forwarding tables
    are empty. Host A sends a packet towards B. Upon reception of this packet, R1
    updates its port-address table. Since B is not present in the port-address table,
    the packet is broadcasted. Both R2 and R3 receive a copy of the packet sent by
    A. They both update their port-address table. Unfortunately, they also both broadcast
    the received packet. B receives a first copy of the packet, but R3 and R2 receive
    it again. R3 will then broadcast this copy of the packet to B and R1 while R2
    will broadcast its copy to R1. Although B has already received two copies of the
    packet, it is still inside the network and continues to loop. Due to the presence
    of the cycle, a single packet towards an unknown destination generates many copies
    of this packet that loop and will eventually saturate the network. Network operators
    who are using port-address tables to automatically compute the forwarding tables
    also use distributed algorithms to ensure that the network topology is always
    a tree.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设网络已经开始，所有端口号和转发表都是空的。主机 A 向 B 发送一个数据包。当接收到这个数据包时，R1 更新其端口号表。由于 B 不在端口号表中，该数据包被广播。R2
    和 R3 都收到了 A 发送的数据包副本。他们都更新了他们的端口号表。不幸的是，他们也同时广播了接收到的数据包。B 收到了数据包的第一个副本，但 R3 和
    R2 又收到了它。然后 R3 将这个数据包副本广播给 B 和 R1，而 R2 将其副本广播给 R1。尽管 B 已经收到了两个数据包副本，但它仍然在网络中，并继续循环。由于存在循环，一个未知目标的数据包会产生许多循环的数据包副本，最终会饱和网络。使用端口号表来自动计算转发表的网络操作员也使用分布式算法来确保网络拓扑始终是树形结构。
- en: 'Another technique called source routing can be used to automatically compute
    forwarding tables. It has been used in interconnecting Token Ring networks and
    in some wireless networks. Intuitively, source routing enables a destination to
    automatically discover the paths from a given source towards itself. This technique
    requires nodes to encode information inside some packets. For simplicity, let
    us assume that the data plane supports two types of packets :'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种称为源路由的技术可以用来自动计算转发表。它已被用于连接令牌环网络和某些无线网络。直观地说，源路由允许目标自动发现从给定源到自身的路径。这种技术要求节点在数据包中编码信息。为了简单起见，让我们假设数据平面支持两种类型的数据包：
- en: the data packets
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the control packets
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制包
- en: Data packets are used to exchange data while control packets are used to discover
    the paths between hosts. With source routing, routers can be kept as simple as
    possible and all the complexity is placed on the hosts. This is in contrast with
    the previous technique where the nodes had to maintain a port-address and a forwarding
    table while the hosts simply sent and received packets. Each node is configured
    with one unique address and there is one identifier per outgoing link. For simplicity
    and to avoid cluttering the figures with those identifiers, we assume that each
    node uses as link identifiers north, west, south,… In practice, a node would associate
    one integer to each outgoing link. This is illustrated in [Fig. 131](#fig-simple-2hosts-4routers).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包用于交换数据，而控制包用于发现主机之间的路径。使用源路由时，可以将路由器保持得尽可能简单，并将所有复杂性放在主机上。这与之前的技巧形成对比，其中节点必须维护一个端口号和转发表，而主机只是简单地发送和接收数据包。每个节点配置有一个唯一的地址，每个出链路有一个标识符。为了简单起见，并避免在图中充斥着这些标识符，我们假设每个节点使用北、西、南等作为链路标识符。在实践中，节点会将一个整数与每个出链路关联起来。这如图[图
    131](#fig-simple-2hosts-4routers)所示。
- en: '![Figure made with TikZ](../Images/4bdec978a60e773b93a0a4c896847066.png)'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/4bdec978a60e773b93a0a4c896847066.png)'
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 131 A simple network with two hosts and four routers
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 131 具有两个主机和四个路由器的简单网络
- en: In the network above, router R2 is attached to two outgoing links. R2 is connected
    to both R1 and R3. R2 can easily determine that it is connected to these two nodes
    by exchanging packets with them or observing the packets that it receives over
    each interface. Assume for example that when a node (either host or router) starts,
    it sends a special control packet over each of its interfaces to advertise its
    own address to its neighbors. When a node receives such a packet, it automatically
    replies with its own address. This exchange can also be used to verify whether
    a neighbor, either router or host, is still alive. With source routing, the data
    plane packets include a list of identifiers. This list is called a source route.
    It indicates the path to be followed by the packet as a sequence of link identifiers.
    When a node receives such a data plane packet, it first checks whether the packet’s
    destination is a direct neighbor. In this case, the packet is forwarded to this
    neighbor. Otherwise, the node extracts the next address from the list and forwards
    it to the neighbor. This allows the source to specify the explicit path to be
    followed for each packet. For example, in the figure above there are two possible
    paths between A and B. To use the path via R2, A would send a packet that contains
    R1,R2,R3 as source route. To avoid going via R2, A would place R1,R3 as the source
    route in its transmitted packet. If A knows the complete network topology and
    all link identifiers, it can easily compute the source route towards each destination.
    It can even use different paths, e.g. for redundancy, to reach a given destination.
    However, in a real network hosts do not usually have a map of the entire network
    topology.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述网络中，路由器R2连接到两个出链路。R2连接到R1和R3。R2可以通过与它们交换数据包或观察每个接口接收到的数据包来轻松确定它连接到这两个节点。例如，假设当一个节点（无论是主机还是路由器）启动时，它会通过每个接口发送一个特殊控制数据包来向其邻居通告自己的地址。当一个节点收到这样的数据包时，它会自动回复自己的地址。这种交换也可以用来验证邻居（无论是路由器还是主机）是否仍然存活。在源路由中，数据平面数据包包含一个标识符列表。这个列表被称为源路由。它指示数据包应遵循的路径，作为一系列链路标识符的序列。当一个节点收到这样的数据平面数据包时，它首先检查数据包的目的地是否是直接邻居。在这种情况下，数据包将被转发到该邻居。否则，节点从列表中提取下一个地址并将其转发给邻居。这允许源为每个数据包指定要遵循的显式路径。例如，在上面的图中，A和B之间存在两条可能的路径。要使用通过R2的路径，A会发送一个包含R1、R2、R3作为源路由的数据包。要避免通过R2，A会在其传输的数据包中将R1、R3作为源路由。如果A知道完整的网络拓扑和所有链路标识符，它可以轻松计算到每个目的地的源路由。它甚至可以使用不同的路径，例如，为了冗余，到达给定的目的地。然而，在现实网络中，主机通常不会拥有整个网络拓扑的映射。
- en: In networks that rely on source routing, hosts use control packets to automatically
    discover the best path(s). In addition to the source and destination addresses,
    control packets contain a list that records the intermediate nodes. This list
    is often called the record route because it allows recording the route followed
    by a given packet. When a node receives such a control packet, it first checks
    whether its address is included in the record route. If yes, the packet has already
    been forwarded by this node and it is silently discarded. Otherwise, it adds its
    own address to the record route and forwards the packet to all its interfaces,
    except the interface over which the packet has been received. Thanks to this,
    the control packet can explore all paths between a source and a given destination.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖于源路由的网络中，主机使用控制数据包来自动发现最佳路径。除了源地址和目的地址外，控制数据包还包含一个列表，记录中间节点。这个列表通常被称为记录路由，因为它允许记录给定数据包所遵循的路径。当一个节点收到这样的控制数据包时，它首先检查其地址是否包含在记录路由中。如果是，则表示该数据包已被此节点转发，并且它将被静默丢弃。否则，它将自己的地址添加到记录路由中，并将数据包转发到所有接口，除了接收数据包的接口。正因为如此，控制数据包可以探索源和给定目的地之间的所有路径。
- en: For example, consider again the network topology above. A sends a control packet
    towards B. The initial record route is empty. When R1 receives the packet, it
    adds its own address to the record route and forwards a copy to R2 and another
    to R3. R2 receives the packet, adds itself to the record route and forwards it
    to R3. R3 receives two copies of the packet. The first contains the [R1,R2] record
    route and the second [R1]. In the end, B will receive two control packets containing
    [R1,R2,R3,R4] and [R1,R3,R4] as record routes. B can keep these two paths or select
    the best one and discard the second. A popular heuristic is to select the record
    route of the first received packet as being the best one since this likely corresponds
    to the shortest delay path.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，再次考虑上面的网络拓扑。A向B发送一个控制包。初始记录路由为空。当R1接收到数据包时，它将自己的地址添加到记录路由中，并将一个副本转发给R2，另一个转发给R3。R2接收到数据包，将其自身添加到记录路由中，并将其转发给R3。R3接收到两个数据包副本。第一个包含[R1,R2]记录路由，第二个包含[R1]。最终，B将接收到包含[R1,R2,R3,R4]和[R1,R3,R4]作为记录路由的两个控制包。B可以保留这两条路径或选择其中最好的一条并丢弃第二条。一种流行的启发式方法是选择第一个接收到的记录路由作为最佳路径，因为这很可能对应于最短延迟路径。
- en: With the received record route, B can send a data packet to A. For this, it
    simply reverses the chosen record route. However, we still need to communicate
    the chosen path to A. This can be done by putting the record route inside a control
    packet which is sent back to A over the reverse path. An alternative is to simply
    send a data packet back to A. This packet will travel back to A. To allow A to
    inspect the entire path followed by the data packet, its source route must contain
    all intermediate routers when it is received by A. This can be achieved by encoding
    the source route using a data structure that contains an index and the ordered
    list of node addresses. The index always points to the next address in the source
    route. It is initialized at 0 when a packet is created and incremented by each
    intermediate node.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到记录路由后，B可以向A发送数据包。为此，它只需简单地反转所选的记录路由。然而，我们仍然需要将所选路径传达给A。这可以通过将记录路由放入一个控制包中来实现，该控制包通过反向路径发送回A。另一种选择是简单地向A发送一个数据包。这个数据包将返回到A。为了允许A检查数据包所经过的整个路径，其源路由必须在A接收到时包含所有中间路由器。这可以通过使用包含索引和节点地址有序列表的数据结构来编码源路由来实现。索引始终指向源路由中的下一个地址。当创建数据包时，它初始化为0，并且每个中间节点递增。
- en: The third technique to compute forwarding tables is to rely on a control plane
    using a distributed algorithm. Routers exchange control messages to discover the
    network topology and build their forwarding table based on them. We dedicate a
    more detailed description of such distributed algorithms later in this section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 计算转发表的第三种技术是依赖于使用分布式算法的控制平面。路由器交换控制消息以发现网络拓扑并根据它们构建它们的转发表。我们将在本节稍后更详细地描述这类分布式算法。
- en: Flat or hierarchical addresses[#](#flat-or-hierarchical-addresses "Link to this
    heading")
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面或分层地址[#](#flat-or-hierarchical-addresses "链接到本标题")
- en: The last, but important, point to discuss about the data plane of the networks
    that rely on the datagram mode is their addressing scheme. In the examples above,
    we have used letters to represent the addresses of the hosts and network nodes.
    In practice, all addresses are encoded as a bit string. Most network technologies
    use a fixed size bit string to represent source and destination address. These
    addresses can be organized in two different ways.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，关于依赖于数据报模式的网络数据平面的讨论点是它们的寻址方案。在上面的示例中，我们使用字母来表示主机和网络节点的地址。在实践中，所有地址都被编码为一个位串。大多数网络技术使用固定大小的位串来表示源地址和目的地址。这些地址可以以两种不同的方式组织。
- en: The first organization, which is the one that we have implicitly assumed until
    now, is the flat addressing scheme. Under this scheme, each host and network node
    has a unique address. The unicity of the addresses is important for the operation
    of the network. If two hosts have the same address, it can become difficult for
    the network to forward packets towards this destination. Flat addresses are typically
    used in situations where network nodes and hosts need to be able to communicate
    immediately with unique addresses. These flat addresses are often embedded inside
    the network interface cards. The network card manufacturer creates one unique
    address for each interface and this address is stored in the read-only memory
    of the interface. An advantage of this addressing scheme is that it easily supports
    unstructured and mobile networks. When a host moves, it can attach to another
    network and remain confident that its address is unique and enables it to communicate
    inside the new network.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种组织方式，即我们至今为止隐含假设的方式，是扁平寻址方案。在这种方案下，每个主机和网络节点都有一个唯一的地址。地址的唯一性对于网络操作非常重要。如果两个主机具有相同的地址，网络转发数据包到该目的地可能会变得困难。扁平地址通常用于网络节点和主机需要能够通过唯一地址立即通信的情况。这些扁平地址通常嵌入在网络接口卡中。网络卡制造商为每个接口创建一个唯一的地址，并将此地址存储在接口的只读存储器中。这种寻址方案的一个优点是它易于支持无结构和移动网络。当主机移动时，它可以连接到另一个网络，并确信其地址是唯一的，并且能够在新网络中进行通信。
- en: With flat addressing the lookup operation in the forwarding table can be implemented
    as an exact match. The forwarding table contains the (sorted) list of all known
    destination addresses. When a packet arrives, a network node only needs to check
    whether this address is included in the forwarding table or not. In software,
    this is an O(log(n)) operation if the list is sorted. In hardware, Content Addressable
    Memories can efficiently perform this lookup operation, but their size is usually
    limited.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扁平寻址时，转发表中的查找操作可以实施为精确匹配。转发表包含所有已知目的地址的（排序）列表。当一个数据包到达时，网络节点只需检查此地址是否包含在转发表中。在软件中，如果列表已排序，这是一个
    O(log(n)) 操作。在硬件中，可寻址存储器可以有效地执行此查找操作，但它们的大小通常有限。
- en: A drawback of the flat addressing scheme is that the forwarding tables linearly
    grow with the number of devices in the network. This addressing scheme is notably
    used by Ethernet networks described in chapter [Ethernet](lan.html#chapter-ethernet).
    With this addressing scheme, each forwarding table must contain an entry that
    points to every address reachable inside the network. Since large networks can
    contain tens of millions of hosts or more, this is a major problem on routers
    that need to be able to quickly forward packets. As an illustration, it is interesting
    to consider the case of an interface running at 10 Gbps. Such interfaces are found
    on high-end servers and in various routers today. Assuming a packet size of 1000
    bits, a conservative number, such interface must forward ten million packets every
    second. This implies that a router that receives packets over such a link must
    forward one 1000 bits packet every 100 nanoseconds. This is the same order of
    magnitude as the memory access times of old DRAMs. This delay decreases when packets
    are smaller or as links become faster. High-end routers today support 400 Gbps
    or 800 Gbps line cards.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 扁平寻址方案的一个缺点是转发表会随着网络中设备数量的增加而线性增长。这种寻址方案特别用于第 [以太网](lan.html#chapter-ethernet)
    章节中描述的以太网网络。使用这种寻址方案，每个转发表必须包含一个条目，指向网络内部可到达的每个地址。由于大型网络可以包含数千万甚至更多的主机，这对于需要能够快速转发数据包的路由器来说是一个主要问题。作为一个例子，考虑一个以
    10 Gbps 运行的接口是有趣的。这样的接口现在可以在高端服务器和各种路由器上找到。假设数据包大小为 1000 位，这是一个保守的数字，这样的接口每秒必须转发一千万个数据包。这意味着接收通过此类链路的数据包的路由器必须每
    100 纳秒转发一个 1000 位的数据包。这与旧 DRAM 的内存访问时间在同一数量级。当数据包更小或链路更快时，这种延迟会降低。今天的顶级路由器支持 400
    Gbps 或 800 Gbps 的线路卡。
- en: A widely used alternative to the flat addressing scheme is the hierarchical
    addressing scheme. This addressing scheme builds upon the fact that networks usually
    contain much more hosts than routers. In this case, a first solution to reduce
    the size of the forwarding tables is to create a hierarchy of addresses. This
    is the solution chosen by the post office since postal addresses contain a country,
    sometimes a state or province, a city, a street and finally a street number. When
    an envelope is forwarded by a post office in a remote country, it only looks at
    the destination country, while a post office in the same province will look at
    the city information. Only the post office responsible for a given city will look
    at the street name and only the postman will use the street number. Hierarchical
    addresses provide a similar solution for network addresses. For example, the address
    of an Internet host attached to a campus network could contain in the high-order
    bits an identification of the Internet Service Provider (ISP) that serves the
    campus network. Then, a subsequent block of bits identifies the campus network
    which is one of the customers of the ISP. Finally, the low order bits of the address
    identify the host in the campus network. Both IPv4 and IPv6 use hierarchical addresses.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 平面地址方案的一个广泛使用的替代方案是分层地址方案。这种地址方案基于这样一个事实：网络通常包含比路由器多得多的主机。在这种情况下，减少转发表大小的第一个解决方案是创建地址层次结构。这是邮局选择的方法，因为邮政地址包含国家、有时是州或省、城市、街道，最后是街道号码。当一个信封被一个遥远国家的邮局转发时，它只查看目的地国家，而同一省份的邮局将查看城市信息。只有负责特定城市的邮局会查看街道名称，而只有邮递员会使用街道号码。分层地址为网络地址提供了类似的解决方案。例如，连接到校园网络的互联网主机的地址可以在高阶位中包含为该校园网络服务的互联网服务提供商（ISP）的标识。然后，随后的位块标识了
    ISP 的客户之一——校园网络。最后，地址的低阶位标识了校园网络中的主机。IPv4 和 IPv6 都使用分层地址。
- en: This hierarchical allocation of addresses can be applied in any type of network.
    In practice, the allocation of the addresses must follow the network topology.
    Usually, this is achieved by dividing the addressing space in consecutive blocks
    and then allocating these blocks to different parts of the network. In a small
    network, the simplest solution is to allocate one block of addresses to each network
    node and assign the host addresses from the attached node.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种地址的分层分配可以应用于任何类型的网络。在实践中，地址的分配必须遵循网络拓扑。通常，这是通过将地址空间划分为连续的块，然后将这些块分配给网络的不同部分来实现的。在一个小型网络中，最简单的解决方案是为每个网络节点分配一个地址块，并从连接的节点分配主机地址。
- en: '![Figure made with TikZ](../Images/4bdec978a60e773b93a0a4c896847066.png)'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/4bdec978a60e773b93a0a4c896847066.png)'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 132 A simple network with two hosts and four routers
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图. 132 具有两个主机和四个路由器的简单网络
- en: In figure [Fig. 132](#fig-net-2hosts-4routers), assume that the network uses
    16 bits addresses and that the prefix 01001010 has been assigned to the entire
    network. Since the network contains four routers, the network operator could assign
    one block of sixty-four addresses to each router. R1 would use address 0100101000000000
    while A could use address 0100101000000001. R2 could be assigned all addresses
    from 0100101001000000 to 0100101001111111. R4 could then use 0100101011000000
    and assign 0100101011000001 to B. Other allocation schemes are possible. For example,
    R3 could be allocated a larger block of addresses than R2 and R4 could use a sub-block
    from R3 ‘s address block.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [图. 132](#fig-net-2hosts-4routers) 中，假设该网络使用 16 位地址，并且前缀 01001010 已分配给整个网络。由于该网络包含四个路由器，网络运营商可以为每个路由器分配一个包含六十四个地址的块。R1
    将使用地址 0100101000000000，而 A 可以使用地址 0100101000000001。R2 可以分配从 0100101001000000 到
    0100101001111111 的所有地址。然后 R4 可以使用 0100101011000000 并将 0100101011000001 分配给 B。其他分配方案也是可能的。例如，R3
    可以分配比 R2 和 R4 更大的地址块，而 R4 可以使用 R3 地址块的一个子块。
- en: The main advantage of hierarchical addresses is that it is possible to significantly
    reduce the size of the forwarding tables. In many networks, the number of routers
    can be several orders of magnitude smaller than the number of hosts. A campus
    network may contain a dozen routers and thousands of hosts. The largest Internet
    Services Providers typically contain no more than a few tens of thousands of routers
    but still serve tens or hundreds of millions of hosts.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化地址的主要优势在于可以显著减少转发表的大小。在许多网络中，路由器的数量可以比主机数量小几个数量级。一个校园网络可能包含十几个路由器和数千个主机。最大的互联网服务提供商通常不超过几万个路由器，但仍为数千或数亿个主机提供服务。
- en: Despite their popularity, hierarchical addresses have some drawbacks. Their
    first drawback is that a lookup in the forwarding table is more complex than when
    using flat addresses. For example, on the Internet, network nodes have to perform
    a longest-match to forward each packet. This is partially compensated by the reduction
    in the size of the forwarding tables, but the additional complexity of the lookup
    operation has been a difficulty to implement hardware support for packet forwarding.
    A second drawback of the utilization of hierarchical addresses is that when a
    host connects for the first time to a network, it must contact one router to determine
    its own address. This requires some packet exchanges between the host and some
    routers. Furthermore, if a host moves and is attached to another routers, its
    network address will change. This can be an issue with some mobile hosts.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管层次化地址很受欢迎，但它们也有一些缺点。它们的第一个缺点是，与使用平面地址相比，在转发表中查找更复杂。例如，在互联网上，网络节点必须执行最长匹配来转发每个数据包。这部分的补偿是通过减少转发表的大小，但查找操作的额外复杂性一直是实现硬件支持数据包转发的一个难题。层次化地址使用的第二个缺点是，当主机第一次连接到网络时，它必须联系一个路由器以确定自己的地址。这需要主机和某些路由器之间的一些数据包交换。此外，如果主机移动并连接到另一个路由器，其网络地址将改变。这可能会对某些移动主机造成问题。
- en: Dealing with heterogeneous datalink layers[#](#dealing-with-heterogeneous-datalink-layers
    "Link to this heading")
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异构数据链路层[#](#dealing-with-heterogeneous-datalink-layers "链接到本标题")
- en: Sometimes, the network layer needs to deal with heterogeneous datalink layers.
    For example, two hosts connected to different datalink layers exchange packets
    via routers that are using other types of datalink layers. Thanks to the network
    layer, this exchange of packets is possible provided that each packet can be placed
    inside a datalink layer frame before being transmitted. If all datalink layers
    support the same frame size, this is simple. When a node receives a frame, it
    decapsulates the packet that it contains, checks the header and forwards it, encapsulated
    inside another frame, to the outgoing interface. Unfortunately, the encapsulation
    operation is not always possible. Each datalink layer is characterized by the
    maximum frame size that it supports. Datalink layers typically support frames
    containing up to a few hundreds or a few thousands of bytes. The maximum frame
    size that a given datalink layer supports depends on its underlying technology.
    Unfortunately, most datalink layers support a different maximum frame size. This
    implies that when a host sends a large packet inside a frame to its nexthop router,
    there is a risk that this packet will have to traverse a link that is not capable
    of forwarding the packet inside a single frame. In principle, there are three
    possibilities to solve this problem. To discuss them, we consider a simple scenario
    with two hosts connected to a router as shown in the figure below.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，网络层需要处理异构数据链路层。例如，连接到不同数据链路层的两个主机通过使用其他类型数据链路层的路由器交换数据包。多亏了网络层，只要每个数据包在传输前都能放入数据链路层帧中，这种数据包交换是可能的。如果所有数据链路层都支持相同的帧大小，这很简单。当一个节点接收到一个帧时，它会解封装包含的包，检查头部信息并将其封装在另一个帧中，然后转发到出口接口。不幸的是，封装操作并不总是可行的。每个数据链路层都有其支持的最大的帧大小。数据链路层通常支持包含数百或数千字节的帧。一个特定数据链路层支持的最大的帧大小取决于其底层技术。不幸的是，大多数数据链路层支持不同的最大帧大小。这意味着当一个主机在帧中发送一个大型数据包到其下一跳路由器时，存在这样的风险：这个数据包将不得不穿越一个无法在单个帧中转发数据包的链路。原则上，有三种可能性来解决此问题。为了讨论它们，我们考虑一个简单的场景，其中有两个主机连接到一个路由器，如图下所示。
- en: '![Figure made with TikZ](../Images/b50bd82cdce23b386cd09872d74ee6e1.png)'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作图](../Images/b50bd82cdce23b386cd09872d74ee6e1.png)'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 133 A simple heterogeneous network
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图133 一个简单的异构网络
- en: Consider in the network above that host A wants to send a 900 bytes packet (870
    bytes of payload and 30 bytes of header) to host B via router R1. Host A encapsulates
    this packet inside a single frame. The frame is received by router R1 which extracts
    the packet. Router R1 has three possible options to process this packet.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述网络中，主机A想要通过路由器R1向主机B发送一个900字节的数据包（870字节的负载和30字节的头部）。主机A将这个数据包封装在一个单独的帧中。该帧被路由器R1接收，并从中提取数据包。路由器R1有三个可能处理这个数据包的选项。
- en: The packet is too large and router R1 cannot forward it to router R2. It rejects
    the packet and sends a control packet back to the source (host A) to indicate
    that it cannot forward packets longer than 500 bytes (minus the packet header).
    The source could react to this control packet by retransmitting the information
    in smaller packets.
  id: totrans-243
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包太大，路由器R1无法将其转发到路由器R2。它拒绝该数据包，并向源（主机A）发送一个控制包，表示它无法转发超过500字节（减去数据包头部）的数据包。源可以对此控制包做出反应，通过重新传输更小的数据包来发送信息。
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The network layer is able to fragment a packet. In our example, the router could
    fragment the packet in two parts. The first part contains the beginning of the
    payload and the second the end. There are two possible ways to perform this fragmentation.
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络层能够分片数据包。在我们的例子中，路由器可以将数据包分成两部分。第一部分包含负载的开始部分，第二部分包含结束部分。有两种可能的方法来进行这种分片。
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Router R1 fragments the packet into two fragments before transmitting them to
    router R2. Router R2 reassembles the two packet fragments in a larger packet before
    transmitting them on the link towards host B.
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器R1在将数据包传输到路由器R2之前将其分成两个片段。路由器R2在将数据包片段重新组装成更大的数据包之前，将它们传输到主机B的链路上。
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Each of the packet fragments is a valid packet that contains a header with the
    source (host A) and destination (host B) addresses. When router R2 receives a
    packet fragment, it treats this packet as a regular packet and forwards it to
    its final destination (host B). Host B reassembles the received fragments.
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个数据包片段都是一个有效的数据包，它包含一个带有源地址（主机A）和目标地址（主机B）的头部。当路由器R2接收到一个数据包片段时，它将这个数据包视为一个普通的数据包，并将其转发到其最终目的地（主机B）。主机B重新组装接收到的片段。
- en: These three solutions have advantages and drawbacks. With the first solution,
    routers remain simple and do not need to perform any fragmentation operation.
    This is important when routers are implemented mainly in hardware. However, hosts
    must be complex since they need to store the packets that they produce if they
    need to pass through a link that does not support large packets. This increases
    the buffering required on the hosts.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种解决方案都有优点和缺点。第一种解决方案中，路由器保持简单，不需要执行任何分片操作。这在路由器主要在硬件中实现时非常重要。然而，主机必须复杂，因为它们需要存储它们产生的数据包，如果它们需要通过不支持大数据包的链路，这会增加主机上所需的缓冲区。
- en: Furthermore, a single large packet may potentially need to be retransmitted
    several times. Consider for example a network similar to the one shown above but
    with four routers. Assume that the link R1->R2 supports 1000 bytes packets, link
    R2->R3 800 bytes packets and link R3->R4 600 bytes packets. A host attached to
    R1 that sends large packet will have to first try 1000 bytes, then 800 bytes and
    finally 600 bytes. Fortunately, this scenario does not occur very often in practice
    and this is the reason why this solution is used in real networks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单个大数据包可能需要被重传多次。例如，考虑一个类似于上面显示的网络，但包含四个路由器。假设R1->R2链路支持1000字节的数据包，R2->R3链路支持800字节的数据包，R3->R4链路支持600字节的数据包。连接到R1的主机发送大数据包时，首先尝试1000字节，然后是800字节，最后是600字节。幸运的是，这种情况在实践中并不常见，这也是为什么这种解决方案在真实网络中被使用的原因。
- en: Fragmenting packets on a per-link basis, as presented for the second solution,
    can minimize the transmission overhead since a packet is only fragmented on the
    links where fragmentation is required. Large packets can continue to be used downstream
    of a link that only accepts small packets. However, this reduction of the overhead
    comes with two drawbacks. First, fragmenting packets, potentially on all links,
    increases the processing time and the buffer requirements on the routers. Second,
    this solution leads to a longer end-to-end delay since the downstream router has
    to reassemble all the packet fragments before forwarding the packet.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个链路的基础上对数据包进行分片，正如第二个解决方案所展示的，可以最小化传输开销，因为数据包只在需要分片的情况下才会被分片。大数据包可以继续在只接受小数据包的链路下游使用。然而，这种减少开销的做法有两个缺点。首先，在所有链路上分片数据包，可能会增加路由器的处理时间和缓冲区需求。其次，这个解决方案会导致更长的端到端延迟，因为下游路由器必须在转发数据包之前重新组装所有的数据包片段。
- en: The last solution is a compromise between the two others. Routers need to perform
    fragmentation but they do not need to reassemble packet fragments. Only the hosts
    need to have buffers to reassemble the received fragments. This solution has a
    lower end-to-end delay and requires fewer processing time and memory on the routers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个解决方案是介于其他两个方案之间的折中方案。路由器需要执行分片，但不需要重新组装数据包片段。只有主机需要拥有缓冲区来重新组装接收到的片段。这个解决方案具有更低的端到端延迟，并且需要路由器更少的处理时间和内存。
- en: 'The first solution to the fragmentation problem presented above suggests the
    utilization of control packets to inform the source about the reception of a too
    long packet. This is only one of the functions that are performed by the control
    protocol in the network layer. Other functions include :'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提出的分片问题第一个解决方案建议利用控制包通知源端接收到的数据包过长。这只是网络层控制协议执行的功能之一。其他功能包括：
- en: sending a control packet back to the source if a packet is received by a router
    that does not have a valid entry in its forwarding table
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据包被没有有效条目的转发表的路由器接收，则向源发送控制包
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: sending a control packet back to the source if a router detects that a packet
    is looping inside the network
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由器检测到数据包在网络内部循环，则向源发送控制包
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: verifying that packets can reach a given destination
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据包能否到达指定的目的地
- en: We will discuss these functions in more details when we will describe the protocols
    that are used in the network layer of the TCP/IP protocol suite.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们描述TCP/IP协议套件网络层中使用的协议时，我们将更详细地讨论这些功能。
- en: Computing forwarding tables[#](#computing-forwarding-tables "Link to this heading")
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算转发表[#](#computing-forwarding-tables "链接到本标题")
- en: Networks deployed several techniques to update the forwarding tables upon the
    arrival of a packet. In this section, we briefly present the principles that underlie
    three of these techniques.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 网络部署了多种技术来在数据包到达时更新转发表。在本节中，我们将简要介绍这些技术背后的原理。
- en: The first technique assumes that the underlying network topology is a tree.
    A tree is the simplest network to be considered when forwarding packets. The main
    advantage of using a tree is that there is only one path between any pair of nodes
    inside the network. Since a tree does not contain any cycle, it is impossible
    to have forwarding loops in a tree-shaped network.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术假设底层网络拓扑是一个树。在转发数据包时，树是最简单的网络结构。使用树的主要优势是网络中任意两个节点之间只有一条路径。由于树不包含任何循环，因此在树形网络中不可能出现转发环路。
- en: In a tree-shaped network, it is relatively simple for each node to automatically
    compute its forwarding table by inspecting the packets that it receives. For this,
    each node uses the source and destination addresses present inside each packet.
    Thanks to the source address, a node can learn the location of the different sources
    inside the network. Each source has a unique address. When a node receives a packet
    over a given interface, it learns that the source (address) of this packet is
    reachable via this interface. The node maintains a data structure that maps each
    known source address to an incoming interface. This data structure is often called
    the port-address table since it indicates the interface (or port) to reach a given
    address.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在树形网络中，每个节点通过检查它接收到的数据包来自动计算其转发表相对简单。为此，每个节点使用每个数据包中存在的源和目的地地址。多亏了源地址，一个节点可以学习网络中不同源的位置。每个源都有一个唯一的地址。当一个节点通过某个接口收到一个数据包时，它了解到这个数据包的源（地址）可以通过这个接口访问。节点维护一个将每个已知源地址映射到入接口的数据结构。这个数据结构通常被称为端地址表，因为它指示了到达给定地址的接口（或端口）。
- en: Learning the location of the sources is not sufficient, nodes also need to forward
    packets towards their destination. When a node receives a packet whose destination
    address is already present inside its port-address table, it simply forwards the
    packet on the interface listed in the port-address table. In this case, the packet
    will follow the port-address table entries in the downstream nodes and will reach
    the destination. If the destination address is not included in the port-address
    table, the node simply forwards the packet on all its interfaces, except the interface
    from which the packet was received. Forwarding a packet over all interfaces is
    usually called broadcasting in the terminology of computer networks. Sending the
    packet over all interfaces except one is a costly operation since the packet is
    sent over links that do not reach the destination. Given the tree-shape of the
    network, the packet will explore all downstream branches of the tree and will
    finally reach its destination. In practice, the broadcasting operation does not
    occur too often and its performance impact remains limited.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 仅学习源的位置是不够的，节点还需要将数据包转发到它们的目的地。当一个节点收到一个其目的地地址已经在其端地址表中的数据包时，它只需在端地址表中列出的接口上转发数据包。在这种情况下，数据包将遵循下游节点的端地址表条目并到达目的地。如果目的地地址不包括在端地址表中，节点只需在其所有接口上转发数据包，除了接收数据包的接口。在计算机网络术语中，将数据包转发到所有接口通常称为广播。在除了一个接口之外的所有接口上发送数据包是一种昂贵的操作，因为数据包是通过无法到达目的地的链路发送的。鉴于网络的树形结构，数据包将探索树的所有下游分支，并最终到达目的地。在实践中，广播操作并不太常见，其性能影响仍然有限。
- en: 'To understand the operation of the port-address table, let us consider the
    example network shown in [Fig. 129](#fig-simple-tree-network). This network contains
    three hosts: A, B and C and five routers, R1 to R5. When the network boots, all
    the forwarding tables of the nodes are empty.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解端地址表的操作，让我们考虑图 [图 129](#fig-simple-tree-network) 中所示的示例网络。这个网络包含三个主机：A、B
    和 C 以及五个路由器，R1 到 R5。当网络启动时，所有节点的转发表都是空的。
- en: '![Figure made with TikZ](../Images/d7769586ddea01abce95ea2ac91eaad6.png)'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/d7769586ddea01abce95ea2ac91eaad6.png)'
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 129 A simple tree-shaped network
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 129 一个简单的树形网络
- en: Host A sends a packet towards B. When receiving this packet, R1 learns that
    A is reachable via its West interface. Since it does not have an entry for destination
    B in its port-address table, it forwards the packet to both R2 and R3. When R2
    receives the packet, it updates its own forwarding table and forward the packet
    to C. Since C is not the intended recipient, it simply discards the received packet.
    Router R3 also receives the packet. It learns that A is reachable via its North-West
    interface and broadcasts the packet to R4 and R5. R5 also updates its forwarding
    table and finally forwards it to destination B. Let us now consider what happens
    when B sends a reply to A. R5 first learns that B is attached to its North-East
    port. It then consults its port-address table and finds that A is reachable via
    its North-West interface. The packet is then forwarded hop-by-hop to A without
    any broadcasting. Later on, if C sends a packet to B, this packet will reach R1
    that contains a valid forwarding entry in its forwarding table.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 主机A向B发送一个数据包。当R1接收到这个数据包时，它了解到A可以通过其西接口到达。由于它在端口地址表中没有为目的地B的条目，它将数据包转发给R2和R3。当R2接收到数据包时，它更新自己的转发表并将数据包转发给C。由于C不是预期的接收者，它简单地丢弃了接收到的数据包。路由器R3也接收到了数据包。它了解到A可以通过其西北接口到达，并将数据包广播给R4和R5。R5也更新了其转发表，最终将数据包转发到目的地B。现在让我们考虑当B向A发送回复时会发生什么。R5首先了解到B连接到其东北端口。然后它查阅自己的端口地址表，发现A可以通过其西北接口到达。然后数据包逐跳转发到A，没有任何广播。稍后，如果C向B发送一个数据包，这个数据包将到达包含有效转发条目的R1。
- en: By inspecting the source and destination addresses of packets, network nodes
    can automatically derive their forwarding tables. As we will discuss later, this
    technique is used in [Ethernet](../glossary.html#term-Ethernet) networks. Despite
    being widely used, it has two important drawbacks. First, packets sent to unknown
    destinations must be broadcasted in the network even if the destination is not
    attached to the network. Consider the transmission of ten packets destined to
    Z in the network above. When a node receives a packet towards this destination,
    it can only broadcast that packet. Since Z is not attached to the network, no
    node will ever receive a packet whose source is Z to update its forwarding table.
    The second and more important problem is that few networks have a tree-shaped
    topology. It is interesting to analyze what happens when a port-address table
    is used in a network that contains a cycle. Consider the simple network shown
    in [Fig. 130](#fig-simple-redundant-network) with a single host.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查数据包的源地址和目的地址，网络节点可以自动推导出它们的转发表。正如我们稍后将要讨论的，这种技术在[以太网](../glossary.html#term-Ethernet)网络中使用。尽管这种方法被广泛使用，但它有两个重要的缺点。首先，即使目的地没有连接到网络，发送到未知目的地的数据包也必须在网络中广播。考虑在上述网络中向Z发送的十个数据包的传输。当一个节点收到指向该目的地的数据包时，它只能广播该数据包。由于Z没有连接到网络，没有任何节点会收到源地址为Z的数据包来更新其转发表。第二个且更为重要的问题是，很少有网络具有树形拓扑结构。分析在包含环路的网络中使用端口地址表时的情况是很有趣的。考虑[图130](#fig-simple-redundant-network)中显示的简单且冗余的网络。
- en: '![Figure made with TikZ](../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png)'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/38c0d2a02efb7e43f6ff0cfbb7ed0c76.png)'
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 130 A simple and redundant network
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图130 一个简单且冗余的网络
- en: Assume that the network has started and all port-address and forwarding tables
    are empty. Host A sends a packet towards B. Upon reception of this packet, R1
    updates its port-address table. Since B is not present in the port-address table,
    the packet is broadcasted. Both R2 and R3 receive a copy of the packet sent by
    A. They both update their port-address table. Unfortunately, they also both broadcast
    the received packet. B receives a first copy of the packet, but R3 and R2 receive
    it again. R3 will then broadcast this copy of the packet to B and R1 while R2
    will broadcast its copy to R1. Although B has already received two copies of the
    packet, it is still inside the network and continues to loop. Due to the presence
    of the cycle, a single packet towards an unknown destination generates many copies
    of this packet that loop and will eventually saturate the network. Network operators
    who are using port-address tables to automatically compute the forwarding tables
    also use distributed algorithms to ensure that the network topology is always
    a tree.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 假设网络已启动，所有端口地址和转发表都是空的。主机 A 向 B 发送一个数据包。当接收到这个数据包时，R1 更新其端口地址表。由于 B 不在端口地址表中，该数据包被广播。R2
    和 R3 都收到了 A 发送的数据包副本。它们都更新了它们的端口地址表。不幸的是，它们也同时广播了接收到的数据包。B 收到了数据包的第一个副本，但 R3 和
    R2 又收到了它。然后 R3 将这个数据包副本广播给 B 和 R1，而 R2 将其副本广播给 R1。尽管 B 已经收到了两个数据包副本，但它仍然在网络中，并继续循环。由于存在循环，一个未知目标的数据包会产生许多循环的数据包副本，最终会饱和网络。使用端口地址表自动计算转发表的网络操作员也使用分布式算法来确保网络拓扑始终是树形结构。
- en: 'Another technique called source routing can be used to automatically compute
    forwarding tables. It has been used in interconnecting Token Ring networks and
    in some wireless networks. Intuitively, source routing enables a destination to
    automatically discover the paths from a given source towards itself. This technique
    requires nodes to encode information inside some packets. For simplicity, let
    us assume that the data plane supports two types of packets :'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种称为源路由的技术可以用来自动计算转发表。它已被用于连接令牌环网络和某些无线网络。直观地说，源路由允许目标自动发现从给定源到自身的路径。这种技术要求节点在数据包中编码信息。为了简单起见，让我们假设数据平面支持两种类型的数据包：
- en: the data packets
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包
- en: ''
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the control packets
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制包
- en: Data packets are used to exchange data while control packets are used to discover
    the paths between hosts. With source routing, routers can be kept as simple as
    possible and all the complexity is placed on the hosts. This is in contrast with
    the previous technique where the nodes had to maintain a port-address and a forwarding
    table while the hosts simply sent and received packets. Each node is configured
    with one unique address and there is one identifier per outgoing link. For simplicity
    and to avoid cluttering the figures with those identifiers, we assume that each
    node uses as link identifiers north, west, south,… In practice, a node would associate
    one integer to each outgoing link. This is illustrated in [Fig. 131](#fig-simple-2hosts-4routers).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包用于交换数据，而控制包用于发现主机之间的路径。使用源路由，可以将路由器保持得尽可能简单，并将所有复杂性放在主机上。这与先前的技术形成对比，其中节点必须维护端口地址和转发表，而主机只是发送和接收数据包。每个节点配置了一个唯一的地址，每个出链路都有一个标识符。为了简单起见，避免在图中添加这些标识符，我们假设每个节点使用北、西、南等作为链路标识符。在实际中，节点会将一个整数与每个出链路关联。这如图
    [图 131](#fig-simple-2hosts-4routers) 所示。
- en: '![Figure made with TikZ](../Images/4bdec978a60e773b93a0a4c896847066.png)'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/4bdec978a60e773b93a0a4c896847066.png)'
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 131 A simple network with two hosts and four routers
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 131 具有两个主机和四个路由器的简单网络
- en: In the network above, router R2 is attached to two outgoing links. R2 is connected
    to both R1 and R3. R2 can easily determine that it is connected to these two nodes
    by exchanging packets with them or observing the packets that it receives over
    each interface. Assume for example that when a node (either host or router) starts,
    it sends a special control packet over each of its interfaces to advertise its
    own address to its neighbors. When a node receives such a packet, it automatically
    replies with its own address. This exchange can also be used to verify whether
    a neighbor, either router or host, is still alive. With source routing, the data
    plane packets include a list of identifiers. This list is called a source route.
    It indicates the path to be followed by the packet as a sequence of link identifiers.
    When a node receives such a data plane packet, it first checks whether the packet’s
    destination is a direct neighbor. In this case, the packet is forwarded to this
    neighbor. Otherwise, the node extracts the next address from the list and forwards
    it to the neighbor. This allows the source to specify the explicit path to be
    followed for each packet. For example, in the figure above there are two possible
    paths between A and B. To use the path via R2, A would send a packet that contains
    R1,R2,R3 as source route. To avoid going via R2, A would place R1,R3 as the source
    route in its transmitted packet. If A knows the complete network topology and
    all link identifiers, it can easily compute the source route towards each destination.
    It can even use different paths, e.g. for redundancy, to reach a given destination.
    However, in a real network hosts do not usually have a map of the entire network
    topology.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述网络中，路由器R2连接了两个出链路。R2与R1和R3都相连。R2可以通过与它们交换数据包或观察每个接口接收到的数据包来轻松确定自己连接到这两个节点。例如，当一个节点（无论是主机还是路由器）启动时，它会通过每个接口发送一个特殊的控制数据包来向邻居通告自己的地址。当一个节点收到这样的数据包时，它会自动回复自己的地址。这种交换也可以用来验证邻居（无论是路由器还是主机）是否仍然存活。在源路由中，数据平面数据包包含一个标识符列表。这个列表被称为源路由，它指示数据包应遵循的路径，即一系列链路标识符。当一个节点收到这样的数据平面数据包时，它首先检查数据包的目的地是否是直接邻居。在这种情况下，数据包被转发到这个邻居。否则，节点从列表中提取下一个地址并将其转发给邻居。这允许源节点为每个数据包指定要遵循的显式路径。例如，在上面的图中，A和B之间存在两条可能的路径。要使用通过R2的路径，A会发送一个包含R1、R2、R3作为源路由的数据包。要避免通过R2，A会在其传输的数据包中将R1、R3作为源路由。如果A知道完整的网络拓扑和所有链路标识符，它可以轻松地计算到每个目的地的源路由。它甚至可以使用不同的路径，例如为了冗余，到达给定的目的地。然而，在现实网络中，主机通常不会拥有整个网络拓扑的映射。
- en: In networks that rely on source routing, hosts use control packets to automatically
    discover the best path(s). In addition to the source and destination addresses,
    control packets contain a list that records the intermediate nodes. This list
    is often called the record route because it allows recording the route followed
    by a given packet. When a node receives such a control packet, it first checks
    whether its address is included in the record route. If yes, the packet has already
    been forwarded by this node and it is silently discarded. Otherwise, it adds its
    own address to the record route and forwards the packet to all its interfaces,
    except the interface over which the packet has been received. Thanks to this,
    the control packet can explore all paths between a source and a given destination.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖于源路由的网络中，主机使用控制数据包来自动发现最佳路径。除了源地址和目的地址外，控制数据包还包含一个列表，记录中间节点。这个列表通常被称为记录路由，因为它允许记录给定数据包遵循的路径。当一个节点收到这样的控制数据包时，它首先检查自己的地址是否包含在记录路由中。如果是，则表示数据包已经被这个节点转发，并且它会被静默丢弃。否则，它会将自己的地址添加到记录路由中，并将数据包转发到所有接口，除了接收数据包的接口。因此，控制数据包可以探索源节点和给定目的地之间的所有路径。
- en: For example, consider again the network topology above. A sends a control packet
    towards B. The initial record route is empty. When R1 receives the packet, it
    adds its own address to the record route and forwards a copy to R2 and another
    to R3. R2 receives the packet, adds itself to the record route and forwards it
    to R3. R3 receives two copies of the packet. The first contains the [R1,R2] record
    route and the second [R1]. In the end, B will receive two control packets containing
    [R1,R2,R3,R4] and [R1,R3,R4] as record routes. B can keep these two paths or select
    the best one and discard the second. A popular heuristic is to select the record
    route of the first received packet as being the best one since this likely corresponds
    to the shortest delay path.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，再次考虑上面的网络拓扑。A向B发送一个控制包。初始记录路由为空。当R1接收到数据包时，它将自己的地址添加到记录路由中，并将一个副本转发给R2，另一个转发给R3。R2接收到数据包，将其自身添加到记录路由中，并将其转发给R3。R3接收到两个数据包副本。第一个包含[R1,R2]记录路由，第二个包含[R1]。最后，B将接收到包含[R1,R2,R3,R4]和[R1,R3,R4]作为记录路由的两个控制包。B可以保留这两条路径或选择其中最好的一条并丢弃第二条。一种流行的启发式方法是选择第一个接收到的记录路由作为最佳路径，因为这很可能对应于最短延迟路径。
- en: With the received record route, B can send a data packet to A. For this, it
    simply reverses the chosen record route. However, we still need to communicate
    the chosen path to A. This can be done by putting the record route inside a control
    packet which is sent back to A over the reverse path. An alternative is to simply
    send a data packet back to A. This packet will travel back to A. To allow A to
    inspect the entire path followed by the data packet, its source route must contain
    all intermediate routers when it is received by A. This can be achieved by encoding
    the source route using a data structure that contains an index and the ordered
    list of node addresses. The index always points to the next address in the source
    route. It is initialized at 0 when a packet is created and incremented by each
    intermediate node.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接收到的记录路由，B可以向A发送数据包。为此，它只需简单地反转所选的记录路由。然而，我们仍然需要将所选路径传达给A。这可以通过将记录路由放入一个控制包中来实现，该控制包通过反向路径发送回A。另一种选择是简单地向A发送一个数据包。这个数据包将返回到A。为了允许A检查数据包所经过的整个路径，其源路由必须在A接收到时包含所有中间路由器。这可以通过使用包含索引和节点地址有序列表的数据结构来编码源路由来实现。索引始终指向源路由中的下一个地址。当创建数据包时，它初始化为0，并且每个中间节点递增。
- en: The third technique to compute forwarding tables is to rely on a control plane
    using a distributed algorithm. Routers exchange control messages to discover the
    network topology and build their forwarding table based on them. We dedicate a
    more detailed description of such distributed algorithms later in this section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 计算转发表的第三种技术是依赖于使用分布式算法的控制平面。路由器交换控制消息以发现网络拓扑并根据它们构建它们的转发表。我们将在本节稍后更详细地描述此类分布式算法。
- en: Flat or hierarchical addresses[#](#flat-or-hierarchical-addresses "Link to this
    heading")
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面或分层地址[#](#flat-or-hierarchical-addresses "链接到本标题")
- en: The last, but important, point to discuss about the data plane of the networks
    that rely on the datagram mode is their addressing scheme. In the examples above,
    we have used letters to represent the addresses of the hosts and network nodes.
    In practice, all addresses are encoded as a bit string. Most network technologies
    use a fixed size bit string to represent source and destination address. These
    addresses can be organized in two different ways.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，关于依赖于数据报模式的网络数据平面的讨论点是它们的寻址方案。在上面的例子中，我们使用字母来表示主机和网络节点的地址。在实践中，所有地址都被编码为一个位串。大多数网络技术使用固定大小的位串来表示源地址和目的地址。这些地址可以以两种不同的方式组织。
- en: The first organization, which is the one that we have implicitly assumed until
    now, is the flat addressing scheme. Under this scheme, each host and network node
    has a unique address. The unicity of the addresses is important for the operation
    of the network. If two hosts have the same address, it can become difficult for
    the network to forward packets towards this destination. Flat addresses are typically
    used in situations where network nodes and hosts need to be able to communicate
    immediately with unique addresses. These flat addresses are often embedded inside
    the network interface cards. The network card manufacturer creates one unique
    address for each interface and this address is stored in the read-only memory
    of the interface. An advantage of this addressing scheme is that it easily supports
    unstructured and mobile networks. When a host moves, it can attach to another
    network and remain confident that its address is unique and enables it to communicate
    inside the new network.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组织，也就是我们至今隐含假设的那个，是平面寻址方案。在这种方案下，每个主机和网络节点都有一个唯一的地址。地址的唯一性对于网络的运行至关重要。如果两个主机拥有相同的地址，网络在转发数据包到该目的地时可能会变得困难。平面地址通常用于网络节点和主机需要能够立即通过唯一地址进行通信的情况。这些平面地址通常嵌入在网络接口卡中。网卡制造商为每个接口创建一个唯一的地址，并将该地址存储在接口的只读存储器中。这种寻址方案的一个优点是它很容易支持无结构和移动网络。当主机移动时，它可以连接到另一个网络，并且可以确信其地址是唯一的，并且能够使其在新网络中通信。
- en: With flat addressing the lookup operation in the forwarding table can be implemented
    as an exact match. The forwarding table contains the (sorted) list of all known
    destination addresses. When a packet arrives, a network node only needs to check
    whether this address is included in the forwarding table or not. In software,
    this is an O(log(n)) operation if the list is sorted. In hardware, Content Addressable
    Memories can efficiently perform this lookup operation, but their size is usually
    limited.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平面寻址，转发表中的查找操作可以实施为精确匹配。转发表包含所有已知目标地址的（排序）列表。当一个数据包到达时，网络节点只需检查此地址是否包含在转发表中。在软件中，如果列表已排序，这是一个O(log(n))的操作。在硬件中，可寻址存储器可以有效地执行此查找操作，但它们的大小通常有限。
- en: A drawback of the flat addressing scheme is that the forwarding tables linearly
    grow with the number of devices in the network. This addressing scheme is notably
    used by Ethernet networks described in chapter [Ethernet](lan.html#chapter-ethernet).
    With this addressing scheme, each forwarding table must contain an entry that
    points to every address reachable inside the network. Since large networks can
    contain tens of millions of hosts or more, this is a major problem on routers
    that need to be able to quickly forward packets. As an illustration, it is interesting
    to consider the case of an interface running at 10 Gbps. Such interfaces are found
    on high-end servers and in various routers today. Assuming a packet size of 1000
    bits, a conservative number, such interface must forward ten million packets every
    second. This implies that a router that receives packets over such a link must
    forward one 1000 bits packet every 100 nanoseconds. This is the same order of
    magnitude as the memory access times of old DRAMs. This delay decreases when packets
    are smaller or as links become faster. High-end routers today support 400 Gbps
    or 800 Gbps line cards.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 平面寻址方案的缺点是转发表会随着网络中设备数量的线性增长而增长。这种寻址方案特别用于第[以太网](lan.html#chapter-ethernet)章中描述的以太网网络。使用这种寻址方案，每个转发表必须包含一个指向网络内部可达的每个地址的条目。由于大型网络可以包含数千万甚至更多的主机，这对于需要能够快速转发数据包的路由器来说是一个主要问题。作为一个例子，考虑一个以10
    Gbps运行的接口是有趣的。这样的接口现在可以在高端服务器和各种路由器上找到。假设数据包大小为1000位，这是一个保守的数字，这样的接口每秒必须转发一千万个数据包。这意味着接收通过这种链路的数据包的路由器必须每100纳秒转发一个1000位的数据包。这与旧DRAM的内存访问时间在同一数量级。当数据包更小或链路更快时，这种延迟会降低。今天的顶级路由器支持400
    Gbps或800 Gbps的线路卡。
- en: A widely used alternative to the flat addressing scheme is the hierarchical
    addressing scheme. This addressing scheme builds upon the fact that networks usually
    contain much more hosts than routers. In this case, a first solution to reduce
    the size of the forwarding tables is to create a hierarchy of addresses. This
    is the solution chosen by the post office since postal addresses contain a country,
    sometimes a state or province, a city, a street and finally a street number. When
    an envelope is forwarded by a post office in a remote country, it only looks at
    the destination country, while a post office in the same province will look at
    the city information. Only the post office responsible for a given city will look
    at the street name and only the postman will use the street number. Hierarchical
    addresses provide a similar solution for network addresses. For example, the address
    of an Internet host attached to a campus network could contain in the high-order
    bits an identification of the Internet Service Provider (ISP) that serves the
    campus network. Then, a subsequent block of bits identifies the campus network
    which is one of the customers of the ISP. Finally, the low order bits of the address
    identify the host in the campus network. Both IPv4 and IPv6 use hierarchical addresses.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与平面地址方案广泛使用的替代方案是分层地址方案。这种地址方案基于这样一个事实，即网络通常包含比路由器多得多的主机。在这种情况下，减少转发表大小的第一个解决方案是创建地址的层次结构。这是邮局选择的方法，因为邮政地址包含国家、有时是州或省、城市、街道，最后是街道号码。当一个信封被一个遥远国家的邮局转发时，它只查看目的地国家，而同一个省份的邮局将查看城市信息。只有负责特定城市的邮局会查看街道名称，而只有邮递员会使用街道号码。分层地址为网络地址提供了类似的解决方案。例如，连接到校园网络的互联网主机的地址可以在高阶位中包含为该校园网络服务的互联网服务提供商（ISP）的标识。然后，随后的位块标识了
    ISP 的客户之一——校园网络。最后，地址的低阶位标识了校园网络中的主机。IPv4 和 IPv6 都使用分层地址。
- en: This hierarchical allocation of addresses can be applied in any type of network.
    In practice, the allocation of the addresses must follow the network topology.
    Usually, this is achieved by dividing the addressing space in consecutive blocks
    and then allocating these blocks to different parts of the network. In a small
    network, the simplest solution is to allocate one block of addresses to each network
    node and assign the host addresses from the attached node.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这种地址的分层分配可以应用于任何类型的网络。在实践中，地址的分配必须遵循网络拓扑。通常，这是通过将地址空间划分为连续的块，然后将这些块分配给网络的不同部分来实现的。在一个小型的网络中，最简单的解决方案是将一个地址块分配给每个网络节点，并从连接的节点分配主机地址。
- en: '![Figure made with TikZ](../Images/4bdec978a60e773b93a0a4c896847066.png)'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/4bdec978a60e773b93a0a4c896847066.png)'
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 132 A simple network with two hosts and four routers
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 132 一个包含两个主机和四个路由器的简单网络
- en: In figure [Fig. 132](#fig-net-2hosts-4routers), assume that the network uses
    16 bits addresses and that the prefix 01001010 has been assigned to the entire
    network. Since the network contains four routers, the network operator could assign
    one block of sixty-four addresses to each router. R1 would use address 0100101000000000
    while A could use address 0100101000000001. R2 could be assigned all addresses
    from 0100101001000000 to 0100101001111111. R4 could then use 0100101011000000
    and assign 0100101011000001 to B. Other allocation schemes are possible. For example,
    R3 could be allocated a larger block of addresses than R2 and R4 could use a sub-block
    from R3 ‘s address block.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [图 132](#fig-net-2hosts-4routers) 中，假设网络使用 16 位地址，并且前缀 01001010 已经分配给了整个网络。由于网络包含四个路由器，网络运营商可以为每个路由器分配一个包含
    64 个地址的块。R1 将使用地址 0100101000000000，而 A 可以使用地址 0100101000000001。R2 可以分配从 0100101001000000
    到 0100101001111111 的所有地址。然后 R4 可以使用 0100101011000000 并将 0100101011000001 分配给 B。其他分配方案也是可能的。例如，R3
    可以分配比 R2 和 R4 更大的地址块，而 R4 可以使用 R3 地址块的一个子块。
- en: The main advantage of hierarchical addresses is that it is possible to significantly
    reduce the size of the forwarding tables. In many networks, the number of routers
    can be several orders of magnitude smaller than the number of hosts. A campus
    network may contain a dozen routers and thousands of hosts. The largest Internet
    Services Providers typically contain no more than a few tens of thousands of routers
    but still serve tens or hundreds of millions of hosts.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 分层地址的主要优点是，可以显著减少转发表的大小。在许多网络中，路由器的数量可以比主机数量小几个数量级。一个校园网络可能包含十几个路由器和数千个主机。最大的互联网服务提供商通常不超过几万个路由器，但仍然为数千或数亿个主机提供服务。
- en: Despite their popularity, hierarchical addresses have some drawbacks. Their
    first drawback is that a lookup in the forwarding table is more complex than when
    using flat addresses. For example, on the Internet, network nodes have to perform
    a longest-match to forward each packet. This is partially compensated by the reduction
    in the size of the forwarding tables, but the additional complexity of the lookup
    operation has been a difficulty to implement hardware support for packet forwarding.
    A second drawback of the utilization of hierarchical addresses is that when a
    host connects for the first time to a network, it must contact one router to determine
    its own address. This requires some packet exchanges between the host and some
    routers. Furthermore, if a host moves and is attached to another routers, its
    network address will change. This can be an issue with some mobile hosts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分层地址很受欢迎，但它们也有一些缺点。它们的第一个缺点是，与使用平面地址相比，在转发表中查找更复杂。例如，在互联网上，网络节点必须执行最长匹配来转发每个数据包。这部分的补偿是通过减少转发表的大小，但查找操作的额外复杂性一直是实现硬件支持数据包转发的一个难题。分层地址使用的第二个缺点是，当主机第一次连接到网络时，它必须联系一个路由器以确定自己的地址。这需要主机和某些路由器之间的一些数据包交换。此外，如果主机移动并连接到另一个路由器，其网络地址将改变。这可能会对某些移动主机造成问题。
- en: Dealing with heterogeneous datalink layers[#](#dealing-with-heterogeneous-datalink-layers
    "Link to this heading")
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异构数据链路层[#](#dealing-with-heterogeneous-datalink-layers "链接到此标题")
- en: Sometimes, the network layer needs to deal with heterogeneous datalink layers.
    For example, two hosts connected to different datalink layers exchange packets
    via routers that are using other types of datalink layers. Thanks to the network
    layer, this exchange of packets is possible provided that each packet can be placed
    inside a datalink layer frame before being transmitted. If all datalink layers
    support the same frame size, this is simple. When a node receives a frame, it
    decapsulates the packet that it contains, checks the header and forwards it, encapsulated
    inside another frame, to the outgoing interface. Unfortunately, the encapsulation
    operation is not always possible. Each datalink layer is characterized by the
    maximum frame size that it supports. Datalink layers typically support frames
    containing up to a few hundreds or a few thousands of bytes. The maximum frame
    size that a given datalink layer supports depends on its underlying technology.
    Unfortunately, most datalink layers support a different maximum frame size. This
    implies that when a host sends a large packet inside a frame to its nexthop router,
    there is a risk that this packet will have to traverse a link that is not capable
    of forwarding the packet inside a single frame. In principle, there are three
    possibilities to solve this problem. To discuss them, we consider a simple scenario
    with two hosts connected to a router as shown in the figure below.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，网络层需要处理异构的数据链路层。例如，连接到不同数据链路层的两个主机通过使用其他类型数据链路层的路由器交换数据包。多亏了网络层，只要每个数据包在传输前都能放入一个数据链路层帧中，这种数据包的交换就是可能的。如果所有数据链路层都支持相同的帧大小，这很简单。当一个节点接收到一个帧时，它会解封装包含的包，检查头部并转发它，封装在另一个帧中，发送到出口接口。不幸的是，封装操作并不总是可能的。每个数据链路层以其支持的最大帧大小为特征。数据链路层通常支持包含数百或数千字节的帧。一个特定数据链路层支持的最大帧大小取决于其底层技术。不幸的是，大多数数据链路层支持不同的最大帧大小。这意味着当一个主机在帧中发送一个大型数据包到其下一跳路由器时，存在这种数据包将不得不穿越一个无法转发单个帧中数据包的链路的风险。原则上，有三种可能性来解决此问题。为了讨论它们，我们考虑一个简单的场景，其中有两个主机连接到一个路由器，如图所示。
- en: '![Figure made with TikZ](../Images/b50bd82cdce23b386cd09872d74ee6e1.png)'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/b50bd82cdce23b386cd09872d74ee6e1.png)'
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 133 A simple heterogeneous network
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 133 一个简单的异构网络
- en: Consider in the network above that host A wants to send a 900 bytes packet (870
    bytes of payload and 30 bytes of header) to host B via router R1. Host A encapsulates
    this packet inside a single frame. The frame is received by router R1 which extracts
    the packet. Router R1 has three possible options to process this packet.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上面的网络，如果主机 A 想通过路由器 R1 向主机 B 发送一个 900 字节的数据包（870 字节的负载和 30 字节的头部），主机 A 将这个数据包封装在一个单独的帧中。该帧被路由器
    R1 接收，并从中提取数据包。路由器 R1 有三种可能的处理这个数据包的方法。
- en: The packet is too large and router R1 cannot forward it to router R2. It rejects
    the packet and sends a control packet back to the source (host A) to indicate
    that it cannot forward packets longer than 500 bytes (minus the packet header).
    The source could react to this control packet by retransmitting the information
    in smaller packets.
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包太大，路由器 R1 无法将其转发到路由器 R2。它拒绝该数据包，并向源（主机 A）发送一个控制包，表明它无法转发超过 500 字节（减去数据包头部）的数据包。源可以对此控制包做出反应，通过发送更小的数据包重新传输信息。
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The network layer is able to fragment a packet. In our example, the router could
    fragment the packet in two parts. The first part contains the beginning of the
    payload and the second the end. There are two possible ways to perform this fragmentation.
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络层能够分片数据包。在我们的例子中，路由器可以将数据包分成两部分。第一部分包含负载的开始部分，第二部分包含结束部分。有两种可能的方法来进行这种分片。
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Router R1 fragments the packet into two fragments before transmitting them to
    router R2. Router R2 reassembles the two packet fragments in a larger packet before
    transmitting them on the link towards host B.
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器 R1 在将数据包传输到路由器 R2 之前将其分成两个片段。路由器 R2 在将数据包片段传输到主机 B 的链路之前，将这两个数据包片段重新组装成更大的数据包。
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Each of the packet fragments is a valid packet that contains a header with the
    source (host A) and destination (host B) addresses. When router R2 receives a
    packet fragment, it treats this packet as a regular packet and forwards it to
    its final destination (host B). Host B reassembles the received fragments.
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个数据包片段都是一个有效的数据包，它包含一个带有源（主机 A）和目的（主机 B）地址的头部。当路由器 R2 接收到一个数据包片段时，它将这个数据包视为一个常规数据包，并将其转发到其最终目的地（主机
    B）。主机 B 将接收到的片段重新组装。
- en: These three solutions have advantages and drawbacks. With the first solution,
    routers remain simple and do not need to perform any fragmentation operation.
    This is important when routers are implemented mainly in hardware. However, hosts
    must be complex since they need to store the packets that they produce if they
    need to pass through a link that does not support large packets. This increases
    the buffering required on the hosts.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种解决方案各有优缺点。使用第一种解决方案时，路由器保持简单，不需要执行任何分片操作。当路由器主要在硬件中实现时，这一点很重要。然而，主机必须复杂，因为它们需要存储它们产生的数据包，如果需要通过不支持大包的链路传输。这增加了主机上所需的缓冲区大小。
- en: Furthermore, a single large packet may potentially need to be retransmitted
    several times. Consider for example a network similar to the one shown above but
    with four routers. Assume that the link R1->R2 supports 1000 bytes packets, link
    R2->R3 800 bytes packets and link R3->R4 600 bytes packets. A host attached to
    R1 that sends large packet will have to first try 1000 bytes, then 800 bytes and
    finally 600 bytes. Fortunately, this scenario does not occur very often in practice
    and this is the reason why this solution is used in real networks.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单个大包可能需要被重传多次。例如，考虑一个类似于上面显示的网络，但包含四个路由器。假设链路 R1->R2 支持最多 1000 字节的数据包，链路
    R2->R3 支持 800 字节的数据包，链路 R3->R4 支持 600 字节的数据包。连接到 R1 的主机发送大包时，首先尝试 1000 字节，然后是
    800 字节，最后是 600 字节。幸运的是，这种情况在实践中并不常见，这也是为什么这种解决方案在真实网络中被采用的原因。
- en: Fragmenting packets on a per-link basis, as presented for the second solution,
    can minimize the transmission overhead since a packet is only fragmented on the
    links where fragmentation is required. Large packets can continue to be used downstream
    of a link that only accepts small packets. However, this reduction of the overhead
    comes with two drawbacks. First, fragmenting packets, potentially on all links,
    increases the processing time and the buffer requirements on the routers. Second,
    this solution leads to a longer end-to-end delay since the downstream router has
    to reassemble all the packet fragments before forwarding the packet.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 按链路分片数据包，如第二种解决方案所示，可以最小化传输开销，因为数据包只在需要分片的链路上进行分片。大数据包可以在只接受小数据包的链路下游继续使用。然而，这种开销的减少伴随着两个缺点。首先，在所有链路上分片数据包可能会增加路由器的处理时间和缓冲区需求。其次，这种解决方案会导致更长的端到端延迟，因为下游路由器必须在转发数据包之前重新组装所有的数据包片段。
- en: The last solution is a compromise between the two others. Routers need to perform
    fragmentation but they do not need to reassemble packet fragments. Only the hosts
    need to have buffers to reassemble the received fragments. This solution has a
    lower end-to-end delay and requires fewer processing time and memory on the routers.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种解决方案是在前两种方案之间的折衷。路由器需要执行分片操作，但它们不需要重新组装数据包片段。只有主机需要拥有缓冲区来重新组装接收到的片段。这种解决方案具有更低的端到端延迟，并且对路由器的处理时间和内存需求更少。
- en: 'The first solution to the fragmentation problem presented above suggests the
    utilization of control packets to inform the source about the reception of a too
    long packet. This is only one of the functions that are performed by the control
    protocol in the network layer. Other functions include :'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提出的分片问题第一种解决方案建议使用控制数据包来通知源端关于接收到的过长数据包的情况。这只是网络层控制协议执行的功能之一。其他功能包括：
- en: sending a control packet back to the source if a packet is received by a router
    that does not have a valid entry in its forwarding table
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由器收到一个在其转发表中没有有效条目的数据包，则向源端发送一个控制数据包
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: sending a control packet back to the source if a router detects that a packet
    is looping inside the network
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路由器检测到数据包在网络内部循环，则向源端发送一个控制数据包
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: verifying that packets can reach a given destination
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据包能否到达指定的目的地
- en: We will discuss these functions in more details when we will describe the protocols
    that are used in the network layer of the TCP/IP protocol suite.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们描述TCP/IP协议套件网络层中使用的协议时，我们将更详细地讨论这些功能。
- en: Virtual circuit organization[#](#virtual-circuit-organization "Link to this
    heading")
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟电路组织[#](#virtual-circuit-organization "链接到本标题")
- en: The second organization of the network layer, called virtual circuits, has been
    inspired by the organization of telephone networks. Telephone networks have been
    designed to carry phone calls that usually last a few minutes. Each phone is identified
    by a telephone number and is attached to a telephone switch. To initiate a phone
    call, a telephone first needs to send the destination’s phone number to its local
    switch. The switch cooperates with the other switches in the network to create
    a bi-directional channel between the two telephones through the network. This
    channel will be used by the two telephones during the lifetime of the call and
    will be released at the end of the call. Until the 1960s, most of these channels
    were created manually, by telephone operators, upon request of the caller. Today’s
    telephone networks use automated switches and allow several channels to be carried
    over the same physical link, but the principles roughly remain the same.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层的第二种组织方式，称为虚拟电路，其灵感来源于电话网络的组织。电话网络被设计用来承载通常持续几分钟的电话通话。每部电话通过电话号码进行标识，并连接到电话交换机。为了发起电话通话，电话首先需要将其目的地的电话号码发送到其本地交换机。交换机与网络中的其他交换机合作，在网络中为两部电话创建一个双向通道。这个通道将在通话期间被两部电话使用，并在通话结束时释放。直到20世纪60年代，大多数这些通道都是通过电话操作员手动创建的，根据呼叫者的请求。今天的电话网络使用自动化交换机，并允许在相同的物理链路上传输多个通道，但基本原则大致相同。
- en: 'In a network using virtual circuits, all hosts are also identified with a network
    layer address. However, packet forwarding is not performed by looking at the destination
    address of each packet. With the virtual circuit organization, each data packet
    contains one label [[1]](#flabels). A label is an integer which is part of the
    packet header. Routers implement label switching to forward labelled data packet.
    Upon reception of a packet, a router consults its label forwarding table to find
    the outgoing interface for this packet. In contrast with the datagram mode, this
    lookup is very simple. The label forwarding table is an array stored in memory
    and the label of the incoming packet is the index to access this array. This implies
    that the lookup operation has an O(1) complexity in contrast with other packet
    forwarding techniques. To ensure that on each node the packet label is an index
    in the label forwarding table, each router that forwards a packet replaces the
    label of the forwarded packet with the label found in the label forwarding table.
    Each entry of the label forwarding table contains two pieces of information :'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚拟电路的网络中，所有主机也使用网络层地址进行标识。然而，数据包转发不是通过查看每个数据包的目的地址来完成的。在虚拟电路组织结构中，每个数据包包含一个标签
    [[1]](#flabels)。标签是一个整数，它是数据包头部的一部分。路由器通过标签交换来转发标记数据包。在接收到数据包后，路由器会查阅其标签转发表以找到该数据包的输出接口。与数据报模式相比，这种查找非常简单。标签转发表是存储在内存中的数组，而进入数据包的标签是该数组的索引。这意味着查找操作具有O(1)的复杂度，与其它数据包转发技术相比。为了确保每个节点上的数据包标签是标签转发表中的索引，每个转发数据包的路由器都会将转发数据包的标签替换为标签转发表中找到的标签。标签转发表的每个条目包含两块信息：
- en: the outgoing interface for the packet
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包的输出接口
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the label for the outgoing packet
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出数据包的标签
- en: For example, consider the label forwarding table of a network node below.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下网络节点的标签转发表。
- en: '| index | outgoing interface | label |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | South | 7 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 0 | South | 7 |'
- en: '| 1 | none | none |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 1 | none | none |'
- en: '| 2 | West | 2 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 2 | West | 2 |'
- en: '| 3 | East | 2 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 3 | East | 2 |'
- en: If this node receives a packet with label=2, it forwards the packet on its West
    interface and sets the label of the outgoing packet to 2. If the received packet’s
    label is set to 3, then the packet is forwarded over the East interface and the
    label of the outgoing packet is set to 2. If a packet is received with a label
    field set to 1, the packet is discarded since the corresponding label forwarding
    table entry is invalid.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个节点接收到标签=2的数据包，它将数据包转发到其西接口，并将输出数据包的标签设置为2。如果接收到的数据包的标签设置为3，则数据包将通过东接口转发，输出数据包的标签也设置为2。如果一个数据包的标签字段设置为1，则该数据包将被丢弃，因为相应的标签转发表条目是无效的。
- en: 'Label switching enables a full control over the path followed by packets inside
    the network. Consider the network below and assume that we want to use two virtual
    circuits : R1->R3->R4->R2->R5 and R2->R1->R3->R4->R5.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 标签交换使得网络内部数据包所遵循的路径完全可控。考虑以下网络，并假设我们想要使用两个虚拟电路：R1->R3->R4->R2->R5和R2->R1->R3->R4->R5。
- en: '![Figure made with TikZ](../Images/c5fa5b3b06d080fc6776a20d0bcd17c6.png)'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c5fa5b3b06d080fc6776a20d0bcd17c6.png)'
- en: ''
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 134 An example of network where label switching can be applied to tune
    its paths
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图134：一个可以应用标签交换来调整其路径的网络示例
- en: 'To create these virtual circuits, we need to configure the label forwarding
    tables of all routers. For simplicity, assume that a label forwarding table only
    contains two entries. Assume that R5 wants to receive the packets from the virtual
    circuit created by R1 (resp. R2) with label=1 (label=0). R4 could use the following
    label forwarding table:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这些虚拟电路，我们需要配置所有路由器的标签转发表。为了简化，假设一个标签转发表只包含两个条目。假设R5想要接收由R1（或R2）创建的、标签=1（标签=0）的虚拟电路中的数据包。R4可以使用以下标签转发表：
- en: '| R4’s label forwarding table |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| R4的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | ->R2 | 1 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ->R2 | 1 |'
- en: '| 1 | ->R5 | 0 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R5 | 0 |'
- en: 'Since a packet received with label=1 must be forwarded to R5 with label=1,
    R2’s label forwarding table could contain :'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于带有标签=1的数据包必须转发到R5且标签也为1，R2的标签转发表可能包含：
- en: '| R2’s label forwarding table |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| R2的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | none | none |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 0 | none | none |'
- en: '| 1 | ->R5 | 1 |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R5 | 1 |'
- en: Two virtual circuits pass through R3. They both need to be forwarded to R4,
    but R4 expects label=1 for packets belonging to the virtual circuit originated
    by R2 and label=0 for packets belonging to the other virtual circuit. R3 could
    choose to leave the labels unchanged.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 两个虚拟电路通过R3。它们都需要转发到R4，但R4期望属于由R2发起的虚拟电路的数据包使用标签=1，而属于另一个虚拟电路的数据包使用标签=0。R3可以选择保持标签不变。
- en: '| R3’s label forwarding table |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| R3的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | ->R4 | 0 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ->R4 | 0 |'
- en: '| 1 | ->R4 | 1 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R4 | 1 |'
- en: 'With the above label forwarding table, R1 needs to originate the packets that
    belong to the R1->R3->R4->R2->R5 circuit with label=0. The packets received from
    R2 and belonging to the R2->R1->R3->R4->R5 circuit would then use label=1 on the
    R1-R3 link. R1 ‘s label forwarding table could be built as follows :'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述标签转发表，R1需要发起属于R1->R3->R4->R2->R5电路且标签为0的数据包。从R2接收到的属于R2->R1->R3->R4->R5电路的数据包将在R1-R3链路上使用标签=1。R1的标签转发表可以构建如下：
- en: '| R1’s label forwarding table |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| R1的标签转发表 |'
- en: '| index | outgoing interface | label |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 输出接口 | 标签 |'
- en: '| 0 | ->R3 | 0 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ->R3 | 0 |'
- en: '| 1 | ->R3 | 1 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ->R3 | 1 |'
- en: The figure below shows the path followed by the packets on the R1->R3->R4->R2->R5
    path in red with on each arrow the label used in the packets.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在R1->R3->R4->R2->R5路径上数据包所遵循的路径，用红色表示，每条箭头上的标签表示数据包中使用的标签。
- en: '![Figure made with TikZ](../Images/aac335913fe6b920a1747148900960d0.png)'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/aac335913fe6b920a1747148900960d0.png)'
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 135 The path followed by packets for a specific circuit
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图135 特定电路的数据包所遵循的路径
- en: MultiProtocol Label Switching (MPLS) is the example of a deployed networking
    technology that relies on label switching. MPLS is more complex than the above
    description because it has been designed to be easily integrated with datagram
    technologies. However, the principles remain. Asynchronous Transfer Mode (ATM)
    and Frame Relay are other examples of technologies that rely on label switching.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 多协议标签交换（MPLS）是依赖标签交换的已部署网络技术的例子。MPLS比上述描述更复杂，因为它被设计成易于与数据报技术集成。然而，原理仍然是。异步传输模式（ATM）和帧中继是其他依赖标签交换技术的例子。
- en: 'Nowadays, most deployed networks rely on distributed algorithms, called routing
    protocols, to compute the forwarding tables that are installed on the routers.
    These distributed algorithms are part of the control plane. They are usually implemented
    in software and are executed on the main CPU of the routers. There are two main
    families of routing protocols : distance vector routing and link state routing.
    Both are capable of discovering autonomously the network and react dynamically
    to topology changes.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数部署的网络都依赖于分布式算法，称为路由协议，来计算安装在路由器上的转发表。这些分布式算法是控制平面的一部分。它们通常在软件中实现，并在路由器的主CPU上执行。主要有两种路由协议家族：距离矢量路由和链路状态路由。两者都能够自主发现网络，并能够动态地响应拓扑变化。
- en: Footnotes
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: The control plane[#](#the-control-plane "Link to this heading")
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制平面[#](#the-control-plane "链接到本标题")
- en: One of the objectives of the control plane in the network layer is to maintain
    the routing tables that are used on all routers. As indicated earlier, a routing
    table is a data structure that contains, for each destination address (or block
    of addresses) known by the router, the outgoing interface over which the router
    must forward a packet destined to this address. The routing table may also contain
    additional information such as the address of the next router on the path towards
    the destination or an estimation of the cost of this path.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层控制平面的一个目标是在所有路由器上维护路由表。如前所述，路由表是一种数据结构，它包含路由器所知的每个目标地址（或地址块），以及路由器必须转发到该地址的输出接口。路由表还可以包含其他信息，例如路径上下一个路由器的地址或该路径成本的估计。
- en: In this section, we discuss the main techniques that can be used to maintain
    the forwarding tables in a network.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论可以用来维护网络中转发表的主要技术。
- en: '## Distance vector routing[#](#distance-vector-routing "Link to this heading")'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '## 距离矢量路由[#](#distance-vector-routing "链接到本标题")'
- en: Distance vector routing is a simple distributed routing protocol. Distance vector
    routing allows routers to automatically discover the destinations reachable inside
    the network as well as the shortest path to reach each of these destinations.
    The shortest path is computed based on metrics or costs that are associated to
    each link. We use l.cost to represent the metric that has been configured for
    link l on a router.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 距离向量路由是一种简单的分布式路由协议。距离向量路由允许路由器自动发现网络内可达的目的地以及到达每个这些目的地的最短路径。最短路径是基于与每个链路关联的度量或成本计算的。我们使用
    l.cost 来表示在路由器上为链路 l 配置的度量。
- en: 'Each router maintains a routing table. The routing table R can be modeled as
    a data structure that stores, for each known destination address d, the following
    attributes :'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由器维护一个路由表。路由表 R 可以建模为一个数据结构，它存储每个已知目的地地址 d 的以下属性：
- en: R[d].link is the outgoing link that the router uses to forward packets towards
    destination d
  id: totrans-388
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[d].link 是路由器用于转发数据包到目的地 d 的出链路
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: R[d].cost is the sum of the metrics of the links that compose the shortest path
    to reach destination d
  id: totrans-391
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[d].cost 是到达目的地 d 的最短路径上链路度量的总和
- en: ''
  id: totrans-392
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-393
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: R[d].time is the timestamp of the last distance vector containing destination
    d
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[d].time 是包含目的地 d 的最后距离向量的时间戳
- en: A router that uses distance vector routing regularly sends its distance vector
    over all its interfaces. This distance vector is a summary of the router’s routing
    table that indicates the distance towards each known destination. This distance
    vector can be computed from the routing table by using the pseudo-code below.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用距离向量路由的路由器定期通过其所有接口发送其距离向量。这个距离向量是路由表的一个总结，它指示每个已知目的地的距离。这个距离向量可以通过以下伪代码从路由表中计算得出。
- en: '[PRE0]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When a router boots, it does not know any destination in the network and its
    routing table only contains its local address(es). It thus sends to all its neighbors
    a distance vector that contains only its address at a distance of 0. When a router
    receives a distance vector on link l, it processes it as follows.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器启动时，它不知道网络中的任何目的地，其路由表只包含其本地地址。因此，它向所有邻居发送一个只包含其地址且距离为 0 的距离向量。当路由器通过链路
    l 接收到一个距离向量时，它按以下方式处理它。
- en: '[PRE1]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The router iterates over all addresses included in the distance vector. If
    the distance vector contains a destination address that the router does not know,
    it inserts it inside its routing table via link l and at a distance which is the
    sum between the distance indicated in the distance vector and the cost associated
    to link l. If the destination was already known by the router, it only updates
    the corresponding entry in its routing table if either :'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器遍历距离向量中包含的所有地址。如果距离向量包含路由器不知道的目的地地址，它通过链路 l 将其插入其路由表，距离是距离向量中指示的距离与链路 l 相关的成本之和。如果目的地已经由路由器知道，它只在其路由表中更新相应的条目，如果以下任一条件成立：
- en: the cost of the new route is smaller than the cost of the already known route
    ((V[d].cost + l.cost) < R[d].cost)
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新路由的成本小于已知路由的成本（(V[d].cost + l.cost) < R[d].cost）
- en: ''
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the new route was learned over the same link as the current best route towards
    this destination (R[d].link == l)
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新路由是在与当前最佳路由到该目的地相同的链路上学习的（R[d].link == l）
- en: The first condition ensures that the router discovers the shortest path towards
    each destination. The second condition is used to take into account the changes
    of routes that may occur after a link failure or a change of the metric associated
    to a link.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件确保路由器发现到每个目的地的最短路径。第二个条件用于考虑在链路故障或链路相关度量变化后可能发生的路由变化。
- en: To understand the operation of a distance vector protocol, let us consider the
    network of five routers shown in [Fig. 136](#fig-dv-5routers).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解距离向量协议的操作，让我们考虑图 [Fig. 136](#fig-dv-5routers) 中显示的五个路由器的网络。
- en: '![Figure made with TikZ](../Images/2fa610c73105286d66d016e10c05cd70.png)'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/2fa610c73105286d66d016e10c05cd70.png)'
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 136 Operation of distance vector routing in a simple network
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 136 简单网络中距离向量路由的操作
- en: Assume that router A is the first to send its distance vector [A=0].
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 假设路由器 A 是第一个发送其距离向量 [A=0] 的路由器。
- en: B and D process the received distance vector and update their routing table
    with a route towards A.
  id: totrans-410
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B 和 D 处理接收到的距离向量，并使用指向 A 的路由更新它们的路由表。
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-412
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: D sends its distance vector [D=0,A=1] to A and E. E can now reach A and D.
  id: totrans-413
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: D 向 A 和 E 发送其距离向量 [D=0,A=1]。现在 E 可以到达 A 和 D。
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: C sends its distance vector [C=0] to B and E
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: C向B和E发送其距离矢量[C=0]
- en: ''
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: E sends its distance vector [E=0,D=1,A=2,C=1] to D, B and C. B can now reach
    A, C, D and E
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: E向D、B和C发送其距离矢量\[E=0,D=1,A=2,C=1\]。现在，B可以到达A、C、D和E。
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: B sends its distance vector [B=0,A=1,C=1,D=2,E=1] to A, C and E. A, B, C and
    E can now reach all five routers of this network.
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B向A、C和E发送其距离矢量[B=0,A=1,C=1,D=2,E=1]。现在，A、B、C和E可以到达这个网络中的所有五个路由器。
- en: ''
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A sends its distance vector [A=0,B=1,C=2,D=1,E=2] to B and D.
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A向B和D发送其距离矢量[A=0,B=1,C=2,D=1,E=2]。
- en: At this point, all routers can reach all other routers in the network thanks
    to the routing tables shown in figure [Fig. 137](#fig-dv-5routers-tables).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，所有路由器都可以通过图[图137](#fig-dv-5routers-tables)中显示的路由表到达网络中的所有其他路由器。
- en: '![Figure made with TikZ](../Images/7c1f3aa75ce05eb9400c684329583c9a.png)'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/7c1f3aa75ce05eb9400c684329583c9a.png)'
- en: ''
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 137 Routing tables computed by distance vector in a simple network
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图137：简单网络中计算出的距离矢量路由表
- en: '[PRE2]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To deal with link and router failures, routers use the timestamp stored in their
    routing table. As all routers send their distance vector every N seconds, the
    timestamp of each route should be regularly refreshed. Thus no route should have
    a timestamp older than N seconds, unless the route is not reachable anymore. In
    practice, to cope with the possible loss of a distance vector due to transmission
    errors, routers check the timestamp of the routes stored in their routing table
    every N seconds and remove the routes that are older than \(3 \times N\) seconds.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理链路和路由器故障，路由器使用其路由表中存储的时间戳。由于所有路由器每N秒发送一次距离矢量，因此每个路由的时间戳应该定期刷新。因此，没有路由的时间戳应该早于N秒，除非该路由不再可达。在实践中，为了应对由于传输错误可能丢失的距离矢量，路由器每N秒检查其路由表中存储的路由的时间戳，并删除超过\(3
    \times N\)秒的路由。
- en: When a router notices that a route towards a destination has expired, it must
    first associate an \(\infty\) cost to this route and send its distance vector
    to its neighbors to inform them. The route can then be removed from the routing
    table after some time (e.g. \(3 \times N\) seconds), to ensure that the neighboring
    routers have received the bad news, even if some distance vectors do not reach
    them due to transmission errors.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个路由器注意到通往目的地的路由已过期时，它必须首先将一个∞成本关联到这条路由，并将其距离矢量发送给其邻居以通知他们。然后，在一段时间后（例如，\(3
    \times N\)秒），可以从路由表中删除该路由，以确保相邻的路由器已经收到了坏消息，即使由于传输错误，某些距离矢量没有到达它们。
- en: Consider the example above and assume that the link between routers A and B
    fails. Before the failure, A used B to reach destinations B, C and E while B only
    used the A-B link to reach A. The two routers detect the failure by the timeouts
    in the affected entries in their routing tables. Both routers A and B send their
    distance vector.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上述示例并假设路由器A和B之间的链路发生故障。在故障之前，A使用B到达目的地B、C和E，而B仅使用A-B链路到达A。两个路由器通过它们路由表中受影响条目的超时来检测故障。A和B两个路由器都发送它们的距离矢量。
- en: A sends its distance vector \([A=0,B=\infty,C=\infty,D=1,E=\infty]\). D knows
    that it cannot reach B anymore via A
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A发送其距离矢量\[A=0,B=∞,C=∞,D=1,E=∞\]。D知道它不能再通过A到达B。
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: D sends its distance vector \([D=0,B=\infty,A=1,C=2,E=1]\) to A and E. A recovers
    routes towards C and E via D.
  id: totrans-437
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: D向A和E发送其距离矢量\[D=0,B=∞,A=1,C=2,E=1\]。A通过D恢复了通往C和E的路由。
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: B sends its distance vector \([B=0,A=\infty,C=1,D=2,E=1]\) to E and C. C learns
    that there is no route anymore to reach A via B.
  id: totrans-440
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B向E和C发送其距离矢量\[B=0,A=∞,C=1,D=2,E=1\]。C了解到通过B到达A的路径不再存在。
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-442
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: E sends its distance vector \([E=0,A=2,C=1,D=1,B=1]\) to D, B and C. D learns
    a route towards B. C and B learn a route towards A.
  id: totrans-443
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: E向D、B和C发送其距离矢量\[E=0,A=2,C=1,D=1,B=1\]。D学习了一条通往B的路由。C和B学习了一条通往A的路由。
- en: At this point, all routers have a routing table allowing them to reach all other
    routers, except router A, which cannot yet reach router B. A recovers the route
    towards B once router D sends its updated distance vector \([A=1,B=2,C=2,D=0,E=1]\).
    This last step is illustrated in figure [Fig. 138](#fig-dv-5routers-failure),
    which shows the routing tables on all routers.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，所有路由器都有一个路由表，允许它们到达网络中的所有其他路由器，除了路由器A，它还不能到达路由器B。一旦路由器D发送其更新的距离矢量\[A=1,B=2,C=2,D=0,E=1\]，A就恢复了通往B的路由。这一最后步骤在图[图138](#fig-dv-5routers-failure)中说明，该图显示了所有路由器上的路由表。
- en: '![Figure made with TikZ](../Images/f6f46399afab72ccf3c3eb51d5f05021.png)'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/f6f46399afab72ccf3c3eb51d5f05021.png)'
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 138 Routing tables computed by distance vector after a failure
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图138：故障后计算出的距离矢量路由表
- en: 'Consider now that the link between D and E fails. The network is now partitioned
    into two disjoint parts: (A , D) and (B, E, C). The routes towards B, C and E
    expire first on router D. At this time, router D updates its routing table.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 D 和 E 之间的链路故障。网络现在被分割成两个不相交的部分：(A , D) 和 (B, E, C)。路由到 B、C 和 E 的路由在路由器
    D 上首先过期。此时，路由器 D 更新其路由表。
- en: If D sends \([D=0, A=1, B=\infty, C=\infty, E=\infty]\), A learns that B, C
    and E are unreachable and updates its routing table.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 D 发送 \([D=0, A=1, B=\infty, C=\infty, E=\infty]\)，A 将了解到 B、C 和 E 不可达，并更新其路由表。
- en: 'Unfortunately, if the distance vector sent to A is lost or if A sends its own
    distance vector ( \([A=0,D=1,B=3,C=3,E=2]\) ) at the same time as D sends its
    distance vector, D updates its routing table to use the shorter routes advertised
    by A towards B, C and E. After some time D sends a new distance vector : \([D=0,A=1,E=3,C=4,B=4]\).
    A updates its routing table and after some time sends its own distance vector
    \([A=0,D=1,B=5,C=5,E=4]\), etc. This problem is known as the count to infinity
    problem in the networking literature.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果发送给 A 的距离矢量丢失，或者如果 A 在 D 发送其距离矢量（ \([A=0,D=1,B=3,C=3,E=2]\) ）的同时发送自己的距离矢量，D
    将更新其路由表以使用 A 向 B、C 和 E 通告的较短路由。经过一段时间后，D 发送新的距离矢量：\([D=0,A=1,E=3,C=4,B=4]\)。A
    更新其路由表，并在一段时间后发送自己的距离矢量 \([A=0,D=1,B=5,C=5,E=4]\)，等等。这个问题在计算机网络文献中被称为无限计数问题。
- en: Routers A and D exchange distance vectors with increasing costs until these
    costs reach \(\infty\). This problem may occur in other scenarios than the one
    depicted in the above figure. In fact, distance vector routing may suffer from
    count to infinity problems as soon as there is a cycle in the network. Unfortunately,
    cycles are widely used in networks since they provide the required redundancy
    to deal with link and router failures. To mitigate the impact of counting to infinity,
    some distance vector protocols consider that \(16=\infty\). Unfortunately, this
    limits the metrics that network operators can use and the diameter of the networks
    using distance vectors.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器 A 和 D 以递增的成本交换距离矢量，直到这些成本达到 \(\infty\)。这个问题可能发生在除了上述图示之外的其他场景中。事实上，距离矢量路由可能在网络中存在环的情况下立即遭受无限计数问题。不幸的是，环在网络中被广泛使用，因为它们提供了处理链路和路由器故障所需的红冗余。为了减轻无限计数的影响，一些距离矢量协议认为
    \(16=\infty\)。不幸的是，这限制了网络运营商可以使用的方法和使用距离矢量的网络的直径。
- en: This count to infinity problem occurs because router A advertises to router
    D a route that it has learned via router D. A possible solution to avoid this
    problem could be to change how a router creates its distance vector. Instead of
    computing one distance vector and sending it to all its neighbors, a router could
    create a distance vector that is specific to each neighbor and only contains the
    routes that have not been learned via this neighbor. This could be implemented
    by the following pseudocode.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这种无限计数问题发生是因为路由器 A 向路由器 D 通告了一条通过路由器 D 学习的路由。避免这种问题的可能解决方案之一是改变路由器创建其距离矢量的方式。而不是计算一个距离矢量并将其发送给所有邻居，路由器可以创建一个针对每个邻居的特定距离矢量，并且只包含通过此邻居未学习到的路由。这可以通过以下伪代码实现。
- en: '[PRE3]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This technique is called split-horizon. With this technique, the count to infinity
    problem would not have happened in the above scenario, as router A would have
    advertised \([A=0]\) after the failure, since it learned all its other routes
    via router D. Another variant called split-horizon with poison reverse is also
    possible. Routers using this variant advertise a cost of \(\infty\) for the destinations
    that they reach via the router to which they send the distance vector. This can
    be implemented by using the pseudo-code below.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为分割视域。使用这种技术，在上述场景中不会发生无限计数问题，因为路由器 A 在故障后将会通告 \([A=0]\)，因为它通过路由器 D 学习了所有其他路由。另一种称为带毒回溯的分割视域的变体也是可能的。使用这种变体的路由器会通告通过它们发送距离矢量的路由器到达的目的地的成本为
    \(\infty\)。这可以通过以下伪代码实现。
- en: '[PRE4]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unfortunately, split-horizon is not sufficient to avoid all count to infinity
    problems with distance vector routing. Consider the failure of link A-B in the
    four routers network shown in figure [Fig. 139](#fig-dv-4routers-count).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，分割视域（split-horizon）不足以避免距离矢量路由中所有无限计数问题。考虑图[图 139](#fig-dv-4routers-count)中所示的四路由器网络中链路
    A-B 的故障。
- en: '![Figure made with TikZ](../Images/52e88a9b6b9535c5fb1a69d33e6abe9d.png)'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/52e88a9b6b9535c5fb1a69d33e6abe9d.png)'
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 139 Count to infinity problem
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 139 无限计数问题
- en: 'After having detected the failure, router B sends its distance vectors:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到故障后，路由器B发送其距离矢量：
- en: \([A=\infty,B=0,C=\infty,E=1]\) to router C
  id: totrans-461
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: \([A=\infty,B=0,C=\infty,E=1]\) 到路由器C
- en: ''
  id: totrans-462
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-463
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \([A=\infty,B=0,C=1,E=\infty]\) to router E
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: \([A=\infty,B=0,C=1,E=\infty]\) 到路由器E
- en: If, unfortunately, the distance vector sent to router C is lost due to a transmission
    error or because router C is overloaded, a new count to infinity problem can occur.
    If router C sends its distance vector \([A=2,B=1,C=0,E=\infty]\) to router E,
    this router installs a route of distance 3 to reach A via C. Router E sends its
    distance vectors \([A=3,B=\infty,C=1,E=1]\) to router B and \([A=\infty,B=1,C=\infty,E=0]\)
    to router C. This distance vector allows B to recover a route of distance 4 to
    reach A.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不幸的是，由于传输错误或路由器C过载，发送到路由器C的距离矢量丢失，可能会出现新的无限计数问题。如果路由器C将其距离矢量 \([A=2,B=1,C=0,E=\infty]\)
    发送到路由器E，则该路由器安装了一条通过C到达A的距离为3的路由。路由器E将其距离矢量 \([A=3,B=\infty,C=1,E=1]\) 发送到路由器B，并将其
    \([A=\infty,B=1,C=\infty,E=0]\) 发送到路由器C。这个距离矢量允许B恢复一条距离为4到达A的路由。
- en: '[PRE5]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Forwarding tables versus routing tables
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 转发表与路由表
- en: Routers usually maintain at least two data structures that contain information
    about the reachable destinations. The first data structure is the routing table.
    The routing table is a data structure that associates a destination to an outgoing
    interface or a nexthop router and a set of additional attributes. Different routing
    protocols can associate different attributes for each destination. Distance vector
    routing protocols will store the cost to reach the destination along the shortest
    path. Other routing protocols may store information about the number of hops of
    the best path, its lifetime or the number of sub paths. A routing table may store
    different paths towards a given destination and flag one of them as the best one.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器通常维护至少两个包含可达目的地信息的数据结构。第一个数据结构是路由表。路由表是一种将目的地与出接口或下一跳路由器以及一组附加属性关联起来的数据结构。不同的路由协议可以为每个目的地关联不同的属性。距离矢量路由协议将存储到达目的地的最短路径的成本。其他路由协议可能存储有关最佳路径的跳数、其生存期或子路径数的信息。路由表可能存储到达给定目的地的不同路径，并将其中之一标记为最佳路径。
- en: 'The routing table is a software data structure which is updated by (one or
    more) routing protocols. The routing table is usually not directly used when forwarding
    packets. Packet forwarding relies on a more compact data structure which is the
    forwarding table. On high-end routers, the forwarding table is implemented directly
    in hardware while lower performance routers will use a software implementation.
    A forwarding table contains a subset of the information found in the routing table.
    It only contains the nexthops towards each destination that are used to forward
    packets and no attributes. A forwarding table will typically associate each destination
    to one or more outgoing interface or nexthop router.  ## Link state routing[#](#link-state-routing
    "Link to this heading")'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '路由表是一种由（一个或多个）路由协议更新的软件数据结构。路由表通常在转发数据包时不会直接使用。数据包转发依赖于一个更紧凑的数据结构，即转发表。在高端路由器上，转发表直接在硬件中实现，而性能较低的路由器将使用软件实现。转发表包含路由表中找到的信息的子集。它只包含用于转发数据包的每个目的地的下一跳，没有属性。转发表通常将每个目的地关联到一个或多个出接口或下一跳路由器。  ##
    链路状态路由[#](#link-state-routing "链接到这个标题")'
- en: Link state routing is the second family of routing protocols. While distance
    vector routers use a distributed algorithm to compute their routing tables, link-state
    routers exchange messages to allow each router to learn the entire network topology.
    Based on this learned topology, each router is then able to compute its routing
    table by using a shortest path computation such as Dijkstra’s algorithm [[Dijkstra1959]](../bibliography.html#dijkstra1959).
    A detailed description of this shortest path algorithm may be found in [[Wikipedia:Dijkstra]](../bibliography.html#wikipedia-dijkstra).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态路由是路由协议的第二大家族。虽然距离矢量路由器使用分布式算法来计算它们的路由表，但链路状态路由器通过交换消息来允许每个路由器学习整个网络拓扑。基于这个学习到的拓扑，每个路由器随后能够通过使用如迪杰斯特拉算法（Dijkstra’s
    algorithm）的最短路径计算来计算其路由表 [[Dijkstra1959]](../bibliography.html#dijkstra1959)。有关此最短路径算法的详细描述，可以在
    [[维基百科:Dijkstra]](../bibliography.html#wikipedia-dijkstra) 中找到。
- en: 'For link-state routing, a network is modeled as a directed weighted graph.
    Each router is a node, and the links between routers are the edges in the graph.
    A positive weight is associated to each directed edge and routers use the shortest
    path to reach each destination. In practice, different types of weights can be
    associated to each directed edge :'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链路状态路由，网络被建模为一个有向加权图。每个路由器是一个节点，路由器之间的链路是图中的边。每个有向边都关联一个正权重，路由器使用最短路径到达每个目的地。在实践中，可以将不同类型的权重关联到每个有向边：
- en: unit weight. If all links have a unit weight, shortest path routing prefers
    the paths with the least number of intermediate routers.
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位权重。如果所有链路都具有单位权重，最短路径路由将优先选择中间路由器数量最少的路径。
- en: ''
  id: totrans-474
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: weight proportional to the propagation delay on the link. If all link weights
    are configured this way, shortest path routing uses the paths with the smallest
    propagation delay.
  id: totrans-476
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重与链路上的传播延迟成正比。如果所有链路权重都这样配置，最短路径路由将使用传播延迟最小的路径。
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-478
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(weight=\frac{C}{bandwidth}\) where C is a constant larger than the highest
    link bandwidth in the network. If all link weights are configured this way, shortest
    path routing prefers higher bandwidth paths over lower bandwidth paths.
  id: totrans-479
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(weight=\frac{C}{bandwidth}\) 其中 C 是一个大于网络中最高链路带宽的常数。如果所有链路权重都这样配置，最短路径路由将优先选择带宽较高的路径，而不是带宽较低的路径。
- en: Usually, the same weight is associated to the two directed edges that correspond
    to a physical link (i.e. \(R1 \rightarrow R2\) and \(R2 \rightarrow R1\)). However,
    nothing in the link state protocols requires this. For example, if the weight
    is set in function of the link bandwidth, then an asymmetric ADSL link could have
    a different weight for the upstream and downstream directions. Other variants
    are possible. Some networks use optimization algorithms to find the best set of
    weights to minimize congestion inside the network for a given traffic demand [[FRT2002]](../bibliography.html#frt2002).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，相同的权重与对应于物理链路的两个有向边相关联（即 \(R1 \rightarrow R2\) 和 \(R2 \rightarrow R1\)）。然而，链路状态协议中没有任何要求必须这样做。例如，如果权重是根据链路带宽设置的，那么不对称的ADSL链路在上行和下行方向上可能具有不同的权重。其他变体也是可能的。一些网络使用优化算法来找到最佳权重集，以最小化给定流量需求下的网络拥塞
    [[FRT2002]](../bibliography.html#frt2002)。
- en: When a link-state router boots, it first needs to discover to which routers
    it is directly connected. For this, each router sends a HELLO message every N
    seconds on all its interfaces. This message contains the router’s address. Each
    router has a unique address. As its neighboring routers also send HELLO messages,
    the router automatically discovers to which neighbors it is connected. These HELLO
    messages are only sent to neighbors that are directly connected to a router, and
    a router never forwards the HELLO messages that it receives. HELLO messages are
    also used to detect link and router failures. A link is considered to have failed
    if no HELLO message has been received from a neighboring router for a period of
    \(k \times N\) seconds. This is illustrated in figure [Fig. 140](#fig-ls-hello).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当链路状态路由器启动时，它首先需要发现它与哪些路由器直接连接。为此，每个路由器在其所有接口上每 N 秒发送一个 HELLO 消息。此消息包含路由器的地址。每个路由器都有一个唯一的地址。随着其邻居路由器也发送
    HELLO 消息，路由器自动发现其连接的邻居。这些 HELLO 消息仅发送给直接连接到路由器的邻居，路由器永远不会转发它接收到的 HELLO 消息。HELLO
    消息还用于检测链路和路由器故障。如果一个邻居路由器在 \(k \times N\) 秒内没有收到 HELLO 消息，则认为链路已失败。这如图 [图 140](#fig-ls-hello)
    所示。
- en: '![Figure made with TikZ](../Images/ed161dec8dab31664eee88d66a4d8f93.png)'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/ed161dec8dab31664eee88d66a4d8f93.png)'
- en: ''
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 140 The exchange of HELLO messages
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 140 HELLO 消息的交换
- en: 'Once a router has discovered its neighbors, it must reliably distribute all
    its outgoing edges to all routers in the network to allow them to compute their
    local view of the network topology. For this, each router builds a link-state
    packet (LSP) containing the following information:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦路由器发现其邻居，它必须可靠地将所有其出边分发给网络中的所有路由器，以便它们计算其网络拓扑的本地视图。为此，每个路由器构建一个包含以下信息的链路状态包（LSP）：
- en: 'LSP.Router: identification (address) of the sender of the LSP'
  id: totrans-486
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Router: LSP 发送者的标识（地址）'
- en: ''
  id: totrans-487
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-488
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.age: age or remaining lifetime of the LSP'
  id: totrans-489
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.age: LSP 的年龄或剩余寿命'
- en: ''
  id: totrans-490
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.seq: sequence number of the LSP'
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.seq: LSP 的序列号'
- en: ''
  id: totrans-493
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-494
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.Links[]: links advertised in the LSP. Each directed link is represented
    with the following information:'
  id: totrans-495
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Links[]: 在 LSP 中宣布的链路。每个有向链路用以下信息表示：'
- en: ''
  id: totrans-496
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-497
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.Links[i].Id: identification of the neighbor'
  id: totrans-498
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Links[i].Id: 邻居的标识'
- en: ''
  id: totrans-499
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.Links[i].cost: cost of the link'
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Links[i].cost: 链路成本'
- en: These LSPs must be reliably distributed inside the network without using the
    router’s routing table since these tables can only be computed once the LSPs have
    been received. The Flooding algorithm is used to efficiently distribute the LSPs
    of all routers. Each router that implements flooding maintains a Link sSate DataBase
    (LSDB) containing the most recent LSP sent by each router. When a router receives
    a LSP, it first verifies whether this LSP is already stored inside its LSDB. If
    so, the router has already distributed the LSP earlier and it does not need to
    forward it. Otherwise, the router forwards the LSP on all its links except the
    link over which the LSP was received. Flooding can be implemented by using the
    following pseudo-code.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 LSP 必须在网络内部可靠地分发，而不使用路由器的路由表，因为这些表只能在收到 LSP 之后计算。泛洪算法用于高效地分发所有路由器的 LSP。每个实现泛洪的路由器都维护一个包含每个路由器发送的最新
    LSP 的链路状态数据库（LSDB）。当路由器收到一个 LSP 时，它首先验证这个 LSP 是否已经存储在其 LSDB 中。如果是这样，该路由器之前已经分发过这个
    LSP，它不需要转发它。否则，路由器在其所有链路上转发 LSP，除了接收 LSP 的链路。可以通过以下伪代码实现泛洪。
- en: '[PRE6]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this pseudo-code, LSDB(r) returns the most recent LSP originating from router
    r that is stored in the LSDB. newer(lsp1, lsp2) returns true if lsp1 is more recent
    than lsp2. See the note below for a discussion on how newer can be implemented.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个伪代码中，LSDB(r) 返回存储在 LSDB 中的来自路由器 r 的最新 LSP。newer(lsp1, lsp2) 如果 lsp1 比 lsp2
    更新则返回 true。有关如何实现 newer 的讨论，请参阅下面的注释。
- en: Note
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Which is the most recent LSP ?
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个是最新的 LSP？
- en: A router that implements flooding must be able to detect whether a received
    LSP is newer than the stored LSP. This requires a comparison between the sequence
    number of the received LSP and the sequence number of the LSP stored in the link
    state database. The ARPANET routing protocol [[MRR1979]](../bibliography.html#mrr1979)
    used a 6 bits sequence number and implemented the comparison as follows [**RFC
    789**](https://datatracker.ietf.org/doc/html/rfc789.html)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 实现泛洪的路由器必须能够检测接收到的 LSP 是否比存储的 LSP 更新。这需要比较接收到的 LSP 的序列号和链路状态数据库中存储的 LSP 的序列号。ARPANET
    路由协议 [[MRR1979]](../bibliography.html#mrr1979) 使用 6 位序列号，并按以下方式实现比较 [**RFC 789**](https://datatracker.ietf.org/doc/html/rfc789.html)。
- en: '[PRE7]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This comparison takes into account the modulo \(2^{6}\) arithmetic used to increment
    the sequence numbers. Intuitively, the comparison divides the circle of all sequence
    numbers into two halves. Usually, the sequence number of the received LSP is equal
    to the sequence number of the stored LSP incremented by one, but sometimes the
    sequence numbers of two successive LSPs may differ, e.g. if one router has been
    disconnected for some time. The comparison above worked well until October 27,
    1980\. On this day, the ARPANET crashed completely. The crash was complex and
    involved several routers. At one point, LSP 40 and LSP 44 from one of the routers
    were stored in the LSDB of some routers in the ARPANET. As LSP 44 was the newest,
    it should have replaced LSP 40 on all routers. Unfortunately, one of the ARPANET
    routers suffered from a memory problem and sequence number 40 (101000 in binary)
    was replaced by 8 (001000 in binary) in the buggy router and flooded. Three LSPs
    were present in the network and 44 was newer than 40 which is newer than 8, but
    unfortunately 8 was considered to be newer than 44… All routers started to exchange
    these three link state packets forever and the only solution to recover from this
    problem was to shutdown the entire network [**RFC 789**](https://datatracker.ietf.org/doc/html/rfc789.html).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较考虑了用于增加序列号的模 \(2^{6}\) 算术。直观上，比较将所有序列号的圆圈分成两半。通常，接收到的 LSP 的序列号等于存储的 LSP
    的序列号加一，但有时两个连续的 LSP 的序列号可能不同，例如，如果一个路由器断开连接了一段时间。上述比较直到 1980 年 10 月 27 日一直有效。在这一天，ARPANET
    完全崩溃。这次崩溃很复杂，涉及多个路由器。在某个时刻，来自一个路由器的 LSP 40 和 LSP 44 存储在 ARPANET 中一些路由器的链路状态数据库（LSDB）中。由于
    LSP 44 是最新的，它应该在所有路由器上替换 LSP 40。不幸的是，ARPANET 中的一个路由器出现了内存问题，序列号 40（二进制为 101000）在有缺陷的路由器中被替换为
    8（二进制为 001000）并进行了泛洪。网络中存在三个 LSP，44 比 40 更新，而 40 比 8 更新，但不幸的是，8 被认为是比 44 更新的……所有路由器开始永久交换这三个链路状态包，解决这个问题的唯一方法是关闭整个网络
    [**RFC 789**](https://datatracker.ietf.org/doc/html/rfc789.html)。
- en: Current link state routing protocols usually use 32 bits sequence numbers and
    include a special mechanism in the unlikely case that a sequence number reaches
    the maximum value (with a 32 bits sequence number space, it takes 136 years to
    cycle the sequence numbers if a link state packet is generated every second).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的链路状态路由协议通常使用 32 位序列号，并在序列号达到最大值（在 32 位序列号空间中，如果每秒生成一个链路状态数据包，则需 136 年才能循环序列号）的不太可能情况下包含一个特殊机制。
- en: To deal with the memory corruption problem, link state packets contain a checksum
    or CRC. This checksum is computed by the router that generates the LSP. Each router
    must verify the checksum when it receives or floods an LSP. Furthermore, each
    router must periodically verify the checksums of the LSPs stored in its LSDB.
    This enables them to cope with memory errors that could corrupt the LSDB as the
    one that occurred in the ARPANET.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理内存损坏问题，链路状态数据包包含校验和或 CRC。这个校验和是由生成 LSP 的路由器计算的。每个路由器在接收或洪泛 LSP 时都必须验证校验和。此外，每个路由器必须定期验证其
    LSDB 中存储的 LSP 的校验和。这使得它们能够应对可能损坏 LSDB 的内存错误，就像在 ARPANET 中发生的那样。
- en: Flooding is illustrated in figure [Fig. 141](#fig-ls-flooding). By exchanging
    HELLO messages, each router learns its direct neighbors. For example, router E
    learns that it is directly connected to routers D, B and C. Its first LSP has
    sequence number 0 and contains the directed links E->D, E->B and E->C. Router
    E sends its LSP on all its links and routers D, B and C insert the LSP in their
    LSDB and forward it over their other links.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [图 141](#fig-ls-flooding) 中展示了洪泛过程。通过交换 HELLO 消息，每个路由器学习到它的直接邻居。例如，路由器 E 学习到它与路由器
    D、B 和 C 直接连接。它的第一个链路状态通告（LSP）的序列号为 0，包含有向链路 E->D、E->B 和 E->C。路由器 E 在所有链路上发送其 LSP，而路由器
    D、B 和 C 则将 LSP 插入它们的链路状态数据库（LSDB）并通过它们的其它链路转发。
- en: '![Figure made with TikZ](../Images/e127285ac098a043b65dee85776a39ab.png)'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/e127285ac098a043b65dee85776a39ab.png)'
- en: ''
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 141 Flooding: example'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 141 洪泛：示例
- en: Flooding allows LSPs to be distributed to all routers inside the network without
    relying on routing tables. In the example above, the LSP sent by router E is likely
    to be sent twice on some links in the network. For example, routers B and C receive
    E’s LSP at almost the same time and forward it over the B-C link. To avoid sending
    the same LSP twice on each link, a possible solution is to slightly change the
    pseudo-code above so that a router waits for some random time before forwarding
    a LSP on each link. The drawback of this solution is that the delay to flood an
    LSP to all routers in the network increases. In practice, routers immediately
    flood the LSPs that contain new information (e.g. addition or removal of a link)
    and delay the flooding of refresh LSPs (i.e. LSPs that contain exactly the same
    information as the previous LSP originating from this router) [[FFEB2005]](../bibliography.html#ffeb2005).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 洪泛允许 LSP 在网络内部的所有路由器之间分发，而不依赖于路由表。在上面的例子中，路由器 E 发送的 LSP 可能会在网络的一些链路上发送两次。例如，路由器
    B 和 C 几乎同时接收到 E 的 LSP 并通过 B-C 链路转发它。为了避免在每个链路上发送相同的 LSP 两次，一个可能的解决方案是稍微修改上面的伪代码，使得路由器在转发每个链路上的
    LSP 之前等待一些随机时间。这种解决方案的缺点是，将 LSP 洪泛到网络中所有路由器的延迟增加了。在实践中，路由器立即洪泛包含新信息（例如，链路的添加或删除）的
    LSP，并延迟刷新 LSP（即包含与来自该路由器的上一个 LSP 完全相同信息的 LSP）的洪泛 [[FFEB2005]](../bibliography.html#ffeb2005)。
- en: To ensure that all routers receive all LSPs, even when there are transmissions
    errors, link state routing protocols use reliable flooding. With reliable flooding,
    routers use acknowledgments and if necessary retransmissions to ensure that all
    link state packets are successfully transferred to each neighboring router. Thanks
    to reliable flooding, all routers store in their LSDB the most recent LSP sent
    by each router in the network. By combining the received LSPs with its own LSP,
    each router can build a graph that represents the entire network topology as shown
    in figure [Fig. 142](#fig-ls-lsdb).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有路由器都能接收到所有 LSP，即使在传输错误的情况下，链路状态路由协议使用可靠的洪泛。在可靠洪泛中，路由器使用确认和必要时重新传输来确保所有链路状态数据包都成功传输到每个相邻路由器。多亏了可靠洪泛，所有路由器都在它们的
    LSDB 中存储了网络中每个路由器发送的最新 LSP。通过将接收到的 LSP 与其自身的 LSP 结合，每个路由器可以构建一个表示整个网络拓扑的图，如图 [图
    142](#fig-ls-lsdb) 所示。
- en: '![Figure made with TikZ](../Images/43bd64f4088699d0e20f5a2a28cc52d3.png)'
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/43bd64f4088699d0e20f5a2a28cc52d3.png)'
- en: ''
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 142 Link state databases received by all routers
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 142 所有路由器接收到的链路状态数据库
- en: Note
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Static or dynamic link metrics ?
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 静态或动态链路度量？
- en: As link state packets are flooded regularly, routers are able to measure the
    quality (e.g. delay or load) of their links and adjust the metric of each link
    according to its current quality. Such dynamic adjustments were included in the
    ARPANET routing protocol [[MRR1979]](../bibliography.html#mrr1979) . However,
    experience showed that it was difficult to tune the dynamic adjustments and ensure
    that no forwarding loops occur in the network [[KZ1989]](../bibliography.html#kz1989).
    Today’s link state routing protocols use metrics that are manually configured
    on the routers and are only changed by the network operators or network management
    tools [[FRT2002]](../bibliography.html#frt2002).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 由于链路状态包定期传播，路由器能够测量它们链路的质量（例如延迟或负载），并根据其当前质量调整每个链路的度量。这种动态调整被包含在ARPANET路由协议中
    [[MRR1979]](../bibliography.html#mrr1979)。然而，经验表明，调整动态调整并确保网络中不发生转发环路是困难的 [[KZ1989]](../bibliography.html#kz1989)。今天的链路状态路由协议使用的是在路由器上手动配置的度量，并且只有网络运营商或网络管理工具才能更改
    [[FRT2002]](../bibliography.html#frt2002)。
- en: When a link fails, the two routers attached to the link detect the failure by
    the absence of HELLO messages received during the last \(k \times N\) seconds.
    Once a router has detected the failure of one of its local links, it generates
    and floods a new LSP that no longer contains the failed link. This new LSP replaces
    the previous LSP in the network. In practice, the two routers attached to a link
    do not detect this failure exactly at the same time. During this period, some
    links may be announced in only one direction. This is illustrated in figure [Fig.
    143](#fig-ls-2way). Router E has detected the failure of link E-B and flooded
    a new LSP, but router B has not yet detected this failure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 当链路失败时，连接到该链路的两个路由器通过在最后 \(k \times N\) 秒内收不到HELLO消息来检测到故障。一旦一个路由器检测到其本地链路之一失败，它就会生成并传播一个新的LSP，该LSP不再包含失败的链路。这个新的LSP替换了网络中的先前LSP。在实践中，连接到链路的两个路由器并不完全同时检测到这个故障。在这段时间内，一些链路可能只在一个方向上宣布。这如图
    [图 143](#fig-ls-2way) 所示。路由器E已经检测到链路E-B的故障并传播了一个新的LSP，但路由器B还没有检测到这个故障。
- en: '![Figure made with TikZ](../Images/54c82dddc42e7ee74ac40c1a259a382f.png)'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/54c82dddc42e7ee74ac40c1a259a382f.png)'
- en: ''
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 143 The two-way connectivity check
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 143 双向连通性检查
- en: When a link is reported in the LSP of only one of the attached routers, routers
    consider the link as having failed and they remove it from the directed graph
    that they compute from their LSDB. This is called the two-way connectivity check.
    This check allows link failures to be quickly flooded as a single LSP is sufficient
    to announce such bad news. However, when a link comes up, it can only be used
    once the two attached routers have sent their LSPs. The two-way connectivity check
    also allows for dealing with router failures. When a router fails, all its links
    fail by definition. These failures are reported in the LSPs sent by the neighbors
    of the failed router. The failed router does not, of course, send a new LSP to
    announce its failure. However, in the graph that represents the network, this
    failed router appears as a node that only has outgoing edges. Thanks to the two-way
    connectivity check, this failed router cannot be considered as a transit router
    to reach any destination since no outgoing edge is attached to it.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有连接的其中一个路由器在链路状态协议（LSP）中报告了链路时，路由器会将该链路视为已失败，并从它们从链路状态数据库（LSDB）计算出的有向图中移除它。这被称为双向连通性检查。这个检查允许链路故障迅速地以单个LSP的形式传播，因为单个LSP足以宣布这样的坏消息。然而，当链路恢复时，它只能在两个连接的路由器都发送了它们的LSP之后才能使用。双向连通性检查还允许处理路由器故障。当一个路由器失败时，根据定义，所有连接的链路都会失败。这些故障由失败路由器的邻居在发送的LSP中报告。当然，失败的路由器不会发送新的LSP来宣布其故障。然而，在表示网络的图中，这个失败的路由器看起来像一个只有出边节点的节点。多亏了双向连通性检查，这个失败的路由器不能被视为到达任何目的地的中继路由器，因为它没有连接任何出边。
- en: When a router has failed, its LSP must be removed from the LSDB of all routers
    [[2]](#foverload). This can be done by using the age field that is included in
    each LSP. The age field is used to bound the maximum lifetime of a link state
    packet in the network. When a router generates a LSP, it sets its lifetime (usually
    measured in seconds) in the age field. All routers regularly decrement the age
    of the LSPs in their LSDB and a LSP is discarded once its age reaches 0. Thanks
    to the age field, the LSP from a failed router does not remain in the LSDBs forever.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个路由器失败时，其 LSP 必须从所有路由器的 LSDB 中移除 [[2]](#foverload)。这可以通过使用包含在每个 LSP 中的年龄字段来完成。年龄字段用于限制网络中链路状态数据包的最大生存时间。当路由器生成
    LSP 时，它将生存时间（通常以秒为单位）设置在年龄字段中。所有路由器都会定期减少其 LSDB 中 LSP 的年龄，一旦年龄达到 0，就会丢弃 LSP。多亏了年龄字段，失败路由器的
    LSP 不会永远留在 LSDB 中。
- en: To compute its forwarding table, each router computes the spanning tree rooted
    at itself by using Dijkstra’s shortest path algorithm [[Dijkstra1959]](../bibliography.html#dijkstra1959).
    The forwarding table can be derived automatically from the spanning as shown in
    figure [Fig. 144](#fig-ls-forwarding-tables).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算其转发表，每个路由器通过使用迪杰斯特拉最短路径算法 [[Dijkstra1959]](../bibliography.html#dijkstra1959)
    来计算以自身为根的生成树。转发表可以从生成树自动导出，如图 [图 144](#fig-ls-forwarding-tables) 所示。
- en: '![Figure made with TikZ](../Images/40a9896cfb388877cc0637008a57262c.png)'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/40a9896cfb388877cc0637008a57262c.png)'
- en: ''
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 144 Computation of the forwarding table, the paths used by packets sent
    by R3 are shown in red
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 144 转发表的计算，R3 发送的数据包所使用的路径用红色表示
- en: '[PRE8]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Footnotes  ## Distance vector routing[#](#distance-vector-routing "Link to
    this heading")'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '脚注  ## 距离矢量路由[#](#distance-vector-routing "链接到这个标题")'
- en: Distance vector routing is a simple distributed routing protocol. Distance vector
    routing allows routers to automatically discover the destinations reachable inside
    the network as well as the shortest path to reach each of these destinations.
    The shortest path is computed based on metrics or costs that are associated to
    each link. We use l.cost to represent the metric that has been configured for
    link l on a router.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 距离矢量路由是一种简单的分布式路由协议。距离矢量路由允许路由器自动发现网络内可达的目的地以及到达这些目的地的最短路径。最短路径是根据与每个链路关联的度量或成本来计算的。我们使用
    l.cost 来表示在路由器上为链路 l 配置的度量。
- en: 'Each router maintains a routing table. The routing table R can be modeled as
    a data structure that stores, for each known destination address d, the following
    attributes :'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由器维护一个路由表。路由表 R 可以建模为一个数据结构，它存储每个已知目的地地址 d 的以下属性：
- en: R[d].link is the outgoing link that the router uses to forward packets towards
    destination d
  id: totrans-538
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[d].link 是路由器用于将数据包转发到目的地 d 的出链路。
- en: ''
  id: totrans-539
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-540
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: R[d].cost is the sum of the metrics of the links that compose the shortest path
    to reach destination d
  id: totrans-541
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[d].cost 是到达目的地 d 的最短路径中链路度量的总和。
- en: ''
  id: totrans-542
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: R[d].time is the timestamp of the last distance vector containing destination
    d
  id: totrans-544
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: R[d].time 是包含目的地 d 的最后一个距离矢量的时间戳。
- en: A router that uses distance vector routing regularly sends its distance vector
    over all its interfaces. This distance vector is a summary of the router’s routing
    table that indicates the distance towards each known destination. This distance
    vector can be computed from the routing table by using the pseudo-code below.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 使用距离矢量路由的路由器定期通过所有接口发送其距离矢量。这个距离矢量是路由器路由表的摘要，指示每个已知目的地的距离。这个距离矢量可以通过以下伪代码从路由表中计算得出。
- en: '[PRE9]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a router boots, it does not know any destination in the network and its
    routing table only contains its local address(es). It thus sends to all its neighbors
    a distance vector that contains only its address at a distance of 0. When a router
    receives a distance vector on link l, it processes it as follows.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器启动时，它不知道网络中的任何目的地，其路由表只包含其本地地址。因此，它向所有邻居发送一个距离矢量，该距离矢量只包含其地址，距离为 0。当路由器在链路
    l 上接收到距离矢量时，它按以下方式处理。
- en: '[PRE10]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The router iterates over all addresses included in the distance vector. If
    the distance vector contains a destination address that the router does not know,
    it inserts it inside its routing table via link l and at a distance which is the
    sum between the distance indicated in the distance vector and the cost associated
    to link l. If the destination was already known by the router, it only updates
    the corresponding entry in its routing table if either :'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器遍历距离向量中包含的所有地址。如果距离向量包含路由器不知道的目的地址，它将通过链路l将其插入其路由表，距离是距离向量中指示的距离与链路l相关的成本之和。如果目的地已经由路由器知道，它只在其路由表中更新相应的条目，如果以下任一条件成立：
- en: the cost of the new route is smaller than the cost of the already known route
    ((V[d].cost + l.cost) < R[d].cost)
  id: totrans-550
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新路由的成本小于已知路由的成本((V[d].cost + l.cost) < R[d].cost)
- en: ''
  id: totrans-551
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-552
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the new route was learned over the same link as the current best route towards
    this destination (R[d].link == l)
  id: totrans-553
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新路由是通过与当前最佳路由到该目的地相同的链路学习的(R[d].link == l)
- en: The first condition ensures that the router discovers the shortest path towards
    each destination. The second condition is used to take into account the changes
    of routes that may occur after a link failure or a change of the metric associated
    to a link.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件确保路由器发现到每个目的地的最短路径。第二个条件用于考虑链路故障或与链路相关的度量值变化后可能发生的路由变化。
- en: To understand the operation of a distance vector protocol, let us consider the
    network of five routers shown in [Fig. 136](#fig-dv-5routers).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解距离向量协议的操作，让我们考虑图[图136](#fig-dv-5routers)中显示的五个路由器的网络。
- en: '![Figure made with TikZ](../Images/2fa610c73105286d66d016e10c05cd70.png)'
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![用TikZ制作的图](../Images/2fa610c73105286d66d016e10c05cd70.png)'
- en: ''
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 136 Operation of distance vector routing in a simple network
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图136 简单网络中距离向量路由的操作
- en: Assume that router A is the first to send its distance vector [A=0].
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 假设路由器A是第一个发送其距离向量[A=0]的路由器。
- en: B and D process the received distance vector and update their routing table
    with a route towards A.
  id: totrans-560
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B和D处理接收到的距离向量，并使用指向A的路由更新其路由表。
- en: ''
  id: totrans-561
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: D sends its distance vector [D=0,A=1] to A and E. E can now reach A and D.
  id: totrans-563
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: D向A和E发送其距离向量[D=0,A=1]。现在E可以到达A和D。
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: C sends its distance vector [C=0] to B and E
  id: totrans-566
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: C向B和E发送其距离向量[C=0]。
- en: ''
  id: totrans-567
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: E sends its distance vector [E=0,D=1,A=2,C=1] to D, B and C. B can now reach
    A, C, D and E
  id: totrans-569
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: E向D、B和C发送其距离向量[E=0,D=1,A=2,C=1]。现在B可以到达A、C、D和E。
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-571
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: B sends its distance vector [B=0,A=1,C=1,D=2,E=1] to A, C and E. A, B, C and
    E can now reach all five routers of this network.
  id: totrans-572
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B向A、C和E发送其距离向量[B=0,A=1,C=1,D=2,E=1]。现在A、B、C和E可以到达这个网络中的所有五个路由器。
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A sends its distance vector [A=0,B=1,C=2,D=1,E=2] to B and D.
  id: totrans-575
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A向B和D发送其距离向量[A=0,B=1,C=2,D=1,E=2]。
- en: At this point, all routers can reach all other routers in the network thanks
    to the routing tables shown in figure [Fig. 137](#fig-dv-5routers-tables).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有路由器都可以通过图[图137](#fig-dv-5routers-tables)中显示的路由表到达网络中的其他所有路由器。
- en: '![Figure made with TikZ](../Images/7c1f3aa75ce05eb9400c684329583c9a.png)'
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![用TikZ制作的图](../Images/7c1f3aa75ce05eb9400c684329583c9a.png)'
- en: ''
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 137 Routing tables computed by distance vector in a simple network
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图137 简单网络中通过距离向量计算的路由表
- en: '[PRE11]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To deal with link and router failures, routers use the timestamp stored in their
    routing table. As all routers send their distance vector every N seconds, the
    timestamp of each route should be regularly refreshed. Thus no route should have
    a timestamp older than N seconds, unless the route is not reachable anymore. In
    practice, to cope with the possible loss of a distance vector due to transmission
    errors, routers check the timestamp of the routes stored in their routing table
    every N seconds and remove the routes that are older than \(3 \times N\) seconds.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理链路和路由器的故障，路由器使用其路由表中存储的时间戳。由于所有路由器每N秒发送一次其距离向量，因此每个路由的时间戳应该定期刷新。因此，没有路由的时间戳应该早于N秒，除非该路由不再可达。在实际操作中，为了应对由于传输错误可能导致的距离向量丢失，路由器每N秒检查其路由表中存储的路由的时间戳，并删除超过\(3
    \times N\)秒的路由。
- en: When a router notices that a route towards a destination has expired, it must
    first associate an \(\infty\) cost to this route and send its distance vector
    to its neighbors to inform them. The route can then be removed from the routing
    table after some time (e.g. \(3 \times N\) seconds), to ensure that the neighboring
    routers have received the bad news, even if some distance vectors do not reach
    them due to transmission errors.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器注意到通往目的地的路由已过期时，它必须首先将一个\(\infty\)成本关联到该路由，并将其距离向量发送给其邻居以通知他们。然后，该路由可以在一段时间后（例如
    \(3 \times N\) 秒）从路由表中删除，以确保相邻的路由器已经收到了坏消息，即使由于传输错误，某些距离向量没有到达它们。
- en: Consider the example above and assume that the link between routers A and B
    fails. Before the failure, A used B to reach destinations B, C and E while B only
    used the A-B link to reach A. The two routers detect the failure by the timeouts
    in the affected entries in their routing tables. Both routers A and B send their
    distance vector.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上述示例，并假设路由器A和B之间的链路故障。在故障之前，A使用B到达目的地B、C和E，而B仅使用A-B链路到达A。两个路由器通过它们路由表中受影响条目的超时来检测故障。A和B路由器都发送它们的距离向量。
- en: A sends its distance vector \([A=0,B=\infty,C=\infty,D=1,E=\infty]\). D knows
    that it cannot reach B anymore via A
  id: totrans-584
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: A发送其距离向量 \([A=0,B=\infty,C=\infty,D=1,E=\infty]\)。D知道它不能再通过A到达B。
- en: ''
  id: totrans-585
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-586
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: D sends its distance vector \([D=0,B=\infty,A=1,C=2,E=1]\) to A and E. A recovers
    routes towards C and E via D.
  id: totrans-587
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: D向A和E发送其距离向量 \([D=0,B=\infty,A=1,C=2,E=1]\)。A通过D恢复通往C和E的路径。
- en: ''
  id: totrans-588
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: B sends its distance vector \([B=0,A=\infty,C=1,D=2,E=1]\) to E and C. C learns
    that there is no route anymore to reach A via B.
  id: totrans-590
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: B向E和C发送其距离向量 \([B=0,A=\infty,C=1,D=2,E=1]\)。C得知通过B到达A的路径已不存在。
- en: ''
  id: totrans-591
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: E sends its distance vector \([E=0,A=2,C=1,D=1,B=1]\) to D, B and C. D learns
    a route towards B. C and B learn a route towards A.
  id: totrans-593
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: E向D、B和C发送其距离向量 \([E=0,A=2,C=1,D=1,B=1]\)。D学习到通往B的路径。C和B学习到通往A的路径。
- en: At this point, all routers have a routing table allowing them to reach all other
    routers, except router A, which cannot yet reach router B. A recovers the route
    towards B once router D sends its updated distance vector \([A=1,B=2,C=2,D=0,E=1]\).
    This last step is illustrated in figure [Fig. 138](#fig-dv-5routers-failure),
    which shows the routing tables on all routers.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，所有路由器都有一个路由表，允许它们到达所有其他路由器，除了路由器A，它还不能到达路由器B。一旦路由器D发送其更新的距离向量 \([A=1,B=2,C=2,D=0,E=1]\)，A就会恢复通往B的路径。这一最后步骤在图[图138](#fig-dv-5routers-failure)中说明，该图显示了所有路由器上的路由表。
- en: '![Figure made with TikZ](../Images/f6f46399afab72ccf3c3eb51d5f05021.png)'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/f6f46399afab72ccf3c3eb51d5f05021.png)'
- en: ''
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 138 Routing tables computed by distance vector after a failure
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图138：故障后计算出的距离向量路由表
- en: 'Consider now that the link between D and E fails. The network is now partitioned
    into two disjoint parts: (A , D) and (B, E, C). The routes towards B, C and E
    expire first on router D. At this time, router D updates its routing table.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑D和E之间的链路故障。网络现在分为两个不相交的部分：（A , D）和（B, E, C）。路由到B、C和E的路径首先在路由器D上过期。此时，路由器D更新其路由表。
- en: If D sends \([D=0, A=1, B=\infty, C=\infty, E=\infty]\), A learns that B, C
    and E are unreachable and updates its routing table.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果D发送 \([D=0, A=1, B=\infty, C=\infty, E=\infty]\)，A就会知道B、C和E无法到达，并更新其路由表。
- en: 'Unfortunately, if the distance vector sent to A is lost or if A sends its own
    distance vector ( \([A=0,D=1,B=3,C=3,E=2]\) ) at the same time as D sends its
    distance vector, D updates its routing table to use the shorter routes advertised
    by A towards B, C and E. After some time D sends a new distance vector : \([D=0,A=1,E=3,C=4,B=4]\).
    A updates its routing table and after some time sends its own distance vector
    \([A=0,D=1,B=5,C=5,E=4]\), etc. This problem is known as the count to infinity
    problem in the networking literature.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果发送给A的距离向量丢失，或者A在与D发送其距离向量（ \([A=0,D=1,B=3,C=3,E=2]\) ）的同时发送自己的距离向量，D将更新其路由表以使用A向B、C和E宣布的较短路径。经过一段时间后，D发送一个新的距离向量：\([D=0,A=1,E=3,C=4,B=4]\)。A更新其路由表，并在一段时间后发送自己的距离向量
    \([A=0,D=1,B=5,C=5,E=4]\)，等等。这个问题在计算机网络文献中被称为“计数到无穷大”问题。
- en: Routers A and D exchange distance vectors with increasing costs until these
    costs reach \(\infty\). This problem may occur in other scenarios than the one
    depicted in the above figure. In fact, distance vector routing may suffer from
    count to infinity problems as soon as there is a cycle in the network. Unfortunately,
    cycles are widely used in networks since they provide the required redundancy
    to deal with link and router failures. To mitigate the impact of counting to infinity,
    some distance vector protocols consider that \(16=\infty\). Unfortunately, this
    limits the metrics that network operators can use and the diameter of the networks
    using distance vectors.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器 A 和 D 交换距离矢量，随着成本的不断增加，这些成本达到 \(\infty\)。这个问题可能出现在上述图示之外的其他场景中。实际上，只要网络中存在环路，距离矢量路由就可能遭受计数到无穷大问题。不幸的是，环路在网络中被广泛使用，因为它们提供了处理链路和路由器故障所需的红冗余。为了减轻计数到无穷大的影响，一些距离矢量协议认为
    \(16=\infty\)。不幸的是，这限制了网络运营商可以使用的方法和采用距离矢量的网络的直径。
- en: This count to infinity problem occurs because router A advertises to router
    D a route that it has learned via router D. A possible solution to avoid this
    problem could be to change how a router creates its distance vector. Instead of
    computing one distance vector and sending it to all its neighbors, a router could
    create a distance vector that is specific to each neighbor and only contains the
    routes that have not been learned via this neighbor. This could be implemented
    by the following pseudocode.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计数到无穷大问题发生是因为路由器 A 向路由器 D 宣告了一条通过路由器 D 学习的路由。避免这个问题的可能解决方案之一是改变路由器创建其距离矢量的方式。而不是计算一个距离矢量并发送给所有邻居，路由器可以创建一个针对每个邻居的特定距离矢量，并且只包含通过这个邻居未学习到的路由。这可以通过以下伪代码实现。
- en: '[PRE12]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This technique is called split-horizon. With this technique, the count to infinity
    problem would not have happened in the above scenario, as router A would have
    advertised \([A=0]\) after the failure, since it learned all its other routes
    via router D. Another variant called split-horizon with poison reverse is also
    possible. Routers using this variant advertise a cost of \(\infty\) for the destinations
    that they reach via the router to which they send the distance vector. This can
    be implemented by using the pseudo-code below.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为分割水平（split-horizon）。使用这种技术，上述场景中就不会发生计数到无穷大问题，因为路由器 A 在故障后就会宣布 \([A=0]\)，因为它通过路由器
    D 学习了所有其他路由。另一种称为带毒回溯的分割水平（split-horizon with poison reverse）的变体也是可能的。使用这种变体的路由器会向它们发送距离矢量的路由器宣布到达目的地的成本为
    \(\infty\)。这可以通过以下伪代码实现。
- en: '[PRE13]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, split-horizon is not sufficient to avoid all count to infinity
    problems with distance vector routing. Consider the failure of link A-B in the
    four routers network shown in figure [Fig. 139](#fig-dv-4routers-count).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，分割水平（split-horizon）并不能完全避免距离矢量路由中的所有计数到无穷大（count to infinity）问题。考虑图[图 139](#fig-dv-4routers-count)中所示的四路由器网络中链路
    A-B 的故障。
- en: '![Figure made with TikZ](../Images/52e88a9b6b9535c5fb1a69d33e6abe9d.png)'
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/52e88a9b6b9535c5fb1a69d33e6abe9d.png)'
- en: ''
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 139 Count to infinity problem
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 139 计数到无穷大问题
- en: 'After having detected the failure, router B sends its distance vectors:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到故障后，路由器 B 发送其距离矢量：
- en: \([A=\infty,B=0,C=\infty,E=1]\) to router C
  id: totrans-611
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: \([A=\infty,B=0,C=\infty,E=1]\) 发送到路由器 C
- en: ''
  id: totrans-612
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-613
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \([A=\infty,B=0,C=1,E=\infty]\) to router E
  id: totrans-614
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: \([A=\infty,B=0,C=1,E=\infty]\) 发送到路由器 E
- en: If, unfortunately, the distance vector sent to router C is lost due to a transmission
    error or because router C is overloaded, a new count to infinity problem can occur.
    If router C sends its distance vector \([A=2,B=1,C=0,E=\infty]\) to router E,
    this router installs a route of distance 3 to reach A via C. Router E sends its
    distance vectors \([A=3,B=\infty,C=1,E=1]\) to router B and \([A=\infty,B=1,C=\infty,E=0]\)
    to router C. This distance vector allows B to recover a route of distance 4 to
    reach A.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不幸的是，发送到路由器 C 的距离矢量由于传输错误或因为路由器 C 过载而丢失，可能会出现新的计数到无穷大问题。如果路由器 C 向路由器 E 发送其距离矢量
    \([A=2,B=1,C=0,E=\infty]\)，则该路由器将安装一条距离为 3 的路由，通过 C 达到 A。路由器 E 向路由器 B 发送其距离矢量
    \([A=3,B=\infty,C=1,E=1]\)，并向路由器 C 发送 \([A=\infty,B=1,C=\infty,E=0]\)。这个距离矢量允许
    B 恢复一条距离为 4 的路由，以到达 A。
- en: '[PRE14]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Forwarding tables versus routing tables
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 转发表与路由表
- en: Routers usually maintain at least two data structures that contain information
    about the reachable destinations. The first data structure is the routing table.
    The routing table is a data structure that associates a destination to an outgoing
    interface or a nexthop router and a set of additional attributes. Different routing
    protocols can associate different attributes for each destination. Distance vector
    routing protocols will store the cost to reach the destination along the shortest
    path. Other routing protocols may store information about the number of hops of
    the best path, its lifetime or the number of sub paths. A routing table may store
    different paths towards a given destination and flag one of them as the best one.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器通常维护至少两个包含可达目的地信息的数据结构。第一个数据结构是路由表。路由表是一种将目的地与出接口或下一跳路由器以及一组附加属性关联起来的数据结构。不同的路由协议可以为每个目的地关联不同的属性。距离矢量路由协议将存储到达目的地的最短路径的成本。其他路由协议可能存储有关最佳路径的跳数、其生存期或子路径数量的信息。路由表可能存储指向给定目的地的不同路径，并将其中之一标记为最佳路径。
- en: The routing table is a software data structure which is updated by (one or more)
    routing protocols. The routing table is usually not directly used when forwarding
    packets. Packet forwarding relies on a more compact data structure which is the
    forwarding table. On high-end routers, the forwarding table is implemented directly
    in hardware while lower performance routers will use a software implementation.
    A forwarding table contains a subset of the information found in the routing table.
    It only contains the nexthops towards each destination that are used to forward
    packets and no attributes. A forwarding table will typically associate each destination
    to one or more outgoing interface or nexthop router.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 路由表是一种由（一个或多个）路由协议更新的软件数据结构。路由表通常在转发数据包时不会直接使用。数据包转发依赖于一个更紧凑的数据结构，即转发表。在高端路由器上，转发表直接在硬件中实现，而性能较低的路由器将使用软件实现。转发表包含路由表中找到的信息的子集。它仅包含用于转发数据包的下一跳目的地以及没有属性。转发表通常将每个目的地与一个或多个出接口或下一跳路由器关联。
- en: '## Link state routing[#](#link-state-routing "Link to this heading")'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '## 链路状态路由[#](#link-state-routing "链接到本标题")'
- en: Link state routing is the second family of routing protocols. While distance
    vector routers use a distributed algorithm to compute their routing tables, link-state
    routers exchange messages to allow each router to learn the entire network topology.
    Based on this learned topology, each router is then able to compute its routing
    table by using a shortest path computation such as Dijkstra’s algorithm [[Dijkstra1959]](../bibliography.html#dijkstra1959).
    A detailed description of this shortest path algorithm may be found in [[Wikipedia:Dijkstra]](../bibliography.html#wikipedia-dijkstra).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 链路状态路由是路由协议的第二类。虽然距离矢量路由器使用分布式算法来计算其路由表，但链路状态路由器交换消息以允许每个路由器学习整个网络拓扑。基于这种学习到的拓扑，每个路由器然后能够通过使用如迪杰斯特拉算法（Dijkstra’s
    algorithm）之类的最短路径计算来计算其路由表 [[Dijkstra1959]](../bibliography.html#dijkstra1959)。有关此最短路径算法的详细描述，请参阅
    [[维基百科:Dijkstra]](../bibliography.html#wikipedia-dijkstra)。
- en: 'For link-state routing, a network is modeled as a directed weighted graph.
    Each router is a node, and the links between routers are the edges in the graph.
    A positive weight is associated to each directed edge and routers use the shortest
    path to reach each destination. In practice, different types of weights can be
    associated to each directed edge :'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链路状态路由，网络被建模为一个有向加权图。每个路由器是一个节点，路由器之间的链路是图中的边。每个有向边都关联一个正权重，路由器使用最短路径到达每个目的地。在实践中，可以给每个有向边关联不同类型的权重：
- en: unit weight. If all links have a unit weight, shortest path routing prefers
    the paths with the least number of intermediate routers.
  id: totrans-624
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单位权重。如果所有链路都具有单位权重，最短路径路由将优先选择具有最少中间路由器的路径。
- en: ''
  id: totrans-625
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-626
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: weight proportional to the propagation delay on the link. If all link weights
    are configured this way, shortest path routing uses the paths with the smallest
    propagation delay.
  id: totrans-627
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重与链路上的传播延迟成正比。如果所有链路权重都按这种方式配置，最短路径路由将使用传播延迟最小的路径。
- en: ''
  id: totrans-628
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-629
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(weight=\frac{C}{bandwidth}\) where C is a constant larger than the highest
    link bandwidth in the network. If all link weights are configured this way, shortest
    path routing prefers higher bandwidth paths over lower bandwidth paths.
  id: totrans-630
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(weight=\frac{C}{bandwidth}\) 其中 C 是一个大于网络中最高链路带宽的常数。如果所有链路权重都这样配置，最短路径路由将优先选择带宽更高的路径，而不是带宽较低的路径。
- en: Usually, the same weight is associated to the two directed edges that correspond
    to a physical link (i.e. \(R1 \rightarrow R2\) and \(R2 \rightarrow R1\)). However,
    nothing in the link state protocols requires this. For example, if the weight
    is set in function of the link bandwidth, then an asymmetric ADSL link could have
    a different weight for the upstream and downstream directions. Other variants
    are possible. Some networks use optimization algorithms to find the best set of
    weights to minimize congestion inside the network for a given traffic demand [[FRT2002]](../bibliography.html#frt2002).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，相同的权重与对应于物理链路的两个有向边相关联（即 \(R1 \rightarrow R2\) 和 \(R2 \rightarrow R1\)）。然而，链路状态协议中没有任何要求必须这样做。例如，如果权重是根据链路带宽设置的，那么不对称的
    ADSL 链路在上行和下行方向上可能具有不同的权重。其他变体也是可能的。一些网络使用优化算法来找到最佳权重集，以最小化给定流量需求下的网络内部拥塞 [[FRT2002]](../bibliography.html#frt2002)。
- en: When a link-state router boots, it first needs to discover to which routers
    it is directly connected. For this, each router sends a HELLO message every N
    seconds on all its interfaces. This message contains the router’s address. Each
    router has a unique address. As its neighboring routers also send HELLO messages,
    the router automatically discovers to which neighbors it is connected. These HELLO
    messages are only sent to neighbors that are directly connected to a router, and
    a router never forwards the HELLO messages that it receives. HELLO messages are
    also used to detect link and router failures. A link is considered to have failed
    if no HELLO message has been received from a neighboring router for a period of
    \(k \times N\) seconds. This is illustrated in figure [Fig. 140](#fig-ls-hello).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当链路状态路由器启动时，它首先需要发现它与哪些路由器直接连接。为此，每个路由器每 N 秒在其所有接口上发送一个 HELLO 消息。此消息包含路由器的地址。每个路由器都有一个唯一的地址。由于其相邻路由器也发送
    HELLO 消息，因此路由器自动发现它与哪些邻居连接。这些 HELLO 消息仅发送给直接连接到路由器的邻居，路由器永远不会转发它接收到的 HELLO 消息。HELLO
    消息还用于检测链路和路由器故障。如果一个相邻路由器在 \(k \times N\) 秒内没有收到 HELLO 消息，则认为链路已失败。这如图 [图 140](#fig-ls-hello)
    所示。
- en: '![Figure made with TikZ](../Images/ed161dec8dab31664eee88d66a4d8f93.png)'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/ed161dec8dab31664eee88d66a4d8f93.png)'
- en: ''
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 140 The exchange of HELLO messages
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 140 HELLO 消息的交换
- en: 'Once a router has discovered its neighbors, it must reliably distribute all
    its outgoing edges to all routers in the network to allow them to compute their
    local view of the network topology. For this, each router builds a link-state
    packet (LSP) containing the following information:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦路由器发现其邻居，它必须可靠地将所有其发出的边分发给网络中的所有路由器，以便它们计算其网络拓扑的本地视图。为此，每个路由器构建一个包含以下信息的链路状态数据包（LSP）：
- en: 'LSP.Router: identification (address) of the sender of the LSP'
  id: totrans-637
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Router: LSP 发送者的标识（地址）'
- en: ''
  id: totrans-638
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-639
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.age: age or remaining lifetime of the LSP'
  id: totrans-640
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.age: LSP 的年龄或剩余寿命'
- en: ''
  id: totrans-641
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.seq: sequence number of the LSP'
  id: totrans-643
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.seq: LSP 的序列号'
- en: ''
  id: totrans-644
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.Links[]: links advertised in the LSP. Each directed link is represented
    with the following information:'
  id: totrans-646
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Links[]: 在 LSP 中宣布的链路。每个有向链路都使用以下信息表示：'
- en: ''
  id: totrans-647
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-648
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.Links[i].Id: identification of the neighbor'
  id: totrans-649
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Links[i].Id: 邻居的标识'
- en: ''
  id: totrans-650
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LSP.Links[i].cost: cost of the link'
  id: totrans-652
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LSP.Links[i].cost: 链路的成本'
- en: These LSPs must be reliably distributed inside the network without using the
    router’s routing table since these tables can only be computed once the LSPs have
    been received. The Flooding algorithm is used to efficiently distribute the LSPs
    of all routers. Each router that implements flooding maintains a Link sSate DataBase
    (LSDB) containing the most recent LSP sent by each router. When a router receives
    a LSP, it first verifies whether this LSP is already stored inside its LSDB. If
    so, the router has already distributed the LSP earlier and it does not need to
    forward it. Otherwise, the router forwards the LSP on all its links except the
    link over which the LSP was received. Flooding can be implemented by using the
    following pseudo-code.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这些LSP必须在网络内部可靠地分发，而不使用路由器的路由表，因为这些表只能在接收到LSP之后才能计算。洪泛算法用于高效地分发所有路由器的LSP。每个实现洪泛的交换机维护一个包含每个路由器发送的最新LSP的链路状态数据库（LSDB）。当交换机接收到一个LSP时，它首先验证这个LSP是否已经存储在其LSDB中。如果是这样，交换机之前已经分发了这个LSP，它不需要转发它。否则，交换机在其所有链路上转发LSP，除了接收LSP的链路。可以通过以下伪代码实现洪泛。
- en: '[PRE15]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this pseudo-code, LSDB(r) returns the most recent LSP originating from router
    r that is stored in the LSDB. newer(lsp1, lsp2) returns true if lsp1 is more recent
    than lsp2. See the note below for a discussion on how newer can be implemented.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个伪代码中，LSDB(r)返回存储在LSDB中由路由器r发出的最新LSP。newer(lsp1, lsp2)如果lsp1比lsp2更新则返回true。有关如何实现newer的讨论，请参阅下面的注释。
- en: Note
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Which is the most recent LSP ?
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个是最新的LSP？
- en: A router that implements flooding must be able to detect whether a received
    LSP is newer than the stored LSP. This requires a comparison between the sequence
    number of the received LSP and the sequence number of the LSP stored in the link
    state database. The ARPANET routing protocol [[MRR1979]](../bibliography.html#mrr1979)
    used a 6 bits sequence number and implemented the comparison as follows [**RFC
    789**](https://datatracker.ietf.org/doc/html/rfc789.html)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 实现洪泛的交换机必须能够检测接收到的LSP是否比存储的LSP更新。这需要比较接收到的LSP的序列号和链路状态数据库中存储的LSP的序列号。ARPANET路由协议[[MRR1979]](../bibliography.html#mrr1979)使用6位序列号，并按以下方式实现了比较[**RFC
    789**](https://datatracker.ietf.org/doc/html/rfc789.html)
- en: '[PRE16]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This comparison takes into account the modulo \(2^{6}\) arithmetic used to increment
    the sequence numbers. Intuitively, the comparison divides the circle of all sequence
    numbers into two halves. Usually, the sequence number of the received LSP is equal
    to the sequence number of the stored LSP incremented by one, but sometimes the
    sequence numbers of two successive LSPs may differ, e.g. if one router has been
    disconnected for some time. The comparison above worked well until October 27,
    1980\. On this day, the ARPANET crashed completely. The crash was complex and
    involved several routers. At one point, LSP 40 and LSP 44 from one of the routers
    were stored in the LSDB of some routers in the ARPANET. As LSP 44 was the newest,
    it should have replaced LSP 40 on all routers. Unfortunately, one of the ARPANET
    routers suffered from a memory problem and sequence number 40 (101000 in binary)
    was replaced by 8 (001000 in binary) in the buggy router and flooded. Three LSPs
    were present in the network and 44 was newer than 40 which is newer than 8, but
    unfortunately 8 was considered to be newer than 44… All routers started to exchange
    these three link state packets forever and the only solution to recover from this
    problem was to shutdown the entire network [**RFC 789**](https://datatracker.ietf.org/doc/html/rfc789.html).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较考虑了用于递增序列号的模\(2^{6}\)算术。直观上，比较将所有序列号的圆圈分为两半。通常，接收到的LSP的序列号等于存储的LSP的序列号加一，但有时两个连续的LSP的序列号可能不同，例如，如果一个路由器断开连接了一段时间。上述比较在1980年10月27日之前工作得很好。在这一天，ARPANET完全崩溃。这次崩溃很复杂，涉及多个路由器。在某个时刻，一个路由器的LSP
    40和LSP 44存储在ARPANET中一些路由器的LSDB中。由于LSP 44是最新的，它应该在所有路由器上替换LSP 40。不幸的是，ARPANET中的一个路由器出现了内存问题，序列号40（二进制为101000）在有缺陷的路由器中被替换为8（二进制为001000）并进行了洪泛。网络中存在三个LSP，44比40更新，40比8更新，但不幸的是，8被认为比44更新……所有路由器开始永久交换这三个链路状态包，从这个问题中恢复的唯一方法是关闭整个网络[**RFC
    789**](https://datatracker.ietf.org/doc/html/rfc789.html)。
- en: Current link state routing protocols usually use 32 bits sequence numbers and
    include a special mechanism in the unlikely case that a sequence number reaches
    the maximum value (with a 32 bits sequence number space, it takes 136 years to
    cycle the sequence numbers if a link state packet is generated every second).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 当前链路状态路由协议通常使用32位序列号，并在序列号达到最大值（在32位序列号空间中，如果每秒生成一个链路状态包，则需136年才能循环序列号）的不太可能情况下包含一个特殊机制。
- en: To deal with the memory corruption problem, link state packets contain a checksum
    or CRC. This checksum is computed by the router that generates the LSP. Each router
    must verify the checksum when it receives or floods an LSP. Furthermore, each
    router must periodically verify the checksums of the LSPs stored in its LSDB.
    This enables them to cope with memory errors that could corrupt the LSDB as the
    one that occurred in the ARPANET.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理内存损坏问题，链路状态包包含校验和或CRC。这个校验和是由生成LSP的路由器计算的。每个路由器在接收或洪泛LSP时必须验证校验和。此外，每个路由器必须定期验证其LSDB中存储的LSP的校验和。这使得它们能够应对可能损坏LSDB的内存错误，就像在ARPANET中发生的那样。
- en: Flooding is illustrated in figure [Fig. 141](#fig-ls-flooding). By exchanging
    HELLO messages, each router learns its direct neighbors. For example, router E
    learns that it is directly connected to routers D, B and C. Its first LSP has
    sequence number 0 and contains the directed links E->D, E->B and E->C. Router
    E sends its LSP on all its links and routers D, B and C insert the LSP in their
    LSDB and forward it over their other links.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 洪泛在图[图141](#fig-ls-flooding)中展示。通过交换HELLO消息，每个路由器学习其直接邻居。例如，路由器E了解到它直接连接到路由器D、B和C。它的第一个LSP序列号为0，包含有向链路E->D、E->B和E->C。路由器E在其所有链路上发送其LSP，路由器D、B和C将其LSP插入到它们的LSDB中，并通过它们的其他链路转发它。
- en: '![Figure made with TikZ](../Images/e127285ac098a043b65dee85776a39ab.png)'
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e127285ac098a043b65dee85776a39ab.png)'
- en: ''
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fig. 141 Flooding: example'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图141 洪泛：示例
- en: Flooding allows LSPs to be distributed to all routers inside the network without
    relying on routing tables. In the example above, the LSP sent by router E is likely
    to be sent twice on some links in the network. For example, routers B and C receive
    E’s LSP at almost the same time and forward it over the B-C link. To avoid sending
    the same LSP twice on each link, a possible solution is to slightly change the
    pseudo-code above so that a router waits for some random time before forwarding
    a LSP on each link. The drawback of this solution is that the delay to flood an
    LSP to all routers in the network increases. In practice, routers immediately
    flood the LSPs that contain new information (e.g. addition or removal of a link)
    and delay the flooding of refresh LSPs (i.e. LSPs that contain exactly the same
    information as the previous LSP originating from this router) [[FFEB2005]](../bibliography.html#ffeb2005).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 洪泛允许LSP在网络内部的所有路由器之间分发，而不依赖于路由表。在上面的例子中，路由器E发送的LSP可能在网络的一些链路上发送两次。例如，路由器B和C几乎同时接收到E的LSP，并通过B-C链路转发它。为了避免在每个链路上发送相同的LSP两次，一个可能的解决方案是稍微修改上面的伪代码，使得路由器在转发每个链路上的LSP之前等待一些随机时间。这种解决方案的缺点是，将LSP洪泛到网络中所有路由器的延迟增加了。在实践中，路由器立即洪泛包含新信息（例如，链路的添加或删除）的LSP，并延迟刷新LSP（即包含与来自该路由器的上一个LSP完全相同信息的LSP）的洪泛
    [[FFEB2005]](../bibliography.html#ffeb2005)。
- en: To ensure that all routers receive all LSPs, even when there are transmissions
    errors, link state routing protocols use reliable flooding. With reliable flooding,
    routers use acknowledgments and if necessary retransmissions to ensure that all
    link state packets are successfully transferred to each neighboring router. Thanks
    to reliable flooding, all routers store in their LSDB the most recent LSP sent
    by each router in the network. By combining the received LSPs with its own LSP,
    each router can build a graph that represents the entire network topology as shown
    in figure [Fig. 142](#fig-ls-lsdb).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保所有路由器都能接收到所有链路状态信息（LSP），即使在传输错误的情况下，链路状态路由协议使用可靠的洪泛。在可靠洪泛中，路由器使用确认和必要时重新传输来确保所有链路状态包都成功传输到每个相邻路由器。多亏了可靠洪泛，所有路由器都存储了它们LSDB中每个网络路由器发送的最新LSP。通过将接收到的LSP与其自身的LSP相结合，每个路由器可以构建一个表示整个网络拓扑的图，如图[图142](#fig-ls-lsdb)所示。
- en: '![Figure made with TikZ](../Images/43bd64f4088699d0e20f5a2a28cc52d3.png)'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/43bd64f4088699d0e20f5a2a28cc52d3.png)'
- en: ''
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 142 Link state databases received by all routers
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图142 所有路由器接收到的链路状态数据库
- en: Note
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Static or dynamic link metrics ?
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 静态或动态链路度量？
- en: As link state packets are flooded regularly, routers are able to measure the
    quality (e.g. delay or load) of their links and adjust the metric of each link
    according to its current quality. Such dynamic adjustments were included in the
    ARPANET routing protocol [[MRR1979]](../bibliography.html#mrr1979) . However,
    experience showed that it was difficult to tune the dynamic adjustments and ensure
    that no forwarding loops occur in the network [[KZ1989]](../bibliography.html#kz1989).
    Today’s link state routing protocols use metrics that are manually configured
    on the routers and are only changed by the network operators or network management
    tools [[FRT2002]](../bibliography.html#frt2002).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 由于链路状态包被定期泛洪，因此路由器能够测量它们链路的质量（例如延迟或负载），并根据其当前质量调整每个链路的度量。这种动态调整被包含在ARPANET路由协议中
    [[MRR1979]](../bibliography.html#mrr1979)。然而，经验表明，调整动态调整并确保网络中不发生转发环路是困难的 [[KZ1989]](../bibliography.html#kz1989)。今天的链路状态路由协议使用的是在路由器上手动配置的度量，并且只有网络运营商或网络管理工具才能更改
    [[FRT2002]](../bibliography.html#frt2002)。
- en: When a link fails, the two routers attached to the link detect the failure by
    the absence of HELLO messages received during the last \(k \times N\) seconds.
    Once a router has detected the failure of one of its local links, it generates
    and floods a new LSP that no longer contains the failed link. This new LSP replaces
    the previous LSP in the network. In practice, the two routers attached to a link
    do not detect this failure exactly at the same time. During this period, some
    links may be announced in only one direction. This is illustrated in figure [Fig.
    143](#fig-ls-2way). Router E has detected the failure of link E-B and flooded
    a new LSP, but router B has not yet detected this failure.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 当链路失败时，连接到该链路的两个路由器通过在最后 \(k \times N\) 秒内收不到HELLO消息来检测故障。一旦一个路由器检测到其本地链路之一的故障，它就会生成并泛洪一个新的链路状态包，该包不再包含失败的链路。这个新的链路状态包替换了网络中的先前链路状态包。实际上，连接到链路的两个路由器并不完全同时检测到这个故障。在这段时间内，一些链路可能只在一个方向上宣布。这如图[图143](#fig-ls-2way)所示。路由器E已经检测到链路E-B的故障并泛洪了一个新的链路状态包，但路由器B还没有检测到这个故障。
- en: '![Figure made with TikZ](../Images/54c82dddc42e7ee74ac40c1a259a382f.png)'
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/54c82dddc42e7ee74ac40c1a259a382f.png)'
- en: ''
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 143 The two-way connectivity check
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图143 双向连通性检查
- en: When a link is reported in the LSP of only one of the attached routers, routers
    consider the link as having failed and they remove it from the directed graph
    that they compute from their LSDB. This is called the two-way connectivity check.
    This check allows link failures to be quickly flooded as a single LSP is sufficient
    to announce such bad news. However, when a link comes up, it can only be used
    once the two attached routers have sent their LSPs. The two-way connectivity check
    also allows for dealing with router failures. When a router fails, all its links
    fail by definition. These failures are reported in the LSPs sent by the neighbors
    of the failed router. The failed router does not, of course, send a new LSP to
    announce its failure. However, in the graph that represents the network, this
    failed router appears as a node that only has outgoing edges. Thanks to the two-way
    connectivity check, this failed router cannot be considered as a transit router
    to reach any destination since no outgoing edge is attached to it.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有连接的其中一个路由器的链路状态包中报告了链路时，路由器会将该链路视为已失败，并从它们从LSDB计算出的有向图中移除它。这被称为双向连通性检查。这个检查允许链路故障迅速泛洪，因为单个链路状态包就足以宣布这样的坏消息。然而，当链路恢复时，它只能在两个连接的路由器都发送了它们的链路状态包之后才能使用。双向连通性检查还允许处理路由器故障。当一个路由器失败时，根据定义，所有链路都会失败。这些故障在失败路由器的邻居发送的链路状态包中报告。当然，失败的路由器不会发送新的链路状态包来宣布其故障。然而，在表示网络的图中，这个失败的路由器看起来像一个只有出边节点的节点。多亏了双向连通性检查，这个失败的路由器不能被视为到达任何目的地的中继路由器，因为它没有出边连接。
- en: When a router has failed, its LSP must be removed from the LSDB of all routers
    [[2]](#foverload). This can be done by using the age field that is included in
    each LSP. The age field is used to bound the maximum lifetime of a link state
    packet in the network. When a router generates a LSP, it sets its lifetime (usually
    measured in seconds) in the age field. All routers regularly decrement the age
    of the LSPs in their LSDB and a LSP is discarded once its age reaches 0. Thanks
    to the age field, the LSP from a failed router does not remain in the LSDBs forever.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个路由器失败时，其 LSP 必须从所有路由器的 LSDB 中移除 [[2]](#foverload)。这可以通过使用包含在每个 LSP 中的年龄字段来完成。年龄字段用于限制网络中链路状态包的最大生存时间。当路由器生成一个
    LSP 时，它将生存时间（通常以秒为单位）设置在年龄字段中。所有路由器定期减少其 LSDB 中 LSP 的年龄，一旦 LSP 的年龄达到 0，就丢弃该 LSP。多亏了年龄字段，失败路由器的
    LSP 不会永远留在 LSDB 中。
- en: To compute its forwarding table, each router computes the spanning tree rooted
    at itself by using Dijkstra’s shortest path algorithm [[Dijkstra1959]](../bibliography.html#dijkstra1959).
    The forwarding table can be derived automatically from the spanning as shown in
    figure [Fig. 144](#fig-ls-forwarding-tables).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算其转发表，每个路由器通过使用迪杰斯特拉最短路径算法 [[Dijkstra1959]](../bibliography.html#dijkstra1959)
    计算以自身为根的生成树。转发表可以从生成树自动导出，如图 [图 144](#fig-ls-forwarding-tables) 所示。
- en: '![Figure made with TikZ](../Images/40a9896cfb388877cc0637008a57262c.png)'
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/40a9896cfb388877cc0637008a57262c.png)'
- en: ''
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 144 Computation of the forwarding table, the paths used by packets sent
    by R3 are shown in red
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 144 转发表的计算，由 R3 发送的包所使用的路径用红色表示
- en: '[PRE17]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Footnotes
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
