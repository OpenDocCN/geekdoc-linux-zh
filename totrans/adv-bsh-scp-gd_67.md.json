["```sh # =============================================================== #\n#\n# PERSONAL $HOME/.bashrc FILE for bash-3.0 (or later)\n# By Emmanuel Rouat [no-email]\n#\n# Last modified: Tue Nov 20 22:04:47 CET 2012\n\n#  This file is normally read by interactive shells only.\n#+ Here is the place to define your aliases, functions and\n#+ other interactive features like your prompt.\n#\n#  The majority of the code here assumes you are on a GNU\n#+ system (most likely a Linux box) and is often based on code\n#+ found on Usenet or Internet.\n#\n#  See for instance:\n#  http://tldp.org/LDP/abs/html/index.html\n#  http://www.caliban.org/bash\n#  http://www.shelldorado.com/scripts/categories.html\n#  http://www.dotfiles.org\n#\n#  The choice of colors was done for a shell with a dark background\n#+ (white on black), and this is usually also suited for pure text-mode\n#+ consoles (no X server available). If you use a white background,\n#+ you'll have to do some other choices for readability.\n#\n#  This bashrc file is a bit overcrowded.\n#  Remember, it is just just an example.\n#  Tailor it to your needs.\n#\n# =============================================================== #\n\n# --> Comments added by HOWTO author.\n\n# If not running interactively, don't do anything\n[ -z \"$PS1\" ] && return\n\n#-------------------------------------------------------------\n# Source global definitions (if any)\n#-------------------------------------------------------------\n\nif [ -f /etc/bashrc ]; then\n      . /etc/bashrc   # --> Read /etc/bashrc, if present.\nfi\n\n#--------------------------------------------------------------\n#  Automatic setting of $DISPLAY (if not set already).\n#  This works for me - your mileage may vary. . . .\n#  The problem is that different types of terminals give\n#+ different answers to 'who am i' (rxvt in particular can be\n#+ troublesome) - however this code seems to work in a majority\n#+ of cases.\n#--------------------------------------------------------------\n\nfunction get_xserver ()\n{\n    case $TERM in\n        xterm )\n            XSERVER=$(who am i &#124; awk '{print $NF}' &#124; tr -d ')''(' )\n            # Ane-Pieter Wieringa suggests the following alternative:\n            #  I_AM=$(who am i)\n            #  SERVER=${I_AM#*(}\n            #  SERVER=${SERVER%*)}\n            XSERVER=${XSERVER%%:*}\n            ;;\n            aterm &#124; rxvt)\n            # Find some code that works here. ...\n            ;;\n    esac\n}\n\nif [ -z ${DISPLAY:=\"\"} ]; then\n    get_xserver\n    if [[ -z ${XSERVER}  &#124;&#124; ${XSERVER} == $(hostname) &#124;&#124;\n       ${XSERVER} == \"unix\" ]]; then\n          DISPLAY=\":0.0\"          # Display on local host.\n    else\n       DISPLAY=${XSERVER}:0.0     # Display on remote host.\n    fi\nfi\n\nexport DISPLAY\n\n#-------------------------------------------------------------\n# Some settings\n#-------------------------------------------------------------\n\n#set -o nounset     # These  two options are useful for debugging.\n#set -o xtrace\nalias debug=\"set -o nounset; set -o xtrace\"\n\nulimit -S -c 0      # Don't want coredumps.\nset -o notify\nset -o noclobber\nset -o ignoreeof\n\n# Enable options:\nshopt -s cdspell\nshopt -s cdable_vars\nshopt -s checkhash\nshopt -s checkwinsize\nshopt -s sourcepath\nshopt -s no_empty_cmd_completion\nshopt -s cmdhist\nshopt -s histappend histreedit histverify\nshopt -s extglob       # Necessary for programmable completion.\n\n# Disable options:\nshopt -u mailwarn\nunset MAILCHECK        # Don't want my shell to warn me of incoming mail.\n\n#-------------------------------------------------------------\n# Greeting, motd etc. ...\n#-------------------------------------------------------------\n\n# Color definitions (taken from Color Bash Prompt HowTo).\n# Some colors might look different of some terminals.\n# For example, I see 'Bold Red' as 'orange' on my screen,\n# hence the 'Green' 'BRed' 'Red' sequence I often use in my prompt.\n\n# Normal Colors\nBlack='\\e[0;30m'        # Black\nRed='\\e[0;31m'          # Red\nGreen='\\e[0;32m'        # Green\nYellow='\\e[0;33m'       # Yellow\nBlue='\\e[0;34m'         # Blue\nPurple='\\e[0;35m'       # Purple\nCyan='\\e[0;36m'         # Cyan\nWhite='\\e[0;37m'        # White\n\n# Bold\nBBlack='\\e[1;30m'       # Black\nBRed='\\e[1;31m'         # Red\nBGreen='\\e[1;32m'       # Green\nBYellow='\\e[1;33m'      # Yellow\nBBlue='\\e[1;34m'        # Blue\nBPurple='\\e[1;35m'      # Purple\nBCyan='\\e[1;36m'        # Cyan\nBWhite='\\e[1;37m'       # White\n\n# Background\nOn_Black='\\e[40m'       # Black\nOn_Red='\\e[41m'         # Red\nOn_Green='\\e[42m'       # Green\nOn_Yellow='\\e[43m'      # Yellow\nOn_Blue='\\e[44m'        # Blue\nOn_Purple='\\e[45m'      # Purple\nOn_Cyan='\\e[46m'        # Cyan\nOn_White='\\e[47m'       # White\n\nNC=\"\\e[m\"               # Color Reset\n\nALERT=${BWhite}${On_Red} # Bold White on red background\n\necho -e \"${BCyan}This is BASH ${BRed}${BASH_VERSION%.*}${BCyan}\\\n- DISPLAY on ${BRed}$DISPLAY${NC}\\n\"\ndate\nif [ -x /usr/games/fortune ]; then\n    /usr/games/fortune -s     # Makes our day a bit more fun.... :-)\nfi\n\nfunction _exit()              # Function to run upon exit of shell.\n{\n    echo -e \"${BRed}Hasta la vista, baby${NC}\"\n}\ntrap _exit EXIT\n\n#-------------------------------------------------------------\n# Shell Prompt - for many examples, see:\n#       http://www.debian-administration.org/articles/205\n#       http://www.askapache.com/linux/bash-power-prompt.html\n#       http://tldp.org/HOWTO/Bash-Prompt-HOWTO\n#       https://github.com/nojhan/liquidprompt\n#-------------------------------------------------------------\n# Current Format: [TIME USER@HOST PWD] >\n# TIME:\n#    Green     == machine load is low\n#    Orange    == machine load is medium\n#    Red       == machine load is high\n#    ALERT     == machine load is very high\n# USER:\n#    Cyan      == normal user\n#    Orange    == SU to user\n#    Red       == root\n# HOST:\n#    Cyan      == local session\n#    Green     == secured remote connection (via ssh)\n#    Red       == unsecured remote connection\n# PWD:\n#    Green     == more than 10% free disk space\n#    Orange    == less than 10% free disk space\n#    ALERT     == less than 5% free disk space\n#    Red       == current user does not have write privileges\n#    Cyan      == current filesystem is size zero (like /proc)\n# >:\n#    White     == no background or suspended jobs in this shell\n#    Cyan      == at least one background job in this shell\n#    Orange    == at least one suspended job in this shell\n#\n#    Command is added to the history file each time you hit enter,\n#    so it's available to all shells (using 'history -a').\n\n# Test connection type:\nif [ -n \"${SSH_CONNECTION}\" ]; then\n    CNX=${Green}        # Connected on remote machine, via ssh (good).\nelif [[ \"${DISPLAY%%:0*}\" != \"\" ]]; then\n    CNX=${ALERT}        # Connected on remote machine, not via ssh (bad).\nelse\n    CNX=${BCyan}        # Connected on local machine.\nfi\n\n# Test user type:\nif [[ ${USER} == \"root\" ]]; then\n    SU=${Red}           # User is root.\nelif [[ ${USER} != $(logname) ]]; then\n    SU=${BRed}          # User is not login user.\nelse\n    SU=${BCyan}         # User is normal (well ... most of us are).\nfi\n\nNCPU=$(grep -c 'processor' /proc/cpuinfo)    # Number of CPUs\nSLOAD=$(( 100*${NCPU} ))        # Small load\nMLOAD=$(( 200*${NCPU} ))        # Medium load\nXLOAD=$(( 400*${NCPU} ))        # Xlarge load\n\n# Returns system load as percentage, i.e., '40' rather than '0.40)'.\nfunction load()\n{\n    local SYSLOAD=$(cut -d \" \" -f1 /proc/loadavg &#124; tr -d '.')\n    # System load of the current host.\n    echo $((10#$SYSLOAD))       # Convert to decimal.\n}\n\n# Returns a color indicating system load.\nfunction load_color()\n{\n    local SYSLOAD=$(load)\n    if [ ${SYSLOAD} -gt ${XLOAD} ]; then\n        echo -en ${ALERT}\n    elif [ ${SYSLOAD} -gt ${MLOAD} ]; then\n        echo -en ${Red}\n    elif [ ${SYSLOAD} -gt ${SLOAD} ]; then\n        echo -en ${BRed}\n    else\n        echo -en ${Green}\n    fi\n}\n\n# Returns a color according to free disk space in $PWD.\nfunction disk_color()\n{\n    if [ ! -w \"${PWD}\" ] ; then\n        echo -en ${Red}\n        # No 'write' privilege in the current directory.\n    elif [ -s \"${PWD}\" ] ; then\n        local used=$(command df -P \"$PWD\" &#124;\n                   awk 'END {print $5} {sub(/%/,\"\")}')\n        if [ ${used} -gt 95 ]; then\n            echo -en ${ALERT}           # Disk almost full (>95%).\n        elif [ ${used} -gt 90 ]; then\n            echo -en ${BRed}            # Free disk space almost gone.\n        else\n            echo -en ${Green}           # Free disk space is ok.\n        fi\n    else\n        echo -en ${Cyan}\n        # Current directory is size '0' (like /proc, /sys etc).\n    fi\n}\n\n# Returns a color according to running/suspended jobs.\nfunction job_color()\n{\n    if [ $(jobs -s &#124; wc -l) -gt \"0\" ]; then\n        echo -en ${BRed}\n    elif [ $(jobs -r &#124; wc -l) -gt \"0\" ] ; then\n        echo -en ${BCyan}\n    fi\n}\n\n# Adds some text in the terminal frame (if applicable).\n\n# Now we construct the prompt.\nPROMPT_COMMAND=\"history -a\"\ncase ${TERM} in\n  *term &#124; rxvt &#124; linux)\n        PS1=\"\\[\\$(load_color)\\][\\A\\[${NC}\\] \"\n        # Time of day (with load info):\n        PS1=\"\\[\\$(load_color)\\][\\A\\[${NC}\\] \"\n        # User@Host (with connection type info):\n        PS1=${PS1}\"\\[${SU}\\]\\u\\[${NC}\\]@\\[${CNX}\\]\\h\\[${NC}\\] \"\n        # PWD (with 'disk space' info):\n        PS1=${PS1}\"\\[\\$(disk_color)\\]\\W]\\[${NC}\\] \"\n        # Prompt (with 'job' info):\n        PS1=${PS1}\"\\[\\$(job_color)\\]>\\[${NC}\\] \"\n        # Set title of current xterm:\n        PS1=${PS1}\"\\[\\e]0;[\\u@\\h] \\w\\a\\]\"\n        ;;\n    *)\n        PS1=\"(\\A \\u@\\h \\W) > \" # --> PS1=\"(\\A \\u@\\h \\w) > \"\n                               # --> Shows full pathname of current dir.\n        ;;\nesac\n\nexport TIMEFORMAT=$'\\nreal %3R\\tuser %3U\\tsys %3S\\tpcpu %P\\n'\nexport HISTIGNORE=\"&:bg:fg:ll:h\"\nexport HISTTIMEFORMAT=\"$(echo -e ${BCyan})[%d/%m %H:%M:%S]$(echo -e ${NC}) \"\nexport HISTCONTROL=ignoredups\nexport HOSTFILE=$HOME/.hosts    # Put a list of remote hosts in ~/.hosts\n\n#============================================================\n#\n#  ALIASES AND FUNCTIONS\n#\n#  Arguably, some functions defined here are quite big.\n#  If you want to make this file smaller, these functions can\n#+ be converted into scripts and removed from here.\n#\n#============================================================\n\n#-------------------\n# Personnal Aliases\n#-------------------\n\nalias rm='rm -i'\nalias cp='cp -i'\nalias mv='mv -i'\n# -> Prevents accidentally clobbering files.\nalias mkdir='mkdir -p'\n\nalias h='history'\nalias j='jobs -l'\nalias which='type -a'\nalias ..='cd ..'\n\n# Pretty-print of some PATH variables:\nalias path='echo -e ${PATH//:/\\\\n}'\nalias libpath='echo -e ${LD_LIBRARY_PATH//:/\\\\n}'\n\nalias du='du -kh'    # Makes a more readable output.\nalias df='df -kTh'\n\n#-------------------------------------------------------------\n# The 'ls' family (this assumes you use a recent GNU ls).\n#-------------------------------------------------------------\n# Add colors for filetype and  human-readable sizes by default on 'ls':\nalias ls='ls -h --color'\nalias lx='ls -lXB'         #  Sort by extension.\nalias lk='ls -lSr'         #  Sort by size, biggest last.\nalias lt='ls -ltr'         #  Sort by date, most recent last.\nalias lc='ls -ltcr'        #  Sort by/show change time,most recent last.\nalias lu='ls -ltur'        #  Sort by/show access time,most recent last.\n\n# The ubiquitous 'll': directories first, with alphanumeric sorting:\nalias ll=\"ls -lv --group-directories-first\"\nalias lm='ll &#124;more'        #  Pipe through 'more'\nalias lr='ll -R'           #  Recursive ls.\nalias la='ll -A'           #  Show hidden files.\nalias tree='tree -Csuh'    #  Nice alternative to 'recursive ls' ...\n\n#-------------------------------------------------------------\n# Tailoring 'less'\n#-------------------------------------------------------------\n\nalias more='less'\nexport PAGER=less\nexport LESSCHARSET='latin1'\nexport LESSOPEN='&#124;/usr/bin/lesspipe.sh %s 2>&-'\n                # Use this if lesspipe.sh exists.\nexport LESS='-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \\\n:stdin .?pb%pb\\%:?lbLine %lb:?bbByte %bb:-...'\n\n# LESS man page colors (makes Man pages more readable).\nexport LESS_TERMCAP_mb=$'\\E[01;31m'\nexport LESS_TERMCAP_md=$'\\E[01;31m'\nexport LESS_TERMCAP_me=$'\\E[0m'\nexport LESS_TERMCAP_se=$'\\E[0m'\nexport LESS_TERMCAP_so=$'\\E[01;44;33m'\nexport LESS_TERMCAP_ue=$'\\E[0m'\nexport LESS_TERMCAP_us=$'\\E[01;32m'\n\n#-------------------------------------------------------------\n# Spelling typos - highly personnal and keyboard-dependent :-)\n#-------------------------------------------------------------\n\nalias xs='cd'\nalias vf='cd'\nalias moer='more'\nalias moew='more'\nalias kk='ll'\n\n#-------------------------------------------------------------\n# A few fun ones\n#-------------------------------------------------------------\n\n# Adds some text in the terminal frame (if applicable).\n\nfunction xtitle()\n{\n    case \"$TERM\" in\n    *term* &#124; rxvt)\n        echo -en  \"\\e]0;$*\\a\" ;;\n    *)  ;;\n    esac\n}\n\n# Aliases that use xtitle\nalias top='xtitle Processes on $HOST && top'\nalias make='xtitle Making $(basename $PWD) ; make'\n\n# .. and functions\nfunction man()\n{\n    for i ; do\n        xtitle The $(basename $1&#124;tr -d .[:digit:]) manual\n        command man -a \"$i\"\n    done\n}\n\n#-------------------------------------------------------------\n# Make the following commands run in background automatically:\n#-------------------------------------------------------------\n\nfunction te()  # wrapper around xemacs/gnuserv\n{\n    if [ \"$(gnuclient -batch -eval t 2>&-)\" == \"t\" ]; then\n       gnuclient -q \"$@\";\n    else\n       ( xemacs \"$@\" &);\n    fi\n}\n\nfunction soffice() { command soffice \"$@\" & }\nfunction firefox() { command firefox \"$@\" & }\nfunction xpdf() { command xpdf \"$@\" & }\n\n#-------------------------------------------------------------\n# File & strings related functions:\n#-------------------------------------------------------------\n\n# Find a file with a pattern in name:\nfunction ff() { find . -type f -iname '*'\"$*\"'*' -ls ; }\n\n# Find a file with pattern $1 in name and Execute $2 on it:\nfunction fe() { find . -type f -iname '*'\"${1:-}\"'*' \\\n-exec ${2:-file} {} \\;  ; }\n\n#  Find a pattern in a set of files and highlight them:\n#+ (needs a recent version of egrep).\nfunction fstr()\n{\n    OPTIND=1\n    local mycase=\"\"\n    local usage=\"fstr: find string in files.\nUsage: fstr [-i] \\\"pattern\\\" [\\\"filename pattern\\\"] \"\n    while getopts :it opt\n    do\n        case \"$opt\" in\n           i) mycase=\"-i \" ;;\n           *) echo \"$usage\"; return ;;\n        esac\n    done\n    shift $(( $OPTIND - 1 ))\n    if [ \"$#\" -lt 1 ]; then\n        echo \"$usage\"\n        return;\n    fi\n    find . -type f -name \"${2:-*}\" -print0 &#124; \\\nxargs -0 egrep --color=always -sn ${case} \"$1\" 2>&- &#124; more\n\n}\n\nfunction swap()\n{ # Swap 2 filenames around, if they exist (from Uzi's bashrc).\n    local TMPFILE=tmp.$$\n\n    [ $# -ne 2 ] && echo \"swap: 2 arguments needed\" && return 1\n    [ ! -e $1 ] && echo \"swap: $1 does not exist\" && return 1\n    [ ! -e $2 ] && echo \"swap: $2 does not exist\" && return 1\n\n    mv \"$1\" $TMPFILE\n    mv \"$2\" \"$1\"\n    mv $TMPFILE \"$2\"\n}\n\nfunction extract()      # Handy Extract Program\n{\n    if [ -f $1 ] ; then\n        case $1 in\n            *.tar.bz2)   tar xvjf $1     ;;\n            *.tar.gz)    tar xvzf $1     ;;\n            *.bz2)       bunzip2 $1      ;;\n            *.rar)       unrar x $1      ;;\n            *.gz)        gunzip $1       ;;\n            *.tar)       tar xvf $1      ;;\n            *.tbz2)      tar xvjf $1     ;;\n            *.tgz)       tar xvzf $1     ;;\n            *.zip)       unzip $1        ;;\n            *.Z)         uncompress $1   ;;\n            *.7z)        7z x $1         ;;\n            *)           echo \"'$1' cannot be extracted via >extract<\" ;;\n        esac\n    else\n        echo \"'$1' is not a valid file!\"\n    fi\n}\n\n# Creates an archive (*.tar.gz) from given directory.\nfunction maketar() { tar cvzf \"${1%%/}.tar.gz\"  \"${1%%/}/\"; }\n\n# Create a ZIP archive of a file or folder.\nfunction makezip() { zip -r \"${1%%/}.zip\" \"$1\" ; }\n\n# Make your directories and files access rights sane.\nfunction sanitize() { chmod -R u=rwX,g=rX,o= \"$@\" ;}\n\n#-------------------------------------------------------------\n# Process/system related functions:\n#-------------------------------------------------------------\n\nfunction my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }\nfunction pp() { my_ps f &#124; awk '!/awk/ && $0~var' var=${1:-\".*\"} ; }\n\nfunction killps()   # kill by process name\n{\n    local pid pname sig=\"-TERM\"   # default signal\n    if [ \"$#\" -lt 1 ] &#124;&#124; [ \"$#\" -gt 2 ]; then\n        echo \"Usage: killps [-SIGNAL] pattern\"\n        return;\n    fi\n    if [ $# = 2 ]; then sig=$1 ; fi\n    for pid in $(my_ps&#124; awk '!/awk/ && $0~pat { print $1 }' pat=${!#} )\n    do\n        pname=$(my_ps &#124; awk '$1~var { print $5 }' var=$pid )\n        if ask \"Kill process $pid <$pname> with signal $sig?\"\n            then kill $sig $pid\n        fi\n    done\n}\n\nfunction mydf()         # Pretty-print of 'df' output.\n{                       # Inspired by 'dfc' utility.\n    for fs ; do\n\n        if [ ! -d $fs ]\n        then\n          echo -e $fs\" :No such file or directory\" ; continue\n        fi\n\n        local info=( $(command df -P $fs &#124; awk 'END{ print $2,$3,$5 }') )\n        local free=( $(command df -Pkh $fs &#124; awk 'END{ print $4 }') )\n        local nbstars=$(( 20 * ${info[1]} / ${info[0]} ))\n        local out=\"[\"\n        for ((j=0;j<20;j++)); do\n            if [ ${j} -lt ${nbstars} ]; then\n               out=$out\"*\"\n            else\n               out=$out\"-\"\n            fi\n        done\n        out=${info[2]}\" \"$out\"] (\"$free\" free on \"$fs\")\"\n        echo -e $out\n    done\n}\n\nfunction my_ip() # Get IP adress on ethernet.\n{\n    MY_IP=$(/sbin/ifconfig eth0 &#124; awk '/inet/ { print $2 } ' &#124;\n      sed -e s/addr://)\n    echo ${MY_IP:-\"Not connected\"}\n}\n\nfunction ii()   # Get current host related info.\n{\n    echo -e \"\\nYou are logged on ${BRed}$HOST\"\n    echo -e \"\\n${BRed}Additionnal information:$NC \" ; uname -a\n    echo -e \"\\n${BRed}Users logged on:$NC \" ; w -hs &#124;\n             cut -d \" \" -f1 &#124; sort &#124; uniq\n    echo -e \"\\n${BRed}Current date :$NC \" ; date\n    echo -e \"\\n${BRed}Machine stats :$NC \" ; uptime\n    echo -e \"\\n${BRed}Memory stats :$NC \" ; free\n    echo -e \"\\n${BRed}Diskspace :$NC \" ; mydf / $HOME\n    echo -e \"\\n${BRed}Local IP Address :$NC\" ; my_ip\n    echo -e \"\\n${BRed}Open connections :$NC \"; netstat -pan --inet;\n    echo\n}\n\n#-------------------------------------------------------------\n# Misc utilities:\n#-------------------------------------------------------------\n\nfunction repeat()       # Repeat n times command.\n{\n    local i max\n    max=$1; shift;\n    for ((i=1; i <= max ; i++)); do  # --> C-like syntax\n        eval \"$@\";\n    done\n}\n\nfunction ask()          # See 'killps' for example of use.\n{\n    echo -n \"$@\" '[y/n] ' ; read ans\n    case \"$ans\" in\n        y*&#124;Y*) return 0 ;;\n        *) return 1 ;;\n    esac\n}\n\nfunction corename()   # Get name of app that created a corefile.\n{\n    for file ; do\n        echo -n $file : ; gdb --core=$file --batch &#124; head -1\n    done\n}\n\n#=========================================================================\n#\n#  PROGRAMMABLE COMPLETION SECTION\n#  Most are taken from the bash 2.05 documentation and from Ian McDonald's\n# 'Bash completion' package (http://www.caliban.org/bash/#completion)\n#  You will in fact need bash more recent then 3.0 for some features.\n#\n#  Note that most linux distributions now provide many completions\n# 'out of the box' - however, you might need to make your own one day,\n#  so I kept those here as examples.\n#=========================================================================\n\nif [ \"${BASH_VERSION%.*}\" \\< \"3.0\" ]; then\n    echo \"You will need to upgrade to version 3.0 for full \\\n          programmable completion features\"\n    return\nfi\n\nshopt -s extglob        # Necessary.\n\ncomplete -A hostname   rsh rcp telnet rlogin ftp ping disk\ncomplete -A export     printenv\ncomplete -A variable   export local readonly unset\ncomplete -A enabled    builtin\ncomplete -A alias      alias unalias\ncomplete -A function   function\ncomplete -A user       su mail finger\n\ncomplete -A helptopic  help     # Currently same as builtins.\ncomplete -A shopt      shopt\ncomplete -A stopped -P '%' bg\ncomplete -A job -P '%'     fg jobs disown\n\ncomplete -A directory  mkdir rmdir\ncomplete -A directory   -o default cd\n\n# Compression\ncomplete -f -o default -X '*.+(zip&#124;ZIP)'  zip\ncomplete -f -o default -X '!*.+(zip&#124;ZIP)' unzip\ncomplete -f -o default -X '*.+(z&#124;Z)'      compress\ncomplete -f -o default -X '!*.+(z&#124;Z)'     uncompress\ncomplete -f -o default -X '*.+(gz&#124;GZ)'    gzip\ncomplete -f -o default -X '!*.+(gz&#124;GZ)'   gunzip\ncomplete -f -o default -X '*.+(bz2&#124;BZ2)'  bzip2\ncomplete -f -o default -X '!*.+(bz2&#124;BZ2)' bunzip2\ncomplete -f -o default -X '!*.+(zip&#124;ZIP&#124;z&#124;Z&#124;gz&#124;GZ&#124;bz2&#124;BZ2)' extract\n\n# Documents - Postscript,pdf,dvi.....\ncomplete -f -o default -X '!*.+(ps&#124;PS)'  gs ghostview ps2pdf ps2ascii\ncomplete -f -o default -X \\\n'!*.+(dvi&#124;DVI)' dvips dvipdf xdvi dviselect dvitype\ncomplete -f -o default -X '!*.+(pdf&#124;PDF)' acroread pdf2ps\ncomplete -f -o default -X '!*.@(@(?(e)ps&#124;?(E)PS&#124;pdf&#124;PDF)?\\\n(.gz&#124;.GZ&#124;.bz2&#124;.BZ2&#124;.Z))' gv ggv\ncomplete -f -o default -X '!*.texi*' makeinfo texi2dvi texi2html texi2pdf\ncomplete -f -o default -X '!*.tex' tex latex slitex\ncomplete -f -o default -X '!*.lyx' lyx\ncomplete -f -o default -X '!*.+(htm*&#124;HTM*)' lynx html2ps\ncomplete -f -o default -X \\\n'!*.+(doc&#124;DOC&#124;xls&#124;XLS&#124;ppt&#124;PPT&#124;sx?&#124;SX?&#124;csv&#124;CSV&#124;od?&#124;OD?&#124;ott&#124;OTT)' soffice\n\n# Multimedia\ncomplete -f -o default -X \\\n'!*.+(gif&#124;GIF&#124;jp*g&#124;JP*G&#124;bmp&#124;BMP&#124;xpm&#124;XPM&#124;png&#124;PNG)' xv gimp ee gqview\ncomplete -f -o default -X '!*.+(mp3&#124;MP3)' mpg123 mpg321\ncomplete -f -o default -X '!*.+(ogg&#124;OGG)' ogg123\ncomplete -f -o default -X \\\n'!*.@(mp[23]&#124;MP[23]&#124;ogg&#124;OGG&#124;wav&#124;WAV&#124;pls&#124;\\\nm3u&#124;xm&#124;mod&#124;s[3t]m&#124;it&#124;mtm&#124;ult&#124;flac)' xmms\ncomplete -f -o default -X '!*.@(mp?(e)g&#124;MP?(E)G&#124;wma&#124;avi&#124;AVI&#124;\\\nasf&#124;vob&#124;VOB&#124;bin&#124;dat&#124;vcd&#124;ps&#124;pes&#124;fli&#124;viv&#124;rm&#124;ram&#124;yuv&#124;mov&#124;MOV&#124;qt&#124;\\\nQT&#124;wmv&#124;mp3&#124;MP3&#124;ogg&#124;OGG&#124;ogm&#124;OGM&#124;mp4&#124;MP4&#124;wav&#124;WAV&#124;asx&#124;ASX)' xine\n\ncomplete -f -o default -X '!*.pl'  perl perl5\n\n#  This is a 'universal' completion function - it works when commands have\n#+ a so-called 'long options' mode , ie: 'ls --all' instead of 'ls -a'\n#  Needs the '-o' option of grep\n#+ (try the commented-out version if not available).\n\n#  First, remove '=' from completion word separators\n#+ (this will allow completions like 'ls --color=auto' to work correctly).\n\nCOMP_WORDBREAKS=${COMP_WORDBREAKS/=/}\n\n_get_longopts()\n{\n  #$1 --help &#124; sed  -e '/--/!d' -e 's/.*--\\([^[:space:].,]*\\).*/--\\1/'&#124; \\\n  #grep ^\"$2\" &#124;sort -u ;\n    $1 --help &#124; grep -o -e \"--[^[:space:].,]*\" &#124; grep -e \"$2\" &#124;sort -u\n}\n\n_longopts()\n{\n    local cur\n    cur=${COMP_WORDS[COMP_CWORD]}\n\n    case \"${cur:-*}\" in\n       -*)      ;;\n        *)      return ;;\n    esac\n\n    case \"$1\" in\n       \\~*)     eval cmd=\"$1\" ;;\n         *)     cmd=\"$1\" ;;\n    esac\n    COMPREPLY=( $(_get_longopts ${1} ${cur} ) )\n}\ncomplete  -o default -F _longopts configure bash\ncomplete  -o default -F _longopts wget id info a2ps ls recode\n\n_tar()\n{\n    local cur ext regex tar untar\n\n    COMPREPLY=()\n    cur=${COMP_WORDS[COMP_CWORD]}\n\n    # If we want an option, return the possible long options.\n    case \"$cur\" in\n        -*)     COMPREPLY=( $(_get_longopts $1 $cur ) ); return 0;;\n    esac\n\n    if [ $COMP_CWORD -eq 1 ]; then\n        COMPREPLY=( $( compgen -W 'c t x u r d A' -- $cur ) )\n        return 0\n    fi\n\n    case \"${COMP_WORDS[1]}\" in\n        ?(-)c*f)\n            COMPREPLY=( $( compgen -f $cur ) )\n            return 0\n            ;;\n        +([^Izjy])f)\n            ext='tar'\n            regex=$ext\n            ;;\n        *z*f)\n            ext='tar.gz'\n            regex='t\\(ar\\.\\)\\(gz\\&#124;Z\\)'\n            ;;\n        *[Ijy]*f)\n            ext='t?(ar.)bz?(2)'\n            regex='t\\(ar\\.\\)bz2\\?'\n            ;;\n        *)\n            COMPREPLY=( $( compgen -f $cur ) )\n            return 0\n            ;;\n\n    esac\n\n    if [[ \"$COMP_LINE\" == tar*.$ext' '* ]]; then\n        # Complete on files in tar file.\n        #\n        # Get name of tar file from command line.\n        tar=$( echo \"$COMP_LINE\" &#124; \\\n                        sed -e 's&#124;^.* \\([^ ]*'$regex'\\) .*$&#124;\\1&#124;' )\n        # Devise how to untar and list it.\n        untar=t${COMP_WORDS[1]//[^Izjyf]/}\n\n        COMPREPLY=( $( compgen -W \"$( echo $( tar $untar $tar \\\n                                2>/dev/null ) )\" -- \"$cur\" ) )\n        return 0\n\n    else\n        # File completion on relevant files.\n        COMPREPLY=( $( compgen -G $cur\\*.$ext ) )\n\n    fi\n\n    return 0\n\n}\n\ncomplete -F _tar -o default tar\n\n_make()\n{\n    local mdef makef makef_dir=\".\" makef_inc gcmd cur prev i;\n    COMPREPLY=();\n    cur=${COMP_WORDS[COMP_CWORD]};\n    prev=${COMP_WORDS[COMP_CWORD-1]};\n    case \"$prev\" in\n        -*f)\n            COMPREPLY=($(compgen -f $cur ));\n            return 0\n            ;;\n    esac;\n    case \"$cur\" in\n        -*)\n            COMPREPLY=($(_get_longopts $1 $cur ));\n            return 0\n            ;;\n    esac;\n\n    # ... make reads\n    #          GNUmakefile,\n    #     then makefile\n    #     then Makefile ...\n    if [ -f ${makef_dir}/GNUmakefile ]; then\n        makef=${makef_dir}/GNUmakefile\n    elif [ -f ${makef_dir}/makefile ]; then\n        makef=${makef_dir}/makefile\n    elif [ -f ${makef_dir}/Makefile ]; then\n        makef=${makef_dir}/Makefile\n    else\n       makef=${makef_dir}/*.mk         # Local convention.\n    fi\n\n    #  Before we scan for targets, see if a Makefile name was\n    #+ specified with -f.\n    for (( i=0; i < ${#COMP_WORDS[@]}; i++ )); do\n        if [[ ${COMP_WORDS[i]} == -f ]]; then\n            # eval for tilde expansion\n            eval makef=${COMP_WORDS[i+1]}\n            break\n        fi\n    done\n    [ ! -f $makef ] && return 0\n\n    # Deal with included Makefiles.\n    makef_inc=$( grep -E '^-?include' $makef &#124;\n                 sed -e \"s,^.* ,\"$makef_dir\"/,\" )\n    for file in $makef_inc; do\n        [ -f $file ] && makef=\"$makef $file\"\n    done\n\n    #  If we have a partial word to complete, restrict completions\n    #+ to matches of that word.\n    if [ -n \"$cur\" ]; then gcmd='grep \"^$cur\"' ; else gcmd=cat ; fi\n\n    COMPREPLY=( $( awk -F':' '/^[a-zA-Z0-9][^$#\\/\\t=]*:([^=]&#124;$)/ \\\n                               {split($1,A,/ /);for(i in A)print A[i]}' \\\n                                $makef 2>/dev/null &#124; eval $gcmd  ))\n\n}\n\ncomplete -F _make -X '+($*&#124;*.[cho])' make gmake pmake\n\n_killall()\n{\n    local cur prev\n    COMPREPLY=()\n    cur=${COMP_WORDS[COMP_CWORD]}\n\n    #  Get a list of processes\n    #+ (the first sed evaluation\n    #+ takes care of swapped out processes, the second\n    #+ takes care of getting the basename of the process).\n    COMPREPLY=( $( ps -u $USER -o comm  &#124; \\\n        sed -e '1,1d' -e 's#[]\\[]##g' -e 's#^.*/##'&#124; \\\n        awk '{if ($0 ~ /^'$cur'/) print $0}' ))\n\n    return 0\n}\n\ncomplete -F _killall killall killps\n\n# Local Variables:\n# mode:shell-script\n# sh-shell:bash\n# End:\n```", "```sh # From Andrzej Szelachowski's ~/.bash_profile:\n\n#  Note that a variable may require special treatment\n#+ if it will be exported.\n\nDARKGRAY='\\e[1;30m'\nLIGHTRED='\\e[1;31m'\nGREEN='\\e[32m'\nYELLOW='\\e[1;33m'\nLIGHTBLUE='\\e[1;34m'\nNC='\\e[m'\n\nPCT=\"\\`if [[ \\$EUID -eq 0 ]]; then T='$LIGHTRED' ; else T='$LIGHTBLUE'; fi; \necho \\$T \\`\"\n\n#  For \"literal\" command substitution to be assigned to a variable,\n#+ use escapes and double quotes:\n#+       PCT=\"\\` ... \\`\" . . .\n#  Otherwise, the value of PCT variable is assigned only once,\n#+ when the variable is exported/read from .bash_profile,\n#+ and it will not change afterwards even if the user ID changes.\n\nPS1=\"\\n$GREEN[\\w] \\n$DARKGRAY($PCT\\t$DARKGRAY)-($PCT\\u$DARKGRAY)-($PCT\\!\n$DARKGRAY)$YELLOW-> $NC\"\n\n#  Escape a variables whose value changes:\n#        if [[ \\$EUID -eq 0 ]],\n#  Otherwise the value of the EUID variable will be assigned only once,\n#+ as above.\n\n#  When a variable is assigned, it should be called escaped:\n#+       echo \\$T,\n#  Otherwise the value of the T variable is taken from the moment the PCT \n#+ variable is exported/read from .bash_profile.\n#  So, in this example it would be null.\n\n#  When a variable's value contains a semicolon it should be strong quoted:\n#        T='$LIGHTRED',\n#  Otherwise, the semicolon will be interpreted as a command separator.\n\n#  Variables PCT and PS1 can be merged into a new PS1 variable:\n\nPS1=\"\\`if [[ \\$EUID -eq 0 ]]; then PCT='$LIGHTRED';\nelse PCT='$LIGHTBLUE'; fi; \necho '\\n$GREEN[\\w] \\n$DARKGRAY('\\$PCT'\\t$DARKGRAY)-\\\n('\\$PCT'\\u$DARKGRAY)-('\\$PCT'\\!$DARKGRAY)$YELLOW-> $NC'\\`\"\n\n# The trick is to use strong quoting for parts of old PS1 variable.\n```"]