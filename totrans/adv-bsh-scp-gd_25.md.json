["```sh    COMMAND_OUTPUT >\n      # Redirect stdout to a file.\n      # Creates the file if not present, otherwise overwrites it.\n\n      ls -lR > dir-tree.list\n      # Creates a file containing a listing of the directory tree.\n\n   : > filename\n      # The > truncates file \"filename\" to zero length.\n      # If file not present, creates zero-length file (same effect as 'touch').\n      # The : serves as a dummy placeholder, producing no output.\n\n   > filename    \n      # The > truncates file \"filename\" to zero length.\n      # If file not present, creates zero-length file (same effect as 'touch').\n      # (Same result as \": >\", above, but this does not work with some shells.)\n\n   COMMAND_OUTPUT >>\n      # Redirect stdout to a file.\n      # Creates the file if not present, otherwise appends to it.\n\n      # Single-line redirection commands (affect only the line they are on):\n      # --------------------------------------------------------------------\n\n   1>filename\n      # Redirect stdout to file \"filename.\"\n   1>>filename\n      # Redirect and append stdout to file \"filename.\"\n   2>filename\n      # Redirect stderr to file \"filename.\"\n   2>>filename\n      # Redirect and append stderr to file \"filename.\"\n   &>filename\n      # Redirect both stdout and stderr to file \"filename.\"\n      # This operator is now functional, as of Bash 4, final release.\n\n   M>N\n     # \"M\" is a file descriptor, which defaults to 1, if not explicitly set.\n     # \"N\" is a filename.\n     # File descriptor \"M\" is redirect to file \"N.\"\n   M>&N\n     # \"M\" is a file descriptor, which defaults to 1, if not set.\n     # \"N\" is another file descriptor.\n\n      #==============================================================================\n\n      # Redirecting stdout, one line at a time.\n      LOGFILE=script.log\n\n      echo \"This statement is sent to the log file, \\\"$LOGFILE\\\".\" 1>$LOGFILE\n      echo \"This statement is appended to \\\"$LOGFILE\\\".\" 1>>$LOGFILE\n      echo \"This statement is also appended to \\\"$LOGFILE\\\".\" 1>>$LOGFILE\n      echo \"This statement is echoed to stdout, and will not appear in \\\"$LOGFILE\\\".\"\n      # These redirection commands automatically \"reset\" after each line.\n\n      # Redirecting stderr, one line at a time.\n      ERRORFILE=script.errors\n\n      bad_command1 2>$ERRORFILE       #  Error message sent to $ERRORFILE.\n      bad_command2 2>>$ERRORFILE      #  Error message appended to $ERRORFILE.\n      bad_command3                    #  Error message echoed to stderr,\n                                      #+ and does not appear in $ERRORFILE.\n      # These redirection commands also automatically \"reset\" after each line.\n      #=======================================================================\n```", "```sh    2>&1\n      # Redirects stderr to stdout.\n      # Error messages get sent to same place as standard output.\n        >>filename 2>&1\n            bad_command >>filename 2>&1\n            # Appends both stdout and stderr to the file \"filename\" ...\n        2>&1 &#124; [command(s)]\n            bad_command 2>&1 &#124; awk '{print $5}'   # found\n            # Sends stderr through a pipe.\n            # &#124;& was added to Bash 4 as an abbreviation for 2>&1 &#124;.\n\n   i>&j\n      # Redirects file descriptor *i* to *j*.\n      # All output of file pointed to by *i* gets sent to file pointed to by *j*.\n\n   >&j\n      # Redirects, by default, file descriptor *1* (stdout) to *j*.\n      # All stdout gets sent to file pointed to by *j*.\n```", "```sh    0< FILENAME\n    < FILENAME\n      # Accept input from a file.\n      # Companion command to \">\", and often used in combination with it.\n      #\n      # grep search-word <filename\n\n   [j]<>filename\n      #  Open file \"filename\" for reading and writing,\n      #+ and assign file descriptor \"j\" to it.\n      #  If \"filename\" does not exist, create it.\n      #  If file descriptor \"j\" is not specified, default to fd 0, stdin.\n      #\n      #  An application of this is writing at a specified place in a file. \n      echo 1234567890 > File    # Write string to \"File\".\n      exec 3<> File             # Open \"File\" and assign fd 3 to it.\n      read -n 4 <&3             # Read only 4 characters.\n      echo -n . >&3             # Write a decimal point there.\n      exec 3>&-                 # Close fd 3.\n      cat File                  # ==> 1234.67890\n      #  Random access, by golly.\n\n   &#124;\n      # Pipe.\n      # General purpose process and command chaining tool.\n      # Similar to \">\", but more general in effect.\n      # Useful for chaining commands, scripts, files, and programs together.\n      cat *.txt &#124; sort &#124; uniq > result-file\n      # Sorts the output of all the .txt files and deletes duplicate lines,\n      # finally saves results to \"result-file\".\n```", "```sh command < input-file > output-file\n# Or the equivalent:\n< input-file command > output-file   # Although this is non-standard.\n\ncommand1 &#124; command2 &#124; command3 > output-file\n```", "```sh ls -yz >> command.log 2>&1\n#  Capture result of illegal options \"yz\" in file \"command.log.\"\n#  Because stderr is redirected to the file,\n#+ any error messages will also be there.\n\n#  Note, however, that the following does *not* give the same result.\nls -yz 2>&1 >> command.log\n#  Outputs an error message, but does not write to file.\n#  More precisely, the command output (in this case, null)\n#+ writes to the file, but the error message goes only to stdout.\n\n#  If redirecting both stdout and stderr,\n#+ the order of the commands makes a difference.\n```", "```sh # Redirecting only stderr to a pipe.\n\nexec 3>&1                              # Save current \"value\" of stdout.\nls -l 2>&1 >&3 3>&- &#124; grep bad 3>&-    # Close fd 3 for 'grep' (but not 'ls').\n#              ^^^^   ^^^^\nexec 3>&-                              # Now close it for the remainder of the script.\n\n# Thanks, S.C.\n```"]