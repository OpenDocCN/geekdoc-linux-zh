["```sh #!/bin/bash\n# subshell-test.sh\n\n(\n# Inside parentheses, and therefore a subshell . . .\nwhile [ 1 ]   # Endless loop.\ndo\n  echo \"Subshell running . . .\"\ndone\n)\n\n#  Script will run forever,\n#+ or at least until terminated by a Ctl-C.\n\nexit $?  # End of script (but will never get here).\n\nNow, run the script:\nsh subshell-test.sh\n\nAnd, while the script is running, from a different xterm:\nps -ef &#124; grep subshell-test.sh\n\nUID       PID   PPID  C STIME TTY      TIME     CMD\n500       2698  2502  0 14:26 pts/4    00:00:00 sh subshell-test.sh\n500       2699  2698 21 14:26 pts/4    00:00:24 sh subshell-test.sh\n\n          ^^^^\n\nAnalysis:\nPID 2698, the script, launched PID 2699, the subshell.\n\nNote: The \"UID ...\" line would be filtered out by the \"grep\" command,\nbut is shown here for illustrative purposes.\n```", "```sh #!/bin/bash\n# subshell.sh\n\necho\n\necho \"We are outside the subshell.\"\necho \"Subshell level OUTSIDE subshell = $BASH_SUBSHELL\"\n# Bash, version 3, adds the new         $BASH_SUBSHELL variable.\necho; echo\n\nouter_variable=Outer\nglobal_variable=\n#  Define global variable for \"storage\" of\n#+ value of subshell variable.\n\n(\necho \"We are inside the subshell.\"\necho \"Subshell level INSIDE subshell = $BASH_SUBSHELL\"\ninner_variable=Inner\n\necho \"From inside subshell, \\\"inner_variable\\\" = $inner_variable\"\necho \"From inside subshell, \\\"outer\\\" = $outer_variable\"\n\nglobal_variable=\"$inner_variable\"   #  Will this allow \"exporting\"\n                                    #+ a subshell variable?\n)\n\necho; echo\necho \"We are outside the subshell.\"\necho \"Subshell level OUTSIDE subshell = $BASH_SUBSHELL\"\necho\n\nif [ -z \"$inner_variable\" ]\nthen\n  echo \"inner_variable undefined in main body of shell\"\nelse\n  echo \"inner_variable defined in main body of shell\"\nfi\n\necho \"From main body of shell, \\\"inner_variable\\\" = $inner_variable\"\n#  $inner_variable will show as blank (uninitialized)\n#+ because variables defined in a subshell are \"local variables\".\n#  Is there a remedy for this?\necho \"global_variable = \"$global_variable\"\"  # Why doesn't this work?\n\necho\n\n# =======================================================================\n\n# Additionally ...\n\necho \"-----------------\"; echo\n\nvar=41                                                 # Global variable.\n\n( let \"var+=1\"; echo \"\\$var INSIDE subshell = $var\" )  # 42\n\necho \"\\$var OUTSIDE subshell = $var\"                   # 41\n#  Variable operations inside a subshell, even to a GLOBAL variable\n#+ do not affect the value of the variable outside the subshell!\n\nexit 0\n\n#  Question:\n#  --------\n#  Once having exited a subshell,\n#+ is there any way to reenter that very same subshell\n#+ to modify or access the subshell variables?\n```", "```sh echo \" \\$BASH_SUBSHELL outside subshell       = $BASH_SUBSHELL\"           # 0\n  ( echo \" \\$BASH_SUBSHELL inside subshell        = $BASH_SUBSHELL\" )     # 1\n  ( ( echo \" \\$BASH_SUBSHELL inside nested subshell = $BASH_SUBSHELL\" ) ) # 2\n# ^ ^                           *** nested ***                        ^ ^\n\necho\n\necho \" \\$SHLVL outside subshell = $SHLVL\"       # 3\n( echo \" \\$SHLVL inside subshell  = $SHLVL\" )   # 3 (No change!)\n```", "```sh #!/bin/bash\n# allprofs.sh: Print all user profiles.\n\n# This script written by Heiner Steven, and modified by the document author.\n\nFILE=.bashrc  #  File containing user profile,\n              #+ was \".profile\" in original script.\n\nfor home in `awk -F: '{print $6}' /etc/passwd`\ndo\n  [ -d \"$home\" ] &#124;&#124; continue    # If no home directory, go to next.\n  [ -r \"$home\" ] &#124;&#124; continue    # If not readable, go to next.\n  (cd $home; [ -e $FILE ] && less $FILE)\ndone\n\n#  When script terminates, there is no need to 'cd' back to original directory,\n#+ because 'cd $home' takes place in a subshell.\n\nexit 0\n```", "```sh COMMAND1\nCOMMAND2\nCOMMAND3\n(\n  IFS=:\n  PATH=/bin\n  unset TERMINFO\n  set -C\n  shift 5\n  COMMAND4\n  COMMAND5\n  exit 3 # Only exits the subshell!\n)\n# The parent shell has not been affected, and the environment is preserved.\nCOMMAND6\nCOMMAND7\n```", "```sh if (set -u; : $variable) 2> /dev/null\nthen\n  echo \"Variable is set.\"\nfi     #  Variable has been set in current script,\n       #+ or is an an internal Bash variable,\n       #+ or is present in environment (has been exported).\n\n# Could also be written [[ ${variable-x} != x &#124;&#124; ${variable-y} != y ]]\n# or                    [[ ${variable-x} != x$variable ]]\n# or                    [[ ${variable+x} = x ]]\n# or                    [[ ${variable-x} != x ]]\n```", "```sh if (set -C; : > lock_file) 2> /dev/null\nthen\n  :   # lock_file didn't exist: no user running the script\nelse\n  echo \"Another user is already running that script.\"\nexit 65\nfi\n\n#  Code snippet by Stphane Chazelas,\n#+ with modifications by Paulo Marcel Coelho Aragao.\n```", "```sh \t(cat list1 list2 list3 &#124; sort &#124; uniq > list123) &\n\t(cat list4 list5 list6 &#124; sort &#124; uniq > list456) &\n\t# Merges and sorts both sets of lists simultaneously.\n\t# Running in background ensures parallel execution.\n\t#\n\t# Same effect as\n\t#   cat list1 list2 list3 &#124; sort &#124; uniq > list123 &\n\t#   cat list4 list5 list6 &#124; sort &#124; uniq > list456 &\n\n\twait   # Don't execute the next command until subshells finish.\n\n\tdiff list123 list456\n```", "```sh var1=23\necho \"$var1\"   # 23\n\n{ var1=76; }\necho \"$var1\"   # 76\n```"]