- en: Introduction#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介#
- en: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/introduction.html](https://4ed.computer-networking.info/syllabus/default/hosts/introduction.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://4ed.computer-networking.info/syllabus/default/hosts/introduction.html](https://4ed.computer-networking.info/syllabus/default/hosts/introduction.html)
- en: The first step when building a network, even a worldwide network such as the
    Internet, is to connect two hosts together. This is illustrated in figure [Fig.
    1](#fig-2hosts).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 建立网络的第一步，即使是像互联网这样的全球网络，也是连接两个主机。这如图 [图 1](#fig-2hosts) 所示。
- en: '![Figure made with TikZ](../Images/d0c285da29813ff49f2acb545b92e1b7.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/d0c285da29813ff49f2acb545b92e1b7.png)'
- en: Fig. 1 Connecting two hosts together
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1 连接两个主机
- en: 'To enable the two hosts to exchange information, they need to be linked together
    by some kind of physical media. Computer networks have used various types of physical
    media to exchange information, notably :'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使两个主机能够交换信息，它们需要通过某种物理介质连接在一起。计算机网络已经使用了各种类型的物理介质来交换信息，特别是：
- en: electrical cable. Information can be transmitted over different types of electrical
    cables. The most common ones are the twisted pairs (that are used in the telephone
    network, but also in enterprise networks) and the coaxial cables (that are still
    used in cable TV networks, but are no longer used in enterprise networks). Some
    networking technologies operate over the classical electrical cable.
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电线电缆。信息可以通过不同类型的电线电缆进行传输。最常见的是双绞线（在电话网络中使用，也用于企业网络）和同轴电缆（仍在有线电视网络中使用，但不再用于企业网络）。一些网络技术是在传统的电线电缆上运行的。
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Optical fiber. Optical fibers are frequently used in public and enterprise
    networks when the distance between the communication devices is larger than one
    kilometer. There are two main types of optical fibers : multi-mode and single-mode.
    Multi-mode is much cheaper than single-mode fiber because a LED can be used to
    send a signal over a multi-mode fiber while a single-mode fiber must be driven
    by a laser. Due to the different modes of propagation of light, multi-mode fibers
    are limited to distances of a few kilometers while single-mode fibers can be used
    over distances greater than several tens of kilometers. In both cases, repeaters
    can be used to regenerate the optical signal at one endpoint of a fiber to send
    it over another fiber.'
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光纤。当通信设备之间的距离大于一公里时，光纤通常用于公共和企业网络。光纤主要有两种类型：多模光纤和单模光纤。多模光纤比单模光纤便宜得多，因为LED可以用来在多模光纤上发送信号，而单模光纤必须由激光驱动。由于光传播的不同模式，多模光纤的传输距离限制在几公里以内，而单模光纤可以用于超过几十公里的距离。在这两种情况下，都可以使用中继器在光纤的一端再生光信号，以便通过另一根光纤发送。
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Wireless. In this case, a radio signal is used to encode the information exchanged
    between the communicating devices. Many types of modulation techniques are used
    to send information over a wireless channel and there is a lot of innovation in
    this field with new techniques appearing every year. While most wireless networks
    rely on radio signals, some use a laser that sends light pulses to a remote detector.
    These optical techniques allow us to create point-to-point links while radio-based
    techniques can be used to build networks containing devices spread over a small
    geographical area.
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线。在这种情况下，使用无线电信号来编码通信设备之间交换的信息。许多类型的调制技术用于在无线信道上发送信息，并且在这一领域有大量的创新，每年都有新技术出现。虽然大多数无线网络依赖于无线电信号，但一些使用激光向远程探测器发送光脉冲。这些光技术使我们能够创建点对点连接，而基于无线电的技术可以用来构建包含分散在较小地理区域内的设备的网络。
- en: The physical layer[#](#the-physical-layer "Link to this heading")
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理层[#](#the-physical-layer "链接到这个标题")
- en: These physical media can be used to exchange information once this information
    has been converted into a suitable electrical signal. Entire telecommunication
    courses and textbooks are devoted to the problem of converting analog or digital
    information into an electrical signal so that it can be transmitted over a given
    physical link. In this book, we only consider two very simple schemes that allow
    us to transmit information over an electrical cable. This enables us to highlight
    the key problems when transmitting information over a physical link. We are only
    interested in techniques that allow transmitting digital information through the
    wire. Here, we will focus on the transmission of bits, i.e. either 0 or 1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些物理媒体可以在信息被转换成合适的电信号后用来交换信息。整个电信课程和教科书都致力于将模拟或数字信息转换成电信号，以便通过给定的物理链路进行传输的问题。在这本书中，我们只考虑两种非常简单的方案，这些方案允许我们通过电电缆传输信息。这使得我们能够突出在物理链路上传输信息时的关键问题。我们只对允许通过电线传输数字信息的技术感兴趣。在这里，我们将关注比特的传输，即0或1。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bit rate
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率
- en: In computer networks, the bit rate of the physical layer is always expressed
    in bits per second. One Mbps is one million bits per second, and one Gbps is one
    billion bits per second. This is in contrast with memory specifications that are
    usually expressed in bytes (8 bits), KiloBytes (1024 bytes), or MegaBytes (1048576
    bytes). Transferring one MByte through a 1 Mbps link lasts 8.39 seconds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机网络中，物理层的比特率总是以每秒比特数来表示。1 Mbps 表示每秒一百万比特，1 Gbps 表示每秒十亿比特。这与通常以字节（8比特）、千字节（1024字节）或兆字节（1048576字节）来表示的内存规格形成对比。通过1
    Mbps链路传输1兆字节需要8.39秒。
- en: '| Bit rate | Bits per second |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 比特率 | 每秒比特数 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 Kbps | \(10^3\) |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Kbps | \(10^3\) |'
- en: '| 1 Mbps | \(10^6\) |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Mbps | \(10^6\) |'
- en: '| 1 Gbps | \(10^9\) |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Gbps | \(10^9\) |'
- en: '| 1 Tbps | \(10^{12}\) |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Tbps | \(10^{12}\) |'
- en: 'To understand some of the principles behind the physical transmission of information,
    let us consider the simple case of an electrical wire that is used to transmit
    bits. Assume that the two communicating hosts want to transmit one thousand bits
    per second. To transmit these bits, the two hosts can agree on the following rules
    :'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解信息物理传输背后的某些原理，让我们考虑一个简单的例子，即用于传输比特的电线路。假设两个通信主机想要以每秒一千比特的速度传输比特。为了传输这些比特，两个主机可以同意以下规则：
- en: 'On the sender side :'
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送方：
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: set the voltage on the electrical wire at `+5V` during one millisecond to transmit
    a bit set to 1
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个毫秒内将电线的电压设置为`+5V`以传输设置为1的比特。
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: set the voltage on the electrical wire at `-5V` during one millisecond to transmit
    a bit set to 0
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个毫秒内将电线的电压设置为`-5V`以传输设置为0的比特。
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the receiver side :'
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收方：
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: every millisecond, record the voltage applied on the electrical wire. If the
    voltage is set to `+5V`, record the reception of bit 1. Otherwise, record the
    reception of bit 0
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每毫秒，记录电线上施加的电压。如果电压设置为`+5V`，则记录接收到的比特1。否则，记录接收到的比特0。
- en: This transmission scheme has been used in some early networks. We use it as
    a basis to understand how hosts communicate. From a computer science viewpoint,
    dealing with voltages is unusual. Computer scientists frequently rely on models
    that enable them to reason about the issues that they face without having to consider
    all implementation details. The physical transmission scheme described above can
    be represented by using a time-sequence diagram.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传输方案被用于一些早期的网络。我们将其作为理解主机如何通信的基础。从计算机科学的角度来看，处理电压是不寻常的。计算机科学家经常依赖于能够使他们推理所面临问题的模型，而无需考虑所有实现细节。上述物理传输方案可以用时间序列图来表示。
- en: A time-sequence diagram describes the interactions between communicating hosts.
    By convention, the communicating hosts are represented in the left and right parts
    of the diagram, while the electrical link occupies the middle of the diagram.
    In such a time-sequence diagram, time flows from the top to the bottom of the
    diagram. The transmission of one bit of information is represented by three arrows.
    Starting from the left, the first horizontal arrow represents the request to transmit
    one bit of information. This request is represented by a primitive, which can
    be considered as a kind of procedure call. This primitive has one parameter (the
    bit being transmitted) and a name (DATA.request in this example). By convention,
    all primitives that are named something.request correspond to a request to transmit
    some information. The dashed arrow indicates the transmission of the corresponding
    electrical signal on the wire. Electrical and optical signals do not travel instantaneously.
    The diagonal dashed arrow indicates that it takes some time for the electrical
    signal to be transmitted from Host A to Host B. Upon reception of the electrical
    signal, the electronics on Host B’s network interface detect the voltage and convert
    it into a bit. This bit is delivered as a DATA.indication primitive. All primitives
    that are named something.indication correspond to the reception of some information.
    The dashed lines also represent the relationship between two (or more) primitives.
    Such a time-sequence diagram provides information about the ordering of the different
    primitives, but the distance between two primitives does not represent a precise
    amount of time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图描述了通信主机之间的交互。按照惯例，通信主机表示在图的左侧和右侧，而电连接占据图的中间部分。在这种时间序列图中，时间从图的顶部流向底部。一个信息位的传输由三个箭头表示。从左侧开始，第一个水平箭头表示请求传输一个信息位。这个请求由一个原语表示，可以将其视为一种过程调用。这个原语有一个参数（要传输的位）和一个名称（例如，本例中的DATA.request）。按照惯例，所有命名为某种.request的原语对应于传输某些信息的要求。虚线箭头表示在电线上传输相应的电信号。电和光信号不会瞬间传播。对角虚线箭头表示电信号从主机A传输到主机B需要一些时间。在接收到电信号后，主机B网络接口上的电子设备检测电压并将其转换为位。这个位作为DATA.indication原语传递。所有命名为某种.indication的原语对应于接收某些信息。虚线还表示两个（或更多）原语之间的关系。这种时间序列图提供了关于不同原语顺序的信息，但两个原语之间的距离并不代表精确的时间量。
- en: '![msc {'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [标签="", 线颜色=白色],
- en: b [label="Host A", linecolour=black],
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [标签="主机A", 线颜色=黑色],
- en: z [label="Physical link", linecolour=white],
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [标签="物理链路", 线颜色=白色],
- en: c [label="Host B", linecolour=black],
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [标签="主机B", 线颜色=黑色],
- en: d [label="", linecolour=white];
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [标签="", 线颜色=白色];
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [标签 = "DATA.req(0)" ] ,
- en: b>>c [ label = "0", arcskip="1"];
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [标签 = "0", 弧跳="1"];
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [标签 = "DATA.ind(0)" ];
- en: '}](../Images/de5f31954ab1b61192e389ebb30fe49c.png)<map id="902747b8597b572a7e1ef798537b1a487e0a6778"
    name="902747b8597b572a7e1ef798537b1a487e0a6778"></map>'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/de5f31954ab1b61192e389ebb30fe49c.png)<map id="902747b8597b572a7e1ef798537b1a487e0a6778"
    name="902747b8597b572a7e1ef798537b1a487e0a6778"></map>'
- en: Time-sequence diagrams are useful when trying to understand the characteristics
    of a given communication scheme. When considering the above transmission scheme,
    it is useful to evaluate whether this scheme allows the two communicating hosts
    to reliably exchange information. A digital transmission is considered reliable
    when a sequence of bits that is transmitted by a host is received correctly at
    the other end of the wire. In practice, achieving perfect reliability when transmitting
    information using the above scheme is difficult. Several problems can occur with
    such a transmission scheme.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图在试图理解给定通信方案的特征时非常有用。在考虑上述传输方案时，评估该方案是否允许两个通信主机可靠地交换信息是有用的。当主机通过一条线正确接收到由主机发送的位序列时，数字传输被认为是可靠的。在实践中，使用上述方案传输信息时实现完美的可靠性是困难的。这种传输方案可能会出现几个问题。
- en: The first problem is that electrical transmission can be affected by electromagnetic
    interference. Interference can have various sources including natural phenomena
    (like thunderstorms, variations of the magnetic field,…) but also other electrical
    signals (such as interference from neighboring cables, interference from neighboring
    antennas,…). Due to these various types of interference, there is unfortunately
    no guarantee that when a host transmits one bit on a wire, the same bit is received
    at the other end. This is illustrated in the figure below where a DATA.request(0)
    on the left host leads to a Data.indication(1) on the right host.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题在于电传输可能会受到电磁干扰的影响。干扰可能来源于自然现象（如雷暴、磁场变化等）以及其他电气信号（如邻近电缆的干扰、邻近天线的干扰等）。由于这些不同类型的干扰，很遗憾，当主机在一条电线上传输一个比特时，并不能保证在另一端接收到的比特是相同的。这在下图中得到了说明，其中左侧主机的
    DATA.request(0) 导致右侧主机的 Data.indication(1)。
- en: '![msc {'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="Physical link", linecolour=white],
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="物理链路", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(1)" ];
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(1)" ];
- en: '}](../Images/72b158d7806ce66e42f4a20fa43137df.png)<map id="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"
    name="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"></map>'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/72b158d7806ce66e42f4a20fa43137df.png)<map id="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"
    name="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"></map>'
- en: With the above transmission scheme, a bit is transmitted by setting the voltage
    on the electrical cable to a specific value during some period of time. We have
    seen that due to electromagnetic interference, the voltage measured by the receiver
    can differ from the voltage set by the transmitter. This is the main cause of
    transmission errors. However, this is not the only type of problem that can occur.
    Besides defining the voltages for bits 0 and 1, the above transmission scheme
    also specifies the duration of each bit. If one million bits are sent every second,
    then each bit lasts 1 microsecond. On each host, the transmission (resp. the reception)
    of each bit is triggered by a local clock having a 1 MHz frequency. These clocks
    are the second source of problems when transmitting bits over a wire. Although
    the two clocks have the same specification, they run on different hosts, possibly
    at a different temperature and with a different source of energy. In practice,
    it is possible that the two clocks do not operate at exactly the same frequency.
    Assume that the clock of the transmitting host operates at exactly 1000000 Hz
    while the receiving clock operates at 999999 Hz. This is a very small difference
    between the two clocks. However, when using the clock to transmit bits, this difference
    is important. With its 1000000 Hz clock, the transmitting host will generate one
    million bits during a period of one second. During the same period, the receiving
    host will sense the wire 999999 times and thus will receive one bit less than
    the bits originally transmitted. This small difference in clock frequencies implies
    that bits can “disappear” during their transmission on an electrical cable. This
    is illustrated in the figure below.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述传输方案中，一个比特是通过在一段时间内将电气电缆上的电压设置为特定值来传输的。我们已经看到，由于电磁干扰，接收器测量的电压可能与发送器设置的电压不同。这是传输错误的主要原因。然而，这并不是唯一可能出现的问题类型。除了定义比特
    0 和 1 的电压外，上述传输方案还指定了每个比特的持续时间。如果每秒发送一百万比特，那么每个比特持续 1 微秒。在每个主机上，每个比特的传输（或接收）都是由一个具有
    1 MHz 频率的本地时钟触发的。这些时钟是传输比特时的第二个问题来源。尽管这两个时钟具有相同的规格，但它们运行在不同的主机上，可能处于不同的温度和不同的能源来源。实际上，两个时钟可能不会以完全相同的频率运行。假设发送主机的时钟运行在
    1000000 Hz，而接收时钟运行在 999999 Hz。这两个时钟之间的差异非常小。然而，当使用时钟来传输比特时，这个差异很重要。具有 1000000
    Hz 时钟的发送主机将在一秒钟内生成一百万比特。在同一时间内，接收主机将检测电线 999999 次，因此将接收到的比特比原始发送的比特少一个。这种时钟频率的小差异意味着比特在通过电气电缆传输过程中可能会“消失”。这在下图中得到了说明。
- en: '![msc {'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="Physical link", linecolour=white],
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="物理链路", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ];
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ];
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(1)" ] ,
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(1)" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(1)" ];
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(1)" ];
- en: '}](../Images/d5c344293b247f77b1781cce32dd951f.png)<map id="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"
    name="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"></map>'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d5c344293b247f77b1781cce32dd951f.png)<map id="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"
    name="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"></map>'
- en: A similar reasoning applies when the clock of the sending host is slower than
    the clock of the receiving host. In this case, the receiver will sense more bits
    than the bits that have been transmitted by the sender. This is illustrated in
    the figure below where the second bit received on the right was not transmitted
    by the left host.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送主机的时钟比接收主机的时钟慢时，类似的推理也适用。在这种情况下，接收者将感知到比发送者已传输的比特更多的比特。这在下图中得到说明，其中右侧接收到的第二个比特并未由左侧主机传输。
- en: '![msc {'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="Physical link", linecolour=white],
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="物理链路", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ] ,
- en: b>>c [ label = "", arcskip=1];
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip=1];
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(1)" ] ,
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(1)" ] ,
- en: b>>c [ label = "", arcskip=1];
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip=1];
- en: c=>d [ label = "DATA.ind(1)" ];
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(1)" ];
- en: '}](../Images/e6f2fc97b4f52f1569c9da37e0a7c885.png)<map id="1344449b0032fa197cd1ad3136ba9de5ea48062d"
    name="1344449b0032fa197cd1ad3136ba9de5ea48062d"></map>'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e6f2fc97b4f52f1569c9da37e0a7c885.png)<map id="1344449b0032fa197cd1ad3136ba9de5ea48062d"
    name="1344449b0032fa197cd1ad3136ba9de5ea48062d"></map>'
- en: 'From a Computer Science viewpoint, the physical transmission of information
    through a wire is often considered as a black box that allows transmitting bits.
    This black box is commonly referred to as the physical layer service and is represented
    by using the DATA.request and DATA.indication primitives introduced earlier. This
    physical layer service facilitates the sending and receiving of bits, by abstracting
    the technological details that are involved in the actual transmission of the
    bits as an electromagnetic signal. However, it is important to remember that the
    physical layer service is imperfect and has the following characteristics :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机科学的角度来看，通过电线传输信息通常被视为一个黑盒，它允许传输比特。这个黑盒通常被称为物理层服务，并且通过使用之前引入的DATA.request和DATA.indication原语来表示。这个物理层服务通过抽象实际比特电磁信号传输所涉及的技术细节来促进比特的发送和接收。然而，重要的是要记住，物理层服务是不完美的，并具有以下特性：
- en: the Physical layer service may change, e.g. due to electromagnetic interference,
    the value of a bit being transmitted
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层服务可能会改变，例如，由于电磁干扰，正在传输的比特值
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Physical layer service may deliver more bits to the receiver than the bits
    sent by the sender
  id: totrans-113
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层服务可能向接收者交付的比特数多于发送者发送的比特数
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Physical layer service may deliver fewer bits to the receiver than the bits
    sent by the sender.
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层服务可能向接收者交付的比特数少于发送者发送的比特数。
- en: 'Many other types of encodings have been defined to transmit information over
    an electrical cable. All physical layers are able to send and receive physical
    symbols that represent values 0 and 1. However, for various reasons that are outside
    the scope of this chapter, several physical layers exchange other physical symbols
    as well. For example, the Manchester encoding used in several physical layers
    can send four different symbols. The Manchester encoding is a differential encoding
    scheme in which time is divided into fixed-length periods. Each period is divided
    into two halves and two different voltage levels can be applied. To send a symbol,
    the sender must set one of these two voltage levels during each half period. To
    send a 1 (resp. 0), the sender must set a high (resp. low) voltage during the
    first half of the period and a low (resp. high) voltage during the second half.
    This encoding ensures that there will be a transition at the middle of each period
    and allows the receiver to synchronize its clock to the sender’s clock. Apart
    from the encodings for 0 and 1, the Manchester encoding also supports two additional
    symbols : InvH and InvB where the same voltage level is used for the two half
    periods. By definition, these two symbols cannot appear inside a frame which is
    only composed of 0 and 1. Some technologies use these special symbols as markers
    for the beginning or end of frames. This encoding is illustrated in [Fig. 2](#fig-manchester).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了许多其他类型的编码方案，用于在电线上传输信息。所有物理层都能够发送和接收代表值0和1的物理符号。然而，由于本章范围之外的各种原因，几个物理层也交换其他物理符号。例如，在几个物理层中使用的曼彻斯特编码可以发送四个不同的符号。曼彻斯特编码是一种差分编码方案，其中时间被分为固定长度的周期。每个周期被分为两个半周期，并且可以应用两种不同的电压水平。为了发送一个符号，发送者必须在每个半周期中设置这两种电压水平之一。为了发送1（或0），发送者必须在周期的第一个半周期中设置高（或低）电压，在第二个半周期中设置低（或高）电压。这种编码确保在每个周期的中间会有一个转换，并允许接收者将时钟与发送者的时钟同步。除了0和1的编码之外，曼彻斯特编码还支持两个额外的符号：InvH和InvB，其中两个半周期使用相同的电压水平。根据定义，这两个符号不能出现在仅由0和1组成的帧中。一些技术使用这些特殊符号作为帧的开始或结束的标记。这种编码在[图2](#fig-manchester)中展示。
- en: '[![../_images/manchester.png](../Images/227f8d0faa5ea71ea44d3e6f473898e6.png)](../_images/manchester.png)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/manchester.png](../Images/227f8d0faa5ea71ea44d3e6f473898e6.png)](../_images/manchester.png)'
- en: Fig. 2 Manchester encoding[#](#fig-manchester "Link to this image")
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2 曼彻斯特编码[#](#fig-manchester "链接到这张图片")
- en: When the physical layer transmits a bit of information using light or an electromagnetic
    signal, there is no guarantee that the bit sent by the transmitter will be received
    as it was sent by the receiver. Several types of errors can impact this transmission.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理层使用光或电磁信号传输一个信息位时，不能保证发送者发送的位会被接收者以相同的方式接收。几种类型的错误可能会影响这种传输。
- en: Information Theory defines two mechanisms that can be used to transmit information
    over a channel affected by random errors. These two mechanisms add redundancy
    to the transmitted information, to allow the receiver to detect or sometimes even
    correct transmission errors. A detailed discussion of these mechanisms is outside
    the scope of this chapter, but it is useful to consider a simple mechanism to
    understand its operation and its limitations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 信息论定义了两种机制，这些机制可以用于在受随机错误影响的信道上传输信息。这两种机制向传输的信息中添加冗余，以便接收者能够检测或有时甚至纠正传输错误。对这些机制的详细讨论超出了本章的范围，但考虑一个简单的机制来理解其操作和限制是有用的。
- en: 'Information theory defines coding schemes. There are different types of coding
    schemes, but let us focus on coding schemes that operate on binary strings. A
    coding scheme is a function that maps information encoded as a string of m bits
    into a string of n bits. The simplest coding scheme is the (even) parity coding.
    This coding scheme takes an m bits source string and produces an m+1 bits coded
    string where the first m bits of the coded string are the bits of the source string
    and the last bit of the coded string is chosen such that the coded string will
    always contain an even number of bits set to 1. For example :'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 信息论定义了编码方案。存在不同类型的编码方案，但让我们关注在二进制字符串上操作的编码方案。编码方案是一个函数，它将编码为m位字符串的信息映射到n位字符串。最简单的编码方案是（偶数）奇偶校验编码。这种编码方案接受一个m位源字符串，并生成一个m+1位的编码字符串，其中编码字符串的前m位是源字符串的位，编码字符串的最后一位被选择，使得编码字符串将始终包含偶数个设置为1的位。例如：
- en: 1001 is encoded as 10010
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001编码为10010
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1101 is encoded as 11011
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1101被编码为11011
- en: This parity scheme has been used in some RAMs as well as to encode characters
    sent over a serial line. It is easy to show that this coding scheme allows the
    receiver to detect a single transmission error, but it cannot correct it. However,
    if two or more bits are in error, the receiver may not always be able to detect
    the error.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种奇偶校验方案已被用于一些RAM以及通过串行线发送的字符编码。很容易证明这种编码方案允许接收者检测单个传输错误，但不能纠正它。然而，如果有两个或更多比特出错，接收者可能无法总是检测到错误。
- en: 'Some coding schemes allow the receiver to correct some transmission errors.
    For example, consider the coding scheme that encodes each source bit as follows
    :'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编码方案允许接收者纠正一些传输错误。例如，考虑以下编码方案，它将每个源比特编码如下：
- en: 1 is encoded as 111
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1被编码为111
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 is encoded as 000
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0被编码为000
- en: For example, consider a sender that sends 111. If there is one bit in error,
    the receiver could receive 011 or 101 or 110. In these three cases, the receiver
    will decode the received bit pattern as a 1 since it contains a majority of bits
    set to 1. If there are two bits in error, the receiver will not be able anymore
    to recover from the transmission error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个发送111的发送者。如果有一个比特出错，接收者可能会收到011或101或110。在这三种情况下，接收者将解码接收到的比特模式为1，因为它包含大多数设置为1的比特。如果有两个比特出错，接收者将无法从传输错误中恢复。
- en: This simple coding scheme forces the sender to transmit three bits for each
    source bit. However, it allows the receiver to correct single bit errors. More
    advanced coding systems that allow recovering from errors are used in several
    types of physical layers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的编码方案迫使发送者对每个源比特传输三个比特。然而，它允许接收者纠正单个比特错误。在多种类型的物理层中，使用了一些允许从错误中恢复的更高级的编码系统。
- en: 'To understand error detection codes, let us consider two devices that exchange
    bit strings containing N bits. To allow the receiver to detect a transmission
    error, the sender converts each string of N bits into a string of N+r bits. Usually,
    the r redundant bits are added at the beginning or the end of the transmitted
    bit string, but some techniques interleave redundant bits with the original bits.
    An error detection code can be defined as a function that computes the r redundant
    bits corresponding to each string of N bits. The simplest error detection code
    is the parity bit. There are two types of parity schemes : even and odd parity.
    With the even (resp. odd) parity scheme, the redundant bit is chosen so that an
    even (resp. odd) number of bits are set to 1 in the transmitted bit string of
    N+r bits. The receiver can easily recompute the parity of each received bit string
    and discard the strings with an invalid parity. The parity scheme is often used
    when 7-bit characters are exchanged. In this case, the eighth bit is often a parity
    bit. The table below shows the parity bits that are computed for bit strings containing
    three bits.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解错误检测码，让我们考虑两个交换包含N比特的比特字符串的设备。为了允许接收者检测传输错误，发送者将每个N比特的字符串转换为N+r比特的字符串。通常，r个冗余比特被添加到传输比特字符串的开始或结束处，但某些技术将冗余比特与原始比特交织。错误检测码可以定义为计算每个N比特字符串对应的r个冗余比特的函数。最简单的错误检测码是奇偶校验位。有两种类型的奇偶校验方案：偶校验和奇校验。在偶校验（分别奇校验）方案中，冗余比特被选择，使得在N+r比特的传输字符串中设置1的比特数为偶数（分别奇数）。接收者可以轻松地重新计算每个接收到的比特字符串的奇偶校验，并丢弃无效奇偶校验的字符串。奇偶校验方案通常用于交换7位字符的情况。在这种情况下，第八位通常是一个奇偶校验位。下表显示了包含三个比特的比特字符串计算出的奇偶校验位。
- en: '| 3 bits string | Odd parity | Even parity |'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 3比特字符串 | 奇偶校验 | 偶校验 |'
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 000 | 1 | 0 |'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 000 | 1 | 0 |'
- en: '| 001 | 0 | 1 |'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 001 | 0 | 1 |'
- en: '| 010 | 0 | 1 |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 010 | 0 | 1 |'
- en: '| 100 | 0 | 1 |'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 100 | 0 | 1 |'
- en: '| 111 | 0 | 1 |'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 111 | 0 | 1 |'
- en: '| 110 | 1 | 0 |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 110 | 1 | 0 |'
- en: '| 101 | 1 | 0 |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 101 | 1 | 0 |'
- en: '| 011 | 1 | 0 |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 011 | 1 | 0 |'
- en: The parity bit allows a receiver to detect transmission errors that have affected
    a single bit among the transmitted N+r bits. If there are two or more bits in
    error, the receiver may not necessarily be able to detect the transmission error.
    More powerful error detection schemes have been defined. The Cyclical Redundancy
    Checks (CRC) are widely used in datalink layer protocols. An N-bits CRC can detect
    all transmission errors affecting a burst of less than N bits in the transmitted
    frame and all transmission errors that affect an odd number of bits. Additional
    details about CRCs may be found in [[Williams1993]](../bibliography.html#williams1993).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 奇偶校验位允许接收器检测到影响传输的N+r位中单个位的传输错误。如果有两个或更多位出错，接收器可能无法必然检测到传输错误。已经定义了更强大的错误检测方案。循环冗余校验（CRC）在数据链路层协议中得到广泛应用。N位CRC可以检测到影响传输帧中少于N位的突发错误以及影响奇数位数的传输错误。有关CRC的更多详细信息，请参阅[[Williams1993]](../bibliography.html#williams1993)。
- en: It is also possible to design a code that allows the receiver to correct transmission
    errors. The simplest error correction code is the triple modular redundancy (TMR).
    To transmit a bit set to 1 (resp. 0), the sender transmits 111 (resp. 000). When
    there are no transmission errors, the receiver can decode 111 as 1. If transmission
    errors have affected a single bit, the receiver performs majority voting as shown
    in the table below. This scheme allows the receiver to correct all transmission
    errors that affect a single bit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以设计一种代码，允许接收器纠正传输错误。最简单的纠错码是三模冗余（TMR）。要传输设置为1的位（分别对应0），发送方发送111（分别对应000）。在没有传输错误的情况下，接收器可以将111解码为1。如果传输错误影响了一个位，接收器将执行如以下表格所示的多数投票。这种方案允许接收器纠正影响单个位的所有传输错误。
- en: '| Received bits | Decoded bit |'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 接收到的位 | 解码位 |'
- en: '| --- | --- |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 | 0 |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 000 | 0 |'
- en: '| 001 | 0 |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 001 | 0 |'
- en: '| 010 | 0 |'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 010 | 0 |'
- en: '| 100 | 0 |'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 100 | 0 |'
- en: '| 111 | 1 |'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 111 | 1 |'
- en: '| 110 | 1 |'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 110 | 1 |'
- en: '| 101 | 1 |'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 101 | 1 |'
- en: '| 011 | 1 |'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 011 | 1 |'
- en: Other more powerful error correction codes have been proposed and are used in
    some applications. The [Hamming Code](https://en.wikipedia.org/wiki/Hamming_code)
    is a clever combination of parity bits that provides error detection and correction
    capabilities.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 还提出了其他更强大的纠错码，并在某些应用中使用。[汉明码](https://en.wikipedia.org/wiki/Hamming_code)是奇偶校验位的巧妙组合，提供了错误检测和纠正能力。
- en: All the functions related to the physical transmission or information through
    a wire (or a wireless link) are usually known as the physical layer. The physical
    layer allows two or more entities that are directly attached to the same transmission
    medium to exchange bits. Being able to exchange bits is important as virtually
    any information can be encoded as a sequence of bits. Electrical engineers are
    used to processing streams of bits, but computer scientists usually prefer to
    deal with higher-level concepts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与通过电线（或无线链路）进行物理传输或信息相关的功能通常被称为物理层。物理层允许直接连接到同一传输介质的两个或多个实体交换位。能够交换位很重要，因为几乎任何信息都可以编码为位序列。电气工程师习惯于处理位流，但计算机科学家通常更喜欢处理更高级的概念。
- en: A similar issue arises with file storage. Storage devices such as hard-disks
    also store streams of bits. There are hardware devices that process the bit stream
    produced by a hard-disk, but computer scientists have designed filesystems to
    allow applications to easily access such storage devices. These filesystems are
    typically divided into several layers as well. Hard-disks store sectors of 512
    bytes or more. Unix filesystems group sectors in larger blocks that can contain
    data or inodes representing the structure of the filesystem. Finally, applications
    manipulate files and directories that are translated into blocks, sectors, and
    eventually bits by the operating system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件存储方面也存在类似的问题。硬盘等存储设备也存储位流。有硬件设备可以处理硬盘产生的位流，但计算机科学家设计了文件系统，以便应用程序可以轻松访问这些存储设备。这些文件系统通常分为几个层次。硬盘存储512字节或更多的扇区。Unix文件系统将扇区分组到更大的块中，这些块可以包含数据或表示文件系统结构的inode。最后，应用程序操作文件和目录，这些文件和目录由操作系统转换为块、扇区和最终位。
- en: Computer networks use a similar approach. Each layer provides a service that
    is built above the underlying layer and is closer to the needs of the applications.
    [Fig. 3](#fig-physical-layer) represents the lower layer of the protocol stack.
    We will explore the different layers of this stack in this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络使用类似的方法。每一层都提供了一种服务，该服务建立在底层之上，更接近应用的需求。[图3](#fig-physical-layer) 表示协议栈的底层。我们将在这本书中探讨这个栈的不同层。
- en: '![Figure made with TikZ](../Images/cdafb80a85063c028d33d656b5dea86a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/cdafb80a85063c028d33d656b5dea86a.png)'
- en: 'Fig. 3 The Physical layer  ## The datalink layer[#](#the-datalink-layer "Link
    to this heading")'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '图3 物理层  ## 数据链路层[#](#the-datalink-layer "链接到这个标题")'
- en: Computer scientists are usually not interested in exchanging bits between two
    hosts. They prefer to write software that deals with larger blocks of data in
    order to transmit messages or complete files. Thanks to the physical layer service,
    it is possible to send a continuous stream of bits between two hosts. This stream
    of bits can include logical blocks of data, but we need to be able to extract
    each block of data from the bit stream despite the imperfections of the physical
    layer. In many networks, the basic unit of information exchanged between two directly
    connected hosts is often called a frame. A frame can be defined as a sequence
    of bits that has a particular syntax or structure. We will see examples of such
    frames later in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家通常对在两个主机之间交换比特不感兴趣。他们更愿意编写处理更大数据块以传输消息或完成文件的软件。多亏了物理层服务，才有可能在两个主机之间发送连续的比特流。这个比特流可以包括逻辑数据块，但我们需要能够从比特流中提取每个数据块，尽管物理层存在缺陷。在许多网络中，两个直接连接的主机之间交换的基本信息单位通常被称为帧。帧可以被定义为具有特定语法或结构的比特序列。我们将在本章后面看到此类帧的示例。
- en: To enable the transmission/reception of frames, the first problem to be solved
    is how to encode a frame as a sequence of bits, so that the receiver can easily
    recover the received frame despite the limitations of the physical layer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现帧的传输/接收，首先要解决的问题是如何将帧编码为比特序列，以便接收器可以轻松地从物理层接收到的比特流中恢复接收到的帧，尽管物理层存在限制。
- en: If the physical layer were perfect, the problem would be very simple. We would
    simply need to define how to encode each frame as a sequence of consecutive bits.
    The receiver would then easily be able to extract the frames from the received
    bits. Unfortunately, the imperfections of the physical layer make this framing
    problem slightly more complex. Several solutions have been proposed and are used
    in practice in different network technologies.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物理层是完美的，问题将会非常简单。我们只需定义如何将每个帧编码为一系列连续的比特。接收器随后将能够轻松地从接收到的比特中提取帧。不幸的是，物理层的缺陷使得这个问题稍微复杂一些。已经提出了几种解决方案，并在不同的网络技术中得到了实际应用。
- en: Framing[#](#framing "Link to this heading")
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧问题[#](#framing "链接到这个标题")
- en: 'The framing problem can be defined as : “How does a sender encode frames so
    that the receiver can efficiently extract them from the stream of bits that it
    receives from the physical layer”.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 帧问题可以定义为：“发送者如何编码帧，以便接收者可以从它从物理层接收到的比特流中有效地提取它们”。
- en: A first solution to this problem is to require the physical layer to remain
    idle for some time after the transmission of each frame. These idle periods can
    be detected by the receiver and serve as a marker to delineate frame boundaries.
    Unfortunately, this solution is not acceptable for two reasons. First, some physical
    layers cannot remain idle and always need to transmit bits. Second, inserting
    an idle period between frames decreases the maximum bit rate that can be achieved.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一个方案是要求物理层在每个帧传输后保持一段时间空闲。接收器可以检测到这些空闲时间段，并作为标记来界定帧边界。不幸的是，这个解决方案不可接受，有两个原因。首先，某些物理层不能保持空闲，并且总是需要传输比特。其次，在帧之间插入空闲时间段会降低可以达到的最大比特率。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bit rate and bandwidth
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率和带宽
- en: Bit rate and bandwidth are often used to characterize the transmission capacity
    of the physical service. The original definition of [bandwidth](https://www.merriam-webster.com/dictionary/bandwidth),
    as listed in the [Webster dictionary](https://www.merriam-webster.com/dictionary)
    is a range of radio frequencies which is occupied by a modulated carrier wave,
    which is assigned to a service, or over which a device can operate. This definition
    corresponds to the characteristics of a given transmission medium or receiver.
    For example, the human ear is able to decode sounds in roughly the 0-20 KHz frequency
    range. By extension, bandwidth is also used to represent the capacity of a communication
    system in bits per second. For example, a Gigabit Ethernet link is theoretically
    capable of transporting one billion bits per second.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率和带宽通常用于表征物理服务的传输能力。在[韦伯斯特词典](https://www.merriam-webster.com/dictionary)中列出的[带宽](https://www.merriam-webster.com/dictionary/bandwidth)的原始定义是一个被调制载波波占用的无线电频率范围，该频率范围分配给某个服务，或者设备可以在其上运行。这个定义对应于特定传输介质或接收器的特性。例如，人耳能够解码大约0-20
    KHz频率范围内的声音。通过扩展，带宽也用来表示通信系统每秒的比特容量。例如，千兆以太网链路理论上能够每秒传输十亿比特。
- en: 'Given that multi-symbol encodings cannot be used by all physical layers, a
    generic solution which can be used with any physical layer that is able to transmit
    and receive only bits 0 and 1 is required. This generic solution is called stuffing
    and two variants exist : bit stuffing and character stuffing. To enable a receiver
    to easily delineate the frame boundaries, these two techniques reserve special
    bit strings as frame boundary markers and encode the frames so that these special
    bit strings do not appear inside the frames.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多符号编码不能被所有物理层使用，因此需要一个通用的解决方案，该方案可以与任何只能传输和接收0和1比特的物理层一起使用。这个通用解决方案被称为填充，并且存在两种变体：比特填充和字符填充。为了使接收器能够轻松地划分帧边界，这两种技术保留特殊的比特串作为帧边界标记，并编码帧，以确保这些特殊的比特串不会出现在帧内部。
- en: Bit stuffing reserves the 01111110 bit string as the frame boundary marker and
    ensures that there will never be six consecutive 1 symbols transmitted by the
    physical layer inside a frame. With bit stuffing, a frame is sent as follows.
    First, the sender transmits the marker, i.e. 01111110. Then, it sends all the
    bits of the frame and inserts an additional bit set to 0 after each sequence of
    five consecutive 1 bits. This ensures that the sent frame never contains a sequence
    of six consecutive bits set to 1. As a consequence, the marker pattern cannot
    appear inside the frame sent. The marker is also sent to mark the end of the frame.
    The receiver performs the opposite to decode a received frame. It first detects
    the beginning of the frame thanks to the 01111110 marker. Then, it processes the
    received bits and counts the number of consecutive bits set to 1. If a 0 follows
    five consecutive bits set to 1, this bit is removed since it was inserted by the
    sender. If a 1 follows five consecutive bits set to 1, it indicates a marker if
    it is followed by a bit set to 0. The table below illustrates the application
    of bit stuffing to some frames.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 比特填充保留01111110比特串作为帧边界标记，并确保物理层在帧内不会连续传输六个1符号。使用比特填充时，帧的发送方式如下。首先，发送者传输标记，即01111110。然后，它发送帧的所有比特，并在每个连续五个1比特的序列后插入一个额外的设置为0的比特。这确保发送的帧永远不会包含连续六个设置为1的比特序列。因此，标记模式不能出现在发送的帧内部。标记也被发送以标记帧的结束。接收器执行相反的操作来解码接收到的帧。它首先通过01111110标记检测到帧的开始。然后，它处理接收到的比特并计算连续设置为1的比特数量。如果一个0跟在五个连续设置为1的比特之后，这个比特被移除，因为它是由发送者插入的。如果一个1跟在五个连续设置为1的比特之后，并且后面跟着一个设置为0的比特，它表示一个标记。下表说明了比特填充在几个帧中的应用。
- en: '| Original frame | Transmitted frame |'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 原始帧 | 传输帧 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0001001001001001001000011 | 01111110000100100100100100100001101111110 |'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0001001001001001001000011 | 01111110000100100100100100100001101111110 |'
- en: '| 0110111111111111111110010 | 01111110011011111011111011111011001001111110
    |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0110111111111111111110010 | 01111110011011111011111011111011001001111110
    |'
- en: '| 0111110 | 011111100111110001111110 |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0111110 | 011111100111110001111110 |'
- en: '| 01111110 | 0111111001111101001111110 |'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 01111110 | 0111111001111101001111110 |'
- en: For example, consider the transmission of 0110111111111111111110010. The sender
    will first send the 01111110 marker followed by 011011111. After these five consecutive
    bits set to 1, it inserts a bit set to 0 followed by 11111. A new 0 is inserted,
    followed by 11111. A new 0 is inserted followed by the end of the frame 110010
    and the 01111110 marker.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑传输0110111111111111111110010。发送者将首先发送01111110标记，然后是011011111。在这些五个连续的设置为1的比特之后，它插入一个设置为0的比特，然后是11111。插入一个新的0，然后是11111。插入一个新的0，然后是帧的结束110010和01111110标记。
- en: Bit stuffing increases the number of bits required to transmit each frame. The
    worst case for bit stuffing is of course a long sequence of bits set to 1 inside
    the frame. If transmission errors occur, stuffed bits or markers can be in error.
    In these cases, the frame affected by the error and possibly the next frame will
    not be correctly decoded by the receiver, but it will be able to resynchronize
    itself at the next valid marker.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 比特填充增加了传输每个帧所需的比特数。比特填充的最坏情况当然是帧内连续的设置为1的比特序列。如果发生传输错误，填充的比特或标记可能会出错。在这些情况下，受错误影响的帧以及可能的下一个帧将不会被接收者正确解码，但它将在下一个有效的标记处重新同步自己。
- en: 'Bit stuffing can be easily implemented in hardware. However, implementing it
    in software is difficult given the complexity of performing bit manipulations
    in software. Software implementations prefer to process characters than bits;
    software-based datalink layers usually use character stuffing. This technique
    operates on frames that contain an integer number of characters. In computer networks,
    characters are usually encoded by relying on the [ASCII](../glossary.html#term-ASCII)
    table. This table defines the encoding of various alphanumeric characters as a
    sequence of bits. [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html)
    provides the ASCII table that is used by many Internet protocols. For example,
    the table defines the following binary representations :'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 比特填充可以在硬件中轻松实现。然而，考虑到在软件中执行位操作复杂性，在软件中实现它则较为困难。基于软件的实现更倾向于处理字符而不是比特；基于软件的数据链路层通常使用字符填充。这种技术作用于包含整数个字符的帧。在计算机网络中，字符通常通过依赖于[ASCII](../glossary.html#term-ASCII)表进行编码。该表定义了各种字母数字字符的编码为一系列比特。[**RFC
    20**](https://datatracker.ietf.org/doc/html/rfc20.html)提供了许多互联网协议使用的ASCII表。例如，该表定义了以下二进制表示：
- en: 'A : 1000011 b'
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'A : 1000011 b'
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0 : 0110000 b'
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0 : 0110000 b'
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'z : 1111010 b'
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'z : 1111010 b'
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '@ : 1000000 b'
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@ : 1000000 b'
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'space : 0100000 b'
  id: totrans-196
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'space : 0100000 b'
- en: In addition, the [ASCII](../glossary.html#term-ASCII) table also defines several
    non-printable or control characters. These characters were designed to allow an
    application to control a printer or a terminal. These control characters include
    CR and LF, that are used to terminate a line, and the BEL character which causes
    the terminal to emit a sound.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[ASCII](../glossary.html#term-ASCII)表还定义了几个不可打印或控制字符。这些字符被设计为允许应用程序控制打印机或终端。这些控制字符包括CR和LF，用于结束一行，以及引起终端发出声音的BEL字符。
- en: 'NUL: 0000000 b'
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NUL: 0000000 b'
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'BEL: 0000111 b'
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BEL: 0000111 b'
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CR : 0001101 b'
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CR : 0001101 b'
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LF : 0001010 b'
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LF : 0001010 b'
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DLE: 0010000 b'
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DLE: 0010000 b'
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'STX: 0000010 b'
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'STX: 0000010 b'
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ETX: 0000011 b'
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ETX: 0000011 b'
- en: Some characters are used as markers to delineate the frame boundaries. Many
    character stuffing techniques use the DLE, STX, and ETX characters of the ASCII
    character set. DLE STX (resp. DLE ETX) is used to mark the beginning (end) of
    a frame. When transmitting a frame, the sender adds a DLE character after each
    transmitted DLE character. This ensures that none of the markers can appear inside
    the transmitted frame. The receiver detects the frame boundaries and removes the
    second DLE when it receives two consecutive DLE characters. For example, to transmit
    frame 1 2 3 DLE STX 4, a sender will first send DLE STX as a marker, followed
    by 1 2 3 DLE. Then, the sender transmits an additional DLE character followed
    by STX 4 and the DLE ETX marker.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符用作标记以界定帧边界。许多字符填充技术使用ASCII字符集中的DLE、STX和ETX字符。DLE STX（分别DLE ETX）用于标记帧的开始（结束）。在传输帧时，发送者在每个传输的DLE字符后添加一个DLE字符。这确保了没有标记可以出现在传输的帧中。接收者检测帧边界，并在接收到两个连续的DLE字符时移除第二个DLE。例如，为了传输帧1
    2 3 DLE STX 4，发送者将首先发送DLE STX作为标记，然后是1 2 3 DLE。然后，发送者传输一个额外的DLE字符，然后是STX 4和DLE
    ETX标记。
- en: '| Original frame | Transmitted frame |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 原始帧 | 传输帧 |'
- en: '| --- | --- |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1** **2** **3** **4** | DLE STX **1** **2** **3** **4** DLE ETX |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **1** **2** **3** **4** | DLE STX **1** **2** **3** **4** DLE ETX |'
- en: '| **1** **2** **3** **DLE** **STX** **4** | DLE STX **1** **2** **3** **DLE**
    DLE **STX** **4** DLE ETX |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **1** **2** **3** **DLE** **STX** **4** | DLE STX **1** **2** **3** **DLE**
    DLE **STX** **4** DLE ETX |'
- en: '| **DLE STX DLE ETX** | DLE STX **DLE** DLE **STX** **DLE** DLE **ETX** DLE
    ETX |'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **DLE STX DLE ETX** | DLE STX **DLE** DLE **STX** **DLE** DLE **ETX** DLE
    ETX |'
- en: Character stuffing, like bit stuffing, increases the length of the transmitted
    frames. For character stuffing, the worst frame is a frame containing many DLE
    characters. When transmission errors occur, the receiver may incorrectly decode
    one or two frames (e.g. if the errors occur in the markers). However, it will
    be able to resynchronize itself with the next correctly received markers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于位填充，字符填充增加了传输帧的长度。对于字符填充，最糟糕的帧是包含许多DLE字符的帧。当发生传输错误时，接收器可能会错误地解码一个或两个帧（例如，如果错误发生在标记处）。然而，它将能够通过下一个正确接收到的标记与自身重新同步。
- en: Bit stuffing and character stuffing allow recovering frames from a stream of
    bits or bytes. This framing mechanism provides a richer service than the physical
    layer. Through the framing service, one can send and receive complete frames.
    This framing service can also be represented by using the DATA.request and DATA.indication
    primitives. This is illustrated in the figure below, assuming hypothetical frames
    containing four useful bits and one bit of framing for graphical reasons.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充和字符填充允许从位或字节流中恢复帧。这种帧机制比物理层提供了更丰富的服务。通过帧服务，可以发送和接收完整的帧。这种帧服务也可以通过使用DATA.request和DATA.indication原语来表示。这在下图中说明，假设包含四个有效位和一个用于图形原因的帧填充位。
- en: '![msc {'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: bf [label="Framing-A", linecolour=black],
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf [label="Framing-A", linecolour=black],
- en: bp [label="Phys-A", linecolour=black],
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp [label="Phys-A", linecolour=black],
- en: cp [label="Phys-B", linecolour=black],
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp [label="Phys-B", linecolour=black],
- en: cf [label="Framing-B", linecolour=black],
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf [label="Framing-B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>bf [ label = "DATA.req(1...1)", textcolour=red ];
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>bf [ label = "DATA.req(1...1)", textcolour=red ];
- en: bf=>bp [label="DATA.req(0)"],
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(0)"],
- en: bp>>cp [label="0", arcskip=1];
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="0", arcskip=1];
- en: cp=>cf [label="DATA.ind(0)"];
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(0)"];
- en: bf=>bp [label="DATA.req(1)"],
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(1)"],
- en: bp>>cp [label="1", arcskip=1];
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="1", arcskip=1];
- en: cp=>cf [label="DATA.ind(1)"];
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(1)"];
- en: '...;'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...;'
- en: bf=>bp [label="DATA.req(1)"],
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(1)"],
- en: bp>>cp [label="1", arcskip=1];
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="1", arcskip=1];
- en: cp=>cf [label="DATA.ind(1)"];
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(1)"];
- en: bf=>bp [label="DATA.req(0)"],
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(0)"],
- en: bp>>cp [label="0", arcskip=1];
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="0", arcskip=1];
- en: cp=>cf [label="DATA.ind(0)"];
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(0)"];
- en: cf=>d [ label = "DATA.ind(1...1)", textcolour=red ];
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf=>d [ label = "DATA.ind(1...1)", textcolour=red ];
- en: '}](../Images/d93486326d5734107393c5cb08e5b59f.png)<map id="978f9dd07afce7e83d1ec64540abe819ff60d9d8"
    name="978f9dd07afce7e83d1ec64540abe819ff60d9d8"></map>'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图片](../Images/d93486326d5734107393c5cb08e5b59f.png)<map id="978f9dd07afce7e83d1ec64540abe819ff60d9d8"
    name="978f9dd07afce7e83d1ec64540abe819ff60d9d8"></map>'
- en: We can now build upon the framing mechanism to allow the hosts to exchange frames
    containing an integer number of bits or bytes. Once the framing problem has been
    solved, we can use these frames to carry Internet packets.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以基于帧机制来允许主机交换包含整数个位或字节的帧。一旦解决了帧问题，我们就可以使用这些帧来携带互联网数据包。
- en: Coping with transmission errors[#](#coping-with-transmission-errors "Link to
    this heading")
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应对传输错误[#](#coping-with-transmission-errors "链接到这个标题")
- en: 'As explained earlier, the physical layer can be subject to various types that
    affect the bits sent by a transmitter. Data transmission on a physical link can
    be affected by the following errors :'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，物理层可能受到各种类型的影响，这些类型会影响发送器发送的位。物理链路上的数据传输可能受到以下错误的影响：
- en: random isolated errors where the value of a single bit has been modified due
    to a transmission error
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于传输错误而修改单个位值的随机孤立错误
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: random burst errors where the values of n consecutive bits have been changed
    due to transmission errors
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于传输错误而改变n个连续位值的随机突发错误
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: random bit creations and random bit removals where bits have been added or removed
    due to transmission errors
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于传输错误而添加或删除位导致的随机位创建和随机位删除
- en: Besides framing, datalink layers also include mechanisms to detect and sometimes
    even recover from transmission errors. To allow a receiver to notice transmission
    errors, a sender must add some redundant information as an error detection code
    to the frame sent. This error detection code is computed by the sender on the
    frame that it transmits. When the receiver receives a frame with an error detection
    code, it recomputes it and verifies whether the received error detection code
    matches the computed error detection code. If they match, the frame is considered
    to be valid.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帧定界外，数据链路层还包括检测和有时甚至从传输错误中恢复的机制。为了使接收器注意到传输错误，发送器必须在发送的帧中添加一些冗余信息作为错误检测码。这个错误检测码是由发送器在其发送的帧上计算的。当接收器收到带有错误检测码的帧时，它会重新计算它并验证接收到的错误检测码是否与计算出的错误检测码匹配。如果它们匹配，则认为该帧是有效的。
- en: '[PRE0]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Framing on the Internet
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的帧定界
- en: The bit stuffing and character stuffing described above are generic solutions
    applied by various protocols. When Internet hosts used dial-up modems or serial
    transmission to exchange data, they used protocols such as SLIP defined in [**RFC
    1035**](https://datatracker.ietf.org/doc/html/rfc1035.html) or PPP defined in
    [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的位填充和字符填充是各种协议中应用的通用解决方案。当互联网主机使用拨号调制解调器或串行传输交换数据时，它们使用了在[**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html)中定义的SLIP协议或在[**RFC
    1661**](https://datatracker.ietf.org/doc/html/rfc1661.html)中定义的PPP协议。
- en: The Serial Line IP (SLIP) protocol uses character stuffing with two special
    characters (`END`, 192 in decimal and `ESC`, 219 in decimal).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 串行线路IP（SLIP）协议使用两个特殊字符（`END`，十进制192和`ESC`，十进制219）进行字符填充。
- en: The Point-to-Point Protocol (PPP) supports different techniques of framing.
    [**RFC 1662**](https://datatracker.ietf.org/doc/html/rfc1662.html) describes how
    character stuffing and bit stuffing can be used by PPP.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点协议（PPP）支持不同的帧定界技术。[**RFC 1662**](https://datatracker.ietf.org/doc/html/rfc1662.html)描述了PPP如何使用字符填充和位填充。
- en: '[Fig. 126](../networks/network.html#fig-datalink-layer) illustrates the second
    layer of the protocol stack that uses the services provided by the Physical layer
    to exchange frames. We will use the word frame throughout this book to refer to
    the unit of information exchanged between two datalink layer entities.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[图126](../networks/network.html#fig-datalink-layer)说明了使用物理层提供的服务的协议栈的第二层，该层交换帧。在这本书中，我们将使用“帧”一词来指代两个数据链路层实体之间交换的信息单元。'
- en: '![Figure made with TikZ](../Images/45dcd309f199df5246b8a933469eb608.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/45dcd309f199df5246b8a933469eb608.png)'
- en: Fig. 4 The Datalink layer in the protocol stack
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图4 协议栈中的数据链路层
- en: The network layer[#](#the-network-layer "Link to this heading")
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络层[#](#the-network-layer "链接到本标题")
- en: The Datalink layer allows directly connected hosts to exchange information,
    but it is often necessary to exchange information between hosts that are not attached
    to the same physical medium. This is the task of the network layer. The network
    layer is built above the datalink layer. Network layer entities exchange packets.
    A packet is a finite sequence of bytes that is transported by the datalink layer
    inside one or more frames. A packet usually contains information about its origin
    and its destination, and usually passes through several intermediate devices called
    routers on its way from its origin to its destination. This is illustrated in
    [Fig. 5](#fig-network-layer).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层允许直接连接的主机交换信息，但通常需要在未连接到同一物理介质的主机之间交换信息。这是网络层的任务。网络层建立在数据链路层之上。网络层实体交换数据包。数据包是由数据链路层在一个或多个帧内传输的有限字节序列。数据包通常包含有关其来源和目的地的信息，并且在从其来源到其目的地的过程中通常通过几个称为路由器的中间设备。这如图5所示。
- en: '![Figure made with TikZ](../Images/df939036e063e29a614edfaad7147595.png)'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/df939036e063e29a614edfaad7147595.png)'
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 5 The network layer
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图5 网络层
- en: Internet hosts such as laptops, smartphones, PCs, servers, and various Internet
    of Things (IoT) devices connect to the Internet through various types of datalink
    layer technologies. Popular datalink layer technologies include Wi-Fi, Ethernet,
    Bluetooth, and the different types of cellular network technologies such as 4G
    and 5G. Some of these technologies will be discussed in the second part of this
    book. They have very specific characteristics that we ignore in this part of the
    book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网主机，如笔记本电脑、智能手机、PC、服务器以及各种物联网（IoT）设备，通过各种类型的链路层技术连接到互联网。流行的链路层技术包括Wi-Fi、以太网、蓝牙以及不同类型的蜂窝网络技术，如4G和5G。本书的第二部分将讨论其中一些技术。它们具有非常具体的特性，本书的这一部分将忽略。
- en: 'The Internet relies on a few architectural principles. First, all the information
    that hosts exchange must be divided into [IP](../glossary.html#term-IP) [packets](../glossary.html#term-packets).
    IP stands for the [Internet Protocol](../glossary.html#term-Internet-Protocol).
    This is the [protocol](../glossary.html#term-protocol) or the set of rules that
    hosts apply when exchanging information. An IP packet is a variable-length sequence
    of bytes that contains two main parts :'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网依赖于几个架构原则。首先，主机交换的所有信息必须分为[IP](../glossary.html#term-IP) [数据包](../glossary.html#term-packets)。IP代表[互联网协议](../glossary.html#term-Internet-Protocol)。这是[协议](../glossary.html#term-protocol)或主机在交换信息时应用的规则集。一个IP数据包是一个可变长度的字节序列，包含两个主要部分：
- en: a header which contains control information specifying notably the source and
    the destination of the payload
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含控制信息的报头，指定了有效载荷的源和目的
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a payload which contains the data to be exchanged
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含要交换数据的有效载荷
- en: A second principle is that each host is identified by a unique [IP address](../glossary.html#term-IP-address).
    An [IP address](../glossary.html#term-IP-address) is a fixed-length bit string
    that identifies a host. Each Internet host has a unique [IP address](../glossary.html#term-IP-address).
    Each IP packet contains both the IP address of the source or origin of the packet
    and the IP address of the destination or recipient of the packet. The network
    uses the destination address to deliver each packet to its final recipient.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原则是每个主机都有一个唯一的[IP地址](../glossary.html#term-IP-address)。[IP地址](../glossary.html#term-IP-address)是一个固定长度的位串，用于标识主机。每个互联网主机都有一个唯一的[IP地址](../glossary.html#term-IP-address)。每个IP数据包都包含数据包的源或原始地址以及数据包的目的或接收者地址。网络使用目的地址将每个数据包交付给其最终接收者。
- en: Throughout this part, we will consider the Internet as a black box as shown
    in [Fig. 6](#fig-network-blackbox). We will focus on hos hosts interact and will
    reveal how the network really operates in the second part of the book.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将互联网视为一个黑盒，如图6所示。[图6](#fig-network-blackbox)。我们将关注主机之间的交互，并在本书的第二部分揭示网络的实际运作方式。
- en: '![Figure made with TikZ](../Images/c28dbcfe5a4f553d7a8b75481407429b.png)'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c28dbcfe5a4f553d7a8b75481407429b.png)'
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 6 Internet hosts can exchange packets
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图6 互联网主机可以交换数据包
- en: Thanks to these architectural principles, any Internet host can send an IP packet
    at any time to any other Internet host. A host could send a packet to a server
    in America and shortly after another packet to a server in Australia or Africa.
    For a host, sending a packet is a cheap operation. It creates a sequence of bytes
    containing the header and the payload and then passes it to the network interface
    card. The other elements of the network will handle the packet and deliver it
    to its final destination.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这些架构原则，任何互联网主机都可以在任何时候向任何其他互联网主机发送IP数据包。一个主机可以向美国的服务器发送一个数据包，然后不久再向澳大利亚或非洲的服务器发送另一个数据包。对于主机来说，发送数据包是一个低成本的操作。它创建了一个包含报头和有效载荷的字节序列，并将其传递给网络接口卡。网络的其余部分将处理数据包并将其交付到最终目的地。
- en: A primer on IP version 4[#](#a-primer-on-ip-version-4 "Link to this heading")
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP版本4入门[#](#a-primer-on-ip-version-4 "链接到这个标题")
- en: Two different versions of the Internet protocol are used on today’s Internet.
    The first one, named [IP version 4](../glossary.html#term-IP-version-4) uses 32-bit
    long addresses. IPv4 addresses are often represented in dotted-decimal format
    as a sequence of four integers separated by a dot. The first integer is the decimal
    representation of the most significant byte of the 32-bit IPv4 address, … For
    example,
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的互联网上使用了两种不同的互联网协议版本。第一个版本，称为[IP版本4](../glossary.html#term-IP-version-4)，使用32位长地址。IPv4地址通常以点分十进制格式表示，由四个整数序列组成，每个整数之间用一个点分隔。第一个整数是32位IPv4地址最高有效字节的十进制表示，……例如，
- en: '`1.2.3.4` corresponds to `00000001 00000010 00000011 00000100`'
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.2.3.4` 对应于 `00000001 00000010 00000011 00000100`'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`127.0.0.1` corresponds to `01111111 00000000 00000000 00000001`'
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1`对应于`01111111 00000000 00000000 00000001`'
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`255.255.255.255` corresponds to `1111111 1111111 11111111 1111111111`'
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255.255.255.255`对应于`1111111 1111111 11111111 1111111111`'
- en: This version was designed when the Internet was a research network that connected
    computers in universities and research labs. At that time, having a maximum of
    \(2^{32}\) IPv4 addresses was not considered to be a severe limitation. Today,
    almost all the available IPv4 addresses have been assigned to various organizations
    ranging from enterprises or universities to [Internet Service Providers](../glossary.html#term-Internet-Service-Providers).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是在互联网还是一个连接大学和研究实验室计算机的研究网络时设计的。当时，拥有最多\(2^{32}\)个IPv4地址并不被认为是一个严重的限制。今天，几乎所有可用的IPv4地址都已分配给各种组织，从企业或大学到[互联网服务提供商](../glossary.html#term-Internet-Service-Providers)。
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high-order bits of the
    address, and the host identifier is encoded in the low-order bits of the address.
    This is illustrated in figure [Fig. 7](#fig-subnetwork) with a 22-bit subnetwork
    identifier shown in blue and a 12-bit host identifier in red.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址由两部分组成：子网标识符和主机标识符。子网标识符由地址的高位比特组成，而主机标识符编码在地址的低位比特中。这如图[图7](#fig-subnetwork)所示，其中22位的子网标识符以蓝色显示，12位的主机标识符以红色显示。
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
- en: Fig. 7 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图7 IPv4地址内的子网（蓝色）和主机标识符（红色）
- en: Flexibility in the IPv4 addressing architecture was added with the introduction
    of variable-length subnets in [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html).
    IPv4 supports variable-length subnets where the subnet identifier can be any size,
    from 1 to 31 bits. Variable-length subnets allow the network operators to use
    a subnet that better matches the number of hosts that are placed inside the subnet.
    A subnet identifier or IPv4 prefix is usually represented as `A.B.C.D/p` where
    `A.B.C.D` is the network address obtained by concatenating the subnet identifier
    with a host identifier containing only 0 and p is the length of the subnet identifier
    in bits. The table below provides examples of IP subnets.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入可变长度子网后，IPv4寻址架构的灵活性得到了增强，这在[**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)中得到体现。IPv4支持可变长度子网，其中子网标识符可以是1到31位中的任何大小。可变长度子网允许网络操作员使用与子网内放置的主机数量更好地匹配的子网。子网标识符或IPv4前缀通常表示为`A.B.C.D/p`，其中`A.B.C.D`是通过将子网标识符与仅包含0的主机标识符连接而获得的网络地址，p是子网标识符的位数。下表提供了IP子网的示例。
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 子网 | 地址数量 | 最小地址 | 最大地址 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Special IPv4 addresses
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊IPv4地址
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in RFC :5735. These include
    :'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数单播IPv4地址都可以出现在全球互联网上的数据包的源地址和目的地址中。然而，值得注意的是，某些IPv4地址块有特殊用途，如RFC 5735中所述。这包括：
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留用于自识别的`0.0.0.0/8`，其中常用的地址是`0.0.0.0`，有时在主机启动且尚未知道其IPv4地址时使用。
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.0/8，这是为环回地址保留的。每个实现IPv4的主机都必须有一个环回接口（即未连接到数据链路层）。按照惯例，IPv4地址127.0.0.1被分配给此接口。这允许在主机上运行的过程使用TCP/IP来联系同一主机上运行的其他过程。这对于测试目的非常有用。
- en: 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0/8, 172.16.0.0/12, 和 192.168.0.0/16 被保留用于非直接连接到互联网的私有网络。这些地址通常被称为私有地址或[**RFC
    1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)地址。
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 169.254.0.0/16 用于链路本地地址[**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。当某些主机连接到一个未按预期分配地址的网络时，它们会使用此块中的地址。
- en: 192.0.2.0/24, 198.51.100.0/24, and 203.0.113.0/24 are reserved for use in documentation.
    These addresses cannot be used on the public Internet and should not be accepted
    by hosts. This book should ideally use these addresses when providing examples.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 192.0.2.0/24, 198.51.100.0/24, 和 203.0.113.0/24 被保留用于文档用途。这些地址不能在公共互联网上使用，主机不应接受这些地址。本书在提供示例时理想情况下应使用这些地址。
- en: The unit of information for IPv4 is the [packet](../glossary.html#term-packet).
    An IPv4 packet has a 20-byte header which contains the source and destination
    addresses of the packet and some control information. One of the control fields
    of the IPv4 header is a 16-bit field that contains the total length of the packet
    (header included). An IPv4 packet cannot be longer than 65535 bytes, header included.
    In practice, hosts rarely send really long packets and most IPv4 packets are shorter
    than about 1500 bytes. The IPv4 packet header is shown in [Fig. 8](#fig-ipv4-header).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的信息单位是[数据包](../glossary.html#term-packet)。一个IPv4数据包有一个20字节的头部，包含数据包的源地址和目的地址以及一些控制信息。IPv4头部的一个控制字段是一个16位的字段，包含数据包的总长度（包括头部）。IPv4数据包的长度不能超过65535字节，包括头部。在实际应用中，主机很少发送真正长的数据包，大多数IPv4数据包的长度都小于约1500字节。IPv4数据包头部在[图8](#fig-ipv4-header)中显示。
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
- en: Fig. 8 The IP version 4 header[#](#fig-ipv4-header "Link to this image")
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 IP版本4头部[#](#fig-ipv4-header "链接到此图像")
- en: A primer on IP version 6[#](#a-primer-on-ip-version-6 "Link to this heading")
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP版本6入门指南[#](#a-primer-on-ip-version-6 "链接到本标题")
- en: The second deployed version of IP is [IP version 6](../glossary.html#term-IP-version-6).
    This version of IP introduces several changes compared to IP version 4 that will
    be discussed later. The most important one is the length of the IPv6 addresses.
    An IPv6 address is 128 bits long. This implies that in theory, there are \(2^128=340,282,366,920,938,463,463,374,607,431,768,211,456\)
    unique IPv6 addresses. The number of IPv6 addresses is much larger than the number
    of IPv4 addresses, and we do not expect the IPv6 addressing space to become exhausted
    one day.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: IP的第二种部署版本是[IP版本6](../glossary.html#term-IP-version-6)。与IP版本4相比，这一版本的IP引入了几个变化，将在后面讨论。其中最重要的是IPv6地址的长度。IPv6地址是128位长。这意味着在理论上，有
    \(2^128=340,282,366,920,938,463,463,374,607,431,768,211,456\) 个唯一的IPv6地址。IPv6地址的数量远大于IPv4地址的数量，我们预计IPv6地址空间不会在某一天耗尽。
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Textual representation of IPv6 addresses
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址的文本表示
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时需要以文本格式编写IPv6地址，例如在手动配置地址或用于文档目的时。编写IPv6地址的首选格式是 `x:x:x:x:x:x:x:x`，其中 `x`
    是表示地址八个16位部分的十六进制数字。以下是一些IPv6地址的示例：
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`'
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0:0:0:219:e3ff:fed7:1204`'
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16-bit blocks containing only bits set to 0. For example,'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'IPv6 地址通常包含一串设置为 `0` 的位。在这种情况下，已经定义了一种紧凑的表示法。使用这种表示法，:: 用于表示一个或多个只包含设置为 `0`
    的位的 16 位块组。例如，'
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a` 表示为 `2001:db8::8:800:200c:417a`'
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff01:0:0:0:0:0:0:101` 表示为 `ff01::101`'
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` 表示为 `::1`'
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` 表示为 `::`'
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 前缀可以表示为地址/长度，其中长度是前缀的位数。例如，以下三种表示法对应于相同的 IPv6 前缀：
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
- en: ''
  id: totrans-346
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  id: totrans-348
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8::cd30:0:0:0:0` / `60`'
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-350
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  id: totrans-351
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0:cd30::` / `60`'
- en: An IPv6 packet starts with a header of at least 40 bytes. It contains the source
    and destination IPv6 addresses as well as a 16-bit-long length field. This implies
    that IPv6 packets cannot be longer than 65535 bytes. As for IPv4, most observed
    IPv6 packets are shorter than about 1500 bytes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 数据包以至少 40 字节的头部开始。它包含源和目的 IPv6 地址以及一个 16 位长的长度字段。这意味着 IPv6 数据包不能超过 65535
    字节。至于 IPv4，大多数观察到的 IPv6 数据包长度小于约 1500 字节。
- en: The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 9](#fig-ipv6-header).
    The structure of this packet will be explained in more detail in the second part
    of this book.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html) 中定义的标准
    IPv6 报头占用 40 字节，包含 8 个不同的字段，如图 9 所示。本书的第二部分将更详细地解释此数据包的结构。
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
- en: Fig. 9 The IP version 6 header[#](#id16 "Link to this image")
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9 IP 版本 6 报头[#](#id16 "链接到此图像")
- en: The transport layer[#](#the-transport-layer "Link to this heading")
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层[#](#the-transport-layer "链接到本标题")
- en: The network layer enables hosts to reach each others through intermediate routers.
    However, different communication flows can take place between the same hosts.
    These communication flows might have different needs (some require reliable delivery,
    other not) and need to be distinguished. Ensuring an identification of a communication
    flow between two given hosts is the task of the transport layer. Transport layer
    entities exchange segments. A segment is a finite sequence of bytes that are transported
    inside one or more packets. A transport layer entity issues segments (or sometimes
    part of segments) as Data.request to the underlying network layer entity. This
    is illustrated in [Fig. 10](#fig-transport-layer1).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层使主机能够通过中间路由器相互通信。然而，同一主机之间可以发生不同的通信流。这些通信流可能有不同的需求（一些需要可靠交付，其他则不需要），并且需要区分。确保两个给定主机之间通信流的识别是传输层的任务。传输层实体交换段。段是在一个或多个数据包内部传输的有限字节序列。传输层实体将段（或有时是段的一部分）作为
    Data.request 发送到下层的网络层实体。这如图 10 所示。
- en: There are different types of transport layers. The most widely used transport
    layers on the Internet are [TCP](../glossary.html#term-TCP), that provides a reliable
    connection-oriented bytestream transport service, and [UDP](../glossary.html#term-UDP),
    that provides an unreliable connection-less transport service.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同类型的传输层。在互联网上最广泛使用的传输层是 [TCP](../glossary.html#term-TCP)，它提供了一种可靠的面向连接的字节流传输服务，以及
    [UDP](../glossary.html#term-UDP)，它提供了一种不可靠的无连接传输服务。
- en: '![Figure made with TikZ](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 10 The transport layer
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 10 传输层
- en: A network is always designed and built to enable applications running on hosts
    to exchange information. In a previous chapter, we have explained the principles
    of the network layer that enables hosts connected to different types of datalink
    layers to exchange information through routers. These routers act as relays in
    the network layer and ensure the delivery of packets between any pair of hosts
    attached to the network.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 网络总是被设计和构建来允许在主机上运行的应用程序交换信息。在前面的一章中，我们解释了网络层原理，该原理允许连接到不同类型数据链路层的主机通过路由器交换信息。这些路由器在网络层充当中继，确保网络中任何一对连接的主机之间数据包的交付。
- en: The network layer ensures the delivery of packets on a hop-by-hop basis through
    intermediate nodes. As such, it provides a service to the upper layer. In practice,
    this layer is usually the transport layer that improves the service provided by
    the network layer to make it usable by applications. This is illustrated in [Fig.
    11](#fig-transport-layer).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层通过中间节点按跳步确保数据包的交付。因此，它为上层提供了一种服务。在实践中，这一层通常是传输层，它改进了网络层提供的服务，使其适用于应用程序。这如图[图11](#fig-transport-layer)所示。
- en: '![Figure made with TikZ](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 11 The transport layer
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图11 传输层
- en: Most networks use a datagram organization and provide a simple service which
    is called the connectionless service.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络使用数据报组织并提供一种简单的服务，称为无连接服务。
- en: 'As the transport layer is built on top of the network layer, it is important
    to know the key features of the network layer service. In this book, we only consider
    the connectionless network layer service which is the most widespread. Its main
    characteristics are :'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传输层建立在网络层之上，了解网络层服务的关键特征很重要。在这本书中，我们只考虑最广泛使用的无连接网络层服务。其主要特征包括：
- en: the connectionless network layer service can only transfer SDUs of *limited
    size*
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务只能传输*有限大小*的SDU
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connectionless network layer service may discard SDUs
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务可能会丢弃SDU
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connectionless network layer service may corrupt SDUs
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务可能会损坏SDU
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connectionless network layer service may delay, reorder or even duplicate
    SDUs
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务可能会延迟、重新排序或甚至重复SDU
- en: These imperfections of the connectionless network layer service are caused by
    the operations of the network layer. This layer is able to deliver packets to
    their intended destination, but it cannot guarantee their delivery. The main cause
    of packet losses and errors are the buffers used on the network nodes. If the
    buffers of one of these nodes becomes full, all arriving packets must be discarded.
    This situation frequently happens in practice. Transmission errors can also affect
    packet transmissions on links where reliable transmission techniques are not enabled
    or because of errors in the buffers of the network nodes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这些无连接网络层服务的不完善是由网络层的操作引起的。该层能够将数据包发送到预期的目的地，但不能保证它们的交付。数据包丢失和错误的主要原因是网络节点上使用的缓冲区。如果这些节点中的一个缓冲区满了，所有到达的数据包都必须被丢弃。这种情况在实践中经常发生。传输错误也可能影响在未启用可靠传输技术或由于网络节点缓冲区错误的情况下进行的数据包传输。
- en: 'There are three main types of transport services :'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要的传输服务类型：
- en: the connectionless service
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接服务
- en: ''
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connection-oriented (byte-stream or message-mode) service
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向连接（字节流或消息模式）服务
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the request-response service
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应服务
- en: The connectionless transport service[#](#the-connectionless-transport-service
    "Link to this heading")
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接传输服务[#](#the-connectionless-transport-service "链接到本标题")
- en: The connectionless service allows applications to easily exchange messages or
    Service Data Units. On the Internet, this service is provided by the UDP protocol
    that will be explained in the next chapter. The connectionless transport service
    on the Internet is unreliable, but is able to detect transmission errors. This
    implies that an application will not receive data that has been corrupted due
    to transmission errors.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务允许应用程序轻松交换消息或服务数据单元。在互联网上，这种服务由UDP协议提供，将在下一章中解释。互联网上的无连接传输服务是不可靠的，但能够检测传输错误。这意味着应用程序不会接收到由于传输错误而损坏的数据。
- en: The figure below provides a representation of the connectionless service as
    a time-sequence diagram. The user on the left, having address S, issues a Data.request
    primitive containing Service Data Unit (SDU) M that must be delivered by the service
    provider to destination D. The dashed line between the two primitives indicates
    that the Data.indication primitive that is delivered to the user on the right
    corresponds to the Data.request primitive sent by the user on the left.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图提供了无连接服务作为时间序列图的表示。左侧的用户，地址为S，发出一个包含服务数据单元（SDU）M的数据请求原语，该数据单元必须由服务提供商交付到目的地D。两个原语之间的虚线表示发送到右侧用户的Data.indication原语对应于左侧用户发送的Data.request原语。
- en: '![msc {'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: '}](../Images/4ee9488e106e721d3505acd29c04b209.png)<map id="fb2f6d7c49baf50b586f9dcecd634d2500634932"
    name="fb2f6d7c49baf50b586f9dcecd634d2500634932"></map>'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/4ee9488e106e721d3505acd29c04b209.png)<map id="fb2f6d7c49baf50b586f9dcecd634d2500634932"
    name="fb2f6d7c49baf50b586f9dcecd634d2500634932"></map>'
- en: There are several possible implementations of the connectionless service. Before
    studying these realizations, it is useful to discuss the possible characteristics
    of the connectionless service. A reliable connectionless service is a service
    where the service provider guarantees that all SDUs submitted in Data.requests
    by a user will eventually be delivered to their destination. Such a service would
    be very useful for users, but guaranteeing perfect delivery is difficult in practice.
    For this reason, network layers usually support an unreliable connectionless service.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务有几种可能的实现方式。在研究这些实现之前，讨论无连接服务的可能特性是有用的。一个可靠的无连接服务是一个服务，其中服务提供商保证用户通过数据请求提交的所有SDU最终将被交付到目的地。这样的服务对用户非常有用，但在实践中保证完美的交付是困难的。因此，网络层通常支持不可靠的无连接服务。
- en: An unreliable connectionless service may suffer from various types of problems
    compared to a reliable connectionless service. First of all, an unreliable connectionless
    service does not guarantee the delivery of all SDUs. This can be expressed graphically
    by using the time-sequence diagram below.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可靠的无连接服务与一个可靠的无连接服务相比可能会遇到各种类型的问题。首先，一个不可靠的无连接服务不能保证所有SDU的交付。这可以通过下面的时间序列图来图形化表示。
- en: '![msc {'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b-x c [ label = "D(b)", arcskip="2", linecolour=red];
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(b)", arcskip="2", linecolour=red];
- en: c=>d1 [ label = "",linecolour=white ];
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "",linecolour=white ];
- en: '}](../Images/177cb46396d45f08e9d7545e3154e18b.png)<map id="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"
    name="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"></map>'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/177cb46396d45f08e9d7545e3154e18b.png)<map id="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"
    name="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"></map>'
- en: In practice, an unreliable connectionless service will usually deliver a large
    fraction of the SDUs. However, since the delivery of SDUs is not guaranteed, the
    user must be able to recover from the loss of any SDU.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，不可靠的无连接服务通常会交付大部分SDU。然而，由于SDU的交付没有保证，用户必须能够从任何SDU的丢失中恢复。
- en: A second imperfection that may affect an unreliable connectionless service is
    that it may duplicate SDUs. Some packets may be duplicated in a network and be
    delivered twice to their destination. This is illustrated by the time-sequence
    diagram below.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 可能影响不可靠的无连接服务的第二个缺陷是它可能会重复SDU。一些数据包可能在网络中被重复，并两次被发送到目的地。这可以通过下面的时间序列图来说明。
- en: '![msc {'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: z>>c [ label = "", arcskip="1"];
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: '}](../Images/f44769bd9ed127c07d494406222a612b.png)<map id="2f24c3b302431a9d40faf6d0285b9a55a8750107"
    name="2f24c3b302431a9d40faf6d0285b9a55a8750107"></map>'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/f44769bd9ed127c07d494406222a612b.png)<map id="2f24c3b302431a9d40faf6d0285b9a55a8750107"
    name="2f24c3b302431a9d40faf6d0285b9a55a8750107"></map>'
- en: Finally, some unreliable connectionless service providers may deliver to a destination
    a different SDU than the one that was supplied in the Data.request. This is illustrated
    in the figure below.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些不可靠的无连接服务提供商可能会将一个与在Data.request中提供的不同的SDU发送到目的地。这在下图中得到了说明。
- en: '![msc {'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"abc\")" ] ,
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"abc\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"xyz\")" ];
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"xyz\")" ];
- en: '}](../Images/d960a02633797ef9170e30439eb112b8.png)<map id="53723b9136cdd91e2719e677046eea6f2bef054a"
    name="53723b9136cdd91e2719e677046eea6f2bef054a"></map>'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/d960a02633797ef9170e30439eb112b8.png)<map id="53723b9136cdd91e2719e677046eea6f2bef054a"
    name="53723b9136cdd91e2719e677046eea6f2bef054a"></map>'
- en: 'The connectionless transport service allows networked application to exchange
    messages. Several networked applications may be running at the same time on a
    single host. Each of these applications must be able to exchange SDUs with remote
    applications. To enable these exchanges of SDUs, each networked application running
    on a host is identified by the following information :'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接传输服务允许网络应用程序交换消息。单个主机上可能同时运行多个网络应用程序。每个应用程序都必须能够与远程应用程序交换SDU。为了实现这些SDU的交换，运行在主机上的每个网络应用程序都通过以下信息进行标识：
- en: the host on which the application is running
  id: totrans-447
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序的主机
- en: ''
  id: totrans-448
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-449
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the port number on which the application listens for data
  id: totrans-450
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序监听数据传输的端口号
- en: On the Internet, the port number is an integer and the host is identified by
    its IPv4 or IPv6 address. A host that only has an IPv4 address cannot communicate
    with a host having only an IPv6 address. [Fig. 12](#fig-cl-transport) illustrates
    two applications that are using the datagram service provided by UDP on hosts
    that are using IPv4 addresses.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，端口号是一个整数，主机通过其IPv4或IPv6地址进行识别。只有IPv4地址的主机无法与只有IPv6地址的主机通信。[图12](#fig-cl-transport)说明了两个在仅使用IPv4地址的主机上使用UDP提供的数据报服务的应用程序。
- en: '![Figure made with TikZ](../Images/e68e29111fe44956f2f9dce525d7fea5.png)'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e68e29111fe44956f2f9dce525d7fea5.png)'
- en: ''
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 12 The connectionless or datagram service
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图12 无连接或数据报服务
- en: The connection-oriented transport service[#](#the-connection-oriented-transport-service
    "Link to this heading")
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向连接的传输服务[#](#the-connection-oriented-transport-service "链接到本标题")
- en: An invocation of the connection-oriented service is divided into three phases.
    The first phase is the establishment of a connection. A connection is a temporary
    association between two users through a service provider. Several connections
    may exist at the same time between any pair of users. Once established, the connection
    is used to transfer SDUs. Connections usually provide one bidirectional stream
    supporting the exchange of SDUs between the two users that are associated through
    the connection. This stream is used to transfer data during the second phase of
    the connection called the data transfer phase. The third phase is the termination
    of the connection. Once the users have finished exchanging SDUs, they request
    the service provider to terminate the connection. As we will see later, there
    are also some cases where the service provider may need to terminate a connection
    itself.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 连接导向服务的调用分为三个阶段。第一阶段是建立连接。连接是通过服务提供商在两个用户之间建立的临时关联。在任何一对用户之间可能同时存在多个连接。一旦建立，连接用于传输
    SDU。连接通常提供一条双向流，支持通过连接关联的两个用户之间的 SDU 交换。此流用于连接的第二阶段，即数据传输阶段。第三阶段是连接的终止。一旦用户完成
    SDU 的交换，他们请求服务提供商终止连接。正如我们稍后将会看到的，也有一些情况是服务提供商可能需要自己终止连接。
- en: 'The establishment of a connection can be modeled by using four primitives :
    Connect.request, Connect.indication, Connect.response and Connect.confirm. The
    Connect.request primitive is used to request the establishment of a connection.
    The main parameter of this primitive is the address of the destination user. The
    service provider delivers a Connect.indication primitive to inform the destination
    user of the connection attempt. If it accepts to establish a connection, it responds
    with a Connect.response primitive. At this point, the connection is considered
    to be established and the destination user can start sending SDUs over the connection.
    The service provider processes the Connect.response and will deliver a Connect.confirm
    to the user who initiated the connection. The delivery of this primitive terminates
    the connection establishment phase. At this point, the connection is considered
    to be open and both users can send SDUs. A successful connection establishment
    is illustrated below.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接可以通过使用四个原语来建模：Connect.request、Connect.indication、Connect.response 和 Connect.confirm。Connect.request
    原语用于请求建立连接。此原语的主要参数是目标用户的地址。服务提供商向目标用户发送 Connect.indication 原语以通知连接尝试。如果目标用户接受建立连接，则通过
    Connect.response 原语进行响应。此时，连接被认为是建立的，并且目标用户可以开始通过连接发送 SDU。服务提供商处理 Connect.response
    并将 Connect.confirm 传递给发起连接的用户。此原语的传递终止了连接建立阶段。此时，连接被认为是打开的，并且两个用户都可以发送 SDU。以下是一个成功的连接建立的示例。
- en: '![msc {'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="服务提供商", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目标", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: '}](../Images/12de7a0d5f3487e2a782a5860da72cff.png)<map id="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"
    name="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"></map>'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/12de7a0d5f3487e2a782a5860da72cff.png)<map id="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"
    name="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"></map>'
- en: The example above shows a successful connection establishment. However, in practice
    not all connections are successfully established. One reason is that the destination
    user may not agree, for policy or performance reasons, to establish a connection
    with the initiating user at this time. In this case, the destination user responds
    to the Connect.indication primitive by a Disconnect.request primitive that contains
    a parameter to indicate why the connection has been refused. The service provider
    will then deliver a Disconnect.indication primitive to inform the initiating user.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了成功建立连接的过程。然而，在实际操作中，并非所有连接都能成功建立。一个原因可能是目标用户可能因为策略或性能原因，不同意在此时刻与发起用户建立连接。在这种情况下，目标用户会通过包含表示连接被拒绝原因的参数的Disconnect.request原语来响应Connect.indication原语。服务提供商随后将发送Disconnect.indication原语来通知发起用户。
- en: '![msc {'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "DISCONNECT.req" ] ,
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.req" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.ind" ];
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.ind" ];
- en: '}](../Images/d7cf3fe0981d29ac305e476158ad3202.png)<map id="369bcd9afd00f0cea64705370c6107ffd854e9a1"
    name="369bcd9afd00f0cea64705370c6107ffd854e9a1"></map>'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/d7cf3fe0981d29ac305e476158ad3202.png)<map id="369bcd9afd00f0cea64705370c6107ffd854e9a1"
    name="369bcd9afd00f0cea64705370c6107ffd854e9a1"></map>'
- en: A second reason is when the service provider is unable to reach the destination
    user. This might happen because the destination user is not currently attached
    to the network or due to congestion. In these cases, the service provider responds
    to the Connect.request with a Disconnect.indication primitive whose reason parameter
    contains additional information about the failure of the connection.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是当服务提供商无法到达目标用户时。这可能是因为目标用户当前未连接到网络，或者由于拥塞。在这些情况下，服务提供商会对Connect.request响应一个包含有关连接失败额外信息的Disconnect.indication原语。
- en: '![msc {'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b-x c [ label = "", arcskip="1"];
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "", arcskip="1"];
- en: c-x b [ label="",linecolour=white];
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: c-x b [ label="",linecolour=white];
- en: b=>a1 [ label = "DISCONNECT.ind" ];
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.ind" ];
- en: '}](../Images/a6977804391f666738b97b912ff2c561.png)<map id="32c26b073aab11b386a68ab9bd6f63a79402c97a"
    name="32c26b073aab11b386a68ab9bd6f63a79402c97a"></map>'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/a6977804391f666738b97b912ff2c561.png)<map id="32c26b073aab11b386a68ab9bd6f63a79402c97a"
    name="32c26b073aab11b386a68ab9bd6f63a79402c97a"></map>'
- en: Once the connection has been established, the service provider supplies two
    data streams to the communicating users. The first data stream can be used by
    the initiating user to send SDUs. The second data stream allows the responding
    user to send SDUs to the initiating user. The data streams can be organized in
    different ways. A first organization is the message-mode transfer. With the message-mode
    transfer, the service provider guarantees that one and only one Data.indication
    will be delivered to the endpoint of the data stream for each Data.request primitive
    issued by the other endpoint. The message-mode transfer is illustrated in the
    figure below. The main advantage of the message-transfer mode is that the recipient
    receives exactly the SDUs that were sent by the other user. If each SDU contains
    a command, the receiving user can process each command as soon as it receives
    a SDU.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，服务提供商向通信用户供应两个数据流。第一个数据流可以被发起用户用来发送SDUs。第二个数据流允许响应用户向发起用户发送SDUs。数据流可以以不同的方式组织。第一种组织方式是消息模式传输。在消息模式传输中，服务提供商保证对于其他端点发出的每个数据请求原语，只向数据流端点传递一个且仅有一个数据指示。消息模式传输在下图中展示。消息传输模式的主要优点是接收者接收到的SDUs正好是其他用户发送的。如果每个SDU包含一个命令，接收用户可以在接收到SDU后立即处理每个命令。
- en: '![msc {'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ] ,
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"BCD\")" ] ,
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"BCD\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"BCD\")" ];
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"BCD\")" ];
- en: a1=>b [ label = "DATA.req(\"EF\")" ] ,
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"EF\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"EF\")" ];
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"EF\")" ];
- en: '}](../Images/2592ed60d53be2396fda0643ecb35744.png)<map id="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"
    name="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"></map>'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/2592ed60d53be2396fda0643ecb35744.png)<map id="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"
    name="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"></map>'
- en: Unfortunately, the message-mode transfer is not widely used on the Internet.
    On the Internet, the most popular connection-oriented service transfers SDUs in
    stream-mode. With the stream-mode, the service provider supplies a byte stream
    that links the two communicating users. The sending user sends bytes by using
    Data.request primitives that contain sequences of bytes as SDUs. The service provider
    delivers SDUs containing consecutive bytes to the receiving user by using Data.indication
    primitives. The service provider ensures that all the bytes sent at one end of
    the stream are delivered correctly in the same order at the other endpoint. However,
    the service provider does not attempt to preserve the boundaries of the SDUs.
    There is no relation enforced by the service provider between the number of Data.request
    and the number of Data.indication primitives. The stream-mode is illustrated in
    the figure below. In practice, a consequence of the utilization of the stream-mode
    is that if the users want to exchange structured SDUs, they will need to provide
    the mechanisms that allow the receiving user to separate successive SDUs in the
    byte stream that it receives. Application layer protocols often use specific delimiters
    such as the end of line character to delineate SDUs in a bytestream.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，消息模式传输在互联网上并不常用。在互联网上，最流行的面向连接的服务以流模式传输SDU。使用流模式，服务提供商提供字节流，将两个通信用户连接起来。发送用户通过包含字节序列的SDU的数据请求原语发送字节。服务提供商通过数据指示原语将包含连续字节的SDU传递给接收用户。服务提供商确保流一端发送的所有字节以相同的顺序正确地传递到流的另一端。然而，服务提供商并不试图保留SDU的边界。服务提供商之间没有强制执行与数据请求原语数量和数据指示原语数量之间的关联。流模式在下图中展示。在实践中，流模式的使用导致的一个后果是，如果用户想要交换结构化的SDU，他们需要提供允许接收用户在接收到的字节流中分离连续SDU的机制。应用层协议通常使用特定的分隔符，如行结束字符，在字节流中划分SDU。
- en: '![msc {'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ label = "DATA.req(\"AB\")" ],
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"AB\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: c=>d1 [ label = "DATA.ind(\"B\")" ];
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"B\")" ];
- en: a1=>b [ label = "DATA.req(\"CD\")" ] ,
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"CD\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"C\")" ];
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"C\")" ];
- en: a1=>b [ label = "DATA.req(\"EF\")" ] ,
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"EF\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"DEF\")" ];
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"DEF\")" ];
- en: '}](../Images/2db37b2091c6c91af8c65803fadd75dc.png)<map id="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"
    name="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"></map>'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/2db37b2091c6c91af8c65803fadd75dc.png)<map id="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"
    name="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"></map>'
- en: The third phase of a connection is its release. As a connection involves three
    parties (two users and one service provider), any of them can request the termination
    of the connection. Usually, connections are terminated upon request of one user
    once the data transfer is finished. However, sometimes the service provider may
    be forced to terminate a connection. This can be due to lack of resources inside
    the service provider or because one of the users is not reachable anymore through
    the network. In this case, the service provider will issue Disconnect.indication
    primitives to both users. These primitives will contain, as parameter, some information
    about the reason for the termination of the connection. Unfortunately, as illustrated
    in the figure below, when a service provider is forced to terminate a connection
    it cannot guarantee that all SDUs sent by each user have been delivered to the
    other user. This connection release is said to be abrupt as it can cause losses
    of data.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的第三阶段是其释放。由于连接涉及三方（两个用户和一个服务提供商），任何一方都可以请求终止连接。通常，一旦数据传输完成，就会根据一方的请求终止连接。然而，有时服务提供商可能被迫终止连接。这可能是因为服务提供商内部资源不足，或者因为用户之一无法通过网络再次访问。在这种情况下，服务提供商将向两个用户发出
    Disconnect.indication 原语。这些原语将包含有关连接终止原因的一些信息。不幸的是，如图所示，当服务提供商被迫终止连接时，它不能保证每个用户发送的所有
    SDU 都已传递给另一方。这种连接释放被称为突然释放，因为它可能导致数据丢失。
- en: '![msc {'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ] ,
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ] ,
- en: b-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: b-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: c-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: b=>a1 [ linecolour=red, label = "DISCONNECT.ind" , textcolour=red] ,
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ linecolour=red, label = "DISCONNECT.ind" , textcolour=red] ,
- en: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
- en: '}](../Images/e332fc75c845caae3e5d76447bc8fb22.png)<map id="602fae060a80344e82486c9382e055244cc76a0a"
    name="602fae060a80344e82486c9382e055244cc76a0a"></map>'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/e332fc75c845caae3e5d76447bc8fb22.png)<map id="602fae060a80344e82486c9382e055244cc76a0a"
    name="602fae060a80344e82486c9382e055244cc76a0a"></map>'
- en: An abrupt connection release can also be triggered by one of the users. If a
    user needs, for any reason, to terminate a connection quickly, it can issue a
    Disconnect.request primitive and to request an abrupt release. The service provider
    will process the request, stop the two data streams and deliver the Disconnect.indication
    primitive to the remote user as soon as possible. As illustrated in the figure
    below, this abrupt connection release may cause losses of SDUs.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 突然的连接释放也可以由用户之一触发。如果用户出于任何原因需要快速终止连接，它可以发出 Disconnect.request 原语并请求突然释放。服务提供商将处理请求，停止两个数据流，并尽快将
    Disconnect.indication 原语传递给远程用户。如图所示，这种突然的连接释放可能会导致 SDUs 的丢失。
- en: '![msc {'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ] ,
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ] ,
- en: b-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: b-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: c-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: a1=>b [ linecolour=red, label = "DISCONNECT.req(abrupt)" , textcolour=red] ,
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=red, label = "DISCONNECT.req(abrupt)" , textcolour=red] ,
- en: b>>c [ label = "", arcskip="1",linecolour=red];
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1",linecolour=red];
- en: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
- en: '}](../Images/bcaa45e4382eb9e52c93458a974ea97e.png)<map id="94fa96cd54acf717988a49a90397299bf8cfd71d"
    name="94fa96cd54acf717988a49a90397299bf8cfd71d"></map>'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/bcaa45e4382eb9e52c93458a974ea97e.png)<map id="94fa96cd54acf717988a49a90397299bf8cfd71d"
    name="94fa96cd54acf717988a49a90397299bf8cfd71d"></map>'
- en: To ensure a reliable delivery of the SDUs sent by each user over a connection,
    we need to consider the two streams that compose a connection as independent.
    A user should be able to release the stream that it uses to send SDUs once it
    has sent all the SDUs that it planned to send over this connection, but still
    continue to receive SDUs over the opposite stream. This graceful connection release
    is usually performed as shown in the figure below. One user issues a Disconnect.request
    primitive to its provider once it has issued all its Data.request primitives.
    The service provider will wait until all Data.indication primitives have been
    delivered to the receiving user before issuing the Disconnnect.indication primitive.
    This primitive informs the receiving user that it will no longer receive SDUs
    over this connection, but it is still able to issue Data.request primitives on
    the stream in the opposite direction. Once the user has issued all of its Data.request
    primitives, it issues a Disconnnect.request primitive to request the termination
    of the remaining stream. The service provider will process the request and deliver
    the corresponding Disconnect.indication to the other user once it has delivered
    all the pending Data.indication primitives. At this point, all data has been delivered,
    the two streams have been released successfully and the connection is completely
    closed.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个用户通过连接发送的SDU（服务数据单元）的可靠交付，我们需要将构成连接的两个流视为独立的。一旦用户发送了它计划通过此连接发送的所有SDU，它应该能够释放它用来发送SDU的流，但仍然可以通过相反的流接收SDU。这种优雅的连接释放通常如图所示执行。一旦用户发出所有其Data.request原语，它就会向其提供者发出Disconnect.request原语。服务提供者将在发出Disconnect.indication原语之前等待所有Data.indication原语都已被发送到接收用户。此原语通知接收用户它将不再通过此连接接收SDU，但它仍然能够在相反方向的流上发出Data.request原语。一旦用户发出所有其Data.request原语，它就会发出Disconnect.request原语以请求终止剩余的流。服务提供者将在发送所有挂起的Data.indication原语后处理请求并向另一个用户发送相应的Disconnect.indication。此时，所有数据都已发送，两个流已成功释放，连接已完全关闭。
- en: '![msc {'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接已建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接已建立" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ],
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"B\")" ];
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"B\")" ];
- en: a1=>b [ label = "DISCONNECT.req(graceful)",textcolour=red, linecolour=red ],
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.req(graceful)",textcolour=red, linecolour=red ],
- en: b>>c [ label = "", arcskip="1", linecolour=red];
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1", linecolour=red];
- en: c=>d1 [ label = "DISCONNECT.ind(graceful)",linecolour=red, textcolour=red ];
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.ind(graceful)",linecolour=red, textcolour=red ];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [label = "DATA.ind(\"C\")" ];
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [标签 = "DATA.ind(\"C\")" ];
- en: d1=>c [ label = "DISCONNECT.req(graceful)", textcolour=blue, linecolour=blue
    ] ,
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [标签 = "DISCONNECT.req(优雅)", 文字颜色=蓝色, 线颜色=蓝色 ] ,
- en: c>>b [ label = "", arcskip="1", linecolour=blue];
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [标签 = "", 跳过弧线="1"，线颜色=蓝色];
- en: b=>a1 [label = "DISCONNECT.ind(graceful)" ];
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [标签 = "DISCONNECT.ind(优雅)" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ] ,
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [线颜色=白色，文字颜色=蓝色，标签 = "连接已关闭"] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ];
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [线颜色=白色，文字颜色=蓝色，标签 = "连接已关闭"];
- en: '}](../Images/93d7ca8af6d44432fde8748dc0e2f7d9.png)<map id="cfd142d18c7142e539c0384b6fcc308356449d2c"
    name="cfd142d18c7142e539c0384b6fcc308356449d2c"></map>'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/93d7ca8af6d44432fde8748dc0e2f7d9.png)<map id="cfd142d18c7142e539c0384b6fcc308356449d2c"
    name="cfd142d18c7142e539c0384b6fcc308356449d2c"></map>'
- en: Note
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reliability of the connection-oriented service
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 面向连接服务的可靠性
- en: An important point to note about the connection-oriented service is its reliability.
    A connection-oriented service can only guarantee the correct delivery of all SDUs
    provided that the connection has been released gracefully. This implies that while
    the connection is active, there is no guarantee for the actual delivery of the
    SDUs exchanged as the connection may need to be abruptly released at any time.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 关于面向连接服务的一个重要观点是其可靠性。面向连接的服务只能保证在连接优雅释放的情况下，所有 SDU 的正确交付。这意味着在连接活动期间，没有保证实际交付交换的
    SDU，因为连接可能需要随时突然释放。
- en: The second transport service is the connection-oriented service. On the Internet,
    this service is often called the byte-stream service as it creates a reliable
    byte stream between the two applications that are linked by a transport connection.
    Like the datagram service, the networked applications that use the byte-stream
    service are identified by the host on which they run and a port number. These
    hosts can be identified by an address or a name. [Fig. 13](#fig-co-transport)
    illustrates two applications that are using the byte-stream service provided by
    the TCP protocol on IPv6 hosts. The byte-stream service provided by TCP is reliable
    and bidirectional.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个传输服务是面向连接的服务。在互联网上，这种服务通常被称为字节流服务，因为它在通过传输连接连接的两个应用程序之间创建了一个可靠的字节流。像数据报服务一样，使用字节流服务的网络应用程序可以通过它们运行的宿主机和端口号来识别。这些宿主机可以通过地址或名称来识别。[图
    13](#fig-co-transport) 展示了两个正在使用通过 IPv6 宿主机提供的 TCP 协议字节流服务的应用程序。TCP 提供的字节流服务是可靠且双向的。
- en: '![Figure made with TikZ](../Images/22d0b3ec409b5e6fa95368ee887a0af6.png)'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/22d0b3ec409b5e6fa95368ee887a0af6.png)'
- en: ''
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 13 The connection-oriented or byte-stream service
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 13 面向连接或字节流服务
- en: '### The request-response service[#](#the-request-response-service "Link to
    this heading")'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '### 请求-响应服务[#](#the-request-response-service "链接到本标题")'
- en: The request-response service is a compromise between the connectionless service
    and the connection-oriented service. Many applications need to send a small amount
    of data and receive a small amount of information back. This is similar to procedure
    calls in programming languages. A call to a procedure takes a few arguments and
    returns a simple answer. In a network, it is sometimes useful to execute a procedure
    on a different host and receive the result of the computation. Executing a procedure
    on another host is often called Remote Procedure Call. It is possible to use the
    connectionless service for this application. However, since this service is usually
    unreliable, this would force the application to deal with any type of error that
    could occur. Using the connection oriented service is another alternative. This
    service ensures the reliable delivery of the data, but a connection must be created
    before the beginning of the data transfer. This overhead can be important for
    applications that only exchange a small amount of data.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应服务是无连接服务和面向连接服务之间的折中方案。许多应用程序需要发送少量数据并接收少量信息。这类似于编程语言中的过程调用。对过程的调用传递几个参数并返回一个简单的答案。在网络中，有时在另一台主机上执行过程并接收计算结果是有用的。在另一台主机上执行过程通常被称为远程过程调用。可以使用无连接服务来处理这种应用。然而，由于此服务通常不可靠，这会迫使应用程序处理可能发生的任何类型的错误。使用面向连接的服务是另一种选择。此服务确保数据的可靠交付，但在数据传输开始之前必须创建连接。对于仅交换少量数据的应用程序来说，这种开销可能很重要。
- en: The request-response service allows to efficiently exchange small amounts of
    information in a request and associate it with the corresponding response. This
    service can be depicted by using the time-sequence diagram below.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应服务允许在请求中高效地交换少量信息，并将其与相应的响应关联。此服务可以通过下面的时序图来表示。
- en: '![msc {'
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机 A", linecolour=black],
- en: z [label="Service", linecolour=white],
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="Service", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机 B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(request)" ] ,
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(request)" ] ,
- en: b>>c [ arcskip="1"];
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1"];
- en: c=>d [ label = "DATA.ind(request)" ];
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(request)" ];
- en: ''
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "DATA.resp(response)" ] ,
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "DATA.resp(response)" ] ,
- en: c>>b [ arcskip="1"];
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a [ label = "DATA.confirm(response)" ];
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "DATA.confirm(response)" ];
- en: '}](../Images/414d09372f22c44dc624c0b21cae0fdc.png)<map id="62a300927dbe4ad95b0ccdb1df72b080f57955e7"
    name="62a300927dbe4ad95b0ccdb1df72b080f57955e7"></map>'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/414d09372f22c44dc624c0b21cae0fdc.png)<map id="62a300927dbe4ad95b0ccdb1df72b080f57955e7"
    name="62a300927dbe4ad95b0ccdb1df72b080f57955e7"></map>'
- en: Note
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Services and layers
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和层
- en: In the previous sections, we have described services that are provided by the
    transport layer. However, it is important to note that the notion of service is
    more general than in the transport layer. As explained earlier, the network layer
    also provides a service, which in most networks is an unreliable connectionless
    service. There are network layers that provide a connection-oriented service.
    Similarly, the datalink layer also provides services. Some datalink layers will
    provide a connectionless service. This will be the case in Local Area Networks
    for examples. Other datalink layers, e.g. in public networks, provide a connection
    oriented service.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了传输层提供的服务。然而，需要注意的是，服务的概念比传输层更一般。如前所述，网络层也提供了一种服务，在大多数网络中这是一种不可靠的无连接服务。有些网络层提供面向连接的服务。同样，数据链路层也提供服务。有些数据链路层将提供无连接服务。例如，在局域网中就是这样。其他数据链路层，例如在公共网络中，提供面向连接的服务。
- en: The transport layer[#](#id6 "Link to this heading")
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层[#](#id6 "链接到本标题")
- en: 'The transport layer entity interacts with both a user in the application layer
    and the network layer. It improves the network layer service to make it usable
    by applications. From the application’s viewpoint, the main limitations of the
    network layer service come from its unreliable service:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层实体与应用层中的用户和网络层进行交互。它提高了网络层服务，使其可供应用程序使用。从应用程序的角度来看，网络层服务的主要限制来自其不可靠的服务：
- en: the network layer may corrupt data;
  id: totrans-660
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能会损坏数据；
- en: ''
  id: totrans-661
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-662
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer may loose data;
  id: totrans-663
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能会丢失数据；
- en: ''
  id: totrans-664
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-665
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer may not deliver data in-order;
  id: totrans-666
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能不会按顺序交付数据；
- en: ''
  id: totrans-667
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-668
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer has an upper bound on maximum length of the data;
  id: totrans-669
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层对数据最大长度有一个上限；
- en: ''
  id: totrans-670
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-671
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer may duplicate data.
  id: totrans-672
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能会重复数据。
- en: To deal with these issues, the transport layer includes several mechanisms that
    depend on the service that it provides. It interacts with both the applications
    and the underlying network layer.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些问题，传输层包括几个依赖于它所提供服务的机制。它与应用程序和底层网络层进行交互。
- en: '[![../_images/transport-entity.png](../Images/2d19dde4426bf6e94db4bbeaf29ba9e7.png)](../_images/transport-entity.png)'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-entity.png](../Images/2d19dde4426bf6e94db4bbeaf29ba9e7.png)](../_images/transport-entity.png)'
- en: Fig. 14 Interactions between the transport layer, its user, and its network
    layer provider[#](#id21 "Link to this image")
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14 传输层、其用户及其网络层提供者之间的交互[#](#id21 "链接到此图像")
- en: We have already described in the datalink layers mechanisms to deal with data
    losses and transmission errors. These techniques are also used in the transport
    layer.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在数据链路层中描述了处理数据丢失和传输错误的机制。这些技术也用于传输层。
- en: Connectionless transport[#](#connectionless-transport "Link to this heading")
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接传输[#](#connectionless-transport "链接到本标题")
- en: 'The simplest service that can be provided in the transport layer is the connectionless
    transport service. Compared to the connectionless network layer service, this
    transport service includes two additional features :'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层可以提供的最简单的服务是无连接传输服务。与无连接网络层服务相比，此传输服务包括两个额外的特性：
- en: an error detection mechanism that allows detecting corrupted data
  id: totrans-679
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个错误检测机制，允许检测损坏的数据
- en: ''
  id: totrans-680
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-681
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a multiplexing technique that enables several applications running on one host
    to exchange information with another host
  id: totrans-682
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种多路复用技术，它使得运行在一个主机上的多个应用程序能够与其他主机交换信息
- en: To exchange data, the transport protocol encapsulates the SDU produced by its
    user inside a segment. The segment is the unit of transfer of information in the
    transport layer. Transport layer entities always exchange segments. When a transport
    layer entity creates a segment, this segment is encapsulated by the network layer
    into a packet which contains the segment as its payload and a network header.
    The packet is then encapsulated in a frame to be transmitted in the datalink layer.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 为了交换数据，传输协议将其用户产生的SDU封装在一个段中。段是传输层中信息传输的单位。传输层实体总是交换段。当一个传输层实体创建一个段时，这个段被网络层封装成一个包含段的负载和网络头部的数据包。然后，这个数据包被封装在帧中，以便在数据链路层传输。
- en: '![Figure made with TikZ](../Images/5015b8f973eb207ae53e5951b99d4821.png)'
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/5015b8f973eb207ae53e5951b99d4821.png)'
- en: ''
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 15 Segments are the unit of transfer at transport layer
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图15 段是传输层传输的单位
- en: A segment also contains control information, usually stored inside a header
    and the payload that comes from the application. To detect transmission errors,
    transport protocols rely on checksums or CRCs like the datalink layer protocols.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 段还包含控制信息，通常存储在头部和来自应用程序的有效负载中。为了检测传输错误，传输协议依赖于校验和或CRC，就像数据链路层协议一样。
- en: Compared to the connectionless network layer service, the transport layer service
    allows several applications running on a host to exchange SDUs with several other
    applications running on remote hosts. Let us consider two hosts, e.g. a client
    and a server. The network layer service allows the client to send information
    to the server, but if an application running on the client wants to contact a
    particular application running on the server, then an additional addressing mechanism
    is required. The network layer address identifies a host, but it is not sufficient
    to differentiate the applications running on a host. Port numbers provides this
    additional addressing. When a server application is launched on a host, it registers
    a port number. This port number will be used by the clients to contact the server
    process.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接的网络层服务相比，传输层服务允许主机上运行的多达几个应用程序与远程主机上运行的其他几个应用程序交换SDU。让我们考虑两个主机，例如一个客户端和一个服务器。网络层服务允许客户端向服务器发送信息，但如果客户端上运行的应用程序想要联系服务器上运行的一个特定应用程序，则需要额外的寻址机制。网络层地址标识一个主机，但它不足以区分主机上运行的应用程序。端口号提供了这种额外的寻址。当服务器应用程序在主机上启动时，它会注册一个端口号。这个端口号将被客户端用来联系服务器进程。
- en: The figure below shows a typical usage of port numbers. The client process uses
    port number 1234 while the server process uses port number 5678. When the client
    sends a request, it is identified as originating from port number 1234 on the
    client host and destined to port number 5678 on the server host. When the server
    process replies to this request, the server’s transport layer returns the reply
    as originating from port 5678 on the server host and destined to port 1234 on
    the client host.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了端口号的典型用法。客户端进程使用端口号1234，而服务器进程使用端口号5678。当客户端发送请求时，它被识别为来自客户端主机的端口号1234，并指向服务器主机的端口号5678。当服务器进程回复此请求时，服务器的传输层将回复作为来自服务器主机的端口号5678，并指向客户端主机的端口号1234。
- en: '![Figure made with TikZ](../Images/ff3ac3cf69da5b775b07d19742a9ce04.png)'
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/ff3ac3cf69da5b775b07d19742a9ce04.png)'
- en: ''
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 16 Utilization of port numbers
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图16 端口号的利用
- en: The User Datagram Protocol[#](#the-user-datagram-protocol "Link to this heading")
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户数据报协议[#](#the-user-datagram-protocol "链接到本标题")
- en: 'The User Datagram Protocol (UDP) is defined in [**RFC 768**](https://datatracker.ietf.org/doc/html/rfc768.html).
    It provides an unreliable connectionless transport service on top of the unreliable
    network layer connectionless service. The main characteristics of the UDP service
    are :'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据报协议（UDP）在[**RFC 768**](https://datatracker.ietf.org/doc/html/rfc768.html)中定义。它在不可靠的网络层无连接服务之上提供了一种不可靠的无连接传输服务。UDP服务的主要特性包括：
- en: the UDP service cannot deliver SDUs that are larger than 65467 bytes [[1]](#fmtuudp)
  id: totrans-695
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务无法传输大于65467字节的SDU [[1]](#fmtuudp)
- en: ''
  id: totrans-696
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-697
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the UDP service does not guarantee the delivery of SDUs (losses can occur and
    SDUs can arrive out-of-sequence)
  id: totrans-698
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务不保证SDU的交付（可能会发生丢失，SDU可能会乱序到达）
- en: ''
  id: totrans-699
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-700
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the UDP service will not deliver a corrupted SDU to the destination
  id: totrans-701
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务不会将损坏的SDU传递给目的地
- en: Compared to the connectionless network layer service, the main advantage of
    the UDP service is that it allows several applications running on a host to exchange
    SDUs with several other applications running on remote hosts. Let us consider
    two hosts, e.g. a client and a server. The network layer service allows the client
    to send information to the server, but if an application running on the client
    wants to contact a particular application running on the server, then an additional
    addressing mechanism is required other than the IP address that identifies a host,
    in order to differentiate the application running on a host. This additional addressing
    is provided by port numbers. When a server using UDP is enabled on a host, this
    server registers a port number. This port number will be used by the clients to
    contact the server process via UDP.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接网络层服务相比，UDP服务的主要优势在于它允许主机上运行的多项应用程序与其他主机上运行的多项应用程序交换SDU。让我们考虑两个主机，例如一个客户端和一个服务器。网络层服务允许客户端向服务器发送信息，但如果客户端上运行的应用程序想要联系服务器上运行的一个特定应用程序，则需要一个额外的寻址机制，除了标识主机的IP地址外，还需要区分主机上运行的应用程序。这种额外的寻址由端口号提供。当主机上启用了使用UDP的服务器时，该服务器会注册一个端口号。这个端口号将被客户端用于通过UDP联系服务器进程。
- en: Figure [Fig. 17](#fig-udp-port) shows a typical usage of the UDP port numbers.
    The client process uses port number 1234, while the server process uses port number
    5678\. When the client sends a request, it is identified as originating from port
    number 1234 on the client host and destined to port number 5678 on the server
    host. When the server process replies to this request, the server’s UDP implementation
    will send the reply as originating from port 5678 on the server host and destined
    to port 1234 on the client host.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 图[图17](#fig-udp-port)显示了UDP端口号的典型使用情况。客户端进程使用端口号1234，而服务器进程使用端口号5678。当客户端发送请求时，它被识别为来自客户端主机的端口号1234，并指向服务器主机的端口号5678。当服务器进程回复此请求时，服务器的UDP实现将回复作为来自服务器主机的端口号5678发送，并指向客户端主机的端口号1234。
- en: '![Figure made with TikZ](../Images/9c30be704be853d5409c2b54c90b5f6c.png)'
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/9c30be704be853d5409c2b54c90b5f6c.png)'
- en: ''
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 17 Usage of the UDP port numbers
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图17 UDP端口号的使用
- en: UDP uses a single segment format shown in figure [Fig. 18](#fig-udp-header).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: UDP使用图[图18](#fig-udp-header)所示的单一段格式。
- en: '[![../_images/udp.svg](../Images/bf09a2e6a873c135ee14e1478682d518.png)](../_images/udp.svg)'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/udp.svg](../Images/bf09a2e6a873c135ee14e1478682d518.png)(../_images/udp.svg)'
- en: Fig. 18 UDP Header Format[#](#fig-udp-header "Link to this image")
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 图18 UDP头部格式[#](#fig-udp-header "链接到该图像")
- en: 'The UDP header contains four fields :'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: UDP头部包含四个字段：
- en: a 16-bit source port
  id: totrans-711
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的源端口号
- en: ''
  id: totrans-712
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit destination port
  id: totrans-714
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的端口号
- en: ''
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-716
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit length field
  id: totrans-717
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的长度字段
- en: ''
  id: totrans-718
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-719
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit checksum
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位的校验和
- en: 'As the port numbers are encoded as a 16-bit field, there can be up to only
    65535 different server processes that are bound to a different UDP port at the
    same time on a given server. In practice, this limit is never reached. However,
    it is worth noticing that most implementations divide the range of allowed UDP
    port numbers into three different ranges :'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端口号被编码为16位字段，因此在给定服务器上，同时只能有最多65535个不同的服务器进程绑定到不同的UDP端口。在实践中，这个限制从未达到。然而，值得注意的是，大多数实现将允许的UDP端口号范围分为三个不同的范围：
- en: the privileged port numbers (1 < port < 1024 )
  id: totrans-722
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权端口号（1 < 端口 < 1024）
- en: ''
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-724
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the ephemeral port numbers ( officially [[2]](#fephemeral) 49152 <= port <=
    65535 )
  id: totrans-725
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时端口号（官方规定：49152 <= 端口 <= 65535）
- en: ''
  id: totrans-726
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the registered port numbers (officially 1024 <= port < 49152)
  id: totrans-728
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已注册的端口号（官方规定：1024 <= 端口 < 49152）
- en: In most Unix variants, only processes having system administrator privileges
    can be bound to port numbers smaller than 1024. Well-known servers such as [DNS](../glossary.html#term-DNS),
    [NNTP](../glossary.html#term-NNTP),or [RPC](../glossary.html#term-RPC) use privileged
    port numbers. When a client needs to use UDP, it usually does not require a specific
    port number. In this case, the UDP implementation will allocate the first available
    port number in the ephemeral range. The range of registered port numbers should
    be used by servers. In theory, developers of network servers should register their
    port number officially through IANA [[3]](#fportnum), but few developers do this.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Unix 变体中，只有具有系统管理员权限的进程才能绑定小于 1024 的端口号。知名服务器，如 [DNS](../glossary.html#term-DNS)、[NNTP](../glossary.html#term-NNTP)
    或 [RPC](../glossary.html#term-RPC)，使用特权端口号。当客户端需要使用 UDP 时，通常不需要特定的端口号。在这种情况下，UDP
    实现将分配 ephemeral 范围内的第一个可用端口号。服务器应使用已注册端口号的范围。理论上，网络服务器的开发人员应通过 IANA 正式注册他们的端口号
    [[3]](#fportnum)，但很少有开发人员这样做。
- en: UDP can be used over IPv4 or IPv6\. When a host receives an IP packet, it needs
    to determine whether this packet should be processed by UDP or another transport
    protocol. This is done by using the Protocol field in the IP version 4 header.
    The [Internet Assigned Numbers Authority](../glossary.html#term-Internet-Assigned-Numbers-Authority)
    (IANA) maintains a [registry of the assigned Internet Protocol numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
    that assigns one integer to each protocol which can be carried inside an IP packet.
    This registry specifies that `17` is reserved to indicate a UDP segment. Figure
    [Fig. 19](#fig-udp-ipv4) shows a UDP segment inside an IPv4 packet.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 可以在 IPv4 或 IPv6 上使用。当主机接收到一个 IP 数据包时，它需要确定这个数据包应该由 UDP 还是其他传输协议处理。这是通过使用
    IPv4 报头中的协议字段来完成的。互联网编号分配机构（[Internet Assigned Numbers Authority](../glossary.html#term-Internet-Assigned-Numbers-Authority)）(IANA)
    维护一个[分配的互联网协议号注册表](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)，为每个可以包含在
    IP 数据包内的协议分配一个整数。此注册表指定 `17` 是保留用于表示 UDP 段的。图 [图 19](#fig-udp-ipv4 "链接到此图像") 展示了
    IPv4 数据包内的 UDP 段。
- en: '[![../_images/udp-ipv4.svg](../Images/80a06b3b8fd203d30e66b836dca4db54.png)](../_images/udp-ipv4.svg)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/udp-ipv4.svg](../Images/80a06b3b8fd203d30e66b836dca4db54.png)](../_images/udp-ipv4.svg)'
- en: Fig. 19 An IPv4 packet containing an empty UDP segment[#](#fig-udp-ipv4 "Link
    to this image")
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19 包含空 UDP 段的 IPv4 数据包[#](#fig-udp-ipv4 "链接到此图像")
- en: Note
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Computation of the UDP checksum
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 校验和的计算
- en: Many Internet protocols use the Internet checksum defined in [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    to detect transmission errors. This checksum is computed by the sender and verified
    by the received. The algorithm defined in [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    uses modular arithmetic. It is computed over a sequence of bytes which is padded
    if it contains an odd number of bytes. The checksum is the one’s complement of
    the sum of the 16 bits words modulo \(2^16\). The python code below computes the
    Internet checksum.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网协议使用在 [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    中定义的互联网校验和来检测传输错误。此校验和由发送方计算并由接收方验证。在 [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    中定义的算法使用模运算。它在一个字节序列上计算，如果包含奇数个字节，则进行填充。校验和是 16 位字之和的 1 的补码，模 \(2^16\)。下面的 Python
    代码计算互联网校验和。
- en: '[PRE2]'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The byte array used to compute the checksum of an UDP segment contains :'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算 UDP 段校验和的字节数组包含：
- en: a pseudo header [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    containing the source address, the destination address, the packet length encoded
    as a 32-bit number and a 32-bit bit field containing the three most significant
    bytes set to 0 and the low-order byte set to 17
  id: totrans-738
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含源地址、目的地址、以 32 位数字编码的包长度以及一个 32 位字段（最高三位字节设置为 0，最低字节设置为 17）的伪头部 [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
- en: ''
  id: totrans-739
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-740
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the entire UDP segment, including its header
  id: totrans-741
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个 UDP 段，包括其报头
- en: Several types of applications rely on UDP. As a rule of thumb, UDP is used for
    applications where delay must be minimized or losses can be recovered by the application
    itself. A first-class of UDP-based applications are applications where the client
    sends a short request and expects a quick and short answer. The [DNS](../glossary.html#term-DNS)
    is an example of a UDP application that is often used in the wide area. However,
    in local area networks, many distributed systems rely on Remote Procedure Call
    ([RPC](../glossary.html#term-RPC)) that is often used on top of UDP. In Unix environments,
    the Network File System ([NFS](../glossary.html#term-NFS)) is built on top of
    RPC and runs frequently on top of UDP. A second class of UDP-based applications
    are the interactive computer games that need to frequently exchange small messages,
    such as the player’s location or their recent actions. Many of these games use
    UDP to minimize the delay and can recover from losses. A third class of applications
    are multimedia applications such as interactive Voice over IP or interactive Video
    over IP. These interactive applications expect a delay shorter than about 200
    milliseconds between the sender and the receiver and can recover from losses directly
    inside the application.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 几种类型的应用依赖于UDP。一般来说，UDP用于需要最小化延迟或应用本身可以恢复丢失的应用。基于UDP的第一类应用是客户端发送简短请求并期望快速简短回答的应用。例如，[DNS](../glossary.html#term-DNS)是一种常用于广域网的UDP应用。然而，在局域网中，许多分布式系统依赖于通常在UDP之上使用的远程过程调用([RPC](../glossary.html#term-RPC))。在Unix环境中，网络文件系统([NFS](../glossary.html#term-NFS))建立在RPC之上，并经常在UDP之上运行。基于UDP的第二类应用是需要频繁交换小消息的交互式计算机游戏，例如玩家的位置或他们的最近动作。许多这些游戏使用UDP来最小化延迟并从丢失中恢复。第三类应用是多媒体应用，如交互式VoIP或交互式VoIP视频。这些交互式应用期望发送方和接收方之间的延迟短于大约200毫秒，并且可以直接在应用中恢复丢失。
- en: Footnotes
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: The physical layer[#](#the-physical-layer "Link to this heading")
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理层[#](#the-physical-layer "链接到本标题")
- en: These physical media can be used to exchange information once this information
    has been converted into a suitable electrical signal. Entire telecommunication
    courses and textbooks are devoted to the problem of converting analog or digital
    information into an electrical signal so that it can be transmitted over a given
    physical link. In this book, we only consider two very simple schemes that allow
    us to transmit information over an electrical cable. This enables us to highlight
    the key problems when transmitting information over a physical link. We are only
    interested in techniques that allow transmitting digital information through the
    wire. Here, we will focus on the transmission of bits, i.e. either 0 or 1.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 这些物理媒体可以在将信息转换为合适的电信号后用于交换信息。整个电信课程和教科书都致力于将模拟或数字信息转换为电信号以便通过给定的物理链路传输的问题。在这本书中，我们只考虑两种非常简单的方案，使我们能够通过电电缆传输信息。这使得我们能够突出在物理链路上传输信息时的关键问题。我们只对允许通过电线传输数字信息的技术感兴趣。在这里，我们将关注比特的传输，即0或1。
- en: Note
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bit rate
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率
- en: In computer networks, the bit rate of the physical layer is always expressed
    in bits per second. One Mbps is one million bits per second, and one Gbps is one
    billion bits per second. This is in contrast with memory specifications that are
    usually expressed in bytes (8 bits), KiloBytes (1024 bytes), or MegaBytes (1048576
    bytes). Transferring one MByte through a 1 Mbps link lasts 8.39 seconds.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机网络中，物理层的比特率总是以每秒比特数来表示。1 Mbps等于每秒一百万比特，1 Gbps等于每秒十亿比特。这与通常以字节（8比特）、千字节（1024字节）或兆字节（1048576字节）来表示的内存规格形成对比。通过1
    Mbps链路传输1兆字节需要8.39秒。
- en: '| Bit rate | Bits per second |'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 比特率 | 每秒比特数 |'
- en: '| --- | --- |'
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 Kbps | \(10^3\) |'
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Kbps | \(10^3\) |'
- en: '| 1 Mbps | \(10^6\) |'
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Mbps | \(10^6\) |'
- en: '| 1 Gbps | \(10^9\) |'
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Gbps | \(10^9\) |'
- en: '| 1 Tbps | \(10^{12}\) |'
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 Tbps | \(10^{12}\) |'
- en: 'To understand some of the principles behind the physical transmission of information,
    let us consider the simple case of an electrical wire that is used to transmit
    bits. Assume that the two communicating hosts want to transmit one thousand bits
    per second. To transmit these bits, the two hosts can agree on the following rules
    :'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解信息物理传输背后的某些原理，让我们考虑一个简单的案例：一个用于传输比特的电信号线。假设两个通信主机想要以每秒一千比特的速度传输比特。为了传输这些比特，两个主机可以同意以下规则：
- en: 'On the sender side :'
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送方：
- en: ''
  id: totrans-757
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-758
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-759
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-760
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-761
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: set the voltage on the electrical wire at `+5V` during one millisecond to transmit
    a bit set to 1
  id: totrans-762
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个毫秒内将电气线上的电压设置为 `+5V` 以传输设置为 1 的位
- en: ''
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-764
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: set the voltage on the electrical wire at `-5V` during one millisecond to transmit
    a bit set to 0
  id: totrans-765
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个毫秒内将电气线上的电压设置为 `-5V` 以传输设置为 0 的位
- en: ''
  id: totrans-766
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-767
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-768
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-769
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-770
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-771
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the receiver side :'
  id: totrans-772
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收端：
- en: ''
  id: totrans-773
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-774
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-775
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-776
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-777
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: every millisecond, record the voltage applied on the electrical wire. If the
    voltage is set to `+5V`, record the reception of bit 1. Otherwise, record the
    reception of bit 0
  id: totrans-778
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个毫秒，记录电气线上的电压应用。如果电压设置为 `+5V`，则记录接收到的位 1。否则，记录接收到的位 0
- en: This transmission scheme has been used in some early networks. We use it as
    a basis to understand how hosts communicate. From a computer science viewpoint,
    dealing with voltages is unusual. Computer scientists frequently rely on models
    that enable them to reason about the issues that they face without having to consider
    all implementation details. The physical transmission scheme described above can
    be represented by using a time-sequence diagram.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传输方案已被一些早期网络使用。我们将其作为理解主机如何通信的基础。从计算机科学的角度来看，处理电压是不寻常的。计算机科学家经常依赖于能够使他们推理面对的问题而无需考虑所有实现细节的模型。上述物理传输方案可以通过使用时间序列图来表示。
- en: A time-sequence diagram describes the interactions between communicating hosts.
    By convention, the communicating hosts are represented in the left and right parts
    of the diagram, while the electrical link occupies the middle of the diagram.
    In such a time-sequence diagram, time flows from the top to the bottom of the
    diagram. The transmission of one bit of information is represented by three arrows.
    Starting from the left, the first horizontal arrow represents the request to transmit
    one bit of information. This request is represented by a primitive, which can
    be considered as a kind of procedure call. This primitive has one parameter (the
    bit being transmitted) and a name (DATA.request in this example). By convention,
    all primitives that are named something.request correspond to a request to transmit
    some information. The dashed arrow indicates the transmission of the corresponding
    electrical signal on the wire. Electrical and optical signals do not travel instantaneously.
    The diagonal dashed arrow indicates that it takes some time for the electrical
    signal to be transmitted from Host A to Host B. Upon reception of the electrical
    signal, the electronics on Host B’s network interface detect the voltage and convert
    it into a bit. This bit is delivered as a DATA.indication primitive. All primitives
    that are named something.indication correspond to the reception of some information.
    The dashed lines also represent the relationship between two (or more) primitives.
    Such a time-sequence diagram provides information about the ordering of the different
    primitives, but the distance between two primitives does not represent a precise
    amount of time.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图描述了通信主机之间的交互。按照惯例，通信主机表示在图的左右两侧，而电气链路占据图的中间部分。在这样的时间序列图中，时间从图的顶部流向底部。一个信息位的传输由三个箭头表示。从左侧开始，第一个水平箭头表示请求传输一个信息位。这个请求由一个原始操作表示，可以将其视为一种过程调用。这个原始操作有一个参数（传输的位）和一个名称（例如，本例中的DATA.request）。按照惯例，所有命名为something.request的原始操作都对应于传输某些信息。虚线箭头表示在电线上传输相应的电气信号。电气和光信号不会瞬间传播。对角虚线箭头表示电气信号从主机A传输到主机B需要一些时间。在接收到电气信号后，主机B的网络接口上的电子设备检测电压并将其转换为位。这个位作为DATA.indication原始操作传递。所有命名为something.indication的原始操作都对应于接收某些信息。虚线还表示两个（或更多）原始操作之间的关系。这样的时间序列图提供了不同原始操作的顺序信息，但两个原始操作之间的距离并不代表精确的时间量。
- en: '![msc {'
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Host A", linecolour=black],
- en: z [label="Physical link", linecolour=white],
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="Physical link", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Host B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ] ,
- en: b>>c [ label = "0", arcskip="1"];
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "0", arcskip="1"];
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: '}](../Images/de5f31954ab1b61192e389ebb30fe49c.png)<map id="902747b8597b572a7e1ef798537b1a487e0a6778"
    name="902747b8597b572a7e1ef798537b1a487e0a6778"></map>'
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/de5f31954ab1b61192e389ebb30fe49c.png)<map id="902747b8597b572a7e1ef798537b1a487e0a6778"
    name="902747b8597b572a7e1ef798537b1a487e0a6778"></map>'
- en: Time-sequence diagrams are useful when trying to understand the characteristics
    of a given communication scheme. When considering the above transmission scheme,
    it is useful to evaluate whether this scheme allows the two communicating hosts
    to reliably exchange information. A digital transmission is considered reliable
    when a sequence of bits that is transmitted by a host is received correctly at
    the other end of the wire. In practice, achieving perfect reliability when transmitting
    information using the above scheme is difficult. Several problems can occur with
    such a transmission scheme.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图在试图理解给定通信方案的特征时很有用。在考虑上述传输方案时，评估该方案是否允许两个通信主机可靠地交换信息是有用的。当主机通过电线发送的位序列在另一端正确接收时，数字传输被认为是可靠的。在实践中，使用上述方案传输信息时实现完美可靠性是困难的。这种传输方案可能会出现几个问题。
- en: The first problem is that electrical transmission can be affected by electromagnetic
    interference. Interference can have various sources including natural phenomena
    (like thunderstorms, variations of the magnetic field,…) but also other electrical
    signals (such as interference from neighboring cables, interference from neighboring
    antennas,…). Due to these various types of interference, there is unfortunately
    no guarantee that when a host transmits one bit on a wire, the same bit is received
    at the other end. This is illustrated in the figure below where a DATA.request(0)
    on the left host leads to a Data.indication(1) on the right host.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是在电传输中可能会受到电磁干扰的影响。干扰可能来自各种来源，包括自然现象（如雷暴、磁场变化等）以及其他电气信号（如邻近电缆的干扰、邻近天线的干扰等）。由于这些各种类型的干扰，不幸的是，无法保证当主机在电线上发送一个位时，相同的位在另一端被接收。这在下图中得到了说明，其中左侧主机的
    DATA.request(0) 导致右侧主机的 Data.indication(1)。
- en: '![msc {'
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [标签="", 线颜色=白色],
- en: b [label="Host A", linecolour=black],
  id: totrans-796
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [标签="主机A", 线颜色=黑色],
- en: z [label="Physical link", linecolour=white],
  id: totrans-797
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [标签="物理链路", 线颜色=白色],
- en: c [label="Host B", linecolour=black],
  id: totrans-798
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [标签="主机B", 线颜色=黑色],
- en: d [label="", linecolour=white];
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [标签="", 线颜色=白色];
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [标签 = "DATA.req(0)" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [标签 = "", 弧跳过="1"];
- en: c=>d [ label = "DATA.ind(1)" ];
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [标签 = "DATA.ind(1)" ];
- en: '}](../Images/72b158d7806ce66e42f4a20fa43137df.png)<map id="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"
    name="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"></map>'
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/72b158d7806ce66e42f4a20fa43137df.png)<map id="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"
    name="0bd2292cb06ed4b5b928363a390a501d7f9bd6e4"></map>'
- en: With the above transmission scheme, a bit is transmitted by setting the voltage
    on the electrical cable to a specific value during some period of time. We have
    seen that due to electromagnetic interference, the voltage measured by the receiver
    can differ from the voltage set by the transmitter. This is the main cause of
    transmission errors. However, this is not the only type of problem that can occur.
    Besides defining the voltages for bits 0 and 1, the above transmission scheme
    also specifies the duration of each bit. If one million bits are sent every second,
    then each bit lasts 1 microsecond. On each host, the transmission (resp. the reception)
    of each bit is triggered by a local clock having a 1 MHz frequency. These clocks
    are the second source of problems when transmitting bits over a wire. Although
    the two clocks have the same specification, they run on different hosts, possibly
    at a different temperature and with a different source of energy. In practice,
    it is possible that the two clocks do not operate at exactly the same frequency.
    Assume that the clock of the transmitting host operates at exactly 1000000 Hz
    while the receiving clock operates at 999999 Hz. This is a very small difference
    between the two clocks. However, when using the clock to transmit bits, this difference
    is important. With its 1000000 Hz clock, the transmitting host will generate one
    million bits during a period of one second. During the same period, the receiving
    host will sense the wire 999999 times and thus will receive one bit less than
    the bits originally transmitted. This small difference in clock frequencies implies
    that bits can “disappear” during their transmission on an electrical cable. This
    is illustrated in the figure below.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述传输方案中，通过在一段时间内将电线的电压设置为特定值来传输一个比特。我们已经看到，由于电磁干扰，接收器测量的电压可能不同于发送器设置的电压。这是传输错误的主要原因。然而，这并不是可能发生的唯一类型的问题。除了定义比特0和1的电压外，上述传输方案还指定了每个比特的持续时间。如果每秒发送一百万比特，那么每个比特持续1微秒。在每个主机上，每个比特的传输（或接收）由一个1
    MHz频率的本地时钟触发。这些时钟是传输比特时的第二个问题来源。尽管这两个时钟具有相同的规格，但它们在不同的主机上运行，可能处于不同的温度和不同的能源来源。在实践中，两个时钟可能不会以完全相同的频率运行。假设发送主机的时钟以1000000
    Hz的精确频率运行，而接收时钟以999999 Hz运行。这两个时钟之间的差异非常小。然而，当使用时钟来传输比特时，这个差异很重要。具有1000000 Hz时钟的发送主机将在一秒钟内生成一百万比特。在同一时间内，接收主机将检测电线999999次，因此将接收比原始发送的比特少一个比特。这种时钟频率的小差异意味着比特在电线上传输过程中可能会“消失”。这在下图中得到了说明。
- en: '![msc {'
  id: totrans-805
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Host A", linecolour=black],
- en: z [label="Physical link", linecolour=white],
  id: totrans-808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="Physical link", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Host B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: ''
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ];
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ];
- en: ''
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(1)" ] ,
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(1)" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d [ label = "DATA.ind(1)" ];
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(1)" ];
- en: '}](../Images/d5c344293b247f77b1781cce32dd951f.png)<map id="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"
    name="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"></map>'
  id: totrans-821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d5c344293b247f77b1781cce32dd951f.png)<map id="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"
    name="bb7f3c74f2faa89ac35bf3e3b87effddbf6030b6"></map>'
- en: A similar reasoning applies when the clock of the sending host is slower than
    the clock of the receiving host. In this case, the receiver will sense more bits
    than the bits that have been transmitted by the sender. This is illustrated in
    the figure below where the second bit received on the right was not transmitted
    by the left host.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送主机的时钟比接收主机的时钟慢时，类似的推理也适用。在这种情况下，接收器将检测到比发送者发送的比特更多的比特。这在下图中得到了说明，其中右侧接收到的第二个比特并未由左侧主机发送。
- en: '![msc {'
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="Host A", linecolour=black],
- en: z [label="Physical link", linecolour=white],
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="Physical link", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="Host B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(0)" ] ,
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(0)" ] ,
- en: b>>c [ label = "", arcskip=1];
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip=1];
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: ''
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c=>d [ label = "DATA.ind(0)" ];
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(0)" ];
- en: ''
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(1)" ] ,
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(1)" ] ,
- en: b>>c [ label = "", arcskip=1];
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip=1];
- en: c=>d [ label = "DATA.ind(1)" ];
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(1)" ];
- en: '}](../Images/e6f2fc97b4f52f1569c9da37e0a7c885.png)<map id="1344449b0032fa197cd1ad3136ba9de5ea48062d"
    name="1344449b0032fa197cd1ad3136ba9de5ea48062d"></map>'
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/e6f2fc97b4f52f1569c9da37e0a7c885.png)<map id="1344449b0032fa197cd1ad3136ba9de5ea48062d"
    name="1344449b0032fa197cd1ad3136ba9de5ea48062d"></map>'
- en: 'From a Computer Science viewpoint, the physical transmission of information
    through a wire is often considered as a black box that allows transmitting bits.
    This black box is commonly referred to as the physical layer service and is represented
    by using the DATA.request and DATA.indication primitives introduced earlier. This
    physical layer service facilitates the sending and receiving of bits, by abstracting
    the technological details that are involved in the actual transmission of the
    bits as an electromagnetic signal. However, it is important to remember that the
    physical layer service is imperfect and has the following characteristics :'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算机科学的角度来看，通过电线物理传输信息通常被视为一个黑盒，它允许传输比特。这个黑盒通常被称为物理层服务，并且通过之前引入的DATA.request和DATA.indication原语来表示。这个物理层服务通过抽象实际传输比特作为电磁信号所涉及的技术细节，从而简化了比特的发送和接收。然而，重要的是要记住，物理层服务是不完美的，并且具有以下特性：
- en: the Physical layer service may change, e.g. due to electromagnetic interference,
    the value of a bit being transmitted
  id: totrans-841
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层服务可能会改变，例如，由于电磁干扰，传输的比特值可能会发生变化
- en: ''
  id: totrans-842
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-843
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Physical layer service may deliver more bits to the receiver than the bits
    sent by the sender
  id: totrans-844
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层服务可能向接收器交付的比特数多于发送器发送的比特数
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the Physical layer service may deliver fewer bits to the receiver than the bits
    sent by the sender.
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层服务可能向接收器交付的比特数少于发送器发送的比特数。
- en: 'Many other types of encodings have been defined to transmit information over
    an electrical cable. All physical layers are able to send and receive physical
    symbols that represent values 0 and 1. However, for various reasons that are outside
    the scope of this chapter, several physical layers exchange other physical symbols
    as well. For example, the Manchester encoding used in several physical layers
    can send four different symbols. The Manchester encoding is a differential encoding
    scheme in which time is divided into fixed-length periods. Each period is divided
    into two halves and two different voltage levels can be applied. To send a symbol,
    the sender must set one of these two voltage levels during each half period. To
    send a 1 (resp. 0), the sender must set a high (resp. low) voltage during the
    first half of the period and a low (resp. high) voltage during the second half.
    This encoding ensures that there will be a transition at the middle of each period
    and allows the receiver to synchronize its clock to the sender’s clock. Apart
    from the encodings for 0 and 1, the Manchester encoding also supports two additional
    symbols : InvH and InvB where the same voltage level is used for the two half
    periods. By definition, these two symbols cannot appear inside a frame which is
    only composed of 0 and 1. Some technologies use these special symbols as markers
    for the beginning or end of frames. This encoding is illustrated in [Fig. 2](#fig-manchester).'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了许多其他类型的编码来通过电电缆传输信息。所有物理层都能够发送和接收代表值0和1的物理符号。然而，由于本章范围之外的各种原因，一些物理层也交换其他物理符号。例如，在多个物理层中使用的曼彻斯特编码可以发送四个不同的符号。曼彻斯特编码是一种差分编码方案，其中时间被分为固定长度的周期。每个周期被分为两个半周期，并且可以应用两种不同的电压水平。为了发送一个符号，发送者必须在每个半周期中设置这两种电压水平之一。为了发送1（或0），发送者必须在周期的第一个半周期中设置高电压（或低电压），在第二个半周期中设置低电压（或高电压）。这种编码确保在每个周期中间会有一个转换，并允许接收器将其时钟与发送者的时钟同步。除了0和1的编码之外，曼彻斯特编码还支持两个额外的符号：InvH和InvB，其中两个半周期使用相同的电压水平。根据定义，这两个符号不能出现在仅由0和1组成的帧中。一些技术使用这些特殊符号作为帧的开始或结束的标记。这种编码在[图2](#fig-manchester)中展示。
- en: '[![../_images/manchester.png](../Images/227f8d0faa5ea71ea44d3e6f473898e6.png)](../_images/manchester.png)'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/manchester.png](../Images/227f8d0faa5ea71ea44d3e6f473898e6.png)'
- en: Fig. 2 Manchester encoding[#](#fig-manchester "Link to this image")
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 图2 曼彻斯特编码[#](#fig-manchester "链接到这张图片")
- en: When the physical layer transmits a bit of information using light or an electromagnetic
    signal, there is no guarantee that the bit sent by the transmitter will be received
    as it was sent by the receiver. Several types of errors can impact this transmission.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理层使用光或电磁信号传输一个比特信息时，无法保证发送者发送的比特会被接收者以相同的方式接收。多种类型的错误可能会影响这种传输。
- en: Information Theory defines two mechanisms that can be used to transmit information
    over a channel affected by random errors. These two mechanisms add redundancy
    to the transmitted information, to allow the receiver to detect or sometimes even
    correct transmission errors. A detailed discussion of these mechanisms is outside
    the scope of this chapter, but it is useful to consider a simple mechanism to
    understand its operation and its limitations.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 信息论定义了两种机制，可以用于在受随机错误影响的信道上传输信息。这两种机制向传输信息添加冗余，以便接收者能够检测或有时甚至纠正传输错误。这些机制的详细讨论超出了本章的范围，但考虑一个简单的机制来理解其操作和限制是有用的。
- en: 'Information theory defines coding schemes. There are different types of coding
    schemes, but let us focus on coding schemes that operate on binary strings. A
    coding scheme is a function that maps information encoded as a string of m bits
    into a string of n bits. The simplest coding scheme is the (even) parity coding.
    This coding scheme takes an m bits source string and produces an m+1 bits coded
    string where the first m bits of the coded string are the bits of the source string
    and the last bit of the coded string is chosen such that the coded string will
    always contain an even number of bits set to 1. For example :'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 信息论定义了编码方案。存在不同类型的编码方案，但让我们专注于操作在二进制字符串上的编码方案。编码方案是一个函数，它将编码为m比特字符串的信息映射到n比特字符串。最简单的编码方案是（偶数）奇偶校验编码。这种编码方案将m比特源字符串转换为m+1比特的编码字符串，其中编码字符串的前m比特是源字符串的比特，编码字符串的最后一位是选择，使得编码字符串总是包含偶数个设置为1的比特。例如：
- en: 1001 is encoded as 10010
  id: totrans-854
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1001编码为10010
- en: ''
  id: totrans-855
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-856
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1101 is encoded as 11011
  id: totrans-857
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1101编码为11011
- en: This parity scheme has been used in some RAMs as well as to encode characters
    sent over a serial line. It is easy to show that this coding scheme allows the
    receiver to detect a single transmission error, but it cannot correct it. However,
    if two or more bits are in error, the receiver may not always be able to detect
    the error.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这种奇偶校验方案已在一些RAM中使用，也用于编码通过串行线发送的字符。很容易证明这种编码方案允许接收者检测单个传输错误，但不能纠正它。然而，如果有两个或更多比特错误，接收者可能无法总是检测到错误。
- en: 'Some coding schemes allow the receiver to correct some transmission errors.
    For example, consider the coding scheme that encodes each source bit as follows
    :'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编码方案允许接收者纠正某些传输错误。例如，考虑以下编码方案的编码方式：
- en: 1 is encoded as 111
  id: totrans-860
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1编码为111
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 is encoded as 000
  id: totrans-863
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0编码为000
- en: For example, consider a sender that sends 111. If there is one bit in error,
    the receiver could receive 011 or 101 or 110. In these three cases, the receiver
    will decode the received bit pattern as a 1 since it contains a majority of bits
    set to 1. If there are two bits in error, the receiver will not be able anymore
    to recover from the transmission error.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个发送111的发送者。如果有一个比特错误，接收者可能会收到011、101或110。在这三种情况下，接收者会将接收到的比特模式解码为1，因为其中包含多数设置为1的比特。如果有两个比特错误，接收者将无法从传输错误中恢复。
- en: This simple coding scheme forces the sender to transmit three bits for each
    source bit. However, it allows the receiver to correct single bit errors. More
    advanced coding systems that allow recovering from errors are used in several
    types of physical layers.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的编码方案迫使发送者对每个源比特传输三个比特。然而，它允许接收者纠正单个比特错误。更高级的编码系统，允许从错误中恢复，被用于多种类型的物理层。
- en: 'To understand error detection codes, let us consider two devices that exchange
    bit strings containing N bits. To allow the receiver to detect a transmission
    error, the sender converts each string of N bits into a string of N+r bits. Usually,
    the r redundant bits are added at the beginning or the end of the transmitted
    bit string, but some techniques interleave redundant bits with the original bits.
    An error detection code can be defined as a function that computes the r redundant
    bits corresponding to each string of N bits. The simplest error detection code
    is the parity bit. There are two types of parity schemes : even and odd parity.
    With the even (resp. odd) parity scheme, the redundant bit is chosen so that an
    even (resp. odd) number of bits are set to 1 in the transmitted bit string of
    N+r bits. The receiver can easily recompute the parity of each received bit string
    and discard the strings with an invalid parity. The parity scheme is often used
    when 7-bit characters are exchanged. In this case, the eighth bit is often a parity
    bit. The table below shows the parity bits that are computed for bit strings containing
    three bits.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解错误检测码，让我们考虑两个交换包含 N 位比特串的设备。为了使接收者能够检测传输错误，发送者将每个 N 位比特串转换为 N+r 位比特串。通常，r
    个冗余位被添加到传输比特串的开始或末尾，但某些技术将冗余位与原始位交织。错误检测码可以定义为计算与每个 N 位比特串对应的 r 个冗余位的函数。最简单的错误检测码是奇偶校验位。有两种类型的奇偶校验方案：偶校验和奇校验。在偶校验（分别奇校验）方案中，冗余位被选择，使得在
    N+r 位传输比特串中设置 1 的比特数为偶数（分别奇数）。接收者可以轻松地重新计算每个接收比特串的奇偶校验，并丢弃奇偶校验无效的字符串。奇偶校验方案通常用于交换
    7 位字符。在这种情况下，第八位通常是奇偶校验位。下表显示了为包含三个比特的比特串计算的奇偶校验位。
- en: '| 3 bits string | Odd parity | Even parity |'
  id: totrans-867
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 3 位字符串 | 奇校验 | 偶校验 |'
- en: '| --- | --- | --- |'
  id: totrans-868
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 000 | 1 | 0 |'
  id: totrans-869
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 000 | 1 | 0 |'
- en: '| 001 | 0 | 1 |'
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 001 | 0 | 1 |'
- en: '| 010 | 0 | 1 |'
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 010 | 0 | 1 |'
- en: '| 100 | 0 | 1 |'
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 100 | 0 | 1 |'
- en: '| 111 | 0 | 1 |'
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 111 | 0 | 1 |'
- en: '| 110 | 1 | 0 |'
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 110 | 1 | 0 |'
- en: '| 101 | 1 | 0 |'
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 101 | 1 | 0 |'
- en: '| 011 | 1 | 0 |'
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 011 | 1 | 0 |'
- en: The parity bit allows a receiver to detect transmission errors that have affected
    a single bit among the transmitted N+r bits. If there are two or more bits in
    error, the receiver may not necessarily be able to detect the transmission error.
    More powerful error detection schemes have been defined. The Cyclical Redundancy
    Checks (CRC) are widely used in datalink layer protocols. An N-bits CRC can detect
    all transmission errors affecting a burst of less than N bits in the transmitted
    frame and all transmission errors that affect an odd number of bits. Additional
    details about CRCs may be found in [[Williams1993]](../bibliography.html#williams1993).
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 奇偶校验位允许接收者检测影响传输的 N+r 比特中单个比特的传输错误。如果有两个或更多比特出错，接收者可能无法必然检测到传输错误。已经定义了更强大的错误检测方案。循环冗余校验（CRC）在数据链路层协议中得到广泛应用。N
    位 CRC 可以检测影响传输帧中小于 N 位突发传输的所有传输错误，以及影响奇数个比特的所有传输错误。有关 CRC 的更多详细信息，请参阅 [[Williams1993]](../bibliography.html#williams1993)。
- en: It is also possible to design a code that allows the receiver to correct transmission
    errors. The simplest error correction code is the triple modular redundancy (TMR).
    To transmit a bit set to 1 (resp. 0), the sender transmits 111 (resp. 000). When
    there are no transmission errors, the receiver can decode 111 as 1. If transmission
    errors have affected a single bit, the receiver performs majority voting as shown
    in the table below. This scheme allows the receiver to correct all transmission
    errors that affect a single bit.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以设计一种代码，允许接收者纠正传输错误。最简单的纠错码是三模冗余（TMR）。要传输设置为 1（分别 0）的比特，发送者传输 111（分别 000）。在没有传输错误的情况下，接收者可以将
    111 解码为 1。如果传输错误影响了一个比特，接收者将执行下表所示的多数投票。此方案允许接收者纠正影响单个比特的所有传输错误。
- en: '| Received bits | Decoded bit |'
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 接收比特 | 解码比特 |'
- en: '| --- | --- |'
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 | 0 |'
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 000 | 0 |'
- en: '| 001 | 0 |'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 001 | 0 |'
- en: '| 010 | 0 |'
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 010 | 0 |'
- en: '| 100 | 0 |'
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 100 | 0 |'
- en: '| 111 | 1 |'
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 111 | 1 |'
- en: '| 110 | 1 |'
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 110 | 1 |'
- en: '| 101 | 1 |'
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 101 | 1 |'
- en: '| 011 | 1 |'
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 011 | 1 |'
- en: Other more powerful error correction codes have been proposed and are used in
    some applications. The [Hamming Code](https://en.wikipedia.org/wiki/Hamming_code)
    is a clever combination of parity bits that provides error detection and correction
    capabilities.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了其他更强大的纠错码，并在某些应用中使用。汉明码（[Hamming Code](https://en.wikipedia.org/wiki/Hamming_code)）是奇偶校验位的巧妙组合，提供了错误检测和纠正功能。
- en: All the functions related to the physical transmission or information through
    a wire (or a wireless link) are usually known as the physical layer. The physical
    layer allows two or more entities that are directly attached to the same transmission
    medium to exchange bits. Being able to exchange bits is important as virtually
    any information can be encoded as a sequence of bits. Electrical engineers are
    used to processing streams of bits, but computer scientists usually prefer to
    deal with higher-level concepts.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与通过电线（或无线链路）进行物理传输或信息相关的功能通常被称为物理层。物理层允许直接连接到同一传输介质的两个或多个实体交换比特。能够交换比特很重要，因为几乎任何信息都可以编码成比特序列。电气工程师习惯于处理比特流，但计算机科学家通常更喜欢处理更高级的概念。
- en: A similar issue arises with file storage. Storage devices such as hard-disks
    also store streams of bits. There are hardware devices that process the bit stream
    produced by a hard-disk, but computer scientists have designed filesystems to
    allow applications to easily access such storage devices. These filesystems are
    typically divided into several layers as well. Hard-disks store sectors of 512
    bytes or more. Unix filesystems group sectors in larger blocks that can contain
    data or inodes representing the structure of the filesystem. Finally, applications
    manipulate files and directories that are translated into blocks, sectors, and
    eventually bits by the operating system.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件存储方面也存在类似的问题。硬盘等存储设备也存储比特流。有硬件设备可以处理硬盘产生的比特流，但计算机科学家已经设计了文件系统，以便应用程序可以轻松访问这些存储设备。这些文件系统通常也分为几个层次。硬盘存储512字节或更多的扇区。Unix文件系统将扇区分组到更大的块中，这些块可以包含数据或表示文件系统结构的inode。最后，应用程序操作文件和目录，这些文件和目录由操作系统转换为块、扇区和最终比特。
- en: Computer networks use a similar approach. Each layer provides a service that
    is built above the underlying layer and is closer to the needs of the applications.
    [Fig. 3](#fig-physical-layer) represents the lower layer of the protocol stack.
    We will explore the different layers of this stack in this book.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络使用类似的方法。每一层都提供一种服务，该服务建立在底层之上，更接近应用的需求。[图3](#fig-physical-layer) 表示协议栈的底层。我们将在这本书中探讨这个栈的不同层。
- en: '![Figure made with TikZ](../Images/cdafb80a85063c028d33d656b5dea86a.png)'
  id: totrans-893
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/cdafb80a85063c028d33d656b5dea86a.png)'
- en: 'Fig. 3 The Physical layer  ## The datalink layer[#](#the-datalink-layer "Link
    to this heading")'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '图3 物理层  ## 数据链路层[#](#the-datalink-layer "链接到这个标题")'
- en: Computer scientists are usually not interested in exchanging bits between two
    hosts. They prefer to write software that deals with larger blocks of data in
    order to transmit messages or complete files. Thanks to the physical layer service,
    it is possible to send a continuous stream of bits between two hosts. This stream
    of bits can include logical blocks of data, but we need to be able to extract
    each block of data from the bit stream despite the imperfections of the physical
    layer. In many networks, the basic unit of information exchanged between two directly
    connected hosts is often called a frame. A frame can be defined as a sequence
    of bits that has a particular syntax or structure. We will see examples of such
    frames later in this chapter.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家通常对在两个主机之间交换比特不感兴趣。他们更倾向于编写处理更大数据块软件，以便传输消息或完成文件。得益于物理层服务，两个主机之间可以发送连续的比特流。这个比特流可以包括数据逻辑块，但我们需要能够从比特流中提取每个数据块，尽管物理层存在不完美之处。在许多网络中，两个直接连接的主机之间交换信息的基本单位通常被称为帧。帧可以被定义为具有特定语法或结构的比特序列。我们将在本章后面看到此类帧的示例。
- en: To enable the transmission/reception of frames, the first problem to be solved
    is how to encode a frame as a sequence of bits, so that the receiver can easily
    recover the received frame despite the limitations of the physical layer.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现帧的传输/接收，首先要解决的问题是如何将一个帧编码成一系列比特，以便接收方能够在物理层的限制下轻松恢复接收到的帧。
- en: If the physical layer were perfect, the problem would be very simple. We would
    simply need to define how to encode each frame as a sequence of consecutive bits.
    The receiver would then easily be able to extract the frames from the received
    bits. Unfortunately, the imperfections of the physical layer make this framing
    problem slightly more complex. Several solutions have been proposed and are used
    in practice in different network technologies.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物理层是完美的，问题将会非常简单。我们只需定义如何将每个帧编码为一系列连续的比特。接收器随后可以轻松地从接收到的比特流中提取帧。不幸的是，物理层的缺陷使得这个问题稍微复杂一些。已经提出了几种解决方案，并在不同的网络技术中得到了实际应用。
- en: Framing[#](#framing "Link to this heading")
  id: totrans-898
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧同步[#](#framing "链接到这个标题")
- en: 'The framing problem can be defined as : “How does a sender encode frames so
    that the receiver can efficiently extract them from the stream of bits that it
    receives from the physical layer”.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 帧同步问题可以这样定义：“发送者如何编码帧，以便接收者能够有效地从它从物理层接收到的比特流中提取它们”。
- en: A first solution to this problem is to require the physical layer to remain
    idle for some time after the transmission of each frame. These idle periods can
    be detected by the receiver and serve as a marker to delineate frame boundaries.
    Unfortunately, this solution is not acceptable for two reasons. First, some physical
    layers cannot remain idle and always need to transmit bits. Second, inserting
    an idle period between frames decreases the maximum bit rate that can be achieved.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一个方案是要求物理层在每个帧传输后保持一段时间空闲。接收器可以检测到这些空闲时间段，并作为标记来界定帧边界。不幸的是，这个方案有两个不可接受的原因。首先，某些物理层不能保持空闲，并且总是需要传输比特。其次，在帧之间插入空闲时间段会降低可以达到的最大比特率。
- en: Note
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bit rate and bandwidth
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率和带宽
- en: Bit rate and bandwidth are often used to characterize the transmission capacity
    of the physical service. The original definition of [bandwidth](https://www.merriam-webster.com/dictionary/bandwidth),
    as listed in the [Webster dictionary](https://www.merriam-webster.com/dictionary)
    is a range of radio frequencies which is occupied by a modulated carrier wave,
    which is assigned to a service, or over which a device can operate. This definition
    corresponds to the characteristics of a given transmission medium or receiver.
    For example, the human ear is able to decode sounds in roughly the 0-20 KHz frequency
    range. By extension, bandwidth is also used to represent the capacity of a communication
    system in bits per second. For example, a Gigabit Ethernet link is theoretically
    capable of transporting one billion bits per second.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率和带宽经常被用来表征物理服务的传输能力。带宽的原始定义，如[韦伯斯特词典](https://www.merriam-webster.com/dictionary)中列出，是指被调制载波波占用的无线电频率范围，该载波波被分配给服务，或设备可以在此范围内操作。这个定义对应于给定传输介质或接收器的特性。例如，人耳能够解码大约0-20
    KHz频率范围内的声音。通过扩展，带宽也被用来表示通信系统的容量，以每秒比特数表示。例如，千兆以太网链路理论上能够每秒传输十亿比特。
- en: 'Given that multi-symbol encodings cannot be used by all physical layers, a
    generic solution which can be used with any physical layer that is able to transmit
    and receive only bits 0 and 1 is required. This generic solution is called stuffing
    and two variants exist : bit stuffing and character stuffing. To enable a receiver
    to easily delineate the frame boundaries, these two techniques reserve special
    bit strings as frame boundary markers and encode the frames so that these special
    bit strings do not appear inside the frames.'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多符号编码不能被所有物理层使用，需要一个通用的解决方案，该方案可以与任何只能传输和接收0和1比特的物理层一起使用。这个通用解决方案被称为填充，存在两种变体：比特填充和字符填充。为了使接收器能够轻松地界定帧边界，这两种技术保留特殊的比特字符串作为帧边界标记，并编码帧，以确保这些特殊的比特字符串不会出现在帧内部。
- en: Bit stuffing reserves the 01111110 bit string as the frame boundary marker and
    ensures that there will never be six consecutive 1 symbols transmitted by the
    physical layer inside a frame. With bit stuffing, a frame is sent as follows.
    First, the sender transmits the marker, i.e. 01111110. Then, it sends all the
    bits of the frame and inserts an additional bit set to 0 after each sequence of
    five consecutive 1 bits. This ensures that the sent frame never contains a sequence
    of six consecutive bits set to 1. As a consequence, the marker pattern cannot
    appear inside the frame sent. The marker is also sent to mark the end of the frame.
    The receiver performs the opposite to decode a received frame. It first detects
    the beginning of the frame thanks to the 01111110 marker. Then, it processes the
    received bits and counts the number of consecutive bits set to 1. If a 0 follows
    five consecutive bits set to 1, this bit is removed since it was inserted by the
    sender. If a 1 follows five consecutive bits set to 1, it indicates a marker if
    it is followed by a bit set to 0. The table below illustrates the application
    of bit stuffing to some frames.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充保留了01111110位字符串作为帧边界标记，并确保在帧内部物理层永远不会传输六个连续的1符号。使用位填充，帧的发送如下。首先，发送者发送标记，即01111110。然后，它发送帧的所有位，并在每个连续五个1位的序列后插入一个额外的设置为0的位。这确保发送的帧永远不会包含连续六个设置为1的位。因此，标记模式不能出现在发送的帧内部。标记也被发送以标记帧的结束。接收者执行相反的操作来解码接收到的帧。它首先通过01111110标记检测帧的开始。然后，它处理接收到的位并计算连续设置为1的位的数量。如果0跟在五个连续的1位之后，则该位被移除，因为它是由发送者插入的。如果1跟在五个连续的1位之后，并且后面跟着一个设置为0的位，则它表示一个标记。下表说明了位填充在几个帧中的应用。
- en: '| Original frame | Transmitted frame |'
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 原始帧 | 传输帧 |'
- en: '| --- | --- |'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0001001001001001001000011 | 01111110000100100100100100100001101111110 |'
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0001001001001001001000011 | 01111110000100100100100100100001101111110 |'
- en: '| 0110111111111111111110010 | 01111110011011111011111011111011001001111110
    |'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0110111111111111111110010 | 01111110011011111011111011111011001001111110
    |'
- en: '| 0111110 | 011111100111110001111110 |'
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0111110 | 011111100111110001111110 |'
- en: '| 01111110 | 0111111001111101001111110 |'
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 01111110 | 0111111001111101001111110 |'
- en: For example, consider the transmission of 0110111111111111111110010. The sender
    will first send the 01111110 marker followed by 011011111. After these five consecutive
    bits set to 1, it inserts a bit set to 0 followed by 11111. A new 0 is inserted,
    followed by 11111. A new 0 is inserted followed by the end of the frame 110010
    and the 01111110 marker.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑传输0110111111111111111110010。发送者首先发送01111110标记，然后是011011111。在这些五个连续的1位之后，它插入一个设置为0的位，然后是11111。插入一个新的0，然后是11111。插入一个新的0，然后是帧的结束110010和01111110标记。
- en: Bit stuffing increases the number of bits required to transmit each frame. The
    worst case for bit stuffing is of course a long sequence of bits set to 1 inside
    the frame. If transmission errors occur, stuffed bits or markers can be in error.
    In these cases, the frame affected by the error and possibly the next frame will
    not be correctly decoded by the receiver, but it will be able to resynchronize
    itself at the next valid marker.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充增加了传输每个帧所需的位数。当然，位填充的最坏情况是帧内有一长串设置为1的位。如果发生传输错误，填充位或标记可能会出错。在这些情况下，受错误影响的帧以及可能的后一个帧将不会被接收者正确解码，但它将在下一个有效的标记处重新同步自己。
- en: 'Bit stuffing can be easily implemented in hardware. However, implementing it
    in software is difficult given the complexity of performing bit manipulations
    in software. Software implementations prefer to process characters than bits;
    software-based datalink layers usually use character stuffing. This technique
    operates on frames that contain an integer number of characters. In computer networks,
    characters are usually encoded by relying on the [ASCII](../glossary.html#term-ASCII)
    table. This table defines the encoding of various alphanumeric characters as a
    sequence of bits. [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html)
    provides the ASCII table that is used by many Internet protocols. For example,
    the table defines the following binary representations :'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充可以在硬件中轻松实现。然而，考虑到在软件中执行位操作复杂性，在软件中实现它则较为困难。软件实现更倾向于处理字符而不是位；基于软件的数据链路层通常使用字符填充。这种技术作用于包含整数个字符的帧。在计算机网络中，字符通常通过依赖[ASCII](../glossary.html#term-ASCII)表进行编码。该表定义了各种字母数字字符的编码为位序列。[**RFC
    20**](https://datatracker.ietf.org/doc/html/rfc20.html)提供了许多互联网协议使用的ASCII表。例如，该表定义了以下二进制表示：
- en: 'A : 1000011 b'
  id: totrans-915
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'A : 1000011 b'
- en: ''
  id: totrans-916
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-917
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0 : 0110000 b'
  id: totrans-918
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0 : 0110000 b'
- en: ''
  id: totrans-919
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-920
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'z : 1111010 b'
  id: totrans-921
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'z : 1111010 b'
- en: ''
  id: totrans-922
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '@ : 1000000 b'
  id: totrans-924
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@ : 1000000 b'
- en: ''
  id: totrans-925
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'space : 0100000 b'
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '空格 : 0100000 b'
- en: In addition, the [ASCII](../glossary.html#term-ASCII) table also defines several
    non-printable or control characters. These characters were designed to allow an
    application to control a printer or a terminal. These control characters include
    CR and LF, that are used to terminate a line, and the BEL character which causes
    the terminal to emit a sound.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[ASCII](../glossary.html#term-ASCII)表还定义了几个不可打印或控制字符。这些字符被设计用来允许应用程序控制打印机或终端。这些控制字符包括CR和LF，用于结束一行，以及引起终端发出声音的BEL字符。
- en: 'NUL: 0000000 b'
  id: totrans-929
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NUL: 0000000 b'
- en: ''
  id: totrans-930
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'BEL: 0000111 b'
  id: totrans-932
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BEL: 0000111 b'
- en: ''
  id: totrans-933
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-934
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CR : 0001101 b'
  id: totrans-935
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CR : 0001101 b'
- en: ''
  id: totrans-936
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-937
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LF : 0001010 b'
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LF : 0001010 b'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DLE: 0010000 b'
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DLE: 0010000 b'
- en: ''
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-943
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'STX: 0000010 b'
  id: totrans-944
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'STX: 0000010 b'
- en: ''
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ETX: 0000011 b'
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ETX: 0000011 b'
- en: Some characters are used as markers to delineate the frame boundaries. Many
    character stuffing techniques use the DLE, STX, and ETX characters of the ASCII
    character set. DLE STX (resp. DLE ETX) is used to mark the beginning (end) of
    a frame. When transmitting a frame, the sender adds a DLE character after each
    transmitted DLE character. This ensures that none of the markers can appear inside
    the transmitted frame. The receiver detects the frame boundaries and removes the
    second DLE when it receives two consecutive DLE characters. For example, to transmit
    frame 1 2 3 DLE STX 4, a sender will first send DLE STX as a marker, followed
    by 1 2 3 DLE. Then, the sender transmits an additional DLE character followed
    by STX 4 and the DLE ETX marker.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符用作标记以界定帧边界。许多字符填充技术使用ASCII字符集中的DLE、STX和ETX字符。DLE STX（分别对应DLE ETX）用于标记帧的开始（结束）。在传输帧时，发送方在每个传输的DLE字符后添加一个DLE字符。这确保了标记中没有任何一个可以出现在传输的帧内。接收方检测帧边界，并在接收到两个连续的DLE字符时移除第二个DLE。例如，要传输帧1
    2 3 DLE STX 4，发送方首先发送DLE STX作为标记，然后是1 2 3 DLE。然后，发送方传输一个额外的DLE字符，后跟STX 4和DLE ETX标记。
- en: '| Original frame | Transmitted frame |'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 原始帧 | 传输帧 |'
- en: '| --- | --- |'
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1** **2** **3** **4** | DLE STX **1** **2** **3** **4** DLE ETX |'
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **1** **2** **3** **4** | DLE STX **1** **2** **3** **4** DLE ETX |'
- en: '| **1** **2** **3** **DLE** **STX** **4** | DLE STX **1** **2** **3** **DLE**
    DLE **STX** **4** DLE ETX |'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **1** **2** **3** **DLE** **STX** **4** | DLE STX **1** **2** **3** **DLE**
    DLE **STX** **4** DLE ETX |'
- en: '| **DLE STX DLE ETX** | DLE STX **DLE** DLE **STX** **DLE** DLE **ETX** DLE
    ETX |'
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **DLE STX DLE ETX** | DLE STX **DLE** DLE **STX** **DLE** DLE **ETX** DLE
    ETX |'
- en: Character stuffing, like bit stuffing, increases the length of the transmitted
    frames. For character stuffing, the worst frame is a frame containing many DLE
    characters. When transmission errors occur, the receiver may incorrectly decode
    one or two frames (e.g. if the errors occur in the markers). However, it will
    be able to resynchronize itself with the next correctly received markers.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 字符填充，就像位填充一样，会增加传输帧的长度。对于字符填充，最糟糕的帧是包含许多DLE字符的帧。当传输错误发生时，接收方可能会错误地解码一个或两个帧（例如，如果错误发生在标记中）。然而，它将能够与下一个正确接收的标记重新同步。
- en: Bit stuffing and character stuffing allow recovering frames from a stream of
    bits or bytes. This framing mechanism provides a richer service than the physical
    layer. Through the framing service, one can send and receive complete frames.
    This framing service can also be represented by using the DATA.request and DATA.indication
    primitives. This is illustrated in the figure below, assuming hypothetical frames
    containing four useful bits and one bit of framing for graphical reasons.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充和字符填充允许从位或字节流中恢复帧。这种帧机制比物理层提供了更丰富的服务。通过帧服务，可以发送和接收完整的帧。这种帧服务也可以通过使用DATA.request和DATA.indication原语来表示。如图所示，假设包含四个有效位和一个用于图形原因的帧。
- en: '![msc {'
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: bf [label="Framing-A", linecolour=black],
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf [label="Framing-A", linecolour=black],
- en: bp [label="Phys-A", linecolour=black],
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp [label="Phys-A", linecolour=black],
- en: cp [label="Phys-B", linecolour=black],
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp [label="Phys-B", linecolour=black],
- en: cf [label="Framing-B", linecolour=black],
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf [label="Framing-B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>bf [ label = "DATA.req(1...1)", textcolour=red ];
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>bf [ label = "DATA.req(1...1)", textcolour=red ];
- en: bf=>bp [label="DATA.req(0)"],
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(0)"],
- en: bp>>cp [label="0", arcskip=1];
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="0", arcskip=1];
- en: cp=>cf [label="DATA.ind(0)"];
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(0)"];
- en: bf=>bp [label="DATA.req(1)"],
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(1)"],
- en: bp>>cp [label="1", arcskip=1];
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="1", arcskip=1];
- en: cp=>cf [label="DATA.ind(1)"];
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(1)"];
- en: '...;'
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...;'
- en: bf=>bp [label="DATA.req(1)"],
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(1)"],
- en: bp>>cp [label="1", arcskip=1];
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="1", arcskip=1];
- en: cp=>cf [label="DATA.ind(1)"];
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(1)"];
- en: bf=>bp [label="DATA.req(0)"],
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(0)"],
- en: bp>>cp [label="0", arcskip=1];
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="0", arcskip=1];
- en: cp=>cf [label="DATA.ind(0)"];
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(0)"];
- en: cf=>d [ label = "DATA.ind(1...1)", textcolour=red ];
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf=>d [ label = "DATA.ind(1...1)", textcolour=red ];
- en: '}](../Images/d93486326d5734107393c5cb08e5b59f.png)<map id="978f9dd07afce7e83d1ec64540abe819ff60d9d8"
    name="978f9dd07afce7e83d1ec64540abe819ff60d9d8"></map>'
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d93486326d5734107393c5cb08e5b59f.png)<map id="978f9dd07afce7e83d1ec64540abe819ff60d9d8"
    name="978f9dd07afce7e83d1ec64540abe819ff60d9d8"></map>'
- en: We can now build upon the framing mechanism to allow the hosts to exchange frames
    containing an integer number of bits or bytes. Once the framing problem has been
    solved, we can use these frames to carry Internet packets.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以基于帧机制来允许主机交换包含整数个位数或字节的帧。一旦解决了帧问题，我们就可以使用这些帧来携带互联网数据包。
- en: Coping with transmission errors[#](#coping-with-transmission-errors "Link to
    this heading")
  id: totrans-981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应对传输错误[#](#coping-with-transmission-errors "链接到这个标题")
- en: 'As explained earlier, the physical layer can be subject to various types that
    affect the bits sent by a transmitter. Data transmission on a physical link can
    be affected by the following errors :'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，物理层可能受到各种类型的影响，这些类型会影响发送器发送的位。物理链路上的数据传输可能受到以下错误的影响：
- en: random isolated errors where the value of a single bit has been modified due
    to a transmission error
  id: totrans-983
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于传输错误，单个位值被修改的随机孤立错误
- en: ''
  id: totrans-984
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-985
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: random burst errors where the values of n consecutive bits have been changed
    due to transmission errors
  id: totrans-986
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于传输错误，n个连续位值发生变化的随机突发错误
- en: ''
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-988
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: random bit creations and random bit removals where bits have been added or removed
    due to transmission errors
  id: totrans-989
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于传输错误，随机生成位和随机删除位，位因为传输错误而被添加或删除
- en: Besides framing, datalink layers also include mechanisms to detect and sometimes
    even recover from transmission errors. To allow a receiver to notice transmission
    errors, a sender must add some redundant information as an error detection code
    to the frame sent. This error detection code is computed by the sender on the
    frame that it transmits. When the receiver receives a frame with an error detection
    code, it recomputes it and verifies whether the received error detection code
    matches the computed error detection code. If they match, the frame is considered
    to be valid.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帧之外，数据链路层还包括检测和有时甚至从传输错误中恢复的机制。为了使接收器注意到传输错误，发送器必须在发送的帧中添加一些冗余信息作为错误检测码。这个错误检测码是由发送器在它发送的帧上计算的。当接收器收到带有错误检测码的帧时，它会重新计算它并验证接收到的错误检测码是否与计算出的错误检测码匹配。如果它们匹配，则认为该帧是有效的。
- en: '[PRE3]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Framing on the Internet
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的帧
- en: The bit stuffing and character stuffing described above are generic solutions
    applied by various protocols. When Internet hosts used dial-up modems or serial
    transmission to exchange data, they used protocols such as SLIP defined in [**RFC
    1035**](https://datatracker.ietf.org/doc/html/rfc1035.html) or PPP defined in
    [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html).
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的比特填充和字符填充是各种协议应用的通用解决方案。当互联网主机使用拨号调制解调器或串行传输交换数据时，它们使用了在[**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html)中定义的SLIP协议或在[**RFC
    1661**](https://datatracker.ietf.org/doc/html/rfc1661.html)中定义的PPP协议。
- en: The Serial Line IP (SLIP) protocol uses character stuffing with two special
    characters (`END`, 192 in decimal and `ESC`, 219 in decimal).
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 串行线IP（SLIP）协议使用两个特殊字符（`END`，十进制192和`ESC`，十进制219）进行字符填充。
- en: The Point-to-Point Protocol (PPP) supports different techniques of framing.
    [**RFC 1662**](https://datatracker.ietf.org/doc/html/rfc1662.html) describes how
    character stuffing and bit stuffing can be used by PPP.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点协议（PPP）支持不同的帧定界技术。[**RFC 1662**](https://datatracker.ietf.org/doc/html/rfc1662.html)描述了PPP如何使用字符填充和比特填充。
- en: '[Fig. 126](../networks/network.html#fig-datalink-layer) illustrates the second
    layer of the protocol stack that uses the services provided by the Physical layer
    to exchange frames. We will use the word frame throughout this book to refer to
    the unit of information exchanged between two datalink layer entities.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[图126](../networks/network.html#fig-datalink-layer)说明了使用物理层提供的服务的协议栈的第二层，用于交换帧。在这本书中，我们将使用“帧”一词来指代两个数据链路层实体之间交换的信息单元。'
- en: '![Figure made with TikZ](../Images/45dcd309f199df5246b8a933469eb608.png)'
  id: totrans-999
  prefs: []
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/45dcd309f199df5246b8a933469eb608.png)'
- en: Fig. 4 The Datalink layer in the protocol stack
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 图4 协议栈中的数据链路层
- en: Framing[#](#framing "Link to this heading")
  id: totrans-1001
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧定界[#](#framing "链接到这个标题")
- en: 'The framing problem can be defined as : “How does a sender encode frames so
    that the receiver can efficiently extract them from the stream of bits that it
    receives from the physical layer”.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 帧定界问题可以定义为：“发送者如何编码帧，以便接收者可以从它从物理层接收到的比特流中有效地提取它们”。
- en: A first solution to this problem is to require the physical layer to remain
    idle for some time after the transmission of each frame. These idle periods can
    be detected by the receiver and serve as a marker to delineate frame boundaries.
    Unfortunately, this solution is not acceptable for two reasons. First, some physical
    layers cannot remain idle and always need to transmit bits. Second, inserting
    an idle period between frames decreases the maximum bit rate that can be achieved.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一个方案是要求物理层在每个帧传输后保持一段时间空闲。这些空闲期可以被接收者检测到，并作为标记来界定帧边界。不幸的是，这个方案不可接受，有两个原因。首先，某些物理层不能保持空闲，总是需要传输比特。其次，在帧之间插入空闲期会降低可以达到的最大比特率。
- en: Note
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bit rate and bandwidth
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率和带宽
- en: Bit rate and bandwidth are often used to characterize the transmission capacity
    of the physical service. The original definition of [bandwidth](https://www.merriam-webster.com/dictionary/bandwidth),
    as listed in the [Webster dictionary](https://www.merriam-webster.com/dictionary)
    is a range of radio frequencies which is occupied by a modulated carrier wave,
    which is assigned to a service, or over which a device can operate. This definition
    corresponds to the characteristics of a given transmission medium or receiver.
    For example, the human ear is able to decode sounds in roughly the 0-20 KHz frequency
    range. By extension, bandwidth is also used to represent the capacity of a communication
    system in bits per second. For example, a Gigabit Ethernet link is theoretically
    capable of transporting one billion bits per second.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 比特率和带宽常用于表征物理服务的传输能力。带宽的原始定义，如[Webster词典](https://www.merriam-webster.com/dictionary)中列出，是指被调制载波波占用的无线电频率范围，该频率范围分配给服务，或设备可以在此范围内操作。这个定义对应于给定传输介质或接收器的特性。例如，人耳能够解码大约0-20
    KHz频率范围内的声音。通过扩展，带宽也用来表示通信系统的容量，以每秒比特数表示。例如，千兆以太网链路理论上能够每秒传输十亿比特。
- en: 'Given that multi-symbol encodings cannot be used by all physical layers, a
    generic solution which can be used with any physical layer that is able to transmit
    and receive only bits 0 and 1 is required. This generic solution is called stuffing
    and two variants exist : bit stuffing and character stuffing. To enable a receiver
    to easily delineate the frame boundaries, these two techniques reserve special
    bit strings as frame boundary markers and encode the frames so that these special
    bit strings do not appear inside the frames.'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多符号编码不能被所有物理层使用，需要一个通用的解决方案，该解决方案可以与任何能够仅传输和接收位0和1的物理层一起使用。这个通用解决方案被称为填充，并且存在两种变体：位填充和字符填充。为了使接收者能够轻松地划分帧边界，这两种技术保留特殊的位字符串作为帧边界标记，并编码帧，以便这些特殊的位字符串不会出现在帧内部。
- en: Bit stuffing reserves the 01111110 bit string as the frame boundary marker and
    ensures that there will never be six consecutive 1 symbols transmitted by the
    physical layer inside a frame. With bit stuffing, a frame is sent as follows.
    First, the sender transmits the marker, i.e. 01111110. Then, it sends all the
    bits of the frame and inserts an additional bit set to 0 after each sequence of
    five consecutive 1 bits. This ensures that the sent frame never contains a sequence
    of six consecutive bits set to 1. As a consequence, the marker pattern cannot
    appear inside the frame sent. The marker is also sent to mark the end of the frame.
    The receiver performs the opposite to decode a received frame. It first detects
    the beginning of the frame thanks to the 01111110 marker. Then, it processes the
    received bits and counts the number of consecutive bits set to 1. If a 0 follows
    five consecutive bits set to 1, this bit is removed since it was inserted by the
    sender. If a 1 follows five consecutive bits set to 1, it indicates a marker if
    it is followed by a bit set to 0. The table below illustrates the application
    of bit stuffing to some frames.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充保留了01111110位字符串作为帧边界标记，并确保在帧内部物理层永远不会传输六个连续的1符号。使用位填充，帧的发送如下。首先，发送者发送标记，即01111110。然后，它发送帧的所有位，并在每个连续五个1位的序列之后插入一个额外的设置为0的位。这确保发送的帧永远不会包含连续六个设置为1的位序列。因此，标记模式不能出现在发送的帧内部。标记也被发送以标记帧的结束。接收者执行相反的操作来解码接收到的帧。它首先通过01111110标记检测到帧的开始。然后，它处理接收到的位并计算连续设置为1的位的数量。如果0跟在五个连续设置为1的位之后，则该位被移除，因为它是由发送者插入的。如果1跟在五个连续设置为1的位之后，则它表示一个标记，如果它后面跟着一个设置为0的位。下表说明了位填充在几个帧中的应用。
- en: '| Original frame | Transmitted frame |'
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 原始帧 | 传输帧 |'
- en: '| --- | --- |'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0001001001001001001000011 | 01111110000100100100100100100001101111110 |'
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0001001001001001001000011 | 01111110000100100100100100100001101111110 |'
- en: '| 0110111111111111111110010 | 01111110011011111011111011111011001001111110
    |'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0110111111111111111110010 | 01111110011011111011111011111011001001111110
    |'
- en: '| 0111110 | 011111100111110001111110 |'
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 0111110 | 011111100111110001111110 |'
- en: '| 01111110 | 0111111001111101001111110 |'
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 01111110 | 0111111001111101001111110 |'
- en: For example, consider the transmission of 0110111111111111111110010. The sender
    will first send the 01111110 marker followed by 011011111. After these five consecutive
    bits set to 1, it inserts a bit set to 0 followed by 11111. A new 0 is inserted,
    followed by 11111. A new 0 is inserted followed by the end of the frame 110010
    and the 01111110 marker.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑传输0110111111111111111110010。发送者首先发送01111110标记，然后是011011111。在这些五个连续设置为1的位之后，它插入一个设置为0的位，然后是11111。插入一个新的0，然后是11111。插入一个新的0，然后是帧的结束110010和01111110标记。
- en: Bit stuffing increases the number of bits required to transmit each frame. The
    worst case for bit stuffing is of course a long sequence of bits set to 1 inside
    the frame. If transmission errors occur, stuffed bits or markers can be in error.
    In these cases, the frame affected by the error and possibly the next frame will
    not be correctly decoded by the receiver, but it will be able to resynchronize
    itself at the next valid marker.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充增加了传输每个帧所需的位数。当然，位填充的最坏情况是帧内部一个长的连续1位序列。如果发生传输错误，填充位或标记可能会出错。在这些情况下，受错误影响的帧以及可能的下一个帧将不会被接收者正确解码，但它将在下一个有效的标记处重新同步自己。
- en: 'Bit stuffing can be easily implemented in hardware. However, implementing it
    in software is difficult given the complexity of performing bit manipulations
    in software. Software implementations prefer to process characters than bits;
    software-based datalink layers usually use character stuffing. This technique
    operates on frames that contain an integer number of characters. In computer networks,
    characters are usually encoded by relying on the [ASCII](../glossary.html#term-ASCII)
    table. This table defines the encoding of various alphanumeric characters as a
    sequence of bits. [**RFC 20**](https://datatracker.ietf.org/doc/html/rfc20.html)
    provides the ASCII table that is used by many Internet protocols. For example,
    the table defines the following binary representations :'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 位填充可以在硬件中轻松实现。然而，考虑到在软件中执行位操作复杂性，在软件中实现它是有困难的。软件实现更倾向于处理字符而不是位；基于软件的数据链路层通常使用字符填充。这种技术作用于包含整数个字符的帧。在计算机网络中，字符通常通过依赖于[ASCII](../glossary.html#term-ASCII)表来进行编码。该表定义了各种字母数字字符的编码为位序列。[**RFC
    20**](https://datatracker.ietf.org/doc/html/rfc20.html)提供了许多互联网协议使用的ASCII表。例如，该表定义了以下二进制表示：
- en: 'A : 1000011 b'
  id: totrans-1018
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'A : 1000011 b'
- en: ''
  id: totrans-1019
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0 : 0110000 b'
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0 : 0110000 b'
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'z : 1111010 b'
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'z : 1111010 b'
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '@ : 1000000 b'
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@ : 1000000 b'
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'space : 0100000 b'
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'space : 0100000 b'
- en: In addition, the [ASCII](../glossary.html#term-ASCII) table also defines several
    non-printable or control characters. These characters were designed to allow an
    application to control a printer or a terminal. These control characters include
    CR and LF, that are used to terminate a line, and the BEL character which causes
    the terminal to emit a sound.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[ASCII](../glossary.html#term-ASCII)表还定义了几个不可打印或控制字符。这些字符被设计成允许应用程序控制打印机或终端。这些控制字符包括CR和LF，用于结束一行，以及引起终端发出声音的BEL字符。
- en: 'NUL: 0000000 b'
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NUL: 0000000 b'
- en: ''
  id: totrans-1033
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1034
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'BEL: 0000111 b'
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BEL: 0000111 b'
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1037
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CR : 0001101 b'
  id: totrans-1038
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CR : 0001101 b'
- en: ''
  id: totrans-1039
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1040
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LF : 0001010 b'
  id: totrans-1041
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LF : 0001010 b'
- en: ''
  id: totrans-1042
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1043
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DLE: 0010000 b'
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DLE: 0010000 b'
- en: ''
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'STX: 0000010 b'
  id: totrans-1047
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'STX: 0000010 b'
- en: ''
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ETX: 0000011 b'
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ETX: 0000011 b'
- en: Some characters are used as markers to delineate the frame boundaries. Many
    character stuffing techniques use the DLE, STX, and ETX characters of the ASCII
    character set. DLE STX (resp. DLE ETX) is used to mark the beginning (end) of
    a frame. When transmitting a frame, the sender adds a DLE character after each
    transmitted DLE character. This ensures that none of the markers can appear inside
    the transmitted frame. The receiver detects the frame boundaries and removes the
    second DLE when it receives two consecutive DLE characters. For example, to transmit
    frame 1 2 3 DLE STX 4, a sender will first send DLE STX as a marker, followed
    by 1 2 3 DLE. Then, the sender transmits an additional DLE character followed
    by STX 4 and the DLE ETX marker.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符用作标记以界定帧边界。许多字符填充技术使用ASCII字符集中的DLE、STX和ETX字符。DLE STX（分别DLE ETX）用于标记帧的开始（结束）。在传输帧时，发送器在每个传输的DLE字符后添加一个DLE字符。这确保了没有标记可以出现在传输帧内。接收器检测帧边界并在接收到两个连续的DLE字符时移除第二个DLE。例如，要传输帧1
    2 3 DLE STX 4，发送器首先发送DLE STX作为标记，然后是1 2 3 DLE。然后，发送器传输一个额外的DLE字符，后跟STX 4和DLE ETX标记。
- en: '| Original frame | Transmitted frame |'
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 原始帧 | 传输帧 |'
- en: '| --- | --- |'
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **1** **2** **3** **4** | DLE STX **1** **2** **3** **4** DLE ETX |'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **1** **2** **3** **4** | DLE STX **1** **2** **3** **4** DLE ETX |'
- en: '| **1** **2** **3** **DLE** **STX** **4** | DLE STX **1** **2** **3** **DLE**
    DLE **STX** **4** DLE ETX |'
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **1** **2** **3** **DLE** **STX** **4** | DLE STX **1** **2** **3** **DLE**
    DLE **STX** **4** DLE ETX |'
- en: '| **DLE STX DLE ETX** | DLE STX **DLE** DLE **STX** **DLE** DLE **ETX** DLE
    ETX |'
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **DLE STX DLE ETX** | DLE STX **DLE** DLE **STX** **DLE** DLE **ETX** DLE
    ETX |'
- en: Character stuffing, like bit stuffing, increases the length of the transmitted
    frames. For character stuffing, the worst frame is a frame containing many DLE
    characters. When transmission errors occur, the receiver may incorrectly decode
    one or two frames (e.g. if the errors occur in the markers). However, it will
    be able to resynchronize itself with the next correctly received markers.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 字符填充，类似于位填充，会增加传输帧的长度。对于字符填充，最糟糕的帧是包含许多DLE字符的帧。当传输错误发生时，接收器可能会错误地解码一个或两个帧（例如，如果错误发生在标记处）。然而，它将能够通过下一个正确接收到的标记来重新同步自己。
- en: Bit stuffing and character stuffing allow recovering frames from a stream of
    bits or bytes. This framing mechanism provides a richer service than the physical
    layer. Through the framing service, one can send and receive complete frames.
    This framing service can also be represented by using the DATA.request and DATA.indication
    primitives. This is illustrated in the figure below, assuming hypothetical frames
    containing four useful bits and one bit of framing for graphical reasons.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 比特填充和字符填充允许从比特或字节流中恢复帧。这种帧机制比物理层提供了更丰富的服务。通过帧服务，可以发送和接收完整的帧。这种帧服务也可以通过使用DATA.request和DATA.indication原语来表示。如图所示，假设假设的帧包含四个有用的比特和一个用于图形原因的帧比特。
- en: '![msc {'
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: bf [label="Framing-A", linecolour=black],
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf [label="Framing-A", linecolour=black],
- en: bp [label="Phys-A", linecolour=black],
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp [label="Phys-A", linecolour=black],
- en: cp [label="Phys-B", linecolour=black],
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp [label="Phys-B", linecolour=black],
- en: cf [label="Framing-B", linecolour=black],
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf [label="Framing-B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1065
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>bf [ label = "DATA.req(1...1)", textcolour=red ];
  id: totrans-1067
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>bf [ label = "DATA.req(1...1)", textcolour=red ];
- en: bf=>bp [label="DATA.req(0)"],
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(0)"],
- en: bp>>cp [label="0", arcskip=1];
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="0", arcskip=1];
- en: cp=>cf [label="DATA.ind(0)"];
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(0)"];
- en: bf=>bp [label="DATA.req(1)"],
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(1)"],
- en: bp>>cp [label="1", arcskip=1];
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="1", arcskip=1];
- en: cp=>cf [label="DATA.ind(1)"];
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(1)"];
- en: '...;'
  id: totrans-1074
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...;'
- en: bf=>bp [label="DATA.req(1)"],
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(1)"],
- en: bp>>cp [label="1", arcskip=1];
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="1", arcskip=1];
- en: cp=>cf [label="DATA.ind(1)"];
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(1)"];
- en: bf=>bp [label="DATA.req(0)"],
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bf=>bp [label="DATA.req(0)"],
- en: bp>>cp [label="0", arcskip=1];
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bp>>cp [label="0", arcskip=1];
- en: cp=>cf [label="DATA.ind(0)"];
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cp=>cf [label="DATA.ind(0)"];
- en: cf=>d [ label = "DATA.ind(1...1)", textcolour=red ];
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cf=>d [ label = "DATA.ind(1...1)", textcolour=red ];
- en: '}](../Images/d93486326d5734107393c5cb08e5b59f.png)<map id="978f9dd07afce7e83d1ec64540abe819ff60d9d8"
    name="978f9dd07afce7e83d1ec64540abe819ff60d9d8"></map>'
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/d93486326d5734107393c5cb08e5b59f.png)<map id="978f9dd07afce7e83d1ec64540abe819ff60d9d8"
    name="978f9dd07afce7e83d1ec64540abe819ff60d9d8"></map>'
- en: We can now build upon the framing mechanism to allow the hosts to exchange frames
    containing an integer number of bits or bytes. Once the framing problem has been
    solved, we can use these frames to carry Internet packets.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以基于帧机制来允许主机交换包含整数个比特或字节的帧。一旦帧问题得到解决，我们就可以使用这些帧来携带互联网数据包。
- en: Coping with transmission errors[#](#coping-with-transmission-errors "Link to
    this heading")
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应对传输错误[#](#coping-with-transmission-errors "链接到这个标题")
- en: 'As explained earlier, the physical layer can be subject to various types that
    affect the bits sent by a transmitter. Data transmission on a physical link can
    be affected by the following errors :'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，物理层可能受到各种类型的影响，这些类型会影响发送器发送的比特。物理链路上的数据传输可能受到以下错误的影响：
- en: random isolated errors where the value of a single bit has been modified due
    to a transmission error
  id: totrans-1086
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机孤立错误，由于传输错误导致单个比特的值被修改
- en: ''
  id: totrans-1087
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: random burst errors where the values of n consecutive bits have been changed
    due to transmission errors
  id: totrans-1089
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机突发错误，由于传输错误导致n个连续比特的值发生变化
- en: ''
  id: totrans-1090
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1091
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: random bit creations and random bit removals where bits have been added or removed
    due to transmission errors
  id: totrans-1092
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机比特生成和随机比特删除，由于传输错误导致比特被添加或删除
- en: Besides framing, datalink layers also include mechanisms to detect and sometimes
    even recover from transmission errors. To allow a receiver to notice transmission
    errors, a sender must add some redundant information as an error detection code
    to the frame sent. This error detection code is computed by the sender on the
    frame that it transmits. When the receiver receives a frame with an error detection
    code, it recomputes it and verifies whether the received error detection code
    matches the computed error detection code. If they match, the frame is considered
    to be valid.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帧之外，数据链路层还包括检测传输错误以及有时甚至从中恢复的机制。为了使接收器能够注意到传输错误，发送器必须在发送的帧中添加一些冗余信息作为错误检测码。这个错误检测码是由发送器在它发送的帧上计算的。当接收器接收到带有错误检测码的帧时，它会重新计算它并验证接收到的错误检测码是否与计算出的错误检测码匹配。如果它们匹配，则认为该帧是有效的。
- en: '[PRE5]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Framing on the Internet
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的帧
- en: The bit stuffing and character stuffing described above are generic solutions
    applied by various protocols. When Internet hosts used dial-up modems or serial
    transmission to exchange data, they used protocols such as SLIP defined in [**RFC
    1035**](https://datatracker.ietf.org/doc/html/rfc1035.html) or PPP defined in
    [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 上文中描述的比特填充和字符填充是各种协议应用的通用解决方案。当互联网主机使用拨号调制解调器或串行传输交换数据时，它们使用了在 [**RFC 1035**](https://datatracker.ietf.org/doc/html/rfc1035.html)
    中定义的 SLIP 或在 [**RFC 1661**](https://datatracker.ietf.org/doc/html/rfc1661.html)
    中定义的 PPP 等协议。
- en: The Serial Line IP (SLIP) protocol uses character stuffing with two special
    characters (`END`, 192 in decimal and `ESC`, 219 in decimal).
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 串行线路 IP (SLIP) 协议使用两个特殊字符（`END`，十进制 192 和 `ESC`，十进制 219）进行字符填充。
- en: The Point-to-Point Protocol (PPP) supports different techniques of framing.
    [**RFC 1662**](https://datatracker.ietf.org/doc/html/rfc1662.html) describes how
    character stuffing and bit stuffing can be used by PPP.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点协议 (PPP) 支持不同的帧定界技术。[**RFC 1662**](https://datatracker.ietf.org/doc/html/rfc1662.html)
    描述了 PPP 如何使用字符填充和比特填充。
- en: '[Fig. 126](../networks/network.html#fig-datalink-layer) illustrates the second
    layer of the protocol stack that uses the services provided by the Physical layer
    to exchange frames. We will use the word frame throughout this book to refer to
    the unit of information exchanged between two datalink layer entities.'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 126](../networks/network.html#fig-datalink-layer) 展示了使用物理层提供的服务的协议栈的第二层，用于交换帧。在这本书中，我们将使用“帧”一词来指代两个数据链路层实体之间交换的信息单元。'
- en: '![Figure made with TikZ](../Images/45dcd309f199df5246b8a933469eb608.png)'
  id: totrans-1102
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/45dcd309f199df5246b8a933469eb608.png)'
- en: Fig. 4 The Datalink layer in the protocol stack
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4 协议栈中的数据链路层
- en: The network layer[#](#the-network-layer "Link to this heading")
  id: totrans-1104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '网络层[#](#the-network-layer "链接到本标题") '
- en: The Datalink layer allows directly connected hosts to exchange information,
    but it is often necessary to exchange information between hosts that are not attached
    to the same physical medium. This is the task of the network layer. The network
    layer is built above the datalink layer. Network layer entities exchange packets.
    A packet is a finite sequence of bytes that is transported by the datalink layer
    inside one or more frames. A packet usually contains information about its origin
    and its destination, and usually passes through several intermediate devices called
    routers on its way from its origin to its destination. This is illustrated in
    [Fig. 5](#fig-network-layer).
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层允许直接连接的主机交换信息，但通常需要在连接到同一物理介质的不同主机之间交换信息。这是网络层的任务。网络层建立在数据链路层之上。网络层实体交换数据包。数据包是由数据链路层在一个或多个帧内传输的有限字节序列。数据包通常包含有关其来源和目的地的信息，并且在从其来源到目的地的过程中通常通过几个称为路由器的中间设备。这如图
    [图 5](#fig-network-layer) 所示。
- en: '![Figure made with TikZ](../Images/df939036e063e29a614edfaad7147595.png)'
  id: totrans-1106
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/df939036e063e29a614edfaad7147595.png)'
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 5 The network layer
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 5 网络层
- en: Internet hosts such as laptops, smartphones, PCs, servers, and various Internet
    of Things (IoT) devices connect to the Internet through various types of datalink
    layer technologies. Popular datalink layer technologies include Wi-Fi, Ethernet,
    Bluetooth, and the different types of cellular network technologies such as 4G
    and 5G. Some of these technologies will be discussed in the second part of this
    book. They have very specific characteristics that we ignore in this part of the
    book.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网主机，如笔记本电脑、智能手机、PC、服务器以及各种物联网 (IoT) 设备，通过各种类型的数据链路层技术连接到互联网。流行的数据链路层技术包括 Wi-Fi、以太网、蓝牙以及不同类型的蜂窝网络技术，如
    4G 和 5G。本书的第二部分将讨论其中一些技术。它们具有非常具体的特性，本书的这一部分将忽略它们。
- en: 'The Internet relies on a few architectural principles. First, all the information
    that hosts exchange must be divided into [IP](../glossary.html#term-IP) [packets](../glossary.html#term-packets).
    IP stands for the [Internet Protocol](../glossary.html#term-Internet-Protocol).
    This is the [protocol](../glossary.html#term-protocol) or the set of rules that
    hosts apply when exchanging information. An IP packet is a variable-length sequence
    of bytes that contains two main parts :'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网依赖于几个架构原则。首先，主机交换的所有信息都必须划分为 [IP](../glossary.html#term-IP) [数据包](../glossary.html#term-packets)。IP
    代表 [互联网协议](../glossary.html#term-Internet-Protocol)。这是主机在交换信息时应用的 [协议](../glossary.html#term-protocol)
    或规则集。IP 数据包是一个可变长度的字节序列，包含两个主要部分：
- en: a header which contains control information specifying notably the source and
    the destination of the payload
  id: totrans-1111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含控制信息的头部，这些信息特别指定了有效负载的源和目的地
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a payload which contains the data to be exchanged
  id: totrans-1114
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含要交换的数据的有效负载
- en: A second principle is that each host is identified by a unique [IP address](../glossary.html#term-IP-address).
    An [IP address](../glossary.html#term-IP-address) is a fixed-length bit string
    that identifies a host. Each Internet host has a unique [IP address](../glossary.html#term-IP-address).
    Each IP packet contains both the IP address of the source or origin of the packet
    and the IP address of the destination or recipient of the packet. The network
    uses the destination address to deliver each packet to its final recipient.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原则是每个主机由一个唯一的[IP地址](../glossary.html#term-IP-address)标识。一个[IP地址](../glossary.html#term-IP-address)是一个固定长度的位串，用于标识一个主机。每个互联网主机都有一个唯一的[IP地址](../glossary.html#term-IP-address)。每个IP数据包都包含数据包的源或原始地址以及数据包的目的地或接收者的IP地址。网络使用目的地地址将每个数据包交付给其最终接收者。
- en: Throughout this part, we will consider the Internet as a black box as shown
    in [Fig. 6](#fig-network-blackbox). We will focus on hos hosts interact and will
    reveal how the network really operates in the second part of the book.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将把互联网视为一个黑盒，如图6所示。[图6](#fig-network-blackbox)。我们将关注主机之间的交互，并在本书的第二部分揭示网络的实际运作方式。
- en: '![Figure made with TikZ](../Images/c28dbcfe5a4f553d7a8b75481407429b.png)'
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/c28dbcfe5a4f553d7a8b75481407429b.png)'
- en: ''
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 6 Internet hosts can exchange packets
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图6 互联网主机可以交换数据包
- en: Thanks to these architectural principles, any Internet host can send an IP packet
    at any time to any other Internet host. A host could send a packet to a server
    in America and shortly after another packet to a server in Australia or Africa.
    For a host, sending a packet is a cheap operation. It creates a sequence of bytes
    containing the header and the payload and then passes it to the network interface
    card. The other elements of the network will handle the packet and deliver it
    to its final destination.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这些架构原则，任何互联网主机都可以在任何时候向任何其他互联网主机发送一个IP数据包。一个主机可以向美国的服务器发送一个数据包，紧接着又向澳大利亚或非洲的服务器发送另一个数据包。对于主机来说，发送一个数据包是一个低成本的操作。它创建了一个包含头部和有效负载的字节序列，并将其传递给网络接口卡。网络的其余部分将处理该数据包并将其交付到最终目的地。
- en: A primer on IP version 4[#](#a-primer-on-ip-version-4 "Link to this heading")
  id: totrans-1121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[IP版本4简介](#a-primer-on-ip-version-4 "链接到本标题")'
- en: Two different versions of the Internet protocol are used on today’s Internet.
    The first one, named [IP version 4](../glossary.html#term-IP-version-4) uses 32-bit
    long addresses. IPv4 addresses are often represented in dotted-decimal format
    as a sequence of four integers separated by a dot. The first integer is the decimal
    representation of the most significant byte of the 32-bit IPv4 address, … For
    example,
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的互联网上使用了两种不同的互联网协议版本。第一个版本，称为[IP版本4](../glossary.html#term-IP-version-4)，使用32位长地址。IPv4地址通常以点分十进制格式表示，为四个由点分隔的整数序列。第一个整数是32位IPv4地址最高有效字节的十进制表示，……例如，
- en: '`1.2.3.4` corresponds to `00000001 00000010 00000011 00000100`'
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.2.3.4` 对应于 `00000001 00000010 00000011 00000100`'
- en: ''
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`127.0.0.1` corresponds to `01111111 00000000 00000000 00000001`'
  id: totrans-1126
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1` 对应于 `01111111 00000000 00000000 00000001`'
- en: ''
  id: totrans-1127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`255.255.255.255` corresponds to `1111111 1111111 11111111 1111111111`'
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255.255.255.255` 对应于 `1111111 1111111 11111111 1111111111`'
- en: This version was designed when the Internet was a research network that connected
    computers in universities and research labs. At that time, having a maximum of
    \(2^{32}\) IPv4 addresses was not considered to be a severe limitation. Today,
    almost all the available IPv4 addresses have been assigned to various organizations
    ranging from enterprises or universities to [Internet Service Providers](../glossary.html#term-Internet-Service-Providers).
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是在互联网还是一个连接大学和研究实验室计算机的研究网络时设计的。当时，拥有最多 \(2^{32}\) 个IPv4地址并不被认为是一个严重的限制。今天，几乎所有可用的IPv4地址都已分配给各种组织，从企业或大学到[互联网服务提供商](../glossary.html#term-Internet-Service-Providers)。
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high-order bits of the
    address, and the host identifier is encoded in the low-order bits of the address.
    This is illustrated in figure [Fig. 7](#fig-subnetwork) with a 22-bit subnetwork
    identifier shown in blue and a 12-bit host identifier in red.'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv4 地址由两部分组成：子网标识符和主机标识符。子网标识符由地址的高位组成，而主机标识符编码在地址的低位中。这如图 [图 7](#fig-subnetwork)
    所示，其中 22 位子网标识符以蓝色显示，12 位主机标识符以红色显示。
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  id: totrans-1132
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
- en: Fig. 7 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7 IPv4 地址内的子网（蓝色）和主机标识符（红色）
- en: Flexibility in the IPv4 addressing architecture was added with the introduction
    of variable-length subnets in [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html).
    IPv4 supports variable-length subnets where the subnet identifier can be any size,
    from 1 to 31 bits. Variable-length subnets allow the network operators to use
    a subnet that better matches the number of hosts that are placed inside the subnet.
    A subnet identifier or IPv4 prefix is usually represented as `A.B.C.D/p` where
    `A.B.C.D` is the network address obtained by concatenating the subnet identifier
    with a host identifier containing only 0 and p is the length of the subnet identifier
    in bits. The table below provides examples of IP subnets.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html) 中引入可变长度子网后，IPv4
    地址架构中增加了灵活性。IPv4 支持可变长度子网，其中子网标识符可以是 1 到 31 位的任何大小。可变长度子网允许网络运营商使用更适合子网内放置的主机数量的子网。子网标识符或
    IPv4 前缀通常表示为 `A.B.C.D/p`，其中 `A.B.C.D` 是通过将子网标识符与仅包含 0 和 p 的主机标识符连接而获得的网络地址，p 是子网标识符的位数长度。下表提供了
    IP 子网的示例。
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  id: totrans-1135
  prefs: []
  type: TYPE_TB
  zh: '| 子网 | 地址数量 | 最小地址 | 最大地址 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  id: totrans-1138
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  id: totrans-1139
  prefs: []
  type: TYPE_TB
  zh: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  id: totrans-1140
  prefs: []
  type: TYPE_TB
  zh: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  id: totrans-1142
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
- en: Note
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Special IPv4 addresses
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的 IPv4 地址
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in RFC :5735. These include
    :'
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数单播 IPv4 地址可以出现在全球互联网上的数据包的源地址和目的地址中。然而，值得注意的是，某些 IPv4 地址块有特殊用途，如 RFC 5735
    所述。这些包括：
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.0.0.0/8，保留用于自我标识。此块中的一个常见地址是 0.0.0.0，有时在主机启动且尚未知道其 IPv4 地址时使用。
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.0/8，保留用于回环地址。每个实现 IPv4 的主机必须有一个回环接口（即未连接到数据链路层）。按照惯例，IPv4 地址 127.0.0.1
    被分配给此接口。这允许在主机上运行的过程使用 TCP/IP 来联系同一主机上运行的其他过程。这在测试目的上非常有用。
- en: 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 保留用于不直接连接到互联网的私有网络。这些地址通常被称为私有地址或[**RFC
    1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)地址。
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  id: totrans-1149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 169.254.0.0/16 用于链路本地地址 [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。当某些主机连接到未按预期分配地址的网络时，它们会使用此块中的地址。
- en: 192.0.2.0/24, 198.51.100.0/24, and 203.0.113.0/24 are reserved for use in documentation.
    These addresses cannot be used on the public Internet and should not be accepted
    by hosts. This book should ideally use these addresses when providing examples.
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 192.0.2.0/24、198.51.100.0/24 和 203.0.113.0/24 保留用于文档用途。这些地址不能在公共互联网上使用，主机也不应接受这些地址。本书在提供示例时理想情况下应使用这些地址。
- en: The unit of information for IPv4 is the [packet](../glossary.html#term-packet).
    An IPv4 packet has a 20-byte header which contains the source and destination
    addresses of the packet and some control information. One of the control fields
    of the IPv4 header is a 16-bit field that contains the total length of the packet
    (header included). An IPv4 packet cannot be longer than 65535 bytes, header included.
    In practice, hosts rarely send really long packets and most IPv4 packets are shorter
    than about 1500 bytes. The IPv4 packet header is shown in [Fig. 8](#fig-ipv4-header).
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 的信息单位是 [数据包](../glossary.html#term-packet)。IPv4 数据包有一个 20 字节的首部，其中包含数据包的源地址和目标地址以及一些控制信息。IPv4
    首部的一个控制字段是一个 16 位字段，包含数据包的总长度（包括首部）。IPv4 数据包的长度不能超过 65535 字节（包括首部）。在实际中，主机很少发送真正长的数据包，大多数
    IPv4 数据包的长度都小于约 1500 字节。IPv4 数据包首部在 [图 8](#fig-ipv4-header) 中显示。
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)'
- en: Fig. 8 The IP version 4 header[#](#fig-ipv4-header "Link to this image")
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8 IPv4 头部版本[#](#fig-ipv4-header "链接到这张图片")
- en: A primer on IP version 6[#](#a-primer-on-ip-version-6 "Link to this heading")
  id: totrans-1154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6 入门[#](#a-primer-on-ip-version-6 "链接到这个标题")
- en: The second deployed version of IP is [IP version 6](../glossary.html#term-IP-version-6).
    This version of IP introduces several changes compared to IP version 4 that will
    be discussed later. The most important one is the length of the IPv6 addresses.
    An IPv6 address is 128 bits long. This implies that in theory, there are \(2^128=340,282,366,920,938,463,463,374,607,431,768,211,456\)
    unique IPv6 addresses. The number of IPv6 addresses is much larger than the number
    of IPv4 addresses, and we do not expect the IPv6 addressing space to become exhausted
    one day.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: IP 的第二个部署版本是 [IP 版本 6](../glossary.html#term-IP-version-6)。与 IP 版本 4 相比，IP 版本
    6 引入了一些变化，这些变化将在后面讨论。其中最重要的是 IPv6 地址的长度。IPv6 地址是 128 位长。这意味着在理论上，有 \(2^128=340,282,366,920,938,463,463,374,607,431,768,211,456\)
    个唯一的 IPv6 地址。IPv6 地址的数量远大于 IPv4 地址的数量，我们也不期望 IPv6 地址空间有一天会耗尽。
- en: Note
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Textual representation of IPv6 addresses
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址的文本表示
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  id: totrans-1158
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时需要以文本格式编写 IPv6 地址，例如在手动配置地址或用于文档目的时。编写 IPv6 地址的首选格式是 `x:x:x:x:x:x:x:x`，其中
    `x` 是表示地址八个 16 位部分的十六进制数字。以下是一些 IPv6 地址的示例：
- en: ''
  id: totrans-1159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  id: totrans-1160
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
- en: ''
  id: totrans-1161
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1162
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  id: totrans-1163
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`'
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1165
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  id: totrans-1166
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0:0:0:219:e3ff:fed7:1204`'
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16-bit blocks containing only bits set to 0. For example,'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 'IPv6 地址通常包含一个长的位序列，这些位被设置为 `0`。在这种情况下，已经定义了一种紧凑的表示法。使用这种表示法，:: 用于表示一个或多个只包含位设置为
    `0` 的 16 位块的组。例如，'
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  id: totrans-1168
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a` 表示为 `2001:db8::8:800:200c:417a`'
- en: ''
  id: totrans-1169
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1170
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff01:0:0:0:0:0:0:101` 表示为 `ff01::101`'
- en: ''
  id: totrans-1172
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  id: totrans-1174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1` 表示为 `::1`'
- en: ''
  id: totrans-1175
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1176
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  id: totrans-1177
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0` 表示为 `::`'
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 前缀可以表示为地址/长度，其中长度是前缀的位数长度。例如，以下三种表示法对应相同的 IPv6 前缀：
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  id: totrans-1179
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
- en: ''
  id: totrans-1180
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1181
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  id: totrans-1182
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8::cd30:0:0:0:0` / `60`'
- en: ''
  id: totrans-1183
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  id: totrans-1185
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0:cd30::` / `60`'
- en: An IPv6 packet starts with a header of at least 40 bytes. It contains the source
    and destination IPv6 addresses as well as a 16-bit-long length field. This implies
    that IPv6 packets cannot be longer than 65535 bytes. As for IPv4, most observed
    IPv6 packets are shorter than about 1500 bytes.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 数据包以至少 40 字节的首部开始。它包含源和目的 IPv6 地址以及一个 16 位长的长度字段。这意味着 IPv6 数据包的长度不能超过
    65535 字节。至于 IPv4，大多数观察到的 IPv6 数据包的长度都短于大约 1500 字节。
- en: The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 9](#fig-ipv6-header).
    The structure of this packet will be explained in more detail in the second part
    of this book.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 IPv6 首部，如 [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    所定义，占用 40 字节，包含 8 个不同的字段，如图 [图 9](#fig-ipv6-header) 所示。这本书的第二部分将更详细地解释这个数据包的结构。
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
- en: Fig. 9 The IP version 6 header[#](#id16 "Link to this image")
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9 IPv6 版本 6 首部[#](#id16 "链接到这张图片")
- en: A primer on IP version 4[#](#a-primer-on-ip-version-4 "Link to this heading")
  id: totrans-1190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP 版本 4 入门[#](#a-primer-on-ip-version-4 "链接到这个标题")
- en: Two different versions of the Internet protocol are used on today’s Internet.
    The first one, named [IP version 4](../glossary.html#term-IP-version-4) uses 32-bit
    long addresses. IPv4 addresses are often represented in dotted-decimal format
    as a sequence of four integers separated by a dot. The first integer is the decimal
    representation of the most significant byte of the 32-bit IPv4 address, … For
    example,
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的互联网上使用了两种不同的互联网协议版本。第一个版本被称为 [IP 版本 4](../glossary.html#term-IP-version-4)，它使用
    32 位长的地址。IPv4 地址通常以点分十进制格式表示，为四个由点分隔的整数序列。第一个整数是 32 位 IPv4 地址最高字节十进制表示，……例如，
- en: '`1.2.3.4` corresponds to `00000001 00000010 00000011 00000100`'
  id: totrans-1192
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.2.3.4` 对应于 `00000001 00000010 00000011 00000100`'
- en: ''
  id: totrans-1193
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1194
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`127.0.0.1` corresponds to `01111111 00000000 00000000 00000001`'
  id: totrans-1195
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1` 对应于 `01111111 00000000 00000000 00000001`'
- en: ''
  id: totrans-1196
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1197
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`255.255.255.255` corresponds to `1111111 1111111 11111111 1111111111`'
  id: totrans-1198
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255.255.255.255` 对应于 `1111111 1111111 11111111 1111111111`'
- en: This version was designed when the Internet was a research network that connected
    computers in universities and research labs. At that time, having a maximum of
    \(2^{32}\) IPv4 addresses was not considered to be a severe limitation. Today,
    almost all the available IPv4 addresses have been assigned to various organizations
    ranging from enterprises or universities to [Internet Service Providers](../glossary.html#term-Internet-Service-Providers).
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是在互联网还是一个连接大学和研究实验室计算机的研究网络时设计的。当时，拥有 \(2^{32}\) 个 IPv4 地址被认为不是严重的限制。今天，几乎所有可用的
    IPv4 地址都已分配给各种组织，从企业或大学到 [互联网服务提供商](../glossary.html#term-Internet-Service-Providers)。
- en: 'An IPv4 address is composed of two parts : a subnetwork identifier and a host
    identifier. The subnetwork identifier is composed of the high-order bits of the
    address, and the host identifier is encoded in the low-order bits of the address.
    This is illustrated in figure [Fig. 7](#fig-subnetwork) with a 22-bit subnetwork
    identifier shown in blue and a 12-bit host identifier in red.'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv4 地址由两部分组成：子网标识符和主机标识符。子网标识符由地址的高位位组成，而主机标识符编码在地址的低位位中。这如图 [图 7](#fig-subnetwork)
    所示，其中蓝色表示 22 位子网标识符，红色表示 12 位主机标识符。
- en: '![Figure made with TikZ](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/03c5aa7a0fcd0914d2426d59732c3312.png)'
- en: Fig. 7 The subnetwork (blue) and host identifiers (red) inside an IPv4 address
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7 IPv4 地址内的子网（蓝色）和主机标识符（红色）
- en: Flexibility in the IPv4 addressing architecture was added with the introduction
    of variable-length subnets in [**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html).
    IPv4 supports variable-length subnets where the subnet identifier can be any size,
    from 1 to 31 bits. Variable-length subnets allow the network operators to use
    a subnet that better matches the number of hosts that are placed inside the subnet.
    A subnet identifier or IPv4 prefix is usually represented as `A.B.C.D/p` where
    `A.B.C.D` is the network address obtained by concatenating the subnet identifier
    with a host identifier containing only 0 and p is the length of the subnet identifier
    in bits. The table below provides examples of IP subnets.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入可变长度子网后，IPv4寻址架构增加了灵活性，如[**RFC 1519**](https://datatracker.ietf.org/doc/html/rfc1519.html)所述。IPv4支持可变长度子网，其中子网标识符可以是1到31位中的任何大小。可变长度子网允许网络操作员使用与子网内放置的主机数量更好地匹配的子网。子网标识符或IPv4前缀通常表示为
    `A.B.C.D/p`，其中 `A.B.C.D` 是通过将子网标识符与仅包含0的主机标识符连接而获得的网络地址，p是子网标识符的位数。下表提供了IP子网的示例。
- en: '| Subnet | Number of addresses | Smallest address | Highest address |'
  id: totrans-1204
  prefs: []
  type: TYPE_TB
  zh: '| 子网 | 地址数量 | 最小地址 | 最大地址 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/8 | 16,777,216 | 10.0.0.0 | 10.255.255.255 |'
- en: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
  id: totrans-1207
  prefs: []
  type: TYPE_TB
  zh: '| 192.168.0.0/16 | 65,536 | 192.168.0.0 | 192.168.255.255 |'
- en: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
  id: totrans-1208
  prefs: []
  type: TYPE_TB
  zh: '| 198.18.0.0/15 | 131,072 | 198.18.0.0 | 198.19.255.255 |'
- en: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
  id: totrans-1209
  prefs: []
  type: TYPE_TB
  zh: '| 192.0.2.0/24 | 256 | 192.0.2.0 | 192.0.2.255 |'
- en: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
  id: totrans-1210
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/30 | 4 | 10.0.0.0 | 10.0.0.3 |'
- en: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
  id: totrans-1211
  prefs: []
  type: TYPE_TB
  zh: '| 10.0.0.0/31 | 2 | 10.0.0.0 | 10.0.0.1 |'
- en: Note
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Special IPv4 addresses
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊IPv4地址
- en: 'Most unicast IPv4 addresses can appear as source and destination addresses
    in packets on the global Internet. However, it is worth noting that some blocks
    of IPv4 addresses have a special usage, as described in RFC :5735. These include
    :'
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数单播IPv4地址可以出现在全球互联网上的数据包的源地址和目的地址中。然而，值得注意的是，某些IPv4地址块有特殊用途，如RFC 5735所述。这些包括：
- en: 0.0.0.0/8, which is reserved for self-identification. A common address in this
    block is 0.0.0.0, which is sometimes used when a host boots and does not yet know
    its IPv4 address.
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.0.0.0/8，保留用于自我标识。此块中的常见地址是0.0.0.0，有时在主机启动且尚未知道其IPv4地址时使用。
- en: 127.0.0.0/8, which is reserved for loopback addresses. Each host implementing
    IPv4 must have a loopback interface (that is not attached to a datalink layer).
    By convention, IPv4 address 127.0.0.1 is assigned to this interface. This allows
    processes running on a host to use TCP/IP to contact other processes running on
    the same host. This can be very useful for testing purposes.
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 127.0.0.0/8，保留用于环回地址。每个实现IPv4的主机都必须有一个环回接口（即未连接到数据链路层）。按照惯例，IPv4地址127.0.0.1分配给此接口。这允许在主机上运行的过程使用TCP/IP来联系同一主机上运行的其他过程。这对于测试目的非常有用。
- en: 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16 are reserved for private networks
    that are not directly attached to the Internet. These addresses are often called
    private addresses or [**RFC 1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)
    addresses.
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0/8, 172.16.0.0/12, 和 192.168.0.0/16 保留用于不直接连接到互联网的私有网络。这些地址通常被称为私有地址或[**RFC
    1918**](https://datatracker.ietf.org/doc/html/rfc1918.html)地址。
- en: 169.254.0.0/16 is used for link-local addresses [**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html).
    Some hosts use an address in this block when they are connected to a network that
    does not allocate addresses as expected.
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 169.254.0.0/16 用于链路本地地址[**RFC 3927**](https://datatracker.ietf.org/doc/html/rfc3927.html)。一些主机在连接到未按预期分配地址的网络时使用此块中的地址。
- en: 192.0.2.0/24, 198.51.100.0/24, and 203.0.113.0/24 are reserved for use in documentation.
    These addresses cannot be used on the public Internet and should not be accepted
    by hosts. This book should ideally use these addresses when providing examples.
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 192.0.2.0/24, 198.51.100.0/24, 和 203.0.113.0/24 保留用于文档用途。这些地址不能在公共互联网上使用，主机不应接受这些地址。本书在提供示例时理想情况下应使用这些地址。
- en: The unit of information for IPv4 is the [packet](../glossary.html#term-packet).
    An IPv4 packet has a 20-byte header which contains the source and destination
    addresses of the packet and some control information. One of the control fields
    of the IPv4 header is a 16-bit field that contains the total length of the packet
    (header included). An IPv4 packet cannot be longer than 65535 bytes, header included.
    In practice, hosts rarely send really long packets and most IPv4 packets are shorter
    than about 1500 bytes. The IPv4 packet header is shown in [Fig. 8](#fig-ipv4-header).
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的信息单位是[数据包](../glossary.html#term-packet)。一个IPv4数据包包含一个20字节的头部，其中包含数据包的源地址和目的地址以及一些控制信息。IPv4头部的一个控制字段是一个16位的字段，包含数据包的总长度（包括头部）。IPv4数据包的长度不能超过65535字节，包括头部。在实际应用中，主机很少发送真正长的数据包，大多数IPv4数据包的长度都小于约1500字节。IPv4数据包头部在[图8](#fig-ipv4-header)中展示。
- en: '[![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)](../_images/ipv4.svg)'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/ipv4.svg](../Images/8871e184de5c481e4e3b12210a03c90b.png)'
- en: Fig. 8 The IP version 4 header[#](#fig-ipv4-header "Link to this image")
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8 IP版本4头部[#](#fig-ipv4-header "链接到这张图片")
- en: A primer on IP version 6[#](#a-primer-on-ip-version-6 "Link to this heading")
  id: totrans-1223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6版本入门[#](#a-primer-on-ip-version-6 "链接到这个标题")
- en: The second deployed version of IP is [IP version 6](../glossary.html#term-IP-version-6).
    This version of IP introduces several changes compared to IP version 4 that will
    be discussed later. The most important one is the length of the IPv6 addresses.
    An IPv6 address is 128 bits long. This implies that in theory, there are \(2^128=340,282,366,920,938,463,463,374,607,431,768,211,456\)
    unique IPv6 addresses. The number of IPv6 addresses is much larger than the number
    of IPv4 addresses, and we do not expect the IPv6 addressing space to become exhausted
    one day.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: IP的第二种部署版本是[IPv6版本](../glossary.html#term-IP-version-6)。与IPv4相比，IPv6引入了几个变化，将在后面讨论。其中最重要的是IPv6地址的长度。IPv6地址是128位长。这意味着在理论上，有\(2^128=340,282,366,920,938,463,463,374,607,431,768,211,456\)个唯一的IPv6地址。IPv6地址的数量远大于IPv4地址的数量，我们并不期望IPv6地址空间有一天会耗尽。
- en: Note
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Textual representation of IPv6 addresses
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址的文本表示
- en: 'It is sometimes necessary to write IPv6 addresses in text format, e.g. when
    manually configuring addresses or for documentation purposes. The preferred format
    for writing IPv6 addresses is `x:x:x:x:x:x:x:x`, where the `x` ‘s are hexadecimal
    digits representing the eight 16-bit parts of the address. Here are a few examples
    of IPv6 addresses :'
  id: totrans-1227
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时需要以文本格式编写IPv6地址，例如手动配置地址或用于文档目的。编写IPv6地址的首选格式是`x:x:x:x:x:x:x:x`，其中`x`是表示地址八个16位部分的十六进制数字。以下是一些IPv6地址的示例：
- en: ''
  id: totrans-1228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
  id: totrans-1229
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abcd:ef01:2345:6789:abcd:ef01:2345:6789`'
- en: ''
  id: totrans-1230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1231
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:db8:0:0:8:800:200c:417a`'
  id: totrans-1232
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`'
- en: ''
  id: totrans-1233
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1234
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fe80:0:0:0:219:e3ff:fed7:1204`'
  id: totrans-1235
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0:0:0:219:e3ff:fed7:1204`'
- en: 'IPv6 addresses often contain a long sequence of bits set to `0`. In this case,
    a compact notation has been defined. With this notation, :: is used to indicate
    one or more groups of 16-bit blocks containing only bits set to 0. For example,'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址通常包含一系列设置为`0`的位。在这种情况下，已经定义了一种紧凑的表示法。使用这种表示法，::用于表示一个或多个只包含设置为0的位的16位块组。例如，
- en: '`2001:db8:0:0:8:800:200c:417a` is represented as `2001:db8::8:800:200c:417a`'
  id: totrans-1237
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8:0:0:8:800:200c:417a`表示为`2001:db8::8:800:200c:417a`'
- en: ''
  id: totrans-1238
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1239
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ff01:0:0:0:0:0:0:101` is represented as `ff01::101`'
  id: totrans-1240
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ff01:0:0:0:0:0:0:101`表示为`ff01::101`'
- en: ''
  id: totrans-1241
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1242
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:1` is represented as `::1`'
  id: totrans-1243
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:1`表示为`::1`'
- en: ''
  id: totrans-1244
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1245
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0:0:0:0:0:0:0:0` is represented as `::`'
  id: totrans-1246
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0:0:0:0:0:0:0:0`表示为`::`'
- en: 'An IPv6 prefix can be represented as address/length, where length is the length
    of the prefix in bits. For example, the three notations below correspond to the
    same IPv6 prefix :'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IPv6前缀可以表示为地址/长度，其中长度是前缀的位数长度。例如，以下三种表示法对应于相同的IPv6前缀：
- en: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
  id: totrans-1248
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:cd30:0000:0000:0000:0000` / `60`'
- en: ''
  id: totrans-1249
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1250
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8::cd30:0:0:0:0` / `60`'
  id: totrans-1251
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8::cd30:0:0:0:0` / `60`'
- en: ''
  id: totrans-1252
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1253
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`2001:0db8:0:cd30::` / `60`'
  id: totrans-1254
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0:cd30::` / `60`'
- en: An IPv6 packet starts with a header of at least 40 bytes. It contains the source
    and destination IPv6 addresses as well as a 16-bit-long length field. This implies
    that IPv6 packets cannot be longer than 65535 bytes. As for IPv4, most observed
    IPv6 packets are shorter than about 1500 bytes.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6数据包以至少40字节的头部开始。它包含源IPv6地址和目的IPv6地址以及一个16位长的长度字段。这意味着IPv6数据包的长度不能超过65535字节。与IPv4类似，观察到的大多数IPv6数据包的长度都小于约1500字节。
- en: The standard IPv6 header defined in [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    occupies 40 bytes and contains 8 different fields, as shown in [Fig. 9](#fig-ipv6-header).
    The structure of this packet will be explained in more detail in the second part
    of this book.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 标准IPv6头部在[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)中定义，占用40字节，包含8个不同的字段，如图9所示。这本书的第二部分将更详细地解释这种数据包的结构。
- en: '[![../_images/ipv6.svg](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)](../_images/ipv6.svg)'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '![IPv6标准头部](../Images/edbbdd527f59f4dd548e19b2b90f6405.png)(../_images/ipv6.svg)'
- en: Fig. 9 The IP version 6 header[#](#id16 "Link to this image")
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 图9 IP版本6头部[#](#id16 "链接到这张图片")
- en: The transport layer[#](#the-transport-layer "Link to this heading")
  id: totrans-1259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层[#](#the-transport-layer "链接到这个标题")
- en: The network layer enables hosts to reach each others through intermediate routers.
    However, different communication flows can take place between the same hosts.
    These communication flows might have different needs (some require reliable delivery,
    other not) and need to be distinguished. Ensuring an identification of a communication
    flow between two given hosts is the task of the transport layer. Transport layer
    entities exchange segments. A segment is a finite sequence of bytes that are transported
    inside one or more packets. A transport layer entity issues segments (or sometimes
    part of segments) as Data.request to the underlying network layer entity. This
    is illustrated in [Fig. 10](#fig-transport-layer1).
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层使主机能够通过中间路由器相互连接。然而，同一主机之间可以发生不同的通信流。这些通信流可能有不同的需求（一些需要可靠交付，其他则不需要）并且需要区分。确保在两个给定主机之间识别通信流是传输层的任务。传输层实体交换段。段是在一个或多个数据包内部传输的字节有限序列。传输层实体将段（或有时是段的一部分）作为Data.request发送到下层的网络层实体。这如图10所示。
- en: There are different types of transport layers. The most widely used transport
    layers on the Internet are [TCP](../glossary.html#term-TCP), that provides a reliable
    connection-oriented bytestream transport service, and [UDP](../glossary.html#term-UDP),
    that provides an unreliable connection-less transport service.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着不同类型的传输层。在互联网上最广泛使用的传输层是[TCP](../glossary.html#term-TCP)，它提供了一种可靠的面向连接的字节流传输服务，以及[UDP](../glossary.html#term-UDP)，它提供了一种不可靠的无连接传输服务。
- en: '![Figure made with TikZ](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
- en: ''
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 10 The transport layer
  id: totrans-1264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10 传输层
- en: A network is always designed and built to enable applications running on hosts
    to exchange information. In a previous chapter, we have explained the principles
    of the network layer that enables hosts connected to different types of datalink
    layers to exchange information through routers. These routers act as relays in
    the network layer and ensure the delivery of packets between any pair of hosts
    attached to the network.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 网络总是被设计和构建，以使在主机上运行的应用程序能够交换信息。在前面的一章中，我们解释了网络层的原理，该原理使连接到不同类型数据链路层的主机能够通过路由器交换信息。这些路由器在网络层中充当中继，确保网络中任何一对连接的主机之间数据包的交付。
- en: The network layer ensures the delivery of packets on a hop-by-hop basis through
    intermediate nodes. As such, it provides a service to the upper layer. In practice,
    this layer is usually the transport layer that improves the service provided by
    the network layer to make it usable by applications. This is illustrated in [Fig.
    11](#fig-transport-layer).
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层通过中间节点按跳步确保数据包的交付。因此，它为上层提供服务。在实践中，这一层通常是传输层，它改进了网络层提供的服务，使其可供应用程序使用。这如图11所示。
- en: '![Figure made with TikZ](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
  id: totrans-1267
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/82aa1449b761b3c878454fd02dcf3153.png)'
- en: ''
  id: totrans-1268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 11 The transport layer
  id: totrans-1269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图11 传输层
- en: Most networks use a datagram organization and provide a simple service which
    is called the connectionless service.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络使用数据报组织并提供一种简单的服务，这种服务被称为无连接服务。
- en: 'As the transport layer is built on top of the network layer, it is important
    to know the key features of the network layer service. In this book, we only consider
    the connectionless network layer service which is the most widespread. Its main
    characteristics are :'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传输层建立在网络层之上，了解网络层服务的关键特征很重要。在这本书中，我们只考虑最广泛使用的无连接网络层服务。其主要特征如下：
- en: the connectionless network layer service can only transfer SDUs of *limited
    size*
  id: totrans-1272
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务只能传输**有限大小**的SDU
- en: ''
  id: totrans-1273
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1274
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connectionless network layer service may discard SDUs
  id: totrans-1275
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务可能会丢弃SDU
- en: ''
  id: totrans-1276
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1277
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connectionless network layer service may corrupt SDUs
  id: totrans-1278
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务可能会损坏SDU
- en: ''
  id: totrans-1279
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1280
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connectionless network layer service may delay, reorder or even duplicate
    SDUs
  id: totrans-1281
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接网络层服务可能会延迟、重排或甚至重复SDU
- en: These imperfections of the connectionless network layer service are caused by
    the operations of the network layer. This layer is able to deliver packets to
    their intended destination, but it cannot guarantee their delivery. The main cause
    of packet losses and errors are the buffers used on the network nodes. If the
    buffers of one of these nodes becomes full, all arriving packets must be discarded.
    This situation frequently happens in practice. Transmission errors can also affect
    packet transmissions on links where reliable transmission techniques are not enabled
    or because of errors in the buffers of the network nodes.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些无连接网络层服务的不完美是由网络层的操作引起的。该层能够将数据包递送到其预期目的地，但不能保证其递送。数据包丢失和错误的主要原因是在网络节点上使用的缓冲区。如果这些节点中的一个缓冲区满了，所有到达的数据包都必须被丢弃。这种情况在实践中经常发生。传输错误也可能影响在未启用可靠传输技术的链路上的数据包传输，或者是因为网络节点缓冲区中的错误。
- en: 'There are three main types of transport services :'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 传输服务主要有三种类型：
- en: the connectionless service
  id: totrans-1284
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无连接服务
- en: ''
  id: totrans-1285
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1286
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the connection-oriented (byte-stream or message-mode) service
  id: totrans-1287
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有连接的（字节流或消息模式）服务
- en: ''
  id: totrans-1288
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1289
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the request-response service
  id: totrans-1290
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应服务
- en: The connectionless transport service[#](#the-connectionless-transport-service
    "Link to this heading")
  id: totrans-1291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接传输服务[#](#the-connectionless-transport-service "链接到本标题")
- en: The connectionless service allows applications to easily exchange messages or
    Service Data Units. On the Internet, this service is provided by the UDP protocol
    that will be explained in the next chapter. The connectionless transport service
    on the Internet is unreliable, but is able to detect transmission errors. This
    implies that an application will not receive data that has been corrupted due
    to transmission errors.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务允许应用程序轻松交换消息或服务数据单元。在互联网上，此服务由将在下一章解释的UDP协议提供。互联网上的无连接传输服务是不可靠的，但能够检测传输错误。这意味着应用程序不会接收到因传输错误而损坏的数据。
- en: The figure below provides a representation of the connectionless service as
    a time-sequence diagram. The user on the left, having address S, issues a Data.request
    primitive containing Service Data Unit (SDU) M that must be delivered by the service
    provider to destination D. The dashed line between the two primitives indicates
    that the Data.indication primitive that is delivered to the user on the right
    corresponds to the Data.request primitive sent by the user on the left.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 下图提供了一个无连接服务作为时序图的表示。左侧的用户，地址为S，发出包含必须由服务提供商递送到目的地D的服务数据单元（SDU）M的数据请求原语。两个原语之间的虚线表示发送到右侧用户的Data.indication原语对应于左侧用户发送的Data.request原语。
- en: '![msc {'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: '}](../Images/4ee9488e106e721d3505acd29c04b209.png)<map id="fb2f6d7c49baf50b586f9dcecd634d2500634932"
    name="fb2f6d7c49baf50b586f9dcecd634d2500634932"></map>'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/4ee9488e106e721d3505acd29c04b209.png)<map id="fb2f6d7c49baf50b586f9dcecd634d2500634932"
    name="fb2f6d7c49baf50b586f9dcecd634d2500634932"></map>'
- en: There are several possible implementations of the connectionless service. Before
    studying these realizations, it is useful to discuss the possible characteristics
    of the connectionless service. A reliable connectionless service is a service
    where the service provider guarantees that all SDUs submitted in Data.requests
    by a user will eventually be delivered to their destination. Such a service would
    be very useful for users, but guaranteeing perfect delivery is difficult in practice.
    For this reason, network layers usually support an unreliable connectionless service.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 连接无关服务的几种可能的实现方式。在研究这些实现之前，讨论连接无关服务的可能特性是有用的。可靠的连接无关服务是一种服务，服务提供商保证用户通过Data.requests提交的所有SDU最终将被交付到目的地。这种服务对用户非常有用，但在实践中保证完美交付是困难的。因此，网络层通常支持不可靠的连接无关服务。
- en: An unreliable connectionless service may suffer from various types of problems
    compared to a reliable connectionless service. First of all, an unreliable connectionless
    service does not guarantee the delivery of all SDUs. This can be expressed graphically
    by using the time-sequence diagram below.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 与可靠连接无关服务相比，不可靠连接无关服务可能会遭受各种类型的问题。首先，不可靠连接无关服务不保证所有SDU的交付。这可以通过下面的时序图来图形化表示。
- en: '![msc {'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b-x c [ label = "D(b)", arcskip="2", linecolour=red];
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(b)", arcskip="2", linecolour=red];
- en: c=>d1 [ label = "",linecolour=white ];
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "",linecolour=white ];
- en: '}](../Images/177cb46396d45f08e9d7545e3154e18b.png)<map id="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"
    name="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"></map>'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/177cb46396d45f08e9d7545e3154e18b.png)<map id="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"
    name="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"></map>'
- en: In practice, an unreliable connectionless service will usually deliver a large
    fraction of the SDUs. However, since the delivery of SDUs is not guaranteed, the
    user must be able to recover from the loss of any SDU.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，不可靠的连接无关服务通常会交付大部分SDU。然而，由于SDU的交付没有保证，用户必须能够从任何SDU的丢失中恢复。
- en: A second imperfection that may affect an unreliable connectionless service is
    that it may duplicate SDUs. Some packets may be duplicated in a network and be
    delivered twice to their destination. This is illustrated by the time-sequence
    diagram below.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 不可靠的连接无关服务的第二个可能影响其性能的不完美之处是它可能会重复SDU。一些数据包可能在网络中被重复，并两次交付到目的地。这由下面的时序图所示。
- en: '![msc {'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: z>>c [ label = "", arcskip="1"];
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: '}](../Images/f44769bd9ed127c07d494406222a612b.png)<map id="2f24c3b302431a9d40faf6d0285b9a55a8750107"
    name="2f24c3b302431a9d40faf6d0285b9a55a8750107"></map>'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/f44769bd9ed127c07d494406222a612b.png)<map id="2f24c3b302431a9d40faf6d0285b9a55a8750107"
    name="2f24c3b302431a9d40faf6d0285b9a55a8750107"></map>'
- en: Finally, some unreliable connectionless service providers may deliver to a destination
    a different SDU than the one that was supplied in the Data.request. This is illustrated
    in the figure below.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些不可靠的连接无关服务提供商可能会将不同的SDU交付到目的地，而不是在Data.request中提供的SDU。这由下面的图所示。
- en: '![msc {'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"abc\")" ] ,
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"abc\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"xyz\")" ];
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"xyz\")" ];
- en: '}](../Images/d960a02633797ef9170e30439eb112b8.png)<map id="53723b9136cdd91e2719e677046eea6f2bef054a"
    name="53723b9136cdd91e2719e677046eea6f2bef054a"></map>'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/d960a02633797ef9170e30439eb112b8.png)<map id="53723b9136cdd91e2719e677046eea6f2bef054a"
    name="53723b9136cdd91e2719e677046eea6f2bef054a"></map>'
- en: 'The connectionless transport service allows networked application to exchange
    messages. Several networked applications may be running at the same time on a
    single host. Each of these applications must be able to exchange SDUs with remote
    applications. To enable these exchanges of SDUs, each networked application running
    on a host is identified by the following information :'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接传输服务允许网络应用程序交换消息。单个主机上可能同时运行多个网络应用程序。这些应用程序中的每一个都必须能够与远程应用程序交换SDU。为了启用这些SDU交换，运行在主机上的每个网络应用程序都通过以下信息进行标识：
- en: the host on which the application is running
  id: totrans-1350
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序的主机
- en: ''
  id: totrans-1351
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1352
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the port number on which the application listens for data
  id: totrans-1353
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序监听数据所在的端口号
- en: On the Internet, the port number is an integer and the host is identified by
    its IPv4 or IPv6 address. A host that only has an IPv4 address cannot communicate
    with a host having only an IPv6 address. [Fig. 12](#fig-cl-transport) illustrates
    two applications that are using the datagram service provided by UDP on hosts
    that are using IPv4 addresses.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，端口号是一个整数，主机通过其IPv4或IPv6地址进行标识。仅具有IPv4地址的主机无法与仅具有IPv6地址的主机通信。[图12](#fig-cl-transport)说明了两个正在使用IPv4地址的主机上由UDP提供的数据报服务提供的数据报服务。
- en: '![Figure made with TikZ](../Images/e68e29111fe44956f2f9dce525d7fea5.png)'
  id: totrans-1355
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e68e29111fe44956f2f9dce525d7fea5.png)'
- en: ''
  id: totrans-1356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 12 The connectionless or datagram service
  id: totrans-1357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图12 无连接或数据报服务
- en: The connection-oriented transport service[#](#the-connection-oriented-transport-service
    "Link to this heading")
  id: totrans-1358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有连接传输服务[#](#the-connection-oriented-transport-service "链接到本标题")
- en: An invocation of the connection-oriented service is divided into three phases.
    The first phase is the establishment of a connection. A connection is a temporary
    association between two users through a service provider. Several connections
    may exist at the same time between any pair of users. Once established, the connection
    is used to transfer SDUs. Connections usually provide one bidirectional stream
    supporting the exchange of SDUs between the two users that are associated through
    the connection. This stream is used to transfer data during the second phase of
    the connection called the data transfer phase. The third phase is the termination
    of the connection. Once the users have finished exchanging SDUs, they request
    the service provider to terminate the connection. As we will see later, there
    are also some cases where the service provider may need to terminate a connection
    itself.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 有连接服务调用分为三个阶段。第一阶段是建立连接。连接是通过服务提供商在两个用户之间建立的临时关联。在任何一对用户之间可能同时存在多个连接。一旦建立，连接就用于传输SDU。连接通常提供一条双向流，支持通过连接关联的两个用户之间的SDU交换。此流用于连接的第二阶段，即数据传输阶段。第三阶段是连接的终止。一旦用户完成交换SDU，他们就会请求服务提供商终止连接。正如我们稍后将会看到的，也有一些情况下服务提供商可能需要自己终止连接。
- en: 'The establishment of a connection can be modeled by using four primitives :
    Connect.request, Connect.indication, Connect.response and Connect.confirm. The
    Connect.request primitive is used to request the establishment of a connection.
    The main parameter of this primitive is the address of the destination user. The
    service provider delivers a Connect.indication primitive to inform the destination
    user of the connection attempt. If it accepts to establish a connection, it responds
    with a Connect.response primitive. At this point, the connection is considered
    to be established and the destination user can start sending SDUs over the connection.
    The service provider processes the Connect.response and will deliver a Connect.confirm
    to the user who initiated the connection. The delivery of this primitive terminates
    the connection establishment phase. At this point, the connection is considered
    to be open and both users can send SDUs. A successful connection establishment
    is illustrated below.'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的建立可以通过使用四个原语来建模：Connect.request、Connect.indication、Connect.response和Connect.confirm。Connect.request原语用于请求建立连接。此原语的主要参数是目标用户的地址。服务提供商将发送一个Connect.indication原语来通知目标用户连接尝试。如果它接受建立连接，则通过Connect.response原语进行响应。此时，连接被认为是建立的，目标用户可以开始通过连接发送SDU。服务提供商处理Connect.response并将Connect.confirm发送给发起连接的用户。此原语的发送标志着连接建立阶段的结束。此时，连接被认为是打开的，两个用户都可以发送SDU。以下是一个成功建立连接的示例。
- en: '![msc {'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: '}](../Images/12de7a0d5f3487e2a782a5860da72cff.png)<map id="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"
    name="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"></map>'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/12de7a0d5f3487e2a782a5860da72cff.png)<map id="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"
    name="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"></map>'
- en: The example above shows a successful connection establishment. However, in practice
    not all connections are successfully established. One reason is that the destination
    user may not agree, for policy or performance reasons, to establish a connection
    with the initiating user at this time. In this case, the destination user responds
    to the Connect.indication primitive by a Disconnect.request primitive that contains
    a parameter to indicate why the connection has been refused. The service provider
    will then deliver a Disconnect.indication primitive to inform the initiating user.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了成功建立连接的过程。然而，在实际操作中，并非所有连接都能成功建立。其中一个原因可能是目标用户可能因为策略或性能原因，不同意在此时刻与发起用户建立连接。在这种情况下，目标用户会通过一个包含表示连接被拒绝原因的参数的Disconnect.request原语来响应Connect.indication原语。服务提供商随后将发送一个Disconnect.indication原语来通知发起用户。
- en: '![msc {'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "DISCONNECT.req" ] ,
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.req" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.ind" ];
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.ind" ];
- en: '}](../Images/d7cf3fe0981d29ac305e476158ad3202.png)<map id="369bcd9afd00f0cea64705370c6107ffd854e9a1"
    name="369bcd9afd00f0cea64705370c6107ffd854e9a1"></map>'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/d7cf3fe0981d29ac305e476158ad3202.png)<map id="369bcd9afd00f0cea64705370c6107ffd854e9a1"
    name="369bcd9afd00f0cea64705370c6107ffd854e9a1"></map>'
- en: A second reason is when the service provider is unable to reach the destination
    user. This might happen because the destination user is not currently attached
    to the network or due to congestion. In these cases, the service provider responds
    to the Connect.request with a Disconnect.indication primitive whose reason parameter
    contains additional information about the failure of the connection.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是当服务提供商无法到达目标用户时。这可能是因为目标用户当前未连接到网络，或者由于拥塞。在这些情况下，服务提供商会对 Connect.request
    响应一个 Disconnect.indication 原语，其 reason 参数包含有关连接失败附加信息的额外信息。
- en: '![msc {'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b-x c [ label = "", arcskip="1"];
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "", arcskip="1"];
- en: c-x b [ label="",linecolour=white];
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: c-x b [ label="",linecolour=white];
- en: b=>a1 [ label = "DISCONNECT.ind" ];
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.ind" ];
- en: '}](../Images/a6977804391f666738b97b912ff2c561.png)<map id="32c26b073aab11b386a68ab9bd6f63a79402c97a"
    name="32c26b073aab11b386a68ab9bd6f63a79402c97a"></map>'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/a6977804391f666738b97b912ff2c561.png)<map id="32c26b073aab11b386a68ab9bd6f63a79402c97a"
    name="32c26b073aab11b386a68ab9bd6f63a79402c97a"></map>'
- en: Once the connection has been established, the service provider supplies two
    data streams to the communicating users. The first data stream can be used by
    the initiating user to send SDUs. The second data stream allows the responding
    user to send SDUs to the initiating user. The data streams can be organized in
    different ways. A first organization is the message-mode transfer. With the message-mode
    transfer, the service provider guarantees that one and only one Data.indication
    will be delivered to the endpoint of the data stream for each Data.request primitive
    issued by the other endpoint. The message-mode transfer is illustrated in the
    figure below. The main advantage of the message-transfer mode is that the recipient
    receives exactly the SDUs that were sent by the other user. If each SDU contains
    a command, the receiving user can process each command as soon as it receives
    a SDU.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，服务提供商向通信用户供应两个数据流。第一个数据流可以被发起用户用来发送 SDUs。第二个数据流允许响应用户向发起用户发送 SDUs。数据流可以以不同的方式组织。第一种组织方式是消息模式传输。在消息模式传输中，服务提供商保证对于其他端点发出的每个
    Data.request 原语，只向数据流端点传递一个且仅一个 Data.indication。消息模式传输在下图所示。消息传输模式的主要优点是接收者接收到的正是其他用户发送的
    SDUs。如果每个 SDU 包含一个命令，接收用户可以在接收到 SDU 后立即处理每个命令。
- en: '![msc {'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ] ,
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"BCD\")" ] ,
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"BCD\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"BCD\")" ];
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"BCD\")" ];
- en: a1=>b [ label = "DATA.req(\"EF\")" ] ,
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"EF\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"EF\")" ];
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"EF\")" ];
- en: '}](../Images/2592ed60d53be2396fda0643ecb35744.png)<map id="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"
    name="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"></map>'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/2592ed60d53be2396fda0643ecb35744.png)<map id="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"
    name="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"></map>'
- en: Unfortunately, the message-mode transfer is not widely used on the Internet.
    On the Internet, the most popular connection-oriented service transfers SDUs in
    stream-mode. With the stream-mode, the service provider supplies a byte stream
    that links the two communicating users. The sending user sends bytes by using
    Data.request primitives that contain sequences of bytes as SDUs. The service provider
    delivers SDUs containing consecutive bytes to the receiving user by using Data.indication
    primitives. The service provider ensures that all the bytes sent at one end of
    the stream are delivered correctly in the same order at the other endpoint. However,
    the service provider does not attempt to preserve the boundaries of the SDUs.
    There is no relation enforced by the service provider between the number of Data.request
    and the number of Data.indication primitives. The stream-mode is illustrated in
    the figure below. In practice, a consequence of the utilization of the stream-mode
    is that if the users want to exchange structured SDUs, they will need to provide
    the mechanisms that allow the receiving user to separate successive SDUs in the
    byte stream that it receives. Application layer protocols often use specific delimiters
    such as the end of line character to delineate SDUs in a bytestream.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，消息模式传输在互联网上并不常用。在互联网上，最流行的面向连接的服务以流模式传输SDU（服务数据单元）。使用流模式，服务提供商提供字节流，将两个通信用户连接起来。发送用户通过包含字节序列的SDU的Data.request原语发送字节。服务提供商通过使用Data.indication原语将包含连续字节的SDU传递给接收用户。服务提供商确保流一端发送的所有字节以相同的顺序正确地传递到流的另一端。然而，服务提供商并不试图保留SDU的边界。服务提供商之间没有强制执行与Data.request原语数量和Data.indication原语数量之间的关联。流模式在下图中展示。在实践中，流模式的使用导致的一个后果是，如果用户想要交换结构化的SDU，他们需要提供允许接收用户在接收到的字节流中分离连续SDU的机制。应用层协议通常使用特定的分隔符，如行结束字符，在字节流中划分SDU。
- en: '![msc {'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="服务提供商", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目标", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ label = "DATA.req(\"AB\")" ],
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"AB\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: c=>d1 [ label = "DATA.ind(\"B\")" ];
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"B\")" ];
- en: a1=>b [ label = "DATA.req(\"CD\")" ] ,
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"CD\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"C\")" ];
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"C\")" ];
- en: a1=>b [ label = "DATA.req(\"EF\")" ] ,
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"EF\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"DEF\")" ];
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"DEF\")" ];
- en: '}](../Images/2db37b2091c6c91af8c65803fadd75dc.png)<map id="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"
    name="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"></map>'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/2db37b2091c6c91af8c65803fadd75dc.png)<map id="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"
    name="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"></map>'
- en: The third phase of a connection is its release. As a connection involves three
    parties (two users and one service provider), any of them can request the termination
    of the connection. Usually, connections are terminated upon request of one user
    once the data transfer is finished. However, sometimes the service provider may
    be forced to terminate a connection. This can be due to lack of resources inside
    the service provider or because one of the users is not reachable anymore through
    the network. In this case, the service provider will issue Disconnect.indication
    primitives to both users. These primitives will contain, as parameter, some information
    about the reason for the termination of the connection. Unfortunately, as illustrated
    in the figure below, when a service provider is forced to terminate a connection
    it cannot guarantee that all SDUs sent by each user have been delivered to the
    other user. This connection release is said to be abrupt as it can cause losses
    of data.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的第三阶段是其释放。由于连接涉及三方（两个用户和一个服务提供商），任何一方都可以请求终止连接。通常，一旦数据传输完成，就会根据一方的请求终止连接。然而，有时服务提供商可能被迫终止连接。这可能是由于服务提供商内部资源不足，或者因为用户之一无法通过网络再被访问。在这种情况下，服务提供商将向两个用户发出
    Disconnect.indication 原语。这些原语将包含有关连接终止原因的一些信息作为参数。不幸的是，如图所示，当服务提供商被迫终止连接时，它不能保证每个用户发送的所有
    SDUs 都已传递给另一方。这种连接释放被称为突然释放，因为它可能导致数据丢失。
- en: '![msc {'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供商", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目标", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接建立" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ] ,
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ] ,
- en: b-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: b-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: c-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: b=>a1 [ linecolour=red, label = "DISCONNECT.ind" , textcolour=red] ,
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ linecolour=red, label = "DISCONNECT.ind" , textcolour=red] ,
- en: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
- en: '}](../Images/e332fc75c845caae3e5d76447bc8fb22.png)<map id="602fae060a80344e82486c9382e055244cc76a0a"
    name="602fae060a80344e82486c9382e055244cc76a0a"></map>'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/e332fc75c845caae3e5d76447bc8fb22.png)<map id="602fae060a80344e82486c9382e055244cc76a0a"
    name="602fae060a80344e82486c9382e055244cc76a0a"></map>'
- en: An abrupt connection release can also be triggered by one of the users. If a
    user needs, for any reason, to terminate a connection quickly, it can issue a
    Disconnect.request primitive and to request an abrupt release. The service provider
    will process the request, stop the two data streams and deliver the Disconnect.indication
    primitive to the remote user as soon as possible. As illustrated in the figure
    below, this abrupt connection release may cause losses of SDUs.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的突然释放也可能由用户之一触发。如果用户出于任何原因需要快速终止连接，它可以发出 Disconnect.request 原语并请求突然释放。服务提供商将处理请求，停止两个数据流，并尽快将
    Disconnect.indication 原语传递给远程用户。如图所示，这种突然的连接释放可能会导致 SDUs 的丢失。
- en: '![msc {'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供商", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目标", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接建立" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ] ,
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ] ,
- en: b-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: b-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: c-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: a1=>b [ linecolour=red, label = "DISCONNECT.req(abrupt)" , textcolour=red] ,
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=red, label = "DISCONNECT.req(abrupt)" , textcolour=red] ,
- en: b>>c [ label = "", arcskip="1",linecolour=red];
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1",linecolour=red];
- en: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
- en: '}](../Images/bcaa45e4382eb9e52c93458a974ea97e.png)<map id="94fa96cd54acf717988a49a90397299bf8cfd71d"
    name="94fa96cd54acf717988a49a90397299bf8cfd71d"></map>'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/bcaa45e4382eb9e52c93458a974ea97e.png)<map id="94fa96cd54acf717988a49a90397299bf8cfd71d"
    name="94fa96cd54acf717988a49a90397299bf8cfd71d"></map>'
- en: To ensure a reliable delivery of the SDUs sent by each user over a connection,
    we need to consider the two streams that compose a connection as independent.
    A user should be able to release the stream that it uses to send SDUs once it
    has sent all the SDUs that it planned to send over this connection, but still
    continue to receive SDUs over the opposite stream. This graceful connection release
    is usually performed as shown in the figure below. One user issues a Disconnect.request
    primitive to its provider once it has issued all its Data.request primitives.
    The service provider will wait until all Data.indication primitives have been
    delivered to the receiving user before issuing the Disconnnect.indication primitive.
    This primitive informs the receiving user that it will no longer receive SDUs
    over this connection, but it is still able to issue Data.request primitives on
    the stream in the opposite direction. Once the user has issued all of its Data.request
    primitives, it issues a Disconnnect.request primitive to request the termination
    of the remaining stream. The service provider will process the request and deliver
    the corresponding Disconnect.indication to the other user once it has delivered
    all the pending Data.indication primitives. At this point, all data has been delivered,
    the two streams have been released successfully and the connection is completely
    closed.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个用户通过连接发送的SDU（服务数据单元）的可靠交付，我们需要将构成连接的两个流视为独立的。一旦用户发送了它计划通过此连接发送的所有SDU，它应该能够释放它用来发送SDU的流，但仍然可以通过相反的流接收SDU。这种优雅的连接释放通常如图所示执行。一旦用户发出所有其Data.request原语，它就会向其提供者发出Disconnect.request原语。服务提供者将在发出Disconnect.indication原语之前等待所有Data.indication原语都已被发送到接收用户。此原语通知接收用户它将不再通过此连接接收SDU，但它仍然能够在相反方向的流上发出Data.request原语。一旦用户发出所有其Data.request原语，它就会发出Disconnect.request原语以请求终止剩余的流。服务提供者将在发送所有挂起的Data.indication原语后处理请求并向另一个用户发送相应的Disconnect.indication。此时，所有数据都已发送，两个流已成功释放，连接已完全关闭。
- en: '![msc {'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源端", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white];
- en: c [label="Destination", linecolour=black],
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的端", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ],
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"B\")" ];
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"B\")" ];
- en: a1=>b [ label = "DISCONNECT.req(graceful)",textcolour=red, linecolour=red ],
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.req(graceful)",textcolour=red, linecolour=red ],
- en: b>>c [ label = "", arcskip="1", linecolour=red];
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1", linecolour=red];
- en: c=>d1 [ label = "DISCONNECT.ind(graceful)",linecolour=red, textcolour=red ];
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.ind(graceful)",linecolour=red, textcolour=red ];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [label = "DATA.ind(\"C\")" ];
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [label = "DATA.ind(\"C\")" ];
- en: d1=>c [ label = "DISCONNECT.req(graceful)", textcolour=blue, linecolour=blue
    ] ,
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.req(graceful)", textcolour=blue, linecolour=blue
    ] ,
- en: c>>b [ label = "", arcskip="1", linecolour=blue];
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1", linecolour=blue];
- en: b=>a1 [label = "DISCONNECT.ind(graceful)" ];
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [label = "DISCONNECT.ind(graceful)" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ] ,
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接\n关闭" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ];
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接\n关闭" ];
- en: '}](../Images/93d7ca8af6d44432fde8748dc0e2f7d9.png)<map id="cfd142d18c7142e539c0384b6fcc308356449d2c"
    name="cfd142d18c7142e539c0384b6fcc308356449d2c"></map>'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/93d7ca8af6d44432fde8748dc0e2f7d9.png)<map id="cfd142d18c7142e539c0384b6fcc308356449d2c"
    name="cfd142d18c7142e539c0384b6fcc308356449d2c"></map>'
- en: Note
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reliability of the connection-oriented service
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 面向连接服务的可靠性
- en: An important point to note about the connection-oriented service is its reliability.
    A connection-oriented service can only guarantee the correct delivery of all SDUs
    provided that the connection has been released gracefully. This implies that while
    the connection is active, there is no guarantee for the actual delivery of the
    SDUs exchanged as the connection may need to be abruptly released at any time.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 关于面向连接服务的一个重要观点是其可靠性。面向连接的服务只能保证在连接优雅释放的情况下，正确地交付所有SDU。这意味着在连接活跃期间，由于连接可能随时需要被突然释放，因此无法保证交换的SDU的实际交付。
- en: The second transport service is the connection-oriented service. On the Internet,
    this service is often called the byte-stream service as it creates a reliable
    byte stream between the two applications that are linked by a transport connection.
    Like the datagram service, the networked applications that use the byte-stream
    service are identified by the host on which they run and a port number. These
    hosts can be identified by an address or a name. [Fig. 13](#fig-co-transport)
    illustrates two applications that are using the byte-stream service provided by
    the TCP protocol on IPv6 hosts. The byte-stream service provided by TCP is reliable
    and bidirectional.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个传输服务是面向连接的服务。在互联网上，这种服务通常被称为字节流服务，因为它在通过传输连接连接的两个应用程序之间创建了一个可靠的字节流。像数据报服务一样，使用字节流服务的网络应用程序由它们运行的主机和端口号标识。这些主机可以通过地址或名称来识别。[图13](#fig-co-transport)说明了两个正在使用IPv6主机上由TCP协议提供的字节流服务的应用程序。TCP提供的字节流服务是可靠且双向的。
- en: '![Figure made with TikZ](../Images/22d0b3ec409b5e6fa95368ee887a0af6.png)'
  id: totrans-1537
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/22d0b3ec409b5e6fa95368ee887a0af6.png)'
- en: ''
  id: totrans-1538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 13 The connection-oriented or byte-stream service
  id: totrans-1539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图13 面向连接或字节流服务
- en: '### The request-response service[#](#the-request-response-service "Link to
    this heading")'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '### 请求-响应服务[#](#the-request-response-service "链接到本标题")'
- en: The request-response service is a compromise between the connectionless service
    and the connection-oriented service. Many applications need to send a small amount
    of data and receive a small amount of information back. This is similar to procedure
    calls in programming languages. A call to a procedure takes a few arguments and
    returns a simple answer. In a network, it is sometimes useful to execute a procedure
    on a different host and receive the result of the computation. Executing a procedure
    on another host is often called Remote Procedure Call. It is possible to use the
    connectionless service for this application. However, since this service is usually
    unreliable, this would force the application to deal with any type of error that
    could occur. Using the connection oriented service is another alternative. This
    service ensures the reliable delivery of the data, but a connection must be created
    before the beginning of the data transfer. This overhead can be important for
    applications that only exchange a small amount of data.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应服务是在无连接服务和面向连接的服务之间的一种折衷方案。许多应用程序需要发送少量数据并接收少量信息反馈。这类似于编程语言中的过程调用。对过程的调用需要几个参数并返回一个简单的答案。在网络中，有时在另一个主机上执行一个过程并接收计算结果是有用的。在另一个主机上执行过程通常被称为远程过程调用。对于这种应用，可以使用无连接服务。然而，由于这种服务通常不可靠，这会迫使应用程序处理可能发生的任何类型的错误。使用面向连接的服务是另一种选择。这种服务确保数据的可靠传输，但在数据传输开始之前必须创建连接。对于仅交换少量数据的应用程序来说，这种开销可能很重要。
- en: The request-response service allows to efficiently exchange small amounts of
    information in a request and associate it with the corresponding response. This
    service can be depicted by using the time-sequence diagram below.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应服务允许在请求中高效地交换少量信息，并将其与相应的响应关联。此服务可以通过下面的时序图来表示。
- en: '![msc {'
  id: totrans-1543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-1545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="Service", linecolour=white],
  id: totrans-1546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="服务", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-1547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(request)" ] ,
  id: totrans-1550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(request)" ] ,
- en: b>>c [ arcskip="1"];
  id: totrans-1551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1"];
- en: c=>d [ label = "DATA.ind(request)" ];
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(request)" ];
- en: ''
  id: totrans-1553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "DATA.resp(response)" ] ,
  id: totrans-1554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "DATA.resp(response)" ] ,
- en: c>>b [ arcskip="1"];
  id: totrans-1555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a [ label = "DATA.confirm(response)" ];
  id: totrans-1556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "DATA.confirm(response)" ];
- en: '}](../Images/414d09372f22c44dc624c0b21cae0fdc.png)<map id="62a300927dbe4ad95b0ccdb1df72b080f57955e7"
    name="62a300927dbe4ad95b0ccdb1df72b080f57955e7"></map>'
  id: totrans-1557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/414d09372f22c44dc624c0b21cae0fdc.png)<map id="62a300927dbe4ad95b0ccdb1df72b080f57955e7"
    name="62a300927dbe4ad95b0ccdb1df72b080f57955e7"></map>'
- en: Note
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Services and layers
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和层
- en: In the previous sections, we have described services that are provided by the
    transport layer. However, it is important to note that the notion of service is
    more general than in the transport layer. As explained earlier, the network layer
    also provides a service, which in most networks is an unreliable connectionless
    service. There are network layers that provide a connection-oriented service.
    Similarly, the datalink layer also provides services. Some datalink layers will
    provide a connectionless service. This will be the case in Local Area Networks
    for examples. Other datalink layers, e.g. in public networks, provide a connection
    oriented service.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了传输层提供的服务。然而，需要注意的是，服务的概念比传输层更广泛。如前所述，网络层也提供了一种服务，在大多数网络中这是一种不可靠的无连接服务。有些网络层提供面向连接的服务。同样，数据链路层也提供服务。有些数据链路层将提供无连接服务。例如，在局域网中就是这样。其他数据链路层，例如在公共网络中，提供面向连接的服务。
- en: The connectionless transport service[#](#the-connectionless-transport-service
    "Link to this heading")
  id: totrans-1561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接传输服务[#](#the-connectionless-transport-service "链接到本标题")
- en: The connectionless service allows applications to easily exchange messages or
    Service Data Units. On the Internet, this service is provided by the UDP protocol
    that will be explained in the next chapter. The connectionless transport service
    on the Internet is unreliable, but is able to detect transmission errors. This
    implies that an application will not receive data that has been corrupted due
    to transmission errors.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务允许应用程序轻松交换消息或服务数据单元。在互联网上，此服务由UDP协议提供，将在下一章中解释。互联网上的无连接传输服务是不可靠的，但能够检测传输错误。这意味着应用程序不会接收到由于传输错误而损坏的数据。
- en: The figure below provides a representation of the connectionless service as
    a time-sequence diagram. The user on the left, having address S, issues a Data.request
    primitive containing Service Data Unit (SDU) M that must be delivered by the service
    provider to destination D. The dashed line between the two primitives indicates
    that the Data.indication primitive that is delivered to the user on the right
    corresponds to the Data.request primitive sent by the user on the left.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图提供了无连接服务作为时序图的表示。左侧的用户，地址为S，发出包含服务数据单元（SDU）M的数据请求原语，该数据单元必须由服务提供商交付到目的地D。两个原语之间的虚线表示，发送给右侧用户的Data.indication原语对应于左侧用户发送的Data.request原语。
- en: '![msc {'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: '}](../Images/4ee9488e106e721d3505acd29c04b209.png)<map id="fb2f6d7c49baf50b586f9dcecd634d2500634932"
    name="fb2f6d7c49baf50b586f9dcecd634d2500634932"></map>'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/4ee9488e106e721d3505acd29c04b209.png)<map id="fb2f6d7c49baf50b586f9dcecd634d2500634932"
    name="fb2f6d7c49baf50b586f9dcecd634d2500634932"></map>'
- en: There are several possible implementations of the connectionless service. Before
    studying these realizations, it is useful to discuss the possible characteristics
    of the connectionless service. A reliable connectionless service is a service
    where the service provider guarantees that all SDUs submitted in Data.requests
    by a user will eventually be delivered to their destination. Such a service would
    be very useful for users, but guaranteeing perfect delivery is difficult in practice.
    For this reason, network layers usually support an unreliable connectionless service.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究这些实现之前，讨论无连接服务的可能特性是有用的。一个可靠的无连接服务是一种服务，服务提供商保证用户通过Data.requests提交的所有SDU最终将被交付到目的地。这种服务对用户非常有用，但在实践中保证完美的交付是困难的。因此，网络层通常支持不可靠的无连接服务。
- en: An unreliable connectionless service may suffer from various types of problems
    compared to a reliable connectionless service. First of all, an unreliable connectionless
    service does not guarantee the delivery of all SDUs. This can be expressed graphically
    by using the time-sequence diagram below.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 与可靠的无连接服务相比，不可靠的无连接服务可能会遇到各种类型的问题。首先，不可靠的无连接服务不能保证所有SDU的交付。这可以通过下述时间序列图来图形化表示。
- en: '![msc {'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b-x c [ label = "D(b)", arcskip="2", linecolour=red];
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "D(b)", arcskip="2", linecolour=red];
- en: c=>d1 [ label = "",linecolour=white ];
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "",linecolour=white ];
- en: '}](../Images/177cb46396d45f08e9d7545e3154e18b.png)<map id="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"
    name="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"></map>'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/177cb46396d45f08e9d7545e3154e18b.png)<map id="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"
    name="03ca33f4f70fd8299f9307aa2d4ae72236f90ec0"></map>'
- en: In practice, an unreliable connectionless service will usually deliver a large
    fraction of the SDUs. However, since the delivery of SDUs is not guaranteed, the
    user must be able to recover from the loss of any SDU.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，不可靠的无连接服务通常会交付大部分SDU。然而，由于SDU的交付不能保证，用户必须能够从任何SDU的丢失中恢复。
- en: A second imperfection that may affect an unreliable connectionless service is
    that it may duplicate SDUs. Some packets may be duplicated in a network and be
    delivered twice to their destination. This is illustrated by the time-sequence
    diagram below.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响不可靠的无连接服务的不完美之处是它可能会重复SDU。一些数据包可能在网络中被重复，并两次发送到目的地。下述时间序列图说明了这一点。
- en: '![msc {'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="", linecolour=white],
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"M\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: z>>c [ label = "", arcskip="1"];
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: z>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(S,D,\"M\")" ];
- en: '}](../Images/f44769bd9ed127c07d494406222a612b.png)<map id="2f24c3b302431a9d40faf6d0285b9a55a8750107"
    name="2f24c3b302431a9d40faf6d0285b9a55a8750107"></map>'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/f44769bd9ed127c07d494406222a612b.png)<map id="2f24c3b302431a9d40faf6d0285b9a55a8750107"
    name="2f24c3b302431a9d40faf6d0285b9a55a8750107"></map>'
- en: Finally, some unreliable connectionless service providers may deliver to a destination
    a different SDU than the one that was supplied in the Data.request. This is illustrated
    in the figure below.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些不可靠的无连接服务提供商可能会向目的地发送与在Data.request中提供的不同的SDU。这在下图中有说明。
- en: '![msc {'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black].
- en: z [label="", linecolour=white],
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "DATA.req(S,D,\"abc\")" ] ,
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(S,D,\"abc\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(S,D,\"xyz\")" ];
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 'c=>d1 [标签 = "DATA.ind(S,D,\"xyz\")"]; '
- en: '}](../Images/d960a02633797ef9170e30439eb112b8.png)<map id="53723b9136cdd91e2719e677046eea6f2bef054a"
    name="53723b9136cdd91e2719e677046eea6f2bef054a"></map>'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/d960a02633797ef9170e30439eb112b8.png)<map id="53723b9136cdd91e2719e677046eea6f2bef054a"
    name="53723b9136cdd91e2719e677046eea6f2bef054a"></map>'
- en: 'The connectionless transport service allows networked application to exchange
    messages. Several networked applications may be running at the same time on a
    single host. Each of these applications must be able to exchange SDUs with remote
    applications. To enable these exchanges of SDUs, each networked application running
    on a host is identified by the following information :'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接传输服务允许网络应用程序交换消息。单个主机上可能同时运行多个网络应用程序。这些应用程序中的每一个都必须能够与远程应用程序交换SDU。为了实现这些SDU的交换，运行在主机上的每个网络应用程序都通过以下信息进行标识：
- en: the host on which the application is running
  id: totrans-1620
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序的主机
- en: ''
  id: totrans-1621
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1622
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the port number on which the application listens for data
  id: totrans-1623
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序监听数据所在的端口号
- en: On the Internet, the port number is an integer and the host is identified by
    its IPv4 or IPv6 address. A host that only has an IPv4 address cannot communicate
    with a host having only an IPv6 address. [Fig. 12](#fig-cl-transport) illustrates
    two applications that are using the datagram service provided by UDP on hosts
    that are using IPv4 addresses.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，端口号是一个整数，主机通过其IPv4或IPv6地址进行标识。仅具有IPv4地址的主机无法与仅具有IPv6地址的主机通信。[图12](#fig-cl-transport)说明了两个应用程序正在使用IPv4地址的主机上由UDP提供的数据报服务。
- en: '![Figure made with TikZ](../Images/e68e29111fe44956f2f9dce525d7fea5.png)'
  id: totrans-1625
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/e68e29111fe44956f2f9dce525d7fea5.png)'
- en: ''
  id: totrans-1626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 12 The connectionless or datagram service
  id: totrans-1627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图12 无连接或数据报服务
- en: The connection-oriented transport service[#](#the-connection-oriented-transport-service
    "Link to this heading")
  id: totrans-1628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接型传输服务[#](#the-connection-oriented-transport-service "链接到本标题")
- en: An invocation of the connection-oriented service is divided into three phases.
    The first phase is the establishment of a connection. A connection is a temporary
    association between two users through a service provider. Several connections
    may exist at the same time between any pair of users. Once established, the connection
    is used to transfer SDUs. Connections usually provide one bidirectional stream
    supporting the exchange of SDUs between the two users that are associated through
    the connection. This stream is used to transfer data during the second phase of
    the connection called the data transfer phase. The third phase is the termination
    of the connection. Once the users have finished exchanging SDUs, they request
    the service provider to terminate the connection. As we will see later, there
    are also some cases where the service provider may need to terminate a connection
    itself.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 连接型服务的调用分为三个阶段。第一阶段是建立连接。连接是通过服务提供商在两个用户之间建立的一个临时关联。在任何一对用户之间可能同时存在多个连接。一旦建立，连接就用于传输SDU。连接通常提供一条双向流，支持通过连接关联的两个用户之间SDU的交换。此流用于连接的第二阶段，即数据传输阶段。第三阶段是连接的终止。一旦用户完成交换SDU，他们就会请求服务提供商终止连接。正如我们稍后将会看到的，也有一些情况下服务提供商可能需要自己终止连接。
- en: 'The establishment of a connection can be modeled by using four primitives :
    Connect.request, Connect.indication, Connect.response and Connect.confirm. The
    Connect.request primitive is used to request the establishment of a connection.
    The main parameter of this primitive is the address of the destination user. The
    service provider delivers a Connect.indication primitive to inform the destination
    user of the connection attempt. If it accepts to establish a connection, it responds
    with a Connect.response primitive. At this point, the connection is considered
    to be established and the destination user can start sending SDUs over the connection.
    The service provider processes the Connect.response and will deliver a Connect.confirm
    to the user who initiated the connection. The delivery of this primitive terminates
    the connection establishment phase. At this point, the connection is considered
    to be open and both users can send SDUs. A successful connection establishment
    is illustrated below.'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接可以通过使用四个原语来建模：Connect.request、Connect.indication、Connect.response 和 Connect.confirm。Connect.request
    原语用于请求建立连接。此原语的主要参数是目标用户的地址。服务提供商将 Connect.indication 原语传递给目标用户，以通知其连接尝试。如果目标用户同意建立连接，则通过
    Connect.response 原语进行响应。此时，连接被认为是建立的，并且目标用户可以开始通过连接发送 SDU。服务提供商处理 Connect.response
    并将 Connect.confirm 传递给发起连接的用户。此原语的传递终止了连接建立阶段。此时，连接被认为是打开的，并且两个用户都可以发送 SDU。以下是一个成功的连接建立的示例。
- en: '![msc {'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目标", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: '}](../Images/12de7a0d5f3487e2a782a5860da72cff.png)<map id="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"
    name="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"></map>'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/12de7a0d5f3487e2a782a5860da72cff.png)<map id="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"
    name="4626a1480049f8bf0a651e3ab8bd1768a8c43e15"></map>'
- en: The example above shows a successful connection establishment. However, in practice
    not all connections are successfully established. One reason is that the destination
    user may not agree, for policy or performance reasons, to establish a connection
    with the initiating user at this time. In this case, the destination user responds
    to the Connect.indication primitive by a Disconnect.request primitive that contains
    a parameter to indicate why the connection has been refused. The service provider
    will then deliver a Disconnect.indication primitive to inform the initiating user.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例显示了一个成功的连接建立。然而，在实践中，并非所有连接都能成功建立。一个原因是目标用户可能不同意，出于策略或性能原因，在此时刻与发起用户建立连接。在这种情况下，目标用户通过包含表示连接被拒绝原因的参数的
    Disconnect.request 原语来响应 Connect.indication 原语。然后，服务提供商将 Disconnect.indication
    原语传递给发起用户。
- en: '![msc {'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目标", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "DISCONNECT.req" ] ,
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.req" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "DISCONNECT.ind" ];
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.ind" ];
- en: '}](../Images/d7cf3fe0981d29ac305e476158ad3202.png)<map id="369bcd9afd00f0cea64705370c6107ffd854e9a1"
    name="369bcd9afd00f0cea64705370c6107ffd854e9a1"></map>'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/d7cf3fe0981d29ac305e476158ad3202.png)<map id="369bcd9afd00f0cea64705370c6107ffd854e9a1"
    name="369bcd9afd00f0cea64705370c6107ffd854e9a1"></map>'
- en: A second reason is when the service provider is unable to reach the destination
    user. This might happen because the destination user is not currently attached
    to the network or due to congestion. In these cases, the service provider responds
    to the Connect.request with a Disconnect.indication primitive whose reason parameter
    contains additional information about the failure of the connection.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是当服务提供商无法到达目标用户时。这可能是因为目标用户当前未连接到网络，或者由于拥塞。在这些情况下，服务提供商会对连接请求（Connect.request）响应一个断开连接指示（Disconnect.indication）原语，其理由参数包含有关连接失败附加信息的额外信息。
- en: '![msc {'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b-x c [ label = "", arcskip="1"];
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: b-x c [ label = "", arcskip="1"];
- en: c-x b [ label="",linecolour=white];
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: c-x b [ label="",linecolour=white];
- en: b=>a1 [ label = "DISCONNECT.ind" ];
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "DISCONNECT.ind" ];
- en: '}](../Images/a6977804391f666738b97b912ff2c561.png)<map id="32c26b073aab11b386a68ab9bd6f63a79402c97a"
    name="32c26b073aab11b386a68ab9bd6f63a79402c97a"></map>'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/a6977804391f666738b97b912ff2c561.png)<map id="32c26b073aab11b386a68ab9bd6f63a79402c97a"
    name="32c26b073aab11b386a68ab9bd6f63a79402c97a"></map>'
- en: Once the connection has been established, the service provider supplies two
    data streams to the communicating users. The first data stream can be used by
    the initiating user to send SDUs. The second data stream allows the responding
    user to send SDUs to the initiating user. The data streams can be organized in
    different ways. A first organization is the message-mode transfer. With the message-mode
    transfer, the service provider guarantees that one and only one Data.indication
    will be delivered to the endpoint of the data stream for each Data.request primitive
    issued by the other endpoint. The message-mode transfer is illustrated in the
    figure below. The main advantage of the message-transfer mode is that the recipient
    receives exactly the SDUs that were sent by the other user. If each SDU contains
    a command, the receiving user can process each command as soon as it receives
    a SDU.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，服务提供商向通信用户供应两个数据流。第一个数据流可以被发起用户用来发送SDU。第二个数据流允许响应用户向发起用户发送SDU。数据流可以以不同的方式组织。第一种组织方式是消息模式传输。在消息模式传输中，服务提供商保证对于其他端点发出的每个数据请求（Data.request）原语，只向数据流端点传递一个且仅一个数据指示（Data.indication）。消息模式传输在下图所示。消息传输模式的主要优点是接收者接收到的SDU正好是其他用户发送的SDU。如果每个SDU包含一个命令，接收用户可以在接收到SDU后立即处理每个命令。
- en: '![msc {'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ] ,
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"BCD\")" ] ,
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"BCD\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"BCD\")" ];
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"BCD\")" ];
- en: a1=>b [ label = "DATA.req(\"EF\")" ] ,
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"EF\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"EF\")" ];
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"EF\")" ];
- en: '}](../Images/2592ed60d53be2396fda0643ecb35744.png)<map id="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"
    name="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"></map>'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/2592ed60d53be2396fda0643ecb35744.png)<map id="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"
    name="d88be1ea545a8c7b5ca3c83c66f6fbf3da2e32ba"></map>'
- en: Unfortunately, the message-mode transfer is not widely used on the Internet.
    On the Internet, the most popular connection-oriented service transfers SDUs in
    stream-mode. With the stream-mode, the service provider supplies a byte stream
    that links the two communicating users. The sending user sends bytes by using
    Data.request primitives that contain sequences of bytes as SDUs. The service provider
    delivers SDUs containing consecutive bytes to the receiving user by using Data.indication
    primitives. The service provider ensures that all the bytes sent at one end of
    the stream are delivered correctly in the same order at the other endpoint. However,
    the service provider does not attempt to preserve the boundaries of the SDUs.
    There is no relation enforced by the service provider between the number of Data.request
    and the number of Data.indication primitives. The stream-mode is illustrated in
    the figure below. In practice, a consequence of the utilization of the stream-mode
    is that if the users want to exchange structured SDUs, they will need to provide
    the mechanisms that allow the receiving user to separate successive SDUs in the
    byte stream that it receives. Application layer protocols often use specific delimiters
    such as the end of line character to delineate SDUs in a bytestream.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，消息模式传输在互联网上并不常用。在互联网上，最流行的面向连接的服务以流模式传输SDU。使用流模式，服务提供商提供一个字节流，将两个通信用户连接起来。发送用户通过包含字节序列的SDU作为原始数据请求来发送字节。服务提供商通过使用数据指示原始数据将包含连续字节的SDU传递给接收用户。服务提供商确保流一端发送的所有字节以相同的顺序正确地传递到流的另一端。然而，服务提供商并不试图保留SDU的边界。服务提供商之间没有强制执行与数据请求和数据指示原始数据数量之间的关系。流模式在下图中说明。实际上，流模式的使用导致的一个后果是，如果用户想要交换结构化的SDU，他们需要提供允许接收用户在接收到的字节流中分离连续SDU的机制。应用层协议通常使用特定的分隔符，如行结束字符，在字节流中划分SDU。
- en: '![msc {'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ label = "CONNECT.req" ] ,
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "CONNECT.req" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "CONNECT.ind" ];
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "CONNECT.ind" ];
- en: d1=>c [ label = "CONNECT.resp" ] ,
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "CONNECT.resp" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [ label = "CONNECT.conf" ];
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ label = "CONNECT.conf" ];
- en: a1=>b [ label = "DATA.req(\"AB\")" ],
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"AB\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: c=>d1 [ label = "DATA.ind(\"B\")" ];
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"B\")" ];
- en: a1=>b [ label = "DATA.req(\"CD\")" ] ,
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"CD\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"C\")" ];
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"C\")" ];
- en: a1=>b [ label = "DATA.req(\"EF\")" ] ,
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"EF\")" ] ,
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"DEF\")" ];
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"DEF\")" ];
- en: '}](../Images/2db37b2091c6c91af8c65803fadd75dc.png)<map id="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"
    name="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"></map>'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/2db37b2091c6c91af8c65803fadd75dc.png)<map id="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"
    name="cd309eabf7a0e1bff40fc40983475e8c2155c5ed"></map>'
- en: The third phase of a connection is its release. As a connection involves three
    parties (two users and one service provider), any of them can request the termination
    of the connection. Usually, connections are terminated upon request of one user
    once the data transfer is finished. However, sometimes the service provider may
    be forced to terminate a connection. This can be due to lack of resources inside
    the service provider or because one of the users is not reachable anymore through
    the network. In this case, the service provider will issue Disconnect.indication
    primitives to both users. These primitives will contain, as parameter, some information
    about the reason for the termination of the connection. Unfortunately, as illustrated
    in the figure below, when a service provider is forced to terminate a connection
    it cannot guarantee that all SDUs sent by each user have been delivered to the
    other user. This connection release is said to be abrupt as it can cause losses
    of data.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的第三阶段是其释放。由于连接涉及三方（两个用户和一个服务提供商），任何一方都可以请求终止连接。通常，数据传输完成后，一旦用户请求，就会终止连接。然而，有时服务提供商可能被迫终止连接。这可能是因为服务提供商内部资源不足，或者因为用户无法通过网络再访问。在这种情况下，服务提供商将向两个用户发出
    Disconnect.indication 原语。这些原语将包含有关连接终止原因的一些信息。不幸的是，如图所示，当服务提供商被迫终止连接时，它不能保证每个用户发送的所有
    SDU 都已传递给另一个用户。这种连接释放被称为突然释放，因为它可能导致数据丢失。
- en: '![msc {'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接建立" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ] ,
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ] ,
- en: b-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: b-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: c-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: b=>a1 [ linecolour=red, label = "DISCONNECT.ind" , textcolour=red] ,
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [ linecolour=red, label = "DISCONNECT.ind" , textcolour=red] ,
- en: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
- en: '}](../Images/e332fc75c845caae3e5d76447bc8fb22.png)<map id="602fae060a80344e82486c9382e055244cc76a0a"
    name="602fae060a80344e82486c9382e055244cc76a0a"></map>'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/e332fc75c845caae3e5d76447bc8fb22.png)<map id="602fae060a80344e82486c9382e055244cc76a0a"
    name="602fae060a80344e82486c9382e055244cc76a0a"></map>'
- en: An abrupt connection release can also be triggered by one of the users. If a
    user needs, for any reason, to terminate a connection quickly, it can issue a
    Disconnect.request primitive and to request an abrupt release. The service provider
    will process the request, stop the two data streams and deliver the Disconnect.indication
    primitive to the remote user as soon as possible. As illustrated in the figure
    below, this abrupt connection release may cause losses of SDUs.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户需要，出于任何原因，快速终止连接，可以发出 Disconnect.request 原语并请求突然释放。服务提供商将处理请求，停止两个数据流，并尽快将
    Disconnect.indication 原语传递给远程用户。如图所示，这种突然的连接释放可能会导致 SDU 的丢失。
- en: '![msc {'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="源", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="提供者", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="目的地", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "连接建立" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "连接建立" ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ] ,
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ] ,
- en: b-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: b-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c-x z [ label = "", arcskip="1", linecolour=red];
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: c-x z [ label = "", arcskip="1", linecolour=red];
- en: a1=>b [ label = "", linecolour=white];
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "", linecolour=white];
- en: a1=>b [ linecolour=red, label = "DISCONNECT.req(abrupt)" , textcolour=red] ,
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=red, label = "DISCONNECT.req(abrupt)" , textcolour=red] ,
- en: b>>c [ label = "", arcskip="1",linecolour=red];
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1",linecolour=red];
- en: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=red, label = "DISCONNECT.ind", textcolour=red ];
- en: '}](../Images/bcaa45e4382eb9e52c93458a974ea97e.png)<map id="94fa96cd54acf717988a49a90397299bf8cfd71d"
    name="94fa96cd54acf717988a49a90397299bf8cfd71d"></map>'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/bcaa45e4382eb9e52c93458a974ea97e.png)<map id="94fa96cd54acf717988a49a90397299bf8cfd71d"
    name="94fa96cd54acf717988a49a90397299bf8cfd71d"></map>'
- en: To ensure a reliable delivery of the SDUs sent by each user over a connection,
    we need to consider the two streams that compose a connection as independent.
    A user should be able to release the stream that it uses to send SDUs once it
    has sent all the SDUs that it planned to send over this connection, but still
    continue to receive SDUs over the opposite stream. This graceful connection release
    is usually performed as shown in the figure below. One user issues a Disconnect.request
    primitive to its provider once it has issued all its Data.request primitives.
    The service provider will wait until all Data.indication primitives have been
    delivered to the receiving user before issuing the Disconnnect.indication primitive.
    This primitive informs the receiving user that it will no longer receive SDUs
    over this connection, but it is still able to issue Data.request primitives on
    the stream in the opposite direction. Once the user has issued all of its Data.request
    primitives, it issues a Disconnnect.request primitive to request the termination
    of the remaining stream. The service provider will process the request and deliver
    the corresponding Disconnect.indication to the other user once it has delivered
    all the pending Data.indication primitives. At this point, all data has been delivered,
    the two streams have been released successfully and the connection is completely
    closed.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个用户通过连接发送的SDU（服务数据单元）的可靠交付，我们需要将构成连接的两个流视为独立的。一旦用户发送了它计划通过此连接发送的所有SDU，它应该能够释放它用于发送SDU的流，但仍然可以通过相反的流接收SDU。这种优雅的连接释放通常如图所示执行。一旦用户发出所有其Data.request原语，它就会向其提供者发出Disconnect.request原语。服务提供者将在发出Disconnect.indication原语之前等待所有Data.indication原语都已被发送到接收用户。此原语通知接收用户它将不再通过此连接接收SDU，但它仍然能够在相反方向的流上发出Data.request原语。一旦用户发出所有其Data.request原语，它就会发出Disconnect.request原语以请求终止剩余的流。服务提供者将在发送所有挂起的Data.indication原语后处理请求并向另一个用户发送相应的Disconnect.indication。此时，所有数据都已交付，两个流已成功释放，连接已完全关闭。
- en: '![msc {'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a1 [label="", linecolour=white],
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: a1 [label="", linecolour=white],
- en: a [label="", linecolour=white],
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Source", linecolour=black],
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: b [label="Source", linecolour=black],
- en: z [label="Provider", linecolour=white],
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: z [label="Provider", linecolour=white],
- en: c [label="Destination", linecolour=black],
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: c [label="Destination", linecolour=black],
- en: d [label="", linecolour=white],
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white],
- en: d1 [label="", linecolour=white];
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: d1 [label="", linecolour=white];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nestablished"
    ];
- en: a1=>b [ label = "DATA.req(\"A\")" ],
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"A\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"A\")" ];
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"A\")" ];
- en: a1=>b [ label = "DATA.req(\"B\")" ],
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DATA.req(\"B\")" ],
- en: b>>c [ label = "", arcskip="1"];
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1"];
- en: c=>d1 [ label = "DATA.ind(\"B\")" ];
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DATA.ind(\"B\")" ];
- en: a1=>b [ label = "DISCONNECT.req(graceful)",textcolour=red, linecolour=red ],
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ label = "DISCONNECT.req(graceful)",textcolour=red, linecolour=red ];
- en: b>>c [ label = "", arcskip="1", linecolour=red];
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: b>>c [ label = "", arcskip="1", linecolour=red];
- en: c=>d1 [ label = "DISCONNECT.ind(graceful)",linecolour=red, textcolour=red ];
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ label = "DISCONNECT.ind(graceful)",linecolour=red, textcolour=red ];
- en: d1=>c [ label = "DATA.req(\"C\")" ] ,
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DATA.req(\"C\")" ] ,
- en: c>>b [ label = "", arcskip="1"];
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1"];
- en: b=>a1 [label = "DATA.ind(\"C\")" ];
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [label = "DATA.ind(\"C\")" ];
- en: d1=>c [ label = "DISCONNECT.req(graceful)", textcolour=blue, linecolour=blue
    ] ,
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: d1=>c [ label = "DISCONNECT.req(graceful)", textcolour=blue, linecolour=blue
    ] ,
- en: c>>b [ label = "", arcskip="1", linecolour=blue];
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: c>>b [ label = "", arcskip="1", linecolour=blue];
- en: b=>a1 [label = "DISCONNECT.ind(graceful)" ];
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: b=>a1 [label = "DISCONNECT.ind(graceful)" ];
- en: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ] ,
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: a1=>b [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ] ,
- en: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ];
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: c=>d1 [ linecolour=white, textcolour=blue, label = "Connection\nclosed" ];
- en: '}](../Images/93d7ca8af6d44432fde8748dc0e2f7d9.png)<map id="cfd142d18c7142e539c0384b6fcc308356449d2c"
    name="cfd142d18c7142e539c0384b6fcc308356449d2c"></map>'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: '}](../Images/93d7ca8af6d44432fde8748dc0e2f7d9.png)<map id="cfd142d18c7142e539c0384b6fcc308356449d2c"
    name="cfd142d18c7142e539c0384b6fcc308356449d2c"></map>'
- en: Note
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Reliability of the connection-oriented service
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 面向连接服务的可靠性
- en: An important point to note about the connection-oriented service is its reliability.
    A connection-oriented service can only guarantee the correct delivery of all SDUs
    provided that the connection has been released gracefully. This implies that while
    the connection is active, there is no guarantee for the actual delivery of the
    SDUs exchanged as the connection may need to be abruptly released at any time.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 关于面向连接服务的一个重要观点是其可靠性。面向连接的服务只能保证在连接优雅地释放的情况下，所有 SDU 的正确交付。这意味着在连接活动期间，没有保证交换的
    SDU 的实际交付，因为连接可能需要随时突然释放。
- en: The second transport service is the connection-oriented service. On the Internet,
    this service is often called the byte-stream service as it creates a reliable
    byte stream between the two applications that are linked by a transport connection.
    Like the datagram service, the networked applications that use the byte-stream
    service are identified by the host on which they run and a port number. These
    hosts can be identified by an address or a name. [Fig. 13](#fig-co-transport)
    illustrates two applications that are using the byte-stream service provided by
    the TCP protocol on IPv6 hosts. The byte-stream service provided by TCP is reliable
    and bidirectional.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个传输服务是面向连接的服务。在互联网上，这种服务通常被称为字节流服务，因为它在通过传输连接连接的两个应用程序之间创建了一个可靠的字节流。像数据报服务一样，使用字节流服务的网络应用程序可以通过它们运行的宿主机和端口号来识别。这些宿主机可以通过地址或名称来识别。[图
    13](#fig-co-transport) 展示了两个正在使用在 IPv6 宿主机上由 TCP 协议提供的字节流服务的应用程序。TCP 提供的字节流服务是可靠且双向的。
- en: '![Figure made with TikZ](../Images/22d0b3ec409b5e6fa95368ee887a0af6.png)'
  id: totrans-1807
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用 TikZ 制作的图](../Images/22d0b3ec409b5e6fa95368ee887a0af6.png)'
- en: ''
  id: totrans-1808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 13 The connection-oriented or byte-stream service
  id: totrans-1809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 13 面向连接或字节流服务
- en: '### The request-response service[#](#the-request-response-service "Link to
    this heading")'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: '### 请求-响应服务[#](#the-request-response-service "链接到本标题")'
- en: The request-response service is a compromise between the connectionless service
    and the connection-oriented service. Many applications need to send a small amount
    of data and receive a small amount of information back. This is similar to procedure
    calls in programming languages. A call to a procedure takes a few arguments and
    returns a simple answer. In a network, it is sometimes useful to execute a procedure
    on a different host and receive the result of the computation. Executing a procedure
    on another host is often called Remote Procedure Call. It is possible to use the
    connectionless service for this application. However, since this service is usually
    unreliable, this would force the application to deal with any type of error that
    could occur. Using the connection oriented service is another alternative. This
    service ensures the reliable delivery of the data, but a connection must be created
    before the beginning of the data transfer. This overhead can be important for
    applications that only exchange a small amount of data.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应服务是无连接服务和面向连接服务之间的折中方案。许多应用程序需要发送少量数据并接收少量信息。这类似于编程语言中的过程调用。对过程的调用传递几个参数并返回一个简单的答案。在网络中，有时在另一台主机上执行一个过程并接收计算结果是有用的。在另一台主机上执行过程通常被称为远程过程调用。可以使用无连接服务来处理这种应用。然而，由于这种服务通常不可靠，这会迫使应用程序处理可能发生的任何类型的错误。使用面向连接的服务是另一种选择。这种服务确保数据的可靠交付，但在数据传输开始之前必须创建连接。对于仅交换少量数据的应用程序来说，这种开销可能很重要。
- en: The request-response service allows to efficiently exchange small amounts of
    information in a request and associate it with the corresponding response. This
    service can be depicted by using the time-sequence diagram below.
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应服务允许在请求中高效地交换少量信息，并将其与相应的响应关联。此服务可以通过下面的时序图来表示。
- en: '![msc {'
  id: totrans-1813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![msc {'
- en: a [label="", linecolour=white],
  id: totrans-1814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a [label="", linecolour=white],
- en: b [label="Host A", linecolour=black],
  id: totrans-1815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b [label="主机A", linecolour=black],
- en: z [label="Service", linecolour=white],
  id: totrans-1816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z [label="服务", linecolour=white],
- en: c [label="Host B", linecolour=black],
  id: totrans-1817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c [label="主机B", linecolour=black],
- en: d [label="", linecolour=white];
  id: totrans-1818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d [label="", linecolour=white];
- en: ''
  id: totrans-1819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a=>b [ label = "DATA.req(request)" ] ,
  id: totrans-1820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a=>b [ label = "DATA.req(request)" ] ,
- en: b>>c [ arcskip="1"];
  id: totrans-1821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b>>c [ arcskip="1"];
- en: c=>d [ label = "DATA.ind(request)" ];
  id: totrans-1822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c=>d [ label = "DATA.ind(request)" ];
- en: ''
  id: totrans-1823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d=>c [ label = "DATA.resp(response)" ] ,
  id: totrans-1824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d=>c [ label = "DATA.resp(response)" ] ,
- en: c>>b [ arcskip="1"];
  id: totrans-1825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c>>b [ arcskip="1"];
- en: b=>a [ label = "DATA.confirm(response)" ];
  id: totrans-1826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b=>a [ label = "DATA.confirm(response)" ];
- en: '}](../Images/414d09372f22c44dc624c0b21cae0fdc.png)<map id="62a300927dbe4ad95b0ccdb1df72b080f57955e7"
    name="62a300927dbe4ad95b0ccdb1df72b080f57955e7"></map>'
  id: totrans-1827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}](../Images/414d09372f22c44dc624c0b21cae0fdc.png)<map id="62a300927dbe4ad95b0ccdb1df72b080f57955e7"
    name="62a300927dbe4ad95b0ccdb1df72b080f57955e7"></map>'
- en: Note
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Services and layers
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和层
- en: In the previous sections, we have described services that are provided by the
    transport layer. However, it is important to note that the notion of service is
    more general than in the transport layer. As explained earlier, the network layer
    also provides a service, which in most networks is an unreliable connectionless
    service. There are network layers that provide a connection-oriented service.
    Similarly, the datalink layer also provides services. Some datalink layers will
    provide a connectionless service. This will be the case in Local Area Networks
    for examples. Other datalink layers, e.g. in public networks, provide a connection
    oriented service.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了传输层提供的服务。然而，需要注意的是，服务的概念比传输层更一般。如前所述，网络层也提供了一种服务，在大多数网络中这是一种不可靠的无连接服务。有些网络层提供面向连接的服务。同样，数据链路层也提供服务。有些数据链路层将提供无连接服务。例如，在局域网中就是这样。其他数据链路层，例如在公共网络中，提供面向连接的服务。
- en: The transport layer[#](#id6 "Link to this heading")
  id: totrans-1831
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层[#](#id6 "链接到本标题")
- en: 'The transport layer entity interacts with both a user in the application layer
    and the network layer. It improves the network layer service to make it usable
    by applications. From the application’s viewpoint, the main limitations of the
    network layer service come from its unreliable service:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层实体与应用层的用户和网络层进行交互。它提高了网络层服务，使其对应用程序可用。从应用程序的角度来看，网络层服务的主要限制来自其不可靠的服务：
- en: the network layer may corrupt data;
  id: totrans-1833
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能会损坏数据；
- en: ''
  id: totrans-1834
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1835
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer may loose data;
  id: totrans-1836
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能会丢失数据；
- en: ''
  id: totrans-1837
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1838
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer may not deliver data in-order;
  id: totrans-1839
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能无法按顺序交付数据；
- en: ''
  id: totrans-1840
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1841
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer has an upper bound on maximum length of the data;
  id: totrans-1842
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层对数据最大长度有一个上限；
- en: ''
  id: totrans-1843
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1844
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the network layer may duplicate data.
  id: totrans-1845
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层可能会重复数据。
- en: To deal with these issues, the transport layer includes several mechanisms that
    depend on the service that it provides. It interacts with both the applications
    and the underlying network layer.
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些问题，传输层包括一些依赖于它所提供服务的机制。它与应用程序和底层网络层进行交互。
- en: '[![../_images/transport-entity.png](../Images/2d19dde4426bf6e94db4bbeaf29ba9e7.png)](../_images/transport-entity.png)'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/transport-entity.png](../Images/2d19dde4426bf6e94db4bbeaf29ba9e7.png)](../_images/transport-entity.png)'
- en: Fig. 14 Interactions between the transport layer, its user, and its network
    layer provider[#](#id21 "Link to this image")
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 图14 传输层、其用户及其网络层提供者之间的交互[#](#id21 "链接到此图像")
- en: We have already described in the datalink layers mechanisms to deal with data
    losses and transmission errors. These techniques are also used in the transport
    layer.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在数据链路层中描述了处理数据丢失和传输错误的机制。这些技术也用于传输层。
- en: Connectionless transport[#](#connectionless-transport "Link to this heading")
  id: totrans-1850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接传输[#](#connectionless-transport "链接到本标题")
- en: 'The simplest service that can be provided in the transport layer is the connectionless
    transport service. Compared to the connectionless network layer service, this
    transport service includes two additional features :'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层可以提供的最简单的服务是无连接传输服务。与无连接网络层服务相比，此传输服务包括两个额外的特性：
- en: an error detection mechanism that allows detecting corrupted data
  id: totrans-1852
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种错误检测机制，可以检测损坏的数据
- en: ''
  id: totrans-1853
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1854
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a multiplexing technique that enables several applications running on one host
    to exchange information with another host
  id: totrans-1855
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种多路复用技术，它使得一个主机上运行的多项应用能够与其他主机交换信息
- en: To exchange data, the transport protocol encapsulates the SDU produced by its
    user inside a segment. The segment is the unit of transfer of information in the
    transport layer. Transport layer entities always exchange segments. When a transport
    layer entity creates a segment, this segment is encapsulated by the network layer
    into a packet which contains the segment as its payload and a network header.
    The packet is then encapsulated in a frame to be transmitted in the datalink layer.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 为了交换数据，传输协议将其用户产生的SDU封装在段中。段是传输层中信息传输的单位。传输层实体总是交换段。当一个传输层实体创建一个段时，这个段被网络层封装成一个包含段的负载和网络头部的数据包。然后，这个数据包被封装在帧中，以便在数据链路层传输。
- en: '![Figure made with TikZ](../Images/5015b8f973eb207ae53e5951b99d4821.png)'
  id: totrans-1857
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/5015b8f973eb207ae53e5951b99d4821.png)'
- en: ''
  id: totrans-1858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 15 Segments are the unit of transfer at transport layer
  id: totrans-1859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图15 传输层的数据传输单位是段
- en: A segment also contains control information, usually stored inside a header
    and the payload that comes from the application. To detect transmission errors,
    transport protocols rely on checksums or CRCs like the datalink layer protocols.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 段还包含控制信息，通常存储在头部和来自应用程序的有效负载中。为了检测传输错误，传输协议依赖于校验和或CRC，就像数据链路层协议一样。
- en: Compared to the connectionless network layer service, the transport layer service
    allows several applications running on a host to exchange SDUs with several other
    applications running on remote hosts. Let us consider two hosts, e.g. a client
    and a server. The network layer service allows the client to send information
    to the server, but if an application running on the client wants to contact a
    particular application running on the server, then an additional addressing mechanism
    is required. The network layer address identifies a host, but it is not sufficient
    to differentiate the applications running on a host. Port numbers provides this
    additional addressing. When a server application is launched on a host, it registers
    a port number. This port number will be used by the clients to contact the server
    process.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接的网络层服务相比，传输层服务允许主机上运行的多项应用与远程主机上运行的其他多项应用交换SDU。让我们考虑两个主机，例如一个客户端和一个服务器。网络层服务允许客户端向服务器发送信息，但如果客户端上运行的应用程序想要联系服务器上运行的一个特定应用程序，则需要额外的寻址机制。网络层地址标识一个主机，但它不足以区分主机上运行的应用程序。端口号提供了这种额外的寻址。当服务器应用程序在主机上启动时，它会注册一个端口号。这个端口号将被客户端用来联系服务器进程。
- en: The figure below shows a typical usage of port numbers. The client process uses
    port number 1234 while the server process uses port number 5678. When the client
    sends a request, it is identified as originating from port number 1234 on the
    client host and destined to port number 5678 on the server host. When the server
    process replies to this request, the server’s transport layer returns the reply
    as originating from port 5678 on the server host and destined to port 1234 on
    the client host.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了端口号的典型用法。客户端进程使用端口号1234，而服务器进程使用端口号5678。当客户端发送请求时，它被识别为来自客户端主机的端口号1234，并指向服务器主机的端口号5678。当服务器进程回复此请求时，服务器的传输层将回复作为来自服务器主机的端口号5678，并指向客户端主机的端口号1234。
- en: '![Figure made with TikZ](../Images/ff3ac3cf69da5b775b07d19742a9ce04.png)'
  id: totrans-1863
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/ff3ac3cf69da5b775b07d19742a9ce04.png)'
- en: ''
  id: totrans-1864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 16 Utilization of port numbers
  id: totrans-1865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图16 端口号的利用
- en: The User Datagram Protocol[#](#the-user-datagram-protocol "Link to this heading")
  id: totrans-1866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户数据报协议[#](#the-user-datagram-protocol "链接到本标题")
- en: 'The User Datagram Protocol (UDP) is defined in [**RFC 768**](https://datatracker.ietf.org/doc/html/rfc768.html).
    It provides an unreliable connectionless transport service on top of the unreliable
    network layer connectionless service. The main characteristics of the UDP service
    are :'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据报协议（UDP）在[**RFC 768**](https://datatracker.ietf.org/doc/html/rfc768.html)中定义。它在上层不可靠的网络层无连接服务之上提供了一种不可靠的无连接传输服务。UDP服务的主要特性包括：
- en: the UDP service cannot deliver SDUs that are larger than 65467 bytes [[1]](#fmtuudp)
  id: totrans-1868
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务无法交付大于65467字节的SDU [[1]](#fmtuudp)
- en: ''
  id: totrans-1869
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1870
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the UDP service does not guarantee the delivery of SDUs (losses can occur and
    SDUs can arrive out-of-sequence)
  id: totrans-1871
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务不保证SDU的交付（可能会发生丢失，SDU可能会乱序到达）
- en: ''
  id: totrans-1872
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1873
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the UDP service will not deliver a corrupted SDU to the destination
  id: totrans-1874
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务不会将损坏的SDU传递到目的地
- en: Compared to the connectionless network layer service, the main advantage of
    the UDP service is that it allows several applications running on a host to exchange
    SDUs with several other applications running on remote hosts. Let us consider
    two hosts, e.g. a client and a server. The network layer service allows the client
    to send information to the server, but if an application running on the client
    wants to contact a particular application running on the server, then an additional
    addressing mechanism is required other than the IP address that identifies a host,
    in order to differentiate the application running on a host. This additional addressing
    is provided by port numbers. When a server using UDP is enabled on a host, this
    server registers a port number. This port number will be used by the clients to
    contact the server process via UDP.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接的网络层服务相比，UDP服务的主要优势是它允许主机上运行的应用程序与远程主机上运行的其他应用程序交换SDU。让我们考虑两个主机，例如一个客户端和一个服务器。网络层服务允许客户端向服务器发送信息，但如果客户端上运行的应用程序想要联系服务器上运行的一个特定应用程序，那么除了标识主机的IP地址之外，还需要一个额外的寻址机制来区分主机上运行的应用程序。这种额外的寻址由端口号提供。当主机上启用了使用UDP的服务器时，该服务器注册一个端口号。这个端口号将被客户端用来通过UDP联系服务器进程。
- en: Figure [Fig. 17](#fig-udp-port) shows a typical usage of the UDP port numbers.
    The client process uses port number 1234, while the server process uses port number
    5678\. When the client sends a request, it is identified as originating from port
    number 1234 on the client host and destined to port number 5678 on the server
    host. When the server process replies to this request, the server’s UDP implementation
    will send the reply as originating from port 5678 on the server host and destined
    to port 1234 on the client host.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 图[图17](#fig-udp-port)显示了UDP端口号的典型使用情况。客户端进程使用端口号1234，而服务器进程使用端口号5678。当客户端发送请求时，它被识别为来自客户端主机的端口号1234，并指向服务器主机的端口号5678。当服务器进程回复此请求时，服务器的UDP实现将回复作为来自服务器主机的端口号5678，并指向客户端主机的端口号1234。
- en: '![Figure made with TikZ](../Images/9c30be704be853d5409c2b54c90b5f6c.png)'
  id: totrans-1877
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/9c30be704be853d5409c2b54c90b5f6c.png)'
- en: ''
  id: totrans-1878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 17 Usage of the UDP port numbers
  id: totrans-1879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图17 UDP端口号的使用
- en: UDP uses a single segment format shown in figure [Fig. 18](#fig-udp-header).
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: UDP使用图[图18](#fig-udp-header)所示的单一段格式。
- en: '[![../_images/udp.svg](../Images/bf09a2e6a873c135ee14e1478682d518.png)](../_images/udp.svg)'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/udp.svg](../Images/bf09a2e6a873c135ee14e1478682d518.png)'
- en: Fig. 18 UDP Header Format[#](#fig-udp-header "Link to this image")
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 图18 UDP头格式[#](#fig-udp-header "链接到这张图片")
- en: 'The UDP header contains four fields :'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: UDP头包含四个字段：
- en: a 16-bit source port
  id: totrans-1884
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位源端口
- en: ''
  id: totrans-1885
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1886
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit destination port
  id: totrans-1887
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位目的端口
- en: ''
  id: totrans-1888
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1889
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit length field
  id: totrans-1890
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位长度字段
- en: ''
  id: totrans-1891
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1892
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit checksum
  id: totrans-1893
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位校验和
- en: 'As the port numbers are encoded as a 16-bit field, there can be up to only
    65535 different server processes that are bound to a different UDP port at the
    same time on a given server. In practice, this limit is never reached. However,
    it is worth noticing that most implementations divide the range of allowed UDP
    port numbers into three different ranges :'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端口号被编码为16位字段，因此同一服务器上最多只能有65535个不同的服务器进程绑定到不同的UDP端口。在实际应用中，这个限制从未达到。然而，值得注意的是，大多数实现将允许的UDP端口号范围分为三个不同的范围：
- en: the privileged port numbers (1 < port < 1024 )
  id: totrans-1895
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权端口号（1 < 端口 < 1024）
- en: ''
  id: totrans-1896
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1897
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the ephemeral port numbers ( officially [[2]](#fephemeral) 49152 <= port <=
    65535 )
  id: totrans-1898
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时端口号（官方定义为 [[2]](#fephemeral) 49152 <= 端口 <= 65535）
- en: ''
  id: totrans-1899
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1900
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the registered port numbers (officially 1024 <= port < 49152)
  id: totrans-1901
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已注册的端口号（官方定义为1024 <= 端口 < 49152）
- en: In most Unix variants, only processes having system administrator privileges
    can be bound to port numbers smaller than 1024. Well-known servers such as [DNS](../glossary.html#term-DNS),
    [NNTP](../glossary.html#term-NNTP),or [RPC](../glossary.html#term-RPC) use privileged
    port numbers. When a client needs to use UDP, it usually does not require a specific
    port number. In this case, the UDP implementation will allocate the first available
    port number in the ephemeral range. The range of registered port numbers should
    be used by servers. In theory, developers of network servers should register their
    port number officially through IANA [[3]](#fportnum), but few developers do this.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Unix变体中，只有具有系统管理员权限的进程才能绑定到小于1024的端口号。知名服务器，如[DNS](../glossary.html#term-DNS)、[NNTP](../glossary.html#term-NNTP)或[RPC](../glossary.html#term-RPC)，使用特权端口号。当客户端需要使用UDP时，通常不需要特定的端口号。在这种情况下，UDP实现将分配第一个可用的临时端口号。注册端口号的范围应由服务器使用。理论上，网络服务器的开发人员应通过IANA正式注册他们的端口号[[3]](#fportnum)，但很少有开发人员这样做。
- en: UDP can be used over IPv4 or IPv6\. When a host receives an IP packet, it needs
    to determine whether this packet should be processed by UDP or another transport
    protocol. This is done by using the Protocol field in the IP version 4 header.
    The [Internet Assigned Numbers Authority](../glossary.html#term-Internet-Assigned-Numbers-Authority)
    (IANA) maintains a [registry of the assigned Internet Protocol numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
    that assigns one integer to each protocol which can be carried inside an IP packet.
    This registry specifies that `17` is reserved to indicate a UDP segment. Figure
    [Fig. 19](#fig-udp-ipv4) shows a UDP segment inside an IPv4 packet.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: UDP可以在IPv4或IPv6上使用。当主机接收到一个IP数据包时，它需要确定这个数据包应该由UDP还是其他传输协议处理。这是通过使用IPv4头部中的协议字段来完成的。互联网编号分配机构([Internet
    Assigned Numbers Authority](../glossary.html#term-Internet-Assigned-Numbers-Authority)
    (IANA))维护一个[分配的互联网协议号注册表](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)，为每个可以包含在IP数据包内的协议分配一个整数。该注册表指定`17`被保留以指示UDP段。图[图19](#fig-udp-ipv4
    "链接到这张图片")显示了IPv4数据包内的UDP段。
- en: '[![../_images/udp-ipv4.svg](../Images/80a06b3b8fd203d30e66b836dca4db54.png)](../_images/udp-ipv4.svg)'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/udp-ipv4.svg](../Images/80a06b3b8fd203d30e66b836dca4db54.png)'
- en: Fig. 19 An IPv4 packet containing an empty UDP segment[#](#fig-udp-ipv4 "Link
    to this image")
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 图19 包含空UDP段的IPv4数据包[#](#fig-udp-ipv4 "链接到这张图片")
- en: Note
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Computation of the UDP checksum
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: UDP校验和的计算
- en: Many Internet protocols use the Internet checksum defined in [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    to detect transmission errors. This checksum is computed by the sender and verified
    by the received. The algorithm defined in [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    uses modular arithmetic. It is computed over a sequence of bytes which is padded
    if it contains an odd number of bytes. The checksum is the one’s complement of
    the sum of the 16 bits words modulo \(2^16\). The python code below computes the
    Internet checksum.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网协议使用在[**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)中定义的互联网校验和来检测传输错误。这个校验和由发送方计算并由接收方验证。在[**RFC
    1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)中定义的算法使用模运算。它在一个字节序列上计算，如果包含奇数个字节，则进行填充。校验和是16位字和的模\(2^16\)的一的补码。下面的Python代码计算互联网校验和。
- en: '[PRE7]'
  id: totrans-1909
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The byte array used to compute the checksum of an UDP segment contains :'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算UDP段校验和的字节数组包含：
- en: a pseudo header [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    containing the source address, the destination address, the packet length encoded
    as a 32-bit number and a 32-bit bit field containing the three most significant
    bytes set to 0 and the low-order byte set to 17
  id: totrans-1911
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含源地址、目的地址、以32位数字编码的包长度以及一个32位位字段（三个最高有效字节设置为0，最低有效字节设置为17）的伪头部[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
- en: ''
  id: totrans-1912
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1913
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the entire UDP segment, including its header
  id: totrans-1914
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个UDP段，包括其头部
- en: Several types of applications rely on UDP. As a rule of thumb, UDP is used for
    applications where delay must be minimized or losses can be recovered by the application
    itself. A first-class of UDP-based applications are applications where the client
    sends a short request and expects a quick and short answer. The [DNS](../glossary.html#term-DNS)
    is an example of a UDP application that is often used in the wide area. However,
    in local area networks, many distributed systems rely on Remote Procedure Call
    ([RPC](../glossary.html#term-RPC)) that is often used on top of UDP. In Unix environments,
    the Network File System ([NFS](../glossary.html#term-NFS)) is built on top of
    RPC and runs frequently on top of UDP. A second class of UDP-based applications
    are the interactive computer games that need to frequently exchange small messages,
    such as the player’s location or their recent actions. Many of these games use
    UDP to minimize the delay and can recover from losses. A third class of applications
    are multimedia applications such as interactive Voice over IP or interactive Video
    over IP. These interactive applications expect a delay shorter than about 200
    milliseconds between the sender and the receiver and can recover from losses directly
    inside the application.
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的应用程序依赖于UDP。一般来说，UDP用于需要最小化延迟或应用程序本身可以恢复丢失的应用程序。基于UDP的第一类应用程序是客户端发送简短请求并期望快速简短回答的应用程序。[DNS](../glossary.html#term-DNS)是广泛使用的一种UDP应用程序的例子。然而，在局域网中，许多分布式系统依赖于通常在UDP之上使用的远程过程调用([RPC](../glossary.html#term-RPC))。在Unix环境中，网络文件系统([NFS](../glossary.html#term-NFS))建立在RPC之上，并经常在UDP之上运行。基于UDP的第二类应用程序是需要频繁交换小消息的交互式计算机游戏，例如玩家的位置或他们的最近动作。许多这些游戏使用UDP来最小化延迟并从丢失中恢复。第三类应用程序是多媒体应用程序，如交互式VoIP或交互式VoIP视频。这些交互式应用程序期望发送者和接收者之间有小于约200毫秒的延迟，并且可以直接在应用程序中恢复丢失。
- en: Footnotes
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
- en: Connectionless transport[#](#connectionless-transport "Link to this heading")
  id: totrans-1917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接传输[#](#connectionless-transport "链接到这个标题")
- en: 'The simplest service that can be provided in the transport layer is the connectionless
    transport service. Compared to the connectionless network layer service, this
    transport service includes two additional features :'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层可以提供的最简单服务是无连接传输服务。与无连接网络层服务相比，这种传输服务包括两个附加功能：
- en: an error detection mechanism that allows detecting corrupted data
  id: totrans-1919
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种错误检测机制，允许检测损坏的数据
- en: ''
  id: totrans-1920
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1921
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a multiplexing technique that enables several applications running on one host
    to exchange information with another host
  id: totrans-1922
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种允许多个运行在一个主机上的应用程序与另一个主机交换信息的复用技术
- en: To exchange data, the transport protocol encapsulates the SDU produced by its
    user inside a segment. The segment is the unit of transfer of information in the
    transport layer. Transport layer entities always exchange segments. When a transport
    layer entity creates a segment, this segment is encapsulated by the network layer
    into a packet which contains the segment as its payload and a network header.
    The packet is then encapsulated in a frame to be transmitted in the datalink layer.
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 为了交换数据，传输协议将其用户产生的SDU封装在段中。段是传输层中信息传输的单位。传输层实体总是交换段。当一个传输层实体创建一个段时，这个段被网络层封装成一个包含段的负载和网络头部的数据包。然后，这个数据包被封装在帧中，以便在数据链路层传输。
- en: '![Figure made with TikZ](../Images/5015b8f973eb207ae53e5951b99d4821.png)'
  id: totrans-1924
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/5015b8f973eb207ae53e5951b99d4821.png)'
- en: ''
  id: totrans-1925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 15 Segments are the unit of transfer at transport layer
  id: totrans-1926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图15 传输层的数据传输单位是段
- en: A segment also contains control information, usually stored inside a header
    and the payload that comes from the application. To detect transmission errors,
    transport protocols rely on checksums or CRCs like the datalink layer protocols.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 段还包含控制信息，通常存储在头部和来自应用程序的有效负载中。为了检测传输错误，传输协议依赖于校验和或CRC，就像数据链路层协议一样。
- en: Compared to the connectionless network layer service, the transport layer service
    allows several applications running on a host to exchange SDUs with several other
    applications running on remote hosts. Let us consider two hosts, e.g. a client
    and a server. The network layer service allows the client to send information
    to the server, but if an application running on the client wants to contact a
    particular application running on the server, then an additional addressing mechanism
    is required. The network layer address identifies a host, but it is not sufficient
    to differentiate the applications running on a host. Port numbers provides this
    additional addressing. When a server application is launched on a host, it registers
    a port number. This port number will be used by the clients to contact the server
    process.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接的网络层服务相比，传输层服务允许主机上运行的多达几个应用程序与其他主机上运行的多达几个其他应用程序交换SDU。让我们考虑两个主机，例如客户端和服务器。网络层服务允许客户端向服务器发送信息，但如果客户端上运行的应用程序想要联系服务器上运行的一个特定应用程序，则需要额外的寻址机制。网络层地址标识一个主机，但不足以区分主机上运行的应用程序。端口号提供了这种额外的寻址。当服务器应用程序在主机上启动时，它会注册一个端口号。这个端口号将被客户端用来联系服务器进程。
- en: The figure below shows a typical usage of port numbers. The client process uses
    port number 1234 while the server process uses port number 5678. When the client
    sends a request, it is identified as originating from port number 1234 on the
    client host and destined to port number 5678 on the server host. When the server
    process replies to this request, the server’s transport layer returns the reply
    as originating from port 5678 on the server host and destined to port 1234 on
    the client host.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了端口号的典型用法。客户端进程使用端口号1234，而服务器进程使用端口号5678。当客户端发送请求时，它被识别为来自客户端主机的端口号1234，并指向服务器主机的端口号5678。当服务器进程回复此请求时，服务器的传输层将回复返回为来自服务器主机的端口号5678，并指向客户端主机的端口号1234。
- en: '![Figure made with TikZ](../Images/ff3ac3cf69da5b775b07d19742a9ce04.png)'
  id: totrans-1930
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/ff3ac3cf69da5b775b07d19742a9ce04.png)'
- en: ''
  id: totrans-1931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 16 Utilization of port numbers
  id: totrans-1932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图16 端口号的利用
- en: The User Datagram Protocol[#](#the-user-datagram-protocol "Link to this heading")
  id: totrans-1933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户数据报协议[#](#the-user-datagram-protocol "链接到本标题")
- en: 'The User Datagram Protocol (UDP) is defined in [**RFC 768**](https://datatracker.ietf.org/doc/html/rfc768.html).
    It provides an unreliable connectionless transport service on top of the unreliable
    network layer connectionless service. The main characteristics of the UDP service
    are :'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据报协议（UDP）在[**RFC 768**](https://datatracker.ietf.org/doc/html/rfc768.html)中定义。它在上层不可靠的网络层无连接服务之上提供不可靠的无连接传输服务。UDP服务的主要特性包括：
- en: the UDP service cannot deliver SDUs that are larger than 65467 bytes [[1]](#fmtuudp)
  id: totrans-1935
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务无法交付大于65467字节的SDU [[1]](#fmtuudp)
- en: ''
  id: totrans-1936
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1937
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the UDP service does not guarantee the delivery of SDUs (losses can occur and
    SDUs can arrive out-of-sequence)
  id: totrans-1938
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务不保证SDU（数据单元）的交付（可能会发生丢失，SDU可能会乱序到达）
- en: ''
  id: totrans-1939
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1940
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the UDP service will not deliver a corrupted SDU to the destination
  id: totrans-1941
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务不会将损坏的SDU交付到目的地
- en: Compared to the connectionless network layer service, the main advantage of
    the UDP service is that it allows several applications running on a host to exchange
    SDUs with several other applications running on remote hosts. Let us consider
    two hosts, e.g. a client and a server. The network layer service allows the client
    to send information to the server, but if an application running on the client
    wants to contact a particular application running on the server, then an additional
    addressing mechanism is required other than the IP address that identifies a host,
    in order to differentiate the application running on a host. This additional addressing
    is provided by port numbers. When a server using UDP is enabled on a host, this
    server registers a port number. This port number will be used by the clients to
    contact the server process via UDP.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 与无连接的网络层服务相比，UDP服务的主要优势是它允许主机上运行的多达几个应用程序与其他主机上运行的多达几个其他应用程序交换SDU。让我们考虑两个主机，例如客户端和服务器。网络层服务允许客户端向服务器发送信息，但如果客户端上运行的应用程序想要联系服务器上运行的一个特定应用程序，那么除了标识主机的IP地址之外，还需要额外的寻址机制来区分主机上运行的应用程序。这种额外的寻址由端口号提供。当在主机上启用UDP服务器时，此服务器会注册一个端口号。这个端口号将被客户端用来通过UDP联系服务器进程。
- en: Figure [Fig. 17](#fig-udp-port) shows a typical usage of the UDP port numbers.
    The client process uses port number 1234, while the server process uses port number
    5678\. When the client sends a request, it is identified as originating from port
    number 1234 on the client host and destined to port number 5678 on the server
    host. When the server process replies to this request, the server’s UDP implementation
    will send the reply as originating from port 5678 on the server host and destined
    to port 1234 on the client host.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [图 17](#fig-udp-port) 展示了UDP端口号的典型用法。客户端进程使用端口号1234，而服务器进程使用端口号5678。当客户端发送请求时，它被识别为来自客户端主机的端口号1234，并指向服务器主机的端口号5678。当服务器进程回复此请求时，服务器的UDP实现将回复发送为来自服务器主机的端口号5678，并指向客户端主机的端口号1234。
- en: '![Figure made with TikZ](../Images/9c30be704be853d5409c2b54c90b5f6c.png)'
  id: totrans-1944
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![使用TikZ制作的图](../Images/9c30be704be853d5409c2b54c90b5f6c.png)'
- en: ''
  id: totrans-1945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fig. 17 Usage of the UDP port numbers
  id: totrans-1946
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 17 UDP端口号的用法
- en: UDP uses a single segment format shown in figure [Fig. 18](#fig-udp-header).
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: UDP使用图 [图 18](#fig-udp-header) 中所示的单一段格式。
- en: '[![../_images/udp.svg](../Images/bf09a2e6a873c135ee14e1478682d518.png)](../_images/udp.svg)'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../_images/udp.svg](../Images/bf09a2e6a873c135ee14e1478682d518.png)](../_images/udp.svg)'
- en: Fig. 18 UDP Header Format[#](#fig-udp-header "Link to this image")
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18 UDP头格式[#](#fig-udp-header "链接到这张图片")
- en: 'The UDP header contains four fields :'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: UDP头包含四个字段：
- en: a 16-bit source port
  id: totrans-1951
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位源端口
- en: ''
  id: totrans-1952
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1953
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit destination port
  id: totrans-1954
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位目的端口
- en: ''
  id: totrans-1955
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1956
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit length field
  id: totrans-1957
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位长度字段
- en: ''
  id: totrans-1958
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1959
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a 16-bit checksum
  id: totrans-1960
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位校验和
- en: 'As the port numbers are encoded as a 16-bit field, there can be up to only
    65535 different server processes that are bound to a different UDP port at the
    same time on a given server. In practice, this limit is never reached. However,
    it is worth noticing that most implementations divide the range of allowed UDP
    port numbers into three different ranges :'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端口号被编码为16位字段，因此同一服务器上最多只能有65535个不同的服务器进程绑定到不同的UDP端口。在实践中，这个限制从未达到。然而，值得注意的是，大多数实现将允许的UDP端口号范围分为三个不同的范围：
- en: the privileged port numbers (1 < port < 1024 )
  id: totrans-1962
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权端口号（1 < 端口 < 1024）
- en: ''
  id: totrans-1963
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1964
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the ephemeral port numbers ( officially [[2]](#fephemeral) 49152 <= port <=
    65535 )
  id: totrans-1965
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时端口号（官方规定 [[2]](#fephemeral) 49152 <= 端口 <= 65535）
- en: ''
  id: totrans-1966
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1967
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the registered port numbers (officially 1024 <= port < 49152)
  id: totrans-1968
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已注册的端口号（官方规定 1024 <= 端口 < 49152）
- en: In most Unix variants, only processes having system administrator privileges
    can be bound to port numbers smaller than 1024. Well-known servers such as [DNS](../glossary.html#term-DNS),
    [NNTP](../glossary.html#term-NNTP),or [RPC](../glossary.html#term-RPC) use privileged
    port numbers. When a client needs to use UDP, it usually does not require a specific
    port number. In this case, the UDP implementation will allocate the first available
    port number in the ephemeral range. The range of registered port numbers should
    be used by servers. In theory, developers of network servers should register their
    port number officially through IANA [[3]](#fportnum), but few developers do this.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Unix变体中，只有具有系统管理员权限的进程才能绑定到小于1024的端口号。知名服务器如 [DNS](../glossary.html#term-DNS)、[NNTP](../glossary.html#term-NNTP)
    或 [RPC](../glossary.html#term-RPC) 使用特权端口号。当客户端需要使用UDP时，通常不需要特定的端口号。在这种情况下，UDP实现将分配临时范围内的第一个可用端口号。服务器应使用已注册端口号的范围。理论上，网络服务器的开发人员应通过IANA
    [[3]](#fportnum) 正式注册他们的端口号，但很少有开发人员这样做。
- en: UDP can be used over IPv4 or IPv6\. When a host receives an IP packet, it needs
    to determine whether this packet should be processed by UDP or another transport
    protocol. This is done by using the Protocol field in the IP version 4 header.
    The [Internet Assigned Numbers Authority](../glossary.html#term-Internet-Assigned-Numbers-Authority)
    (IANA) maintains a [registry of the assigned Internet Protocol numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)
    that assigns one integer to each protocol which can be carried inside an IP packet.
    This registry specifies that `17` is reserved to indicate a UDP segment. Figure
    [Fig. 19](#fig-udp-ipv4) shows a UDP segment inside an IPv4 packet.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: UDP可以在IPv4或IPv6上使用。当主机接收到IP数据包时，它需要确定该数据包是否应由UDP或其他传输协议处理。这是通过使用IPv4头中的协议字段来完成的。互联网名称和数字地址分配机构（[IANA](../glossary.html#term-Internet-Assigned-Numbers-Authority)）维护一个[分配的互联网协议号注册表](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)，为每个可以包含在IP数据包内的协议分配一个整数。此注册表指定`17`被保留以指示UDP段。图
    [图 19](#fig-udp-ipv4) 展示了IPv4数据包内的UDP段。
- en: '[![../_images/udp-ipv4.svg](../Images/80a06b3b8fd203d30e66b836dca4db54.png)](../_images/udp-ipv4.svg)'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: '![../_images/udp-ipv4.svg](../Images/80a06b3b8fd203d30e66b836dca4db54.png)(../_images/udp-ipv4.svg)'
- en: Fig. 19 An IPv4 packet containing an empty UDP segment[#](#fig-udp-ipv4 "Link
    to this image")
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 图19 包含空UDP数据段的IPv4数据包[#](#fig-udp-ipv4 "链接到这张图片")
- en: Note
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Computation of the UDP checksum
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: UDP校验和的计算
- en: Many Internet protocols use the Internet checksum defined in [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    to detect transmission errors. This checksum is computed by the sender and verified
    by the received. The algorithm defined in [**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)
    uses modular arithmetic. It is computed over a sequence of bytes which is padded
    if it contains an odd number of bytes. The checksum is the one’s complement of
    the sum of the 16 bits words modulo \(2^16\). The python code below computes the
    Internet checksum.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网协议使用在[**RFC 1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)中定义的互联网校验和来检测传输错误。这个校验和由发送者计算并由接收者验证。在[**RFC
    1071**](https://datatracker.ietf.org/doc/html/rfc1071.html)中定义的算法使用模运算。它是在一个字节序列上计算的，如果包含奇数个字节，则进行填充。校验和是16位字和的模\(2^16\)的一的补码。下面的Python代码计算互联网校验和。
- en: '[PRE8]'
  id: totrans-1976
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The byte array used to compute the checksum of an UDP segment contains :'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算UDP数据段校验和的字节数组包含：
- en: a pseudo header [**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
    containing the source address, the destination address, the packet length encoded
    as a 32-bit number and a 32-bit bit field containing the three most significant
    bytes set to 0 and the low-order byte set to 17
  id: totrans-1978
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含源地址、目的地址、以32位数字编码的包长度以及一个32位位字段（三个最高字节设置为0，最低字节设置为17）的伪头部[**RFC 2460**](https://datatracker.ietf.org/doc/html/rfc2460.html)
- en: ''
  id: totrans-1979
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1980
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: the entire UDP segment, including its header
  id: totrans-1981
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个UDP数据段，包括其头部
- en: Several types of applications rely on UDP. As a rule of thumb, UDP is used for
    applications where delay must be minimized or losses can be recovered by the application
    itself. A first-class of UDP-based applications are applications where the client
    sends a short request and expects a quick and short answer. The [DNS](../glossary.html#term-DNS)
    is an example of a UDP application that is often used in the wide area. However,
    in local area networks, many distributed systems rely on Remote Procedure Call
    ([RPC](../glossary.html#term-RPC)) that is often used on top of UDP. In Unix environments,
    the Network File System ([NFS](../glossary.html#term-NFS)) is built on top of
    RPC and runs frequently on top of UDP. A second class of UDP-based applications
    are the interactive computer games that need to frequently exchange small messages,
    such as the player’s location or their recent actions. Many of these games use
    UDP to minimize the delay and can recover from losses. A third class of applications
    are multimedia applications such as interactive Voice over IP or interactive Video
    over IP. These interactive applications expect a delay shorter than about 200
    milliseconds between the sender and the receiver and can recover from losses directly
    inside the application.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 几种类型的应用依赖于UDP。一般来说，UDP用于需要最小化延迟或应用本身可以恢复丢失的应用。基于UDP的第一类应用是客户端发送简短请求并期望快速简短回答的应用。DNS（[域名系统](../glossary.html#term-DNS)）是广泛使用的一个UDP应用示例。然而，在局域网中，许多分布式系统依赖于通常在UDP之上使用的远程过程调用（[RPC](../glossary.html#term-RPC)）。在Unix环境中，网络文件系统（[NFS](../glossary.html#term-NFS)）建立在RPC之上，并经常在UDP之上运行。基于UDP的第二类应用是需要频繁交换小消息的交互式计算机游戏，例如玩家的位置或他们的最近动作。许多这些游戏使用UDP来最小化延迟并能够从丢失中恢复。第三类应用是多媒体应用，如交互式VoIP或交互式VoIP视频。这些交互式应用期望发送者和接收者之间延迟短于大约200毫秒，并且可以直接在应用中恢复丢失。
- en: Footnotes
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 脚注
