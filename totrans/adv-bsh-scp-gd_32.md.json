["```sh #!/bin/bash\n\narea[11]=23\narea[13]=37\narea[51]=UFOs\n\n#  Array members need not be consecutive or contiguous.\n\n#  Some members of the array can be left uninitialized.\n#  Gaps in the array are okay.\n#  In fact, arrays with sparse data (\"sparse arrays\")\n#+ are useful in spreadsheet-processing software.\n\necho -n \"area[11] = \"\necho ${area[11]}    #  {curly brackets} needed.\n\necho -n \"area[13] = \"\necho ${area[13]}\n\necho \"Contents of area[51] are ${area[51]}.\"\n\n# Contents of uninitialized array variable print blank (null variable).\necho -n \"area[43] = \"\necho ${area[43]}\necho \"(area[43] unassigned)\"\n\necho\n\n# Sum of two array variables assigned to third\narea[5]=`expr ${area[11]} + ${area[13]}`\necho \"area[5] = area[11] + area[13]\"\necho -n \"area[5] = \"\necho ${area[5]}\n\narea[6]=`expr ${area[11]} + ${area[51]}`\necho \"area[6] = area[11] + area[51]\"\necho -n \"area[6] = \"\necho ${area[6]}\n# This fails because adding an integer to a string is not permitted.\n\necho; echo; echo\n\n# -----------------------------------------------------------------\n# Another array, \"area2\".\n# Another way of assigning array variables...\n# array_name=( XXX YYY ZZZ ... )\n\narea2=( zero one two three four )\n\necho -n \"area2[0] = \"\necho ${area2[0]}\n# Aha, zero-based indexing (first element of array is [0], not [1]).\n\necho -n \"area2[1] = \"\necho ${area2[1]}    # [1] is second element of array.\n# -----------------------------------------------------------------\n\necho; echo; echo\n\n# -----------------------------------------------\n# Yet another array, \"area3\".\n# Yet another way of assigning array variables...\n# array_name=([xx]=XXX [yy]=YYY ...)\n\narea3=([17]=seventeen [24]=twenty-four)\n\necho -n \"area3[17] = \"\necho ${area3[17]}\n\necho -n \"area3[24] = \"\necho ${area3[24]}\n# -----------------------------------------------\n\nexit 0\n```", "```sh base64_charset=( {A..Z} {a..z} {0..9} + / = )\n               #  Using extended brace expansion\n               #+ to initialize the elements of the array.                \n               #  Excerpted from vladz's \"base64.sh\" script\n               #+ in the \"Contributed Scripts\" appendix.\n```", "```sh string=abcABC123ABCabc\necho ${string[@]}               # abcABC123ABCabc\necho ${string[*]}               # abcABC123ABCabc \necho ${string[0]}               # abcABC123ABCabc\necho ${string[1]}               # No output!\n                                # Why?\necho ${#string[@]}              # 1\n                                # One element in the array.\n                                # The string itself.\n\n# Thank you, Michael Zick, for pointing this out.\n```", "```sh #!/bin/bash\n# poem.sh: Pretty-prints one of the ABS Guide author's favorite poems.\n\n# Lines of the poem (single stanza).\nLine[1]=\"I do not know which to prefer,\"\nLine[2]=\"The beauty of inflections\"\nLine[3]=\"Or the beauty of innuendoes,\"\nLine[4]=\"The blackbird whistling\"\nLine[5]=\"Or just after.\"\n# Note that quoting permits embedding whitespace.\n\n# Attribution.\nAttrib[1]=\" Wallace Stevens\"\nAttrib[2]=\"\\\"Thirteen Ways of Looking at a Blackbird\\\"\"\n# This poem is in the Public Domain (copyright expired).\n\necho\n\ntput bold   # Bold print.\n\nfor index in 1 2 3 4 5    # Five lines.\ndo\n  printf \"     %s\\n\" \"${Line[index]}\"\ndone\n\nfor index in 1 2          # Two attribution lines.\ndo\n  printf \"          %s\\n\" \"${Attrib[index]}\"\ndone\n\ntput sgr0   # Reset terminal.\n            # See 'tput' docs.\n\necho\n\nexit 0\n\n# Exercise:\n# --------\n# Modify this script to pretty-print a poem from a text data file.\n```", "```sh #!/bin/bash\n# array-ops.sh: More fun with arrays.\n\narray=( zero one two three four five )\n# Element 0   1   2    3     4    5\n\necho ${array[0]}       #  zero\necho ${array:0}        #  zero\n                       #  Parameter expansion of first element,\n                       #+ starting at position # 0 (1st character).\necho ${array:1}        #  ero\n                       #  Parameter expansion of first element,\n                       #+ starting at position # 1 (2nd character).\n\necho \"--------------\"\n\necho ${#array[0]}      #  4\n                       #  Length of first element of array.\necho ${#array}         #  4\n                       #  Length of first element of array.\n                       #  (Alternate notation)\n\necho ${#array[1]}      #  3\n                       #  Length of second element of array.\n                       #  Arrays in Bash have zero-based indexing.\n\necho ${#array[*]}      #  6\n                       #  Number of elements in array.\necho ${#array[@]}      #  6\n                       #  Number of elements in array.\n\necho \"--------------\"\n\narray2=( [0]=\"first element\" [1]=\"second element\" [3]=\"fourth element\" )\n#            ^     ^       ^     ^      ^       ^     ^      ^       ^\n# Quoting permits embedding whitespace within individual array elements.\n\necho ${array2[0]}      # first element\necho ${array2[1]}      # second element\necho ${array2[2]}      #\n                       # Skipped in initialization, and therefore null.\necho ${array2[3]}      # fourth element\necho ${#array2[0]}     # 13    (length of first element)\necho ${#array2[*]}     # 3     (number of elements in array)\n\nexit\n```", "```sh #!/bin/bash\n# array-strops.sh: String operations on arrays.\n\n# Script by Michael Zick.\n# Used in ABS Guide with permission.\n# Fixups: 05 May 08, 04 Aug 08.\n\n#  In general, any string operation using the ${name ... } notation\n#+ can be applied to all string elements in an array,\n#+ with the ${name[@] ... } or ${name[*] ...} notation.\n\narrayZ=( one two three four five five )\n\necho\n\n# Trailing Substring Extraction\necho ${arrayZ[@]:0}     # one two three four five five\n#                ^        All elements.\n\necho ${arrayZ[@]:1}     # two three four five five\n#                ^        All elements following element[0].\n\necho ${arrayZ[@]:1:2}   # two three\n#                  ^      Only the two elements after element[0].\n\necho \"---------\"\n\n# Substring Removal\n\n# Removes shortest match from front of string(s).\n\necho ${arrayZ[@]#f*r}   # one two three five five\n#               ^       # Applied to all elements of the array.\n                        # Matches \"four\" and removes it.\n\n# Longest match from front of string(s)\necho ${arrayZ[@]##t*e}  # one two four five five\n#               ^^      # Applied to all elements of the array.\n                        # Matches \"three\" and removes it.\n\n# Shortest match from back of string(s)\necho ${arrayZ[@]%h*e}   # one two t four five five\n#               ^       # Applied to all elements of the array.\n                        # Matches \"hree\" and removes it.\n\n# Longest match from back of string(s)\necho ${arrayZ[@]%%t*e}  # one two four five five\n#               ^^      # Applied to all elements of the array.\n                        # Matches \"three\" and removes it.\n\necho \"----------------------\"\n\n# Substring Replacement\n\n# Replace first occurrence of substring with replacement.\necho ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe\n#               ^           # Applied to all elements of the array.\n\n# Replace all occurrences of substring.\necho ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe\n                            # Applied to all elements of the array.\n\n# Delete all occurrences of substring.\n# Not specifing a replacement defaults to 'delete' ...\necho ${arrayZ[@]//fi/}      # one two three four ve ve\n#               ^^          # Applied to all elements of the array.\n\n# Replace front-end occurrences of substring.\necho ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve\n#                ^          # Applied to all elements of the array.\n\n# Replace back-end occurrences of substring.\necho ${arrayZ[@]/%ve/ZZ}    # one two three four fiZZ fiZZ\n#                ^          # Applied to all elements of the array.\n\necho ${arrayZ[@]/%o/XX}     # one twXX three four five five\n#                ^          # Why?\n\necho \"-----------------------------\"\n\nreplacement() {\n    echo -n \"!!!\"\n}\n\necho ${arrayZ[@]/%e/$(replacement)}\n#                ^  ^^^^^^^^^^^^^^\n# on!!! two thre!!! four fiv!!! fiv!!!\n# The stdout of replacement() is the replacement string.\n# Q.E.D: The replacement action is, in effect, an 'assignment.'\n\necho \"------------------------------------\"\n\n#  Accessing the \"for-each\":\necho ${arrayZ[@]//*/$(replacement optional_arguments)}\n#                ^^ ^^^^^^^^^^^^^\n# !!! !!! !!! !!! !!! !!!\n\n#  Now, if Bash would only pass the matched string\n#+ to the function being called . . .\n\necho\n\nexit 0\n\n#  Before reaching for a Big Hammer -- Perl, Python, or all the rest --\n#  recall:\n#    $( ... ) is command substitution.\n#    A function runs as a sub-process.\n#    A function writes its output (if echo-ed) to stdout.\n#    Assignment, in conjunction with \"echo\" and command substitution,\n#+   can read a function's stdout.\n#    The name[@] notation specifies (the equivalent of) a \"for-each\"\n#+   operation.\n#  Bash is more powerful than you think!\n```", "```sh #!/bin/bash\n# script-array.sh: Loads this script into an array.\n# Inspired by an e-mail from Chris Martin (thanks!).\n\nscript_contents=( $(cat \"$0\") )  #  Stores contents of this script ($0)\n                                 #+ in an array.\n\nfor element in $(seq 0 $((${#script_contents[@]} - 1)))\n  do                #  ${#script_contents[@]}\n                    #+ gives number of elements in the array.\n                    #\n                    #  Question:\n                    #  Why is  seq 0  necessary?\n                    #  Try changing it to seq 1.\n  echo -n \"${script_contents[$element]}\"\n                    # List each field of this script on a single line.\n# echo -n \"${script_contents[element]}\" also works because of ${ ... }.\n  echo -n \" -- \"    # Use \" -- \" as a field separator.\ndone\n\necho\n\nexit 0\n\n# Exercise:\n# --------\n#  Modify this script so it lists itself\n#+ in its original format,\n#+ complete with whitespace, line breaks, etc.\n```", "```sh #!/bin/bash\n\ndeclare -a colors\n#  All subsequent commands in this script will treat\n#+ the variable \"colors\" as an array.\n\necho \"Enter your favorite colors (separated from each other by a space).\"\n\nread -a colors    # Enter at least 3 colors to demonstrate features below.\n#  Special option to 'read' command,\n#+ allowing assignment of elements in an array.\n\necho\n\nelement_count=${#colors[@]}\n# Special syntax to extract number of elements in array.\n#     element_count=${#colors[*]} works also.\n#\n#  The \"@\" variable allows word splitting within quotes\n#+ (extracts variables separated by whitespace).\n#\n#  This corresponds to the behavior of \"$@\" and \"$*\"\n#+ in positional parameters. \n\nindex=0\n\nwhile [ \"$index\" -lt \"$element_count\" ]\ndo    # List all the elements in the array.\n  echo ${colors[$index]}\n  #    ${colors[index]} also works because it's within ${ ... } brackets.\n  let \"index = $index + 1\"\n  # Or:\n  #    ((index++))\ndone\n# Each array element listed on a separate line.\n# If this is not desired, use  echo -n \"${colors[$index]} \"\n#\n# Doing it with a \"for\" loop instead:\n#   for i in \"${colors[@]}\"\n#   do\n#     echo \"$i\"\n#   done\n# (Thanks, S.C.)\n\necho\n\n# Again, list all the elements in the array, but using a more elegant method.\n  echo ${colors[@]}          # echo ${colors[*]} also works.\n\necho\n\n# The \"unset\" command deletes elements of an array, or entire array.\nunset colors[1]              # Remove 2nd element of array.\n                             # Same effect as   colors[1]=\necho  ${colors[@]}           # List array again, missing 2nd element.\n\nunset colors                 # Delete entire array.\n                             #  unset colors[*] and\n                             #+ unset colors[@] also work.\necho; echo -n \"Colors gone.\"\t\t\t   \necho ${colors[@]}            # List array again, now empty.\n\nexit 0\n```", "```sh #!/bin/bash\n# empty-array.sh\n\n#  Thanks to Stephane Chazelas for the original example,\n#+ and to Michael Zick and Omair Eshkenazi, for extending it.\n#  And to Nathan Coulter for clarifications and corrections.\n\n# An empty array is not the same as an array with empty elements.\n\n  array0=( first second third )\n  array1=( '' )   # \"array1\" consists of one empty element.\n  array2=( )      # No elements . . . \"array2\" is empty.\n  array3=(   )    # What about this array?\n\necho\nListArray()\n{\necho\necho \"Elements in array0:  ${array0[@]}\"\necho \"Elements in array1:  ${array1[@]}\"\necho \"Elements in array2:  ${array2[@]}\"\necho \"Elements in array3:  ${array3[@]}\"\necho\necho \"Length of first element in array0 = ${#array0}\"\necho \"Length of first element in array1 = ${#array1}\"\necho \"Length of first element in array2 = ${#array2}\"\necho \"Length of first element in array3 = ${#array3}\"\necho\necho \"Number of elements in array0 = ${#array0[*]}\"  # 3\necho \"Number of elements in array1 = ${#array1[*]}\"  # 1  (Surprise!)\necho \"Number of elements in array2 = ${#array2[*]}\"  # 0\necho \"Number of elements in array3 = ${#array3[*]}\"  # 0\n}\n\n# ===================================================================\n\nListArray\n\n# Try extending those arrays.\n\n# Adding an element to an array.\narray0=( \"${array0[@]}\" \"new1\" )\narray1=( \"${array1[@]}\" \"new1\" )\narray2=( \"${array2[@]}\" \"new1\" )\narray3=( \"${array3[@]}\" \"new1\" )\n\nListArray\n\n# or\narray0[${#array0[*]}]=\"new2\"\narray1[${#array1[*]}]=\"new2\"\narray2[${#array2[*]}]=\"new2\"\narray3[${#array3[*]}]=\"new2\"\n\nListArray\n\n# When extended as above, arrays are 'stacks' ...\n# Above is the 'push' ...\n# The stack 'height' is:\nheight=${#array2[@]}\necho\necho \"Stack height for array2 = $height\"\n\n# The 'pop' is:\nunset array2[${#array2[@]}-1]   #  Arrays are zero-based,\nheight=${#array2[@]}            #+ which means first element has index 0.\necho\necho \"POP\"\necho \"New stack height for array2 = $height\"\n\nListArray\n\n# List only 2nd and 3rd elements of array0.\nfrom=1\t\t    # Zero-based numbering.\nto=2\narray3=( ${array0[@]:1:2} )\necho\necho \"Elements in array3:  ${array3[@]}\"\n\n# Works like a string (array of characters).\n# Try some other \"string\" forms.\n\n# Replacement:\narray4=( ${array0[@]/second/2nd} )\necho\necho \"Elements in array4:  ${array4[@]}\"\n\n# Replace all matching wildcarded string.\narray5=( ${array0[@]//new?/old} )\necho\necho \"Elements in array5:  ${array5[@]}\"\n\n# Just when you are getting the feel for this . . .\narray6=( ${array0[@]#*new} )\necho # This one might surprise you.\necho \"Elements in array6:  ${array6[@]}\"\n\narray7=( ${array0[@]#new1} )\necho # After array6 this should not be a surprise.\necho \"Elements in array7:  ${array7[@]}\"\n\n# Which looks a lot like . . .\narray8=( ${array0[@]/new1/} )\necho\necho \"Elements in array8:  ${array8[@]}\"\n\n#  So what can one say about this?\n\n#  The string operations are performed on\n#+ each of the elements in var[@] in succession.\n#  Therefore : Bash supports string vector operations.\n#  If the result is a zero length string,\n#+ that element disappears in the resulting assignment.\n#  However, if the expansion is in quotes, the null elements remain.\n\n#  Michael Zick:    Question, are those strings hard or soft quotes?\n#  Nathan Coulter:  There is no such thing as \"soft quotes.\"\n#!    What's really happening is that\n#!+   the pattern matching happens after\n#!+   all the other expansions of [word]\n#!+   in cases like ${parameter#word}.\n\nzap='new*'\narray9=( ${array0[@]/$zap/} )\necho\necho \"Number of elements in array9:  ${#array9[@]}\"\narray9=( \"${array0[@]/$zap/}\" )\necho \"Elements in array9:  ${array9[@]}\"\n# This time the null elements remain.\necho \"Number of elements in array9:  ${#array9[@]}\"\n\n# Just when you thought you were still in Kansas . . .\narray10=( ${array0[@]#$zap} )\necho\necho \"Elements in array10:  ${array10[@]}\"\n# But, the asterisk in zap won't be interpreted if quoted.\narray10=( ${array0[@]#\"$zap\"} )\necho\necho \"Elements in array10:  ${array10[@]}\"\n# Well, maybe we _are_ still in Kansas . . .\n# (Revisions to above code block by Nathan Coulter.)\n\n#  Compare array7 with array10.\n#  Compare array8 with array9.\n\n#  Reiterating: No such thing as soft quotes!\n#  Nathan Coulter explains:\n#  Pattern matching of 'word' in ${parameter#word} is done after\n#+ parameter expansion and *before* quote removal.\n#  In the normal case, pattern matching is done *after* quote removal.\n\nexit\n```", "```sh # Copying an array.\narray2=( \"${array1[@]}\" )\n# or\narray2=\"${array1[@]}\"\n#\n#  However, this fails with \"sparse\" arrays,\n#+ arrays with holes (missing elements) in them,\n#+ as Jochen DeSmet points out.\n# ------------------------------------------\n  array1[0]=0\n# array1[1] not assigned\n  array1[2]=2\n  array2=( \"${array1[@]}\" )       # Copy it?\n\necho ${array2[0]}      # 0\necho ${array2[2]}      # (null), should be 2\n# ------------------------------------------\n\n# Adding an element to an array.\narray=( \"${array[@]}\" \"new element\" )\n# or\narray[${#array[*]}]=\"new element\"\n\n# Thanks, S.C.\n```", "```sh #!/bin/bash\n\nfilename=sample_file\n\n#            cat sample_file\n#\n#            1 a b c\n#            2 d e fg\n\ndeclare -a array1\n\narray1=( `cat \"$filename\"`)                #  Loads contents\n#         List file to stdout              #+ of $filename into array1.\n#\n#  array1=( `cat \"$filename\" &#124; tr '\\n' ' '`)\n#                            change linefeeds in file to spaces. \n#  Not necessary because Bash does word splitting,\n#+ changing linefeeds to spaces.\n\necho ${array1[@]}            # List the array.\n#                              1 a b c 2 d e fg\n#\n#  Each whitespace-separated \"word\" in the file\n#+ has been assigned to an element of the array.\n\nelement_count=${#array1[*]}\necho $element_count          # 8\n```", "```sh #! /bin/bash\n# array-assign.bash\n\n#  Array operations are Bash-specific,\n#+ hence the \".bash\" in the script name.\n\n# Copyright (c) Michael S. Zick, 2003, All rights reserved.\n# License: Unrestricted reuse in any form, for any purpose.\n# Version: $ID$\n#\n# Clarification and additional comments by William Park.\n\n#  Based on an example provided by Stephane Chazelas\n#+ which appeared in an earlier version of the\n#+ Advanced Bash Scripting Guide.\n\n# Output format of the 'times' command:\n# User CPU <space> System CPU\n# User CPU of dead children <space> System CPU of dead children\n\n#  Bash has two versions of assigning all elements of an array\n#+ to a new array variable.\n#  Both drop 'null reference' elements\n#+ in Bash versions 2.04 and later.\n#  An additional array assignment that maintains the relationship of\n#+ [subscript]=value for arrays may be added to newer versions.\n\n#  Constructs a large array using an internal command,\n#+ but anything creating an array of several thousand elements\n#+ will do just fine.\n\ndeclare -a bigOne=( /dev/* )  # All the files in /dev . . .\necho\necho 'Conditions: Unquoted, default IFS, All-Elements-Of'\necho \"Number of elements in array is ${#bigOne[@]}\"\n\n# set -vx\n\necho\necho '- - testing: =( ${array[@]} ) - -'\ntimes\ndeclare -a bigTwo=( ${bigOne[@]} )\n# Note parens:    ^              ^\ntimes\n\necho\necho '- - testing: =${array[@]} - -'\ntimes\ndeclare -a bigThree=${bigOne[@]}\n# No parentheses this time.\ntimes\n\n#  Comparing the numbers shows that the second form, pointed out\n#+ by Stephane Chazelas, is faster.\n#\n#  As William Park explains:\n#+ The bigTwo array assigned element by element (because of parentheses),\n#+ whereas bigThree assigned as a single string.\n#  So, in essence, you have:\n#                   bigTwo=( [0]=\"...\" [1]=\"...\" [2]=\"...\" ... )\n#                   bigThree=( [0]=\"... ... ...\" )\n#\n#  Verify this by:  echo ${bigTwo[0]}\n#                   echo ${bigThree[0]}\n\n#  I will continue to use the first form in my example descriptions\n#+ because I think it is a better illustration of what is happening.\n\n#  The reusable portions of my examples will actual contain\n#+ the second form where appropriate because of the speedup.\n\n# MSZ: Sorry about that earlier oversight folks.\n\n#  Note:\n#  ----\n#  The \"declare -a\" statements in lines 32 and 44\n#+ are not strictly necessary, since it is implicit\n#+ in the  Array=( ... )  assignment form.\n#  However, eliminating these declarations slows down\n#+ the execution of the following sections of the script.\n#  Try it, and see.\n\nexit 0\n```", "```sh #! /bin/bash\n# CopyArray.sh\n#\n# This script written by Michael Zick.\n# Used here with permission.\n\n#  How-To \"Pass by Name & Return by Name\"\n#+ or \"Building your own assignment statement\".\n\nCpArray_Mac() {\n\n# Assignment Command Statement Builder\n\n    echo -n 'eval '\n    echo -n \"$2\"                    # Destination name\n    echo -n '=( ${'\n    echo -n \"$1\"                    # Source name\n    echo -n '[@]} )'\n\n# That could all be a single command.\n# Matter of style only.\n}\n\ndeclare -f CopyArray                # Function \"Pointer\"\nCopyArray=CpArray_Mac               # Statement Builder\n\nHype()\n{\n\n# Hype the array named $1.\n# (Splice it together with array containing \"Really Rocks\".)\n# Return in array named $2.\n\n    local -a TMP\n    local -a hype=( Really Rocks )\n\n    $($CopyArray $1 TMP)\n    TMP=( ${TMP[@]} ${hype[@]} )\n    $($CopyArray TMP $2)\n}\n\ndeclare -a before=( Advanced Bash Scripting )\ndeclare -a after\n\necho \"Array Before = ${before[@]}\"\n\nHype before after\n\necho \"Array After = ${after[@]}\"\n\n# Too much hype?\n\necho \"What ${after[@]:3:2}?\"\n\ndeclare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )\n#                    ---- substring extraction ----\n\necho \"Array Modest = ${modest[@]}\"\n\n# What happened to 'before' ?\n\necho \"Array Before = ${before[@]}\"\n\nexit 0\n```", "```sh #! /bin/bash\n# array-append.bash\n\n# Copyright (c) Michael S. Zick, 2003, All rights reserved.\n# License: Unrestricted reuse in any form, for any purpose.\n# Version: $ID$\n#\n# Slightly modified in formatting by M.C.\n\n# Array operations are Bash-specific.\n# Legacy UNIX /bin/sh lacks equivalents.\n\n#  Pipe the output of this script to 'more'\n#+ so it doesn't scroll off the terminal.\n#  Or, redirect output to a file.\n\ndeclare -a array1=( zero1 one1 two1 )\n# Subscript packed.\ndeclare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )\n# Subscript sparse -- [1] is not defined.\n\necho\necho '- Confirm that the array is really subscript sparse. -'\necho \"Number of elements: 4\"        # Hard-coded for illustration.\nfor (( i = 0 ; i < 4 ; i++ ))\ndo\n    echo \"Element [$i]: ${array2[$i]}\"\ndone\n# See also the more general code example in basics-reviewed.bash.\n\ndeclare -a dest\n\n# Combine (append) two arrays into a third array.\necho\necho 'Conditions: Unquoted, default IFS, All-Elements-Of operator'\necho '- Undefined elements not present, subscripts not maintained. -'\n# # The undefined elements do not exist; they are not being dropped.\n\ndest=( ${array1[@]} ${array2[@]} )\n# dest=${array1[@]}${array2[@]}     # Strange results, possibly a bug.\n\n# Now, list the result.\necho\necho '- - Testing Array Append - -'\ncnt=${#dest[@]}\n\necho \"Number of elements: $cnt\"\nfor (( i = 0 ; i < cnt ; i++ ))\ndo\n    echo \"Element [$i]: ${dest[$i]}\"\ndone\n\n# Assign an array to a single array element (twice).\ndest[0]=${array1[@]}\ndest[1]=${array2[@]}\n\n# List the result.\necho\necho '- - Testing modified array - -'\ncnt=${#dest[@]}\n\necho \"Number of elements: $cnt\"\nfor (( i = 0 ; i < cnt ; i++ ))\ndo\n    echo \"Element [$i]: ${dest[$i]}\"\ndone\n\n# Examine the modified second element.\necho\necho '- - Reassign and list second element - -'\n\ndeclare -a subArray=${dest[1]}\ncnt=${#subArray[@]}\n\necho \"Number of elements: $cnt\"\nfor (( i = 0 ; i < cnt ; i++ ))\ndo\n    echo \"Element [$i]: ${subArray[$i]}\"\ndone\n\n#  The assignment of an entire array to a single element\n#+ of another array using the '=${ ... }' array assignment\n#+ has converted the array being assigned into a string,\n#+ with the elements separated by a space (the first character of IFS).\n\n# If the original elements didn't contain whitespace . . .\n# If the original array isn't subscript sparse . . .\n# Then we could get the original array structure back again.\n\n# Restore from the modified second element.\necho\necho '- - Listing restored element - -'\n\ndeclare -a subArray=( ${dest[1]} )\ncnt=${#subArray[@]}\n\necho \"Number of elements: $cnt\"\nfor (( i = 0 ; i < cnt ; i++ ))\ndo\n    echo \"Element [$i]: ${subArray[$i]}\"\ndone\necho '- - Do not depend on this behavior. - -'\necho '- - This behavior is subject to change - -'\necho '- - in versions of Bash newer than version 2.05b - -'\n\n# MSZ: Sorry about any earlier confusion folks.\n\nexit 0\n```", "```sh #!/bin/bash\n# bubble.sh: Bubble sort, of sorts.\n\n# Recall the algorithm for a bubble sort. In this particular version...\n\n#  With each successive pass through the array to be sorted,\n#+ compare two adjacent elements, and swap them if out of order.\n#  At the end of the first pass, the \"heaviest\" element has sunk to bottom.\n#  At the end of the second pass, the next \"heaviest\" one has sunk next to bottom.\n#  And so forth.\n#  This means that each successive pass needs to traverse less of the array.\n#  You will therefore notice a speeding up in the printing of the later passes.\n\nexchange()\n{\n  # Swaps two members of the array.\n  local temp=${Countries[$1]} #  Temporary storage\n                              #+ for element getting swapped out.\n  Countries[$1]=${Countries[$2]}\n  Countries[$2]=$temp\n\n  return\n}  \n\ndeclare -a Countries  #  Declare array,\n                      #+ optional here since it's initialized below.\n\n#  Is it permissable to split an array variable over multiple lines\n#+ using an escape (\\)?\n#  Yes.\n\nCountries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \\\nBrazil Argentina Nicaragua Japan Mexico Venezuela Greece England \\\nIsrael Peru Canada Oman Denmark Wales France Kenya \\\nXanadu Qatar Liechtenstein Hungary)\n\n# \"Xanadu\" is the mythical place where, according to Coleridge,\n#+ Kubla Khan did a pleasure dome decree.\n\nclear                      # Clear the screen to start with. \n\necho \"0: ${Countries[*]}\"  # List entire array at pass 0.\n\nnumber_of_elements=${#Countries[@]}\nlet \"comparisons = $number_of_elements - 1\"\n\ncount=1 # Pass number.\n\nwhile [ \"$comparisons\" -gt 0 ]          # Beginning of outer loop\ndo\n\n  index=0  # Reset index to start of array after each pass.\n\n  while [ \"$index\" -lt \"$comparisons\" ] # Beginning of inner loop\n  do\n    if [ ${Countries[$index]} \\> ${Countries[`expr $index + 1`]} ]\n    #  If out of order...\n    #  Recalling that \\> is ASCII comparison operator\n    #+ within single brackets.\n\n    #  if [[ ${Countries[$index]} > ${Countries[`expr $index + 1`]} ]]\n    #+ also works.\n    then\n      exchange $index `expr $index + 1`  # Swap.\n    fi  \n    let \"index += 1\"  # Or,   index+=1   on Bash, ver. 3.1 or newer.\n  done # End of inner loop\n\n# ----------------------------------------------------------------------\n# Paulo Marcel Coelho Aragao suggests for-loops as a simpler altenative.\n#\n# for (( last = $number_of_elements - 1 ; last > 0 ; last-- ))\n##                     Fix by C.Y. Hunt          ^   (Thanks!)\n# do\n#     for (( i = 0 ; i < last ; i++ ))\n#     do\n#         [[ \"${Countries[$i]}\" > \"${Countries[$((i+1))]}\" ]] \\\n#             && exchange $i $((i+1))\n#     done\n# done\n# ----------------------------------------------------------------------\n\nlet \"comparisons -= 1\" #  Since \"heaviest\" element bubbles to bottom,\n                       #+ we need do one less comparison each pass.\n\necho\necho \"$count: ${Countries[@]}\"  # Print resultant array at end of each pass.\necho\nlet \"count += 1\"                # Increment pass count.\n\ndone                            # End of outer loop\n                                # All done.\n\nexit 0\n```", "```sh #!/bin/bash\n# \"Nested\" array.\n\n#  Michael Zick provided this example,\n#+ with corrections and clarifications by William Park.\n\nAnArray=( $(ls --inode --ignore-backups --almost-all \\\n\t--directory --full-time --color=none --time=status \\\n\t--sort=time -l ${PWD} ) )  # Commands and options.\n\n# Spaces are significant . . . and don't quote anything in the above.\n\nSubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )\n#  This array has six elements:\n#+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}\n#      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )\n#\n#  Arrays in Bash are (circularly) linked lists\n#+ of type string (char *).\n#  So, this isn't actually a nested array,\n#+ but it's functionally similar.\n\necho \"Current directory and date of last status change:\"\necho \"${SubArray[@]}\"\n\nexit 0\n```", "```sh #!/bin/bash\n# embedded-arrays.sh\n# Embedded arrays and indirect references.\n\n# This script by Dennis Leeuw.\n# Used with permission.\n# Modified by document author.\n\nARRAY1=(\n        VAR1_1=value11\n        VAR1_2=value12\n        VAR1_3=value13\n)\n\nARRAY2=(\n        VARIABLE=\"test\"\n        STRING=\"VAR1=value1 VAR2=value2 VAR3=value3\"\n        ARRAY21=${ARRAY1[*]}\n)       # Embed ARRAY1 within this second array.\n\nfunction print () {\n        OLD_IFS=\"$IFS\"\n        IFS=$'\\n'       #  To print each array element\n                        #+ on a separate line.\n        TEST1=\"ARRAY2[*]\"\n        local ${!TEST1} # See what happens if you delete this line.\n        #  Indirect reference.\n\t#  This makes the components of $TEST1\n\t#+ accessible to this function.\n\n        #  Let's see what we've got so far.\n        echo\n        echo \"\\$TEST1 = $TEST1\"       #  Just the name of the variable.\n        echo; echo\n        echo \"{\\$TEST1} = ${!TEST1}\"  #  Contents of the variable.\n                                      #  That's what an indirect\n                                      #+ reference does.\n        echo\n        echo \"-------------------------------------------\"; echo\n        echo\n\n        # Print variable\n        echo \"Variable VARIABLE: $VARIABLE\"\n\n        # Print a string element\n        IFS=\"$OLD_IFS\"\n        TEST2=\"STRING[*]\"\n        local ${!TEST2}      # Indirect reference (as above).\n        echo \"String element VAR2: $VAR2 from STRING\"\n\n        # Print an array element\n        TEST2=\"ARRAY21[*]\"\n        local ${!TEST2}      # Indirect reference (as above).\n        echo \"Array element VAR1_1: $VAR1_1 from ARRAY21\"\n}\n\nprint\necho\n\nexit 0\n\n#   As the author of the script notes,\n#+ \"you can easily expand it to create named-hashes in bash.\"\n#   (Difficult) exercise for the reader: implement this.\n```", "```sh #!/bin/bash\n# sieve.sh (ex68.sh)\n\n# Sieve of Eratosthenes\n# Ancient algorithm for finding prime numbers.\n\n#  This runs a couple of orders of magnitude slower\n#+ than the equivalent program written in C.\n\nLOWER_LIMIT=1       # Starting with 1.\nUPPER_LIMIT=1000    # Up to 1000.\n# (You may set this higher . . . if you have time on your hands.)\n\nPRIME=1\nNON_PRIME=0\n\nlet SPLIT=UPPER_LIMIT/2\n# Optimization:\n# Need to test numbers only halfway to upper limit. Why?\n\ndeclare -a Primes\n# Primes[] is an array.\n\ninitialize ()\n{\n# Initialize the array.\n\ni=$LOWER_LIMIT\nuntil [ \"$i\" -gt \"$UPPER_LIMIT\" ]\ndo\n  Primes[i]=$PRIME\n  let \"i += 1\"\ndone\n#  Assume all array members guilty (prime)\n#+ until proven innocent.\n}\n\nprint_primes ()\n{\n# Print out the members of the Primes[] array tagged as prime.\n\ni=$LOWER_LIMIT\n\nuntil [ \"$i\" -gt \"$UPPER_LIMIT\" ]\ndo\n\n  if [ \"${Primes[i]}\" -eq \"$PRIME\" ]\n  then\n    printf \"%8d\" $i\n    # 8 spaces per number gives nice, even columns.\n  fi\n\n  let \"i += 1\"\n\ndone\n\n}\n\nsift () # Sift out the non-primes.\n{\n\nlet i=$LOWER_LIMIT+1\n# Let's start with 2.\n\nuntil [ \"$i\" -gt \"$UPPER_LIMIT\" ]\ndo\n\nif [ \"${Primes[i]}\" -eq \"$PRIME\" ]\n# Don't bother sieving numbers already sieved (tagged as non-prime).\nthen\n\n  t=$i\n\n  while [ \"$t\" -le \"$UPPER_LIMIT\" ]\n  do\n    let \"t += $i \"\n    Primes[t]=$NON_PRIME\n    # Tag as non-prime all multiples.\n  done\n\nfi  \n\n  let \"i += 1\"\ndone  \n\n}\n\n# ==============================================\n# main ()\n# Invoke the functions sequentially.\ninitialize\nsift\nprint_primes\n# This is what they call structured programming.\n# ==============================================\n\necho\n\nexit 0\n\n# -------------------------------------------------------- #\n# Code below line will not execute, because of 'exit.'\n\n#  This improved version of the Sieve, by Stephane Chazelas,\n#+ executes somewhat faster.\n\n# Must invoke with command-line argument (limit of primes).\n\nUPPER_LIMIT=$1                  # From command-line.\nlet SPLIT=UPPER_LIMIT/2         # Halfway to max number.\n\nPrimes=( '' $(seq $UPPER_LIMIT) )\n\ni=1\nuntil (( ( i += 1 ) > SPLIT ))  # Need check only halfway.\ndo\n  if [[ -n ${Primes[i]} ]]\n  then\n    t=$i\n    until (( ( t += i ) > UPPER_LIMIT ))\n    do\n      Primes[t]=\n    done\n  fi  \ndone  \necho ${Primes[*]}\n\nexit $?\n```", "```sh #!/bin/bash\n# Optimized Sieve of Eratosthenes\n# Script by Jared Martin, with very minor changes by ABS Guide author.\n# Used in ABS Guide with permission (thanks!).\n\n# Based on script in Advanced Bash Scripting Guide.\n# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).\n\n# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (reference)\n# Check results against http://primes.utm.edu/lists/small/1000.txt\n\n# Necessary but not sufficient would be, e.g.,\n#     (($(sieve 7919 &#124; wc -w) == 1000)) && echo \"7919 is the 1000th prime\"\n\nUPPER_LIMIT=${1:?\"Need an upper limit of primes to search.\"}\n\nPrimes=( '' $(seq ${UPPER_LIMIT}) )\n\ntypeset -i i t\nPrimes[i=1]='' # 1 is not a prime.\nuntil (( ( i += 1 ) > (${UPPER_LIMIT}/i) ))  # Need check only ith-way.\n  do                                         # Why?\n    if ((${Primes[t=i*(i-1), i]}))\n    # Obscure, but instructive, use of arithmetic expansion in subscript.\n    then\n      until (( ( t += i ) > ${UPPER_LIMIT} ))\n        do Primes[t]=; done\n    fi\n  done\n\n# echo ${Primes[*]}\necho   # Change to original script for pretty-printing (80-col. display).\nprintf \"%8d\" ${Primes[*]}\necho; echo\n\nexit $?\n```", "```sh #!/bin/bash\n# stack.sh: push-down stack simulation\n\n#  Similar to the CPU stack, a push-down stack stores data items\n#+ sequentially, but releases them in reverse order, last-in first-out.\n\nBP=100            #  Base Pointer of stack array.\n                  #  Begin at element 100.\n\nSP=$BP            #  Stack Pointer.\n                  #  Initialize it to \"base\" (bottom) of stack.\n\nData=             #  Contents of stack location.  \n                  #  Must use global variable,\n                  #+ because of limitation on function return range.\n\n                  # 100     Base pointer       <-- Base Pointer\n                  #  99     First data item\n                  #  98     Second data item\n                  # ...     More data\n                  #         Last data item     <-- Stack pointer\n\ndeclare -a stack\n\npush()            # Push item on stack.\n{\nif [ -z \"$1\" ]    # Nothing to push?\nthen\n  return\nfi\n\nlet \"SP -= 1\"     # Bump stack pointer.\nstack[$SP]=$1\n\nreturn\n}\n\npop()                    # Pop item off stack.\n{\nData=                    # Empty out data item.\n\nif [ \"$SP\" -eq \"$BP\" ]   # Stack empty?\nthen\n  return\nfi                       #  This also keeps SP from getting past 100,\n                         #+ i.e., prevents a runaway stack.\n\nData=${stack[$SP]}\nlet \"SP += 1\"            # Bump stack pointer.\nreturn\n}\n\nstatus_report()          # Find out what's happening.\n{\necho \"-------------------------------------\"\necho \"REPORT\"\necho \"Stack Pointer = $SP\"\necho \"Just popped \\\"\"$Data\"\\\" off the stack.\"\necho \"-------------------------------------\"\necho\n}\n\n# =======================================================\n# Now, for some fun.\n\necho\n\n# See if you can pop anything off empty stack.\npop\nstatus_report\n\necho\n\npush garbage\npop\nstatus_report     # Garbage in, garbage out.      \n\nvalue1=23;        push $value1\nvalue2=skidoo;    push $value2\nvalue3=LAST;      push $value3\n\npop               # LAST\nstatus_report\npop               # skidoo\nstatus_report\npop               # 23\nstatus_report     # Last-in, first-out!\n\n#  Notice how the stack pointer decrements with each push,\n#+ and increments with each pop.\n\necho\n\nexit 0\n\n# =======================================================\n\n# Exercises:\n# ---------\n\n# 1)  Modify the \"push()\" function to permit pushing\n#   + multiple element on the stack with a single function call.\n\n# 2)  Modify the \"pop()\" function to permit popping\n#   + multiple element from the stack with a single function call.\n\n# 3)  Add error checking to the critical functions.\n#     That is, return an error code, depending on\n#   + successful or unsuccessful completion of the operation,\n#   + and take appropriate action.\n\n# 4)  Using this script as a starting point,\n#   + write a stack-based 4-function calculator.\n```", "```sh #!/bin/bash\n\n# Douglas Hofstadter's notorious \"Q-series\":\n\n# Q(1) = Q(2) = 1\n# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), for n>2\n\n#  This is a \"chaotic\" integer series with strange\n#+ and unpredictable behavior.\n#  The first 20 terms of the series are:\n#  1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12 \n\n#  See Hofstadter's book, _Goedel, Escher, Bach: An Eternal Golden Braid_,\n#+ p. 137, ff.\n\nLIMIT=100     # Number of terms to calculate.\nLINEWIDTH=20  # Number of terms printed per line.\n\nQ[1]=1        # First two terms of series are 1.\nQ[2]=1\n\necho\necho \"Q-series [$LIMIT terms]:\"\necho -n \"${Q[1]} \"             # Output first two terms.\necho -n \"${Q[2]} \"\n\nfor ((n=3; n <= $LIMIT; n++))  # C-like loop expression.\ndo   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  for n>2\n#    Need to break the expression into intermediate terms,\n#+   since Bash doesn't handle complex array arithmetic very well.\n\n  let \"n1 = $n - 1\"        # n-1\n  let \"n2 = $n - 2\"        # n-2\n\n  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]\n  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]\n\n  T0=${Q[t0]}              # Q[n - Q[n-1]]\n  T1=${Q[t1]}              # Q[n - Q[n-2]]\n\nQ[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]\necho -n \"${Q[n]} \"\n\nif [ `expr $n % $LINEWIDTH` -eq 0 ]    # Format output.\nthen   #      ^ modulo\n  echo # Break lines into neat chunks.\nfi\n\ndone\n\necho\n\nexit 0\n\n#  This is an iterative implementation of the Q-series.\n#  The more intuitive recursive implementation is left as an exercise.\n#  Warning: calculating this series recursively takes a VERY long time\n#+ via a script. C/C++ would be orders of magnitude faster.\n```", "```sh #!/bin/bash\n# twodim.sh: Simulating a two-dimensional array.\n\n# A one-dimensional array consists of a single row.\n# A two-dimensional array stores rows sequentially.\n\nRows=5\nColumns=5\n# 5 X 5 Array.\n\ndeclare -a alpha     # char alpha [Rows] [Columns];\n                     # Unnecessary declaration. Why?\n\nload_alpha ()\n{\nlocal rc=0\nlocal index\n\nfor i in A B C D E F G H I J K L M N O P Q R S T U V W X Y\ndo     # Use different symbols if you like.\n  local row=`expr $rc / $Columns`\n  local column=`expr $rc % $Rows`\n  let \"index = $row * $Rows + $column\"\n  alpha[$index]=$i\n# alpha[$row][$column]\n  let \"rc += 1\"\ndone  \n\n#  Simpler would be\n#+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )\n#+ but this somehow lacks the \"flavor\" of a two-dimensional array.\n}\n\nprint_alpha ()\n{\nlocal row=0\nlocal index\n\necho\n\nwhile [ \"$row\" -lt \"$Rows\" ]   #  Print out in \"row major\" order:\ndo                             #+ columns vary,\n                               #+ while row (outer loop) remains the same.\n  local column=0\n\n  echo -n \"       \"            #  Lines up \"square\" array with rotated one.\n\n  while [ \"$column\" -lt \"$Columns\" ]\n  do\n    let \"index = $row * $Rows + $column\"\n    echo -n \"${alpha[index]} \"  # alpha[$row][$column]\n    let \"column += 1\"\n  done\n\n  let \"row += 1\"\n  echo\n\ndone  \n\n# The simpler equivalent is\n#     echo ${alpha[*]} &#124; xargs -n $Columns\n\necho\n}\n\nfilter ()     # Filter out negative array indices.\n{\n\necho -n \"  \"  # Provides the tilt.\n              # Explain how.\n\nif [[ \"$1\" -ge 0 &&  \"$1\" -lt \"$Rows\" && \"$2\" -ge 0 && \"$2\" -lt \"$Columns\" ]]\nthen\n    let \"index = $1 * $Rows + $2\"\n    # Now, print it rotated.\n    echo -n \" ${alpha[index]}\"\n    #           alpha[$row][$column]\nfi    \n\n}\n\nrotate ()  #  Rotate the array 45 degrees --\n{          #+ \"balance\" it on its lower lefthand corner.\nlocal row\nlocal column\n\nfor (( row = Rows; row > -Rows; row-- ))\n  do       # Step through the array backwards. Why?\n\n  for (( column = 0; column < Columns; column++ ))\n  do\n\n    if [ \"$row\" -ge 0 ]\n    then\n      let \"t1 = $column - $row\"\n      let \"t2 = $column\"\n    else\n      let \"t1 = $column\"\n      let \"t2 = $column + $row\"\n    fi  \n\n    filter $t1 $t2   # Filter out negative array indices.\n                     # What happens if you don't do this?\n  done\n\n  echo; echo\n\ndone \n\n#  Array rotation inspired by examples (pp. 143-146) in\n#+ \"Advanced C Programming on the IBM PC,\" by Herbert Mayer\n#+ (see bibliography).\n#  This just goes to show that much of what can be done in C\n#+ can also be done in shell scripting.\n\n}\n\n#--------------- Now, let the show begin. ------------#\nload_alpha     # Load the array.\nprint_alpha    # Print it out.  \nrotate         # Rotate it 45 degrees counterclockwise.\n#-----------------------------------------------------#\n\nexit 0\n\n# This is a rather contrived, not to mention inelegant simulation.\n\n# Exercises:\n# ---------\n# 1)  Rewrite the array loading and printing functions\n#     in a more intuitive and less kludgy fashion.\n#\n# 2)  Figure out how the array rotation functions work.\n#     Hint: think about the implications of backwards-indexing an array.\n#\n# 3)  Rewrite this script to handle a non-square array,\n#     such as a 6 X 4 one.\n#     Try to minimize \"distortion\" when the array is rotated.\n```"]