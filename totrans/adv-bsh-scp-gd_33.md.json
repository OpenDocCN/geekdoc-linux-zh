["```sh #!/bin/bash\n# ind-ref.sh: Indirect variable referencing.\n# Accessing the contents of the contents of a variable.\n\n# First, let's fool around a little.\n\nvar=23\n\necho \"\\$var   = $var\"           # $var   = 23\n# So far, everything as expected. But ...\n\necho \"\\$\\$var  = $$var\"         # $$var  = 4570var\n#  Not useful ...\n#  \\$\\$ expanded to PID of the script\n#  -- refer to the entry on the $$ variable --\n#+ and \"var\" is echoed as plain text.\n#  (Thank you, Jakob Bohm, for pointing this out.)\n\necho \"\\\\\\$\\$var = \\$$var\"       # \\$$var = $23\n#  As expected. The first $ is escaped and pasted on to\n#+ the value of var ($var = 23 ).\n#  Meaningful, but still not useful. \n\n# Now, let's start over and do it the right way.\n\n# ============================================== #\n\na=letter_of_alphabet   # Variable \"a\" holds the name of another variable.\nletter_of_alphabet=z\n\necho\n\n# Direct reference.\necho \"a = $a\"          # a = letter_of_alphabet\n\n# Indirect reference.\n  eval a=\\$$a\n# ^^^        Forcing an eval(uation), and ...\n#        ^   Escaping the first $ ...\n# ------------------------------------------------------------------------\n# The 'eval' forces an update of $a, sets it to the updated value of \\$$a.\n# So, we see why 'eval' so often shows up in indirect reference notation.\n# ------------------------------------------------------------------------\n  echo \"Now a = $a\"    # Now a = z\n\necho\n\n# Now, let's try changing the second-order reference.\n\nt=table_cell_3\ntable_cell_3=24\necho \"\\\"table_cell_3\\\" = $table_cell_3\"            # \"table_cell_3\" = 24\necho -n \"dereferenced \\\"t\\\" = \"; eval echo \\$$t    # dereferenced \"t\" = 24\n# In this simple case, the following also works (why?).\n#         eval t=\\$$t; echo \"\\\"t\\\" = $t\"\n\necho\n\nt=table_cell_3\nNEW_VAL=387\ntable_cell_3=$NEW_VAL\necho \"Changing value of \\\"table_cell_3\\\" to $NEW_VAL.\"\necho \"\\\"table_cell_3\\\" now $table_cell_3\"\necho -n \"dereferenced \\\"t\\\" now \"; eval echo \\$$t\n# \"eval\" takes the two arguments \"echo\" and \"\\$$t\" (set equal to $table_cell_3)\n\necho\n\n# (Thanks, Stephane Chazelas, for clearing up the above behavior.)\n\n#   A more straightforward method is the ${!t} notation, discussed in the\n#+ \"Bash, version 2\" section.\n#   See also ex78.sh.\n\nexit 0\n```", "```sh #!/bin/bash\n\n# ---------------------------------------------\n# This could be \"sourced\" from a separate file.\nisdnMyProviderRemoteNet=172.16.0.100\nisdnYourProviderRemoteNet=10.0.0.10\nisdnOnlineService=\"MyProvider\"\n# ---------------------------------------------\n\nremoteNet=$(eval \"echo \\$$(echo isdn${isdnOnlineService}RemoteNet)\")\nremoteNet=$(eval \"echo \\$$(echo isdnMyProviderRemoteNet)\")\nremoteNet=$(eval \"echo \\$isdnMyProviderRemoteNet\")\nremoteNet=$(eval \"echo $isdnMyProviderRemoteNet\")\n\necho \"$remoteNet\"    # 172.16.0.100\n\n# ================================================================\n\n#  And, it gets even better.\n\n#  Consider the following snippet given a variable named getSparc,\n#+ but no such variable getIa64:\n\nchkMirrorArchs () { \n  arch=\"$1\";\n  if [ \"$(eval \"echo \\${$(echo get$(echo -ne $arch &#124;\n       sed 's/^\\(.\\).*/\\1/g' &#124; tr 'a-z' 'A-Z'; echo $arch &#124;\n       sed 's/^.\\(.*\\)/\\1/g')):-false}\")\" = true ]\n  then\n     return 0;\n  else\n     return 1;\n  fi;\n}\n\ngetSparc=\"true\"\nunset getIa64\nchkMirrorArchs sparc\necho $?        # 0\n               # True\n\nchkMirrorArchs Ia64\necho $?        # 1\n               # False\n\n# Notes:\n# -----\n# Even the to-be-substituted variable name part is built explicitly.\n# The parameters to the chkMirrorArchs calls are all lower case.\n# The variable name is composed of two parts: \"get\" and \"Sparc\" . . .\n```", "```sh #!/bin/bash\n\n#  Another version of the \"column totaler\" script\n#+ that adds up a specified column (of numbers) in the target file.\n#  This one uses indirect references.\n\nARGS=2\nE_WRONGARGS=85\n\nif [ $# -ne \"$ARGS\" ] # Check for proper number of command-line args.\nthen\n   echo \"Usage: `basename $0` filename column-number\"\n   exit $E_WRONGARGS\nfi\n\nfilename=$1         # Name of file to operate on.\ncolumn_number=$2    # Which column to total up.\n\n#===== Same as original script, up to this point =====#\n\n# A multi-line awk script is invoked by\n#   awk \"\n#   ...\n#   ...\n#   ...\n#   \"\n\n# Begin awk script.\n# -------------------------------------------------\nawk \"\n\n{ total += \\$${column_number} # Indirect reference\n}\nEND {\n     print total\n     }\n\n     \" \"$filename\"\n# Note that awk doesn't need an eval preceding \\$$.\n# -------------------------------------------------\n# End awk script.\n\n#  Indirect variable reference avoids the hassles\n#+ of referencing a shell variable within the embedded awk script.\n#  Thanks, Stephane Chazelas.\n\nexit $?\n```"]