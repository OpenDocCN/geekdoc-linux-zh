["```sh\n#!/bin/bash\n\necho \"Hello $USER\"\necho \"Today is $(date -u +%A)\"\necho 'Have a nice day' \n```", "```sh\n$ chmod +x hello.sh\n\n$ ./hello.sh\nHello learnbyexample\nToday is Wednesday\nHave a nice day \n```", "```sh\n$ cat greeting.sh\necho 'hello'\necho 'have a nice day'\n\n$ bash greeting.sh\nhello\nhave a nice day \n```", "```sh\n$ cat prev_cmd.sh\nprev=$(fc -ln -2 | sed 's/^\\s*//; q')\necho \"$prev\"\n\n# 'echo' here is just a sample command for illustration purposes\n$ echo 'hello'\nhello\n# sourcing the script correctly gives the previous command\n$ source prev_cmd.sh\necho 'hello'\n\n$ echo 'hello'\nhello\n# no output when the script is executed in a sub-shell\n$ bash prev_cmd.sh \n```", "```sh\n$ cat comments.sh\n# this is a comment on its own line\necho 'hello' # and this is a comment after a command\n\n$ bash comments.sh\nhello \n```", "```sh\n# note that there cannot be any space characters around the = operator\n$ name='learnbyexample'\n\n$ echo \"$name\"\nlearnbyexample \n```", "```sh\n$ colors='blue'\n$ echo \"$colors\"\nblue\n\n$ colors+=' green'\n$ echo \"$colors\"\nblue green \n```", "```sh\n$ declare -i num=5\n$ echo \"$num\"\n5\n$ num+=42\n$ echo \"$num\"\n47\n\n$ declare -r color='brown'\n$ echo \"$color\"\nbrown\n$ color+=' green'\nbash: color: readonly variable \n```", "```sh\n> $ num = 42\n> num: command not found\n> \n> $ greeting=hello world\n> world: command not found\n> $ greeting='hello world'\n> $ echo \"$greeting\"\n> hello world\n> \n> # using quotes is NOT desirable here\n> $ dir_path=~/reports\n> $ echo \"$dir_path\"\n> /home/learnbyexample/reports\n> $ dir_path='~/reports'\n> $ echo \"$dir_path\"\n> ~/reports \n> ```", "```sh\n$ fruits=('apple' 'fig' 'mango')\n\n# first element\n$ echo \"${fruits[0]}\"\napple\n\n# last element\n$ echo \"${fruits[-1]}\"\nmango\n\n# all elements (example with for loop will be discussed later on)\n$ echo \"${fruits[@]}\"\napple fig mango\n$ printf '%s\\n' \"${fruits[@]}\"\napple\nfig\nmango \n```", "```sh\n$ city='Lucknow'\n\n# all characters from index 4 onwards\n# indexing starts from 0\n$ echo \"${city:4}\"\nnow\n\n# last two characters\n# space before the negative sign is compulsory here,\n# since ${parameter:-word} is a different feature\n$ echo \"${city: -2}\"\now \n```", "```sh\n$ fruits=('apple' 'fig' 'mango')\n\n# all elements from index 1\n$ echo \"${fruits[@]:1}\"\nfig mango \n```", "```sh\n$ city='Lucknow'\n\n# 4 characters starting from index 0\n# can also use: echo \"${city::4}\"\n$ echo \"${city:0:4}\"\nLuck\n\n# 2 characters starting from index -4 (4th character from the end)\n$ echo \"${city: -4:2}\"\nkn\n\n# except the last 2 characters\n$ echo \"${city::-2}\"\nLuckn \n```", "```sh\n$ city='Lucknow'\n$ echo \"${#city}\"\n7\n\n$ fruits=('apple' 'fig' 'mango')\n$ echo \"${#fruits[@]}\"\n3 \n```", "```sh\n$ s='this is his life history'\n\n# shortest match is deleted\n$ echo \"${s#*is}\"\n is his life history\n# longest match is deleted\n$ echo \"${s##*is}\"\ntory\n\n# assuming extglob is already enabled\n$ echo \"${s#+([^ ])}\"\nhis is his life history\n$ echo \"${s##+([^ ])}\"\n is his life history\n\n# for arrays, the processing is applied to each element\n$ fruits=('apple' 'fig' 'mango')\n$ echo \"${fruits[@]#*[aeiou]}\"\npple g ngo \n```", "```sh\n$ s='this is his life history'\n\n$ echo \"${s%is*}\"\nthis is his life h\n$ echo \"${s%%is*}\"\nth\n\n$ fruits=('apple' 'fig' 'mango')\n$ echo \"${fruits[@]%[aeiou]*}\"\nappl f mang \n```", "```sh\n$ ip='this is a sample string'\n\n# first occurrence of 'is' is replaced with '123'\n$ echo \"${ip/is/123}\"\nth123 is a sample string\n# all occurrences of 'is' are replaced with '123'\n$ echo \"${ip//is/123}\"\nth123 123 a sample string\n\n# replace all occurrences of 'am' or 'in' with '-'\n$ echo \"${ip//@(am|in)/-}\"\nthis is a s-ple str-g\n\n# matches from the first 'is' to the last 's' in the input\n$ echo \"${ip/is*s/ X }\"\nth X tring\n\n# delete the first occurrence of 's'\n$ echo \"${ip/s}\"\nthi is a sample string\n# delete all the occurrences of 's'\n$ echo \"${ip//s}\"\nthi i a ample tring \n```", "```sh\n$ ip='spare'\n\n# remove only from the start of the string\n$ echo \"${ip/#sp}\"\nare\n$ echo \"${ip/#par}\"\nspare\n# example with replacement string\n$ echo \"${ip/#sp/fl}\"\nflare\n\n# remove only from the end of the string\n$ echo \"${ip/%re}\"\nspa\n$ echo \"${ip/%par}\"\nspare \n```", "```sh\n$ fruit='apple'\n\n# uppercase the first character\n$ echo \"${fruit^}\"\nApple\n# uppercase the entire parameter\n$ echo \"${fruit^^}\"\nAPPLE\n\n# first character doesn't match the 'g-z' range, so no change\n$ echo \"${fruit^[g-z]}\"\napple\n# uppercase all letters in the 'g-z' range\n$ echo \"${fruit^^[g-z]}\"\naPPLe\n# uppercase all letters in the 'a-e' or 'j-m' ranges\n$ echo \"${fruit^^[a-ej-m]}\"\nAppLE\n\n# this won't work since 'sky-' is not a single character\n$ color='sky-rose'\n$ echo \"${color^^*-}\"\nsky-rose \n```", "```sh\n$ fruit='APPLE'\n\n$ echo \"${fruit,}\"\naPPLE\n$ echo \"${fruit,,}\"\napple\n\n$ echo \"${fruit,,[G-Z]}\"\nApplE \n```", "```sh\n$ fruit='aPPle'\n\n# swap case only the first character\n$ echo \"${fruit~}\"\nAPPle\n# swap case all the characters\n$ echo \"${fruit~~}\"\nAppLE\n\n# swap case characters matching the given character set\n$ echo \"${fruit~~[g-zG-Z]}\"\nappLe \n```", "```sh\n$ cat command_line_arguments.sh\necho \"No. of lines in '$1' is $(wc -l < \"$1\")\"\necho \"No. of lines in '$2' is $(wc -l < \"$2\")\"\n\n$ seq 12 > 'test file.txt'\n\n$ bash command_line_arguments.sh hello.sh test\\ file.txt\nNo. of lines in 'hello.sh' is 5\nNo. of lines in 'test file.txt' is 12 \n```", "```sh\n# change to the 'example_files/shell_scripting' directory for this section\n\n$ [[ -e hello.sh ]] && echo 'found' || echo 'not found'\nfound\n\n$ [[ -e xyz.txt ]] && echo 'found' || echo 'not found'\nnot found\n\n# exit status\n$ [[ -e hello.sh ]] ; echo $?\n0\n$ [[ -e xyz.txt ]] ; echo $?\n1\n$ [[ ! -e xyz.txt ]] ; echo $?\n0 \n```", "```sh\n$ fruit='apple'\n$ [[ $fruit == 'apple' ]] && echo 'true' || echo 'false'\ntrue\n$ [[ $fruit == 'banana' ]] && echo 'true' || echo 'false'\nfalse\n\n# glob should be constructed to match the entire string\n$ [[ hello == h* ]] && echo 'true' || echo 'false'\ntrue\n# don't quote the glob!\n$ [[ hello == 'h*' ]] && echo 'true' || echo 'false'\nfalse\n\n# another example to emphasize that the glob should match the entire string\n$ [[ hello == e*o ]] && echo 'true' || echo 'false'\nfalse\n$ [[ hello == *e*o ]] && echo 'true' || echo 'false'\ntrue\n\n$ [[ hello != *a* ]] && echo 'true' || echo 'false'\ntrue\n$ [[ hello != *e* ]] && echo 'true' || echo 'false'\nfalse \n```", "```sh\n$ [[ apple < banana ]] && echo 'true' || echo 'false'\ntrue\n$ [[ par < part ]] && echo 'true' || echo 'false'\ntrue\n\n$ [[ mango > banana ]] && echo 'true' || echo 'false'\ntrue\n$ [[ sun > moon && fig < papaya ]] && echo 'true' || echo 'false'\ntrue\n\n# don't use this to compare numbers!\n$ [[ 20 > 3 ]] && echo 'true' || echo 'false'\nfalse\n# -gt and other such operators will be discussed later\n$ [[ 20 -gt 3 ]] && echo 'true' || echo 'false'\ntrue \n```", "```sh\n$ fruit='apple'\n$ [[ $fruit =~ ^a ]] && echo 'true' || echo 'false'\ntrue\n$ [[ $fruit =~ ^b ]] && echo 'true' || echo 'false'\nfalse\n\n# entire matched portion\n$ [[ $fruit =~ a.. ]] && echo \"${BASH_REMATCH[0]}\"\napp\n# portion matched by the first capture group\n$ [[ $fruit =~ a(..) ]] && echo \"${BASH_REMATCH[1]}\"\npp \n```", "```sh\n$ [[ 20 -gt 3 ]] && echo 'true' || echo 'false'\ntrue\n\n$ n1='42'\n$ n2='25'\n$ [[ $n1 -gt 30 && $n2 -lt 12 ]] && echo 'true' || echo 'false'\nfalse \n```", "```sh\n$ (( 20 > 3 )) && echo 'true' || echo 'false'\n\n$ n1='42'\n$ n2='25'\n$ (( n1 > 30 && n2 < 12 )) && echo 'true' || echo 'false'\nfalse \n```", "```sh\n# press 'Enter' after the 'read' command\n# and also after you've finished entering the input\n$ read color\nlight green\n$ echo \"$color\"\nlight green\n\n# example with multiple variables\n$ read fruit qty\napple 10\n$ echo \"${fruit}: ${qty}\"\napple: 10 \n```", "```sh\n$ cat user_input.sh\nread -p 'Enter two integers separated by spaces: ' num1 num2\nsum=$(( num1 + num2 ))\necho \"$num1 + $num2 = $sum\"\n\n$ bash user_input.sh\nEnter two integers separated by spaces: -2 42\n-2 + 42 = 40 \n```", "```sh\n$ cat if_then_else.sh\nif (( $# != 1 )) ; then\n    echo 'Error! One file argument expected.' 1>&2\n    exit 1\nelse\n    if [[ ! -f $1 ]] ; then\n        printf 'Error! %q is not a valid file\\n' \"$1\" 1>&2\n        exit 1\n    else\n        echo \"No. of lines in '$1' is $(wc -l < \"$1\")\"\n    fi\nfi \n```", "```sh\n$ bash if_then_else.sh\nError! One file argument expected.\n$ echo $?\n1\n\n$ bash if_then_else.sh xyz.txt\nError! xyz.txt is not a valid file\n$ echo $?\n1\n\n$ bash if_then_else.sh hello.sh\nNo. of lines in 'hello.sh' is 5\n$ echo $?\n0 \n```", "```sh\n$ cat search.sh\nread -p 'Enter a search pattern: ' search\n\nif grep -q \"$search\" hello.sh ; then\n    echo \"match found\"\nelse\n    echo \"match not found\"\nfi \n```", "```sh\n$ bash search.sh\nEnter a search pattern: echo\nmatch found\n\n$ bash search.sh\nEnter a search pattern: xyz\nmatch not found \n```", "```sh\n# iterate over numbers generated using brace expansion\n$ for num in {2..4}; do echo \"$num\"; done\n2\n3\n4\n\n# iterate over files matched using wildcards\n# echo is used here for dry run testing\n$ for file in [gh]*.sh; do echo mv \"$file\" \"$file.bkp\"; done\nmv greeting.sh greeting.sh.bkp\nmv hello.sh hello.sh.bkp \n```", "```sh\n$ cat for_loop.sh\nfor file in \"$@\"; do\n    echo mv \"$file\" \"$file.bkp\"\ndone\n\n$ bash for_loop.sh [gh]*.sh\nmv greeting.sh greeting.sh.bkp\nmv hello.sh hello.sh.bkp\n\n$ bash for_loop.sh report.log ip.txt fruits.txt\nmv report.log report.log.bkp\nmv ip.txt ip.txt.bkp\nmv fruits.txt fruits.txt.bkp \n```", "```sh\n$ files=('report.log' 'pass_list.txt')\n$ for f in \"${files[@]}\"; do echo \"$f\"; done\nreport.log\npass_list.txt \n```", "```sh\n$ cat while_loop.sh\ni=\"$1\"\nwhile (( i > 0 )) ; do\n    echo \"$i\"\n    (( i-- ))\ndone\n\n$ bash while_loop.sh 3\n3\n2\n1 \n```", "```sh\n$ cat read_file_lines.sh\nwhile IFS= read -r line; do\n    # do something with each line\n    wc -l \"$line\"\ndone < \"$1\"\n\n$ printf 'hello.sh\\ngreeting.sh\\n' > files.txt\n$ bash read_file_lines.sh files.txt\n5 hello.sh\n2 greeting.sh \n```", "```sh\n$ cat read_file_fields.sh\nwhile IFS=' : ' read -r field1 field2; do\n    echo \"$field2,$field1\"\ndone < \"$1\"\n\n$ bash read_file_fields.sh <(printf 'apple : 3\\nfig : 100\\n')\n3,apple\n100,fig \n```", "```sh\n$ while read -r -n2 ip; do echo \"$ip\"; done <<< '\\word'\n\\w\nor\nd \n```", "```sh\nfname () compound-command [ redirections ]\n\nfunction fname [()] compound-command [ redirections ] \n```", "```sh\n$ cat functions.sh\nadd_border ()\n{\n    size='10'\n    color='grey'\n    if (( $# == 1 )) ; then\n        ip=\"$1\"\n    elif (( $# == 2 )) ; then\n        if [[ $1 =~ ^[0-9]+$ ]] ; then\n            size=\"$1\"\n        else\n            color=\"$1\"\n        fi\n        ip=\"$2\"\n    else\n        size=\"$1\"\n        color=\"$2\"\n        ip=\"$3\"\n    fi\n\n    op=\"${ip%.*}_border.${ip##*.}\"\n    echo convert -border \"$size\" -bordercolor \"$color\" \"$ip\" \"$op\"\n}\n\nadd_border flower.png\nadd_border 5 insect.png\nadd_border red lake.png\nadd_border 20 blue sky.png \n```", "```sh\n$ bash functions.sh\nconvert -border 10 -bordercolor grey flower.png flower_border.png\nconvert -border 5 -bordercolor grey insect.png insect_border.png\nconvert -border 10 -bordercolor red lake.png lake_border.png\nconvert -border 20 -bordercolor blue sky.png sky_border.png \n```", "```sh\n$ bash -x search.sh\n+ read -p 'Enter a search pattern: ' search\nEnter a search pattern: xyz\n+ grep -q xyz hello.sh\n+ echo 'match not found'\nmatch not found \n```", "```sh\n$ bash -xv search.sh\nread -p 'Enter a search pattern: ' search\n+ read -p 'Enter a search pattern: ' search\nEnter a search pattern: xyz\n\nif grep -q \"$search\" hello.sh ; then\n    echo \"match found\"\nelse\n    echo \"match not found\"\nfi\n+ grep -q xyz hello.sh\n+ echo 'match not found'\nmatch not found \n```", "```sh\n$ cat bad_script.sh\n#!/bin/bash\n\ngreeting = 'hello world'\necho \"$greeting\" \n```", "```sh\n$ shellcheck bad_script.sh\n\nIn bad_script.sh line 3:\ngreeting = 'hello world'\n         ^-- SC1068: Don't put spaces around the = in assignments\n                     (or quote to make it literal).\n\nFor more information:\n  https://www.shellcheck.net/wiki/SC1068 -- Don't put spaces around the = in ... \n```", "```sh\n$ printf '    \\n!#/bin/bash\\n\\necho hello\\n' > try.sh\n$ chmod +x try.sh\n$ ./try.sh\n./try.sh: line 2: !#/bin/bash: No such file or directory\nhello\n\n# expected output\n$ ./try.sh\nhello \n```", "```sh\n$ echo echo hello | bash \n```", "```sh\n$ fruit='banana'\n\n$ echo # ???\nbananashake \n```", "```sh\n# default behavior\n$ n=100\n$ n+=100\n$ echo \"$n\"\n100100\n\n# expected output\n$ echo \"$n\"\n200 \n```", "```sh\n$ declare -a colors\n$ colors[3]='green'\n$ colors[1]='blue'\n\n$ echo \"${colors[@]}\"\n# ??? \n```", "```sh\n$ fruit='banana'\n\n# ???\nana \n```", "```sh\n$ fruits=('apple' 'fig' 'mango')\n$ echo \"${#fruits[@]}\"\n3\n\n$ echo \"${#fruits}\"\n# ??? \n```", "```sh\n$ colors=('green' 'dark brown' 'deep sky blue white')\n\n# remove till the first space\n$ printf '%s\\n' # ???\ngreen\nbrown\nsky blue white\n\n# remove till the last space\n$ printf '%s\\n' # ???\ngreen\nbrown\nwhite \n```", "```sh\n$ ip='apple:banana:cherry:dragon'\n\n$ echo # ???\napple:banana:cherry\n\n$ echo # ???\napple \n```", "```sh\n$ ip1='apple:banana:cherry:dragon'\n$ ip2='Cradle:Mistborn:Piranesi'\n\n$ echo # ???\napple 42 dragon\n$ echo # ???\nCradle 42 Piranesi\n\n$ echo # ???\nfig:banana:cherry:dragon\n$ echo # ???\nfig:Mistborn:Piranesi\n\n$ echo # ???\napple:banana:cherry:end\n$ echo # ???\nCradle:Mistborn:end \n```", "```sh\n$ ip='This is a Sample STRING'\n\n$ echo # ???\nTHIS IS A SAMPLE STRING\n\n$ echo # ???\nthis is a sample string\n\n$ echo # ???\ntHIS IS A sAMPLE string \n```", "```sh\n$ touch ip.txt\n$ [[-f ip.txt]] && echo 'file exists'\n[[-f: command not found \n```", "```sh\n$ f1='1234.txt'\n$ f2='report_2.txt'\n\n$ [[ $f1 == '+([0-9]).txt' ]] && echo 'matched' || echo 'failed'\nfailed\n$ [[ $f2 == '+([0-9]).txt' ]] && echo 'matched' || echo 'failed'\nfailed \n```", "```sh\n$ item='chocolate:50'\n# ???\n50\n\n$ item='50 apples, fig:100, books-12'\n# ???\n100 \n```", "```sh\n$ num=12345\n$ [[ $num > 3 ]] && echo 'true' || echo 'false'\nfalse \n```", "```sh\n$ bash array.sh\nenter array elements: apple banana cherry\nenter array index: 1\nelement at index '1' is: banana\n\n$ bash array.sh\nenter array elements: dragon unicorn centaur\nenter array index: -1\nelement at index '-1' is: centaur \n```", "```sh\n$ ./case.sh upper 'how are you?'\nHOW ARE YOU?\n\n$ ./case.sh lower PineAPPLE\npineapple\n\n$ ./case.sh swap 'HeLlo WoRlD'\nhElLO wOrLd\n\n$ ./case.sh lower\nError! Two arguments expected.\n$ echo $?\n1\n\n$ ./case.sh upper apple fig\nError! Two arguments expected.\n\n$ ./case.sh lowercase DRAGON\nError! 'lowercase' command not recognized.\n$ echo $?\n1\n\n$ ./case.sh apple lower 2> /dev/null\n$ echo $?\n1 \n```", "```sh\n$ printf 'apple\\nbanana\\ncherry\\n' > items_1.txt\n$ printf 'dragon\\nowl\\nunicorn\\ntroll\\ncentaur\\n' > items_2.txt\n\n$ bash loop.sh items_1.txt\nnumber of lines in 'items_1.txt' is: 3\n\n$ bash loop.sh items_1.txt items_2.txt\nnumber of lines in 'items_1.txt' is: 3\nnumber of lines in 'items_2.txt' is: 5 \n```", "```sh\n$ printf 'apple\\nbanana\\ncherry\\n' > items_1.txt\n$ printf 'dragon\\nowl\\nunicorn\\ntroll\\ncentaur\\n' > items_2.txt\n$ printf 'items_1.txt\\nitems_2.txt\\n' > list.txt\n\n$ bash read_file.sh list.txt\napple,banana,cherry\ndragon,owl,unicorn,troll,centaur\n\n$ xargs # ???\napple,banana,cherry\ndragon,owl,unicorn,troll,centaur \n```", "```sh\n$ add_path() # ???\n\n$ cd\n$ pwd\n/home/learnbyexample\n$ add_path ip.txt report.log\n/home/learnbyexample/ip.txt /home/learnbyexample/report.log\n\n$ cd cli-computing\n$ pwd\n/home/learnbyexample/cli-computing\n$ add_path f1\n/home/learnbyexample/cli-computing/f1 \n```"]