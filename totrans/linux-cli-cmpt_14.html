<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Assorted Text Processing Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Assorted Text Processing Tools</h1>
<blockquote>原文：<a href="https://learnbyexample.github.io/cli-computing/assorted-text-processing-tools.html">https://learnbyexample.github.io/cli-computing/assorted-text-processing-tools.html</a></blockquote><p>There are way too many specialized text processing tools. This chapter will discuss some of the commands that haven't been covered in the previous chapters.</p><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> The <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files">example_files</a> directory has the sample input files used in this chapter.</p></blockquote><h2 id="seq"><a class="header" href="#seq">seq</a></h2><p>The <code>seq</code> command is a handy tool to generate a sequence of numbers in ascending or descending order. Both integer and floating-point numbers are supported. You can also customize the formatting for numbers and the separator between them.</p><p>You need three numbers to generate an arithmetic progression — <strong>start</strong>, <strong>step</strong> and <strong>stop</strong>. When you pass only a single number as the stop value, the default start and step values are assumed to be <code>1</code>. Passing two numbers are considered as start and stop values (in that order).</p><pre><code class="language-bash"># start=1, step=1 and stop=3
$ seq 3
1
2
3

# start=25434, step=1 and stop=25437
$ seq 25434 25437
25434
25435
25436
25437

# start=-5, step=1 and stop=-3
$ seq -5 -3
-5
-4
-3

# start=0.25, step=0.33 and stop=1.12
$ seq 0.25 0.33 1.12
0.25
0.58
0.91
</code></pre><p>By using a negative step value, you can generate sequences in descending order.</p><pre><code class="language-bash">$ seq 3 -1 1
3
2
1
</code></pre><p>You can use the <code>-s</code> option to change the separator <em>between</em> the numbers of a sequence. A single newline character is always the character added after the final number.</p><pre><code class="language-bash">$ seq -s' - ' 4
1 - 2 - 3 - 4

$ seq -s: 1.2e2 0.752 1.22e2
120.000:120.752:121.504
</code></pre><p>The <code>-w</code> option will equalize the width of the output numbers using leading zeros. The largest width between the start and stop values will be used.</p><pre><code class="language-bash">$ seq -w 8 10
08
09
10

$ seq -w 0003
0001
0002
0003
</code></pre><p>You can use the <code>-f</code> option for <code>printf</code> style floating-point number formatting.</p><pre><code class="language-bash">$ seq -f'%g' -s: 1 0.75 3
1:1.75:2.5

$ seq -f'%.4f' -s: 1 0.75 3
1.0000:1.7500:2.5000

$ seq -f'%.3e' 1.2e2 0.752 1.22e2
1.200e+02
1.208e+02
1.215e+02
</code></pre><h2 id="shuf"><a class="header" href="#shuf">shuf</a></h2><p>By default, <code>shuf</code> will randomize the order of input lines. You can use the <code>-n</code> option to limit the number of output lines.</p><pre><code class="language-bash">$ printf 'apple\nbanana\ncherry\nfig\nmango' | shuf
banana
cherry
mango
apple
fig

$ printf 'apple\nbanana\ncherry\nfig\nmango' | shuf -n2
mango
cherry
</code></pre><p>You can use the <code>-e</code> option to specify multiple input lines as arguments to the command. The <code>-r</code> option helps if you want to allow input lines to be repeated. This option is usually paired with <code>-n</code> to limit the number of lines in the output.</p><pre><code class="language-bash">$ shuf -n4 -r -e brown green blue
green
brown
blue
green
</code></pre><p>The <code>-i</code> option will help you generate random positive integers.</p><pre><code class="language-bash">$ shuf -n3 -i 100-200
170
112
148
</code></pre><h2 id="cut"><a class="header" href="#cut">cut</a></h2><p><code>cut</code> is a handy tool for many field processing use cases. The features are limited compared to the <code>awk</code> and <code>perl</code> commands, but the reduced scope also leads to faster processing.</p><p>By default, <code>cut</code> splits the input content into fields based on the tab character, which you can change using the <code>-d</code> option. The <code>-f</code> option allows you to select a desired field from each input line. To extract multiple fields, specify the selections separated by the comma character. By default, lines not containing the input delimiter will still be part of the output. You can use the <code>-s</code> option to suppress such lines.</p><pre><code class="language-bash"># second field
$ printf 'apple\tbanana\tcherry\n' | cut -f2
banana

# first and third fields
$ printf 'apple\tbanana\tcherry\n' | cut -f1,3
apple   cherry

# setting -d automatically changes the output delimiter as well
$ echo 'one;two;three;four;five' | cut -d';' -f2,5
two;five
</code></pre><p>You can use the <code>-</code> character to specify field ranges. The starting or ending field number can be skipped, but not both.</p><pre><code class="language-bash"># 2nd, 3rd and 4th fields
$ printf 'apple\tbanana\tcherry\tdates\n' | cut -f2-4
banana  cherry  dates

# all fields from the start till the 3rd field
$ printf 'apple\tbanana\tcherry\tdates\n' | cut -f-3
apple   banana  cherry

# 1st field and all fields from the 3rd field till the end
$ printf 'apple\tbanana\tcherry\tdates\n' | cut -f1,3-
apple   cherry  dates
</code></pre><p>Use the <code>--output-delimiter</code> option to customize the output separator to any string of your choice.</p><pre><code class="language-bash"># same as: tr '\t' ','
$ printf 'apple\tbanana\tcherry\n' | cut --output-delimiter=, -f1-
apple,banana,cherry

# multicharacter example
$ echo 'one;two;three;four' | cut -d';' --output-delimiter=' : ' -f1,3-
one : three : four
</code></pre><p>The <code>--complement</code> option allows you to invert the field selections.</p><pre><code class="language-bash"># except the second field
$ printf 'apple ball cat\n1 2 3 4 5' | cut --complement -d' ' -f2
apple cat
1 3 4 5

# except the first and third fields
$ printf 'apple ball cat\n1 2 3 4 5' | cut --complement -d' ' -f1,3
ball
2 4 5
</code></pre><p>You can use the <code>-b</code> or <code>-c</code> options to select specified bytes from each input line. The syntax is same as the <code>-f</code> option. The <code>-c</code> option is intended for multibyte character selection, but for now it works exactly as the <code>-b</code> option.</p><pre><code class="language-bash">$ printf 'apple\tbanana\tcherry\n' | cut -c2,8,11
pan

$ printf 'apple\tbanana\tcherry\n' | cut -c2,8,11 --output-delimiter=-
p-a-n

$ printf 'apple\tbanana\tcherry\n' | cut --complement -c13-
apple   banana

$ printf 'cat-bat\ndog:fog' | cut -c5-
bat
fog
</code></pre><h2 id="column"><a class="header" href="#column">column</a></h2><p>The <code>column</code> command is a nifty tool to align the input data column wise. By default, whitespace is used as the input delimiter. Space character is used to align the output columns, so whitespace characters like tab will get converted to spaces.</p><pre><code class="language-bash">$ printf 'one two three\nfour five six\nseven eight nine\n'
one two three
four five six
seven eight nine

$ printf 'one two three\nfour five six\nseven eight nine\n' | column -t
one    two    three
four   five   six
seven  eight  nine
</code></pre><p>You can use the <code>-s</code> option to customize the input delimiter. Note that the output delimiter will still be made up of spaces only.</p><pre><code class="language-bash">$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

$ column -s, -t scores.csv
Name  Maths  Physics  Chemistry
Ith   100    100      100
Cy    97     98       95
Lin   78     83       80

$ printf '1:-:2:-:3\napple:-:banana:-:cherry\n' | column -s:-: -t
1      2       3
apple  banana  cherry
</code></pre><blockquote><p><img alt="warning" src="../Images/b5314b4a0acf0f436c4bf59486793342.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/warning.svg"/> Input should have a newline at the end, otherwise you'll get an error:</p><pre><code class="language-bash">$ printf '1 2 3\na   b   c' | column -t
column: line too long
1  2  3
</code></pre></blockquote><h2 id="tr"><a class="header" href="#tr">tr</a></h2><p><code>tr</code> helps you to map one set of characters to another set of characters. Features like range, repeats, character sets, squeeze, complement, etc makes it a must know text processing tool.</p><p><code>tr</code> works only on <code>stdin</code> data, so you'll need to use shell input redirection for file input. Here are some basic examples:</p><pre><code class="language-bash"># 'l' maps to '1', 'e' to '3', 't' to '7' and 's' to '5'
$ echo 'leet speak' | tr 'lets' '1375'
1337 5p3ak

# example with shell metacharacters
$ echo 'apple;banana;cherry' | tr ';' ':'
apple:banana:cherry

# swap case
$ echo 'Hello World' | tr 'a-zA-Z' 'A-Za-z'
hELLO wORLD

$ tr 'a-z' 'A-Z' &amp;LTgreeting.txt
HI THERE
HAVE A NICE DAY
</code></pre><p>You can use the <code>-d</code> option to specify a set of characters to be deleted. The <code>-c</code> option will invert the first set of characters. Here are some examples:</p><pre><code class="language-bash">$ echo '2021-08-12' | tr -d '-'
20210812

$ s='"Hi", there! How *are* you? All fine here.'
$ echo "$s" | tr -d '[:punct:]'
Hi there How are you All fine here

# retain alphabets, whitespaces, period, exclamation and question mark
$ echo "$s" | tr -cd 'a-zA-Z.!?[:space:]'
Hi there! How are you? All fine here.
</code></pre><p>The <code>-s</code> option changes consecutive repeated characters to a single copy of that character.</p><pre><code class="language-bash"># squeeze lowercase alphabets
$ echo 'HELLO... hhoowwww aaaaaareeeeee yyouuuu!!' | tr -s 'a-z'
HELLO... how are you!!

# translate and squeeze
$ echo 'hhoowwww aaaaaareeeeee yyouuuu!!' | tr -s 'a-z' 'A-Z'
HOW ARE YOU!!

# delete and squeeze
$ echo 'hhoowwww aaaaaareeeeee yyouuuu!!' | tr -sd '!' 'a-z'
how are you

# squeeze other than lowercase alphabets
$ echo 'apple    noon     banana!!!!!' | tr -cs 'a-z'
apple noon banana!
</code></pre><h2 id="paste"><a class="header" href="#paste">paste</a></h2><p><code>paste</code> is typically used to merge two or more files column wise. It also has a handy feature for serializing data. By default, <code>paste</code> adds a tab character between the corresponding lines of input files.</p><pre><code class="language-bash">$ cat colors_1.txt
Blue
Brown
Orange
Purple
$ cat colors_2.txt
Black
Blue
Green
Orange

$ paste colors_1.txt colors_2.txt
Blue    Black
Brown   Blue
Orange  Green
Purple  Orange
</code></pre><p>You can use the <code>-d</code> option to change the delimiter between the columns. The separator is added even if the data has been exhausted for some of the input files.</p><pre><code class="language-bash">$ paste -d'|' &lt;(seq 3) &lt;(seq 4 5) &lt;(seq 6 8)
1|4|6
2|5|7
3||8

# note that the space between -d and the empty string is necessary here
$ paste -d '' &lt;(seq 3) &lt;(seq 6 8)
16
27
38

$ paste -d'\n' &lt;(seq 11 12) &lt;(seq 101 102)
11
101
12
102
</code></pre><p>You can use empty files to get multicharacter separation between the columns.</p><pre><code class="language-bash">$ paste -d' : ' &lt;(seq 3) /dev/null /dev/null &lt;(seq 4 6)
1 : 4
2 : 5
3 : 6
</code></pre><p>If you use <code>-</code> multiple times, <code>paste</code> will consume a line from <code>stdin</code> data every time <code>-</code> is encountered. This is different from using the same filename multiple times, in which case they are treated as separate inputs.</p><pre><code class="language-bash"># five columns
$ seq 10 | paste -d: - - - - -
1:2:3:4:5
6:7:8:9:10

# use redirection for file input
$ &amp;LTcolors_1.txt paste -d: - - -
Blue:Brown:Orange
Purple::
</code></pre><p>The <code>-s</code> option allows you to combine all the input lines from a file into a single line using the given delimiter. Multiple input files are treated separately. <code>paste</code> will ensure to add a final newline character even if it isn't present in the input.</p><pre><code class="language-bash"># &amp;LTcolors_1.txt tr '\n' ',' will give you a trailing comma
$ paste -sd, colors_1.txt
Blue,Brown,Orange,Purple

# multiple file example
$ paste -sd: colors_1.txt colors_2.txt
Blue:Brown:Orange:Purple
Black:Blue:Green:Orange
</code></pre><h2 id="pr"><a class="header" href="#pr">pr</a></h2><blockquote><p>Paginate or columnate FILE(s) for printing.</p></blockquote><p>As stated in the above quote from the manual, the <code>pr</code> command is mainly used for those two tasks. This section will discuss only the columnate features and some miscellaneous tasks. Here's a pagination example if you are interested in exploring further. The <code>pr</code> command will add blank lines, a header and so on to make it suitable for printing.</p><pre><code class="language-bash">$ pr greeting.txt | head -n8


2024-05-17 10:48                   greeting.txt                   Page 1


Hi there
Have a nice day

</code></pre><p>The <code>--columns</code> and <code>-a</code> options can be used to merge the input lines in two different ways:</p><ul><li>split the input file and then merge them as columns</li><li>merge consecutive lines, similar to the <code>paste</code> command</li></ul><p>Here's an example to get started. Note that <code>-N</code> is same as using <code>--columns=N</code> where <code>N</code> is the number of columns you want in the output. The default page width is <code>72</code>, which means each column can only have a maximum of <code>72/N</code> characters (including the separator). Tab and space characters will be used to fill the columns as needed. You can use the <code>-J</code> option to prevent <code>pr</code> from truncating longer columns. The <code>-t</code> option is used here to turn off the pagination features.</p><pre><code class="language-bash"># split input into three parts
# each column width is 72/3 = 24 characters max
$ seq 9 | pr -3t
1                       4                       7
2                       5                       8
3                       6                       9
</code></pre><p>You can customize the separator using the <code>-s</code> option. The default is a tab character which you can change to any other string value. The <code>-s</code> option also turns off line truncation, so the <code>-J</code> option isn't needed. Use the <code>-a</code> option to merge consecutive lines, similar to the <code>paste</code> command example seen earlier.</p><pre><code class="language-bash"># tab is the default separator when no argument is passed to the -s option
$ seq 9 | pr -3ts
1       4       7
2       5       8
3       6       9

# multicharacter custom separator example
$ seq 9 | pr -3ats' : '
1 : 2 : 3
4 : 5 : 6
7 : 8 : 9

# unlike paste, pr doesn't add separators if the last row has less columns to fill
$ seq 10 | pr -4ats,
1,2,3,4
5,6,7,8
9,10
</code></pre><p>However, the default page width of <code>72</code> can still cause issues, which you can prevent by using the <code>-w</code> option. The <code>-w</code> option overrides the effect of the <code>-s</code> option on line truncation, so use the <code>-J</code> option as well unless you really need truncation.</p><pre><code class="language-bash">$ seq 6 | pr -J -w10 -3ats'::::'
pr: page width too narrow

$ seq 6 | pr -J -w11 -3ats'::::'
1::::2::::3
4::::5::::6
</code></pre><p>Two or more input files can be merged column wise using the <code>-m</code> option. As seen before, the <code>-t</code> option is needed to ignore pagination features and <code>-s</code> can be used to customize the separator.</p><pre><code class="language-bash"># same as: paste -d' : ' &lt;(seq 3) /dev/null /dev/null &lt;(seq 4 6)
$ pr -mts' : ' &lt;(seq 3) &lt;(seq 4 6)
1 : 4
2 : 5
3 : 6
</code></pre><h2 id="rev"><a class="header" href="#rev">rev</a></h2><p>The <code>rev</code> command reverses each input line character wise. The newline character <em>won't</em> be added to the end if it wasn't present in the input. Here are some examples:</p><pre><code class="language-bash">$ echo 'This is a sample text' | rev
txet elpmas a si sihT

$ printf 'apple\nbanana\ncherry\n' | rev
elppa
ananab
yrrehc

$ printf 'malayalam\nnoon\n' | rev
malayalam
noon
</code></pre><h2 id="split"><a class="header" href="#split">split</a></h2><p>The <code>split</code> command is useful to divide the input into smaller parts based on the number of lines, bytes, file size, etc. You can also execute another command on the divided parts before saving the results. An example use case is sending a large file as multiple parts as a workaround for online transfer size limits.</p><p>By default, the <code>split</code> command divides the input <code>1000</code> lines at a time. Newline character is the default line separator. You can pass a single file or <code>stdin</code> data as the input. Use <code>cat</code> if you need to concatenate multiple input sources. By default, the output files will be named <code>xaa</code>, <code>xab</code>, <code>xac</code> and so on (where <code>x</code> is the prefix). If the filenames are exhausted, two more letters will be appended and the pattern will continue as needed. If the number of input lines is not evenly divisible, the last file will contain less than <code>1000</code> lines.</p><pre><code class="language-bash"># divide input 1000 lines at a time
$ seq 10000 | split

# output filenames
$ ls x*
xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj

# preview of some of the output files
$ head -n1 xaa xab xae xaj
==&gt; xaa &lt;==
1

==&gt; xab &lt;==
1001

==&gt; xae &lt;==
4001

==&gt; xaj &lt;==
9001
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> For more examples, customization options and other details, see the <a href="https://learnbyexample.github.io/cli_text_processing_coreutils/split.html">split chapter</a> from my <a href="https://github.com/learnbyexample/cli_text_processing_coreutils">CLI text processing with GNU Coreutils</a> ebook.</p></blockquote><h2 id="csplit"><a class="header" href="#csplit">csplit</a></h2><p>The <code>csplit</code> command is useful to divide the input into smaller parts based on line numbers and regular expression patterns.</p><p>You can split the input into two based on a particular line number. To do so, specify the line number after the input source (filename or <code>stdin</code> data). The first output file will have the input lines <em>before</em> the given line number and the second output file will have the rest of the contents. By default, the output files will be named <code>xx00</code>, <code>xx01</code>, <code>xx02</code> and so on (where <code>xx</code> is the prefix). The numerical suffix will automatically use more digits if needed.</p><pre><code class="language-bash"># split input into two based on line number 2
# the -q option suppresses output showing number of bytes written for each file
$ seq 4 | csplit -q - 2

# first output file will have the first line
# second output file will have the rest
$ head xx*
==&gt; xx00 &lt;==
1

==&gt; xx01 &lt;==
2
3
4
</code></pre><p>You can also split the input based on a line matching the given regular expression. The output produced will vary based on the <code>//</code> or <code>%%</code> delimiters being used to surround the regexp. When <code>/regexp/</code> is used, output is similar to the line number based splitting. The first output file will have the input lines <em>before</em> the first occurrence of a line matching the given regexp and the second output file will have the rest of the contents.</p><p>Consider this sample input file:</p><pre><code class="language-bash">$ cat purchases.txt
coffee
tea
washing powder
coffee
toothpaste
tea
soap
tea
</code></pre><p>Here's an example of splitting the input file using the <code>/regexp/</code> syntax:</p><pre><code class="language-bash"># match a line containing 't' followed by zero or more characters and then 'p'
# 'toothpaste' is the only match for this input file
$ csplit -q purchases.txt '/t.*p/'

$ head xx*
==&gt; xx00 &lt;==
coffee
tea
washing powder
coffee

==&gt; xx01 &lt;==
toothpaste
tea
soap
tea
</code></pre><p>When <code>%regexp%</code> is used, the lines occurring before the matching line won't be part of the output. Only the line matching the given regexp and the rest of the contents will be part of the single output file.</p><pre><code class="language-bash">$ csplit -q purchases.txt '%t.*p%'

$ cat xx00
toothpaste
tea
soap
tea
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> For more examples, customization options and other details, see the <a href="https://learnbyexample.github.io/cli_text_processing_coreutils/csplit.html">csplit chapter</a> from my <a href="https://github.com/learnbyexample/cli_text_processing_coreutils">CLI text processing with GNU Coreutils</a> ebook.</p></blockquote><h2 id="xargs"><a class="header" href="#xargs">xargs</a></h2><p>By default, <code>xargs</code> executes the <code>echo</code> command for the arguments extracted from <code>stdin</code> data (or file input via the <code>-a</code> option). The <code>-n</code> option helps to customize how many arguments should be passed at a time. Together, these features can be used to reshape whitespace separated data as shown in the examples below:</p><pre><code class="language-bash">$ printf '  apple   banana cherry\n\t\tdragon unicorn   \n'
  apple   banana cherry
                dragon unicorn   
$ printf '  apple   banana cherry\n\t\tdragon unicorn   \n' | xargs -n2
apple banana
cherry dragon
unicorn

$ cat ip.txt
deep blue
light orange
blue delight
$ xargs -a ip.txt -n3
deep blue light
orange blue delight
</code></pre><p>You can use the <code>-L</code> option to specify how many input lines should be combined at a time:</p><pre><code class="language-bash"># same as: pr -3ats' ' or paste -d' ' - - -
$ seq 9 | xargs -L3
1 2 3
4 5 6
7 8 9

$ xargs -a ip.txt -L2
deep blue light orange
blue delight

# you can also use -l instead of -L1
$ printf '  apple   banana cherry\n\t\tdragon unicorn   \n' | xargs -L1
apple banana cherry
dragon unicorn
</code></pre><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Note that <code>xargs -L1</code> is not the same as <code>awk '{$1=$1} 1'</code> since <code>xargs</code> will discard blank lines. Also, trailing blank characters will cause the next line to be considered as part of the current line. For example:</p><pre><code class="language-bash"># no trailing blanks
$ printf 'xerox apple\nregex   go  sea\n' | xargs -L1
xerox apple
regex go sea

# with trailing blanks
$ printf 'xerox apple  \nregex   go  sea\n' | xargs -L1
xerox apple regex go sea
</code></pre></blockquote><p>You can use the <code>-d</code> option to specify a custom single character input delimiter. For example:</p><pre><code class="language-bash">$ printf '1,2,3,4,5,6' | xargs -d, -n3
1 2 3
4 5 6
</code></pre><h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2><blockquote><p><img alt="info" src="../Images/147d5d96e6e103c258c8b5f99e9505a9.png" data-original-src="https://learnbyexample.github.io/cli-computing/images/info.svg"/> Use the <a href="https://github.com/learnbyexample/cli-computing/tree/master/example_files/text_files">example_files/text_files</a> directory for input files used in the following exercises.</p></blockquote><p><strong>1)</strong> Generate the following sequence.</p><pre><code class="language-bash"># ???
100
95
90
85
80
</code></pre><p><strong>2)</strong> Is the sequence shown below possible to generate with <code>seq</code>? If so, how?</p><pre><code class="language-bash"># ???
01.5,02.5,03.5,04.5,05.5
</code></pre><p><strong>3)</strong> Display three random words from <code>/usr/share/dict/words</code> (or an equivalent dictionary word file) containing <code>s</code> and <code>e</code> and <code>t</code> in any order. The output shown below is just an example.</p><pre><code class="language-bash"># ???
supplemental
foresight
underestimates
</code></pre><p><strong>4)</strong> Briefly describe the purpose of the <code>shuf</code> command options <code>-i</code>, <code>-e</code> and <code>-r</code>.</p><p><strong>5)</strong> Why does the below command not work as expected? What other tools can you use in such cases?</p><pre><code class="language-bash"># not working as expected
$ echo 'apple,banana,cherry,dates' | cut -d, -f3,1,3
apple,cherry

# expected output
# ???
cherry,apple,cherry
</code></pre><p><strong>6)</strong> Display except the second field in the format shown below. Can you construct two different solutions?</p><pre><code class="language-bash">$ echo 'apple,banana,cherry,dates' | cut # ???
apple cherry dates

$ echo '2,3,4,5,6,7,8' | cut # ???
2 4 5 6 7 8
</code></pre><p><strong>7)</strong> Extract the first three characters from the input lines as shown below. Can you also use the <code>head</code> command for this purpose? If not, why not?</p><pre><code class="language-bash">$ printf 'apple\nbanana\ncherry\ndates\n' | cut # ???
app
ban
che
dat
</code></pre><p><strong>8)</strong> Display only the first and third columns of the <code>scores.csv</code> input file in the format as shown below. Note that only space characters are present between the two columns, not tab.</p><pre><code class="language-bash">$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

# ???
Name  Physics
Ith   100
Cy    98
Lin   83
</code></pre><p><strong>9)</strong> Display the contents of <code>table.txt</code> in the format shown below.</p><pre><code class="language-bash"># ???
brown   bread   mat     hair   42
blue    cake    mug     shirt  -7
yellow  banana  window  shoes  3.14
</code></pre><p><strong>10)</strong> Implement <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a> cipher using the <code>tr</code> command.</p><pre><code class="language-bash">$ echo 'Hello World' | tr # ???
Uryyb Jbeyq

$ echo 'Uryyb Jbeyq' | tr # ???
Hello World
</code></pre><p><strong>11)</strong> Retain only alphabets, digits and whitespace characters.</p><pre><code class="language-bash">$ echo 'Apple_42 cool,blue Dragon:army' | # ???
Apple42 coolblue Dragonarmy
</code></pre><p><strong>12)</strong> Use <code>tr</code> to get the output shown below.</p><pre><code class="language-bash">$ echo '!!hhoowwww !!aaaaaareeeeee!! yyouuuu!!' | tr # ???
how are you
</code></pre><p><strong>13)</strong> <code>paste -s</code> works separately for multiple input files. How would you workaround this if you needed to treat all the input files as a single source?</p><pre><code class="language-bash"># this works individually for each input file
$ paste -sd, fruits.txt ip.txt
banana,papaya,mango
deep blue,light orange,blue delight

# expected output
# ???
banana,papaya,mango,deep blue,light orange,blue delight
</code></pre><p><strong>14)</strong> Use appropriate options to get the expected output shown below.</p><pre><code class="language-bash"># default output
$ paste fruits.txt ip.txt
banana  deep blue
papaya  light orange
mango   blue delight

# expected output
$ paste # ???
banana
deep blue
papaya
light orange
mango
blue delight
</code></pre><p><strong>15)</strong> Use the <code>pr</code> command to get the expected output shown below.</p><pre><code class="language-bash">$ seq -w 16 | pr # ???
01,02,03,04
05,06,07,08
09,10,11,12
13,14,15,16

$ seq -w 16 | pr # ???
01,05,09,13
02,06,10,14
03,07,11,15
04,08,12,16
</code></pre><p><strong>16)</strong> Use the <code>pr</code> command to join the input files <code>fruits.txt</code> and <code>ip.txt</code> as shown below.</p><pre><code class="language-bash"># ???
banana : deep blue
papaya : light orange
mango : blue delight
</code></pre><p><strong>17)</strong> The <code>cut</code> command doesn't support a way to choose the last <code>N</code> fields. Which tool presented in this chapter can be combined to work with <code>cut</code> to get the output shown below?</p><pre><code class="language-bash"># last two characters from each line
$ printf 'apple\nbanana\ncherry\ndates\n' | # ???
le
na
ry
es
</code></pre><p><strong>18)</strong> Go through the <code>split</code> documentation and use appropriate options to get the output shown below for the input file <code>purchases.txt</code>.</p><pre><code class="language-bash"># split input by 3 lines (max) at a time
# ???

$ head xa?
==&gt; xaa &lt;==
coffee
tea
washing powder

==&gt; xab &lt;==
coffee
toothpaste
tea

==&gt; xac &lt;==
soap
tea

$ rm xa?
</code></pre><p><strong>19)</strong> Go through the <code>split</code> documentation and use appropriate options to get the output shown below.</p><pre><code class="language-bash">$ echo 'apple,banana,cherry,dates' | split # ???

$ head xa?
==&gt; xaa &lt;==
apple,
==&gt; xab &lt;==
banana,
==&gt; xac &lt;==
cherry,
==&gt; xad &lt;==
dates

$ rm xa?
</code></pre><p><strong>20)</strong> Split the input file <code>purchases.txt</code> such that the text before a line containing <code>powder</code> is part of the first file and the rest are part of the second file as shown below.</p><pre><code class="language-bash"># ???

$ head xx0?
==&gt; xx00 &lt;==
coffee
tea

==&gt; xx01 &lt;==
washing powder
coffee
toothpaste
tea
soap
tea

$ rm xx0?
</code></pre><p><strong>21)</strong> Write a generic solution that transposes comma delimited data. Example input/output is shown below. You can use any tool(s) presented in this book.</p><pre><code class="language-bash">$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

# ???
Name,Ith,Cy,Lin
Maths,100,97,78
Physics,100,98,83
Chemistry,100,95,80
</code></pre><p><strong>22)</strong> Reshape the contents of <code>table.txt</code> to the expected output shown below.</p><pre><code class="language-bash">$ cat table.txt
brown bread mat hair 42
blue cake mug shirt -7
yellow banana window shoes 3.14

# ???
brown   bread  mat     hair
42      blue   cake    mug
shirt   -7     yellow  banana
window  shoes  3.14
</code></pre>    
</body>
</html>