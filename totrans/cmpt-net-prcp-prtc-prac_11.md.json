["```sh\ndef  initialize_BGP_session(remoteAS, remoteIP):\n    # Initialize and start BGP session\n    # Send BGP OPEN Message to RemoteIP on port 179\n    # Follow BGP state machine\n    # Advertise local routes and routes learned from peers\n    for d in BGPLocRIB:\n        msg = build_BGP_update(d)\n        msg_to_send = apply_export_filter(remoteAS, msg)\n        if msg_to_send is not None:\n            send_update(msg_to_send, remoteAS, remoteIP)\n    # Entire RIB has now been sent. New updates will be sent\n    # to reflect local or distant changes in routers. \n```", "```sh\ndef  apply_export_filter(remoteAS, bgpMsg):\n    # Check if RemoteAS already received route\n    if remoteAS in bgpMsg.ASPath:\n        bgpMsg = None\n        # Many additional export policies can be configured:\n        # accept or refuse the bgpMsg, modify selected attributes\n        # inside bgpMsg, ...\n    return bgpMsg \n```", "```sh\ndef  bgp_message_received(msg, remoteAS):\n    filtered_msg = apply_import_filter(msg, remoteAS)\n    if filtered_msg is None: # msg is not acceptable\n        return\n\n    if is_update(msg):\n        old_route = best_route(msg.prefix)\n        insert_in_RIB(msg)\n        run_decision_process(RIB)\n        if best_route(msg.prefix) != old_route:\n            # Best route changed\n            out_msg = build_BGP_message(msg.prefix)\n            to_send = apply_export_filter(remoteAS, out_msg)\n            if to_send is not None:\n                # Announce best route\n                send_update(to_send, remoteAS, remoteIP)\n            elif old_route is not None:\n                # Withdraw the route\n                send_withdraw(msg.prefix, remoteAS, remoteIP)\n\n    else:  # msg is WITHDRAW\n        old_route = best_route(msg.prefix)\n        remove_from_rib(msg)\n        run_decision_process(RIB)\n        if best_route(msg.prefix) != old_route:\n            # Best route changed\n            out_msg = build_BGP_message(msg.prefix)\n            to_send = apply_export_filter(remoteAS, out_msg)\n            if to_send is not None:\n                # There is still one best route\n                # towards msg.prefix\n                send_update(to_send, remoteAS, remoteIP)\n            elif old_route is not None:\n                # No best route anymore\n                send_withdraw(msg.prefix, remoteAS, remoteIP) \n```", "```sh\ndef  apply_import_filter(remoteAS, bgpMsg):\n    if my_AS in bgpMsg.ASPath:\n        bgpMsg = None\n        # Many additional import policies can be configured:\n        # accept or refuse the bgpMsg, modify selected\n        # attributes inside bgpMsg,...\n    return bgpMsg \n```", "```sh\nimport: from  AS2 RA at R1 set localpref=100;\n        from  AS2 RB at R1 set localpref=200;\n        accept ANY \n```", "```sh\nimport: from  AS1 R1 at RA set localpref=100;\n        from  AS1 R1 at RB set localpref=200;\n        accept AS1 \n```", "```sh\nimport: from  AS2 RA at R1 set localpref=100;\n        from  AS4 R2 at R1 set localpref=200;\n        accept ANY \n```", "```sh\ndef  initialize_BGP_session(remoteAS, remoteIP):\n    # Initialize and start BGP session\n    # Send BGP OPEN Message to RemoteIP on port 179\n    # Follow BGP state machine\n    # Advertise local routes and routes learned from peers\n    for d in BGPLocRIB:\n        msg = build_BGP_update(d)\n        msg_to_send = apply_export_filter(remoteAS, msg)\n        if msg_to_send is not None:\n            send_update(msg_to_send, remoteAS, remoteIP)\n    # Entire RIB has now been sent. New updates will be sent\n    # to reflect local or distant changes in routers. \n```", "```sh\ndef  apply_export_filter(remoteAS, bgpMsg):\n    # Check if RemoteAS already received route\n    if remoteAS in bgpMsg.ASPath:\n        bgpMsg = None\n        # Many additional export policies can be configured:\n        # accept or refuse the bgpMsg, modify selected attributes\n        # inside bgpMsg, ...\n    return bgpMsg \n```", "```sh\ndef  bgp_message_received(msg, remoteAS):\n    filtered_msg = apply_import_filter(msg, remoteAS)\n    if filtered_msg is None: # msg is not acceptable\n        return\n\n    if is_update(msg):\n        old_route = best_route(msg.prefix)\n        insert_in_RIB(msg)\n        run_decision_process(RIB)\n        if best_route(msg.prefix) != old_route:\n            # Best route changed\n            out_msg = build_BGP_message(msg.prefix)\n            to_send = apply_export_filter(remoteAS, out_msg)\n            if to_send is not None:\n                # Announce best route\n                send_update(to_send, remoteAS, remoteIP)\n            elif old_route is not None:\n                # Withdraw the route\n                send_withdraw(msg.prefix, remoteAS, remoteIP)\n\n    else:  # msg is WITHDRAW\n        old_route = best_route(msg.prefix)\n        remove_from_rib(msg)\n        run_decision_process(RIB)\n        if best_route(msg.prefix) != old_route:\n            # Best route changed\n            out_msg = build_BGP_message(msg.prefix)\n            to_send = apply_export_filter(remoteAS, out_msg)\n            if to_send is not None:\n                # There is still one best route\n                # towards msg.prefix\n                send_update(to_send, remoteAS, remoteIP)\n            elif old_route is not None:\n                # No best route anymore\n                send_withdraw(msg.prefix, remoteAS, remoteIP) \n```", "```sh\ndef  apply_import_filter(remoteAS, bgpMsg):\n    if my_AS in bgpMsg.ASPath:\n        bgpMsg = None\n        # Many additional import policies can be configured:\n        # accept or refuse the bgpMsg, modify selected\n        # attributes inside bgpMsg,...\n    return bgpMsg \n```", "```sh\nimport: from  AS2 RA at R1 set localpref=100;\n        from  AS2 RB at R1 set localpref=200;\n        accept ANY \n```", "```sh\nimport: from  AS1 R1 at RA set localpref=100;\n        from  AS1 R1 at RB set localpref=200;\n        accept AS1 \n```", "```sh\nimport: from  AS2 RA at R1 set localpref=100;\n        from  AS4 R2 at R1 set localpref=200;\n        accept ANY \n```", "```sh\nimport: from  AS2 RA at R1 set localpref=100;\n        from  AS2 RB at R1 set localpref=200;\n        accept ANY \n```", "```sh\nimport: from  AS1 R1 at RA set localpref=100;\n        from  AS1 R1 at RB set localpref=200;\n        accept AS1 \n```", "```sh\nimport: from  AS2 RA at R1 set localpref=100;\n        from  AS4 R2 at R1 set localpref=200;\n        accept ANY \n```"]