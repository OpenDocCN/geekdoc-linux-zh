- en: ATM Machine System Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://techbyexample.com/atm-machine-system-design/](https://techbyexample.com/atm-machine-system-design/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Table of Contents
  prefs: []
  type: TYPE_NORMAL
- en: '[Overview](#Overview "Overview")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UML Diagram](#UML_Diagram "UML Diagram")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Low–Level Design](#Low%E2%80%93Level_Design "Low–Level Design")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Program](#Program "Program")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusion](#Conclusion "Conclusion")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The objective is to design an ATM machine. Please note that designing an ATM
    Machine is an Object-Oriented Problem. It is not a distributed system problem.
    So we need to approach it that way. Below are the requirements
  prefs: []
  type: TYPE_NORMAL
- en: An ATM machine will allow the admin or bank to add the money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ATM machine will allow users to enter the amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the amount is entered the user can enter the pin. The cash will be dispensed
    after the pin is entered and is correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ATM machine will have different states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also for simplicity let’s assume that an ATM Machine can be in 4 different states
  prefs: []
  type: TYPE_NORMAL
- en: '**noMoney –** This is the initial state when ATM has no money and hence it
    cannot accept the withdrawal of money.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hasMoney –** This is the next state when ATM is ready to accept the withdrawal
    of money.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**amountEntered –** This is the state after which the amount is entered by
    the user. At this state, it will allow the user to enter the amount'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pinEntered –** This is the state when the user has entered the pin. If the
    pin is correct then the cash will be dispensed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An ATM machine will also have different actions. Again for simplicity lets
    assume that there are only four actions:**'
  prefs: []
  type: TYPE_NORMAL
- en: '***   **Add money**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter amount**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enter Pin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispense Cash**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a state design pattern here to design the ATM machine. State design
    pattern is a behavioral design pattern that is based on a Finite State Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Now the question is why we are using a State Design Pattern to design an ATM
    Machine? Below are two reasons
  prefs: []
  type: TYPE_NORMAL
- en: State design pattern is used when an object can be in many different states. Depending
    upon the current request the object needs to change its current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATM machines can be in many different states. An ATM Machine will move from
    one state to another. Let’s say ATM Machine is in **amountEntered** then it will
    move to **pinEntered** state once the action **“Enter Pin”** is done
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State design pattern is used when an object will have different responses to
    the same request depending upon the current state. Using state design pattern
    here will prevent a lot of conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example in the case of an ATM Machine, if a user wants to dispense cash
    then the machine will proceed if it is in **hasMoney** or it will reject if it
    is in **noMoney**. If you notice here that the ATM Machine on the request of withdrawal
    gives two different responses depending upon whether it is in **hasMoney** or **noMoney.**
    With this approach, our code will not have any kind of conditional statement.
    All the logic is being handled by concrete state implementations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UML Diagram**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is the UML diagram of the ATM Machine
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/abc27bbd3d788680b834477c96729157.png)'
  prefs: []
  type: TYPE_IMG
- en: Here is the overall idea
  prefs: []
  type: TYPE_NORMAL
- en: We will have an interface “State” which defines signatures of functions that
    represents action in the context of an ATM Machine. Below are the actions function
    signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stateName() string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: addMoney(int) error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: enterAmount(int) error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: enterPin(money int) error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: dispenseCash() error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of the concrete states implements all 5 above functions and either move
    to another state on these actions or gives some response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the concrete states also embeds a pointer to the current ATM Machine
    object so that state transition can invoke some calls on the ATM Machine Object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low**–**Level Design**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is the low-level design expressed in the Go programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Later we will see a working example as well
  prefs: []
  type: TYPE_NORMAL
- en: '**ATM Machine Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**State Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**NoMoney State Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Has Money State Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Amount Entered State Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Pin Entered State Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Program**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the full working code if anyone is interested in the Go programming
    language
  prefs: []
  type: TYPE_NORMAL
- en: '**atmMachine.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**state.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**noMoneyState.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**hasMoneyState.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**amountEnteredState.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**pinEnteredState.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**main.go**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Conclusion**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is all about designing an ATM Machine. Hope you have liked this article.
    Please share feedback in the comments
  prefs: []
  type: TYPE_NORMAL
- en: '[atm](https://techbyexample.com/tag/atm/)*   [system](https://techbyexample.com/tag/system/)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
