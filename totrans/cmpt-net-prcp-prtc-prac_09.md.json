["```sh\nEvery N seconds:\n    v = Vector()\n    for d in R[]:\n        # add destination d to vector\n        v.add(Pair(d, R[d].cost))\n    for i in interfaces\n        # send vector v on this interface\n        send(v, i) \n```", "```sh\n# V : received Vector\n# l : link over which vector is received\ndef  received(V, l):\n    # received vector from link l\n    for d in V[]\n        if not (d in R[]):\n            # new route\n            R[d].cost = V[d].cost + l.cost\n            R[d].link = l\n            R[d].time = now\n        else:\n            # existing route, is the new better ?\n            if ((V[d].cost + l.cost) < R[d].cost) or (R[d].link == l):\n                # Better route or change to current route\n                R[d].cost = V[d].cost + l.cost\n                R[d].link = l\n                R[d].time = now \n```", "```sh\nPlease log in to see this exercise\n```", "```sh\n# split horizon\nEvery N seconds:\n    # one vector for each interface\n    for l in interfaces:\n        v = Vector()\n        for d in R[]:\n            if (R[d].link != l):\n                v = v + Pair(d, R[d].cost)\n        send(v, l)\n        # end for d in R[]\n    # end for l in interfaces \n```", "```sh\n# split horizon with poison reverse\nEvery N seconds:\n    for l in interfaces:\n        # one vector for each interface\n        v = Vector()\n        for d in R[]:\n            if (R[d].link != l):\n                v = v + Pair(d, R[d].cost)\n            else:\n                v = v + Pair(d, infinity)\n        send(v, l)\n        # end for d in R[]\n    # end for l in interfaces \n```", "```sh\nPlease log in to see this exercise\n```", "```sh\n# links is the set of all links on the router\n# Router R's LSP arrival on link l\nif newer(LSP, LSDB(LSP.Router)) :\n    LSDB.add(LSP)  # implicitly removes older LSP from same router\n    for i in links:\n        if i!=l:\n           send(LSP,i)\n# else, LSP has already been flooded \n```", "```sh\ndef  newer( lsp1, lsp2 ):\n    return ( ((lsp1.seq > lsp2.seq) and ((lsp1.seq - lsp2.seq) <= 32)) or\n           ( (lsp1.seq < lsp2.seq) and ((lsp2.seq - lsp1.seq) > 32)) ) \n```", "```sh\nPlease log in to see this exercise\n```", "```sh\nEvery N seconds:\n    v = Vector()\n    for d in R[]:\n        # add destination d to vector\n        v.add(Pair(d, R[d].cost))\n    for i in interfaces\n        # send vector v on this interface\n        send(v, i) \n```", "```sh\n# V : received Vector\n# l : link over which vector is received\ndef  received(V, l):\n    # received vector from link l\n    for d in V[]\n        if not (d in R[]):\n            # new route\n            R[d].cost = V[d].cost + l.cost\n            R[d].link = l\n            R[d].time = now\n        else:\n            # existing route, is the new better ?\n            if ((V[d].cost + l.cost) < R[d].cost) or (R[d].link == l):\n                # Better route or change to current route\n                R[d].cost = V[d].cost + l.cost\n                R[d].link = l\n                R[d].time = now \n```", "```sh\nPlease log in to see this exercise\n```", "```sh\n# split horizon\nEvery N seconds:\n    # one vector for each interface\n    for l in interfaces:\n        v = Vector()\n        for d in R[]:\n            if (R[d].link != l):\n                v = v + Pair(d, R[d].cost)\n        send(v, l)\n        # end for d in R[]\n    # end for l in interfaces \n```", "```sh\n# split horizon with poison reverse\nEvery N seconds:\n    for l in interfaces:\n        # one vector for each interface\n        v = Vector()\n        for d in R[]:\n            if (R[d].link != l):\n                v = v + Pair(d, R[d].cost)\n            else:\n                v = v + Pair(d, infinity)\n        send(v, l)\n        # end for d in R[]\n    # end for l in interfaces \n```", "```sh\nPlease log in to see this exercise\n```", "```sh\n# links is the set of all links on the router\n# Router R's LSP arrival on link l\nif newer(LSP, LSDB(LSP.Router)) :\n    LSDB.add(LSP)  # implicitly removes older LSP from same router\n    for i in links:\n        if i!=l:\n           send(LSP,i)\n# else, LSP has already been flooded \n```", "```sh\ndef  newer( lsp1, lsp2 ):\n    return ( ((lsp1.seq > lsp2.seq) and ((lsp1.seq - lsp2.seq) <= 32)) or\n           ( (lsp1.seq < lsp2.seq) and ((lsp2.seq - lsp1.seq) > 32)) ) \n```", "```sh\nPlease log in to see this exercise\n```"]